---
title: "dubbo-go Trusted Call Implementation"
linkTitle: "dubbo-go Trusted Call Implementation"
tags: ["Go"]
date: 2021-01-14
description: >
  This article will explain how to implement a flexible, secure, and efficient authentication and authorization scheme in Dubbo/Dubbo-Go.
---

Apache Dubbo/Dubbo-Go, as an open-source service governance framework by Alibaba, is widely used in China due to its advantages such as adaptability to Java/Go developers' interface-oriented programming habits, fully transparent calling methods, excellent performance, and strong extensibility. Additionally, the open-source version of Dubbo natively integrates many ready-to-use service governance features, including link tracing, routing, load balancing, service registration and discovery, monitoring, and authentication.

This article will explain how to implement a flexible, secure, and efficient authentication and authorization scheme in Dubbo/Dubbo-Go.

## Trusted Purpose

Why is authentication necessary? In actual production, security-sensitive businesses like payments have restrictions on anonymous system calls. Other businesses need to pass approval before normally accessing such sensitive services, which requires permission control. Although the open-source version of Dubbo supports token-based authentication, this implementation is generally not very secure and cannot meet our need for dynamic issuance and changes.

To address this, we redesigned a set of authentication and authorization features for service calls in Dubbo/Dubbo-Go, focusing on enhancing security and flexibility. This article will mainly explain the general implementation ideas from an implementation perspective.

## Trusted Scheme

From an abstract perspective, authentication and authorization revolve around the following two questions:

- Identity Authentication: Validates the identity of the application, with each application having a unique identity throughout its lifecycle that cannot be changed or forged.
- Permission Verification: Determines whether permissions meet calling requirements based on identity information. Permissions can be controlled at a granular level.

We identify the identity relationships between applications using Access Key ID/Secret Access Key (referred to as AK/SK). For example, if upstream Application A relies on downstream Services B and C, then A will have a separate set of AK/SK for B and C. They are mutually independent and have no relationship. Even if A's AK/SK is leaked, it cannot be used to call other services.

In terms of permission verification, we also borrowed the commonly used AK/SK signing mechanism from public cloud open APIs. During the request process, the SK is used to generate a SigningKey, and additional metadata information and SigningKey are transmitted to the server through Dubbo's attachment mechanism for computation and signature verification.

The signing process mainly reinforces the reliability and security of the SigningKey through the following three methods:

- Verifying the requestor's identity
  
  The signature is generated by encrypting the request metadata (and parameters) using the corresponding application's SK as the encryption key, ensuring the uniqueness and non-forgeability of the signature.
- Supporting parameter calculation signing to prevent illegal tampering
  
  If request parameters are tampered during transmission, the server's signature verification will fail, and identity verification will not pass, preventing parameter tampering. This process is optional to avoid performance impacts during the signing and verification process.
- Preventing replay attacks
  
  Each SigningKey generated for a request has a specified valid time. If the request is intercepted, that request cannot be called outside the valid time, to some extent avoiding replay attacks.

Additionally, to eliminate plaintext configuration and prevent AK/SK information leakage, we distribute and manage all AK/SK information through the authentication system. By integrating with internal approval processes, we standardize the process. Applications needing authentication will pull the currently authorized AK/SK information through a startup retrieval mechanism. This approach also brings another benefit: adding, revoking, or updating permissions without needing to restart applications.

## Trusted Process

Combining the above requirements and schemes, the entire access and authentication process diagram is as follows:

![img](/imgs/blog/dubbo-go/trusted-call/process.png)

The overall process is as follows:

1. Applications using this feature need to apply for the corresponding certificate in advance and submit access requests to the service-providing application. After approval from both sides, the authentication service center automatically generates key-value pairs.
2. Additionally, services with authentication enabled will run a background thread after application startup to long-poll the authentication service center to check for new permission changes and pull them as needed.
3. The upstream application, when requesting authentication-required services, will use the SK as the signing algorithm key, calculate the signature for this request's metadata and even parameter information, and send it to the other end via the Dubbo protocol Attachment field, along with request timestamps, AK information, etc.
4. The downstream application will verify the signature upon handling the authentication service; if verification passes, it continues processing the request, otherwise, it returns an error.

It is important to note that the interaction between applications using the authentication service and the authentication service center must use HTTPS with mutual authentication and exchange data over a TLS channel to ensure the secure transmission of AK/SK information.

This scheme has been implemented in both Java and Go, and it has been merged into dubbo/dubbo-go. In addition to the default Hmac signing algorithm, we abstract the signing and authentication methods, taking the implementation in Dubbo Go as an example.

```go
// Authenticator
type Authenticator interface {

    // Sign
    // give a sign to request
    Sign(protocol.Invocation, *common.URL) error

    // Authenticate
    // verify the signature of the request is valid or not
    Authenticate(protocol.Invocation, *common.URL) error
}
```

Users can customize signing and authentication methods using the SPI mechanism and adapt the key service to distribute AK/SK in their internal infrastructure.

## Example

Taking the code in the [Helloworld example](https://github.com/apache/dubbo-go-samples/tree/f7febed9d686cb940ea55d34b5baa567d7574a44/helloworld/) as an example to access the current community version's default authentication implementation:

Without changing the code, you only need to add extra related authentication configurations to the settings; here is an example of the dubbo-go server configuration:

```yaml
services:
  "UserProvider":
    registry: "hangzhouzk"
    protocol : "dubbo"
    interface : "com.ikurento.user.UserProvider"
    loadbalance: "random"
    auth: "true"  
    filter: "auth"
    params:
      .accessKeyId: "SYD8-23DF"
      .secretAccessKey: "BSDY-FDF1"
    warmup: "100"
    cluster: "failover"
    methods:
      - name: "GetUser"
        retries: 1
        loadbalance: "random"
```

The dubbo-go client configuration example is as follows:

```yaml
references:
  "UserProvider":
    registry: "hangzhouzk"
    protocol: "dubbo"
    interface: "com.ikurento.user.UserProvider"
    cluster: "failover"
    filter: "sign"
    params:
      .accessKeyId: "SYD8-23DF"
      .secretAccessKey: "BSDY-FDF1"
    methods:
      - name: "GetUser"
        retries: 3
```

As can be seen, accessing the authentication feature in dubbo-go is quite simple. It should be noted that the configuration file fields for ak/sk have a special prefix ".", indicating that these fields contain sensitive information and should not be transmitted during network requests. Relevant code can refer to [dubbo-go-pr-509](https://github.com/apache/dubbo-go/pull/509).

## Conclusion

As an old yet evolving service governance framework, Apache Dubbo continues to evolve, both in its own features and its ecosystem. The latest trusted service call implementation described in this article provides additional assurance against anonymous user access to sensitive interfaces at the SDK level, ensuring security at the RPC level.

Dubbo-Go, as the fastest-growing member of the Dubbo ecosystem, has basically been keeping pace with Dubbo. The Dubbo-Go community DingTalk group number is 23331795, and you are welcome to join.

> Author Information: Zheng Zechao, Apache Dubbo/Dubbo-Go committer, Github ID: CodingSinger, currently employed at iQIYI Technology Co., Ltd. in Shanghai, as a Java/Golang developer.

