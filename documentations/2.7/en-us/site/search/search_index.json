{"config":{"lang":["en"],"min_search_length":2,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":"Dubbo Overview Apache Dubbo is a high-performance, open source RPC framework. Dubbo 3.0 , the Cloud Native version of Dubbo, is under development. If you have any ideas or suggestions on Dubbo 3.0, please join us on Github. Basic Architecture Features Transparent interface based RPC Intelligent load balancing Automatic service registration and discovery High extensibility Runtime traffic routing Visualized service governance","title":"Dubbo Overview"},{"location":"#dubbo-overview","text":"Apache Dubbo is a high-performance, open source RPC framework. Dubbo 3.0 , the Cloud Native version of Dubbo, is under development. If you have any ideas or suggestions on Dubbo 3.0, please join us on Github.","title":"Dubbo Overview"},{"location":"#basic-architecture","text":"","title":"Basic Architecture"},{"location":"#features","text":"Transparent interface based RPC Intelligent load balancing Automatic service registration and discovery High extensibility Runtime traffic routing Visualized service governance","title":"Features"},{"location":"admin/","text":"This document explains the structure, deploy procedure and function of Dubbo Admin","title":"Home"},{"location":"admin/SUMMARY/","text":"1 Dubbo Admin introduction 1.1 service search and detail 1.2 service governance 1.3 service test","title":"SUMMARY"},{"location":"admin/introduction/","text":"Dubbo Admin introduction Now version 0.1 has been released, frontend uses Vue and Vuetify as javascript framework and UI framework, backend uses spring framework, you can deploy the whole project with maven or deploy frontend and backend separately. Deploy the whole project through maven install git clone https://github.com/apache/dubbo-admin.git cd dubbo-admin mvn clean package cd dubbo-admin-distribution/target java -jar dubbo-admin-0.1.jar visit http://localhost:8080 Deploy frontend and backend separately frontend deploy cd dubbo-admin-ui npm install npm run dev backend deploy cd dubbo-admin-server mvn clean package cd target java -jar dubbo-admin-server-0.1.jar visit http://localhost:8081 in this mode, any modify of frontend will be hot reloaded configuration: [^1] configuration file location dubbo-admin-server/src/main/resources/application.properties configuration: admin.config-center=zookeeper://127.0.0.1:2181 admin.registry.address=zookeeper://127.0.0.1:2181 admin.metadata-report.address=zookeeper://127.0.0.1:2181 the three configure item above are configuration center, registry center and metadata center respectively, you can find explanation about the three centers here Same as Dubbo 2.7, you can set the addresses of metadata center and registry center on configuration center, in zookeeper, the path and content are as below: # /dubbo/config/dubbo/dubbo.properties dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 the addresses in configuration center have higher priority than those in application.properties visit documents on github: https://github.com/apache/dubbo-admin [^1]: there's no login module in the current version.","title":"Dubbo Admin Overview"},{"location":"admin/introduction/#dubbo-admin-introduction","text":"Now version 0.1 has been released, frontend uses Vue and Vuetify as javascript framework and UI framework, backend uses spring framework, you can deploy the whole project with maven or deploy frontend and backend separately.","title":"Dubbo Admin introduction"},{"location":"admin/introduction/#deploy-the-whole-project-through-maven","text":"install git clone https://github.com/apache/dubbo-admin.git cd dubbo-admin mvn clean package cd dubbo-admin-distribution/target java -jar dubbo-admin-0.1.jar visit http://localhost:8080","title":"Deploy the whole project through maven"},{"location":"admin/introduction/#deploy-frontend-and-backend-separately","text":"frontend deploy cd dubbo-admin-ui npm install npm run dev backend deploy cd dubbo-admin-server mvn clean package cd target java -jar dubbo-admin-server-0.1.jar visit http://localhost:8081 in this mode, any modify of frontend will be hot reloaded","title":"Deploy frontend and backend separately"},{"location":"admin/introduction/#configuration-1","text":"configuration file location dubbo-admin-server/src/main/resources/application.properties configuration: admin.config-center=zookeeper://127.0.0.1:2181 admin.registry.address=zookeeper://127.0.0.1:2181 admin.metadata-report.address=zookeeper://127.0.0.1:2181 the three configure item above are configuration center, registry center and metadata center respectively, you can find explanation about the three centers here Same as Dubbo 2.7, you can set the addresses of metadata center and registry center on configuration center, in zookeeper, the path and content are as below: # /dubbo/config/dubbo/dubbo.properties dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 the addresses in configuration center have higher priority than those in application.properties visit documents on github: https://github.com/apache/dubbo-admin [^1]: there's no login module in the current version.","title":"configuration: [^1]"},{"location":"admin/serviceGovernance/","text":"Service governance and configuration management Service governance \u670d\u52a1\u6cbb\u7406\u4e3b\u8981\u4f5c\u7528\u662f\u6539\u53d8\u8fd0\u884c\u65f6\u670d\u52a1\u7684\u884c\u4e3a\u548c\u9009\u5740\u903b\u8f91\uff0c\u8fbe\u5230\u9650\u6d41\uff0c\u6743\u91cd\u914d\u7f6e\u7b49\u76ee\u7684\uff0c\u4e3b\u8981\u6709\u4ee5\u4e0b\u51e0\u4e2a\u529f\u80fd\uff1a the basic function of service governance is changing the runtime behaviour and routing logic, to do weight configuration and current limiting: \u5e94\u7528\u7ea7\u522b\u7684\u670d\u52a1\u6cbb\u7406 application level service governance \u5728Dubbo2.6\u53ca\u66f4\u65e9\u7248\u672c\u4e2d\uff0c\u6240\u6709\u7684\u670d\u52a1\u6cbb\u7406\u89c4\u5219\u90fd\u53ea\u9488\u5bf9\u670d\u52a1\u7c92\u5ea6\uff0c\u5982\u679c\u8981\u628a\u67d0\u6761\u89c4\u5219\u4f5c\u7528\u5230\u5e94\u7528\u7c92\u5ea6\u4e0a\uff0c\u9700\u8981\u4e3a\u5e94\u7528\u4e0b\u7684\u6240\u6709\u670d\u52a1\u914d\u5408\u76f8\u540c\u7684\u89c4\u5219\uff0c\u53d8\u66f4\uff0c\u5220\u9664\u7684\u65f6\u5019\u4e5f\u9700\u8981\u5bf9\u5e94\u7684\u64cd\u4f5c\uff0c\u8fd9\u6837\u7684\u64cd\u4f5c\u5f88\u4e0d\u53cb\u597d\uff0c\u56e0\u6b64Dubbo2.7\u7248\u672c\u4e2d\u589e\u52a0\u4e86\u5e94\u7528\u7c92\u5ea6\u7684\u670d\u52a1\u6cbb\u7406\u64cd\u4f5c\uff0c\u5bf9\u4e8e\u6761\u4ef6\u8def\u7531(\u5305\u62ec\u9ed1\u767d\u540d\u5355)\uff0c\u52a8\u6001\u914d\u7f6e(\u5305\u62ec\u6743\u91cd\uff0c\u8d1f\u8f7d\u5747\u8861)\u90fd\u53ef\u4ee5\u505a\u5e94\u7528\u7ea7\u522b\u7684\u914d\u7f6e\uff1a In Dubbo 2.6 or earlier version, all service governance rule are in service scope, if you need to make application scope rule, you need to set the same rule for all services under an application, modify and delete need the same operation, this is very unfriendly. In Dubbo 2.7, application scope service governance is supported, condition route(including black white list) and dynamic configuration(including weight, load balance) all support application scope config. picture above is condition route configuration, can create and search by both application name and service name. tag route \u6807\u7b7e\u8def\u7531\u662fDubbo2.7\u5f15\u5165\u7684\u65b0\u529f\u80fd\uff0c\u914d\u7f6e\u4ee5\u5e94\u7528\u4f5c\u4e3a\u7ef4\u5ea6\uff0c\u7ed9\u4e0d\u540c\u7684\u670d\u52a1\u5668\u6253\u4e0a\u4e0d\u540c\u540d\u5b57\u7684\u6807\u7b7e\uff0c\u914d\u7f6e\u5982\u4e0b\u56fe\u6240\u793a\uff1a tag route is a new feature in Dubbo2.7, in application scope, to set different tag on different server, the screenshot is shown as below: the client can use setAttachment to specify different tag, is the above case, setAttachment(tag1) , the client will choose from the three servers in the picture above. In this way, you can implement features such as traffic isolation and gray release. condition route condition route is a traditional function in Dubbo, now you can create it in either service scope or application scope. Condition route is in yaml format, you can read here to find more. black white list black white list is a part of condition route and store with condition route together, you can set black list or white list, in either service scope or application scope: dynamic configuration dynamic configuration has the same level with routing rule, it can change the RPC behaviour dynamically without restart service. It supports application scope since Dubbo 2,7, in Dubbo format, the screen shot shows in below: to read more, please refer here weight adjust weigth adjuest is part of dynamic configuration, change the weight of server side to do traffic control dynamically: load balancing load balancing is also poart of dynamic configuration, to specify the route strategy in client side. now we have three strategies: random, least active and round robin, to read more, please refer here configuration management configuration management is also a new feaature for Dubbo 2.7. In Dubbo 2.7, we can specify configurations in global scope and application scope(including services in application), you can view, modify and create new configurations in Dubbo Admin. * global configuration: you can set registry center, metadata center, timeout for provider and consumer in global configurations. If the implementation of registry center and metadata center is zookeeper, you can also check the location of configuration file. * application and service scope configuration: application configuration can also set service configuration in this application. you need to specify consumer and provider in service scope: dubbo.reference.{serviceName} stands for configuration as consumer side\uff0c dubbo.provider.{servcieName} stands for configuration as provider side. the address of registry address and metadata center address can only be configured in global configuration, which is also the recommendation way in Dubbo 2.7 * priority service configuration application configuration global configuration","title":"Governance"},{"location":"admin/serviceGovernance/#service-governance-and-configuration-management","text":"","title":"Service governance and configuration management"},{"location":"admin/serviceGovernance/#service-governance","text":"\u670d\u52a1\u6cbb\u7406\u4e3b\u8981\u4f5c\u7528\u662f\u6539\u53d8\u8fd0\u884c\u65f6\u670d\u52a1\u7684\u884c\u4e3a\u548c\u9009\u5740\u903b\u8f91\uff0c\u8fbe\u5230\u9650\u6d41\uff0c\u6743\u91cd\u914d\u7f6e\u7b49\u76ee\u7684\uff0c\u4e3b\u8981\u6709\u4ee5\u4e0b\u51e0\u4e2a\u529f\u80fd\uff1a the basic function of service governance is changing the runtime behaviour and routing logic, to do weight configuration and current limiting:","title":"Service governance"},{"location":"admin/serviceGovernance/#_1","text":"","title":"\u5e94\u7528\u7ea7\u522b\u7684\u670d\u52a1\u6cbb\u7406"},{"location":"admin/serviceGovernance/#application-level-service-governance","text":"\u5728Dubbo2.6\u53ca\u66f4\u65e9\u7248\u672c\u4e2d\uff0c\u6240\u6709\u7684\u670d\u52a1\u6cbb\u7406\u89c4\u5219\u90fd\u53ea\u9488\u5bf9\u670d\u52a1\u7c92\u5ea6\uff0c\u5982\u679c\u8981\u628a\u67d0\u6761\u89c4\u5219\u4f5c\u7528\u5230\u5e94\u7528\u7c92\u5ea6\u4e0a\uff0c\u9700\u8981\u4e3a\u5e94\u7528\u4e0b\u7684\u6240\u6709\u670d\u52a1\u914d\u5408\u76f8\u540c\u7684\u89c4\u5219\uff0c\u53d8\u66f4\uff0c\u5220\u9664\u7684\u65f6\u5019\u4e5f\u9700\u8981\u5bf9\u5e94\u7684\u64cd\u4f5c\uff0c\u8fd9\u6837\u7684\u64cd\u4f5c\u5f88\u4e0d\u53cb\u597d\uff0c\u56e0\u6b64Dubbo2.7\u7248\u672c\u4e2d\u589e\u52a0\u4e86\u5e94\u7528\u7c92\u5ea6\u7684\u670d\u52a1\u6cbb\u7406\u64cd\u4f5c\uff0c\u5bf9\u4e8e\u6761\u4ef6\u8def\u7531(\u5305\u62ec\u9ed1\u767d\u540d\u5355)\uff0c\u52a8\u6001\u914d\u7f6e(\u5305\u62ec\u6743\u91cd\uff0c\u8d1f\u8f7d\u5747\u8861)\u90fd\u53ef\u4ee5\u505a\u5e94\u7528\u7ea7\u522b\u7684\u914d\u7f6e\uff1a In Dubbo 2.6 or earlier version, all service governance rule are in service scope, if you need to make application scope rule, you need to set the same rule for all services under an application, modify and delete need the same operation, this is very unfriendly. In Dubbo 2.7, application scope service governance is supported, condition route(including black white list) and dynamic configuration(including weight, load balance) all support application scope config. picture above is condition route configuration, can create and search by both application name and service name.","title":"application level service governance"},{"location":"admin/serviceGovernance/#tag-route","text":"\u6807\u7b7e\u8def\u7531\u662fDubbo2.7\u5f15\u5165\u7684\u65b0\u529f\u80fd\uff0c\u914d\u7f6e\u4ee5\u5e94\u7528\u4f5c\u4e3a\u7ef4\u5ea6\uff0c\u7ed9\u4e0d\u540c\u7684\u670d\u52a1\u5668\u6253\u4e0a\u4e0d\u540c\u540d\u5b57\u7684\u6807\u7b7e\uff0c\u914d\u7f6e\u5982\u4e0b\u56fe\u6240\u793a\uff1a tag route is a new feature in Dubbo2.7, in application scope, to set different tag on different server, the screenshot is shown as below: the client can use setAttachment to specify different tag, is the above case, setAttachment(tag1) , the client will choose from the three servers in the picture above. In this way, you can implement features such as traffic isolation and gray release.","title":"tag route"},{"location":"admin/serviceGovernance/#condition-route","text":"condition route is a traditional function in Dubbo, now you can create it in either service scope or application scope. Condition route is in yaml format, you can read here to find more.","title":"condition route"},{"location":"admin/serviceGovernance/#black-white-list","text":"black white list is a part of condition route and store with condition route together, you can set black list or white list, in either service scope or application scope:","title":"black white list"},{"location":"admin/serviceGovernance/#dynamic-configuration","text":"dynamic configuration has the same level with routing rule, it can change the RPC behaviour dynamically without restart service. It supports application scope since Dubbo 2,7, in Dubbo format, the screen shot shows in below: to read more, please refer here","title":"dynamic configuration"},{"location":"admin/serviceGovernance/#weight-adjust","text":"weigth adjuest is part of dynamic configuration, change the weight of server side to do traffic control dynamically:","title":"weight adjust"},{"location":"admin/serviceGovernance/#load-balancing","text":"load balancing is also poart of dynamic configuration, to specify the route strategy in client side. now we have three strategies: random, least active and round robin, to read more, please refer here","title":"load balancing"},{"location":"admin/serviceGovernance/#configuration-management","text":"configuration management is also a new feaature for Dubbo 2.7. In Dubbo 2.7, we can specify configurations in global scope and application scope(including services in application), you can view, modify and create new configurations in Dubbo Admin. * global configuration: you can set registry center, metadata center, timeout for provider and consumer in global configurations. If the implementation of registry center and metadata center is zookeeper, you can also check the location of configuration file. * application and service scope configuration: application configuration can also set service configuration in this application. you need to specify consumer and provider in service scope: dubbo.reference.{serviceName} stands for configuration as consumer side\uff0c dubbo.provider.{servcieName} stands for configuration as provider side. the address of registry address and metadata center address can only be configured in global configuration, which is also the recommendation way in Dubbo 2.7 * priority service configuration application configuration global configuration","title":"configuration management"},{"location":"admin/serviceSearch/","text":"Service search and service detail Service search is the basic function of Dubbo OPS, you can search by service name, application name and IP address, the service name and application name support wildcard and autocomplete: the service detail page display providers, consumers, medata information is supported in Dubbo 2.7 or higher version:","title":"Search & Details"},{"location":"admin/serviceSearch/#service-search-and-service-detail","text":"Service search is the basic function of Dubbo OPS, you can search by service name, application name and IP address, the service name and application name support wildcard and autocomplete: the service detail page display providers, consumers, medata information is supported in Dubbo 2.7 or higher version:","title":"Service search and service detail"},{"location":"admin/serviceTest/","text":"please refer to this blog","title":"Testing"},{"location":"admin/install/admin-console/","text":"Install admin console The current version of dubbo admin is under development, including: route rule, dynamic configuration, access control, weight adjustment, load balance, etc. Install: git clone https://github.com/apache/dubbo-admin.git /var/tmp/dubbo-admin cd /var/tmp/dubbo-admin mvn clean package Configuration [^1]: configuration file\uff1a dubbo-admin-backend/src/main/resources/application.properties configurations\uff1a dubbo.registry.address=zookeeper://127.0.0.1:2181 Start: mvn --projects dubbo-admin-backend spring-boot:run For more information, please visit: https://github.com/apache/dubbo-admin Visit [^2]: http://127.0.0.1:8080 [^1]: There's no login for current version, will be added later","title":"Install admin console"},{"location":"admin/install/admin-console/#install-admin-console","text":"The current version of dubbo admin is under development, including: route rule, dynamic configuration, access control, weight adjustment, load balance, etc. Install: git clone https://github.com/apache/dubbo-admin.git /var/tmp/dubbo-admin cd /var/tmp/dubbo-admin mvn clean package Configuration [^1]: configuration file\uff1a dubbo-admin-backend/src/main/resources/application.properties configurations\uff1a dubbo.registry.address=zookeeper://127.0.0.1:2181 Start: mvn --projects dubbo-admin-backend spring-boot:run For more information, please visit: https://github.com/apache/dubbo-admin Visit [^2]: http://127.0.0.1:8080 [^1]: There's no login for current version, will be added later","title":"Install admin console"},{"location":"admin/install/consumer-demo/","text":"Install demo consumer Install: $ git clone https://github.com/apache/dubbo.git $ cd dubbo/dubbo-demo/dubbo-demo-xml # run org.apache.dubbo.demo.consumer.Application under dubbo-demo-xml-consumer module # please start Provider first # add -Djava.net.preferIPv4Stack=true if your IDE is Intellij Idea Configuration: # resources/spring/dubbo-consumer.xml # change dubbo:registry to the real registry center address, for example: # dubbo:registry address= zookeeper://127.0.0.1:2181 /","title":"Install demo consumer"},{"location":"admin/install/consumer-demo/#install-demo-consumer","text":"Install: $ git clone https://github.com/apache/dubbo.git $ cd dubbo/dubbo-demo/dubbo-demo-xml # run org.apache.dubbo.demo.consumer.Application under dubbo-demo-xml-consumer module # please start Provider first # add -Djava.net.preferIPv4Stack=true if your IDE is Intellij Idea Configuration: # resources/spring/dubbo-consumer.xml # change dubbo:registry to the real registry center address, for example: # dubbo:registry address= zookeeper://127.0.0.1:2181 /","title":"Install demo consumer"},{"location":"admin/install/introduction/","text":"Install manual You can run Demo Provider and Demo Consumer only, the default discovery strategy is Multicast by configuration center broadcast, do not run the two parts on the same machine, if you have to do so, set unicast=false , like multicast://224.5.6.7:1234?unicast=false , or the unicast send to consumer will be taken by provider, and the same for consumers. Only multicast has this issue You can run multiple Demo Provider and Demo consumer to verify load balance. Demo Consumer can run multi instance directly. Because of port conflict, you can either run multi Demo Providers on different machines or modify the value of dubbo.protocol.port in conf/dubbo.properties under the install directory of conf/dubbo.properties You can add Simple Monitor as a monitor center, the default discovery strategy is Multicast by configuration center broadcast, display the dependency relationship, call times and cost You can use Zookeeper instead of Multicast as the configuration center, after Zookeeper Registry installation, modify conf/dubbo.properties under the installation directory of Demo Provider, Demo Consumer and Simple Monitor, change the value of dubbo.registry.address to zookeeper://127.0.0.1:2181 ( redis://127.0.0.1:6379 for Redis Registry). the value for Simple Registry is dubbo://127.0.0.1:9090 Zookeeper configuration address is recommended [^1]: NOTICE: multicast can be neither 127.0.0.1 nor the machine's IP address, it must be a type D broadcast address, from 224.0.0.0 to 239.255.255.255","title":"Install manual"},{"location":"admin/install/introduction/#install-manual","text":"You can run Demo Provider and Demo Consumer only, the default discovery strategy is Multicast by configuration center broadcast, do not run the two parts on the same machine, if you have to do so, set unicast=false , like multicast://224.5.6.7:1234?unicast=false , or the unicast send to consumer will be taken by provider, and the same for consumers. Only multicast has this issue You can run multiple Demo Provider and Demo consumer to verify load balance. Demo Consumer can run multi instance directly. Because of port conflict, you can either run multi Demo Providers on different machines or modify the value of dubbo.protocol.port in conf/dubbo.properties under the install directory of conf/dubbo.properties You can add Simple Monitor as a monitor center, the default discovery strategy is Multicast by configuration center broadcast, display the dependency relationship, call times and cost You can use Zookeeper instead of Multicast as the configuration center, after Zookeeper Registry installation, modify conf/dubbo.properties under the installation directory of Demo Provider, Demo Consumer and Simple Monitor, change the value of dubbo.registry.address to zookeeper://127.0.0.1:2181 ( redis://127.0.0.1:6379 for Redis Registry). the value for Simple Registry is dubbo://127.0.0.1:9090 Zookeeper configuration address is recommended [^1]: NOTICE: multicast can be neither 127.0.0.1 nor the machine's IP address, it must be a type D broadcast address, from 224.0.0.0 to 239.255.255.255","title":"Install manual"},{"location":"admin/install/provider-demo/","text":"Install demo provider install: $ git clone https://github.com/apache/dubbo.git $ cd dubbo/dubbo-demo/dubbo-demo-xml # run org.apache.dubbo.demo.provider.Application under dubbo-demo-xml-provider module # add -Djava.net.preferIPv4Stack=true if your IDE is Intellij Idea configuration: # resources/spring/dubbo-provider.xml # change dubbo:registry to a real registry server address, zookeeper is recommended, for example: # dubbo:registry address= zookeeper://127.0.0.1:2181 /","title":"Install demo provider"},{"location":"admin/install/provider-demo/#install-demo-provider","text":"install: $ git clone https://github.com/apache/dubbo.git $ cd dubbo/dubbo-demo/dubbo-demo-xml # run org.apache.dubbo.demo.provider.Application under dubbo-demo-xml-provider module # add -Djava.net.preferIPv4Stack=true if your IDE is Intellij Idea configuration: # resources/spring/dubbo-provider.xml # change dubbo:registry to a real registry server address, zookeeper is recommended, for example: # dubbo:registry address= zookeeper://127.0.0.1:2181 /","title":"Install demo provider"},{"location":"admin/install/redis/","text":"install Redis register center Redis [^1] introductions, please refer to: Redis application center manual \u3002 you need an origin Redis server only, and change the value from dubbo.registry.address to redis://127.0.0.1:6379 in conf/dubbo.properties of quick start Redis configuration center cluster [^2] write multiple server in client side and read from a single server. Install: wget http://redis.googlecode.com/files/redis-2.4.8.tar.gz tar xzf redis-2.4.8.tar.gz cd redis-2.4.8 make Configuration: vi redis.conf Start: nohup ./src/redis-server redis.conf Stop: killall redis-server Command line [^3]: ./src/redis-cli hgetall /dubbo/com.foo.BarService/providers Or: telnet 127.0.0.1 6379 hgetall /dubbo/com.foo.BarService/providers [^1]: Redis is a high performance KV store server, please refer to: http://redis.io/topics/quickstart [^2]: Support for version 2.1.0 and higher [^3]: Please refer to: http://redis.io/commands","title":"install Redis register center"},{"location":"admin/install/redis/#install-redis-register-center","text":"Redis [^1] introductions, please refer to: Redis application center manual \u3002 you need an origin Redis server only, and change the value from dubbo.registry.address to redis://127.0.0.1:6379 in conf/dubbo.properties of quick start Redis configuration center cluster [^2] write multiple server in client side and read from a single server. Install: wget http://redis.googlecode.com/files/redis-2.4.8.tar.gz tar xzf redis-2.4.8.tar.gz cd redis-2.4.8 make Configuration: vi redis.conf Start: nohup ./src/redis-server redis.conf Stop: killall redis-server Command line [^3]: ./src/redis-cli hgetall /dubbo/com.foo.BarService/providers Or: telnet 127.0.0.1 6379 hgetall /dubbo/com.foo.BarService/providers [^1]: Redis is a high performance KV store server, please refer to: http://redis.io/topics/quickstart [^2]: Support for version 2.1.0 and higher [^3]: Please refer to: http://redis.io/commands","title":"install Redis register center"},{"location":"admin/install/simple-monitor-center/","text":"install Simple monitor center The function of monitor center will be merged to dubbo admin, based on metrics, coming soon","title":"install Simple monitor center"},{"location":"admin/install/simple-monitor-center/#install-simple-monitor-center","text":"","title":"install Simple monitor center"},{"location":"admin/install/simple-monitor-center/#the-function-of-monitor-center-will-be-merged-to-dubbo-admin-based-on-metrics-coming-soon","text":"","title":"The function of monitor center will be merged to dubbo admin, based on metrics, coming soon"},{"location":"admin/install/simple-registry-center/","text":"install Simple configuration center","title":"install Simple configuration center"},{"location":"admin/install/simple-registry-center/#install-simple-configuration-center","text":"","title":"install Simple configuration center"},{"location":"admin/install/zookeeper/","text":"install Zookeeper configuration center zookeeper register center client version: dubbo-2.3.3 and above[^1] Dubbo changes nothing of Zookeeper's server side, an original Zookeeper server is fine. All change happens while calling Zookeeper's client side install: wget http://archive.apache.org/dist/zookeeper/zookeeper-3.3.3/zookeeper-3.3.3.tar.gz tar zxvf zookeeper-3.3.3.tar.gz cd zookeeper-3.3.3 cp conf/zoo_sample.cfg conf/zoo.cfg configuration: vi conf/zoo.cfg If cluster is not needed, the content of zoo.cfg is as below [^2]: tickTime=2000 initLimit=10 syncLimit=5 dataDir=/home/dubbo/zookeeper-3.3.3/data clientPort=2181 If cluster is needed, the content of zoo.cfg is as below [^3]: tickTime=2000 initLimit=10 syncLimit=5 dataDir=/home/dubbo/zookeeper-3.3.3/data clientPort=2181 server.1=10.20.153.10:2555:3555 server.2=10.20.153.11:2555:3555 Put myid file in data directory [^4]: mkdir data vi myid Myid is the number after server in zoo.cfg . The first one's content is 1, the second one's content is 2: 1 Start: ./bin/zkServer.sh start Stop: ./bin/zkServer.sh stop Command line ^5 : telnet 127.0.0.1 2181 dump Or: echo dump | nc 127.0.0.1 2181 Usage: dubbo.registry.address=zookeeper://10.20.153.10:2181?backup=10.20.153.11:2181 Or: dubbo:registry protocol= zookeeper address= 10.20.153.10:2181,10.20.153.11:2181 / [^1]: Zookeeper is a sub project of Apache Hadoop.As it is robust, we recommend to use in production environment. [^2]: Data directory should be changed into your real output directory [^3]: Data directory and server address should be changed into your real machine information [^4]: dataDir in zoo.cfg","title":"install Zookeeper configuration center"},{"location":"admin/install/zookeeper/#install-zookeeper-configuration-center","text":"zookeeper register center client version: dubbo-2.3.3 and above[^1] Dubbo changes nothing of Zookeeper's server side, an original Zookeeper server is fine. All change happens while calling Zookeeper's client side install: wget http://archive.apache.org/dist/zookeeper/zookeeper-3.3.3/zookeeper-3.3.3.tar.gz tar zxvf zookeeper-3.3.3.tar.gz cd zookeeper-3.3.3 cp conf/zoo_sample.cfg conf/zoo.cfg configuration: vi conf/zoo.cfg If cluster is not needed, the content of zoo.cfg is as below [^2]: tickTime=2000 initLimit=10 syncLimit=5 dataDir=/home/dubbo/zookeeper-3.3.3/data clientPort=2181 If cluster is needed, the content of zoo.cfg is as below [^3]: tickTime=2000 initLimit=10 syncLimit=5 dataDir=/home/dubbo/zookeeper-3.3.3/data clientPort=2181 server.1=10.20.153.10:2555:3555 server.2=10.20.153.11:2555:3555 Put myid file in data directory [^4]: mkdir data vi myid Myid is the number after server in zoo.cfg . The first one's content is 1, the second one's content is 2: 1 Start: ./bin/zkServer.sh start Stop: ./bin/zkServer.sh stop Command line ^5 : telnet 127.0.0.1 2181 dump Or: echo dump | nc 127.0.0.1 2181 Usage: dubbo.registry.address=zookeeper://10.20.153.10:2181?backup=10.20.153.11:2181 Or: dubbo:registry protocol= zookeeper address= 10.20.153.10:2181,10.20.153.11:2181 / [^1]: Zookeeper is a sub project of Apache Hadoop.As it is robust, we recommend to use in production environment. [^2]: Data directory should be changed into your real output directory [^3]: Data directory and server address should be changed into your real machine information [^4]: dataDir in zoo.cfg","title":"install Zookeeper configuration center"},{"location":"admin/ops/dubbo-ops/","text":"Ops console management Page search If you need to manage a Dubbo service, you need to search it first and open it's management page Service provider page Service consumer page Add route rule page Add dynamic configuration page","title":"Ops console management"},{"location":"admin/ops/dubbo-ops/#ops-console-management","text":"","title":"Ops console management"},{"location":"admin/ops/dubbo-ops/#page-search","text":"If you need to manage a Dubbo service, you need to search it first and open it's management page","title":"Page search"},{"location":"admin/ops/dubbo-ops/#service-provider-page","text":"","title":"Service provider page"},{"location":"admin/ops/dubbo-ops/#service-consumer-page","text":"","title":"Service consumer page"},{"location":"admin/ops/dubbo-ops/#add-route-rule-page","text":"","title":"Add route rule page"},{"location":"admin/ops/dubbo-ops/#add-dynamic-configuration-page","text":"","title":"Add dynamic configuration page"},{"location":"admin/ops/introduction/","text":"Ops manual","title":"Ops manual"},{"location":"admin/ops/introduction/#ops-manual","text":"","title":"Ops manual"},{"location":"admin/ops/pinpoint/","text":"Tracking with Pinpoint After using Dubbo to serve or integrate applications, assuming that a service backstage log shows an exception and that the service is invoked by multiple applications, it is often difficult to determine which application is called, and what is the cause of the problem, so we need a set of distributed tracking systems to quickly locate the problem. Pinpoint can help us quickly locate problems (of course, there are more than one solution). What is Pinpoint Pinpoint is an APM (Application Performance Management) tool for large-scale distributed systems written in Java. Inspired by Dapper, Pinpoint provides a solution to help analyze the overall structure of the system and how components within them are interconnected by tracing transactions across distributed applications. You should definitely check Pinpoint out If you want to understand your application topology at a glance monitor your application in Real-Time gain code-level visibility to every transaction install APM Agents without changing a single line of code have minimal impact on the performance (approximately 3% increase in resource usage) ServerMap Understand the topology of any distributed systems by visualizing how their components are interconnected. Clicking on a node reveals details about the component, such as its current status, and transaction count. Realtime Active Thread Chart Monitor active threads inside applications in real-time. Request/Response Scatter Chart Visualize request count and response patterns over time to identify potential problems. Transactions can be selected for additional detail by dragging over the chart. CallStack Gain code-level visibility to every transaction in a distributed environment, identifying bottlenecks and points of failure in a single view. Inspector View additional details on the application such as CPU usage, Memory/Garbage Collection, TPS, and JVM arguments. Supported Modules (last updated 2018/04/01) JDK 6+ Tomcat 6/7/8, Jetty 8/9, JBoss EAP 6, Resin 4, Websphere 6/7/8, Vertx 3.3/3.4/3.5 Spring, Spring Boot (Embedded Tomcat, Jetty) Apache HTTP Client 3.x/4.x, JDK HttpConnector, GoogleHttpClient, OkHttpClient, NingAsyncHttpClient Thrift Client, Thrift Service, DUBBO PROVIDER, DUBBO CONSUMER ActiveMQ, RabbitMQ MySQL, Oracle, MSSQL, CUBRID,POSTGRESQL, MARIA Arcus, Memcached, Redis, CASSANDRA iBATIS, MyBatis DBCP, DBCP2, HIKARICP gson, Jackson, Json Lib log4j, Logback Pinpoint and Dubbo Quickstart Pinpoint Quick start \uff08No neet to start TestApp\uff09 Dubbo demo Create API module pom.xml ?xml version= 1.0 encoding= UTF-8 ? project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion 4.0.0 /modelVersion groupId com.example /groupId artifactId demo-api /artifactId version 0.0.1-SNAPSHOT /version /project Create API interface\uff1a package com.example.demoapi; public interface HelloService { String sayHello(String name); } Dubbo provider pom.xml ?xml version= 1.0 encoding= UTF-8 ? project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion 4.0.0 /modelVersion groupId com.example /groupId artifactId demo-provider /artifactId version 0.0.1-SNAPSHOT /version packaging jar /packaging name demo-provider /name parent groupId org.springframework.boot /groupId artifactId spring-boot-starter-parent /artifactId version 2.0.3.RELEASE /version relativePath/ !-- lookup parent from repository -- /parent properties project.build.sourceEncoding UTF-8 /project.build.sourceEncoding project.reporting.outputEncoding UTF-8 /project.reporting.outputEncoding java.version 1.8 /java.version /properties repositories repository id sonatype-nexus-snapshots /id url https://oss.sonatype.org/content/repositories/snapshots /url releases enabled false /enabled /releases snapshots enabled true /enabled /snapshots /repository /repositories dependencies dependency groupId org.springframework.boot /groupId artifactId spring-boot-starter /artifactId /dependency dependency groupId com.alibaba.boot /groupId artifactId dubbo-spring-boot-starter /artifactId version 0.2.0 /version /dependency dependency groupId com.example /groupId artifactId demo-api /artifactId version 0.0.1-SNAPSHOT /version /dependency dependency groupId org.springframework.boot /groupId artifactId spring-boot-starter-test /artifactId scope test /scope /dependency /dependencies build plugins plugin groupId org.springframework.boot /groupId artifactId spring-boot-maven-plugin /artifactId /plugin /plugins /build /project HelloService interface\uff1a package com.example.demoprovider.provider; import org.apache.dubbo.config.annotation.Service; import com.example.demoapi.HelloService; @Service(version = ${demo.service.version} , application = ${dubbo.application.id} , protocol = ${dubbo.protocol.id} , registry = ${dubbo.registry.id} ) public class HelloServiceImpl implements HelloService { static int i = 0; @Override public String sayHello(String name) { i++; if (i % 3 == 0) { throw new RuntimeException( ex ); } return Hello + name + ! ; } } Spring Boot bootstrap\uff1a package com.example.demoprovider; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class DemoProviderApplication { public static void main(String[] args) { SpringApplication.run(DemoProviderApplication.class, args); } } application.properties \uff1a # Spring boot application spring.application.name = dubbo-provider-demo server.port = 9090 management.port = 9091 # Service version demo.service.version = 1.0.0 # Base packages to scan Dubbo Components (e.g @Service , @Reference) dubbo.scan.basePackages = com.example.demoprovider # Dubbo Config properties ## ApplicationConfig Bean dubbo.application.id = dubbo-provider-demo dubbo.application.name = dubbo-provider-demo ## ProtocolConfig Bean dubbo.protocol.id = dubbo dubbo.protocol.name = dubbo dubbo.protocol.port = 12345 ## RegistryConfig Bean dubbo.registry.id = my-registry dubbo.registry.address = N/A Dubbo consumer pom.xml ?xml version= 1.0 encoding= UTF-8 ? project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion 4.0.0 /modelVersion groupId com.example /groupId artifactId demo-consumer /artifactId version 0.0.1-SNAPSHOT /version packaging jar /packaging name demo-consumer /name parent groupId org.springframework.boot /groupId artifactId spring-boot-starter-parent /artifactId version 2.0.3.RELEASE /version relativePath/ !-- lookup parent from repository -- /parent properties project.build.sourceEncoding UTF-8 /project.build.sourceEncoding project.reporting.outputEncoding UTF-8 /project.reporting.outputEncoding java.version 1.8 /java.version /properties repositories repository id sonatype-nexus-snapshots /id url https://oss.sonatype.org/content/repositories/snapshots /url releases enabled false /enabled /releases snapshots enabled true /enabled /snapshots /repository /repositories dependencies dependency groupId org.springframework.boot /groupId artifactId spring-boot-starter-web /artifactId /dependency dependency groupId com.alibaba.boot /groupId artifactId dubbo-spring-boot-starter /artifactId version 0.2.0 /version /dependency dependency groupId com.example /groupId artifactId demo-api /artifactId version 0.0.1-SNAPSHOT /version /dependency dependency groupId org.springframework.boot /groupId artifactId spring-boot-starter-test /artifactId scope test /scope /dependency /dependencies build plugins plugin groupId org.springframework.boot /groupId artifactId spring-boot-maven-plugin /artifactId configuration classifier exec /classifier /configuration /plugin /plugins /build /project @Reference injection HelloService package com.example.democonsumer.controller; import org.apache.dubbo.config.annotation.Reference; import com.example.demoapi.HelloService; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController public class DemoConsumerController { @Reference(version = ${demo.service.version} , application = ${dubbo.application.id} , url = dubbo:// Real IP Address :12345 ) private HelloService helloService; @RequestMapping( /sayHello ) public String sayHello(@RequestParam String name) { return helloService.sayHello(name); } } Spring Boot bootstrap: package com.example.democonsumer; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class DemoConsumerApplication { public static void main(String[] args) { SpringApplication.run(DemoConsumerApplication.class, args); } } application.properties : # Spring boot application spring.application.name=dubbo-consumer-demo server.port=8080 management.port=8081 # Service Version demo.service.version=1.0.0 # Dubbo Config properties ## ApplicationConfig Bean dubbo.application.id=dubbo-consumer-demo dubbo.application.name=dubbo-consumer-demo ## ProtocolConfig Bean dubbo.protocol.id=dubbo dubbo.protocol.name=dubbo dubbo.protocol.port=12345 Using Pinpoint-agent to start Dubbo provider and Dubbo consumer Maven clean package mvn clean package Start provider java -jar -javaagent:$AGENT_PATH/pinpoint-bootstrap-$VERSION.jar -Dpinpoint.agentId=demo-provider -Dpinpoint.applicationName=DP target/demo-provider-0.0.1-SNAPSHOT.jar Start consumer java -jar -javaagent:$AGENT_PATH/pinpoint-bootstrap-$VERSION.jar -Dpinpoint.agentId=demo-consumer -Dpinpoint.applicationName=DC target/demo-comsumer-0.0.1-SNAPSHOT-exec.jar Access the consumer address to simulate user requests http://localhost:8080/sayHello?name=ABC Using Pinpoint locate problems Homepage The user request here is double the number of requests for DubboProvider, because the favicon.ico icon request is recorded. Call tree Mixed view Other The example simply simulates the provision and call of Dubbo, and does not carry out the application of other middleware such as database. For detailed use, please refer to the Pinpoint document.","title":"Tracking with Pinpoint"},{"location":"admin/ops/pinpoint/#tracking-with-pinpoint","text":"After using Dubbo to serve or integrate applications, assuming that a service backstage log shows an exception and that the service is invoked by multiple applications, it is often difficult to determine which application is called, and what is the cause of the problem, so we need a set of distributed tracking systems to quickly locate the problem. Pinpoint can help us quickly locate problems (of course, there are more than one solution).","title":"Tracking with Pinpoint"},{"location":"admin/ops/pinpoint/#what-is-pinpoint","text":"Pinpoint is an APM (Application Performance Management) tool for large-scale distributed systems written in Java. Inspired by Dapper, Pinpoint provides a solution to help analyze the overall structure of the system and how components within them are interconnected by tracing transactions across distributed applications. You should definitely check Pinpoint out If you want to understand your application topology at a glance monitor your application in Real-Time gain code-level visibility to every transaction install APM Agents without changing a single line of code have minimal impact on the performance (approximately 3% increase in resource usage)","title":"What is Pinpoint"},{"location":"admin/ops/pinpoint/#servermap","text":"Understand the topology of any distributed systems by visualizing how their components are interconnected. Clicking on a node reveals details about the component, such as its current status, and transaction count.","title":"ServerMap"},{"location":"admin/ops/pinpoint/#realtime-active-thread-chart","text":"Monitor active threads inside applications in real-time.","title":"Realtime Active Thread Chart"},{"location":"admin/ops/pinpoint/#requestresponse-scatter-chart","text":"Visualize request count and response patterns over time to identify potential problems. Transactions can be selected for additional detail by dragging over the chart.","title":"Request/Response Scatter Chart"},{"location":"admin/ops/pinpoint/#callstack","text":"Gain code-level visibility to every transaction in a distributed environment, identifying bottlenecks and points of failure in a single view.","title":"CallStack"},{"location":"admin/ops/pinpoint/#inspector","text":"View additional details on the application such as CPU usage, Memory/Garbage Collection, TPS, and JVM arguments.","title":"Inspector"},{"location":"admin/ops/pinpoint/#supported-modules-last-updated-20180401","text":"JDK 6+ Tomcat 6/7/8, Jetty 8/9, JBoss EAP 6, Resin 4, Websphere 6/7/8, Vertx 3.3/3.4/3.5 Spring, Spring Boot (Embedded Tomcat, Jetty) Apache HTTP Client 3.x/4.x, JDK HttpConnector, GoogleHttpClient, OkHttpClient, NingAsyncHttpClient Thrift Client, Thrift Service, DUBBO PROVIDER, DUBBO CONSUMER ActiveMQ, RabbitMQ MySQL, Oracle, MSSQL, CUBRID,POSTGRESQL, MARIA Arcus, Memcached, Redis, CASSANDRA iBATIS, MyBatis DBCP, DBCP2, HIKARICP gson, Jackson, Json Lib log4j, Logback","title":"Supported Modules (last updated 2018/04/01)"},{"location":"admin/ops/pinpoint/#pinpoint-and-dubbo","text":"","title":"Pinpoint and Dubbo"},{"location":"admin/ops/pinpoint/#quickstart-pinpoint","text":"Quick start \uff08No neet to start TestApp\uff09","title":"Quickstart Pinpoint"},{"location":"admin/ops/pinpoint/#dubbo-demo","text":"","title":"Dubbo demo"},{"location":"admin/ops/pinpoint/#create-api-module","text":"pom.xml ?xml version= 1.0 encoding= UTF-8 ? project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion 4.0.0 /modelVersion groupId com.example /groupId artifactId demo-api /artifactId version 0.0.1-SNAPSHOT /version /project Create API interface\uff1a package com.example.demoapi; public interface HelloService { String sayHello(String name); }","title":"Create API module"},{"location":"admin/ops/pinpoint/#dubbo-provider","text":"pom.xml ?xml version= 1.0 encoding= UTF-8 ? project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion 4.0.0 /modelVersion groupId com.example /groupId artifactId demo-provider /artifactId version 0.0.1-SNAPSHOT /version packaging jar /packaging name demo-provider /name parent groupId org.springframework.boot /groupId artifactId spring-boot-starter-parent /artifactId version 2.0.3.RELEASE /version relativePath/ !-- lookup parent from repository -- /parent properties project.build.sourceEncoding UTF-8 /project.build.sourceEncoding project.reporting.outputEncoding UTF-8 /project.reporting.outputEncoding java.version 1.8 /java.version /properties repositories repository id sonatype-nexus-snapshots /id url https://oss.sonatype.org/content/repositories/snapshots /url releases enabled false /enabled /releases snapshots enabled true /enabled /snapshots /repository /repositories dependencies dependency groupId org.springframework.boot /groupId artifactId spring-boot-starter /artifactId /dependency dependency groupId com.alibaba.boot /groupId artifactId dubbo-spring-boot-starter /artifactId version 0.2.0 /version /dependency dependency groupId com.example /groupId artifactId demo-api /artifactId version 0.0.1-SNAPSHOT /version /dependency dependency groupId org.springframework.boot /groupId artifactId spring-boot-starter-test /artifactId scope test /scope /dependency /dependencies build plugins plugin groupId org.springframework.boot /groupId artifactId spring-boot-maven-plugin /artifactId /plugin /plugins /build /project HelloService interface\uff1a package com.example.demoprovider.provider; import org.apache.dubbo.config.annotation.Service; import com.example.demoapi.HelloService; @Service(version = ${demo.service.version} , application = ${dubbo.application.id} , protocol = ${dubbo.protocol.id} , registry = ${dubbo.registry.id} ) public class HelloServiceImpl implements HelloService { static int i = 0; @Override public String sayHello(String name) { i++; if (i % 3 == 0) { throw new RuntimeException( ex ); } return Hello + name + ! ; } } Spring Boot bootstrap\uff1a package com.example.demoprovider; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class DemoProviderApplication { public static void main(String[] args) { SpringApplication.run(DemoProviderApplication.class, args); } } application.properties \uff1a # Spring boot application spring.application.name = dubbo-provider-demo server.port = 9090 management.port = 9091 # Service version demo.service.version = 1.0.0 # Base packages to scan Dubbo Components (e.g @Service , @Reference) dubbo.scan.basePackages = com.example.demoprovider # Dubbo Config properties ## ApplicationConfig Bean dubbo.application.id = dubbo-provider-demo dubbo.application.name = dubbo-provider-demo ## ProtocolConfig Bean dubbo.protocol.id = dubbo dubbo.protocol.name = dubbo dubbo.protocol.port = 12345 ## RegistryConfig Bean dubbo.registry.id = my-registry dubbo.registry.address = N/A","title":"Dubbo provider"},{"location":"admin/ops/pinpoint/#dubbo-consumer","text":"pom.xml ?xml version= 1.0 encoding= UTF-8 ? project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion 4.0.0 /modelVersion groupId com.example /groupId artifactId demo-consumer /artifactId version 0.0.1-SNAPSHOT /version packaging jar /packaging name demo-consumer /name parent groupId org.springframework.boot /groupId artifactId spring-boot-starter-parent /artifactId version 2.0.3.RELEASE /version relativePath/ !-- lookup parent from repository -- /parent properties project.build.sourceEncoding UTF-8 /project.build.sourceEncoding project.reporting.outputEncoding UTF-8 /project.reporting.outputEncoding java.version 1.8 /java.version /properties repositories repository id sonatype-nexus-snapshots /id url https://oss.sonatype.org/content/repositories/snapshots /url releases enabled false /enabled /releases snapshots enabled true /enabled /snapshots /repository /repositories dependencies dependency groupId org.springframework.boot /groupId artifactId spring-boot-starter-web /artifactId /dependency dependency groupId com.alibaba.boot /groupId artifactId dubbo-spring-boot-starter /artifactId version 0.2.0 /version /dependency dependency groupId com.example /groupId artifactId demo-api /artifactId version 0.0.1-SNAPSHOT /version /dependency dependency groupId org.springframework.boot /groupId artifactId spring-boot-starter-test /artifactId scope test /scope /dependency /dependencies build plugins plugin groupId org.springframework.boot /groupId artifactId spring-boot-maven-plugin /artifactId configuration classifier exec /classifier /configuration /plugin /plugins /build /project @Reference injection HelloService package com.example.democonsumer.controller; import org.apache.dubbo.config.annotation.Reference; import com.example.demoapi.HelloService; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController public class DemoConsumerController { @Reference(version = ${demo.service.version} , application = ${dubbo.application.id} , url = dubbo:// Real IP Address :12345 ) private HelloService helloService; @RequestMapping( /sayHello ) public String sayHello(@RequestParam String name) { return helloService.sayHello(name); } } Spring Boot bootstrap: package com.example.democonsumer; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class DemoConsumerApplication { public static void main(String[] args) { SpringApplication.run(DemoConsumerApplication.class, args); } } application.properties : # Spring boot application spring.application.name=dubbo-consumer-demo server.port=8080 management.port=8081 # Service Version demo.service.version=1.0.0 # Dubbo Config properties ## ApplicationConfig Bean dubbo.application.id=dubbo-consumer-demo dubbo.application.name=dubbo-consumer-demo ## ProtocolConfig Bean dubbo.protocol.id=dubbo dubbo.protocol.name=dubbo dubbo.protocol.port=12345","title":"Dubbo consumer"},{"location":"admin/ops/pinpoint/#using-pinpoint-agent-to-start-dubbo-provider-and-dubbo-consumer","text":"Maven clean package mvn clean package Start provider java -jar -javaagent:$AGENT_PATH/pinpoint-bootstrap-$VERSION.jar -Dpinpoint.agentId=demo-provider -Dpinpoint.applicationName=DP target/demo-provider-0.0.1-SNAPSHOT.jar Start consumer java -jar -javaagent:$AGENT_PATH/pinpoint-bootstrap-$VERSION.jar -Dpinpoint.agentId=demo-consumer -Dpinpoint.applicationName=DC target/demo-comsumer-0.0.1-SNAPSHOT-exec.jar Access the consumer address to simulate user requests http://localhost:8080/sayHello?name=ABC","title":"Using Pinpoint-agent to start Dubbo provider and Dubbo consumer"},{"location":"admin/ops/pinpoint/#using-pinpoint-locate-problems","text":"","title":"Using Pinpoint locate problems"},{"location":"admin/ops/pinpoint/#homepage","text":"The user request here is double the number of requests for DubboProvider, because the favicon.ico icon request is recorded.","title":"Homepage"},{"location":"admin/ops/pinpoint/#call-tree","text":"","title":"Call tree"},{"location":"admin/ops/pinpoint/#mixed-view","text":"","title":"Mixed view"},{"location":"admin/ops/pinpoint/#other","text":"The example simply simulates the provision and call of Dubbo, and does not carry out the application of other middleware such as database. For detailed use, please refer to the Pinpoint document.","title":"Other"},{"location":"admin/ops/skywalking/","text":"Tracing Dubbo service with Apache Skywalking(incubator) Introduction to Apache Skywalking(Incubator) Apache Skywalking(Incubator) is the APM system that it designed for micro-services architectures and cloud native architecture systems and supports distribute tracking. Apache skywalking (incubator) collects and analyzes the trace data and generates the relationship between the application and the service metric, Apache skywalking supports multiple languages agent, for example Java , .net core , Node.js and Go . Currently, Skywalking has supported analysis the operation of distributed systems from 6 visual dimensions. The overview view is a global view of your applications and components, including the number of components and applications, application alarm fluctuations, slow service lists, and application throughput; The topology shows the topological relationship of the whole application; The application view represents the upstream and downstream relationship of the application from single application, TOP N services and servers, JVM, host and process info. The service view focuses on the operation of a single service portal and the upstream and downstream dependencies of this service and it helps the user to optimize and monitor a single service; the trace graph shows all the buried points of the invocation and the execution time of each burial point, and the alarm view is based on the configuration threshold for the application, server, service for real-time alarms Dubbo and Apache Skywalking(Incubator) Build the Dubbo demo project The Dubbo demo has been uploaded to the GitHub repository . API project Service interface definition: package org.apache.skywalking.demo.interfaces; public interface HelloService { String sayHello(String name); } Service provider project package org.apache.skywalking.demo.provider; @Service(version = \"${demo.service.version}\", application = \"${dubbo.application.id}\", protocol = \"${dubbo.protocol.id}\", registry = \"${dubbo.registry.id}\", timeout = 60000) public class HelloServiceImpl implements HelloService { public String sayHello(String name) { LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(1)); return \"Hello, \" + name; } } Service consumer project package org.apache.skywalking.demo.consumer; @RestController public class ConsumerController { private static int COUNT = 0; @Reference(version = \"${demo.service.version}\", application = \"${dubbo.application.id}\", url = \"dubbo://localhost:20880\", timeout = 60000) private HelloService helloService; @GetMapping(\"/sayHello/{name}\") public String sayHello(@PathVariable(name = \"name\") String name) { if ((COUNT++) % 3 == 0){ throw new RuntimeException(); } LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(2)); return helloService.sayHello(name); } } Deploy Apache Skywalking(incubator) Apache skywalking (Incubator) offers two deployment modes: single-node mode and cluster mode,Here is the single-node mode deployment step, and more about how to deploy skywalking with cluster mode, please reference document . Third-party components JDK 8+ Elasticsearch 5.x Deployment step Download Apache Skywalking Collector Deploy Elasticsearch service Set cluster.name to CollectorDBCluster Set network.host to 0.0.0.0 Start elasticsearch service Unzip and start the Skywalking Collector. Run the ' bin/startup.sh ' command to start skywalking Collector Deploy the demo Before you deploy the demo service, please run the following command: ./mvnw clean package Deploy the provider service java -jar -javaagent:$AGENT_PATH/skywalking-agent.jar -Dskywalking.agent.application_code=dubbo-provider -Dskywalking.collector.servers=localhost:10800 dubbo-provider/target/dubbo-provider.jar Deploy the consumer service java -jar -javaagent:$AGENT_PATH/skywalking-agent.jar -Dskywalking.agent.application_code=dubbo-consumer -Dskywalking.collector.servers=localhost:10800 dubbo-consumer/target/dubbo-consumer.jar visit demo service curl http://localhost:8080/sayHello/test Skywalking scren snapshot Dashboard Topology Application view JVM Information Service view Consumer side provider side Trace Span info Alarm view","title":"Tracing Dubbo service with Apache Skywalking(incubator)"},{"location":"admin/ops/skywalking/#tracing-dubbo-service-with-apache-skywalkingincubator","text":"","title":"Tracing Dubbo service with Apache Skywalking(incubator)"},{"location":"admin/ops/skywalking/#introduction-to-apache-skywalkingincubator","text":"Apache Skywalking(Incubator) is the APM system that it designed for micro-services architectures and cloud native architecture systems and supports distribute tracking. Apache skywalking (incubator) collects and analyzes the trace data and generates the relationship between the application and the service metric, Apache skywalking supports multiple languages agent, for example Java , .net core , Node.js and Go . Currently, Skywalking has supported analysis the operation of distributed systems from 6 visual dimensions. The overview view is a global view of your applications and components, including the number of components and applications, application alarm fluctuations, slow service lists, and application throughput; The topology shows the topological relationship of the whole application; The application view represents the upstream and downstream relationship of the application from single application, TOP N services and servers, JVM, host and process info. The service view focuses on the operation of a single service portal and the upstream and downstream dependencies of this service and it helps the user to optimize and monitor a single service; the trace graph shows all the buried points of the invocation and the execution time of each burial point, and the alarm view is based on the configuration threshold for the application, server, service for real-time alarms","title":"Introduction to Apache Skywalking(Incubator)"},{"location":"admin/ops/skywalking/#dubbo-and-apache-skywalkingincubator","text":"","title":"Dubbo and Apache Skywalking(Incubator)"},{"location":"admin/ops/skywalking/#build-the-dubbo-demo-project","text":"The Dubbo demo has been uploaded to the GitHub repository .","title":"Build the Dubbo demo  project"},{"location":"admin/ops/skywalking/#api-project","text":"Service interface definition: package org.apache.skywalking.demo.interfaces; public interface HelloService { String sayHello(String name); }","title":"API project"},{"location":"admin/ops/skywalking/#service-provider-project","text":"package org.apache.skywalking.demo.provider; @Service(version = \"${demo.service.version}\", application = \"${dubbo.application.id}\", protocol = \"${dubbo.protocol.id}\", registry = \"${dubbo.registry.id}\", timeout = 60000) public class HelloServiceImpl implements HelloService { public String sayHello(String name) { LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(1)); return \"Hello, \" + name; } }","title":"Service provider project"},{"location":"admin/ops/skywalking/#service-consumer-project","text":"package org.apache.skywalking.demo.consumer; @RestController public class ConsumerController { private static int COUNT = 0; @Reference(version = \"${demo.service.version}\", application = \"${dubbo.application.id}\", url = \"dubbo://localhost:20880\", timeout = 60000) private HelloService helloService; @GetMapping(\"/sayHello/{name}\") public String sayHello(@PathVariable(name = \"name\") String name) { if ((COUNT++) % 3 == 0){ throw new RuntimeException(); } LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(2)); return helloService.sayHello(name); } }","title":"Service consumer project"},{"location":"admin/ops/skywalking/#deploy-apache-skywalkingincubator","text":"Apache skywalking (Incubator) offers two deployment modes: single-node mode and cluster mode,Here is the single-node mode deployment step, and more about how to deploy skywalking with cluster mode, please reference document .","title":"Deploy Apache Skywalking(incubator)"},{"location":"admin/ops/skywalking/#third-party-components","text":"JDK 8+ Elasticsearch 5.x","title":"Third-party components"},{"location":"admin/ops/skywalking/#deployment-step","text":"Download Apache Skywalking Collector Deploy Elasticsearch service Set cluster.name to CollectorDBCluster Set network.host to 0.0.0.0 Start elasticsearch service Unzip and start the Skywalking Collector. Run the ' bin/startup.sh ' command to start skywalking Collector","title":"Deployment step"},{"location":"admin/ops/skywalking/#deploy-the-demo","text":"Before you deploy the demo service, please run the following command: ./mvnw clean package","title":"Deploy the demo"},{"location":"admin/ops/skywalking/#deploy-the-provider-service","text":"java -jar -javaagent:$AGENT_PATH/skywalking-agent.jar -Dskywalking.agent.application_code=dubbo-provider -Dskywalking.collector.servers=localhost:10800 dubbo-provider/target/dubbo-provider.jar","title":"Deploy the provider service"},{"location":"admin/ops/skywalking/#deploy-the-consumer-service","text":"java -jar -javaagent:$AGENT_PATH/skywalking-agent.jar -Dskywalking.agent.application_code=dubbo-consumer -Dskywalking.collector.servers=localhost:10800 dubbo-consumer/target/dubbo-consumer.jar","title":"Deploy the consumer service"},{"location":"admin/ops/skywalking/#visit-demo-service","text":"curl http://localhost:8080/sayHello/test","title":"visit demo service"},{"location":"admin/ops/skywalking/#skywalking-scren-snapshot","text":"","title":"Skywalking scren snapshot"},{"location":"admin/ops/skywalking/#dashboard","text":"","title":"Dashboard"},{"location":"admin/ops/skywalking/#topology","text":"","title":"Topology"},{"location":"admin/ops/skywalking/#application-view","text":"JVM Information","title":"Application view"},{"location":"admin/ops/skywalking/#service-view","text":"Consumer side provider side","title":"Service view"},{"location":"admin/ops/skywalking/#trace","text":"Span info","title":"Trace"},{"location":"admin/ops/skywalking/#alarm-view","text":"","title":"Alarm view"},{"location":"dev/","text":"dubbo-dev-book This book dives into the design principles of dubbo, mainly covers the following topics: extension, coding styles, versio, build, etc.","title":"dubbo-dev-book"},{"location":"dev/#dubbo-dev-book","text":"This book dives into the design principles of dubbo, mainly covers the following topics: extension, coding styles, versio, build, etc.","title":"dubbo-dev-book"},{"location":"dev/SPI/","text":"SPI Loading SPI Config Source: Dubbo SPI is inherited from standard JDK SPI(Service Provider Interface) and makes it more powerful. Dubbo fixed below issues of the standard JDK SPI: The standard JDK SPI will load and instantize all the implementations at once. It will be a waste of resources if one implementation is timecosted, but never be used. We can't accquire the SPI name, if loading the SPI implementation is failed.For example: standard JDK ScriptEngine, get script type by invoking method getName(). RubyScriptEngine class will load failed if the depenency jar jruby.jar is missing, and the real error info will be lost. When user executes ruby scripts, the program throws exception that doesn't support ruby, but it is not the real cause. Enhance the SPI functionality by supporting IoC and AOP, one SPI can be easily injected by another SPI simply using setter. Appointment: In the jar file containing extension class [^1], places a config file META-INF/dubbo/full interface name , file content pattern: SPI name=the fully qualified name for the extension class , use new line seperator for multiple implementation. Example: To extend Dubbo Protocol, place a text file in the extension jar file: META-INF/dubbo/org.apache.dubbo.rpc.Protocol , content: xxx=com.alibaba.xxx.XxxProtocol content of the implementation [^2]: package com.alibaba.xxx; import org.apache.dubbo.rpc.Protocol; public class XxxProtocol implements Protocol { // ... } Configuration in config module In Dubbo config module, all SPI points have related attributes or labels, we can choose the specific SPI implementation by using its name. Like: dubbo:protocol name= xxx / SPI Features SPI Auto Wrap Auto wrap the SPI's Wrapper class. ExtensionLoader loads the SPI implementation, if the SPI has a copy instructor, it will be regarded as the SPI's Wrapper class. Wrapper class content: package com.alibaba.xxx; import org.apache.dubbo.rpc.Protocol; public class XxxProtocolWrapper implements Protocol { Protocol impl; public XxxProtocolWrapper(Protocol protocol) { impl = protocol; } //after interface method is executed, the method in extension will be executed public void refer() { //... some operation impl.refer(); // ... some operation } // ... } Wrapper class also implements the same SPI interface, but Wrapper is not the real implementation. It is used for wrap the real implementation returned from the ExtensionLoader . The real returned instance by ExtensionLoader is the Wrapper class instance, Wrapper holder the real SPI implementation class. There can be many Wrapper for one spi, simply add one if you need. With Wrapper class, you will be able to move same logics into Wrapper for all SPIs. Newly added Wrapper class add external logics for all SPIs, looks like AOP, Wrapper acts as a proxy for SPI. SPI Auto Load when loading the SPI, Dubbo will auto load the depency SPI. When one SPI implementation contains attribute which is also an SPI of another type, ExtensionLoader will automatically load the depency SPI. ExtensionLoader knows all the members of the specific SPI by scanning the setter method of all implementation class. Demo: two SPI CarMaker \uff08car maker\uff09\u3001 WheelMaker (wheel maker) Intefaces look like: public interface CarMaker { Car makeCar(); } public interface WheelMaker { Wheel makeWheel(); } CarMaker 's implementation: public class RaceCarMaker implements CarMaker { WheelMaker wheelMaker; public setWheelMaker(WheelMaker wheelMaker) { this.wheelMaker = wheelMaker; } public Car makeCar() { // ... Wheel wheel = wheelMaker.makeWheel(); // ... return new RaceCar(wheel, ...); } } when ExtensionLoader loads CarMaker 's implementation RaceCarMaker , the method setWheelMaker needs paramType WheelMaker which is also a SPI, It will be automatically loaded. This brings a new question:How ExtensionLoader determines which implementation to use when load the injected SPI. As for this demo, when existing multi WheelMaker implementation, which one should the ExtensionLoader chooses. Good question, we will explain it in the following chapter: SPI Auto Adaptive. SPI Auto Adaptive The depency SPI that ExtensionLoader injects is an instance of Adaptive , the real spi implementation is known until the adaptive instance is executed. Dubbo use URL (containing Key-Value) to pass the configuration. The SPI method invocation has the URL parameter\uff08Or Entity that has URL attribute\uff09 In this way depended SPI can get configuration from URL, after config all SPI key needed, configuration information will be passed from outer by URL. URL acts as a bus when passing the config information. Demo: two SPI CarMaker \u3001 WheelMaker interface looks like: public interface CarMaker { Car makeCar(URL url); } public interface WheelMaker { Wheel makeWheel(URL url); } CarMaker 's implementation: public class RaceCarMaker implements CarMaker { WheelMaker wheelMaker; public setWheelMaker(WheelMaker wheelMaker) { this.wheelMaker = wheelMaker; } public Car makeCar(URL url) { // ... Wheel wheel = wheelMaker.makeWheel(url); // ... return new RaceCar(wheel, ...); } } when execute the code above // ... Wheel wheel = wheelMaker.makeWheel(url); // ... , the injected Adaptive object determine which WheelMaker 's makeWheel method will be executed by predefined Key. Such as wheel.type , key url.get(\"wheel.type\") will determine WheelMake implementation. The logic of Adaptive instance of fixed, getting the predefined Key of the URL, dynamically creating the real implementation and execute it. For Dubbo, the SPI Adaptive implementation in ExtensionLoader is dynamically created when dubbo is loading the SPI. Get the Key from URL, the Key will be provided through @Adaptive annotation for the interface method definition. Below is Dubbo Transporter SPI codes: public interface Transporter { @Adaptive({ server , transport }) Server bind(URL url, ChannelHandler handler) throws RemotingException; @Adaptive({ client , transport }) Client connect(URL url, ChannelHandler handler) throws RemotingException; } for the method bind(), Adaptive will firstly search server key, if no Key were founded then will search transport key, to determine the implementation that the proxy represent for. SPI Auto Activation As for Collections SPI, such as: Filter , InvokerListener , ExportListener , TelnetHandler , StatusChecker etc, multi implementations can be loaded at one time. User can simplify configuration by using auto activation, Like: import org.apache.dubbo.common.extension.Activate; import org.apache.dubbo.rpc.Filter; @Activate // Active for any condition public class XxxFilter implements Filter { // ... } Or: import org.apache.dubbo.common.extension.Activate; import org.apache.dubbo.rpc.Filter; @Activate( xxx ) // when configed xxx parameter and the parameter has a valid value,the SPI is activated, for example configed cache= lru , auto acitivate CacheFilter. public class XxxFilter implements Filter { // ... } Or: import org.apache.dubbo.common.extension.Activate; import org.apache.dubbo.rpc.Filter; @Activate(group = provider , value = xxx ) // only activate for provider, group can be provider or consumer public class XxxFilter implements Filter { // ... } [^1]: Note: The config file here is in you own jar file, not in dubbo release jar file, Dubbo will scan all jar files with the same filename in classpath and then merge them together [^2]: Note: SPI will be loaded in singleton pattern(Please ensure thread safety), cached in ExtensionLoader","title":"How SPI Works"},{"location":"dev/SPI/#spi-loading","text":"","title":"SPI Loading"},{"location":"dev/SPI/#spi-config","text":"","title":"SPI Config"},{"location":"dev/SPI/#source","text":"Dubbo SPI is inherited from standard JDK SPI(Service Provider Interface) and makes it more powerful. Dubbo fixed below issues of the standard JDK SPI: The standard JDK SPI will load and instantize all the implementations at once. It will be a waste of resources if one implementation is timecosted, but never be used. We can't accquire the SPI name, if loading the SPI implementation is failed.For example: standard JDK ScriptEngine, get script type by invoking method getName(). RubyScriptEngine class will load failed if the depenency jar jruby.jar is missing, and the real error info will be lost. When user executes ruby scripts, the program throws exception that doesn't support ruby, but it is not the real cause. Enhance the SPI functionality by supporting IoC and AOP, one SPI can be easily injected by another SPI simply using setter.","title":"Source:"},{"location":"dev/SPI/#appointment","text":"In the jar file containing extension class [^1], places a config file META-INF/dubbo/full interface name , file content pattern: SPI name=the fully qualified name for the extension class , use new line seperator for multiple implementation.","title":"Appointment:"},{"location":"dev/SPI/#example","text":"To extend Dubbo Protocol, place a text file in the extension jar file: META-INF/dubbo/org.apache.dubbo.rpc.Protocol , content: xxx=com.alibaba.xxx.XxxProtocol content of the implementation [^2]: package com.alibaba.xxx; import org.apache.dubbo.rpc.Protocol; public class XxxProtocol implements Protocol { // ... }","title":"Example:"},{"location":"dev/SPI/#configuration-in-config-module","text":"In Dubbo config module, all SPI points have related attributes or labels, we can choose the specific SPI implementation by using its name. Like: dubbo:protocol name= xxx /","title":"Configuration in config module"},{"location":"dev/SPI/#spi-features","text":"","title":"SPI Features"},{"location":"dev/SPI/#spi-auto-wrap","text":"Auto wrap the SPI's Wrapper class. ExtensionLoader loads the SPI implementation, if the SPI has a copy instructor, it will be regarded as the SPI's Wrapper class. Wrapper class content: package com.alibaba.xxx; import org.apache.dubbo.rpc.Protocol; public class XxxProtocolWrapper implements Protocol { Protocol impl; public XxxProtocolWrapper(Protocol protocol) { impl = protocol; } //after interface method is executed, the method in extension will be executed public void refer() { //... some operation impl.refer(); // ... some operation } // ... } Wrapper class also implements the same SPI interface, but Wrapper is not the real implementation. It is used for wrap the real implementation returned from the ExtensionLoader . The real returned instance by ExtensionLoader is the Wrapper class instance, Wrapper holder the real SPI implementation class. There can be many Wrapper for one spi, simply add one if you need. With Wrapper class, you will be able to move same logics into Wrapper for all SPIs. Newly added Wrapper class add external logics for all SPIs, looks like AOP, Wrapper acts as a proxy for SPI.","title":"SPI Auto Wrap"},{"location":"dev/SPI/#spi-auto-load","text":"when loading the SPI, Dubbo will auto load the depency SPI. When one SPI implementation contains attribute which is also an SPI of another type, ExtensionLoader will automatically load the depency SPI. ExtensionLoader knows all the members of the specific SPI by scanning the setter method of all implementation class. Demo: two SPI CarMaker \uff08car maker\uff09\u3001 WheelMaker (wheel maker) Intefaces look like: public interface CarMaker { Car makeCar(); } public interface WheelMaker { Wheel makeWheel(); } CarMaker 's implementation: public class RaceCarMaker implements CarMaker { WheelMaker wheelMaker; public setWheelMaker(WheelMaker wheelMaker) { this.wheelMaker = wheelMaker; } public Car makeCar() { // ... Wheel wheel = wheelMaker.makeWheel(); // ... return new RaceCar(wheel, ...); } } when ExtensionLoader loads CarMaker 's implementation RaceCarMaker , the method setWheelMaker needs paramType WheelMaker which is also a SPI, It will be automatically loaded. This brings a new question:How ExtensionLoader determines which implementation to use when load the injected SPI. As for this demo, when existing multi WheelMaker implementation, which one should the ExtensionLoader chooses. Good question, we will explain it in the following chapter: SPI Auto Adaptive.","title":"SPI Auto Load"},{"location":"dev/SPI/#spi-auto-adaptive","text":"The depency SPI that ExtensionLoader injects is an instance of Adaptive , the real spi implementation is known until the adaptive instance is executed. Dubbo use URL (containing Key-Value) to pass the configuration. The SPI method invocation has the URL parameter\uff08Or Entity that has URL attribute\uff09 In this way depended SPI can get configuration from URL, after config all SPI key needed, configuration information will be passed from outer by URL. URL acts as a bus when passing the config information. Demo: two SPI CarMaker \u3001 WheelMaker interface looks like: public interface CarMaker { Car makeCar(URL url); } public interface WheelMaker { Wheel makeWheel(URL url); } CarMaker 's implementation: public class RaceCarMaker implements CarMaker { WheelMaker wheelMaker; public setWheelMaker(WheelMaker wheelMaker) { this.wheelMaker = wheelMaker; } public Car makeCar(URL url) { // ... Wheel wheel = wheelMaker.makeWheel(url); // ... return new RaceCar(wheel, ...); } } when execute the code above // ... Wheel wheel = wheelMaker.makeWheel(url); // ... , the injected Adaptive object determine which WheelMaker 's makeWheel method will be executed by predefined Key. Such as wheel.type , key url.get(\"wheel.type\") will determine WheelMake implementation. The logic of Adaptive instance of fixed, getting the predefined Key of the URL, dynamically creating the real implementation and execute it. For Dubbo, the SPI Adaptive implementation in ExtensionLoader is dynamically created when dubbo is loading the SPI. Get the Key from URL, the Key will be provided through @Adaptive annotation for the interface method definition. Below is Dubbo Transporter SPI codes: public interface Transporter { @Adaptive({ server , transport }) Server bind(URL url, ChannelHandler handler) throws RemotingException; @Adaptive({ client , transport }) Client connect(URL url, ChannelHandler handler) throws RemotingException; } for the method bind(), Adaptive will firstly search server key, if no Key were founded then will search transport key, to determine the implementation that the proxy represent for.","title":"SPI Auto Adaptive"},{"location":"dev/SPI/#spi-auto-activation","text":"As for Collections SPI, such as: Filter , InvokerListener , ExportListener , TelnetHandler , StatusChecker etc, multi implementations can be loaded at one time. User can simplify configuration by using auto activation, Like: import org.apache.dubbo.common.extension.Activate; import org.apache.dubbo.rpc.Filter; @Activate // Active for any condition public class XxxFilter implements Filter { // ... } Or: import org.apache.dubbo.common.extension.Activate; import org.apache.dubbo.rpc.Filter; @Activate( xxx ) // when configed xxx parameter and the parameter has a valid value,the SPI is activated, for example configed cache= lru , auto acitivate CacheFilter. public class XxxFilter implements Filter { // ... } Or: import org.apache.dubbo.common.extension.Activate; import org.apache.dubbo.rpc.Filter; @Activate(group = provider , value = xxx ) // only activate for provider, group can be provider or consumer public class XxxFilter implements Filter { // ... } [^1]: Note: The config file here is in you own jar file, not in dubbo release jar file, Dubbo will scan all jar files with the same filename in classpath and then merge them together [^2]: Note: SPI will be loaded in singleton pattern(Please ensure thread safety), cached in ExtensionLoader","title":"SPI Auto Activation"},{"location":"dev/SUMMARY/","text":"Summary 1 How To Build 2 Architecture 3 How SPI Works 4 Init, Process, Protocols 5 SPI Extensions 5.1 Protocol 5.2 Filter 5.3 InvokerListener 5.4 ExporterListener 5.5 Cluster 5.6 Router 5.7 LoadBalance 5.8 Merger 5.9 Registry 5.10 Monitor 5.11 ExtensionFactory 5.12 ProxyFactory 5.13 Compiler 5.14 Dispatcher 5.15 Threadpool 5.16 Serialization 5.17 Remoting 5.18 Exchanger 5.19 Networker 5.20 TelnetHandler 5.21 StatusChecker 5.22 Container 5.23 PageHandler 5.24 Cache 5.25 Validation 5.26 LoggerAdapter 6 Contract 7 Code Style 9 Versions 10 Contribution 11 Checklist 12 Code Smell 13 TCK","title":"Summary"},{"location":"dev/SUMMARY/#summary","text":"1 How To Build 2 Architecture 3 How SPI Works 4 Init, Process, Protocols 5 SPI Extensions 5.1 Protocol 5.2 Filter 5.3 InvokerListener 5.4 ExporterListener 5.5 Cluster 5.6 Router 5.7 LoadBalance 5.8 Merger 5.9 Registry 5.10 Monitor 5.11 ExtensionFactory 5.12 ProxyFactory 5.13 Compiler 5.14 Dispatcher 5.15 Threadpool 5.16 Serialization 5.17 Remoting 5.18 Exchanger 5.19 Networker 5.20 TelnetHandler 5.21 StatusChecker 5.22 Container 5.23 PageHandler 5.24 Cache 5.25 Validation 5.26 LoggerAdapter 6 Contract 7 Code Style 9 Versions 10 Contribution 11 Checklist 12 Code Smell 13 TCK","title":"Summary"},{"location":"dev/TCK/","text":"Compatibility test Dubbo's protocol, communication, serialization, registry, load balancing and other SPI all offer alternative strategies for different application scenarios while our test cases are very scattered. Ours is always uncertain whether it can satisfy the complete contract of the extension point when users need to add a new implementation. Thus we need to use TCK (Technology Compatibility Kit) for the core extension points. When users add a new implementaion, compatibility with the rest of the framework can be ensured with TCK. This can effectively improve the overall health and also facilitate the access of the third party extenders, which accelerates the maturity of the open source community. Xingzhi from the open source community is already working on this part. His preliminary idea is to build a TCK framework for Dubbo drawing on the CDI-TCK of JBoss first, then realize the TCK implementing case of Dubbo. Reference\uff1ahttp://docs.jboss.org/cdi/tck/reference/1.0.1-Final/html/introduction.html Anyone interested is welcomed to work on this together. Protocol TCK TODO Registry TCK TODO","title":"TCK"},{"location":"dev/TCK/#compatibility-test","text":"Dubbo's protocol, communication, serialization, registry, load balancing and other SPI all offer alternative strategies for different application scenarios while our test cases are very scattered. Ours is always uncertain whether it can satisfy the complete contract of the extension point when users need to add a new implementation. Thus we need to use TCK (Technology Compatibility Kit) for the core extension points. When users add a new implementaion, compatibility with the rest of the framework can be ensured with TCK. This can effectively improve the overall health and also facilitate the access of the third party extenders, which accelerates the maturity of the open source community. Xingzhi from the open source community is already working on this part. His preliminary idea is to build a TCK framework for Dubbo drawing on the CDI-TCK of JBoss first, then realize the TCK implementing case of Dubbo. Reference\uff1ahttp://docs.jboss.org/cdi/tck/reference/1.0.1-Final/html/introduction.html Anyone interested is welcomed to work on this together.","title":"Compatibility test"},{"location":"dev/TCK/#protocol-tck","text":"TODO","title":"Protocol TCK"},{"location":"dev/TCK/#registry-tck","text":"TODO","title":"Registry TCK"},{"location":"dev/build/","text":"Source Code Build Checkout checkout the lastest project source code with commands blow: git clone https://github.com/apache/dubbo.git dubbo Branches We use master as the major branch for new feature development, and use other branches for maintenance. Tags for all versions can be checked via https://github.com/apache/dubbo/tags. Building Dubbo relies on maven as the building tool. Requirements: Java above 1.5 version Maven version 2.2.1 or above The following MAVEN_OPTS should be configured before building: export MAVEN_OPTS=-Xmx1024m -XX:MaxPermSize=512m build with below command: mvn clean install skip testing using below building command: mvn install -Dmaven.test.skip Building jar package of source code build Dubbo source code jar package with below command. mvn clean source:jar install -Dmaven.test.skip and modify the dubbo dependency in your sample project to the SANPSHOT version of the local repository, and then use remote debugger to debug dubbo. IDE support use below command to generate IDE. Intellij Idea mvn idea:idea Eclipse mvn eclipse:eclipse Importing into eclipse Firstly, a maven repository needs to be configured in eclipse. Define M2_REPO and point it to the local maven repository by clicking Preferences - Java - Build Path - Classpath . Use the following maven command as well: mvn eclipse:configure-workspace -Declipse.workspace=/path/to/the/workspace/ 1: view the source code through https://github.com/apache/dubbo 2: path under UNIX is ${HOME}/.m2/repository, path under Windows is C:\\Documents and Settings\\ .m2\\repository","title":"How to Build"},{"location":"dev/build/#source-code-build","text":"","title":"Source Code Build"},{"location":"dev/build/#checkout","text":"checkout the lastest project source code with commands blow: git clone https://github.com/apache/dubbo.git dubbo","title":"Checkout"},{"location":"dev/build/#branches","text":"We use master as the major branch for new feature development, and use other branches for maintenance. Tags for all versions can be checked via https://github.com/apache/dubbo/tags.","title":"Branches"},{"location":"dev/build/#building","text":"Dubbo relies on maven as the building tool. Requirements: Java above 1.5 version Maven version 2.2.1 or above The following MAVEN_OPTS should be configured before building: export MAVEN_OPTS=-Xmx1024m -XX:MaxPermSize=512m build with below command: mvn clean install skip testing using below building command: mvn install -Dmaven.test.skip","title":"Building"},{"location":"dev/build/#building-jar-package-of-source-code","text":"build Dubbo source code jar package with below command. mvn clean source:jar install -Dmaven.test.skip and modify the dubbo dependency in your sample project to the SANPSHOT version of the local repository, and then use remote debugger to debug dubbo.","title":"Building jar package of source code"},{"location":"dev/build/#ide-support","text":"use below command to generate IDE.","title":"IDE support"},{"location":"dev/build/#intellij-idea","text":"mvn idea:idea","title":"Intellij Idea"},{"location":"dev/build/#eclipse","text":"mvn eclipse:eclipse Importing into eclipse Firstly, a maven repository needs to be configured in eclipse. Define M2_REPO and point it to the local maven repository by clicking Preferences - Java - Build Path - Classpath . Use the following maven command as well: mvn eclipse:configure-workspace -Declipse.workspace=/path/to/the/workspace/ 1: view the source code through https://github.com/apache/dubbo 2: path under UNIX is ${HOME}/.m2/repository, path under Windows is C:\\Documents and Settings\\ .m2\\repository","title":"Eclipse"},{"location":"dev/checklist/","text":"Checklist Checklist before release github milestones github change lists Travis CI test code find bugs Checklist for bigfix versions Create a github issue before coding Create unit test before bugfix Review Test your code (Normal process / Abnormal process) Record your design on github issue Complete javadoc and comment in code Manager for every version, responsible for scope and check","title":"Checklist"},{"location":"dev/checklist/#checklist","text":"","title":"Checklist"},{"location":"dev/checklist/#checklist-before-release","text":"github milestones github change lists Travis CI test code find bugs","title":"Checklist before release"},{"location":"dev/checklist/#checklist-for-bigfix-versions","text":"Create a github issue before coding Create unit test before bugfix Review Test your code (Normal process / Abnormal process) Record your design on github issue Complete javadoc and comment in code Manager for every version, responsible for scope and check","title":"Checklist for bigfix versions"},{"location":"dev/code-smell/","text":"Bad Smell Ugly Dubbo design or implementation will be record here. URL Convertion 1. Point to Point Service export and refer service directly export\uff1a EXPORT(dubbo://provider-address/com.xxx.XxxService?version=1.0.0 ) service directly refer\uff1a REFER(dubbo://provider-address/com.xxx.XxxService?version=1.0.0) 2. Export servie by registry export service to registry\uff1a EXPORT(registry://registry-address/org.apache.dubbo.registry.RegistrySerevice?registry=dubbo export=ENCODE(dubbo://provider-address/com.xxx.XxxService?version=1.0.0)) accquire registry\uff1a url.setProtocol(url.getParameter( registry , dubbo )) GETREGISTRY(dubbo://registry-address/org.apache.dubbo.registry.RegistrySerevice) registry service address\uff1a url.getParameterAndDecoded( export )) REGISTER(dubbo://provider-address/com.xxx.XxxService?version=1.0.0) 3. Refer service from registry refer service from registry\uff1a REFER(registry://registry-address/org.apache.dubbo.registry.RegistrySerevice?registry=dubbo refer=ENCODE(version=1.0.0)) accquire registry\uff1a url.setProtocol(url.getParameter( registry , dubbo )) GETREGISTRY(dubbo://registry-address/org.apache.dubbo.registry.RegistrySerevice) subscribe service address\uff1a url.addParameters(url.getParameterAndDecoded( refer )) SUBSCRIBE(dubbo://registry-address/com.xxx.XxxService?version=1.0.0) notify service address\uff1a url.addParameters(url.getParameterAndDecoded( refer )) NOTIFY(dubbo://provider-address/com.xxx.XxxService?version=1.0.0) 4. Registry push route rule registry push route rule\uff1a NOTIFY(route://registry-address/com.xxx.XxxService?router=script type=js rule=ENCODE(function{...})) accquire routers\uff1a url.setProtocol(url.getParameter( router , script )) GETROUTE(script://registry-address/com.xxx.XxxService?type=js rule=ENCODE(function{...})) 5. Load route rule from file load route rule from file\uff1a GETROUTE(file://path/file.js?router=script) accquire routers\uff1a url.setProtocol(url.getParameter( router , script )).addParameter( type , SUFFIX(file)).addParameter( rule , READ(file)) GETROUTE(script://path/file.js?type=js rule=ENCODE(function{...})) Invoke parameters path service path group service group version service version dubbo current dubbo release version token verify token timeout invocation timeout SPI Loading 1. SPI Auto Adaptive When ExtensionLoader loads SPI, It will check spi attributes(using set method) . If one attribute is SPI, ExtensionLoader will load the SPI implementation. Auto injected object is an adaptive instance\uff08proxy\uff09 ,because the real implementation is confirmed only in execution stage.\u3002when adaptive spi is invoked, Dubbo will choose the real implementation and executes it. Dubbo choose the right implementation according to the parameters that the mehod defines. All the inner SPIs that Dubbo defines have the URL parameter defined for the method invocation. Adaptive SPI uses URL to determine which implementation is needed. One specific Key and Value in the URL confirms the usage of the specific implementation, All these is done by adding @Adaptive annotation. @Extension public interface Car { @Adaptive({ http://10.20.160.198/wiki/display/dubbo/car.type , http://10.20.160.198/wiki/display/dubbo/transport.type }) public run(URL url, Type1 arg1, Type2 arg2); } For the rules above\uff0cExtensionLoader will create a adaptive instance for each SPI injected. ExtensionLoader generated adaptive classes look like \uff1a package package name for SPI interface ; public class SPI interface name $Adpative implements SPI interface { public contains @Adaptive annotation method ( parameters ) { if(parameters containing URL Type?) using URL parameter else if(method returns URL) using the return URL # else throw exception,inject SPI fail\uff01 if(URL accquired == null) { throw new IllegalArgumentException( url == null ); } According to the Key order from @Adaptive annotation\uff0cget the Value from the URL as the real SPI name if no value is found then use the default SPI implementation\u3002If no SPI point\uff0c throw new IllegalStateException( Fail to get extension ); Invoke the method using the spi and return the result. } public method having annotation @Adaptive ( parameters ) { throw new UnsupportedOperationException( is not adaptive method! ); } } @Adaptive annotation usage\uff1a If no value is configed for those Keys in URL\uff0cdefault SPI implementation is used\u3002For example \uff0cString[] {\"key1\", \"key2\"}\uff0cfirstly Dubbo will look up value for key1 and use it as SPI name;if key1 value is not founded then look up for key2\uff0cif value of key2 is also not found ,then use default spi implementation. If no default implementation is configed, then the method will throw IllegalStateException\u3002if not configed , then default implement is lower case of the interface class full package name. For Extension interface org.apache.dubbo.xxx.YyyInvokerWrapper , default value is new String[] {\"yyy.invoker.wrapper\"} Callback Function 1. Parameter Callback main theory \uff1a in the persistent connection for one consumer- provider\uff0cexport a service in Consumer side\uff0cprovider side can reversely call the instance in consumer side. Implement details\uff1a For exchanging interface instance in transmition, auto export and auto refer is implemented in DubboCodec . Need to seperate business logic and codec logic. you will need to judge whether needing callback when getting exporter from invocation\uff0cif needed, get the callback instance id from the attachments. By using this method, consumer side can implement the callback interface with different implementations. 2. Event Notification main theory \uff1a when Consumer executing invoke method\uff0cjudging if any configuration for onreturn/onerror... put the method for onreturn to the callback list of the async invocatioin. Implement details\uff1aparameters is passed using URL\uff0cbut string-object is not supported for URL, so the method is stored in staticMap\uff0cit needs to be optimized. Lazy Connection DubboProtocol specific features, default disabled When client creating proxy for server, do not establish TCP persistent connection at first, only init the connecton when data is needing transmision. This feather will disable the connection retry policy , resend the data again(if connection is lost when sending data ,try to establish a new connection to send data) Share Connection DubboProtocol specific features, default enabled\u3002 JVM A export many services\uff0cJVM B refer more than one services of A\uff0cShare Connection means those different services invocations between A and B uses the same TCP connection to transmit data, reducing server connections. Implement details\uff1awhen using share connection for the same address\uff0cyou need pay more attention to the invoker's destroy action.on one hand, you should close the connection when all the invokers refering the same address is destroyed, on another hand ,you should not close the connection when not all of the invokers are destroyed. In design implementation, we uses a strategy called reference count , we create a connection called Lazy connection for exceptions not affacting business when closing the connection just in case. sticky policy when existing many providers and configing the sticky policy\uff0cinvocation will be sent to the same provider as last invocation. Sticky Policy opens the lazy attribute of connection, for avoiding open useless connectons. provider selecting logic existing multi providers\uff0cfirstly select by Loadbalance \u3002If the selected provider is available ,then just doing the invocation If the selected provider is not available in stage 1, then choose from the remaining ,if available then doing the inovation If all providers are not available , rescan the list(not choosen invoker first),juding if any provider is available, if existing,doing the invocatiion. If no available provider in stage 3, then the next invoker of the invoker of stage 1 will be choosen(if not the last one),avoiding collision.","title":"Code Smell"},{"location":"dev/code-smell/#bad-smell","text":"Ugly Dubbo design or implementation will be record here.","title":"Bad Smell"},{"location":"dev/code-smell/#url-convertion","text":"","title":"URL Convertion"},{"location":"dev/code-smell/#1-point-to-point-service-export-and-refer","text":"service directly export\uff1a EXPORT(dubbo://provider-address/com.xxx.XxxService?version=1.0.0 ) service directly refer\uff1a REFER(dubbo://provider-address/com.xxx.XxxService?version=1.0.0)","title":"1. Point to Point Service export and refer"},{"location":"dev/code-smell/#2-export-servie-by-registry","text":"export service to registry\uff1a EXPORT(registry://registry-address/org.apache.dubbo.registry.RegistrySerevice?registry=dubbo export=ENCODE(dubbo://provider-address/com.xxx.XxxService?version=1.0.0)) accquire registry\uff1a url.setProtocol(url.getParameter( registry , dubbo )) GETREGISTRY(dubbo://registry-address/org.apache.dubbo.registry.RegistrySerevice) registry service address\uff1a url.getParameterAndDecoded( export )) REGISTER(dubbo://provider-address/com.xxx.XxxService?version=1.0.0)","title":"2. Export servie by registry"},{"location":"dev/code-smell/#3-refer-service-from-registry","text":"refer service from registry\uff1a REFER(registry://registry-address/org.apache.dubbo.registry.RegistrySerevice?registry=dubbo refer=ENCODE(version=1.0.0)) accquire registry\uff1a url.setProtocol(url.getParameter( registry , dubbo )) GETREGISTRY(dubbo://registry-address/org.apache.dubbo.registry.RegistrySerevice) subscribe service address\uff1a url.addParameters(url.getParameterAndDecoded( refer )) SUBSCRIBE(dubbo://registry-address/com.xxx.XxxService?version=1.0.0) notify service address\uff1a url.addParameters(url.getParameterAndDecoded( refer )) NOTIFY(dubbo://provider-address/com.xxx.XxxService?version=1.0.0)","title":"3. Refer service from registry"},{"location":"dev/code-smell/#4-registry-push-route-rule","text":"registry push route rule\uff1a NOTIFY(route://registry-address/com.xxx.XxxService?router=script type=js rule=ENCODE(function{...})) accquire routers\uff1a url.setProtocol(url.getParameter( router , script )) GETROUTE(script://registry-address/com.xxx.XxxService?type=js rule=ENCODE(function{...}))","title":"4. Registry push route rule"},{"location":"dev/code-smell/#5-load-route-rule-from-file","text":"load route rule from file\uff1a GETROUTE(file://path/file.js?router=script) accquire routers\uff1a url.setProtocol(url.getParameter( router , script )).addParameter( type , SUFFIX(file)).addParameter( rule , READ(file)) GETROUTE(script://path/file.js?type=js rule=ENCODE(function{...}))","title":"5. Load route rule from file"},{"location":"dev/code-smell/#invoke-parameters","text":"path service path group service group version service version dubbo current dubbo release version token verify token timeout invocation timeout","title":"Invoke parameters"},{"location":"dev/code-smell/#spi-loading","text":"","title":"SPI Loading"},{"location":"dev/code-smell/#1-spi-auto-adaptive","text":"When ExtensionLoader loads SPI, It will check spi attributes(using set method) . If one attribute is SPI, ExtensionLoader will load the SPI implementation. Auto injected object is an adaptive instance\uff08proxy\uff09 ,because the real implementation is confirmed only in execution stage.\u3002when adaptive spi is invoked, Dubbo will choose the real implementation and executes it. Dubbo choose the right implementation according to the parameters that the mehod defines. All the inner SPIs that Dubbo defines have the URL parameter defined for the method invocation. Adaptive SPI uses URL to determine which implementation is needed. One specific Key and Value in the URL confirms the usage of the specific implementation, All these is done by adding @Adaptive annotation. @Extension public interface Car { @Adaptive({ http://10.20.160.198/wiki/display/dubbo/car.type , http://10.20.160.198/wiki/display/dubbo/transport.type }) public run(URL url, Type1 arg1, Type2 arg2); } For the rules above\uff0cExtensionLoader will create a adaptive instance for each SPI injected. ExtensionLoader generated adaptive classes look like \uff1a package package name for SPI interface ; public class SPI interface name $Adpative implements SPI interface { public contains @Adaptive annotation method ( parameters ) { if(parameters containing URL Type?) using URL parameter else if(method returns URL) using the return URL # else throw exception,inject SPI fail\uff01 if(URL accquired == null) { throw new IllegalArgumentException( url == null ); } According to the Key order from @Adaptive annotation\uff0cget the Value from the URL as the real SPI name if no value is found then use the default SPI implementation\u3002If no SPI point\uff0c throw new IllegalStateException( Fail to get extension ); Invoke the method using the spi and return the result. } public method having annotation @Adaptive ( parameters ) { throw new UnsupportedOperationException( is not adaptive method! ); } } @Adaptive annotation usage\uff1a If no value is configed for those Keys in URL\uff0cdefault SPI implementation is used\u3002For example \uff0cString[] {\"key1\", \"key2\"}\uff0cfirstly Dubbo will look up value for key1 and use it as SPI name;if key1 value is not founded then look up for key2\uff0cif value of key2 is also not found ,then use default spi implementation. If no default implementation is configed, then the method will throw IllegalStateException\u3002if not configed , then default implement is lower case of the interface class full package name. For Extension interface org.apache.dubbo.xxx.YyyInvokerWrapper , default value is new String[] {\"yyy.invoker.wrapper\"}","title":"1. SPI Auto Adaptive"},{"location":"dev/code-smell/#callback-function","text":"","title":"Callback Function"},{"location":"dev/code-smell/#1-parameter-callback","text":"main theory \uff1a in the persistent connection for one consumer- provider\uff0cexport a service in Consumer side\uff0cprovider side can reversely call the instance in consumer side. Implement details\uff1a For exchanging interface instance in transmition, auto export and auto refer is implemented in DubboCodec . Need to seperate business logic and codec logic. you will need to judge whether needing callback when getting exporter from invocation\uff0cif needed, get the callback instance id from the attachments. By using this method, consumer side can implement the callback interface with different implementations.","title":"1. Parameter Callback"},{"location":"dev/code-smell/#2-event-notification","text":"main theory \uff1a when Consumer executing invoke method\uff0cjudging if any configuration for onreturn/onerror... put the method for onreturn to the callback list of the async invocatioin. Implement details\uff1aparameters is passed using URL\uff0cbut string-object is not supported for URL, so the method is stored in staticMap\uff0cit needs to be optimized.","title":"2. Event Notification"},{"location":"dev/code-smell/#lazy-connection","text":"DubboProtocol specific features, default disabled When client creating proxy for server, do not establish TCP persistent connection at first, only init the connecton when data is needing transmision. This feather will disable the connection retry policy , resend the data again(if connection is lost when sending data ,try to establish a new connection to send data)","title":"Lazy Connection"},{"location":"dev/code-smell/#share-connection","text":"DubboProtocol specific features, default enabled\u3002 JVM A export many services\uff0cJVM B refer more than one services of A\uff0cShare Connection means those different services invocations between A and B uses the same TCP connection to transmit data, reducing server connections. Implement details\uff1awhen using share connection for the same address\uff0cyou need pay more attention to the invoker's destroy action.on one hand, you should close the connection when all the invokers refering the same address is destroyed, on another hand ,you should not close the connection when not all of the invokers are destroyed. In design implementation, we uses a strategy called reference count , we create a connection called Lazy connection for exceptions not affacting business when closing the connection just in case.","title":"Share Connection"},{"location":"dev/code-smell/#sticky-policy","text":"when existing many providers and configing the sticky policy\uff0cinvocation will be sent to the same provider as last invocation. Sticky Policy opens the lazy attribute of connection, for avoiding open useless connectons.","title":"sticky policy"},{"location":"dev/code-smell/#provider-selecting-logic","text":"existing multi providers\uff0cfirstly select by Loadbalance \u3002If the selected provider is available ,then just doing the invocation If the selected provider is not available in stage 1, then choose from the remaining ,if available then doing the inovation If all providers are not available , rescan the list(not choosen invoker first),juding if any provider is available, if existing,doing the invocatiion. If no available provider in stage 3, then the next invoker of the invoker of stage 1 will be choosen(if not the last one),avoiding collision.","title":"provider selecting logic"},{"location":"dev/coding/","text":"Coding convention Code style The source and JavaDoc of Dubbo follow below specifications: Code Conventions for the Java Programming Language How to Write Doc Comments for the Javadoc Tool Exception and Logging Log more context information as possible, such as error reason, error server address, client address, registry center address, dubbo version and so on. Try to put the main cause at the front, and display all other context information with key-value paris after it. Log is not printed where the exception is thrown, log level is determined by the final exception handler, and must print log when dicarding exception. ERROR log means NEED TO ALARM, WARN log means COULD AUTO RECOVERY, INFO long mean NORMAL. Suggestion: config ERROR log in Monitor center for real-time alarm, summary and send WARN log weekly. RpcException is the ONLY external exception of Dubbo\uff0call internal exceptions mush be transfered to RpcException if need to throw out to user. RpcException CAN NOT have sub-class, all types of information are identified with ErrorCode in order to keep compatible. Configuration and URL Use initials and camelCase for multiple words for object properties [^1]. Use lowercase and split by '-' for multiple words for config properties [^2]. Use lowercase and split by '.' for multiple words for URL properties [^3]. Use URL transfer parameters as possible, Don't define Map or other types, config information also transfer to URL style. Minimize URL nesting to keep URL simplicity. Unit testing and integration testing Use JUnit and EasyMock for unit testing, use TestNG for integration testing, use DBUnit for database testing. Don't put large integration test case in unit testing for running speed of unit test case. Use try...finally or tearDown to release resource for all test cases of unit testing. Minimize test case that with while loop which need waiting repsonse, use to make the logic in timer as function for timer and net testing. For fail-safe testing, unified use LogUtil assertion log output. Extension point base class and AOP AOP class should be named as XxxWrapper \uff0cBase class should be named as AbstractXxx . Use AOP for combine relationship between extension points, ExtensionLoader only loads extension points, including AOP extension. Try to use Ioc inject dependency of extension points, Don't direct dependent on factory method of ExtensionLoader . Try to use AOP implement the common action of extension points, instead of using base class, such as the isAvailable checking before load balancing, which is independent of load balance. Close the URL paramters which no need to check. Use base class for abstaction for a variety of similar types, such as RMI, Hessian 3rd protocols which have generated interface proxy, only transfer interface proxy to Invoker to complete bridging, and public base class can do the logic. The base class is also part of the SPI, and each extension should have a convenient base class support. Module and packaging Base on reusability for packaging, dividing the interface, base class and large implementation into separate modules. Put all interfaces under the base package of module, and put base classes in support subpackage, different implementations are placed under the subpackage named by extension point. Try to keep subpackage dependent on parent package, NOT reverse. [^1]: Java convention [^2]: Spring convention [^3]: Dubbo convention","title":"Coding"},{"location":"dev/coding/#coding-convention","text":"","title":"Coding convention"},{"location":"dev/coding/#code-style","text":"The source and JavaDoc of Dubbo follow below specifications: Code Conventions for the Java Programming Language How to Write Doc Comments for the Javadoc Tool","title":"Code style"},{"location":"dev/coding/#exception-and-logging","text":"Log more context information as possible, such as error reason, error server address, client address, registry center address, dubbo version and so on. Try to put the main cause at the front, and display all other context information with key-value paris after it. Log is not printed where the exception is thrown, log level is determined by the final exception handler, and must print log when dicarding exception. ERROR log means NEED TO ALARM, WARN log means COULD AUTO RECOVERY, INFO long mean NORMAL. Suggestion: config ERROR log in Monitor center for real-time alarm, summary and send WARN log weekly. RpcException is the ONLY external exception of Dubbo\uff0call internal exceptions mush be transfered to RpcException if need to throw out to user. RpcException CAN NOT have sub-class, all types of information are identified with ErrorCode in order to keep compatible.","title":"Exception and Logging"},{"location":"dev/coding/#configuration-and-url","text":"Use initials and camelCase for multiple words for object properties [^1]. Use lowercase and split by '-' for multiple words for config properties [^2]. Use lowercase and split by '.' for multiple words for URL properties [^3]. Use URL transfer parameters as possible, Don't define Map or other types, config information also transfer to URL style. Minimize URL nesting to keep URL simplicity.","title":"Configuration and URL"},{"location":"dev/coding/#unit-testing-and-integration-testing","text":"Use JUnit and EasyMock for unit testing, use TestNG for integration testing, use DBUnit for database testing. Don't put large integration test case in unit testing for running speed of unit test case. Use try...finally or tearDown to release resource for all test cases of unit testing. Minimize test case that with while loop which need waiting repsonse, use to make the logic in timer as function for timer and net testing. For fail-safe testing, unified use LogUtil assertion log output.","title":"Unit testing and integration testing"},{"location":"dev/coding/#extension-point-base-class-and-aop","text":"AOP class should be named as XxxWrapper \uff0cBase class should be named as AbstractXxx . Use AOP for combine relationship between extension points, ExtensionLoader only loads extension points, including AOP extension. Try to use Ioc inject dependency of extension points, Don't direct dependent on factory method of ExtensionLoader . Try to use AOP implement the common action of extension points, instead of using base class, such as the isAvailable checking before load balancing, which is independent of load balance. Close the URL paramters which no need to check. Use base class for abstaction for a variety of similar types, such as RMI, Hessian 3rd protocols which have generated interface proxy, only transfer interface proxy to Invoker to complete bridging, and public base class can do the logic. The base class is also part of the SPI, and each extension should have a convenient base class support.","title":"Extension point base class and AOP"},{"location":"dev/coding/#module-and-packaging","text":"Base on reusability for packaging, dividing the interface, base class and large implementation into separate modules. Put all interfaces under the base package of module, and put base classes in support subpackage, different implementations are placed under the subpackage named by extension point. Try to keep subpackage dependent on parent package, NOT reverse. [^1]: Java convention [^2]: Spring convention [^3]: Dubbo convention","title":"Module and packaging"},{"location":"dev/contract/","text":"Public Agreement This document is Dubbo public agreement, we expect all extension points comply with it. URL All extension points must include URL parameter, design URL as a context information which throughouts the whole extension point design system. URL standard style: protocol://username:password@host:port/path?key=value key=value Logging Print ERROR log for unrecoverable and NEED TO ALARM situation. Print WARN log for recoverable exception or transient state inconsistency. Print INFO log for normally status.","title":"Contract"},{"location":"dev/contract/#public-agreement","text":"This document is Dubbo public agreement, we expect all extension points comply with it.","title":"Public Agreement"},{"location":"dev/contract/#url","text":"All extension points must include URL parameter, design URL as a context information which throughouts the whole extension point design system. URL standard style: protocol://username:password@host:port/path?key=value key=value","title":"URL"},{"location":"dev/contract/#logging","text":"Print ERROR log for unrecoverable and NEED TO ALARM situation. Print WARN log for recoverable exception or transient state inconsistency. Print INFO log for normally status.","title":"Logging"},{"location":"dev/contribution/","text":"table { width: 100%; max-width: 65em; border: 1px solid #dedede; margin: 15px auto; border-collapse: collapse; empty-cells: show; } table th, table td { height: 35px; border: 1px solid #dedede; padding: 0 10px; } table th { font-weight: bold; text-align: center !important; background: rgba(158,188,226,0.2); white-space: nowrap; } table tbody tr:nth-child(2n) { background: rgba(158,188,226,0.12); } table td:nth-child(1) { white-space: nowrap; } table tr:hover { background: #efefef; } .table-area { overflow: auto; } [].slice.call(document.querySelectorAll('table')).forEach(function(el){ var wrapper = document.createElement('div'); wrapper.className = 'table-area'; el.parentNode.insertBefore(wrapper, el); el.parentNode.removeChild(el); wrapper.appendChild(el); }) Contribution Flow Direct adding new project, black-box dependent on Dubbo for function extension. Fork Dubbo on Github for BUG fixing or modify the framework. Pull Request after changing. Tasks Funcation Type Priority Status Claimer Plan complete time progress Translation Document High Unclaimed Pending Pending 0% translation Document High Unclaimed Pending Pending 0% Extension point compatibility testing Testing High Claimed \u7f57\u7acb\u6811 Pending 0% Performance benchmark testing Testing High Unclaimed Pending Pending 0% Functional unit testing Testing High Unclaimed Pending Pending 0% JTA/XA distributed transaction Interceptor extension High Unclaimed Pending Pending 0% Thrift Protocol extension High Developing done \u95fe\u521a 2012-04-27 90% ICE Protocol extension High Unclaimed Pending Pending 0% ACE Protocol extension Low Unclaimed Pending Pending 0% JSON-RPC Protocol extension Low Unclaimed Pending Pending 0% XML-RPC Protocol extension Low Unclaimed Pending Pending 0% JSR181 CXF(WebService) Protocol extension High Developing done \u767d\u6587\u5fd7 2012-04-27 90% JSR311 JSR339(RestfulWebService) Protocol extension High Unclaimed Pending Pending 0% JMS ActiveMQ Protocol extension High Unclaimed Pending Pending 0% Protobuf Serialization extension High Researching \u6731\u542f\u6052 2012-02-30 20% Avro Serialization extension Low Unclaimed Pending Pending 0% XSocket Transmission extension Low Unclaimed Pending Pending 0% CGLib Dynamic proxy extension Low Unclaimed Pending Pending 0% JNDI Registry extension High Unclaimed Pending Pending 0% LDAP Registry extension Low Unclaimed Pending Pending 0% JSR140 SLP Registry extension High Unclaimed Pending Pending 0% UDDI Registry extension High Unclaimed Pending Pending 0% JMX Monitoring expansion High Unclaimed Pending Pending 0% SNMP Monitoring expansion High Unclaimed Pending Pending 0% Cacti Monitoring expansion High Unclaimed Pending Pending 0% Nagios Monitoring expansion High Unclaimed Pending Pending 0% Logstash Monitoring expansion High Unclaimed Pending Pending 0% JRobin Monitoring expansion High Unclaimed Pending Pending 0% Maven Package management Low Unclaimed Pending Pending 0% Subversion Package management Low Unclaimed Pending Pending 0% JCR/JSR283 Package management Low Unclaimed Pending Pending 0% SimpleDeployer Local deployment agent Low Unclaimed Pending Pending 0% SimpleScheduler Scheduler Low Unclaimed Pending Pending 0%","title":"Contribution"},{"location":"dev/contribution/#contribution","text":"","title":"Contribution"},{"location":"dev/contribution/#flow","text":"Direct adding new project, black-box dependent on Dubbo for function extension. Fork Dubbo on Github for BUG fixing or modify the framework. Pull Request after changing.","title":"Flow"},{"location":"dev/contribution/#tasks","text":"Funcation Type Priority Status Claimer Plan complete time progress Translation Document High Unclaimed Pending Pending 0% translation Document High Unclaimed Pending Pending 0% Extension point compatibility testing Testing High Claimed \u7f57\u7acb\u6811 Pending 0% Performance benchmark testing Testing High Unclaimed Pending Pending 0% Functional unit testing Testing High Unclaimed Pending Pending 0% JTA/XA distributed transaction Interceptor extension High Unclaimed Pending Pending 0% Thrift Protocol extension High Developing done \u95fe\u521a 2012-04-27 90% ICE Protocol extension High Unclaimed Pending Pending 0% ACE Protocol extension Low Unclaimed Pending Pending 0% JSON-RPC Protocol extension Low Unclaimed Pending Pending 0% XML-RPC Protocol extension Low Unclaimed Pending Pending 0% JSR181 CXF(WebService) Protocol extension High Developing done \u767d\u6587\u5fd7 2012-04-27 90% JSR311 JSR339(RestfulWebService) Protocol extension High Unclaimed Pending Pending 0% JMS ActiveMQ Protocol extension High Unclaimed Pending Pending 0% Protobuf Serialization extension High Researching \u6731\u542f\u6052 2012-02-30 20% Avro Serialization extension Low Unclaimed Pending Pending 0% XSocket Transmission extension Low Unclaimed Pending Pending 0% CGLib Dynamic proxy extension Low Unclaimed Pending Pending 0% JNDI Registry extension High Unclaimed Pending Pending 0% LDAP Registry extension Low Unclaimed Pending Pending 0% JSR140 SLP Registry extension High Unclaimed Pending Pending 0% UDDI Registry extension High Unclaimed Pending Pending 0% JMX Monitoring expansion High Unclaimed Pending Pending 0% SNMP Monitoring expansion High Unclaimed Pending Pending 0% Cacti Monitoring expansion High Unclaimed Pending Pending 0% Nagios Monitoring expansion High Unclaimed Pending Pending 0% Logstash Monitoring expansion High Unclaimed Pending Pending 0% JRobin Monitoring expansion High Unclaimed Pending Pending 0% Maven Package management Low Unclaimed Pending Pending 0% Subversion Package management Low Unclaimed Pending Pending 0% JCR/JSR283 Package management Low Unclaimed Pending Pending 0% SimpleDeployer Local deployment agent Low Unclaimed Pending Pending 0% SimpleScheduler Scheduler Low Unclaimed Pending Pending 0%","title":"Tasks"},{"location":"dev/design/","text":"Framework Design Overall design Image description: Left area with light blue background shows service consumer interfaces, Right area with light green background shows service provider interfaces, center area shows both side interfaces. The image is divided into 10 layers from the bottom to the top, and the layers are one-way dependence. The black arrow on the right represents the dependency between layers, and each layer can be stripped from the upper layer to be reused, the Service and Config layers are API, and the other layers are SPI. Green boxes are extension interfaces, blue boxes are implementation classes, image only shows implementation class of associated layers. The blue dashed line is the initialization process, which is assembly chain when starting, red line for the method call process, which is calling chain when running, purple triangle arrow is inherited, can treat subclass as the same node of parent class, text of lines are the method invocation. Layer description config layer : external config interface, ServiceConfig and ReferenceConfig is the center of the layer, you can directly initialize config class, also can generate config class by spring. proxy layer : transparent proxy of service interface, generate client Stub of service and server Skeletion of service, ServiceProxy is the center, extension interface is ProxyFactory . registry layer : encapsulation of service registry and discovery, service URL is the center, extension interfaces are RegistryFactory , Registry and RegistryService . cluster layer : encapsulation of cluster of muliple providers and load balance, and bridging registration center, Invoker is the center, extension interfaces are Cluster , Directory , Router , LoadBalance . monitor layer : monitor of RPC call times and call execute time, Statistics is the center, extension interface are MonitorFactory , Monitor , MonitorService protocol layer : encapsulation of RPC, Invocation and Result are the center, extension interfaces are Protocol , Invoker , Exporter exchange layer : encapsulation of request and response, synchronous transfer asynchronous, Request and Response are the center, extension interfaces are Exchanger , ExchangeChannel , ExchangeClient , ExchangeServer transport layer : abstraction of mina and netty, Message is the center, extension interfaces are Channel , Transporter , Client , Server , Codec serialize layer : reusable tools, extension interfaces are Serialization , ObjectInput , ObjectOutput , ThreadPool Relationship description In RPC, Protocol is the core layer, it means that you can complete RPC calling by Protocol + Invoker + Exporter, then filter at the main process of Invoker. Consumer and Provider are abstraction concepts, just want you have a more intuitive understanding of which classes belong to the client and server side, the reason not use Client and Server is that Dubbo uses Provider, Consumer, Registry, Monitor divide logical topology node in many scenes, keep the concept of unity. Cluster is external concept, the purpose of Cluster is that make various Invoker disguise to one Invoker, so that we just pay attention to the Invoker in Protocol layer, adding Cluster or removing Cluster will not affect other layers, because we don't need Cluster when only have one provider. The Proxy layer encapsulates the transparent proxy for all interfaces, and in other layers with Invoker as the center, turn Invoker into interface, or turn interface implementation into Invoker by Proxy only when exposuring to user. RPC still work even removing Proxy layer, but not so transparent, making remote service calling don't look like local service calling. Remoting is the implemetation of Dubbo protocols, you can remove Remoting if choosing RMI. The Remoting is divided into Transport layer and Exchange layer, Transport layer is responsible for one-way message transmission, it's abstraction of Mina, Netty, Grizzly, it also can extend UDP transmission. The Exchange layer encapsulates the Request-Response semantics over the transport layer. Actually Registry and Monitor are not at the same layer, they are independent nodes, draw them together by layer just for global view. Modules packaging Modules description: dubbo-common module : includes Util classes and common modules. dubbo-remoting module : is Dubbo protocol implementation, no need to use this module if using RMI for RPC. dubbo-rpc module : abstraction of various protocols, and dynamic proxy, only one to one call, not concerned with the management of cluster. dubbo-cluster module : disguise many service providers as one provider, including load balancing, fault tolerance, routing, etc. the address list of clusters can be either static or send by registry. dubbo-registry module : Based on the cluster of registry send address and the abstraction of various registry centers. dubbo-monitor module : statistics of service call times, call time, call chain tracked services. dubbo-config module : is Dubbo external API, users use Dubbo by Config, hide Dubbo details. dubbo-container module : is a Standlone container, just use Main method to load Spring, because usually service no need Tomcat/JBoss features. Package dividing according to the layer structure, and the difference with layer dividing: container is service container, for service running deployment, not showed in the image. protocol layer and proxy layer are placed in RPC module, they are the core of RPC module, you can use these 2 layers complete RPC call when only have 1 provider. transport layer and exchange layer are placed in remoting module, for RPC call base comminucation. serialize layer is placed in common module, for reuse. Dependence relationship Image description: The boxes in image, Protocol, Cluster, Proxy, Service, Container, Registry, Monitor represent layer or module, the blues mean interactive with business, the greens mean only internal interactive with Dubbo. The backgroud boxes in image, Consumer, Provider, Registry, Monitor represent deployment logical topology node. The blue dashed line in the image is called for initialization, the red dashed line is called asynchronously for runtime, and the red line is called synchronously for runtime. The image only includes RPC layer, don't includes Remoting layer, the whole Remoting hides in Protocol layer. Call chain Expand the red call chain of the overall design map: Expose service sequence Expand the initialization chain of service provider exposes service which at the left of the overall design map, the sequence diagram shows below: Reference service sequence Expand the initialization chain of service consumer references service which at the right of the overall design map, the sequence diagram shows below: Domain model The core domain models of Dubbo: Protocol is service domain, it is the main function entrance of Invoker exposure and reference, it is responsible for the life cycle management of Invoker. Invoker is entity domain, it is the core model of Dubbo, all the other models are disturbed, or converted to it, it represents an executable, you can call it by calling invoke, it can be a local implementation, a remote implementation, or a cluster implementation. Invocation is session domain, it holds variables in the calling process, such as the method name, the parameters, and so on. Base design principle Use Microkernel + Plugin design pattern\uff0cMicrokernel only responsible for assembly Plugin, the functions of Dubbo are implemented by extension points, it means that all functions of Dubbo can be replaced by self defined extension by user. Use URL to be the startdard format of config information, all extension points transfer config information by URL. More design principles refer to: Framework design principle","title":"Architecture"},{"location":"dev/design/#framework-design","text":"","title":"Framework Design"},{"location":"dev/design/#overall-design","text":"Image description: Left area with light blue background shows service consumer interfaces, Right area with light green background shows service provider interfaces, center area shows both side interfaces. The image is divided into 10 layers from the bottom to the top, and the layers are one-way dependence. The black arrow on the right represents the dependency between layers, and each layer can be stripped from the upper layer to be reused, the Service and Config layers are API, and the other layers are SPI. Green boxes are extension interfaces, blue boxes are implementation classes, image only shows implementation class of associated layers. The blue dashed line is the initialization process, which is assembly chain when starting, red line for the method call process, which is calling chain when running, purple triangle arrow is inherited, can treat subclass as the same node of parent class, text of lines are the method invocation.","title":"Overall design"},{"location":"dev/design/#layer-description","text":"config layer : external config interface, ServiceConfig and ReferenceConfig is the center of the layer, you can directly initialize config class, also can generate config class by spring. proxy layer : transparent proxy of service interface, generate client Stub of service and server Skeletion of service, ServiceProxy is the center, extension interface is ProxyFactory . registry layer : encapsulation of service registry and discovery, service URL is the center, extension interfaces are RegistryFactory , Registry and RegistryService . cluster layer : encapsulation of cluster of muliple providers and load balance, and bridging registration center, Invoker is the center, extension interfaces are Cluster , Directory , Router , LoadBalance . monitor layer : monitor of RPC call times and call execute time, Statistics is the center, extension interface are MonitorFactory , Monitor , MonitorService protocol layer : encapsulation of RPC, Invocation and Result are the center, extension interfaces are Protocol , Invoker , Exporter exchange layer : encapsulation of request and response, synchronous transfer asynchronous, Request and Response are the center, extension interfaces are Exchanger , ExchangeChannel , ExchangeClient , ExchangeServer transport layer : abstraction of mina and netty, Message is the center, extension interfaces are Channel , Transporter , Client , Server , Codec serialize layer : reusable tools, extension interfaces are Serialization , ObjectInput , ObjectOutput , ThreadPool","title":"Layer description"},{"location":"dev/design/#relationship-description","text":"In RPC, Protocol is the core layer, it means that you can complete RPC calling by Protocol + Invoker + Exporter, then filter at the main process of Invoker. Consumer and Provider are abstraction concepts, just want you have a more intuitive understanding of which classes belong to the client and server side, the reason not use Client and Server is that Dubbo uses Provider, Consumer, Registry, Monitor divide logical topology node in many scenes, keep the concept of unity. Cluster is external concept, the purpose of Cluster is that make various Invoker disguise to one Invoker, so that we just pay attention to the Invoker in Protocol layer, adding Cluster or removing Cluster will not affect other layers, because we don't need Cluster when only have one provider. The Proxy layer encapsulates the transparent proxy for all interfaces, and in other layers with Invoker as the center, turn Invoker into interface, or turn interface implementation into Invoker by Proxy only when exposuring to user. RPC still work even removing Proxy layer, but not so transparent, making remote service calling don't look like local service calling. Remoting is the implemetation of Dubbo protocols, you can remove Remoting if choosing RMI. The Remoting is divided into Transport layer and Exchange layer, Transport layer is responsible for one-way message transmission, it's abstraction of Mina, Netty, Grizzly, it also can extend UDP transmission. The Exchange layer encapsulates the Request-Response semantics over the transport layer. Actually Registry and Monitor are not at the same layer, they are independent nodes, draw them together by layer just for global view.","title":"Relationship description"},{"location":"dev/design/#modules-packaging","text":"Modules description: dubbo-common module : includes Util classes and common modules. dubbo-remoting module : is Dubbo protocol implementation, no need to use this module if using RMI for RPC. dubbo-rpc module : abstraction of various protocols, and dynamic proxy, only one to one call, not concerned with the management of cluster. dubbo-cluster module : disguise many service providers as one provider, including load balancing, fault tolerance, routing, etc. the address list of clusters can be either static or send by registry. dubbo-registry module : Based on the cluster of registry send address and the abstraction of various registry centers. dubbo-monitor module : statistics of service call times, call time, call chain tracked services. dubbo-config module : is Dubbo external API, users use Dubbo by Config, hide Dubbo details. dubbo-container module : is a Standlone container, just use Main method to load Spring, because usually service no need Tomcat/JBoss features. Package dividing according to the layer structure, and the difference with layer dividing: container is service container, for service running deployment, not showed in the image. protocol layer and proxy layer are placed in RPC module, they are the core of RPC module, you can use these 2 layers complete RPC call when only have 1 provider. transport layer and exchange layer are placed in remoting module, for RPC call base comminucation. serialize layer is placed in common module, for reuse.","title":"Modules packaging"},{"location":"dev/design/#dependence-relationship","text":"Image description: The boxes in image, Protocol, Cluster, Proxy, Service, Container, Registry, Monitor represent layer or module, the blues mean interactive with business, the greens mean only internal interactive with Dubbo. The backgroud boxes in image, Consumer, Provider, Registry, Monitor represent deployment logical topology node. The blue dashed line in the image is called for initialization, the red dashed line is called asynchronously for runtime, and the red line is called synchronously for runtime. The image only includes RPC layer, don't includes Remoting layer, the whole Remoting hides in Protocol layer.","title":"Dependence relationship"},{"location":"dev/design/#call-chain","text":"Expand the red call chain of the overall design map:","title":"Call chain"},{"location":"dev/design/#expose-service-sequence","text":"Expand the initialization chain of service provider exposes service which at the left of the overall design map, the sequence diagram shows below:","title":"Expose service sequence"},{"location":"dev/design/#reference-service-sequence","text":"Expand the initialization chain of service consumer references service which at the right of the overall design map, the sequence diagram shows below:","title":"Reference service sequence"},{"location":"dev/design/#domain-model","text":"The core domain models of Dubbo: Protocol is service domain, it is the main function entrance of Invoker exposure and reference, it is responsible for the life cycle management of Invoker. Invoker is entity domain, it is the core model of Dubbo, all the other models are disturbed, or converted to it, it represents an executable, you can call it by calling invoke, it can be a local implementation, a remote implementation, or a cluster implementation. Invocation is session domain, it holds variables in the calling process, such as the method name, the parameters, and so on.","title":"Domain model"},{"location":"dev/design/#base-design-principle","text":"Use Microkernel + Plugin design pattern\uff0cMicrokernel only responsible for assembly Plugin, the functions of Dubbo are implemented by extension points, it means that all functions of Dubbo can be replaced by self defined extension by user. Use URL to be the startdard format of config information, all extension points transfer config information by URL. More design principles refer to: Framework design principle","title":"Base design principle"},{"location":"dev/implementation/","text":"Implementation details Initialization details Service parsing Based on META-INF/spring.handlers config in dubbo.jar, Spring calls DubboNamespaceHandler when meeting dubbo namespace. All Dubbo tags are parsed by DubboBeanDefinitionParser , based on one to one attribute mapping, the XML label is parsed as a Bean object. Transfer Bean object to URL, and transfer all attributes of Bean to URL parameters when ServiceConfig.export() or ReferenceConfig.get() initialization. Then pase URL to Protocol extension point , based on Extension point adaptive mechanism of extension point, processing service exposure or reference for different protocols according to URL protocol header. Service Exposure 1. Only expose service port: Direct exposing to provider when have not Registry, [^1], the URL format which parsing by ServiceConfig : dubbo://service-host/com.foo.FooService?version=1.0.0 . Based on extension point adaptive mechanism, call export() method of DubboProtocol and open server port by identifying dubbo:// protocol header of URL. 2. Expose to Registry: Expose provider address to Registry [^2], the URL format which parsing by ServiceConfig : registry://registry-host/org.apache.dubbo.registry.RegistryService?export=URL.encode(\"dubbo://service-host/com.foo.FooService?version=1.0.0\") \uff0c Based on extension point adaptive mechanism, call export() method of RegistryProtocol by identifying registry:// protocol header, register the provider URL parameter of export to Registry. Resend to Protocol extension point to do exposure: dubbo://service-host/com.foo.FooService?version=1.0.0 , then based on extension point adaptive mechanism, call export() method of DubboProtocol and open server port by identifying dubbo:// protocol header of provider URL. Service Reference 1. Direct connect service Direct connect provider when have not Registry [^3], the URL format which parsing by ReferenceConfig : dubbo://service-host/com.foo.FooService?version=1.0.0 . Based on extension point adaptive mechanism, call refer() method of DubboProtocol by identifying dubbo:// protocol header of URL, and return provider reference. 2. Service Registry discovery Discover provider address by Registry [^4], the URL format which parsing by ReferenceConfig : registry://registry-host/org.apache.dubbo.registry.RegistryService?refer=URL.encode(\"consumer://consumer-host/com.foo.FooService?version=1.0.0\") . Based on extension point adaptive mechanism, call refer() method of RegistryProtocol by identifying registry:// protocol header of URL, then based on the condition of parameter of refer to search provider URL, for example: dubbo://service-host/com.foo.FooService?version=1.0.0 . Then based on extension point adaptive mechanism, call refer() method of DubboProtocol to get provider reference by identifying dubbo:// protocol header of provider URL. Then RegistryProtocol disguise various provider references to single provider by Cluster extension point and return. Service Filter Based on extension point adaptive mechanism, all Protocol extension points are auto wrapped Wrapper class. Based on ProtocolFilterWrapper class, make all Filter as chain, call the real reference at the end of the chain. Based on ProtocolListenerWrapper class, make all InvokerListener and ExporterListener as list, perform call back before and after exposure and reference. All additional functions would be implementated by Filter , including Monitor. RPC details The detail process of exposing service by service provider The above image shows the main process of exposing service by service provider: First ServiceConfig class get the actual class ref that provides service(e.g. \u5982\uff1aHelloWorldImpl), then generating a AbstractProxyInvoker instance by the getInvoker method of ProxyFactory class, to this step, complete the transformation of specific service to Invoker , next is the process of converting Invoker to Exporter . The key of Dubbo processing service exposure is the process of converting Invoker to Exporter , the red part in the above image. Here we introduce the implementation of the two typical protocols, Dubbo and RMI: Dubbo implementation The transformation from Invoker of Dubbo protocol to Exporter takes place in the export method of DubboProtocol class, it mainly opens the socket to listen service and receive all kinds of requests sent by the client, and the communication details are implementated by Dubbo itself. RMI implementation The transformation from Invoker of RMI protocol to Exporter takes place in the export method of RmiProtocol class, the RMI service is implementated by Spring, Dubbo or JDK, and the communication details are implementated by JDK, which saves a lot of work. The detail process of serving service for service consumer The above image is the main process of service consumption: First, the init method of ReferenceConfig class calls the refer method of Protocol to generate Invoker instance(such as the red part in the above image), which is the key of service consumption. Then the Invoker is converted to the interface required by the client (such as: HelloWorld). For each protocol such as RMI/Dubbo/Web service, the details they call refer method generate Invoker instance are similar to the previous section. Invoker everywhere Because of Invoker is a very important concept in the Dubbo domain model, many of the design ideas are close to it. This makes Invoker permeate the entire implementation code, and it's really easy to mix up for people who have just started Dubbo. Let's use a simple image below to describe the 2 important Invoker : service provider Invoker and service consumer Invoker : To better explain the above image, we provide the below code examples of service consumption and providers: Service consumer code: public class DemoClientAction { private DemoService demoService; public void setDemoService(DemoService demoService) { this.demoService = demoService; } public void start() { String hello = demoService.sayHello( world ); } } The DemoService in above code is the proxy of service consumer in above image, user can call Invoker [^5] which implementate the real RPC by the proxy. Service provider code: public class DemoServiceImpl implements DemoService { public String sayHello(String name) throws RemoteException { return Hello + name; } } The above class would be encapsulated to be a AbstractProxyInvoker instance, and create a new Exporter instance, then find corresponding Exporter instance and call its corresponding AbstractProxyInvoker instance when network communication layer recieve request, so that real call service provider code. There are some other Invoker classes, but the above 2 are the most important. Remote communication details Protocol header agreement Thread dispatch model Dispather: all , direct , message , execution , connection ThreadPool: fixed , cached [^1]: is dubbo:service regisrty=\"N/A\" / or dubbo:registry address=\"N/A\" / [^2]: is dubbo:registry address=\"zookeeper://10.20.153.10:2181\" / [^3]: is dubbo:reference url=\"dubbo://service-host/com.foo.FooService?version=1.0.0\" / [^4]: is dubbo:registry address=\"zookeeper://10.20.153.10:2181\" / [^5]: is one of DubboInvoker , HessianRpcInvoker , InjvmInvoker , RmiInvoker , WebServiceInvoker","title":"Init, Process, Protocols"},{"location":"dev/implementation/#implementation-details","text":"","title":"Implementation details"},{"location":"dev/implementation/#initialization-details","text":"","title":"Initialization details"},{"location":"dev/implementation/#service-parsing","text":"Based on META-INF/spring.handlers config in dubbo.jar, Spring calls DubboNamespaceHandler when meeting dubbo namespace. All Dubbo tags are parsed by DubboBeanDefinitionParser , based on one to one attribute mapping, the XML label is parsed as a Bean object. Transfer Bean object to URL, and transfer all attributes of Bean to URL parameters when ServiceConfig.export() or ReferenceConfig.get() initialization. Then pase URL to Protocol extension point , based on Extension point adaptive mechanism of extension point, processing service exposure or reference for different protocols according to URL protocol header.","title":"Service parsing"},{"location":"dev/implementation/#service-exposure","text":"","title":"Service Exposure"},{"location":"dev/implementation/#1-only-expose-service-port","text":"Direct exposing to provider when have not Registry, [^1], the URL format which parsing by ServiceConfig : dubbo://service-host/com.foo.FooService?version=1.0.0 . Based on extension point adaptive mechanism, call export() method of DubboProtocol and open server port by identifying dubbo:// protocol header of URL.","title":"1. Only expose service port:"},{"location":"dev/implementation/#2-expose-to-registry","text":"Expose provider address to Registry [^2], the URL format which parsing by ServiceConfig : registry://registry-host/org.apache.dubbo.registry.RegistryService?export=URL.encode(\"dubbo://service-host/com.foo.FooService?version=1.0.0\") \uff0c Based on extension point adaptive mechanism, call export() method of RegistryProtocol by identifying registry:// protocol header, register the provider URL parameter of export to Registry. Resend to Protocol extension point to do exposure: dubbo://service-host/com.foo.FooService?version=1.0.0 , then based on extension point adaptive mechanism, call export() method of DubboProtocol and open server port by identifying dubbo:// protocol header of provider URL.","title":"2. Expose to Registry:"},{"location":"dev/implementation/#service-reference","text":"","title":"Service Reference"},{"location":"dev/implementation/#1-direct-connect-service","text":"Direct connect provider when have not Registry [^3], the URL format which parsing by ReferenceConfig : dubbo://service-host/com.foo.FooService?version=1.0.0 . Based on extension point adaptive mechanism, call refer() method of DubboProtocol by identifying dubbo:// protocol header of URL, and return provider reference.","title":"1. Direct connect service"},{"location":"dev/implementation/#2-service-registry-discovery","text":"Discover provider address by Registry [^4], the URL format which parsing by ReferenceConfig : registry://registry-host/org.apache.dubbo.registry.RegistryService?refer=URL.encode(\"consumer://consumer-host/com.foo.FooService?version=1.0.0\") . Based on extension point adaptive mechanism, call refer() method of RegistryProtocol by identifying registry:// protocol header of URL, then based on the condition of parameter of refer to search provider URL, for example: dubbo://service-host/com.foo.FooService?version=1.0.0 . Then based on extension point adaptive mechanism, call refer() method of DubboProtocol to get provider reference by identifying dubbo:// protocol header of provider URL. Then RegistryProtocol disguise various provider references to single provider by Cluster extension point and return.","title":"2. Service Registry discovery"},{"location":"dev/implementation/#service-filter","text":"Based on extension point adaptive mechanism, all Protocol extension points are auto wrapped Wrapper class. Based on ProtocolFilterWrapper class, make all Filter as chain, call the real reference at the end of the chain. Based on ProtocolListenerWrapper class, make all InvokerListener and ExporterListener as list, perform call back before and after exposure and reference. All additional functions would be implementated by Filter , including Monitor.","title":"Service Filter"},{"location":"dev/implementation/#rpc-details","text":"","title":"RPC details"},{"location":"dev/implementation/#the-detail-process-of-exposing-service-by-service-provider","text":"The above image shows the main process of exposing service by service provider: First ServiceConfig class get the actual class ref that provides service(e.g. \u5982\uff1aHelloWorldImpl), then generating a AbstractProxyInvoker instance by the getInvoker method of ProxyFactory class, to this step, complete the transformation of specific service to Invoker , next is the process of converting Invoker to Exporter . The key of Dubbo processing service exposure is the process of converting Invoker to Exporter , the red part in the above image. Here we introduce the implementation of the two typical protocols, Dubbo and RMI:","title":"The detail process of exposing service by service provider"},{"location":"dev/implementation/#dubbo-implementation","text":"The transformation from Invoker of Dubbo protocol to Exporter takes place in the export method of DubboProtocol class, it mainly opens the socket to listen service and receive all kinds of requests sent by the client, and the communication details are implementated by Dubbo itself.","title":"Dubbo implementation"},{"location":"dev/implementation/#rmi-implementation","text":"The transformation from Invoker of RMI protocol to Exporter takes place in the export method of RmiProtocol class, the RMI service is implementated by Spring, Dubbo or JDK, and the communication details are implementated by JDK, which saves a lot of work.","title":"RMI implementation"},{"location":"dev/implementation/#the-detail-process-of-serving-service-for-service-consumer","text":"The above image is the main process of service consumption: First, the init method of ReferenceConfig class calls the refer method of Protocol to generate Invoker instance(such as the red part in the above image), which is the key of service consumption. Then the Invoker is converted to the interface required by the client (such as: HelloWorld). For each protocol such as RMI/Dubbo/Web service, the details they call refer method generate Invoker instance are similar to the previous section.","title":"The detail process of serving service for service consumer"},{"location":"dev/implementation/#invoker-everywhere","text":"Because of Invoker is a very important concept in the Dubbo domain model, many of the design ideas are close to it. This makes Invoker permeate the entire implementation code, and it's really easy to mix up for people who have just started Dubbo. Let's use a simple image below to describe the 2 important Invoker : service provider Invoker and service consumer Invoker : To better explain the above image, we provide the below code examples of service consumption and providers: Service consumer code: public class DemoClientAction { private DemoService demoService; public void setDemoService(DemoService demoService) { this.demoService = demoService; } public void start() { String hello = demoService.sayHello( world ); } } The DemoService in above code is the proxy of service consumer in above image, user can call Invoker [^5] which implementate the real RPC by the proxy. Service provider code: public class DemoServiceImpl implements DemoService { public String sayHello(String name) throws RemoteException { return Hello + name; } } The above class would be encapsulated to be a AbstractProxyInvoker instance, and create a new Exporter instance, then find corresponding Exporter instance and call its corresponding AbstractProxyInvoker instance when network communication layer recieve request, so that real call service provider code. There are some other Invoker classes, but the above 2 are the most important.","title":"Invoker everywhere"},{"location":"dev/implementation/#remote-communication-details","text":"","title":"Remote communication details"},{"location":"dev/implementation/#protocol-header-agreement","text":"","title":"Protocol header agreement"},{"location":"dev/implementation/#thread-dispatch-model","text":"Dispather: all , direct , message , execution , connection ThreadPool: fixed , cached [^1]: is dubbo:service regisrty=\"N/A\" / or dubbo:registry address=\"N/A\" / [^2]: is dubbo:registry address=\"zookeeper://10.20.153.10:2181\" / [^3]: is dubbo:reference url=\"dubbo://service-host/com.foo.FooService?version=1.0.0\" / [^4]: is dubbo:registry address=\"zookeeper://10.20.153.10:2181\" / [^5]: is one of DubboInvoker , HessianRpcInvoker , InjvmInvoker , RmiInvoker , WebServiceInvoker","title":"Thread dispatch model"},{"location":"dev/introduction/","text":"","title":"Introduction"},{"location":"dev/release/","text":"Versions New feature development and stability improvement are equally important to product. But adding new features will affect stability, dubbo uses the following version development pattern to achieve a good balance. Two versions evolving at the same time BugFix Version\uff1alow version\uff0ce.g. 2.4.x . This is called the GA version, which can be applied in production. We are supposed only to fix bugs in this version, and increase the third version number when release. Feature Version\uff1ahigh version, e.g. 2.5.x . We add new features to this version, so applications have opportunities try new features. When features in 2.5.x are proved stable enough, we will announce 2.5.x as a beta release. When 2.5.x proved stable after enough test on enough applications\uff1a 2.5.x , the GA Version, only do BugFix, the main version to be used. We can try to promote applications to upgrade to GA at the desired time. 2.4.x , no longer maintained. When bugs appear, applications have no choice but upgrade to the latest stable version- Sunset Clause We create a new branch 2.6.0 based on 2.5.x for new features. Pros GA Version are promised stable: only BugFix GA Version got enough tests before promotion New features can respond quickly in Feature Version and allow applications to try that Significantly reduces development and maintenance costs The responsibilities of users Users should always keep in track with the GA Version, make sure all bugs were fixed. There is a fake proposition: regular upgrades bring more risks. Here's the reasons: GA remains stable after a trial period. Bugs find on GA will be fixed immediately. Comparing with the on-need-upgrade (only upgrade when find a serious problem, and may span multiple versions), upgrade periodically can flat risk. Experienced a long cycle of large projects, students will have such an experience, the tripartite library version does not upgrade for a long time, the result of the problem had to upgrade to the new version (across multiple versions) a huge risk.","title":"Release"},{"location":"dev/release/#versions","text":"New feature development and stability improvement are equally important to product. But adding new features will affect stability, dubbo uses the following version development pattern to achieve a good balance.","title":"Versions"},{"location":"dev/release/#two-versions-evolving-at-the-same-time","text":"BugFix Version\uff1alow version\uff0ce.g. 2.4.x . This is called the GA version, which can be applied in production. We are supposed only to fix bugs in this version, and increase the third version number when release. Feature Version\uff1ahigh version, e.g. 2.5.x . We add new features to this version, so applications have opportunities try new features. When features in 2.5.x are proved stable enough, we will announce 2.5.x as a beta release. When 2.5.x proved stable after enough test on enough applications\uff1a 2.5.x , the GA Version, only do BugFix, the main version to be used. We can try to promote applications to upgrade to GA at the desired time. 2.4.x , no longer maintained. When bugs appear, applications have no choice but upgrade to the latest stable version- Sunset Clause We create a new branch 2.6.0 based on 2.5.x for new features.","title":"Two versions evolving at the same time"},{"location":"dev/release/#pros","text":"GA Version are promised stable: only BugFix GA Version got enough tests before promotion New features can respond quickly in Feature Version and allow applications to try that Significantly reduces development and maintenance costs","title":"Pros"},{"location":"dev/release/#the-responsibilities-of-users","text":"Users should always keep in track with the GA Version, make sure all bugs were fixed. There is a fake proposition: regular upgrades bring more risks. Here's the reasons: GA remains stable after a trial period. Bugs find on GA will be fixed immediately. Comparing with the on-need-upgrade (only upgrade when find a serious problem, and may span multiple versions), upgrade periodically can flat risk. Experienced a long cycle of large projects, students will have such an experience, the tripartite library version does not upgrade for a long time, the result of the problem had to upgrade to the new version (across multiple versions) a huge risk.","title":"The responsibilities of users"},{"location":"dev/impls/cache/","text":"Cache Extension Summary Cache the return value, use request parameter as the key. Extension Interface org.apache.dubbo.cache.CacheFactory Extension Configuration dubbo:service cache= lru / !-- method level cache -- dubbo:service dubbo:method cache= lru / /dubbo:service !-- \u7f3a\u7701\u503c\u8bbe\u7f6e\uff0c\u5f53 dubbo:service \u6ca1\u6709\u914d\u7f6ecache\u5c5e\u6027\u65f6\uff0c\u4f7f\u7528\u6b64\u914d\u7f6e -- !-- default configuration, will take affect if cache attribute isn't configured in dubbo:service -- dubbo:provider cache= xxx,yyy / Existing Extensions org.apache.dubbo.cache.support.lru.LruCacheFactory org.apache.dubbo.cache.support.threadlocal.ThreadLocalCacheFactory org.apache.dubbo.cache.support.jcache.JCacheFactory Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxCacheFactory.java (CacheFactory implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.cache.CacheFactory (plain text file with contents: xxx=com.xxx.XxxCacheFactory) XxxCacheFactory.java\uff1a package com.xxx; import org.apache.dubbo.cache.CacheFactory; public class XxxCacheFactory implements CacheFactory { public Cache getCache(URL url, String name) { return new XxxCache(url, name); } } XxxCacheFactory.java\uff1a package com.xxx; import org.apache.dubbo.cache.Cache; public class XxxCache implements Cache { public Cache(URL url, String name) { // ... } public void put(Object key, Object value) { // ... } public Object get(Object key) { // ... } } META-INF/dubbo/org.apache.dubbo.cache.CacheFactory\uff1a xxx=com.xxx.XxxCacheFactory","title":"Cache"},{"location":"dev/impls/cache/#cache-extension","text":"","title":"Cache Extension"},{"location":"dev/impls/cache/#summary","text":"Cache the return value, use request parameter as the key.","title":"Summary"},{"location":"dev/impls/cache/#extension-interface","text":"org.apache.dubbo.cache.CacheFactory","title":"Extension Interface"},{"location":"dev/impls/cache/#extension-configuration","text":"dubbo:service cache= lru / !-- method level cache -- dubbo:service dubbo:method cache= lru / /dubbo:service !-- \u7f3a\u7701\u503c\u8bbe\u7f6e\uff0c\u5f53 dubbo:service \u6ca1\u6709\u914d\u7f6ecache\u5c5e\u6027\u65f6\uff0c\u4f7f\u7528\u6b64\u914d\u7f6e -- !-- default configuration, will take affect if cache attribute isn't configured in dubbo:service -- dubbo:provider cache= xxx,yyy /","title":"Extension Configuration"},{"location":"dev/impls/cache/#existing-extensions","text":"org.apache.dubbo.cache.support.lru.LruCacheFactory org.apache.dubbo.cache.support.threadlocal.ThreadLocalCacheFactory org.apache.dubbo.cache.support.jcache.JCacheFactory","title":"Existing Extensions"},{"location":"dev/impls/cache/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxCacheFactory.java (CacheFactory implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.cache.CacheFactory (plain text file with contents: xxx=com.xxx.XxxCacheFactory) XxxCacheFactory.java\uff1a package com.xxx; import org.apache.dubbo.cache.CacheFactory; public class XxxCacheFactory implements CacheFactory { public Cache getCache(URL url, String name) { return new XxxCache(url, name); } } XxxCacheFactory.java\uff1a package com.xxx; import org.apache.dubbo.cache.Cache; public class XxxCache implements Cache { public Cache(URL url, String name) { // ... } public void put(Object key, Object value) { // ... } public Object get(Object key) { // ... } } META-INF/dubbo/org.apache.dubbo.cache.CacheFactory\uff1a xxx=com.xxx.XxxCacheFactory","title":"Extension Guide"},{"location":"dev/impls/cluster/","text":"Cluster Extension Summary Group service providers in a cluster, and treat them as one single provider. Extension Interface org.apache.dubbo.rpc.cluster.Cluster Extension Configuration dubbo:protocol cluster= xxx / !-- default configuration, will take affect if cluster attribute is not configured in dubbo:protocol -- dubbo:provider cluster= xxx / Existing Extensions org.apache.dubbo.rpc.cluster.support.FailoverCluster org.apache.dubbo.rpc.cluster.support.FailfastCluster org.apache.dubbo.rpc.cluster.support.FailsafeCluster org.apache.dubbo.rpc.cluster.support.FailbackCluster org.apache.dubbo.rpc.cluster.support.ForkingCluster org.apache.dubbo.rpc.cluster.support.AvailableCluster Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxCluster.java (Cluster implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.Cluster (plain text file with the content: xxx=com.xxx.XxxCluster) XxxCluster.java\uff1a package com.xxx; import org.apache.dubbo.rpc.cluster.Cluster; import org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker; import org.apache.dubbo.rpc.cluster.Directory; import org.apache.dubbo.rpc.cluster.LoadBalance; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.Result; import org.apache.dubbo.rpc.RpcException; public class XxxCluster implements Cluster { public T Invoker T merge(Directory T directory) throws RpcException { return new AbstractClusterInvoker T (directory) { public Result doInvoke(Invocation invocation, List Invoker T invokers, LoadBalance loadbalance) throws RpcException { // ... } }; } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.Cluster\uff1a xxx=com.xxx.XxxCluster","title":"Cluster"},{"location":"dev/impls/cluster/#cluster-extension","text":"","title":"Cluster Extension"},{"location":"dev/impls/cluster/#summary","text":"Group service providers in a cluster, and treat them as one single provider.","title":"Summary"},{"location":"dev/impls/cluster/#extension-interface","text":"org.apache.dubbo.rpc.cluster.Cluster","title":"Extension Interface"},{"location":"dev/impls/cluster/#extension-configuration","text":"dubbo:protocol cluster= xxx / !-- default configuration, will take affect if cluster attribute is not configured in dubbo:protocol -- dubbo:provider cluster= xxx /","title":"Extension Configuration"},{"location":"dev/impls/cluster/#existing-extensions","text":"org.apache.dubbo.rpc.cluster.support.FailoverCluster org.apache.dubbo.rpc.cluster.support.FailfastCluster org.apache.dubbo.rpc.cluster.support.FailsafeCluster org.apache.dubbo.rpc.cluster.support.FailbackCluster org.apache.dubbo.rpc.cluster.support.ForkingCluster org.apache.dubbo.rpc.cluster.support.AvailableCluster","title":"Existing Extensions"},{"location":"dev/impls/cluster/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxCluster.java (Cluster implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.Cluster (plain text file with the content: xxx=com.xxx.XxxCluster) XxxCluster.java\uff1a package com.xxx; import org.apache.dubbo.rpc.cluster.Cluster; import org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker; import org.apache.dubbo.rpc.cluster.Directory; import org.apache.dubbo.rpc.cluster.LoadBalance; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.Result; import org.apache.dubbo.rpc.RpcException; public class XxxCluster implements Cluster { public T Invoker T merge(Directory T directory) throws RpcException { return new AbstractClusterInvoker T (directory) { public Result doInvoke(Invocation invocation, List Invoker T invokers, LoadBalance loadbalance) throws RpcException { // ... } }; } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.Cluster\uff1a xxx=com.xxx.XxxCluster","title":"Extension Guide"},{"location":"dev/impls/compiler/","text":"Compiler Extension Summary Java compiler, used for byte code dynamic generation for RPC invocation. Extension Interface org.apache.dubbo.common.compiler.Compiler Extension Configuration No configuration required, the extension will be automatically discovered and loaded. Existing Extensions org.apache.dubbo.common.compiler.support.JdkCompiler org.apache.dubbo.common.compiler.support.JavassistCompiler Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxCompiler.java (Compiler implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.compiler.Compiler (plain text file with the content: xxx=com.xxx.XxxCompiler) XxxCompiler.java\uff1a package com.xxx; import org.apache.dubbo.common.compiler.Compiler; public class XxxCompiler implements Compiler { public Object getExtension(Class ? type, String name) { // ... } } META-INF/dubbo/org.apache.dubbo.common.compiler.Compiler\uff1a xxx=com.xxx.XxxCompiler","title":"Compiler"},{"location":"dev/impls/compiler/#compiler-extension","text":"","title":"Compiler Extension"},{"location":"dev/impls/compiler/#summary","text":"Java compiler, used for byte code dynamic generation for RPC invocation.","title":"Summary"},{"location":"dev/impls/compiler/#extension-interface","text":"org.apache.dubbo.common.compiler.Compiler","title":"Extension Interface"},{"location":"dev/impls/compiler/#extension-configuration","text":"No configuration required, the extension will be automatically discovered and loaded.","title":"Extension Configuration"},{"location":"dev/impls/compiler/#existing-extensions","text":"org.apache.dubbo.common.compiler.support.JdkCompiler org.apache.dubbo.common.compiler.support.JavassistCompiler","title":"Existing Extensions"},{"location":"dev/impls/compiler/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxCompiler.java (Compiler implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.compiler.Compiler (plain text file with the content: xxx=com.xxx.XxxCompiler) XxxCompiler.java\uff1a package com.xxx; import org.apache.dubbo.common.compiler.Compiler; public class XxxCompiler implements Compiler { public Object getExtension(Class ? type, String name) { // ... } } META-INF/dubbo/org.apache.dubbo.common.compiler.Compiler\uff1a xxx=com.xxx.XxxCompiler","title":"Extension Guide"},{"location":"dev/impls/config-center/","text":"Dubbo Configuration Center Design Purpose The key function of CC(Configuration Center) is to act as a Key-Value store. Dubbo Framework tells CC the key it care about, CC return the corresponding value. Divided by application scenarios, CC mainly undertake the following responsibilities in Dubbo Framework: As a external configuration center, CC store configuration files like dubbo.properties, where the key is usually file name like dubbo.properties, and value is content of the file. Store single configuration items, like all kinds of switchs, contants, etc. Store service governance rules, where the key is usually formated like \"ServiceName+RuleType\", while value is the specific governance rule. Dubbo CC also introduced concepts of namespace and group to better manage Key-Value pairs by group, those concepts are already built-in in many professional third-party configuration centers. In most cases, namespace is used to isolate different tetants, while group is used to divid the key set from one tetant into groups. Dubbo CC has currently supported Zookeeper, Nacos, Etcd, Consul, Apollo, next we will see how Dubbo CC is mapped to a specific third-party implementation. Extension Interface org.apache.dubbo.configcenter.DynamicConfigurationFactory org.apache.dubbo.configcenter.DynamicConfiguration Existing Extension org.apache.dubbo.configcenter.support.zookeeper.ZookeeperDynamicConfigurationFactory org.apache.dubbo.configcenter.support.nacos.NacosDynamicConfigurationFactory org.apache.dubbo.configcenter.support.etcd.EtcdDynamicConfigurationFactory org.apache.dubbo.configcenter.consul.ConsulDynamicConfigurationFactory org.apache.dubbo.configcenter.support.apollo.ApolloDynamicConfigurationFactory org.apache.dubbo.common.config.configcenter.file.FileSystemDynamicConfigurationFactory Implementation Zookeeper Zookeeper provided a tree-structure storage model, the implementation is as follows: namespace, group, key are corresponded to different levels of ZNodes, while value is content of the key ZNode. External configuration cetner dubbo.properties The figure above shows the storage structure of the dubbo.properties file in two different scopes in zookeeper: - namespace: both are 'dubbo' - group: 'dubbo' is globally shared by all applications; 'demo-provider' is application level, only affect the specific application - key: dubbo.properties Single configuration item The figure above shows how we set the shutdown wait time to 15000: - namespace: dubbo - group: dubbo - key: dubbo.service.shutdown.wait - value: 15000 Service governance rule The figure above shows an application-level conditional routing rule: namespace\uff1adubbo group\uff1adubbo key\uff1agovernance-conditionrouter-consumer.condition-router, in wich governance-conditionrouter-consumer is application name, condition-router represents condition router. Notice: Dubbo support two level of governance rules: application, service. The key format are as follows: * application level {application name + rule suffix}, such as: demo-application.configurators , demo-application.tag-router , etc. * service level {service interface name:[version]:[group] + rule suffix}, in which version and group are optional, such as: org.apache.dubbo.demo.DemoService::.configurators , org.apache.dubbo.demo.DemoService:1.0.0:group1.configurators , etc. Etcd Consul Etcd and Consul are essencially tree-structure storage like Zookeeper, see zookeeper for implementation. Nacos Nacos is a professional third-party configuration center, it has a storage structure designed specifically for the configuration center, including built-in concepts like namespace, group, dataid, etc. And these concepts basically correspond to the configuration center of the Dubbo framework abstraction. The correspondence with the Zookeeper implementation is as follows\uff1a Refer to the example described in the zookeeper implementation above, where dataid might be: * External configuration center: dubbo.properties * Single configuration item: dubbo.service.shutdown.wait * Service governance rule: org.apache.dubbo.demo.DemoService:1.0.0:group1.configurators Apollo Apollo is similar to Nacos. Please refer to the documentation on the Apollo section.","title":"Dubbo Configuration Center"},{"location":"dev/impls/config-center/#dubbo-configuration-center","text":"","title":"Dubbo Configuration Center"},{"location":"dev/impls/config-center/#design-purpose","text":"The key function of CC(Configuration Center) is to act as a Key-Value store. Dubbo Framework tells CC the key it care about, CC return the corresponding value. Divided by application scenarios, CC mainly undertake the following responsibilities in Dubbo Framework: As a external configuration center, CC store configuration files like dubbo.properties, where the key is usually file name like dubbo.properties, and value is content of the file. Store single configuration items, like all kinds of switchs, contants, etc. Store service governance rules, where the key is usually formated like \"ServiceName+RuleType\", while value is the specific governance rule. Dubbo CC also introduced concepts of namespace and group to better manage Key-Value pairs by group, those concepts are already built-in in many professional third-party configuration centers. In most cases, namespace is used to isolate different tetants, while group is used to divid the key set from one tetant into groups. Dubbo CC has currently supported Zookeeper, Nacos, Etcd, Consul, Apollo, next we will see how Dubbo CC is mapped to a specific third-party implementation.","title":"Design Purpose"},{"location":"dev/impls/config-center/#extension-interface","text":"org.apache.dubbo.configcenter.DynamicConfigurationFactory org.apache.dubbo.configcenter.DynamicConfiguration","title":"Extension Interface"},{"location":"dev/impls/config-center/#existing-extension","text":"org.apache.dubbo.configcenter.support.zookeeper.ZookeeperDynamicConfigurationFactory org.apache.dubbo.configcenter.support.nacos.NacosDynamicConfigurationFactory org.apache.dubbo.configcenter.support.etcd.EtcdDynamicConfigurationFactory org.apache.dubbo.configcenter.consul.ConsulDynamicConfigurationFactory org.apache.dubbo.configcenter.support.apollo.ApolloDynamicConfigurationFactory org.apache.dubbo.common.config.configcenter.file.FileSystemDynamicConfigurationFactory","title":"Existing Extension"},{"location":"dev/impls/config-center/#implementation","text":"","title":"Implementation"},{"location":"dev/impls/config-center/#zookeeper","text":"Zookeeper provided a tree-structure storage model, the implementation is as follows: namespace, group, key are corresponded to different levels of ZNodes, while value is content of the key ZNode. External configuration cetner dubbo.properties The figure above shows the storage structure of the dubbo.properties file in two different scopes in zookeeper: - namespace: both are 'dubbo' - group: 'dubbo' is globally shared by all applications; 'demo-provider' is application level, only affect the specific application - key: dubbo.properties Single configuration item The figure above shows how we set the shutdown wait time to 15000: - namespace: dubbo - group: dubbo - key: dubbo.service.shutdown.wait - value: 15000 Service governance rule The figure above shows an application-level conditional routing rule: namespace\uff1adubbo group\uff1adubbo key\uff1agovernance-conditionrouter-consumer.condition-router, in wich governance-conditionrouter-consumer is application name, condition-router represents condition router. Notice: Dubbo support two level of governance rules: application, service. The key format are as follows: * application level {application name + rule suffix}, such as: demo-application.configurators , demo-application.tag-router , etc. * service level {service interface name:[version]:[group] + rule suffix}, in which version and group are optional, such as: org.apache.dubbo.demo.DemoService::.configurators , org.apache.dubbo.demo.DemoService:1.0.0:group1.configurators , etc.","title":"Zookeeper"},{"location":"dev/impls/config-center/#etcd-consul","text":"Etcd and Consul are essencially tree-structure storage like Zookeeper, see zookeeper for implementation.","title":"Etcd &amp; Consul"},{"location":"dev/impls/config-center/#nacos","text":"Nacos is a professional third-party configuration center, it has a storage structure designed specifically for the configuration center, including built-in concepts like namespace, group, dataid, etc. And these concepts basically correspond to the configuration center of the Dubbo framework abstraction. The correspondence with the Zookeeper implementation is as follows\uff1a Refer to the example described in the zookeeper implementation above, where dataid might be: * External configuration center: dubbo.properties * Single configuration item: dubbo.service.shutdown.wait * Service governance rule: org.apache.dubbo.demo.DemoService:1.0.0:group1.configurators","title":"Nacos"},{"location":"dev/impls/config-center/#apollo","text":"Apollo is similar to Nacos. Please refer to the documentation on the Apollo section.","title":"Apollo"},{"location":"dev/impls/container/","text":"Container Extension Summary Service container extension, useful for loading custom contents. Extension Interface org.apache.dubbo.container.Container Extension Configuration java org.apache.dubbo.container.Main spring jetty log4j Existing Extensions org.apache.dubbo.container.spring.SpringContainer org.apache.dubbo.container.spring.JettyContainer org.apache.dubbo.container.spring.Log4jContainer Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxContainer.java (Container implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.container.Container (plain text file with the content: xxx=com.xxx.XxxContainer) XxxContainer.java\uff1a package com.xxx; org.apache.dubbo.container.Container; public class XxxContainer implements Container { public Status start() { // ... } public Status stop() { // ... } } META-INF/dubbo/org.apache.dubbo.container.Container\uff1a xxx=com.xxx.XxxContainer","title":"Container"},{"location":"dev/impls/container/#container-extension","text":"","title":"Container Extension"},{"location":"dev/impls/container/#summary","text":"Service container extension, useful for loading custom contents.","title":"Summary"},{"location":"dev/impls/container/#extension-interface","text":"org.apache.dubbo.container.Container","title":"Extension Interface"},{"location":"dev/impls/container/#extension-configuration","text":"java org.apache.dubbo.container.Main spring jetty log4j","title":"Extension Configuration"},{"location":"dev/impls/container/#existing-extensions","text":"org.apache.dubbo.container.spring.SpringContainer org.apache.dubbo.container.spring.JettyContainer org.apache.dubbo.container.spring.Log4jContainer","title":"Existing Extensions"},{"location":"dev/impls/container/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxContainer.java (Container implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.container.Container (plain text file with the content: xxx=com.xxx.XxxContainer) XxxContainer.java\uff1a package com.xxx; org.apache.dubbo.container.Container; public class XxxContainer implements Container { public Status start() { // ... } public Status stop() { // ... } } META-INF/dubbo/org.apache.dubbo.container.Container\uff1a xxx=com.xxx.XxxContainer","title":"Extension Guide"},{"location":"dev/impls/dispatcher/","text":"Dispatcher Extension Summary Thread pool dispatch strategy. Extension Interface org.apache.dubbo.remoting.Dispatcher Extension Configuration dubbo:protocol dispatcher= xxx / !-- default configuration, will take effect if dispatcher attribute is not set in dubbo:protocol -- dubbo:provider dispatcher= xxx / Existing Extensions org.apache.dubbo.remoting.transport.dispatcher.all.AllDispatcher org.apache.dubbo.remoting.transport.dispatcher.direct.DirectDispatcher org.apache.dubbo.remoting.transport.dispatcher.message.MessageOnlyDispatcher org.apache.dubbo.remoting.transport.dispatcher.execution.ExecutionDispatcher org.apache.dubbo.remoting.transport.dispatcher.connection.ConnectionOrderedDispatcher Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxDispatcher.java (Dispatcher implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.Dispatcher (plain text file with the content: xxx=com.xxx.XxxDispatcher) XxxDispatcher.java\uff1a package com.xxx; import org.apache.dubbo.remoting.Dispatcher; public class XxxDispatcher implements Dispatcher { public Group lookup(URL url) { // ... } } META-INF/dubbo/org.apache.dubbo.remoting.Dispatcher\uff1a xxx=com.xxx.XxxDispatcher","title":"Dispatcher"},{"location":"dev/impls/dispatcher/#dispatcher-extension","text":"","title":"Dispatcher Extension"},{"location":"dev/impls/dispatcher/#summary","text":"Thread pool dispatch strategy.","title":"Summary"},{"location":"dev/impls/dispatcher/#extension-interface","text":"org.apache.dubbo.remoting.Dispatcher","title":"Extension Interface"},{"location":"dev/impls/dispatcher/#extension-configuration","text":"dubbo:protocol dispatcher= xxx / !-- default configuration, will take effect if dispatcher attribute is not set in dubbo:protocol -- dubbo:provider dispatcher= xxx /","title":"Extension Configuration"},{"location":"dev/impls/dispatcher/#existing-extensions","text":"org.apache.dubbo.remoting.transport.dispatcher.all.AllDispatcher org.apache.dubbo.remoting.transport.dispatcher.direct.DirectDispatcher org.apache.dubbo.remoting.transport.dispatcher.message.MessageOnlyDispatcher org.apache.dubbo.remoting.transport.dispatcher.execution.ExecutionDispatcher org.apache.dubbo.remoting.transport.dispatcher.connection.ConnectionOrderedDispatcher","title":"Existing Extensions"},{"location":"dev/impls/dispatcher/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxDispatcher.java (Dispatcher implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.Dispatcher (plain text file with the content: xxx=com.xxx.XxxDispatcher) XxxDispatcher.java\uff1a package com.xxx; import org.apache.dubbo.remoting.Dispatcher; public class XxxDispatcher implements Dispatcher { public Group lookup(URL url) { // ... } } META-INF/dubbo/org.apache.dubbo.remoting.Dispatcher\uff1a xxx=com.xxx.XxxDispatcher","title":"Extension Guide"},{"location":"dev/impls/exchanger/","text":"Exchanger Extension Summary Exchange message between request and response on network transport layer. Extension Interface org.apache.dubbo.remoting.exchange.Exchanger org.apache.dubbo.remoting.exchange.ExchangeServer org.apache.dubbo.remoting.exchange.ExchangeClient Extension Configuration dubbo:protocol exchanger= xxx / !-- default configuration, will take effect if exchanger attribute is not set in dubbo:protocol -- dubbo:provider exchanger= xxx / Existing Extension org.apache.dubbo.remoting.exchange.exchanger.HeaderExchanger Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxExchanger.java (Exchanger implementation) |-XxxExchangeServer.java (ExchangeServer implementation) |-XxxExchangeClient.java (ExchangeClient implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.exchange.Exchanger (plain text file with the content: xxx=com.xxx.XxxExchanger) XxxExchanger.java\uff1a package com.xxx; import org.apache.dubbo.remoting.exchange.Exchanger; public class XxxExchanger implements Exchanger { public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException { return new XxxExchangeServer(url, handler); } public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException { return new XxxExchangeClient(url, handler); } } XxxExchangeServer.java\uff1a package com.xxx; import org.apache.dubbo.remoting.exchange.ExchangeServer; public class XxxExchangeServer impelements ExchangeServer { // ... } XxxExchangeClient.java\uff1a package com.xxx; import org.apache.dubbo.remoting.exchange.ExchangeClient; public class XxxExchangeClient impelments ExchangeClient { // ... } META-INF/dubbo/org.apache.dubbo.remoting.exchange.Exchanger\uff1a xxx=com.xxx.XxxExchanger","title":"Exchanger"},{"location":"dev/impls/exchanger/#exchanger-extension","text":"","title":"Exchanger Extension"},{"location":"dev/impls/exchanger/#summary","text":"Exchange message between request and response on network transport layer.","title":"Summary"},{"location":"dev/impls/exchanger/#extension-interface","text":"org.apache.dubbo.remoting.exchange.Exchanger org.apache.dubbo.remoting.exchange.ExchangeServer org.apache.dubbo.remoting.exchange.ExchangeClient","title":"Extension Interface"},{"location":"dev/impls/exchanger/#extension-configuration","text":"dubbo:protocol exchanger= xxx / !-- default configuration, will take effect if exchanger attribute is not set in dubbo:protocol -- dubbo:provider exchanger= xxx /","title":"Extension Configuration"},{"location":"dev/impls/exchanger/#existing-extension","text":"org.apache.dubbo.remoting.exchange.exchanger.HeaderExchanger","title":"Existing Extension"},{"location":"dev/impls/exchanger/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxExchanger.java (Exchanger implementation) |-XxxExchangeServer.java (ExchangeServer implementation) |-XxxExchangeClient.java (ExchangeClient implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.exchange.Exchanger (plain text file with the content: xxx=com.xxx.XxxExchanger) XxxExchanger.java\uff1a package com.xxx; import org.apache.dubbo.remoting.exchange.Exchanger; public class XxxExchanger implements Exchanger { public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException { return new XxxExchangeServer(url, handler); } public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException { return new XxxExchangeClient(url, handler); } } XxxExchangeServer.java\uff1a package com.xxx; import org.apache.dubbo.remoting.exchange.ExchangeServer; public class XxxExchangeServer impelements ExchangeServer { // ... } XxxExchangeClient.java\uff1a package com.xxx; import org.apache.dubbo.remoting.exchange.ExchangeClient; public class XxxExchangeClient impelments ExchangeClient { // ... } META-INF/dubbo/org.apache.dubbo.remoting.exchange.Exchanger\uff1a xxx=com.xxx.XxxExchanger","title":"Extension Guide"},{"location":"dev/impls/exporter-listener/","text":"ExporterListener Extension Summary Fire events when there's any service exported. Extension Interface org.apache.dubbo.rpc.ExporterListener Extension Configuration !-- service exporter listener -- dubbo:service listener= xxx,yyy / !-- default exporter listener for service provider -- dubbo:provider listener= xxx,yyy / Existing Extension org.apache.dubbo.registry.directory.RegistryExporterListener Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxExporterListener.java (ExporterListener implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.ExporterListener (plain text file with the content: xxx=com.xxx.XxxExporterListener) XxxExporterListener.java\uff1a package com.xxx; import org.apache.dubbo.rpc.ExporterListener; import org.apache.dubbo.rpc.Exporter; import org.apache.dubbo.rpc.RpcException; public class XxxExporterListener implements ExporterListener { public void exported(Exporter ? exporter) throws RpcException { // ... } public void unexported(Exporter ? exporter) throws RpcException { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.ExporterListener\uff1a xxx=com.xxx.XxxExporterListener","title":"Exporter Listener"},{"location":"dev/impls/exporter-listener/#exporterlistener-extension","text":"","title":"ExporterListener Extension"},{"location":"dev/impls/exporter-listener/#summary","text":"Fire events when there's any service exported.","title":"Summary"},{"location":"dev/impls/exporter-listener/#extension-interface","text":"org.apache.dubbo.rpc.ExporterListener","title":"Extension Interface"},{"location":"dev/impls/exporter-listener/#extension-configuration","text":"!-- service exporter listener -- dubbo:service listener= xxx,yyy / !-- default exporter listener for service provider -- dubbo:provider listener= xxx,yyy /","title":"Extension Configuration"},{"location":"dev/impls/exporter-listener/#existing-extension","text":"org.apache.dubbo.registry.directory.RegistryExporterListener","title":"Existing Extension"},{"location":"dev/impls/exporter-listener/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxExporterListener.java (ExporterListener implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.ExporterListener (plain text file with the content: xxx=com.xxx.XxxExporterListener) XxxExporterListener.java\uff1a package com.xxx; import org.apache.dubbo.rpc.ExporterListener; import org.apache.dubbo.rpc.Exporter; import org.apache.dubbo.rpc.RpcException; public class XxxExporterListener implements ExporterListener { public void exported(Exporter ? exporter) throws RpcException { // ... } public void unexported(Exporter ? exporter) throws RpcException { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.ExporterListener\uff1a xxx=com.xxx.XxxExporterListener","title":"Extension Guide"},{"location":"dev/impls/extension-factory/","text":"ExtensionFactory Extension Summary Factory to load dubbo extensions. Extension Interface org.apache.dubbo.common.extension.ExtensionFactory Extension Configuration dubbo:application compiler= jdk / Existing Extension org.apache.dubbo.common.extension.factory.SpiExtensionFactory org.apache.dubbo.config.spring.extension.SpringExtensionFactory Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxExtensionFactory.java (ExtensionFactory implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.extension.ExtensionFactory (plain text file with the content: xxx=com.xxx.XxxExtensionFactory) XxxExtensionFactory.java\uff1a package com.xxx; import org.apache.dubbo.common.extension.ExtensionFactory; public class XxxExtensionFactory implements ExtensionFactory { public Object getExtension(Class ? type, String name) { // ... } } META-INF/dubbo/org.apache.dubbo.common.extension.ExtensionFactory\uff1a xxx=com.xxx.XxxExtensionFactory","title":"Extension Factory"},{"location":"dev/impls/extension-factory/#extensionfactory-extension","text":"","title":"ExtensionFactory Extension"},{"location":"dev/impls/extension-factory/#summary","text":"Factory to load dubbo extensions.","title":"Summary"},{"location":"dev/impls/extension-factory/#extension-interface","text":"org.apache.dubbo.common.extension.ExtensionFactory","title":"Extension Interface"},{"location":"dev/impls/extension-factory/#extension-configuration","text":"dubbo:application compiler= jdk /","title":"Extension Configuration"},{"location":"dev/impls/extension-factory/#existing-extension","text":"org.apache.dubbo.common.extension.factory.SpiExtensionFactory org.apache.dubbo.config.spring.extension.SpringExtensionFactory","title":"Existing Extension"},{"location":"dev/impls/extension-factory/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxExtensionFactory.java (ExtensionFactory implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.extension.ExtensionFactory (plain text file with the content: xxx=com.xxx.XxxExtensionFactory) XxxExtensionFactory.java\uff1a package com.xxx; import org.apache.dubbo.common.extension.ExtensionFactory; public class XxxExtensionFactory implements ExtensionFactory { public Object getExtension(Class ? type, String name) { // ... } } META-INF/dubbo/org.apache.dubbo.common.extension.ExtensionFactory\uff1a xxx=com.xxx.XxxExtensionFactory","title":"Extension Guide"},{"location":"dev/impls/filter/","text":"Filter Extension Summary Extension for intercepting the invocation for both service provider and consumer, furthermore, most of functions in dubbo are implemented base on the same mechanism. Since every time when remote method is invoked, the filter extensions will be executed too, the corresponding penalty should be considered before more filters are added. Contract: User defined filters are executed after built-in filters by default. Special value default is introduced to represent the default extension location. For example: for filter=\"xxx,default,yyy\" , xxx is before default filter, and yyy is after the default filter. Special value - means delete. For example: filter=\"-foo1\" excludes foo1 extension. For example, filter=\"-default\" exclues all default filters. When provider and service have filter configured at the same moment, all filters are accumulated together instead of override, for example: for dubbo:provider filter=\"xxx,yyy\"/ and dubbo:service filter=\"aaa,bbb\" / \uff0c xxx , yyy , aaa , bbb are all count as filters. In order to change to override, use: dubbo:service filter=\"-xxx,-yyy,aaa,bbb\" / Extension Interface org.apache.dubbo.rpc.Filter Extension Configuration !-- filter for consumer -- dubbo:reference filter= xxx,yyy / !-- default filter configuration for the consumer, will intercept for all references -- dubbo:consumer filter= xxx,yyy / !-- filter for provider -- dubbo:service filter= xxx,yyy / !-- default filter configuration for the provider, will intercept for all services -- dubbo:provider filter= xxx,yyy / Existing Extension org.apache.dubbo.rpc.filter.EchoFilter org.apache.dubbo.rpc.filter.GenericFilter org.apache.dubbo.rpc.filter.GenericImplFilter org.apache.dubbo.rpc.filter.TokenFilter org.apache.dubbo.rpc.filter.AccessLogFilter org.apache.dubbo.rpc.filter.CountFilter org.apache.dubbo.rpc.filter.ActiveLimitFilter org.apache.dubbo.rpc.filter.ClassLoaderFilter org.apache.dubbo.rpc.filter.ContextFilter org.apache.dubbo.rpc.filter.ConsumerContextFilter org.apache.dubbo.rpc.filter.ExceptionFilter org.apache.dubbo.rpc.filter.ExecuteLimitFilter org.apache.dubbo.rpc.filter.DeprecatedFilter Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxFilter.java (Filter implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.Filter (plain text file with the content: xxx=com.xxx.XxxFilter) XxxFilter.java\uff1a package com.xxx; import org.apache.dubbo.rpc.Filter; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.Result; import org.apache.dubbo.rpc.RpcException; public class XxxFilter implements Filter { public Result invoke(Invoker ? invoker, Invocation invocation) throws RpcException { // before filter ... Result result = invoker.invoke(invocation); // after filter ... return result; } } META-INF/dubbo/org.apache.dubbo.rpc.Filter\uff1a xxx=com.xxx.XxxFilter","title":"Filter"},{"location":"dev/impls/filter/#filter-extension","text":"","title":"Filter Extension"},{"location":"dev/impls/filter/#summary","text":"Extension for intercepting the invocation for both service provider and consumer, furthermore, most of functions in dubbo are implemented base on the same mechanism. Since every time when remote method is invoked, the filter extensions will be executed too, the corresponding penalty should be considered before more filters are added. Contract: User defined filters are executed after built-in filters by default. Special value default is introduced to represent the default extension location. For example: for filter=\"xxx,default,yyy\" , xxx is before default filter, and yyy is after the default filter. Special value - means delete. For example: filter=\"-foo1\" excludes foo1 extension. For example, filter=\"-default\" exclues all default filters. When provider and service have filter configured at the same moment, all filters are accumulated together instead of override, for example: for dubbo:provider filter=\"xxx,yyy\"/ and dubbo:service filter=\"aaa,bbb\" / \uff0c xxx , yyy , aaa , bbb are all count as filters. In order to change to override, use: dubbo:service filter=\"-xxx,-yyy,aaa,bbb\" /","title":"Summary"},{"location":"dev/impls/filter/#extension-interface","text":"org.apache.dubbo.rpc.Filter","title":"Extension Interface"},{"location":"dev/impls/filter/#extension-configuration","text":"!-- filter for consumer -- dubbo:reference filter= xxx,yyy / !-- default filter configuration for the consumer, will intercept for all references -- dubbo:consumer filter= xxx,yyy / !-- filter for provider -- dubbo:service filter= xxx,yyy / !-- default filter configuration for the provider, will intercept for all services -- dubbo:provider filter= xxx,yyy /","title":"Extension Configuration"},{"location":"dev/impls/filter/#existing-extension","text":"org.apache.dubbo.rpc.filter.EchoFilter org.apache.dubbo.rpc.filter.GenericFilter org.apache.dubbo.rpc.filter.GenericImplFilter org.apache.dubbo.rpc.filter.TokenFilter org.apache.dubbo.rpc.filter.AccessLogFilter org.apache.dubbo.rpc.filter.CountFilter org.apache.dubbo.rpc.filter.ActiveLimitFilter org.apache.dubbo.rpc.filter.ClassLoaderFilter org.apache.dubbo.rpc.filter.ContextFilter org.apache.dubbo.rpc.filter.ConsumerContextFilter org.apache.dubbo.rpc.filter.ExceptionFilter org.apache.dubbo.rpc.filter.ExecuteLimitFilter org.apache.dubbo.rpc.filter.DeprecatedFilter","title":"Existing Extension"},{"location":"dev/impls/filter/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxFilter.java (Filter implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.Filter (plain text file with the content: xxx=com.xxx.XxxFilter) XxxFilter.java\uff1a package com.xxx; import org.apache.dubbo.rpc.Filter; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.Result; import org.apache.dubbo.rpc.RpcException; public class XxxFilter implements Filter { public Result invoke(Invoker ? invoker, Invocation invocation) throws RpcException { // before filter ... Result result = invoker.invoke(invocation); // after filter ... return result; } } META-INF/dubbo/org.apache.dubbo.rpc.Filter\uff1a xxx=com.xxx.XxxFilter","title":"Extension Guide"},{"location":"dev/impls/introduction/","text":"SPI Extension Implementations SPI extension interface is used for system integration, it's also useful for dubbo contributor to extend dubbo functionality.","title":"SPI Extension Implementations"},{"location":"dev/impls/introduction/#spi-extension-implementations","text":"SPI extension interface is used for system integration, it's also useful for dubbo contributor to extend dubbo functionality.","title":"SPI Extension Implementations"},{"location":"dev/impls/invoker-listener/","text":"InvokerListener Extension Summary Fire event when there's any service referenced. Extension Interface org.apache.dubbo.rpc.InvokerListener Extension Configuration !-- \u5f15\u7528\u670d\u52a1\u76d1\u542c -- !-- service reference listener -- dubbo:reference listener= xxx,yyy / !-- default service reference listener -- dubbo:consumer listener= xxx,yyy / Existing Extension org.apache.dubbo.rpc.listener.DeprecatedInvokerListener Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxInvokerListener.java (InvokerListener implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.InvokerListener (plain text file with the content: xxx=com.xxx.XxxInvokerListener) XxxInvokerListener.java\uff1a package com.xxx; import org.apache.dubbo.rpc.InvokerListener; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.RpcException; public class XxxInvokerListener implements InvokerListener { public void referred(Invoker ? invoker) throws RpcException { // ... } public void destroyed(Invoker ? invoker) throws RpcException { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.InvokerListener\uff1a xxx=com.xxx.XxxInvokerListener","title":"Invoker Listener"},{"location":"dev/impls/invoker-listener/#invokerlistener-extension","text":"","title":"InvokerListener Extension"},{"location":"dev/impls/invoker-listener/#summary","text":"Fire event when there's any service referenced.","title":"Summary"},{"location":"dev/impls/invoker-listener/#extension-interface","text":"org.apache.dubbo.rpc.InvokerListener","title":"Extension Interface"},{"location":"dev/impls/invoker-listener/#extension-configuration","text":"!-- \u5f15\u7528\u670d\u52a1\u76d1\u542c -- !-- service reference listener -- dubbo:reference listener= xxx,yyy / !-- default service reference listener -- dubbo:consumer listener= xxx,yyy /","title":"Extension Configuration"},{"location":"dev/impls/invoker-listener/#existing-extension","text":"org.apache.dubbo.rpc.listener.DeprecatedInvokerListener","title":"Existing Extension"},{"location":"dev/impls/invoker-listener/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxInvokerListener.java (InvokerListener implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.InvokerListener (plain text file with the content: xxx=com.xxx.XxxInvokerListener) XxxInvokerListener.java\uff1a package com.xxx; import org.apache.dubbo.rpc.InvokerListener; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.RpcException; public class XxxInvokerListener implements InvokerListener { public void referred(Invoker ? invoker) throws RpcException { // ... } public void destroyed(Invoker ? invoker) throws RpcException { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.InvokerListener\uff1a xxx=com.xxx.XxxInvokerListener","title":"Extension Guide"},{"location":"dev/impls/load-balance/","text":"LoadBalance Extension Summary Pick one from service providers and fire the invocation. Extension Interface org.apache.dubbo.rpc.cluster.LoadBalance Extension Configuration dubbo:protocol loadbalance= xxx / !-- default configuration, will take effect when loadbalance is not configured in dubbo:protocol -- dubbo:provider loadbalance= xxx / Existing Extension org.apache.dubbo.rpc.cluster.loadbalance.RandomLoadBalance org.apache.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance org.apache.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxLoadBalance.java (LoadBalance implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.LoadBalance (plain text file with the content: xxx=com.xxx.XxxLoadBalance) XxxLoadBalance.java\uff1a package com.xxx; import org.apache.dubbo.rpc.cluster.LoadBalance; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.RpcException; public class XxxLoadBalance implements LoadBalance { public T Invoker T select(List Invoker T invokers, Invocation invocation) throws RpcException { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.LoadBalance\uff1a xxx=com.xxx.XxxLoadBalance","title":"Load Balance"},{"location":"dev/impls/load-balance/#loadbalance-extension","text":"","title":"LoadBalance Extension"},{"location":"dev/impls/load-balance/#summary","text":"Pick one from service providers and fire the invocation.","title":"Summary"},{"location":"dev/impls/load-balance/#extension-interface","text":"org.apache.dubbo.rpc.cluster.LoadBalance","title":"Extension Interface"},{"location":"dev/impls/load-balance/#extension-configuration","text":"dubbo:protocol loadbalance= xxx / !-- default configuration, will take effect when loadbalance is not configured in dubbo:protocol -- dubbo:provider loadbalance= xxx /","title":"Extension Configuration"},{"location":"dev/impls/load-balance/#existing-extension","text":"org.apache.dubbo.rpc.cluster.loadbalance.RandomLoadBalance org.apache.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance org.apache.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance","title":"Existing Extension"},{"location":"dev/impls/load-balance/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxLoadBalance.java (LoadBalance implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.LoadBalance (plain text file with the content: xxx=com.xxx.XxxLoadBalance) XxxLoadBalance.java\uff1a package com.xxx; import org.apache.dubbo.rpc.cluster.LoadBalance; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.RpcException; public class XxxLoadBalance implements LoadBalance { public T Invoker T select(List Invoker T invokers, Invocation invocation) throws RpcException { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.LoadBalance\uff1a xxx=com.xxx.XxxLoadBalance","title":"Extension Guide"},{"location":"dev/impls/logger-adapter/","text":"LoggerAdapter Extension Summary Extension for adapting logger output Extension Interface org.apache.dubbo.common.logger.LoggerAdapter Extension Configuration dubbo:application logger= xxx / Or: -Ddubbo:application.logger=xxx Existing Extension org.apache.dubbo.common.logger.slf4j.Slf4jLoggerAdapter org.apache.dubbo.common.logger.jcl.JclLoggerAdapter org.apache.dubbo.common.logger.log4j.Log4jLoggerAdapter org.apache.dubbo.common.logger.log4j2.Log4j2LoggerAdapter org.apache.dubbo.common.logger.jdk.JdkLoggerAdapter Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxLoggerAdapter.java (LoggerAdapter implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.logger.LoggerAdapter (plain text file with the content: xxx=com.xxx.XxxLoggerAdapter) XxxLoggerAdapter.java\uff1a package com.xxx; import org.apache.dubbo.common.logger.LoggerAdapter; public class XxxLoggerAdapter implements LoggerAdapter { public Logger getLogger(URL url) { // ... } } XxxLogger.java\uff1a package com.xxx; import org.apache.dubbo.common.logger.Logger; public class XxxLogger implements Logger { public XxxLogger(URL url) { // ... } public void info(String msg) { // ... } // ... } META-INF/dubbo/org.apache.dubbo.common.logger.LoggerAdapter\uff1a xxx=com.xxx.XxxLoggerAdapter","title":"Logger Adapter"},{"location":"dev/impls/logger-adapter/#loggeradapter-extension","text":"","title":"LoggerAdapter Extension"},{"location":"dev/impls/logger-adapter/#summary","text":"Extension for adapting logger output","title":"Summary"},{"location":"dev/impls/logger-adapter/#extension-interface","text":"org.apache.dubbo.common.logger.LoggerAdapter","title":"Extension Interface"},{"location":"dev/impls/logger-adapter/#extension-configuration","text":"dubbo:application logger= xxx / Or: -Ddubbo:application.logger=xxx","title":"Extension Configuration"},{"location":"dev/impls/logger-adapter/#existing-extension","text":"org.apache.dubbo.common.logger.slf4j.Slf4jLoggerAdapter org.apache.dubbo.common.logger.jcl.JclLoggerAdapter org.apache.dubbo.common.logger.log4j.Log4jLoggerAdapter org.apache.dubbo.common.logger.log4j2.Log4j2LoggerAdapter org.apache.dubbo.common.logger.jdk.JdkLoggerAdapter","title":"Existing Extension"},{"location":"dev/impls/logger-adapter/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxLoggerAdapter.java (LoggerAdapter implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.logger.LoggerAdapter (plain text file with the content: xxx=com.xxx.XxxLoggerAdapter) XxxLoggerAdapter.java\uff1a package com.xxx; import org.apache.dubbo.common.logger.LoggerAdapter; public class XxxLoggerAdapter implements LoggerAdapter { public Logger getLogger(URL url) { // ... } } XxxLogger.java\uff1a package com.xxx; import org.apache.dubbo.common.logger.Logger; public class XxxLogger implements Logger { public XxxLogger(URL url) { // ... } public void info(String msg) { // ... } // ... } META-INF/dubbo/org.apache.dubbo.common.logger.LoggerAdapter\uff1a xxx=com.xxx.XxxLoggerAdapter","title":"Extension Guide"},{"location":"dev/impls/merger/","text":"Merger Extension Summary Merge strategy for return result aggregation in group. Extension Interface org.apache.dubbo.rpc.cluster.Merger Extension Configuration dubbo:method merger= xxx / Existing Extension org.apache.dubbo.rpc.cluster.merger.ArrayMerger org.apache.dubbo.rpc.cluster.merger.ListMerger org.apache.dubbo.rpc.cluster.merger.SetMerger org.apache.dubbo.rpc.cluster.merger.MapMerger Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxMerger.java (Merger implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.Merger (plain text file with the content: xxx=com.xxx.XxxMerger) XxxMerger.java\uff1a package com.xxx; import org.apache.dubbo.rpc.cluster.Merger; public class XxxMerger T implements Merger T { public T merge(T... results) { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.Merger\uff1a xxx=com.xxx.XxxMerger","title":"Merge"},{"location":"dev/impls/merger/#merger-extension","text":"","title":"Merger Extension"},{"location":"dev/impls/merger/#summary","text":"Merge strategy for return result aggregation in group.","title":"Summary"},{"location":"dev/impls/merger/#extension-interface","text":"org.apache.dubbo.rpc.cluster.Merger","title":"Extension Interface"},{"location":"dev/impls/merger/#extension-configuration","text":"dubbo:method merger= xxx /","title":"Extension Configuration"},{"location":"dev/impls/merger/#existing-extension","text":"org.apache.dubbo.rpc.cluster.merger.ArrayMerger org.apache.dubbo.rpc.cluster.merger.ListMerger org.apache.dubbo.rpc.cluster.merger.SetMerger org.apache.dubbo.rpc.cluster.merger.MapMerger","title":"Existing Extension"},{"location":"dev/impls/merger/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxMerger.java (Merger implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.Merger (plain text file with the content: xxx=com.xxx.XxxMerger) XxxMerger.java\uff1a package com.xxx; import org.apache.dubbo.rpc.cluster.Merger; public class XxxMerger T implements Merger T { public T merge(T... results) { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.Merger\uff1a xxx=com.xxx.XxxMerger","title":"Extension Guide"},{"location":"dev/impls/monitor/","text":"Monitor Extension Summary Extension to monitor service invocation times and time taken for each service invocation. Extension Interface org.apache.dubbo.monitor.MonitorFactory org.apache.dubbo.monitor.Monitor Extension Configuration !-- configure monitor center -- dubbo:monitor address= xxx://ip:port / Existing Extension org.apache.dubbo.monitor.support.dubbo.DubboMonitorFactory Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxMonitorFactoryjava (MonitorFactory implementation) |-XxxMonitor.java (Monitor implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.monitor.MonitorFactory (plain text file with the format: xxx=com.xxx.XxxMonitorFactory) XxxMonitorFactory.java\uff1a package com.xxx; import org.apache.dubbo.monitor.MonitorFactory; import org.apache.dubbo.monitor.Monitor; import org.apache.dubbo.common.URL; public class XxxMonitorFactory implements MonitorFactory { public Monitor getMonitor(URL url) { return new XxxMonitor(url); } } XxxMonitor.java\uff1a package com.xxx; import org.apache.dubbo.monitor.Monitor; public class XxxMonitor implements Monitor { public void count(URL statistics) { // ... } } META-INF/dubbo/org.apache.dubbo.monitor.MonitorFactory\uff1a xxx=com.xxx.XxxMonitorFactory","title":"Monitor"},{"location":"dev/impls/monitor/#monitor-extension","text":"","title":"Monitor Extension"},{"location":"dev/impls/monitor/#summary","text":"Extension to monitor service invocation times and time taken for each service invocation.","title":"Summary"},{"location":"dev/impls/monitor/#extension-interface","text":"org.apache.dubbo.monitor.MonitorFactory org.apache.dubbo.monitor.Monitor","title":"Extension Interface"},{"location":"dev/impls/monitor/#extension-configuration","text":"!-- configure monitor center -- dubbo:monitor address= xxx://ip:port /","title":"Extension Configuration"},{"location":"dev/impls/monitor/#existing-extension","text":"org.apache.dubbo.monitor.support.dubbo.DubboMonitorFactory","title":"Existing Extension"},{"location":"dev/impls/monitor/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxMonitorFactoryjava (MonitorFactory implementation) |-XxxMonitor.java (Monitor implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.monitor.MonitorFactory (plain text file with the format: xxx=com.xxx.XxxMonitorFactory) XxxMonitorFactory.java\uff1a package com.xxx; import org.apache.dubbo.monitor.MonitorFactory; import org.apache.dubbo.monitor.Monitor; import org.apache.dubbo.common.URL; public class XxxMonitorFactory implements MonitorFactory { public Monitor getMonitor(URL url) { return new XxxMonitor(url); } } XxxMonitor.java\uff1a package com.xxx; import org.apache.dubbo.monitor.Monitor; public class XxxMonitor implements Monitor { public void count(URL statistics) { // ... } } META-INF/dubbo/org.apache.dubbo.monitor.MonitorFactory\uff1a xxx=com.xxx.XxxMonitorFactory","title":"Extension Guide"},{"location":"dev/impls/networker/","text":"Networker Extension Summary Extension for peer to peer network grouping. Extension Interface org.apache.dubbo.remoting.p2p.Networker Extension Configuration dubbo:protocol networker= xxx / !-- default configuration, it takes effect if networker attribute is not set in dubbo:protocol -- dubbo:provider networker= xxx / Existing Extension org.apache.dubbo.remoting.p2p.support.MulticastNetworker org.apache.dubbo.remoting.p2p.support.FileNetworker Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxNetworker.java (Networker implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.p2p.Networker (plain text file with the content: xxx=com.xxx.XxxNetworker) XxxNetworker.java\uff1a package com.xxx; import org.apache.dubbo.remoting.p2p.Networker; public class XxxNetworker implements Networker { public Group lookup(URL url) { // ... } } META-INF/dubbo/org.apache.dubbo.remoting.p2p.Networker\uff1a xxx=com.xxx.XxxNetworker","title":"Networker"},{"location":"dev/impls/networker/#networker-extension","text":"","title":"Networker Extension"},{"location":"dev/impls/networker/#summary","text":"Extension for peer to peer network grouping.","title":"Summary"},{"location":"dev/impls/networker/#extension-interface","text":"org.apache.dubbo.remoting.p2p.Networker","title":"Extension Interface"},{"location":"dev/impls/networker/#extension-configuration","text":"dubbo:protocol networker= xxx / !-- default configuration, it takes effect if networker attribute is not set in dubbo:protocol -- dubbo:provider networker= xxx /","title":"Extension Configuration"},{"location":"dev/impls/networker/#existing-extension","text":"org.apache.dubbo.remoting.p2p.support.MulticastNetworker org.apache.dubbo.remoting.p2p.support.FileNetworker","title":"Existing Extension"},{"location":"dev/impls/networker/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxNetworker.java (Networker implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.p2p.Networker (plain text file with the content: xxx=com.xxx.XxxNetworker) XxxNetworker.java\uff1a package com.xxx; import org.apache.dubbo.remoting.p2p.Networker; public class XxxNetworker implements Networker { public Group lookup(URL url) { // ... } } META-INF/dubbo/org.apache.dubbo.remoting.p2p.Networker\uff1a xxx=com.xxx.XxxNetworker","title":"Extension Guide"},{"location":"dev/impls/page/","text":"Page Extension Summary Extension for page handler Extension Interface org.apache.dubbo.container.page.PageHandler Extension Configuration dubbo:protocol page= xxx,yyy / !-- default configuration, will take effect if page attribute is not set in dubbo:protocol -- dubbo:provider page= xxx,yyy / Existing Extension org.apache.dubbo.container.page.pages.HomePageHandler org.apache.dubbo.container.page.pages.StatusPageHandler org.apache.dubbo.container.page.pages.LogPageHandler org.apache.dubbo.container.page.pages.SystemPageHandler Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxPageHandler.java (PageHandler implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.container.page.PageHandler (plain text file with the content: xxx=com.xxx.XxxPageHandler) XxxPageHandler.java\uff1a package com.xxx; import org.apache.dubbo.container.page.PageHandler; public class XxxPageHandler implements PageHandler { public Group lookup(URL url) { // ... } } META-INF/dubbo/org.apache.dubbo.container.page.PageHandler\uff1a xxx=com.xxx.XxxPageHandler","title":"Page"},{"location":"dev/impls/page/#page-extension","text":"","title":"Page Extension"},{"location":"dev/impls/page/#summary","text":"Extension for page handler","title":"Summary"},{"location":"dev/impls/page/#extension-interface","text":"org.apache.dubbo.container.page.PageHandler","title":"Extension Interface"},{"location":"dev/impls/page/#extension-configuration","text":"dubbo:protocol page= xxx,yyy / !-- default configuration, will take effect if page attribute is not set in dubbo:protocol -- dubbo:provider page= xxx,yyy /","title":"Extension Configuration"},{"location":"dev/impls/page/#existing-extension","text":"org.apache.dubbo.container.page.pages.HomePageHandler org.apache.dubbo.container.page.pages.StatusPageHandler org.apache.dubbo.container.page.pages.LogPageHandler org.apache.dubbo.container.page.pages.SystemPageHandler","title":"Existing Extension"},{"location":"dev/impls/page/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxPageHandler.java (PageHandler implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.container.page.PageHandler (plain text file with the content: xxx=com.xxx.XxxPageHandler) XxxPageHandler.java\uff1a package com.xxx; import org.apache.dubbo.container.page.PageHandler; public class XxxPageHandler implements PageHandler { public Group lookup(URL url) { // ... } } META-INF/dubbo/org.apache.dubbo.container.page.PageHandler\uff1a xxx=com.xxx.XxxPageHandler","title":"Extension Guide"},{"location":"dev/impls/protocol/","text":"Protocol Extension Summary Extension to RPC protocol, hide details of remote call. Contract: When user calls invoke() method of Invoker object which's returned from refer() call, the protocol needs to correspondingly execute invoke() method of Invoker object passed from remote export() method associated with the same URL. Moreover, it's protocol's responsibility to implement Invoker which's returned from refer() . Generally speaking, protocol sends remote request in the Invoker implementation, but needs not to care about the Invoker passed into export() since the framework will implement the logic and pass in the instance. Notes: Protocol does not need to care about the proxy of the business interface. The upper layer of the framework will convert Invoker into business interface. It is not a requirement that the protocol must use TCP for network communication. It could be file-sharing, IPC, or others. Extension Interface org.apache.dubbo.rpc.Protocol org.apache.dubbo.rpc.Exporter org.apache.dubbo.rpc.Invoker public interface Protocol { /** * Export remote service: br * 1. Should save address info for the request when the protocol receives it: RpcContext.getContext().setRemoteAddress(); br * 2. export() must be implemented as idempotent, that is, it should not introduce side effect when the implementation gets called with the same Invoker for more than once. * 3. Invoker is passed by the framework, and the protocol should not care about it. br * * @param T Service type * @param invoker Service invoker * @return exporter The reference of service exporter, used for cancelling service export. * @throws RpcException throw when there's any error during service export, e.g. the port is occupied */ T Exporter T export(Invoker T invoker) throws RpcException; /** * Reference remote service: br * 1. When user calls `invoke()` method of `Invoker` object which's returned from `refer()` call, the protocol needs to correspondingly execute `invoke()` method of `Invoker` object passed from remote `export()` method associated with the same URL. br * 2. It's protocol's responsibility to implement `Invoker` which's returned from `refer()`. Generally speaking, protocol sends remote request in the `Invoker` implementation. br * 3. When there's check=false set in URL, the implementation must not throw exception but try to recover when connection fails. * * @param T Service type * @param type Service type * @param url URL address for the remote service * @return invoker service's local proxy * @throws RpcException throw when there's any error while connecting to the service provider */ T Invoker T refer(Class T type, URL url) throws RpcException; } Extension Configuration !-- declare protocol, if id is not set, then use the value of name for id -- dubbo:protocol id= xxx1 name= xxx / !-- reference protocol, if protocol's attribute is not set, then protocol configuration will be scanned automatically from ApplicationContext -- dubbo:service protocol= xxx1 / !-- default value for referenced protocol, it will be used if protocol attribute is not configured in dubbo:service -- dubbo:provider protocol= xxx1 / Existing Protocol org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol org.apache.dubbo.rpc.protocol.rmi.RmiProtocol org.apache.dubbo.rpc.protocol.http.HttpProtocol org.apache.dubbo.rpc.protocol.http.hessian.HessianProtocol Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxProtocol.java (Protocol implementation) |-XxxExporter.java (Exporter implementation) |-XxxInvoker.java (Invoker implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.Protocol (plain text file with the content: xxx=com.xxx.XxxProtocol) XxxProtocol.java\uff1a package com.xxx; import org.apache.dubbo.rpc.Protocol; public class XxxProtocol implements Protocol { public T Exporter T export(Invoker T invoker) throws RpcException { return new XxxExporter(invoker); } public T Invoker T refer(Class T type, URL url) throws RpcException { return new XxxInvoker(type, url); } } XxxExporter.java\uff1a package com.xxx; import org.apache.dubbo.rpc.support.AbstractExporter; public class XxxExporter T extends AbstractExporter T { public XxxExporter(Invoker T invoker) throws RemotingException{ super(invoker); // ... } public void unexport() { super.unexport(); // ... } } XxxInvoker.java\uff1a package com.xxx; import org.apache.dubbo.rpc.support.AbstractInvoker; public class XxxInvoker T extends AbstractInvoker T { public XxxInvoker(Class T type, URL url) throws RemotingException{ super(type, url); } protected abstract Object doInvoke(Invocation invocation) throws Throwable { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.Protocol\uff1a xxx=com.xxx.XxxProtocol","title":"Protocol"},{"location":"dev/impls/protocol/#protocol-extension","text":"","title":"Protocol Extension"},{"location":"dev/impls/protocol/#summary","text":"Extension to RPC protocol, hide details of remote call. Contract: When user calls invoke() method of Invoker object which's returned from refer() call, the protocol needs to correspondingly execute invoke() method of Invoker object passed from remote export() method associated with the same URL. Moreover, it's protocol's responsibility to implement Invoker which's returned from refer() . Generally speaking, protocol sends remote request in the Invoker implementation, but needs not to care about the Invoker passed into export() since the framework will implement the logic and pass in the instance. Notes: Protocol does not need to care about the proxy of the business interface. The upper layer of the framework will convert Invoker into business interface. It is not a requirement that the protocol must use TCP for network communication. It could be file-sharing, IPC, or others.","title":"Summary"},{"location":"dev/impls/protocol/#extension-interface","text":"org.apache.dubbo.rpc.Protocol org.apache.dubbo.rpc.Exporter org.apache.dubbo.rpc.Invoker public interface Protocol { /** * Export remote service: br * 1. Should save address info for the request when the protocol receives it: RpcContext.getContext().setRemoteAddress(); br * 2. export() must be implemented as idempotent, that is, it should not introduce side effect when the implementation gets called with the same Invoker for more than once. * 3. Invoker is passed by the framework, and the protocol should not care about it. br * * @param T Service type * @param invoker Service invoker * @return exporter The reference of service exporter, used for cancelling service export. * @throws RpcException throw when there's any error during service export, e.g. the port is occupied */ T Exporter T export(Invoker T invoker) throws RpcException; /** * Reference remote service: br * 1. When user calls `invoke()` method of `Invoker` object which's returned from `refer()` call, the protocol needs to correspondingly execute `invoke()` method of `Invoker` object passed from remote `export()` method associated with the same URL. br * 2. It's protocol's responsibility to implement `Invoker` which's returned from `refer()`. Generally speaking, protocol sends remote request in the `Invoker` implementation. br * 3. When there's check=false set in URL, the implementation must not throw exception but try to recover when connection fails. * * @param T Service type * @param type Service type * @param url URL address for the remote service * @return invoker service's local proxy * @throws RpcException throw when there's any error while connecting to the service provider */ T Invoker T refer(Class T type, URL url) throws RpcException; }","title":"Extension Interface"},{"location":"dev/impls/protocol/#extension-configuration","text":"!-- declare protocol, if id is not set, then use the value of name for id -- dubbo:protocol id= xxx1 name= xxx / !-- reference protocol, if protocol's attribute is not set, then protocol configuration will be scanned automatically from ApplicationContext -- dubbo:service protocol= xxx1 / !-- default value for referenced protocol, it will be used if protocol attribute is not configured in dubbo:service -- dubbo:provider protocol= xxx1 /","title":"Extension Configuration"},{"location":"dev/impls/protocol/#existing-protocol","text":"org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol org.apache.dubbo.rpc.protocol.rmi.RmiProtocol org.apache.dubbo.rpc.protocol.http.HttpProtocol org.apache.dubbo.rpc.protocol.http.hessian.HessianProtocol","title":"Existing Protocol"},{"location":"dev/impls/protocol/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxProtocol.java (Protocol implementation) |-XxxExporter.java (Exporter implementation) |-XxxInvoker.java (Invoker implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.Protocol (plain text file with the content: xxx=com.xxx.XxxProtocol) XxxProtocol.java\uff1a package com.xxx; import org.apache.dubbo.rpc.Protocol; public class XxxProtocol implements Protocol { public T Exporter T export(Invoker T invoker) throws RpcException { return new XxxExporter(invoker); } public T Invoker T refer(Class T type, URL url) throws RpcException { return new XxxInvoker(type, url); } } XxxExporter.java\uff1a package com.xxx; import org.apache.dubbo.rpc.support.AbstractExporter; public class XxxExporter T extends AbstractExporter T { public XxxExporter(Invoker T invoker) throws RemotingException{ super(invoker); // ... } public void unexport() { super.unexport(); // ... } } XxxInvoker.java\uff1a package com.xxx; import org.apache.dubbo.rpc.support.AbstractInvoker; public class XxxInvoker T extends AbstractInvoker T { public XxxInvoker(Class T type, URL url) throws RemotingException{ super(type, url); } protected abstract Object doInvoke(Invocation invocation) throws Throwable { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.Protocol\uff1a xxx=com.xxx.XxxProtocol","title":"Extension Guide"},{"location":"dev/impls/proxy-factory/","text":"ProxyFactory Extension Summary Convert Invoker into business interface. Extension Interface org.apache.dubbo.rpc.ProxyFactory Extension Configuration dubbo:protocol proxy= xxx / !-- default configuration, it will take effect when proxy attribute is not configured in dubbo:protocol -- dubbo:provider proxy= xxx / Existing Extension org.apache.dubbo.rpc.proxy.JdkProxyFactory org.apache.dubbo.rpc.proxy.JavassistProxyFactory Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxProxyFactory.java (ProxyFactory implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.ProxyFactory (plain text file with the content: xxx=com.xxx.XxxProxyFactory) XxxProxyFactory.java\uff1a package com.xxx; import org.apache.dubbo.rpc.ProxyFactory; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.RpcException; public class XxxProxyFactory implements ProxyFactory { public T T getProxy(Invoker T invoker) throws RpcException { // ... } public T Invoker T getInvoker(T proxy, Class T type, URL url) throws RpcException { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.ProxyFactory\uff1a xxx=com.xxx.XxxProxyFactory","title":"Proxy Factory"},{"location":"dev/impls/proxy-factory/#proxyfactory-extension","text":"","title":"ProxyFactory Extension"},{"location":"dev/impls/proxy-factory/#summary","text":"Convert Invoker into business interface.","title":"Summary"},{"location":"dev/impls/proxy-factory/#extension-interface","text":"org.apache.dubbo.rpc.ProxyFactory","title":"Extension Interface"},{"location":"dev/impls/proxy-factory/#extension-configuration","text":"dubbo:protocol proxy= xxx / !-- default configuration, it will take effect when proxy attribute is not configured in dubbo:protocol -- dubbo:provider proxy= xxx /","title":"Extension Configuration"},{"location":"dev/impls/proxy-factory/#existing-extension","text":"org.apache.dubbo.rpc.proxy.JdkProxyFactory org.apache.dubbo.rpc.proxy.JavassistProxyFactory","title":"Existing Extension"},{"location":"dev/impls/proxy-factory/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxProxyFactory.java (ProxyFactory implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.ProxyFactory (plain text file with the content: xxx=com.xxx.XxxProxyFactory) XxxProxyFactory.java\uff1a package com.xxx; import org.apache.dubbo.rpc.ProxyFactory; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.RpcException; public class XxxProxyFactory implements ProxyFactory { public T T getProxy(Invoker T invoker) throws RpcException { // ... } public T Invoker T getInvoker(T proxy, Class T type, URL url) throws RpcException { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.ProxyFactory\uff1a xxx=com.xxx.XxxProxyFactory","title":"Extension Guide"},{"location":"dev/impls/registry/","text":"Registry Extension Summary Registry extension is used for service registration and discovery. Extension Interface org.apache.dubbo.registry.RegistryFactory org.apache.dubbo.registry.Registry Extension Configuration !-- config registry server -- dubbo:registry id= xxx1 address= xxx://ip:port / !-- reference registry server, if registry attribute is not specified, then ApplicationContext will be scanned to find if there's any -- dubbo:service registry= xxx1 / !-- default configuration for referencing registry server, it will take effect if there's no registry attribute specified in dubbo:service -- dubbo:provider registry= xxx1 / Extension Contract RegistryFactory.java\uff1a public interface RegistryFactory { /** * Connect to registry server * * The contract for connecting to registry server: br * 1. Will not check connection when check=false is set, otherwise exception will be thrown if connection fails. br * 2. Support authorizing against username:password in the URL br * 3. Support registry server backup with backup=10.20.153.10 br * 4. Support cache on local disk with file=registry.cache br * 5. Support timeout setup with timeout=1000 br * 6. Support session expiration setup with session=60000 br * * @param url registry server address, null is not allowed * @return reference to registry server, never return null */ Registry getRegistry(URL url); } RegistryService.java\uff1a public interface RegistryService { // Registry extends RegistryService /** * Register service. * * Contract for registering service: br * 1. Registration failure will be ignored and kept retrying if check=false is set in URL, otherwise exception will be thrown br * 2. Persistence is required if dynamic=false is set in URL, otherwise, the registration info will be removed automatically when register quits accidentally br * 3. Persistent by category if category=overrides is set in URL, default category is providers. It is possible to notify by category. br * 4. Data lost is not tolerant when registry server reboots or network jitter happens. br * 5. It is not allowed to override each other when URLs have same URI part but different parameters br * * @param url registration info\uff0cnull is not allowed, e.g.: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0 application=kylin */ void register(URL url); /** * Unregister service. * * Contract for unregistering service: br * 1. IllegalStateException should be thrown when registration info which's supposed to be persistent (with dynamic=false set) cannot be found, otherwise it should be ignored. br * 2. To cancel one service, extract match on its URL will be honored br * * @param url registration info\uff0cnull is not allowed, e.g.: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0 application=kylin */ void unregister(URL url); /** * \u8ba2\u9605\u670d\u52a1. * Subscribe service. * * Contract for subscribing service: br * 1. Subscription failure will be ignored and kept retrying if check=false is set in URL br * 2. Only the specified category will be notified if category=overrides is set in URL. Categories are seperated with comma, and all categorized data will be subscribed when wildcard * is specified. br * 3. Allow to query by interface, group, version, classifier, e.g.: interface=com.alibaba.foo.BarService version=1.0.0 br * 4. Allow to query with wildcard * to subscribe all versions under all categories for all interfaces, e.g.: interface=* group=* version=* classifier=* br * 5. Subscription will be automatically recoverred when registry server reboots or network jitter happens. br * 6. It is not allowed to override each other when URLs have same URI part but different parameters br * 7. Subscription procedure will not return until the first notification happens. br * * @param url URL for subscription, null isn't allowed, e.g.: consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0 application=kylin * @param listener notification listener, null is not allowed */ void subscribe(URL url, NotifyListener listener); /** * Unsubscribe service. * * Contract for unsubscribing service: br * 1. Simply ignore if not subscribe br * 2. Unsubscribe with URL exact match br * * @param url URL for unsubscription, null is not allowed, e.g.: consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0 application=kylin * @param listener notification listener, null is not allowed */ void unsubscribe(URL url, NotifyListener listener); /** * \u67e5\u8be2\u6ce8\u518c\u5217\u8868\uff0c\u4e0e\u8ba2\u9605\u7684\u63a8\u6a21\u5f0f\u76f8\u5bf9\u5e94\uff0c\u8fd9\u91cc\u4e3a\u62c9\u6a21\u5f0f\uff0c\u53ea\u8fd4\u56de\u4e00\u6b21\u7ed3\u679c\u3002 * Lookup subscription list. Compared to push mode for subscription, this is pull mode and returns result only once. * * @see org.apache.dubbo.registry.NotifyListener#notify(List) * @param url URL for query, null is not allowed, e.g.: consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0 application=kylin * @return subscription list, could be null, has the same meaning as the parameters in {@link org.apache.dubbo.registry.NotifyListener#notify(List URL )}. */ List URL lookup(URL url); } NotifyListener.java\uff1a public interface NotifyListener { /** * Fire event when receive service change notification. * * Contract for notify: br * 1. Always notify with the whole data instead of partial data from the perspective of service interface and data type. In this way, user needs not compare with the previous result. br * 2. First notification for subscription must contain the full set of data for one particular service br * 3. It is allowed to separate the different type of data in the upcoming notifications, e.g.: it is legal to only notify one of types among providers, consumers, routes or overrides each time, but pls. note for this particular type, the data must be a full set. br * 4. If the data for one particular type is empty, need to notify with a special URL which has empty as its protocol and has category parameter for this particluar type. * 5. Notifier (usually it is monitor center) needs to guarantee the notification sequence by, for say: single thread push, queuing in order, versioning, etc. br * * @param urls subscription list, always not empty, equivalent to the return result of {@link org.apache.dubbo.registry.RegistryService#lookup(URL)}. */ void notify(List URL urls); } Existing Extension org.apache.dubbo.registry.support.dubbo.DubboRegistryFactory Extension Guide Directory structure: src |-main |-java |-com |-xxx |-XxxRegistryFactoryjava (RegistryFactory implementation) |-XxxRegistry.java (Registry implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.registry.RegistryFactory (plain text file with the content: xxx=com.xxx.XxxRegistryFactory) XxxRegistryFactory.java\uff1a package com.xxx; import org.apache.dubbo.registry.RegistryFactory; import org.apache.dubbo.registry.Registry; import org.apache.dubbo.common.URL; public class XxxRegistryFactory implements RegistryFactory { public Registry getRegistry(URL url) { return new XxxRegistry(url); } } XxxRegistry.java\uff1a package com.xxx; import org.apache.dubbo.registry.Registry; import org.apache.dubbo.registry.NotifyListener; import org.apache.dubbo.common.URL; public class XxxRegistry implements Registry { public void register(URL url) { // ... } public void unregister(URL url) { // ... } public void subscribe(URL url, NotifyListener listener) { // ... } public void unsubscribe(URL url, NotifyListener listener) { // ... } } META-INF/dubbo/org.apache.dubbo.registry.RegistryFactory\uff1a xxx=com.xxx.XxxRegistryFactory","title":"Registry"},{"location":"dev/impls/registry/#registry-extension","text":"","title":"Registry Extension"},{"location":"dev/impls/registry/#summary","text":"Registry extension is used for service registration and discovery.","title":"Summary"},{"location":"dev/impls/registry/#extension-interface","text":"org.apache.dubbo.registry.RegistryFactory org.apache.dubbo.registry.Registry","title":"Extension Interface"},{"location":"dev/impls/registry/#extension-configuration","text":"!-- config registry server -- dubbo:registry id= xxx1 address= xxx://ip:port / !-- reference registry server, if registry attribute is not specified, then ApplicationContext will be scanned to find if there's any -- dubbo:service registry= xxx1 / !-- default configuration for referencing registry server, it will take effect if there's no registry attribute specified in dubbo:service -- dubbo:provider registry= xxx1 /","title":"Extension Configuration"},{"location":"dev/impls/registry/#extension-contract","text":"RegistryFactory.java\uff1a public interface RegistryFactory { /** * Connect to registry server * * The contract for connecting to registry server: br * 1. Will not check connection when check=false is set, otherwise exception will be thrown if connection fails. br * 2. Support authorizing against username:password in the URL br * 3. Support registry server backup with backup=10.20.153.10 br * 4. Support cache on local disk with file=registry.cache br * 5. Support timeout setup with timeout=1000 br * 6. Support session expiration setup with session=60000 br * * @param url registry server address, null is not allowed * @return reference to registry server, never return null */ Registry getRegistry(URL url); } RegistryService.java\uff1a public interface RegistryService { // Registry extends RegistryService /** * Register service. * * Contract for registering service: br * 1. Registration failure will be ignored and kept retrying if check=false is set in URL, otherwise exception will be thrown br * 2. Persistence is required if dynamic=false is set in URL, otherwise, the registration info will be removed automatically when register quits accidentally br * 3. Persistent by category if category=overrides is set in URL, default category is providers. It is possible to notify by category. br * 4. Data lost is not tolerant when registry server reboots or network jitter happens. br * 5. It is not allowed to override each other when URLs have same URI part but different parameters br * * @param url registration info\uff0cnull is not allowed, e.g.: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0 application=kylin */ void register(URL url); /** * Unregister service. * * Contract for unregistering service: br * 1. IllegalStateException should be thrown when registration info which's supposed to be persistent (with dynamic=false set) cannot be found, otherwise it should be ignored. br * 2. To cancel one service, extract match on its URL will be honored br * * @param url registration info\uff0cnull is not allowed, e.g.: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0 application=kylin */ void unregister(URL url); /** * \u8ba2\u9605\u670d\u52a1. * Subscribe service. * * Contract for subscribing service: br * 1. Subscription failure will be ignored and kept retrying if check=false is set in URL br * 2. Only the specified category will be notified if category=overrides is set in URL. Categories are seperated with comma, and all categorized data will be subscribed when wildcard * is specified. br * 3. Allow to query by interface, group, version, classifier, e.g.: interface=com.alibaba.foo.BarService version=1.0.0 br * 4. Allow to query with wildcard * to subscribe all versions under all categories for all interfaces, e.g.: interface=* group=* version=* classifier=* br * 5. Subscription will be automatically recoverred when registry server reboots or network jitter happens. br * 6. It is not allowed to override each other when URLs have same URI part but different parameters br * 7. Subscription procedure will not return until the first notification happens. br * * @param url URL for subscription, null isn't allowed, e.g.: consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0 application=kylin * @param listener notification listener, null is not allowed */ void subscribe(URL url, NotifyListener listener); /** * Unsubscribe service. * * Contract for unsubscribing service: br * 1. Simply ignore if not subscribe br * 2. Unsubscribe with URL exact match br * * @param url URL for unsubscription, null is not allowed, e.g.: consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0 application=kylin * @param listener notification listener, null is not allowed */ void unsubscribe(URL url, NotifyListener listener); /** * \u67e5\u8be2\u6ce8\u518c\u5217\u8868\uff0c\u4e0e\u8ba2\u9605\u7684\u63a8\u6a21\u5f0f\u76f8\u5bf9\u5e94\uff0c\u8fd9\u91cc\u4e3a\u62c9\u6a21\u5f0f\uff0c\u53ea\u8fd4\u56de\u4e00\u6b21\u7ed3\u679c\u3002 * Lookup subscription list. Compared to push mode for subscription, this is pull mode and returns result only once. * * @see org.apache.dubbo.registry.NotifyListener#notify(List) * @param url URL for query, null is not allowed, e.g.: consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0 application=kylin * @return subscription list, could be null, has the same meaning as the parameters in {@link org.apache.dubbo.registry.NotifyListener#notify(List URL )}. */ List URL lookup(URL url); } NotifyListener.java\uff1a public interface NotifyListener { /** * Fire event when receive service change notification. * * Contract for notify: br * 1. Always notify with the whole data instead of partial data from the perspective of service interface and data type. In this way, user needs not compare with the previous result. br * 2. First notification for subscription must contain the full set of data for one particular service br * 3. It is allowed to separate the different type of data in the upcoming notifications, e.g.: it is legal to only notify one of types among providers, consumers, routes or overrides each time, but pls. note for this particular type, the data must be a full set. br * 4. If the data for one particular type is empty, need to notify with a special URL which has empty as its protocol and has category parameter for this particluar type. * 5. Notifier (usually it is monitor center) needs to guarantee the notification sequence by, for say: single thread push, queuing in order, versioning, etc. br * * @param urls subscription list, always not empty, equivalent to the return result of {@link org.apache.dubbo.registry.RegistryService#lookup(URL)}. */ void notify(List URL urls); }","title":"Extension Contract"},{"location":"dev/impls/registry/#existing-extension","text":"org.apache.dubbo.registry.support.dubbo.DubboRegistryFactory","title":"Existing Extension"},{"location":"dev/impls/registry/#extension-guide","text":"Directory structure: src |-main |-java |-com |-xxx |-XxxRegistryFactoryjava (RegistryFactory implementation) |-XxxRegistry.java (Registry implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.registry.RegistryFactory (plain text file with the content: xxx=com.xxx.XxxRegistryFactory) XxxRegistryFactory.java\uff1a package com.xxx; import org.apache.dubbo.registry.RegistryFactory; import org.apache.dubbo.registry.Registry; import org.apache.dubbo.common.URL; public class XxxRegistryFactory implements RegistryFactory { public Registry getRegistry(URL url) { return new XxxRegistry(url); } } XxxRegistry.java\uff1a package com.xxx; import org.apache.dubbo.registry.Registry; import org.apache.dubbo.registry.NotifyListener; import org.apache.dubbo.common.URL; public class XxxRegistry implements Registry { public void register(URL url) { // ... } public void unregister(URL url) { // ... } public void subscribe(URL url, NotifyListener listener) { // ... } public void unsubscribe(URL url, NotifyListener listener) { // ... } } META-INF/dubbo/org.apache.dubbo.registry.RegistryFactory\uff1a xxx=com.xxx.XxxRegistryFactory","title":"Extension Guide"},{"location":"dev/impls/remoting/","text":"Transporter Extension Summary Transportation extension for communication between server and client. Extension Interface org.apache.dubbo.remoting.Transporter org.apache.dubbo.remoting.Server org.apache.dubbo.remoting.Client Extension Configuration !-- server and client use the same transporter -- dubbo:protocol transporter= xxx / !-- server and client use the different transporter -- dubbo:protocol server= xxx client= xxx / !-- default configuration, will take effect when transport/server/client attribute is not set in dubbo:protocol -- dubbo:provider transporter= xxx server= xxx client= xxx / Existing Extension org.apache.dubbo.remoting.transport.transporter.netty.NettyTransporter org.apache.dubbo.remoting.transport.transporter.mina.MinaTransporter org.apache.dubbo.remoting.transport.transporter.grizzly.GrizzlyTransporter Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxTransporter.java (Transporter implementation) |-XxxServer.java (Server implementation) |-XxxClient.java (Client implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.Transporter (plain text file with the content: xxx=com.xxx.XxxTransporter) XxxTransporter.java\uff1a package com.xxx; import org.apache.dubbo.remoting.Transporter; public class XxxTransporter implements Transporter { public Server bind(URL url, ChannelHandler handler) throws RemotingException { return new XxxServer(url, handler); } public Client connect(URL url, ChannelHandler handler) throws RemotingException { return new XxxClient(url, handler); } } XxxServer.java\uff1a package com.xxx; import org.apache.dubbo.remoting.transport.transporter.AbstractServer; public class XxxServer extends AbstractServer { public XxxServer(URL url, ChannelHandler handler) throws RemotingException{ super(url, handler); } protected void doOpen() throws Throwable { // ... } protected void doClose() throws Throwable { // ... } public Collection Channel getChannels() { // ... } public Channel getChannel(InetSocketAddress remoteAddress) { // ... } } XxxClient.java\uff1a package com.xxx; import org.apache.dubbo.remoting.transport.transporter.AbstractClient; public class XxxClient extends AbstractClient { public XxxServer(URL url, ChannelHandler handler) throws RemotingException{ super(url, handler); } protected void doOpen() throws Throwable { // ... } protected void doClose() throws Throwable { // ... } protected void doConnect() throws Throwable { // ... } public Channel getChannel() { // ... } } META-INF/dubbo/org.apache.dubbo.remoting.Transporter\uff1a xxx=com.xxx.XxxTransporter","title":"Remoting"},{"location":"dev/impls/remoting/#transporter-extension","text":"","title":"Transporter Extension"},{"location":"dev/impls/remoting/#summary","text":"Transportation extension for communication between server and client.","title":"Summary"},{"location":"dev/impls/remoting/#extension-interface","text":"org.apache.dubbo.remoting.Transporter org.apache.dubbo.remoting.Server org.apache.dubbo.remoting.Client","title":"Extension Interface"},{"location":"dev/impls/remoting/#extension-configuration","text":"!-- server and client use the same transporter -- dubbo:protocol transporter= xxx / !-- server and client use the different transporter -- dubbo:protocol server= xxx client= xxx / !-- default configuration, will take effect when transport/server/client attribute is not set in dubbo:protocol -- dubbo:provider transporter= xxx server= xxx client= xxx /","title":"Extension Configuration"},{"location":"dev/impls/remoting/#existing-extension","text":"org.apache.dubbo.remoting.transport.transporter.netty.NettyTransporter org.apache.dubbo.remoting.transport.transporter.mina.MinaTransporter org.apache.dubbo.remoting.transport.transporter.grizzly.GrizzlyTransporter","title":"Existing Extension"},{"location":"dev/impls/remoting/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxTransporter.java (Transporter implementation) |-XxxServer.java (Server implementation) |-XxxClient.java (Client implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.Transporter (plain text file with the content: xxx=com.xxx.XxxTransporter) XxxTransporter.java\uff1a package com.xxx; import org.apache.dubbo.remoting.Transporter; public class XxxTransporter implements Transporter { public Server bind(URL url, ChannelHandler handler) throws RemotingException { return new XxxServer(url, handler); } public Client connect(URL url, ChannelHandler handler) throws RemotingException { return new XxxClient(url, handler); } } XxxServer.java\uff1a package com.xxx; import org.apache.dubbo.remoting.transport.transporter.AbstractServer; public class XxxServer extends AbstractServer { public XxxServer(URL url, ChannelHandler handler) throws RemotingException{ super(url, handler); } protected void doOpen() throws Throwable { // ... } protected void doClose() throws Throwable { // ... } public Collection Channel getChannels() { // ... } public Channel getChannel(InetSocketAddress remoteAddress) { // ... } } XxxClient.java\uff1a package com.xxx; import org.apache.dubbo.remoting.transport.transporter.AbstractClient; public class XxxClient extends AbstractClient { public XxxServer(URL url, ChannelHandler handler) throws RemotingException{ super(url, handler); } protected void doOpen() throws Throwable { // ... } protected void doClose() throws Throwable { // ... } protected void doConnect() throws Throwable { // ... } public Channel getChannel() { // ... } } META-INF/dubbo/org.apache.dubbo.remoting.Transporter\uff1a xxx=com.xxx.XxxTransporter","title":"Extension Guide"},{"location":"dev/impls/router/","text":"Router Extension Summary Pick one from service providers and fire the invocation. Extension Interface org.apache.dubbo.rpc.cluster.RouterFactory org.apache.dubbo.rpc.cluster.Router Existing Extension org.apache.dubbo.rpc.cluster.router.ScriptRouterFactory org.apache.dubbo.rpc.cluster.router.FileRouterFactory Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxRouterFactory.java (RouterFactory implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.RouterFactory (plain text file with the content: xxx=com.xxx.XxxRouterFactory) XxxRouterFactory.java\uff1a package com.xxx; import org.apache.dubbo.rpc.cluster.RouterFactory; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.RpcException; public class XxxRouterFactory implements RouterFactory { public T List Invoker T select(List Invoker T invokers, Invocation invocation) throws RpcException { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.RouterFactory\uff1a xxx=com.xxx.XxxRouterFactory","title":"Router"},{"location":"dev/impls/router/#router-extension","text":"","title":"Router Extension"},{"location":"dev/impls/router/#summary","text":"Pick one from service providers and fire the invocation.","title":"Summary"},{"location":"dev/impls/router/#extension-interface","text":"org.apache.dubbo.rpc.cluster.RouterFactory org.apache.dubbo.rpc.cluster.Router","title":"Extension Interface"},{"location":"dev/impls/router/#existing-extension","text":"org.apache.dubbo.rpc.cluster.router.ScriptRouterFactory org.apache.dubbo.rpc.cluster.router.FileRouterFactory","title":"Existing Extension"},{"location":"dev/impls/router/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxRouterFactory.java (RouterFactory implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.RouterFactory (plain text file with the content: xxx=com.xxx.XxxRouterFactory) XxxRouterFactory.java\uff1a package com.xxx; import org.apache.dubbo.rpc.cluster.RouterFactory; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.RpcException; public class XxxRouterFactory implements RouterFactory { public T List Invoker T select(List Invoker T invokers, Invocation invocation) throws RpcException { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.RouterFactory\uff1a xxx=com.xxx.XxxRouterFactory","title":"Extension Guide"},{"location":"dev/impls/serialize/","text":"Serialization Extension Summary Extension to serializing java object into byte code stream for transporting on the network, and vise versa. Extension Interface org.apache.dubbo.common.serialize.Serialization org.apache.dubbo.common.serialize.ObjectInput org.apache.dubbo.common.serialize.ObjectOutput Extension Configuration !-- protocol serialization style -- dubbo:protocol serialization= xxx / !-- default configuration, will take effect if serialization is not configured in dubbo:protocol -- dubbo:provider serialization= xxx / Existing Extension org.apache.dubbo.common.serialize.dubbo.DubboSerialization org.apache.dubbo.common.serialize.hessian.Hessian2Serialization org.apache.dubbo.common.serialize.java.JavaSerialization org.apache.dubbo.common.serialize.java.CompactedJavaSerialization Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxSerialization.java (Serialization implementation) |-XxxObjectInput.java (ObjectInput implementation) |-XxxObjectOutput.java (ObjectOutput implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.serialize.Serialization (plain text file with the content: xxx=com.xxx.XxxSerialization) XxxSerialization.java\uff1a package com.xxx; import org.apache.dubbo.common.serialize.Serialization; import org.apache.dubbo.common.serialize.ObjectInput; import org.apache.dubbo.common.serialize.ObjectOutput; public class XxxSerialization implements Serialization { public ObjectOutput serialize(Parameters parameters, OutputStream output) throws IOException { return new XxxObjectOutput(output); } public ObjectInput deserialize(Parameters parameters, InputStream input) throws IOException { return new XxxObjectInput(input); } } META-INF/dubbo/org.apache.dubbo.common.serialize.Serialization\uff1a xxx=com.xxx.XxxSerialization","title":"Serialize"},{"location":"dev/impls/serialize/#serialization-extension","text":"","title":"Serialization Extension"},{"location":"dev/impls/serialize/#summary","text":"Extension to serializing java object into byte code stream for transporting on the network, and vise versa.","title":"Summary"},{"location":"dev/impls/serialize/#extension-interface","text":"org.apache.dubbo.common.serialize.Serialization org.apache.dubbo.common.serialize.ObjectInput org.apache.dubbo.common.serialize.ObjectOutput","title":"Extension Interface"},{"location":"dev/impls/serialize/#extension-configuration","text":"!-- protocol serialization style -- dubbo:protocol serialization= xxx / !-- default configuration, will take effect if serialization is not configured in dubbo:protocol -- dubbo:provider serialization= xxx /","title":"Extension Configuration"},{"location":"dev/impls/serialize/#existing-extension","text":"org.apache.dubbo.common.serialize.dubbo.DubboSerialization org.apache.dubbo.common.serialize.hessian.Hessian2Serialization org.apache.dubbo.common.serialize.java.JavaSerialization org.apache.dubbo.common.serialize.java.CompactedJavaSerialization","title":"Existing Extension"},{"location":"dev/impls/serialize/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxSerialization.java (Serialization implementation) |-XxxObjectInput.java (ObjectInput implementation) |-XxxObjectOutput.java (ObjectOutput implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.serialize.Serialization (plain text file with the content: xxx=com.xxx.XxxSerialization) XxxSerialization.java\uff1a package com.xxx; import org.apache.dubbo.common.serialize.Serialization; import org.apache.dubbo.common.serialize.ObjectInput; import org.apache.dubbo.common.serialize.ObjectOutput; public class XxxSerialization implements Serialization { public ObjectOutput serialize(Parameters parameters, OutputStream output) throws IOException { return new XxxObjectOutput(output); } public ObjectInput deserialize(Parameters parameters, InputStream input) throws IOException { return new XxxObjectInput(input); } } META-INF/dubbo/org.apache.dubbo.common.serialize.Serialization\uff1a xxx=com.xxx.XxxSerialization","title":"Extension Guide"},{"location":"dev/impls/status-checker/","text":"StatusChecker Extension Summary Extension to check status of resources service depends on. This status checker can be used in both telnet status command and status page. Extension Interface org.apache.dubbo.common.status.StatusChecker Extension Configuration dubbo:protocol status= xxx,yyy / !-- default configuration, will take effect if no status attribute is configured in dubbo:protocol -- dubbo:provider status= xxx,yyy / Existing Extension org.apache.dubbo.common.status.support.MemoryStatusChecker org.apache.dubbo.common.status.support.LoadStatusChecker org.apache.dubbo.rpc.dubbo.status.ServerStatusChecker org.apache.dubbo.rpc.dubbo.status.ThreadPoolStatusChecker org.apache.dubbo.registry.directory.RegistryStatusChecker org.apache.dubbo.rpc.config.spring.status.SpringStatusChecker org.apache.dubbo.rpc.config.spring.status.DataSourceStatusChecker Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxStatusChecker.java (StatusChecker implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.status.StatusChecker (plain text file with the content: xxx=com.xxx.XxxStatusChecker) XxxStatusChecker.java\uff1a package com.xxx; import org.apache.dubbo.common.status.StatusChecker; public class XxxStatusChecker implements StatusChecker { public Status check() { // ... } } META-INF/dubbo/org.apache.dubbo.common.status.StatusChecker\uff1a xxx=com.xxx.XxxStatusChecker","title":"Status Checker"},{"location":"dev/impls/status-checker/#statuschecker-extension","text":"","title":"StatusChecker Extension"},{"location":"dev/impls/status-checker/#summary","text":"Extension to check status of resources service depends on. This status checker can be used in both telnet status command and status page.","title":"Summary"},{"location":"dev/impls/status-checker/#extension-interface","text":"org.apache.dubbo.common.status.StatusChecker","title":"Extension Interface"},{"location":"dev/impls/status-checker/#extension-configuration","text":"dubbo:protocol status= xxx,yyy / !-- default configuration, will take effect if no status attribute is configured in dubbo:protocol -- dubbo:provider status= xxx,yyy /","title":"Extension Configuration"},{"location":"dev/impls/status-checker/#existing-extension","text":"org.apache.dubbo.common.status.support.MemoryStatusChecker org.apache.dubbo.common.status.support.LoadStatusChecker org.apache.dubbo.rpc.dubbo.status.ServerStatusChecker org.apache.dubbo.rpc.dubbo.status.ThreadPoolStatusChecker org.apache.dubbo.registry.directory.RegistryStatusChecker org.apache.dubbo.rpc.config.spring.status.SpringStatusChecker org.apache.dubbo.rpc.config.spring.status.DataSourceStatusChecker","title":"Existing Extension"},{"location":"dev/impls/status-checker/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxStatusChecker.java (StatusChecker implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.status.StatusChecker (plain text file with the content: xxx=com.xxx.XxxStatusChecker) XxxStatusChecker.java\uff1a package com.xxx; import org.apache.dubbo.common.status.StatusChecker; public class XxxStatusChecker implements StatusChecker { public Status check() { // ... } } META-INF/dubbo/org.apache.dubbo.common.status.StatusChecker\uff1a xxx=com.xxx.XxxStatusChecker","title":"Extension Guide"},{"location":"dev/impls/telnet-handler/","text":"TelnetHandler Extension Summary Extension to telnet command. All server should support telnet access for operation convenience. Extension Interface org.apache.dubbo.remoting.telnet.TelnetHandler Extension Configuration dubbo:protocol telnet= xxx,yyy / !-- default configuration, will take effect if telnet attribute is not specified in dubbo:protocol -- dubbo:provider telnet= xxx,yyy / Existing Extension org.apache.dubbo.remoting.telnet.support.ClearTelnetHandler org.apache.dubbo.remoting.telnet.support.ExitTelnetHandler org.apache.dubbo.remoting.telnet.support.HelpTelnetHandler org.apache.dubbo.remoting.telnet.support.StatusTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.ListTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.ChangeTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.CurrentTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.InvokeTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.TraceTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.CountTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.PortTelnetHandler Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxTelnetHandler.java (TelnetHandler implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.telnet.TelnetHandler (plain text file with the content: xxx=com.xxx.XxxTelnetHandler) XxxTelnetHandler.java\uff1a package com.xxx; import org.apache.dubbo.remoting.telnet.TelnetHandler; @Help(parameter= ... , summary= ... , detail= ... ) public class XxxTelnetHandler implements TelnetHandler { public String telnet(Channel channel, String message) throws RemotingException { // ... } } META-INF/dubbo/org.apache.dubbo.remoting.telnet.TelnetHandler\uff1a xxx=com.xxx.XxxTelnetHandler \u7528\u6cd5 telnet 127.0.0.1 20880 dubbo xxx args","title":"Telnet Handler"},{"location":"dev/impls/telnet-handler/#telnethandler-extension","text":"","title":"TelnetHandler Extension"},{"location":"dev/impls/telnet-handler/#summary","text":"Extension to telnet command. All server should support telnet access for operation convenience.","title":"Summary"},{"location":"dev/impls/telnet-handler/#extension-interface","text":"org.apache.dubbo.remoting.telnet.TelnetHandler","title":"Extension Interface"},{"location":"dev/impls/telnet-handler/#extension-configuration","text":"dubbo:protocol telnet= xxx,yyy / !-- default configuration, will take effect if telnet attribute is not specified in dubbo:protocol -- dubbo:provider telnet= xxx,yyy /","title":"Extension Configuration"},{"location":"dev/impls/telnet-handler/#existing-extension","text":"org.apache.dubbo.remoting.telnet.support.ClearTelnetHandler org.apache.dubbo.remoting.telnet.support.ExitTelnetHandler org.apache.dubbo.remoting.telnet.support.HelpTelnetHandler org.apache.dubbo.remoting.telnet.support.StatusTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.ListTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.ChangeTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.CurrentTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.InvokeTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.TraceTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.CountTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.PortTelnetHandler","title":"Existing Extension"},{"location":"dev/impls/telnet-handler/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxTelnetHandler.java (TelnetHandler implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.telnet.TelnetHandler (plain text file with the content: xxx=com.xxx.XxxTelnetHandler) XxxTelnetHandler.java\uff1a package com.xxx; import org.apache.dubbo.remoting.telnet.TelnetHandler; @Help(parameter= ... , summary= ... , detail= ... ) public class XxxTelnetHandler implements TelnetHandler { public String telnet(Channel channel, String message) throws RemotingException { // ... } } META-INF/dubbo/org.apache.dubbo.remoting.telnet.TelnetHandler\uff1a xxx=com.xxx.XxxTelnetHandler","title":"Extension Guide"},{"location":"dev/impls/telnet-handler/#_1","text":"telnet 127.0.0.1 20880 dubbo xxx args","title":"\u7528\u6cd5"},{"location":"dev/impls/threadpool/","text":"ThreadPool Extension Summary Thread pool strategy extension for service provider. When server receives one request, it needs a thread from thread pool to execute business logic in service provider. Extension Interface org.apache.dubbo.common.threadpool.ThreadPool Extension Configuration dubbo:protocol threadpool= xxx / !-- default configuration, it will take effect when threadpool attribute is not specified in dubbo:protocol -- dubbo:provider threadpool= xxx / Existing Extension org.apache.dubbo.common.threadpool.FixedThreadPool org.apache.dubbo.common.threadpool.CachedThreadPool Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxThreadPool.java (ThreadPool implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.threadpool.ThreadPool (plain text file with the content: xxx=com.xxx.XxxThreadPool) XxxThreadPool.java\uff1a package com.xxx; import org.apache.dubbo.common.threadpool.ThreadPool; import java.util.concurrent.Executor; public class XxxThreadPool implements ThreadPool { public Executor getExecutor() { // ... } } META-INF/dubbo/org.apache.dubbo.common.threadpool.ThreadPool\uff1a xxx=com.xxx.XxxThreadPool","title":"Threadpool"},{"location":"dev/impls/threadpool/#threadpool-extension","text":"","title":"ThreadPool Extension"},{"location":"dev/impls/threadpool/#summary","text":"Thread pool strategy extension for service provider. When server receives one request, it needs a thread from thread pool to execute business logic in service provider.","title":"Summary"},{"location":"dev/impls/threadpool/#extension-interface","text":"org.apache.dubbo.common.threadpool.ThreadPool","title":"Extension Interface"},{"location":"dev/impls/threadpool/#extension-configuration","text":"dubbo:protocol threadpool= xxx / !-- default configuration, it will take effect when threadpool attribute is not specified in dubbo:protocol -- dubbo:provider threadpool= xxx /","title":"Extension Configuration"},{"location":"dev/impls/threadpool/#existing-extension","text":"org.apache.dubbo.common.threadpool.FixedThreadPool org.apache.dubbo.common.threadpool.CachedThreadPool","title":"Existing Extension"},{"location":"dev/impls/threadpool/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxThreadPool.java (ThreadPool implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.threadpool.ThreadPool (plain text file with the content: xxx=com.xxx.XxxThreadPool) XxxThreadPool.java\uff1a package com.xxx; import org.apache.dubbo.common.threadpool.ThreadPool; import java.util.concurrent.Executor; public class XxxThreadPool implements ThreadPool { public Executor getExecutor() { // ... } } META-INF/dubbo/org.apache.dubbo.common.threadpool.ThreadPool\uff1a xxx=com.xxx.XxxThreadPool","title":"Extension Guide"},{"location":"dev/impls/validation/","text":"Validation Extension Summary Extension for parameter validation. Extension Inteface org.apache.dubbo.validation.Validation Extension Configuration dubbo:service validation= xxx,yyy / !-- default configuration, it will take effect when there's no validation attribute specified in dubbo:service -- dubbo:provider validation= xxx,yyy / Existing Extension org.apache.dubbo.validation.support.jvalidation.JValidation Extension Guide Directory layout: src |-main |-java |-com |-xxx |-XxxValidation.java (Validation implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.validation.Validation (plain text file with the content: xxx=com.xxx.XxxValidation) XxxValidation.java\uff1a package com.xxx; import org.apache.dubbo.validation.Validation; public class XxxValidation implements Validation { public Object getValidator(URL url) { // ... } } XxxValidator.java\uff1a package com.xxx; import org.apache.dubbo.validation.Validator; public class XxxValidator implements Validator { public XxxValidator(URL url) { // ... } public void validate(Invocation invocation) throws Exception { // ... } } META-INF/dubbo/org.apache.dubbo.validation.Validation\uff1a xxx=com.xxx.XxxValidation","title":"Validation"},{"location":"dev/impls/validation/#validation-extension","text":"","title":"Validation Extension"},{"location":"dev/impls/validation/#summary","text":"Extension for parameter validation.","title":"Summary"},{"location":"dev/impls/validation/#extension-inteface","text":"org.apache.dubbo.validation.Validation","title":"Extension Inteface"},{"location":"dev/impls/validation/#extension-configuration","text":"dubbo:service validation= xxx,yyy / !-- default configuration, it will take effect when there's no validation attribute specified in dubbo:service -- dubbo:provider validation= xxx,yyy /","title":"Extension Configuration"},{"location":"dev/impls/validation/#existing-extension","text":"org.apache.dubbo.validation.support.jvalidation.JValidation","title":"Existing Extension"},{"location":"dev/impls/validation/#extension-guide","text":"Directory layout: src |-main |-java |-com |-xxx |-XxxValidation.java (Validation implementation) |-resources |-META-INF |-dubbo |-org.apache.dubbo.validation.Validation (plain text file with the content: xxx=com.xxx.XxxValidation) XxxValidation.java\uff1a package com.xxx; import org.apache.dubbo.validation.Validation; public class XxxValidation implements Validation { public Object getValidator(URL url) { // ... } } XxxValidator.java\uff1a package com.xxx; import org.apache.dubbo.validation.Validator; public class XxxValidator implements Validator { public XxxValidator(URL url) { // ... } public void validate(Invocation invocation) throws Exception { // ... } } META-INF/dubbo/org.apache.dubbo.validation.Validation\uff1a xxx=com.xxx.XxxValidation","title":"Extension Guide"},{"location":"dev/principals/code-detail/","text":"The devil is in the details http://javatar.iteye.com/blog/1056664 Recently, I have been worried about the quality of the Dubbo distributed service framework. If there are more maintenance personnel or changes, there will be a decline in quality. I am thinking, is there any need for everyone to abide by it, according to a habit when writing code, I have summarized it. The code process, especially the framework code, should always keep in mind the details. Maybe the following will be said, everyone will feel very simple, very basic, but always keep in mind. Considering these factors in every line of code requires a lot of patience. It is often said that the devil is in the details. Prevent null pointer dereference and index out of bounds This is the exception I least like to see, especially in the core framework, in contrast I would like to see a parameter not legal exception with detail information. This is also a robust program developer who should be prevented in the subconscious by writing every line of code. Basically, you must be able to ensure that the code that is written once will not appear in the case of no test. Ensure thread safety and visibility For framework developers, a deep understanding of thread safety and visibility is the most basic requirement. Developers are required to ensure that they are correct in the subconscious when writing each line of code. Because of this kind of code, it will look normal when doing functional tests under small concurrency. However, under high concurrency, there will be inexplicable problems, and the scene is difficult to reproduce, and it is extremely difficult to check. Fail fast and precondition Fail fast should also become a subconscious mind, assert at the entrance when there are incoming parameters and state changes. An illegal value and state should be reported at the first time, rather than waiting until the time is needed. Because when it is time to use, other related states may have been modified before, and few people in the program handle the rollback logic. After this error, the internal state may be confusing, and it is easy to cause the program to be unrecoverable on a hidden branch. Separate reliable operation and unreliable operation The reliability here is narrowly defined whether it will throw an exception or cause a state inconsistency. For example, writing a thread-safe Map can be considered reliable, but writing to a database can be considered unreliable. Developers must pay attention to its reliability when writing each line of code, divide it as much as possible in the code, and handle exceptions for failures, and provide clear logic for fault-tolerant, self-protection, automatic recovery or switching. The entry point ensures that the code that is subsequently added is not misplaced, and the original fault-tolerant processing is confusing. Safeguard against exceptions, but does not ignore exceptions The exception defense mentioned here refers to the maximum tolerance of the code on the non-crucial path, including the bug on the program. For example, the version number of program is retrieved by scanning the Manifest and jar package names. This logic is auxiliary, but the code is quite a bit. Although the initial test works well but you should add a try-catch block to cover the whole getVersion() function, if something goes wrong then print error message and return the basic version. Because getVersion() may encounter exception for specific unknown scene, or other developers mistakenly modify the logic (usually they won't remove try-catch). Otherwise if it throws an exception, the main process will be interrupted which we don't want to see. It should be controlled properly, do not abuse try-catch, and do not eat the exception silently. Reduce scope of variable and use final liberally If a class can be an Immutable Class, it is preferred to design it as an Immutable Class. The immutable class has natural concurrency advantages, reduce synchronization and replication, it can efficiently help analyze the scope of thread safety. Even if a mutable class, for references passed in from constructor then held internally, it is better to make this field final, so as not to be mistakenly modified. Don't assume that the field won't be reassigned if this field is private or this class is written by myself. One factor to consider is that this code may be modified by others. He may not aware your weak convention\uff0c and the Final is a invariant contract. Reduce misunderstanding when modifying, do not bury mine It is repeatedly mentioned that the code being modified by the others, and this is something developers should keep in mind. This other person includes the future of yourself, you always have to think about this code, someone may change it. I should give the modified person a hint, let him know my current design intent, instead of adding hidden rules in the program, or bury some easily overlooked mines, such as: use null to indicate that it is not available, the size is equal to 0 means black list, this is a mine. The next modifier, including yourself, will not remember to have such an agreement, may later change some of the other bugs, accidentally changed to here, directly detonated the fault. For this example, one principle is to never distinguish between null references and null values. Improve code testability The testability here mainly refers to the ease of Mock and the isolation of the test cases. As for the automation, repeatability, stability, disorder, completeness (full coverage), lightweight (fast execution) of the test, the general developer, plus the assist of tools such as JUnit can do it. Can also understand its benefits, just the matter of workload. Primary emphasis on unicity(only test the target class itself) and isolation(do not propagate failure). Nowadays there is too much emphasis on completeness, a lot of crossed and repeated test cases. It seems fine, but the more test code, the higher maintenance cost. A common problem is that modifying a line of code or adding an assertion causes more than 100 test cases to fail. It will cost a lot of time to fix these variance test cases. Over time, this test cases can't really reflect the current state of the code, and it will often be compromised to bypass. In the best case, modify a line of code, and only one line of test code does not pass. If the code is modified and the test case can still pass, that doesn't work, indicating that the scenario is not covered. In addition, Mockability is the basis of isolation, it hide the logic of indirect dependencies. One of the biggest killers of Mockability is the static method, which should be avoid as possible.","title":"The devil is in the details"},{"location":"dev/principals/code-detail/#the-devil-is-in-the-details","text":"http://javatar.iteye.com/blog/1056664 Recently, I have been worried about the quality of the Dubbo distributed service framework. If there are more maintenance personnel or changes, there will be a decline in quality. I am thinking, is there any need for everyone to abide by it, according to a habit when writing code, I have summarized it. The code process, especially the framework code, should always keep in mind the details. Maybe the following will be said, everyone will feel very simple, very basic, but always keep in mind. Considering these factors in every line of code requires a lot of patience. It is often said that the devil is in the details.","title":"The devil is in the details"},{"location":"dev/principals/code-detail/#prevent-null-pointer-dereference-and-index-out-of-bounds","text":"This is the exception I least like to see, especially in the core framework, in contrast I would like to see a parameter not legal exception with detail information. This is also a robust program developer who should be prevented in the subconscious by writing every line of code. Basically, you must be able to ensure that the code that is written once will not appear in the case of no test.","title":"Prevent null pointer dereference and index out of bounds"},{"location":"dev/principals/code-detail/#ensure-thread-safety-and-visibility","text":"For framework developers, a deep understanding of thread safety and visibility is the most basic requirement. Developers are required to ensure that they are correct in the subconscious when writing each line of code. Because of this kind of code, it will look normal when doing functional tests under small concurrency. However, under high concurrency, there will be inexplicable problems, and the scene is difficult to reproduce, and it is extremely difficult to check.","title":"Ensure thread safety and visibility"},{"location":"dev/principals/code-detail/#fail-fast-and-precondition","text":"Fail fast should also become a subconscious mind, assert at the entrance when there are incoming parameters and state changes. An illegal value and state should be reported at the first time, rather than waiting until the time is needed. Because when it is time to use, other related states may have been modified before, and few people in the program handle the rollback logic. After this error, the internal state may be confusing, and it is easy to cause the program to be unrecoverable on a hidden branch.","title":"Fail fast and precondition"},{"location":"dev/principals/code-detail/#separate-reliable-operation-and-unreliable-operation","text":"The reliability here is narrowly defined whether it will throw an exception or cause a state inconsistency. For example, writing a thread-safe Map can be considered reliable, but writing to a database can be considered unreliable. Developers must pay attention to its reliability when writing each line of code, divide it as much as possible in the code, and handle exceptions for failures, and provide clear logic for fault-tolerant, self-protection, automatic recovery or switching. The entry point ensures that the code that is subsequently added is not misplaced, and the original fault-tolerant processing is confusing.","title":"Separate reliable operation and unreliable operation"},{"location":"dev/principals/code-detail/#safeguard-against-exceptions-but-does-not-ignore-exceptions","text":"The exception defense mentioned here refers to the maximum tolerance of the code on the non-crucial path, including the bug on the program. For example, the version number of program is retrieved by scanning the Manifest and jar package names. This logic is auxiliary, but the code is quite a bit. Although the initial test works well but you should add a try-catch block to cover the whole getVersion() function, if something goes wrong then print error message and return the basic version. Because getVersion() may encounter exception for specific unknown scene, or other developers mistakenly modify the logic (usually they won't remove try-catch). Otherwise if it throws an exception, the main process will be interrupted which we don't want to see. It should be controlled properly, do not abuse try-catch, and do not eat the exception silently.","title":"Safeguard against exceptions, but does not ignore exceptions"},{"location":"dev/principals/code-detail/#reduce-scope-of-variable-and-use-final-liberally","text":"If a class can be an Immutable Class, it is preferred to design it as an Immutable Class. The immutable class has natural concurrency advantages, reduce synchronization and replication, it can efficiently help analyze the scope of thread safety. Even if a mutable class, for references passed in from constructor then held internally, it is better to make this field final, so as not to be mistakenly modified. Don't assume that the field won't be reassigned if this field is private or this class is written by myself. One factor to consider is that this code may be modified by others. He may not aware your weak convention\uff0c and the Final is a invariant contract.","title":"Reduce scope of variable and use final liberally"},{"location":"dev/principals/code-detail/#reduce-misunderstanding-when-modifying-do-not-bury-mine","text":"It is repeatedly mentioned that the code being modified by the others, and this is something developers should keep in mind. This other person includes the future of yourself, you always have to think about this code, someone may change it. I should give the modified person a hint, let him know my current design intent, instead of adding hidden rules in the program, or bury some easily overlooked mines, such as: use null to indicate that it is not available, the size is equal to 0 means black list, this is a mine. The next modifier, including yourself, will not remember to have such an agreement, may later change some of the other bugs, accidentally changed to here, directly detonated the fault. For this example, one principle is to never distinguish between null references and null values.","title":"Reduce misunderstanding when modifying, do not bury mine"},{"location":"dev/principals/code-detail/#improve-code-testability","text":"The testability here mainly refers to the ease of Mock and the isolation of the test cases. As for the automation, repeatability, stability, disorder, completeness (full coverage), lightweight (fast execution) of the test, the general developer, plus the assist of tools such as JUnit can do it. Can also understand its benefits, just the matter of workload. Primary emphasis on unicity(only test the target class itself) and isolation(do not propagate failure). Nowadays there is too much emphasis on completeness, a lot of crossed and repeated test cases. It seems fine, but the more test code, the higher maintenance cost. A common problem is that modifying a line of code or adding an assertion causes more than 100 test cases to fail. It will cost a lot of time to fix these variance test cases. Over time, this test cases can't really reflect the current state of the code, and it will often be compromised to bypass. In the best case, modify a line of code, and only one line of test code does not pass. If the code is modified and the test case can still pass, that doesn't work, indicating that the scenario is not covered. In addition, Mockability is the basis of isolation, it hide the logic of indirect dependencies. One of the biggest killers of Mockability is the static method, which should be avoid as possible.","title":"Improve code testability"},{"location":"dev/principals/configuration/","text":"The configuration design http://javatar.iteye.com/blog/949527 Dubbo design is now completely unobtrusive, namely the user only depends on the configuration of contract.After multiple versions of the development, in order to meet the demand of various scenarios, configuration is more and more.In order to maintain compatibility with only grow, lurking inside all sorts of styles, convention, rules.The new version will also be configured for a adjustment, remove the dubbo, properties, instead of all the spring configuration.Will think of some written in this memo. Classification of configuration First of all, the purpose is to have a variety of configuration, which can be roughly divided into: Environment configuration, such as: the number of connections, the timeout configuration, etc. Describe the configuration, such as: service interface description, service version, etc. Extension configuration, such as: protocol extension, strategy to expand, etc. Configuration format Usually environment configuration, using the configuration properties will be more convenient, because is some simple discrete values, with the key - value configuration can reduce the learning cost configuration. Describe the configuration, information more often, and even have a hierarchy, using XML configuration would be more convenient, because the tree structure configuration expression was stronger.If very complex, and can also custom DSL as configuration.Sometimes such configuration can also use the Annotation instead of, because the configuration and related business logic, in the code is also reasonable. Another extension configuration, which may be different.If only policy interface implementation class to replace, can consider the properties of the structure.If there is a complex life cycle management, may need to configure such as XML.Sometimes extended by registering interface provided. Configuration is loaded For environment configuration, in the Java world, comparing to conventional approach, was agreed in a project under the classpath for the name of the configuration properties, such as: log4j. Properties, velocity. The properties and so on.Product during initialization, automatically from the classpath under loading the configuration.Our platform of many programs use a similar strategy, such as: dubbo. Properties, comsat. XML, etc.This has its advantages, is based on agreement, simplifies the user to configure the loading process of intervention.But also has its disadvantages, when the classpath is the same configuration, may be loaded by mistake, and when this isolation, may can't find the configuration, and, when the user wants to configure into the unified directory, not very convenient. Dubbo new version removes dubbo.properties , because the contract often conflicts configuration. And to describe the configuration, because want to participate in the business logic, usually embedded into the application of life cycle management.There are more and more using spring projects, directly using the spring configuration is common, and spring permits custom schema, configuration simplified is very convenient.Also has its disadvantages, of course, is strongly dependent on the spring, can ask programming interface to do the matching scheme In Dubbo configuration is described, but also environment configuration.Part with spring schame configuration is loaded, in part, from the classpath scanning properties configuration is loaded.Users feel very inconvenient, so in the new version of the merged, unified into spring schame configuration load, also increases the flexibility of configuration. Extension configuration, usually to the configuration of aggregate demand is higher.Because the product need to find the third party implementation, add it to the product inside.Agreed in the Java world, usually in a specified file each jar package down load, such as: the eclipse plugin. The XML, struts 2 struts - plugin. XML, and so on, this kind of configuration can consider Java standard service discovery mechanisms, namely in the jar meta-inf/services placed under the interface class name file, content is an implementation class name of the class in a row, like encryption algorithm in the JDK extension, the script engine extension, new JDBC driver, etc., are all in this way.see\uff1a ServiceProvider Provider \u3002 Dubbo old version under each jar package through agreement, place called Dubbo - context. The spring configuration XML extensions and integration, the new version to use the JDK's own meta-inf/services, spring from too much dependence. Programmable configuration Configuration of programmability is very necessary, no matter in what way you load the configuration file, should provide a programming way of configuration, allows the user to not using a configuration file, complete the configuration process with code directly.As a product, especially the component products, usually require collaboration use and other products, when a user integration of your product, may need adapter configuration mode. Dubbo new version offers one-on-one configuration class with XML configuration, such as: ServiceConfig corresponding Dubbo: service / , and one-to-one attributes, this configuration file configuration and programming the consistency of the understanding, reduce the learning cost. Configure the default Configuration of the default, usually set the reasonable value of a regular environment, thus reducing the user's configuration.Is generally recommended that in online environment for reference, the development environment can adapt by changing the configuration.The default Settings, had better be in the outermost configuration do processing load.The underlying program if found configuration is not correct, you should direct error, fault tolerance in the outermost layer.If, when the underlying program to use, found unreasonable configuration values, just fill a default value, it is easy to cover up the surface, and trigger a deeper problem.And configuration of the middle layer, probably don't know the underlying USES a default value, some may be failure in the middle of the testing conditions.Dubbo first appeared in this problem, the middle layer with \"address\" as the cache Key, and the bottom, to \"address\" a default port number, lead to don't add port number \"address\" and add the default port \"address\" did not use the same cache. Configuration consistency Configuration is always implied some style or hidden rules, should as far as possible to keep its consistency.For example: a lot of functions have switch, and then have a configuration value\uff1a Whether to use the registry, the registry address. Whether to allow a retry, retries. You may agree: Each is to configure a Boolean type of switch, to configure a value. On behalf of the closed with an invalid values, N/A address 0 retries, etc. No matter which way, all the configuration items, should keep the same style, Dubbo selected is the second.Also, similar to that of timeout, retry time, timer interval.If a unit is second, another unit is milliseconds (C3P0 configuration item is) so, staff will be crazy. Configuration coverage Provide configuration, want to consider developers, testers, piping, the system administrator.Testers can't modify the code, and test environment is likely to be more complex, need to have some set aside for testers \"back door\", can be modified in the peripheral configuration items.Like spring is accomplished configuration, support SYSTEM_PROPERTIES_MODE_OVERRIDE , can through the JVM -d parameters, or like hosts agreed a cover configuration files, on the outside of the program, modify some configuration, easy to test. Dubbo support through the JVM parameter - Dcom. XXX. XxxService = Dubbo: / / 10.1.1.1:1234 directly make the remote service call bypass registry, point to point test.There is a kind of situation, developers to increase the configuration, can according to the deployment of online configuration, such as: dubbo: registry address = \"${dubbo. Registry. Address}\" / because only one online registry, this configuration is no problem, and the testing environment may have two registry, testers can't to modify configuration, changed to: dubbo:registry address=\"${dubbo.registry.address1}\" / \uff0c dubbo:registry address=\"${dubbo.registry.address2}\" / \uff0cSo this place, Dubbo support in the ${Dubbo. Registry. Address} value, through vertical dividing multiple registry addresses, used to represent a registry address. Configuration inheritance Configuration is also \"duplicate code\", there is also a \"generalization and elaboration\" problem.Such as: Dubbo timeout Settings, each service, and each method, should be can set the timeout.But a lot of service don't care about overtime, if required each method configuration, it is not realistic.So Dubbo adopted method inherit service timeout, overtime service timeout to inherit the default timeout, no configuration, opens up search. Dubbo, moreover, the old version all the timeout, retries, load balancing strategies are only in the service consumer configuration.But in the process of actual use, found that the service provider knows better than consumer, but the configuration items are used in consumer.The new version, joined in the provider can match these parameters, through the registry to the consumer,As a reference, if there is no configuration, consumer to provide configuration shall prevail, the equivalent of consumption ji-cheng fang the provider's advice configuration values.And at the time of the relay configuration registry, can also be on the way to modify configuration, so that achieve the purpose of governance, the equivalent of inheritance relationship\uff1aService consumers -- Registry -- Service provider Dubbo, moreover, the old version all the timeout, retries, load balancing strategies are only in the service consumer configuration.But in the process of actual use, found that the service provider knows better than consumer, but the configuration items are used in consumer.The new version, joined in the provider can match these parameters, through the registry to the consumer. Configuration backward compatibility Forwards compatibility is very good, as long as you guarantee configuration only grow, basically can guarantee forwards compatibility.But backward compatibility, but also should pay attention to, to prepare for subsequent to join the new configuration items.If a special configuration in configuration, you should make an appointment a compatibility for the \"special\" case rules, because the special case, probably will happen later.For example, have a configuration file is save \"service = address mapping\", one of the special line, is saved \"registry = address\".Now application load time to define \"registry\" the Key is special, do special processing, the other is \"service\".New version found, however, to add a \"monitoring center\" = address, at this point, the old version of the program will handle \"monitoring center\" as a \"service\", because the old code can't be change, compatibility is will be very troublesome.If previously agreed upon in the \"special\" logo + XXX for special treatment, follow-up will be more convenient. Backward compatibility, can learn a lot from HTML5, refer to\uff1a HTML5 design principle","title":"The configuration design"},{"location":"dev/principals/configuration/#the-configuration-design","text":"http://javatar.iteye.com/blog/949527 Dubbo design is now completely unobtrusive, namely the user only depends on the configuration of contract.After multiple versions of the development, in order to meet the demand of various scenarios, configuration is more and more.In order to maintain compatibility with only grow, lurking inside all sorts of styles, convention, rules.The new version will also be configured for a adjustment, remove the dubbo, properties, instead of all the spring configuration.Will think of some written in this memo.","title":"The configuration design"},{"location":"dev/principals/configuration/#classification-of-configuration","text":"First of all, the purpose is to have a variety of configuration, which can be roughly divided into: Environment configuration, such as: the number of connections, the timeout configuration, etc. Describe the configuration, such as: service interface description, service version, etc. Extension configuration, such as: protocol extension, strategy to expand, etc.","title":"Classification of configuration"},{"location":"dev/principals/configuration/#configuration-format","text":"Usually environment configuration, using the configuration properties will be more convenient, because is some simple discrete values, with the key - value configuration can reduce the learning cost configuration. Describe the configuration, information more often, and even have a hierarchy, using XML configuration would be more convenient, because the tree structure configuration expression was stronger.If very complex, and can also custom DSL as configuration.Sometimes such configuration can also use the Annotation instead of, because the configuration and related business logic, in the code is also reasonable. Another extension configuration, which may be different.If only policy interface implementation class to replace, can consider the properties of the structure.If there is a complex life cycle management, may need to configure such as XML.Sometimes extended by registering interface provided.","title":"Configuration format"},{"location":"dev/principals/configuration/#configuration-is-loaded","text":"For environment configuration, in the Java world, comparing to conventional approach, was agreed in a project under the classpath for the name of the configuration properties, such as: log4j. Properties, velocity. The properties and so on.Product during initialization, automatically from the classpath under loading the configuration.Our platform of many programs use a similar strategy, such as: dubbo. Properties, comsat. XML, etc.This has its advantages, is based on agreement, simplifies the user to configure the loading process of intervention.But also has its disadvantages, when the classpath is the same configuration, may be loaded by mistake, and when this isolation, may can't find the configuration, and, when the user wants to configure into the unified directory, not very convenient. Dubbo new version removes dubbo.properties , because the contract often conflicts configuration. And to describe the configuration, because want to participate in the business logic, usually embedded into the application of life cycle management.There are more and more using spring projects, directly using the spring configuration is common, and spring permits custom schema, configuration simplified is very convenient.Also has its disadvantages, of course, is strongly dependent on the spring, can ask programming interface to do the matching scheme In Dubbo configuration is described, but also environment configuration.Part with spring schame configuration is loaded, in part, from the classpath scanning properties configuration is loaded.Users feel very inconvenient, so in the new version of the merged, unified into spring schame configuration load, also increases the flexibility of configuration. Extension configuration, usually to the configuration of aggregate demand is higher.Because the product need to find the third party implementation, add it to the product inside.Agreed in the Java world, usually in a specified file each jar package down load, such as: the eclipse plugin. The XML, struts 2 struts - plugin. XML, and so on, this kind of configuration can consider Java standard service discovery mechanisms, namely in the jar meta-inf/services placed under the interface class name file, content is an implementation class name of the class in a row, like encryption algorithm in the JDK extension, the script engine extension, new JDBC driver, etc., are all in this way.see\uff1a ServiceProvider Provider \u3002 Dubbo old version under each jar package through agreement, place called Dubbo - context. The spring configuration XML extensions and integration, the new version to use the JDK's own meta-inf/services, spring from too much dependence.","title":"Configuration is loaded"},{"location":"dev/principals/configuration/#programmable-configuration","text":"Configuration of programmability is very necessary, no matter in what way you load the configuration file, should provide a programming way of configuration, allows the user to not using a configuration file, complete the configuration process with code directly.As a product, especially the component products, usually require collaboration use and other products, when a user integration of your product, may need adapter configuration mode. Dubbo new version offers one-on-one configuration class with XML configuration, such as: ServiceConfig corresponding Dubbo: service / , and one-to-one attributes, this configuration file configuration and programming the consistency of the understanding, reduce the learning cost.","title":"Programmable configuration"},{"location":"dev/principals/configuration/#configure-the-default","text":"Configuration of the default, usually set the reasonable value of a regular environment, thus reducing the user's configuration.Is generally recommended that in online environment for reference, the development environment can adapt by changing the configuration.The default Settings, had better be in the outermost configuration do processing load.The underlying program if found configuration is not correct, you should direct error, fault tolerance in the outermost layer.If, when the underlying program to use, found unreasonable configuration values, just fill a default value, it is easy to cover up the surface, and trigger a deeper problem.And configuration of the middle layer, probably don't know the underlying USES a default value, some may be failure in the middle of the testing conditions.Dubbo first appeared in this problem, the middle layer with \"address\" as the cache Key, and the bottom, to \"address\" a default port number, lead to don't add port number \"address\" and add the default port \"address\" did not use the same cache.","title":"Configure the default"},{"location":"dev/principals/configuration/#configuration-consistency","text":"Configuration is always implied some style or hidden rules, should as far as possible to keep its consistency.For example: a lot of functions have switch, and then have a configuration value\uff1a Whether to use the registry, the registry address. Whether to allow a retry, retries. You may agree: Each is to configure a Boolean type of switch, to configure a value. On behalf of the closed with an invalid values, N/A address 0 retries, etc. No matter which way, all the configuration items, should keep the same style, Dubbo selected is the second.Also, similar to that of timeout, retry time, timer interval.If a unit is second, another unit is milliseconds (C3P0 configuration item is) so, staff will be crazy.","title":"Configuration consistency"},{"location":"dev/principals/configuration/#configuration-coverage","text":"Provide configuration, want to consider developers, testers, piping, the system administrator.Testers can't modify the code, and test environment is likely to be more complex, need to have some set aside for testers \"back door\", can be modified in the peripheral configuration items.Like spring is accomplished configuration, support SYSTEM_PROPERTIES_MODE_OVERRIDE , can through the JVM -d parameters, or like hosts agreed a cover configuration files, on the outside of the program, modify some configuration, easy to test. Dubbo support through the JVM parameter - Dcom. XXX. XxxService = Dubbo: / / 10.1.1.1:1234 directly make the remote service call bypass registry, point to point test.There is a kind of situation, developers to increase the configuration, can according to the deployment of online configuration, such as: dubbo: registry address = \"${dubbo. Registry. Address}\" / because only one online registry, this configuration is no problem, and the testing environment may have two registry, testers can't to modify configuration, changed to: dubbo:registry address=\"${dubbo.registry.address1}\" / \uff0c dubbo:registry address=\"${dubbo.registry.address2}\" / \uff0cSo this place, Dubbo support in the ${Dubbo. Registry. Address} value, through vertical dividing multiple registry addresses, used to represent a registry address.","title":"Configuration coverage"},{"location":"dev/principals/configuration/#configuration-inheritance","text":"Configuration is also \"duplicate code\", there is also a \"generalization and elaboration\" problem.Such as: Dubbo timeout Settings, each service, and each method, should be can set the timeout.But a lot of service don't care about overtime, if required each method configuration, it is not realistic.So Dubbo adopted method inherit service timeout, overtime service timeout to inherit the default timeout, no configuration, opens up search. Dubbo, moreover, the old version all the timeout, retries, load balancing strategies are only in the service consumer configuration.But in the process of actual use, found that the service provider knows better than consumer, but the configuration items are used in consumer.The new version, joined in the provider can match these parameters, through the registry to the consumer,As a reference, if there is no configuration, consumer to provide configuration shall prevail, the equivalent of consumption ji-cheng fang the provider's advice configuration values.And at the time of the relay configuration registry, can also be on the way to modify configuration, so that achieve the purpose of governance, the equivalent of inheritance relationship\uff1aService consumers -- Registry -- Service provider Dubbo, moreover, the old version all the timeout, retries, load balancing strategies are only in the service consumer configuration.But in the process of actual use, found that the service provider knows better than consumer, but the configuration items are used in consumer.The new version, joined in the provider can match these parameters, through the registry to the consumer.","title":"Configuration inheritance"},{"location":"dev/principals/configuration/#configuration-backward-compatibility","text":"Forwards compatibility is very good, as long as you guarantee configuration only grow, basically can guarantee forwards compatibility.But backward compatibility, but also should pay attention to, to prepare for subsequent to join the new configuration items.If a special configuration in configuration, you should make an appointment a compatibility for the \"special\" case rules, because the special case, probably will happen later.For example, have a configuration file is save \"service = address mapping\", one of the special line, is saved \"registry = address\".Now application load time to define \"registry\" the Key is special, do special processing, the other is \"service\".New version found, however, to add a \"monitoring center\" = address, at this point, the old version of the program will handle \"monitoring center\" as a \"service\", because the old code can't be change, compatibility is will be very troublesome.If previously agreed upon in the \"special\" logo + XXX for special treatment, follow-up will be more convenient. Backward compatibility, can learn a lot from HTML5, refer to\uff1a HTML5 design principle","title":"Configuration backward compatibility"},{"location":"dev/principals/dummy/","text":"\"Fool-proof\" design http://javatar.iteye.com/blog/804187 Recently I was feeling stupid because I solved too many stupid problems. The service framework is becoming more widely used. Every day, I have to help the endpoint user to resolve problems. Gradually, it is found that most of the problems are configuration errors, or duplicated files or classes, or network failure. So I prepare to add some \"fool-proof\" design to the further version. It may be very simple, but it is still a little help for troubleshooting speed. I hope that I can throw a brick to attract jade, and everyone can help to come up with more preventive measures to share. Check for duplicated jars The most annoying problem is that, if we have several jars with different version number at the same time, there will be a problem. Imagine that, a new version of the Class A may invoke a old version of the Class B, it's related to the JVM loading order. The problem may encounter occasionally and hard to resolve. So the first, let's try to avoid it. For each jar package, pick a class that will be loaded, check it for duplication for example: static { Duplicate.checkDuplicate(Xxx.class); } Utility class for check duplication\uff1a public final class Duplicate { private Duplicate() {} public static void checkDuplicate(Class cls) { checkDuplicate(cls.getName().replace('.', '/') + .class ); } public static void checkDuplicate(String path) { try { // search from ClassPath Enumeration urls = Thread.currentThread().getContextClassLoader().getResources(path); Set files = new HashSet(); while (urls.hasMoreElements()) { URL url = urls.nextElement(); if (url != null) { String file = url.getFile(); if (file != null amp; amp; file.length() gt; 0) { files.add(file); } } } // if there are more than one indicates duplication if (files.size() gt; 1) { logger.error( Duplicate class + path + in + files.size() + jar + files); } } catch (Throwable e) { // safe guard logger.error(e.getMessage(), e); } } } Check for duplicate configuration files It is also a frequently encountered problem that the configuration file is loaded incorrectly. Users often complain that they have the right configuration but program says something is wrong. After some troubleshooting, found that the configuration file is not even loaded. Many products put a default configuration file under classpath, if there are several, usually the first one loaded by JVM is effective. In order not to be bothered by such problem, just like checking duplicate jars, add this: Duplicate.checkDuplicate( xxx.properties ); Check for optional configuration The required configuration is estimated to be checked by everyone, because without it the program may not even start. However, for some optional parameters, some checks should also be made. For example, the service framework allows the service consumers and service providers to be associated with the registry, and allows direct configuring the service provider address to point-to-point direct connect. At this time, the registry address is optional, but if there is no point-to-point direct connect configured, the registry center address must be matched, and this time you have to check accordingly. Provide error message with a solution if possible It's hard to troubleshooting problem with a simple error message which has no detail information. For example, the last time I encountered a \"Failed to get session\" exception, just the few words. I'm wondering which session is wrong? What is the reason Failed? It makes me crazy, the problem happens in an production environment and it's hard to reproduce. The exception should have some basic context information, such as author info, operation system, failed reason. The best exception information should be given a solution, such as the above: \"From 10.20.16.3 to 10.20.130.20:20880 The network is unreachable. Please use telnet 10.20.130.20 20880 to test the network at 10.20.16.3. If it is called across data center, it may be blocked by the firewall. Please contact SA to grant access permission.\" etc. The above can even judge whether it is cross data center based on IP address. Another example is the spring-web context loading, If spring is not started when getBean, spring will report an error. The error message says: \"Please add: listener ... init-param ... \", just copy and paste. We should learn from it. You can deliberately make a common mistake and see if you can solve the problem yourself by the error message. Or we can write some solution of common problems in error message. And also the environment information Every time an application error occurs, the developer or QA will send the error message and ask the reason. At this time, I will ask some question again, which version is used? Is it a production environment or a development environment? Which registry center? Which project is it? Which machine? And which service? The problem is, some developers or QA can't tell the difference, it waste me a lot of time. So, it is best to log some environment information, we can make a wrapper. Decorate the Logger interface such as: public void error(String msg, Throwable e) { delegate.error(msg + on server + InetAddress.getLocalHost() + using version + Version.getVersion(), e); } Utility class for retrieve version\uff1a public final class Version { private Version() {} private static final Logger logger = LoggerFactory.getLogger(Version.class); private static final Pattern VERSION_PATTERN = Pattern.compile( ([0-9][0-9\\\\.\\\\-]*)\\\\.jar ); private static final String VERSION = getVersion(Version.class, 2.0.0 ); public static String getVersion(){ return VERSION; } public static String getVersion(Class cls, String defaultVersion) { try { // search version number from MANIFEST.MF String version = cls.getPackage().getImplementationVersion(); if (version == null || version.length() == 0) { version = cls.getPackage().getSpecificationVersion(); } if (version == null || version.length() == 0) { // if not found, extract from jar name String file = cls.getProtectionDomain().getCodeSource().getLocation().getFile(); if (file != null amp; amp; file.length() gt; 0 amp; amp; file.endsWith( .jar )) { Matcher matcher = VERSION_PATTERN.matcher(file); while (matcher.find() amp; amp; matcher.groupCount() gt; 0) { version = matcher.group(1); } } } // return version, return default if null return version == null || version.length() == 0 ? defaultVersion : version; } catch (Throwable e) { // ignore exception, return default version logger.error(e.getMessage(), e); return defaultVersion; } } } Dump before kill Every time there is a problem with the production environment, everyone panics. Usually the most direct way is to rollback and restart, to reduce the downtime. So that the scene is destroyed, and it's hard to check the problem afterwards. Some problem is hard to reproduce in development environment and may happen under hard pressure. It is unlikely let the developer or Appops manually backup all the data before. Therefore, it is best to call dump before the kill script to backup automatically and avoid mistake. Dump script for example: JAVA_HOME=/usr/java OUTPUT_HOME=~/output DEPLOY_HOME=`dirname $0` HOST_NAME=`hostname` DUMP_PIDS=`ps --no-heading -C java -f --width 1000 | grep $DEPLOY_HOME |awk '{print $2}'` if [ -z $DUMP_PIDS ]; then echo The server $HOST_NAME is not started! exit 1; fi DUMP_ROOT=$OUTPUT_HOME/dump if [ ! -d $DUMP_ROOT ]; then mkdir $DUMP_ROOT fi DUMP_DATE=`date +%Y%m%d%H%M%S` DUMP_DIR=$DUMP_ROOT/dump-$DUMP_DATE if [ ! -d $DUMP_DIR ]; then mkdir $DUMP_DIR fi echo -e Dumping the server $HOST_NAME ...\\c for PID in $DUMP_PIDS ; do $JAVA_HOME/bin/jstack $PID $DUMP_DIR/jstack-$PID.dump 2 1 echo -e .\\c $JAVA_HOME/bin/jinfo $PID $DUMP_DIR/jinfo-$PID.dump 2 1 echo -e .\\c $JAVA_HOME/bin/jstat -gcutil $PID $DUMP_DIR/jstat-gcutil-$PID.dump 2 1 echo -e .\\c $JAVA_HOME/bin/jstat -gccapacity $PID $DUMP_DIR/jstat-gccapacity-$PID.dump 2 1 echo -e .\\c $JAVA_HOME/bin/jmap $PID $DUMP_DIR/jmap-$PID.dump 2 1 echo -e .\\c $JAVA_HOME/bin/jmap -heap $PID $DUMP_DIR/jmap-heap-$PID.dump 2 1 echo -e .\\c $JAVA_HOME/bin/jmap -histo $PID $DUMP_DIR/jmap-histo-$PID.dump 2 1 echo -e .\\c if [ -r /usr/sbin/lsof ]; then /usr/sbin/lsof -p $PID $DUMP_DIR/lsof-$PID.dump echo -e .\\c fi done if [ -r /usr/bin/sar ]; then /usr/bin/sar $DUMP_DIR/sar.dump echo -e .\\c fi if [ -r /usr/bin/uptime ]; then /usr/bin/uptime $DUMP_DIR/uptime.dump echo -e .\\c fi if [ -r /usr/bin/free ]; then /usr/bin/free -t $DUMP_DIR/free.dump echo -e .\\c fi if [ -r /usr/bin/vmstat ]; then /usr/bin/vmstat $DUMP_DIR/vmstat.dump echo -e .\\c fi if [ -r /usr/bin/mpstat ]; then /usr/bin/mpstat $DUMP_DIR/mpstat.dump echo -e .\\c fi if [ -r /usr/bin/iostat ]; then /usr/bin/iostat $DUMP_DIR/iostat.dump echo -e .\\c fi if [ -r /bin/netstat ]; then /bin/netstat $DUMP_DIR/netstat.dump echo -e .\\c fi echo OK!","title":"\"Fool-proof\" design"},{"location":"dev/principals/dummy/#fool-proof-design","text":"http://javatar.iteye.com/blog/804187 Recently I was feeling stupid because I solved too many stupid problems. The service framework is becoming more widely used. Every day, I have to help the endpoint user to resolve problems. Gradually, it is found that most of the problems are configuration errors, or duplicated files or classes, or network failure. So I prepare to add some \"fool-proof\" design to the further version. It may be very simple, but it is still a little help for troubleshooting speed. I hope that I can throw a brick to attract jade, and everyone can help to come up with more preventive measures to share.","title":"\"Fool-proof\" design"},{"location":"dev/principals/dummy/#check-for-duplicated-jars","text":"The most annoying problem is that, if we have several jars with different version number at the same time, there will be a problem. Imagine that, a new version of the Class A may invoke a old version of the Class B, it's related to the JVM loading order. The problem may encounter occasionally and hard to resolve. So the first, let's try to avoid it. For each jar package, pick a class that will be loaded, check it for duplication for example: static { Duplicate.checkDuplicate(Xxx.class); } Utility class for check duplication\uff1a public final class Duplicate { private Duplicate() {} public static void checkDuplicate(Class cls) { checkDuplicate(cls.getName().replace('.', '/') + .class ); } public static void checkDuplicate(String path) { try { // search from ClassPath Enumeration urls = Thread.currentThread().getContextClassLoader().getResources(path); Set files = new HashSet(); while (urls.hasMoreElements()) { URL url = urls.nextElement(); if (url != null) { String file = url.getFile(); if (file != null amp; amp; file.length() gt; 0) { files.add(file); } } } // if there are more than one indicates duplication if (files.size() gt; 1) { logger.error( Duplicate class + path + in + files.size() + jar + files); } } catch (Throwable e) { // safe guard logger.error(e.getMessage(), e); } } }","title":"Check for duplicated jars"},{"location":"dev/principals/dummy/#check-for-duplicate-configuration-files","text":"It is also a frequently encountered problem that the configuration file is loaded incorrectly. Users often complain that they have the right configuration but program says something is wrong. After some troubleshooting, found that the configuration file is not even loaded. Many products put a default configuration file under classpath, if there are several, usually the first one loaded by JVM is effective. In order not to be bothered by such problem, just like checking duplicate jars, add this: Duplicate.checkDuplicate( xxx.properties );","title":"Check for duplicate configuration files"},{"location":"dev/principals/dummy/#check-for-optional-configuration","text":"The required configuration is estimated to be checked by everyone, because without it the program may not even start. However, for some optional parameters, some checks should also be made. For example, the service framework allows the service consumers and service providers to be associated with the registry, and allows direct configuring the service provider address to point-to-point direct connect. At this time, the registry address is optional, but if there is no point-to-point direct connect configured, the registry center address must be matched, and this time you have to check accordingly.","title":"Check for optional configuration"},{"location":"dev/principals/dummy/#provide-error-message-with-a-solution-if-possible","text":"It's hard to troubleshooting problem with a simple error message which has no detail information. For example, the last time I encountered a \"Failed to get session\" exception, just the few words. I'm wondering which session is wrong? What is the reason Failed? It makes me crazy, the problem happens in an production environment and it's hard to reproduce. The exception should have some basic context information, such as author info, operation system, failed reason. The best exception information should be given a solution, such as the above: \"From 10.20.16.3 to 10.20.130.20:20880 The network is unreachable. Please use telnet 10.20.130.20 20880 to test the network at 10.20.16.3. If it is called across data center, it may be blocked by the firewall. Please contact SA to grant access permission.\" etc. The above can even judge whether it is cross data center based on IP address. Another example is the spring-web context loading, If spring is not started when getBean, spring will report an error. The error message says: \"Please add: listener ... init-param ... \", just copy and paste. We should learn from it. You can deliberately make a common mistake and see if you can solve the problem yourself by the error message. Or we can write some solution of common problems in error message.","title":"Provide error message with a solution if possible"},{"location":"dev/principals/dummy/#and-also-the-environment-information","text":"Every time an application error occurs, the developer or QA will send the error message and ask the reason. At this time, I will ask some question again, which version is used? Is it a production environment or a development environment? Which registry center? Which project is it? Which machine? And which service? The problem is, some developers or QA can't tell the difference, it waste me a lot of time. So, it is best to log some environment information, we can make a wrapper. Decorate the Logger interface such as: public void error(String msg, Throwable e) { delegate.error(msg + on server + InetAddress.getLocalHost() + using version + Version.getVersion(), e); } Utility class for retrieve version\uff1a public final class Version { private Version() {} private static final Logger logger = LoggerFactory.getLogger(Version.class); private static final Pattern VERSION_PATTERN = Pattern.compile( ([0-9][0-9\\\\.\\\\-]*)\\\\.jar ); private static final String VERSION = getVersion(Version.class, 2.0.0 ); public static String getVersion(){ return VERSION; } public static String getVersion(Class cls, String defaultVersion) { try { // search version number from MANIFEST.MF String version = cls.getPackage().getImplementationVersion(); if (version == null || version.length() == 0) { version = cls.getPackage().getSpecificationVersion(); } if (version == null || version.length() == 0) { // if not found, extract from jar name String file = cls.getProtectionDomain().getCodeSource().getLocation().getFile(); if (file != null amp; amp; file.length() gt; 0 amp; amp; file.endsWith( .jar )) { Matcher matcher = VERSION_PATTERN.matcher(file); while (matcher.find() amp; amp; matcher.groupCount() gt; 0) { version = matcher.group(1); } } } // return version, return default if null return version == null || version.length() == 0 ? defaultVersion : version; } catch (Throwable e) { // ignore exception, return default version logger.error(e.getMessage(), e); return defaultVersion; } } }","title":"And also the environment information"},{"location":"dev/principals/dummy/#dump-before-kill","text":"Every time there is a problem with the production environment, everyone panics. Usually the most direct way is to rollback and restart, to reduce the downtime. So that the scene is destroyed, and it's hard to check the problem afterwards. Some problem is hard to reproduce in development environment and may happen under hard pressure. It is unlikely let the developer or Appops manually backup all the data before. Therefore, it is best to call dump before the kill script to backup automatically and avoid mistake. Dump script for example: JAVA_HOME=/usr/java OUTPUT_HOME=~/output DEPLOY_HOME=`dirname $0` HOST_NAME=`hostname` DUMP_PIDS=`ps --no-heading -C java -f --width 1000 | grep $DEPLOY_HOME |awk '{print $2}'` if [ -z $DUMP_PIDS ]; then echo The server $HOST_NAME is not started! exit 1; fi DUMP_ROOT=$OUTPUT_HOME/dump if [ ! -d $DUMP_ROOT ]; then mkdir $DUMP_ROOT fi DUMP_DATE=`date +%Y%m%d%H%M%S` DUMP_DIR=$DUMP_ROOT/dump-$DUMP_DATE if [ ! -d $DUMP_DIR ]; then mkdir $DUMP_DIR fi echo -e Dumping the server $HOST_NAME ...\\c for PID in $DUMP_PIDS ; do $JAVA_HOME/bin/jstack $PID $DUMP_DIR/jstack-$PID.dump 2 1 echo -e .\\c $JAVA_HOME/bin/jinfo $PID $DUMP_DIR/jinfo-$PID.dump 2 1 echo -e .\\c $JAVA_HOME/bin/jstat -gcutil $PID $DUMP_DIR/jstat-gcutil-$PID.dump 2 1 echo -e .\\c $JAVA_HOME/bin/jstat -gccapacity $PID $DUMP_DIR/jstat-gccapacity-$PID.dump 2 1 echo -e .\\c $JAVA_HOME/bin/jmap $PID $DUMP_DIR/jmap-$PID.dump 2 1 echo -e .\\c $JAVA_HOME/bin/jmap -heap $PID $DUMP_DIR/jmap-heap-$PID.dump 2 1 echo -e .\\c $JAVA_HOME/bin/jmap -histo $PID $DUMP_DIR/jmap-histo-$PID.dump 2 1 echo -e .\\c if [ -r /usr/sbin/lsof ]; then /usr/sbin/lsof -p $PID $DUMP_DIR/lsof-$PID.dump echo -e .\\c fi done if [ -r /usr/bin/sar ]; then /usr/bin/sar $DUMP_DIR/sar.dump echo -e .\\c fi if [ -r /usr/bin/uptime ]; then /usr/bin/uptime $DUMP_DIR/uptime.dump echo -e .\\c fi if [ -r /usr/bin/free ]; then /usr/bin/free -t $DUMP_DIR/free.dump echo -e .\\c fi if [ -r /usr/bin/vmstat ]; then /usr/bin/vmstat $DUMP_DIR/vmstat.dump echo -e .\\c fi if [ -r /usr/bin/mpstat ]; then /usr/bin/mpstat $DUMP_DIR/mpstat.dump echo -e .\\c fi if [ -r /usr/bin/iostat ]; then /usr/bin/iostat $DUMP_DIR/iostat.dump echo -e .\\c fi if [ -r /bin/netstat ]; then /bin/netstat $DUMP_DIR/netstat.dump echo -e .\\c fi echo OK!","title":"Dump before kill"},{"location":"dev/principals/expansibility/","text":"Talk about expansion of extension and incremental extension http://javatar.iteye.com/blog/690845 There are more and more products in our platform, the function of the product also more and more.Platform products in order to meet the requirement of each BU and department as well as product line, will surely will be a lot of irrelevant function together, the customer can use selective.In order to compatible with more demand for each product, each framework, are constantly expanding, and we often choose some extension of the extension, namely to old and new function expanded into a general implementation.I want to discuss is, in some cases also can consider to the expansion of the incremental way, also is to retain the original function of simplicity, new feature implementation independence.I have been doing the development of distributed service framework, and then take such problem in our project. Such as: remote invocation framework, definitely not serialize function, function is very simple, is to transfer as object, the object into a stream.But because of some places may be using osgi, such serialization, IO in this may be isolated and the business side of this.Need to stream into byte [] array, and then passed on to the business side of this serialization.In order to adapt itself to the requirements of the osgi, expanded the original non osgi with osgi scenes, so, no matter whether the osgi environment, all will move into a byte [] array, first copy again.However, most of the scenes with osgi, paid the price, but for the osgi.And if adopts incremental extension method, the osgi code intact, plus an osgi implementation, when wanting to use osgi, rely on osgi implementation can directly. Such as: remote invocation framework, definitely not serialize function, function is very simple, is to transfer as object, the object into a stream.But because of some places may be using osgi, such serialization, IO in this may be isolated and the business side of this.Need to stream into byte [] array, and then passed on to the business side of this serialization.In order to adapt itself to the requirements of the osgi, expanded the original non osgi with osgi scenes, so, no matter whether the osgi environment, all will move into a byte [] array, first copy again.However, most of the scenes with osgi, paid the price, but for the osgi.And if adopts incremental extension method, the osgi code intact, plus an osgi implementation, when wanting to use osgi, rely on osgi implementation can directly. Such as: no status messages before, is very simple, just pass a serialized object.Later a synchronous message send demand, need a Request/Response matching, using extended extension, naturally thought, stateless news is actually a Request without Response, add a Boolean state so in the Request, said do you want to return the Response.If the message is sent to a Session needs again, then add a Session interaction, and then found that the original synchronous message sent is a special case of Session message, all scenarios Session, don't need the Session can be ignored. If the incremental extension, stateless messages intact, synchronous message is sent, on the basis of stateless news add a Request/Response processing, message sending session, plus a SessionRequest/SessionResponse processing.","title":"Talk about expansion of extension and incremental extension"},{"location":"dev/principals/expansibility/#talk-about-expansion-of-extension-and-incremental-extension","text":"http://javatar.iteye.com/blog/690845 There are more and more products in our platform, the function of the product also more and more.Platform products in order to meet the requirement of each BU and department as well as product line, will surely will be a lot of irrelevant function together, the customer can use selective.In order to compatible with more demand for each product, each framework, are constantly expanding, and we often choose some extension of the extension, namely to old and new function expanded into a general implementation.I want to discuss is, in some cases also can consider to the expansion of the incremental way, also is to retain the original function of simplicity, new feature implementation independence.I have been doing the development of distributed service framework, and then take such problem in our project. Such as: remote invocation framework, definitely not serialize function, function is very simple, is to transfer as object, the object into a stream.But because of some places may be using osgi, such serialization, IO in this may be isolated and the business side of this.Need to stream into byte [] array, and then passed on to the business side of this serialization.In order to adapt itself to the requirements of the osgi, expanded the original non osgi with osgi scenes, so, no matter whether the osgi environment, all will move into a byte [] array, first copy again.However, most of the scenes with osgi, paid the price, but for the osgi.And if adopts incremental extension method, the osgi code intact, plus an osgi implementation, when wanting to use osgi, rely on osgi implementation can directly. Such as: remote invocation framework, definitely not serialize function, function is very simple, is to transfer as object, the object into a stream.But because of some places may be using osgi, such serialization, IO in this may be isolated and the business side of this.Need to stream into byte [] array, and then passed on to the business side of this serialization.In order to adapt itself to the requirements of the osgi, expanded the original non osgi with osgi scenes, so, no matter whether the osgi environment, all will move into a byte [] array, first copy again.However, most of the scenes with osgi, paid the price, but for the osgi.And if adopts incremental extension method, the osgi code intact, plus an osgi implementation, when wanting to use osgi, rely on osgi implementation can directly. Such as: no status messages before, is very simple, just pass a serialized object.Later a synchronous message send demand, need a Request/Response matching, using extended extension, naturally thought, stateless news is actually a Request without Response, add a Boolean state so in the Request, said do you want to return the Response.If the message is sent to a Session needs again, then add a Session interaction, and then found that the original synchronous message sent is a special case of Session message, all scenarios Session, don't need the Session can be ignored. If the incremental extension, stateless messages intact, synchronous message is sent, on the basis of stateless news add a Request/Response processing, message sending session, plus a SessionRequest/SessionResponse processing.","title":"Talk about expansion of extension and incremental extension"},{"location":"dev/principals/extension/","text":"Extension points to reconstruct http://javatar.iteye.com/blog/1041832 With the promotion of service, the website of Dubbo service framework requirements gradually increase, Dubbo existing developers can implement demand is limited, many requirements have been delay, and site classmates also want to participate, combined with field, so the platform will be open to internal part of the project, let everyone together to implement, Dubbo as one of the pilot project. Now that want to open it, about to take some extension point Dubbo, let participants black box extend as far as possible, rather than a white box to modify the code, or branch, quality, merger, the conflict will be hard to manage. First look at the Dubbo existing design\uff1a There though some extension interface, but not very good collaboration, and loading and configuration of extension points are not unified handling, so face it under the refactoring. Step 1, the core plug-in, equal treatment to the third party Now that want to expand, extension point loading mode, the first thing to unification, micro core + plug-in, can achieve the principle of OCP is train of thought. Made up of a plugin lifecycle management container, core, core does not include any functions, this will ensure that all functions can be replaced, and framework, the authors can achieve the function of the extension must also can do it, so as to guarantee the equal treatment to a third party, so, the function of the framework itself also want to use the plug-in way, cannot have any hard coded. Micro core usually adopt the Factory, the IoC, the OSGi plugin lifecycle management.Consider the applicable Dubbo, strong don't want to rely on the Spring IoC container.The IoC container that you made a small also feel a little too much design, so intend to use the most simple way of Factory management plug-in. Finally decided to adopt the JDK standard SPI extension mechanism, see: Java. Util. The ServiceLoader , namely extension in the jar package meta-inf/services / directory placed with interface of text files, with the same content for interface implementation class name, multiple separate implementation class name with a newline.Need to expand Dubbo agreement, for example, simply by XXX. Placed in a jar file: meta-inf/services/com. Alibaba. Dubbo. RPC. Protocol , contents for com. Alibaba. XXX. XxxProtocol .Dubbo by ServiceLoader scanning to all Protocol implementation. All plug-in and agreed, must be marked with: @ the Extension (\" name \"), as the identity of the name, after loading is used to configure option. Step 2 each extension point encapsulate a change factor, only to maximize reuse Each extension point implementers, usually only care about one thing, now the extension points, is not entirely separate.Such as: Failover, the Route, LoadBalance, Directory not completely separate, all written by RoutingInvokerGroup died. Again, for example, protocol extension, the extension may just want to replace the serialization way, or just replace transmission mode, and Remoting and Http can also reuse serialization, etc.In this way, the need for transport, the client, the server implementation, protocol parsing, data serialization, allow different extension point. After break up, the design is as follows: Step 3, the entire pipeline design, logic framework itself, are implemented using cross section intercept Now a lot of logic, are placed in the base class implementation, then by the method of template back to the realization of the tone categories, including: local, mock, generic, echo, token, accesslog, monitor, count, limit, etc., can use the Filter to realize all split, each function is called a ring on the chain.Such as: (the base class template method) public abstract AbstractInvoker implements Invoker { public Result invoke(Invocation inv) throws RpcException { // Pseudo code active ++; if (active max) wait(); doInvoke(inv); active --; notify(); } protected abstract Result doInvoke(Invocation inv) throws RpcException } To: (chain filter) public abstract LimitFilter implements Filter { public Result invoke(Invoker chain, Invocation inv) throws RpcException { // Pseudo code active ++; if (active max) wait(); chain.invoke(inv); active --; notify(); } } Step 4, a minimum concept, consistent conceptual model Keep the concept of as little as possible, help to understand, for open systems is particularly important.In addition, the interface can use a consistent conceptual model, can guide each other, and reduce the model transformation, For example, Invoker method signature as follows: Result invoke(Invocation invocation) throws RpcException; The Exporter method signature as follows: Object invoke(Method method, Object[] args) throws Throwable; But they are the same, only is a on the client side, one on the server side, different model classes are applied. For example, the URL string, parse and assembled, not a URL model classes, and the Parameters of the URL, but sometimes the Map, and sometimes the Parameters class wrapping, export(String url) createExporter(String host, int port, Parameters params); Use consistent model: export(URL url) createExporter(URL url); For example, the existing: Invoker, Exporter, InvocationHandler, FilterChainAre actually invoke behavior at different stages, can abstract away completely, unified for the Invoker, reduce the concept. Step 5, hierarchical, modular extensions, rather than generic type extension Why see: expansibility \u3002 Generalization expansion refers to: the extension point gradually abstraction, take all functions, sets and new function is always set in and expand the function of the old concept. Combined extension refers to: the extension points orthogonal decomposition, all functions of overlap, new function is always based on the old function implementation. The above design, unconsciously will Dubbo existing function as the core functionality.Above contains the concept of Dubbo existing RPC all functions, including: the Proxy, the Router, Failover, LoadBalance, Subscriber, Publisher, Invoker, Exporter, Filter, etc., But these are the core?RPC can Run, kicked off what?And what is not kick off?Based on this consideration, the RPC can be broken down into two levels, Protocol and Invoker is the core of RPC.Other, including the Router, Failover, Loadbalance, Subscriber, the Publisher is the core, but the Routing.Therefore, the Routing as an extension of the Rpc core, design is as follows: Step 6, and networking After finishing, the design is as follows:","title":"Extension points to reconstruct"},{"location":"dev/principals/extension/#extension-points-to-reconstruct","text":"http://javatar.iteye.com/blog/1041832 With the promotion of service, the website of Dubbo service framework requirements gradually increase, Dubbo existing developers can implement demand is limited, many requirements have been delay, and site classmates also want to participate, combined with field, so the platform will be open to internal part of the project, let everyone together to implement, Dubbo as one of the pilot project. Now that want to open it, about to take some extension point Dubbo, let participants black box extend as far as possible, rather than a white box to modify the code, or branch, quality, merger, the conflict will be hard to manage. First look at the Dubbo existing design\uff1a There though some extension interface, but not very good collaboration, and loading and configuration of extension points are not unified handling, so face it under the refactoring.","title":"Extension points to reconstruct"},{"location":"dev/principals/extension/#step-1-the-core-plug-in-equal-treatment-to-the-third-party","text":"Now that want to expand, extension point loading mode, the first thing to unification, micro core + plug-in, can achieve the principle of OCP is train of thought. Made up of a plugin lifecycle management container, core, core does not include any functions, this will ensure that all functions can be replaced, and framework, the authors can achieve the function of the extension must also can do it, so as to guarantee the equal treatment to a third party, so, the function of the framework itself also want to use the plug-in way, cannot have any hard coded. Micro core usually adopt the Factory, the IoC, the OSGi plugin lifecycle management.Consider the applicable Dubbo, strong don't want to rely on the Spring IoC container.The IoC container that you made a small also feel a little too much design, so intend to use the most simple way of Factory management plug-in. Finally decided to adopt the JDK standard SPI extension mechanism, see: Java. Util. The ServiceLoader , namely extension in the jar package meta-inf/services / directory placed with interface of text files, with the same content for interface implementation class name, multiple separate implementation class name with a newline.Need to expand Dubbo agreement, for example, simply by XXX. Placed in a jar file: meta-inf/services/com. Alibaba. Dubbo. RPC. Protocol , contents for com. Alibaba. XXX. XxxProtocol .Dubbo by ServiceLoader scanning to all Protocol implementation. All plug-in and agreed, must be marked with: @ the Extension (\" name \"), as the identity of the name, after loading is used to configure option.","title":"Step 1, the core plug-in, equal treatment to the third party"},{"location":"dev/principals/extension/#step-2-each-extension-point-encapsulate-a-change-factor-only-to-maximize-reuse","text":"Each extension point implementers, usually only care about one thing, now the extension points, is not entirely separate.Such as: Failover, the Route, LoadBalance, Directory not completely separate, all written by RoutingInvokerGroup died. Again, for example, protocol extension, the extension may just want to replace the serialization way, or just replace transmission mode, and Remoting and Http can also reuse serialization, etc.In this way, the need for transport, the client, the server implementation, protocol parsing, data serialization, allow different extension point. After break up, the design is as follows:","title":"Step 2 each extension point encapsulate a change factor, only to maximize reuse"},{"location":"dev/principals/extension/#step-3-the-entire-pipeline-design-logic-framework-itself-are-implemented-using-cross-section-intercept","text":"Now a lot of logic, are placed in the base class implementation, then by the method of template back to the realization of the tone categories, including: local, mock, generic, echo, token, accesslog, monitor, count, limit, etc., can use the Filter to realize all split, each function is called a ring on the chain.Such as: (the base class template method) public abstract AbstractInvoker implements Invoker { public Result invoke(Invocation inv) throws RpcException { // Pseudo code active ++; if (active max) wait(); doInvoke(inv); active --; notify(); } protected abstract Result doInvoke(Invocation inv) throws RpcException } To: (chain filter) public abstract LimitFilter implements Filter { public Result invoke(Invoker chain, Invocation inv) throws RpcException { // Pseudo code active ++; if (active max) wait(); chain.invoke(inv); active --; notify(); } }","title":"Step 3, the entire pipeline design, logic framework itself, are implemented using cross section intercept"},{"location":"dev/principals/extension/#step-4-a-minimum-concept-consistent-conceptual-model","text":"Keep the concept of as little as possible, help to understand, for open systems is particularly important.In addition, the interface can use a consistent conceptual model, can guide each other, and reduce the model transformation, For example, Invoker method signature as follows: Result invoke(Invocation invocation) throws RpcException; The Exporter method signature as follows: Object invoke(Method method, Object[] args) throws Throwable; But they are the same, only is a on the client side, one on the server side, different model classes are applied. For example, the URL string, parse and assembled, not a URL model classes, and the Parameters of the URL, but sometimes the Map, and sometimes the Parameters class wrapping, export(String url) createExporter(String host, int port, Parameters params); Use consistent model: export(URL url) createExporter(URL url); For example, the existing: Invoker, Exporter, InvocationHandler, FilterChainAre actually invoke behavior at different stages, can abstract away completely, unified for the Invoker, reduce the concept.","title":"Step 4, a minimum concept, consistent conceptual model"},{"location":"dev/principals/extension/#step-5-hierarchical-modular-extensions-rather-than-generic-type-extension","text":"Why see: expansibility \u3002 Generalization expansion refers to: the extension point gradually abstraction, take all functions, sets and new function is always set in and expand the function of the old concept. Combined extension refers to: the extension points orthogonal decomposition, all functions of overlap, new function is always based on the old function implementation. The above design, unconsciously will Dubbo existing function as the core functionality.Above contains the concept of Dubbo existing RPC all functions, including: the Proxy, the Router, Failover, LoadBalance, Subscriber, Publisher, Invoker, Exporter, Filter, etc., But these are the core?RPC can Run, kicked off what?And what is not kick off?Based on this consideration, the RPC can be broken down into two levels, Protocol and Invoker is the core of RPC.Other, including the Router, Failover, Loadbalance, Subscriber, the Publisher is the core, but the Routing.Therefore, the Routing as an extension of the Rpc core, design is as follows:","title":"Step 5, hierarchical, modular extensions, rather than generic type extension"},{"location":"dev/principals/extension/#step-6-and-networking","text":"After finishing, the design is as follows:","title":"Step 6, and networking"},{"location":"dev/principals/general-knowledge/","text":"Some in the design of the basic common sense http://javatar.iteye.com/blog/706098 Recently told the new team some design on the common sense, is likely to be new and some other help, the thought of a few temporarily, first write here. The API and SPI separation Framework or component there are generally two types of customers, one is a consumer, is an extension.API (Application Programming Interface) is used to users, and SPI (Service dojo.provide Interface) is used to expand.At design time, try to put them off, and don't mix.In other words, the user is can't see write the implementation of the extension. For example, a Web framework, it has an API interface to call the Action, there is a the execute () method, which is for the user to write business logic.Then, Web frameworks have a SPI interface to extend the control output, such as velocity templates output or a json output, etc.If this Web framework using an inheritance VelocityAction and a JsonAction as extension of the Action, with output velocity templates will inherit VelocityAction, want to use the json output will inherit JsonAction, this is the opposite of the API and SPI no separation example, SPI interface in the API interface. Is a reasonable way, there is a separate Renderer interface, VelocityRenderer and JsonRenderer implementation, Web framework will transfer the output of the Action to the Renderer interface for rendering output. Service domain/entity/session domains separation Any framework or component, there will always be the core domain model, such as: Spring Bean, Struts Action, Service of Dubbo, Napoli Queue, and so on.The core areas of the model and its component is called physical domain, it represents our goal to operate on itself.Physical domain is thread-safe, usually either through the same class, sync, or copy the way. Service domain, that is, behavior domain, it is the function of the components, but also is responsible for the entity and session domains of life cycle management, such as Spring ApplicationContext, Dubbo ServiceManager, etc.Service domain objects often is heavy, and is thread-safe, and serve all calls to a single instance. What is a session?Is an interactive process.Session key is the concept of context, the context is what?For example, we said: \"old place\", the \"old place\" is the context information.Why do you say \"old place\" other person will know, because we defined earlier the specific content of the \"old place\".So, the context often hold state variables in the process of interaction, etc.The session object, were generally mild and every request to create an instance, destroyed after the request.In short: the meta information held by the entity domain, the temporary state of a request by the session domain, by the service domain throughout the entire process. On the important process to interceptor interface If you want to write a remote invocation framework, the remote call block the process should have a unified interface.If you want to write an ORM framework, that at least the SQL execution, the Mapping process to intercept interface;If you want to write a Web framework, the request execution should be interception interfaces, and so on.No common framework can Cover all requirements, allowing external behavior, is the basic extension of the framework.Before a remote call, so that if someone wants to verify ordered CARDS, verification of black and white list, log statistics;If someone wants to add paging under packing before SQL execution, do data access control, statistics under the SQL execution time.If someone wants to check before the request execution, packaging, input and output flow request quantity statistics, and so on, can accomplish on their own, rather than into frame inside.Interception interfaces, usually to encapsulate process itself with an object, to the interceptor chain, such as: remote calls the main process for the invoke (), the interceptor interface to invoke usually (Invocation), Invocation object encapsulates the would have the execution context, and Invocation in an invoke () method, performed by the interceptor decide when, at the same time, also on behalf of the interceptor Invocation itself, such a interceptor Invocation is actually the process of packaging the next interceptor, until the last interceptor Invocation is packing the final invoke () process;Similarly, the main process for the execute SQL (), the interceptor interface is usually the execute (Execution), principle.Can implement ways, of course, the above is only for example. The important status of sending events and set aside to monitor interface Here to tell the difference between an event and the interceptor above, the interceptor is in the process of intervention, it is part of the process, is based on process behavior, and event is based on state data, any behavior changes of the same condition, the event should be consistent.Event is usually after the event notification is a Callback interface, the method name is usually past tense, such as onChanged ().Remote invocation framework, for example, when the network disconnect or even should send out an event, when there is an error can also be considered an event, such peripheral applications could be observed within the framework of change, make corresponding adjustment. Extension interface functions as a single, composability For example, the remote invocation framework agreement is to replace it.If only provide a general extension interface, switch can deal, of course, but the protocol support can be subdivided into the underlying communication, serialization, dynamic proxy mode and so on.If the interface split, orthogonal decomposition, will be easier to reuse existing logical extension, and just replace a part of the implementation strategy.Of course the decomposition the granularity of the need to grasp. Micronucleus plug-in, equal treatment to the third party \"A good framework of development, abide by the concept of micronucleus.Eclipse is OSGi microkernel, Spring's microkernel is the BeanFactory, Maven microkernel is breadth.With functional core is usually should not be, but a life cycle and integrated container, so that each function can interact through the same way and extension, and any function can be replaced.If they do not microkernel, must be at least equal treatment to a third party, namely, the author can realize the function of extension should can be done by extending all the way.The author want to regard themselves as extension, so as to ensure framework of sustainability and stability of the outside introversion. Don't control the external object lifecycle Such as the above said the Action using the interface and the Renderer extension interface.Framework if let users or extend the Action or the Renderer implementation class name of the class or kind of meta information submitted, then internally by reflecting newInstance () to create an instance of this framework is to control the Action or the Renderer implementation class life cycle, the Action or the Renderer physical, frameworks do it himself, external extension or integration are powerless.Good idea is to let the user or extend the Action or submitted to the realization of the Renderer class instance, framework just use these instances, is how to create these objects, how to destroy, had nothing to do with frame, frame up to provide assistant management tools, rather than absolute control. Configurable must be programmable, and maintain friendly CoC conventions Framework using the environment uncertainty because of the many, there will always be some configuration, usually to a specified name classpath straight sweep configuration, or startup allows you to specify the configuration path.As a common framework, should do all can do configuration file must be able to programmatically, or when the user needs to be your frame with another frame integration will bring a lot of unnecessary trouble. In addition, as far as possible do a standard contract, if the user has to do things by some sort of agreement, there is no need for the configuration items.Such as: configuration templates location, you can agree, if in the templates directory doesn't have to match, if you want to change the directory, and configuration. Distinguish between commands and queries, clear pre-conditions and post-conditions This is part of the design by contract, try to keep to a return value method is to query methods, void return method is to command.Query methods are usually idempotence, without side effects, also is not change any state, the n results are the same, such as the get a property value, or query a database record.Command is to point to have side effects, namely will change state, such as set a value, or update a database record.If you have modified the status of the operation, do a query returns again, if possible, to split it into writing reading separation of the two methods, such as: User deleteUser (id), delete users and returns the deleted users, consider to the getUser () and void deleteUser ().In addition, each method is front-facing assert that the legitimacy of the incoming parameters, as far as possible the rear assertion returns the legitimacy, and documented. Incremental extension, and not to extend the original core concept refer to\uff1a expansibility","title":"Some in the design of the basic common sense"},{"location":"dev/principals/general-knowledge/#some-in-the-design-of-the-basic-common-sense","text":"http://javatar.iteye.com/blog/706098 Recently told the new team some design on the common sense, is likely to be new and some other help, the thought of a few temporarily, first write here.","title":"Some in the design of the basic common sense"},{"location":"dev/principals/general-knowledge/#the-api-and-spi-separation","text":"Framework or component there are generally two types of customers, one is a consumer, is an extension.API (Application Programming Interface) is used to users, and SPI (Service dojo.provide Interface) is used to expand.At design time, try to put them off, and don't mix.In other words, the user is can't see write the implementation of the extension. For example, a Web framework, it has an API interface to call the Action, there is a the execute () method, which is for the user to write business logic.Then, Web frameworks have a SPI interface to extend the control output, such as velocity templates output or a json output, etc.If this Web framework using an inheritance VelocityAction and a JsonAction as extension of the Action, with output velocity templates will inherit VelocityAction, want to use the json output will inherit JsonAction, this is the opposite of the API and SPI no separation example, SPI interface in the API interface. Is a reasonable way, there is a separate Renderer interface, VelocityRenderer and JsonRenderer implementation, Web framework will transfer the output of the Action to the Renderer interface for rendering output.","title":"The API and SPI separation"},{"location":"dev/principals/general-knowledge/#service-domainentitysession-domains-separation","text":"Any framework or component, there will always be the core domain model, such as: Spring Bean, Struts Action, Service of Dubbo, Napoli Queue, and so on.The core areas of the model and its component is called physical domain, it represents our goal to operate on itself.Physical domain is thread-safe, usually either through the same class, sync, or copy the way. Service domain, that is, behavior domain, it is the function of the components, but also is responsible for the entity and session domains of life cycle management, such as Spring ApplicationContext, Dubbo ServiceManager, etc.Service domain objects often is heavy, and is thread-safe, and serve all calls to a single instance. What is a session?Is an interactive process.Session key is the concept of context, the context is what?For example, we said: \"old place\", the \"old place\" is the context information.Why do you say \"old place\" other person will know, because we defined earlier the specific content of the \"old place\".So, the context often hold state variables in the process of interaction, etc.The session object, were generally mild and every request to create an instance, destroyed after the request.In short: the meta information held by the entity domain, the temporary state of a request by the session domain, by the service domain throughout the entire process.","title":"Service domain/entity/session domains separation"},{"location":"dev/principals/general-knowledge/#on-the-important-process-to-interceptor-interface","text":"If you want to write a remote invocation framework, the remote call block the process should have a unified interface.If you want to write an ORM framework, that at least the SQL execution, the Mapping process to intercept interface;If you want to write a Web framework, the request execution should be interception interfaces, and so on.No common framework can Cover all requirements, allowing external behavior, is the basic extension of the framework.Before a remote call, so that if someone wants to verify ordered CARDS, verification of black and white list, log statistics;If someone wants to add paging under packing before SQL execution, do data access control, statistics under the SQL execution time.If someone wants to check before the request execution, packaging, input and output flow request quantity statistics, and so on, can accomplish on their own, rather than into frame inside.Interception interfaces, usually to encapsulate process itself with an object, to the interceptor chain, such as: remote calls the main process for the invoke (), the interceptor interface to invoke usually (Invocation), Invocation object encapsulates the would have the execution context, and Invocation in an invoke () method, performed by the interceptor decide when, at the same time, also on behalf of the interceptor Invocation itself, such a interceptor Invocation is actually the process of packaging the next interceptor, until the last interceptor Invocation is packing the final invoke () process;Similarly, the main process for the execute SQL (), the interceptor interface is usually the execute (Execution), principle.Can implement ways, of course, the above is only for example.","title":"On the important process to interceptor interface"},{"location":"dev/principals/general-knowledge/#the-important-status-of-sending-events-and-set-aside-to-monitor-interface","text":"Here to tell the difference between an event and the interceptor above, the interceptor is in the process of intervention, it is part of the process, is based on process behavior, and event is based on state data, any behavior changes of the same condition, the event should be consistent.Event is usually after the event notification is a Callback interface, the method name is usually past tense, such as onChanged ().Remote invocation framework, for example, when the network disconnect or even should send out an event, when there is an error can also be considered an event, such peripheral applications could be observed within the framework of change, make corresponding adjustment.","title":"The important status of sending events and set aside to monitor interface"},{"location":"dev/principals/general-knowledge/#extension-interface-functions-as-a-single-composability","text":"For example, the remote invocation framework agreement is to replace it.If only provide a general extension interface, switch can deal, of course, but the protocol support can be subdivided into the underlying communication, serialization, dynamic proxy mode and so on.If the interface split, orthogonal decomposition, will be easier to reuse existing logical extension, and just replace a part of the implementation strategy.Of course the decomposition the granularity of the need to grasp.","title":"Extension interface functions as a single, composability"},{"location":"dev/principals/general-knowledge/#micronucleus-plug-in-equal-treatment-to-the-third-party","text":"\"A good framework of development, abide by the concept of micronucleus.Eclipse is OSGi microkernel, Spring's microkernel is the BeanFactory, Maven microkernel is breadth.With functional core is usually should not be, but a life cycle and integrated container, so that each function can interact through the same way and extension, and any function can be replaced.If they do not microkernel, must be at least equal treatment to a third party, namely, the author can realize the function of extension should can be done by extending all the way.The author want to regard themselves as extension, so as to ensure framework of sustainability and stability of the outside introversion.","title":"Micronucleus plug-in, equal treatment to the third party"},{"location":"dev/principals/general-knowledge/#dont-control-the-external-object-lifecycle","text":"Such as the above said the Action using the interface and the Renderer extension interface.Framework if let users or extend the Action or the Renderer implementation class name of the class or kind of meta information submitted, then internally by reflecting newInstance () to create an instance of this framework is to control the Action or the Renderer implementation class life cycle, the Action or the Renderer physical, frameworks do it himself, external extension or integration are powerless.Good idea is to let the user or extend the Action or submitted to the realization of the Renderer class instance, framework just use these instances, is how to create these objects, how to destroy, had nothing to do with frame, frame up to provide assistant management tools, rather than absolute control.","title":"Don't control the external object lifecycle"},{"location":"dev/principals/general-knowledge/#configurable-must-be-programmable-and-maintain-friendly-coc-conventions","text":"Framework using the environment uncertainty because of the many, there will always be some configuration, usually to a specified name classpath straight sweep configuration, or startup allows you to specify the configuration path.As a common framework, should do all can do configuration file must be able to programmatically, or when the user needs to be your frame with another frame integration will bring a lot of unnecessary trouble. In addition, as far as possible do a standard contract, if the user has to do things by some sort of agreement, there is no need for the configuration items.Such as: configuration templates location, you can agree, if in the templates directory doesn't have to match, if you want to change the directory, and configuration.","title":"Configurable must be programmable, and maintain friendly CoC conventions"},{"location":"dev/principals/general-knowledge/#distinguish-between-commands-and-queries-clear-pre-conditions-and-post-conditions","text":"This is part of the design by contract, try to keep to a return value method is to query methods, void return method is to command.Query methods are usually idempotence, without side effects, also is not change any state, the n results are the same, such as the get a property value, or query a database record.Command is to point to have side effects, namely will change state, such as set a value, or update a database record.If you have modified the status of the operation, do a query returns again, if possible, to split it into writing reading separation of the two methods, such as: User deleteUser (id), delete users and returns the deleted users, consider to the getUser () and void deleteUser ().In addition, each method is front-facing assert that the legitimacy of the incoming parameters, as far as possible the rear assertion returns the legitimacy, and documented.","title":"Distinguish between commands and queries, clear pre-conditions and post-conditions"},{"location":"dev/principals/general-knowledge/#incremental-extension-and-not-to-extend-the-original-core-concept","text":"refer to\uff1a expansibility","title":"Incremental extension, and not to extend the original core concept"},{"location":"dev/principals/introduction/","text":"Design principals The design principles in this chapter are taken from a series of articles published by Liang Fei on javaeye.","title":"Design principals"},{"location":"dev/principals/introduction/#design-principals","text":"The design principles in this chapter are taken from a series of articles published by Liang Fei on javaeye.","title":"Design principals"},{"location":"dev/principals/robustness/","text":"The robustness of the design implementation http://oldratlee.com/380/tech/java/robustness-of-implement.html Dubbo as a remote service exposure, calls and management solutions, through the meridians of the application is running, its itself to achieve robustness of importance is self-evident. Here are some Dubbo principle and method of use. The log Logging is one of the most commonly used way to find, discover problems.Log quality is often neglected, there is no log on using expressly agreed upon.Attaches great importance to the use of the Log, and improve the concentration of the Log information.Log too much, too much chaos, could lead to useful information. To effectively use this tool to note: Record the contents of the stipulated strictly WARN, the ERROR level WARN that can restore the problem without human intervention. The ERROR says requires human intervention. With such agreement, the regulatory system found in the ERROR log file of the string will call the police, and to minimize the occurrence.Excessive alarm can let a person tired, make the person lose vigilance in alarm, make the ERROR log.Along with artificial, regularly check the WARN level information to assess the degree of \"subhealth\" system. In the log, as much as possible to collect key information What is the key information? Site information at the time of the problem, namely the screening questions to use information.Such as service invocation fails, to give the use of Dubbo version, the service provider's IP, which is used in the registry;Which service invocation, which method and so on.This information if not given, then later artificial collection, problem after the site may have already can't recover, increase the difficulty of the problem. If possible, the cause of the problem and the solution is given.This makes maintenance and problem solving becomes simple, rather than seeking savvy (often the implementer) for help. Don't duplicate records many times the same or a class of problems The same or a kind of abnormal log continuous there dozens of times, still can often see.The human eye is easy to miss under the different important log information.Try to avoid this situation.Will appear in the foreseeable, it is necessary to add some logic to avoid. As a symbol for a question, a problem after log Settings after sign and avoid a repeat of the log.The problem clear sign after recovery. Although a bit troublesome, but do ensure log information concentration, the more effective for monitoring. Limit set Resources are limited, CPU, memory, IO, etc.Don't cry because it is outside of the request, the data is not limited. The size of the thread pool (ExectorService) and saturated strategy The Server end ExectorService set limit for processing requests.Use limited queue ExecutorService task waiting queue, avoid resource depletion.When the task waiting queue saturated, choose a suitable saturated strategy.This ensures smooth degradation. In Dubbo, saturated strategy is to discard data, waiting for the result is only a request timeout. Saturated, the specification has reached the maximum load, the service provider to logging in the operation of the saturated strategy of the problem, in order to monitor warnings.Remember to be careful not to repeat many times record well.(note that the default saturation strategy will not have these additional operation.)According to the frequency of the alarm, has decided to increase adjustment, etc., avoid system problems are ignored. The collection capacity If to ensure element is controlled on the collection and is small enough, then you can rest assured use.This is most of the situation.If can't guarantee anything, use a bounded set.When reach the boundary, choose a suitable strategy. Fault tolerant - retry - recovery High availability components to tolerate its dependence on the failure of the component. Dubbo service registry The service registry using the database to store the information service providers and consumers.Different registry registry cluster through the database to synchronize data, to perceive other providers on the registry.Registry would ensure a provider and consumer data in memory, the database is unavailable, independent of the normal operation of foreign registry, just can't get other registry data.When the database recovery, retry logic will modify memory write data back to the database, and get a new database data. Service consumers After the message service provider list from the registry, will save the provider list to memory and disk file.Consumers can function properly after this registry is down, even in the registry during outage restart consumers.Consumers started, find the registry is not available, will read the list stored in the disk file provider.Retry logic to ensure the registry after recovery, update the information. Retry delay strategy On a bit of the subproblem.Dubbo encountered two related scenario. On the database lock Registration center will regularly update the database of a record timestamp, such cluster other registry perceive it is alive.Overdue registry and its associated data will be cleared.Database is normal, the mechanism as well.But the database load is high, its every action is slow.This occurs: A registry that B expired, delete B data.B find their data, to write their own data repeatedly.These repeated operation and increase load the database, deterioration. Use the following logic: When data is deleted B found themselves fail (write), choose to wait for this period of time and try again.Can choose to retry time exponentially, such as first class 1 minute, the second for 10 minutes, 100 minutes for the third time. This decrease after operation, ensure database can cooling Down (Cool Down). The Client reconnection registry When a registry downtime, other Client will receive events at the same time, and to reconnect to another registry.The Client number is relatively more, will be the impact of the registry.Avoid method can be a Client reconnection random delay for 3 minutes, when the reconnection spread out.","title":"The robustness of the design implementation"},{"location":"dev/principals/robustness/#the-robustness-of-the-design-implementation","text":"http://oldratlee.com/380/tech/java/robustness-of-implement.html Dubbo as a remote service exposure, calls and management solutions, through the meridians of the application is running, its itself to achieve robustness of importance is self-evident. Here are some Dubbo principle and method of use.","title":"The robustness of the design implementation"},{"location":"dev/principals/robustness/#the-log","text":"Logging is one of the most commonly used way to find, discover problems.Log quality is often neglected, there is no log on using expressly agreed upon.Attaches great importance to the use of the Log, and improve the concentration of the Log information.Log too much, too much chaos, could lead to useful information. To effectively use this tool to note:","title":"The log"},{"location":"dev/principals/robustness/#record-the-contents-of-the-stipulated-strictly-warn-the-error-level","text":"WARN that can restore the problem without human intervention. The ERROR says requires human intervention. With such agreement, the regulatory system found in the ERROR log file of the string will call the police, and to minimize the occurrence.Excessive alarm can let a person tired, make the person lose vigilance in alarm, make the ERROR log.Along with artificial, regularly check the WARN level information to assess the degree of \"subhealth\" system.","title":"Record the contents of the stipulated strictly WARN, the ERROR level"},{"location":"dev/principals/robustness/#in-the-log-as-much-as-possible-to-collect-key-information","text":"What is the key information? Site information at the time of the problem, namely the screening questions to use information.Such as service invocation fails, to give the use of Dubbo version, the service provider's IP, which is used in the registry;Which service invocation, which method and so on.This information if not given, then later artificial collection, problem after the site may have already can't recover, increase the difficulty of the problem. If possible, the cause of the problem and the solution is given.This makes maintenance and problem solving becomes simple, rather than seeking savvy (often the implementer) for help.","title":"In the log, as much as possible to collect key information"},{"location":"dev/principals/robustness/#dont-duplicate-records-many-times-the-same-or-a-class-of-problems","text":"The same or a kind of abnormal log continuous there dozens of times, still can often see.The human eye is easy to miss under the different important log information.Try to avoid this situation.Will appear in the foreseeable, it is necessary to add some logic to avoid. As a symbol for a question, a problem after log Settings after sign and avoid a repeat of the log.The problem clear sign after recovery. Although a bit troublesome, but do ensure log information concentration, the more effective for monitoring.","title":"Don't duplicate records many times the same or a class of problems"},{"location":"dev/principals/robustness/#limit-set","text":"Resources are limited, CPU, memory, IO, etc.Don't cry because it is outside of the request, the data is not limited.","title":"Limit set"},{"location":"dev/principals/robustness/#the-size-of-the-thread-pool-exectorservice-and-saturated-strategy","text":"The Server end ExectorService set limit for processing requests.Use limited queue ExecutorService task waiting queue, avoid resource depletion.When the task waiting queue saturated, choose a suitable saturated strategy.This ensures smooth degradation. In Dubbo, saturated strategy is to discard data, waiting for the result is only a request timeout. Saturated, the specification has reached the maximum load, the service provider to logging in the operation of the saturated strategy of the problem, in order to monitor warnings.Remember to be careful not to repeat many times record well.(note that the default saturation strategy will not have these additional operation.)According to the frequency of the alarm, has decided to increase adjustment, etc., avoid system problems are ignored.","title":"The size of the thread pool (ExectorService) and saturated strategy"},{"location":"dev/principals/robustness/#the-collection-capacity","text":"If to ensure element is controlled on the collection and is small enough, then you can rest assured use.This is most of the situation.If can't guarantee anything, use a bounded set.When reach the boundary, choose a suitable strategy.","title":"The collection capacity"},{"location":"dev/principals/robustness/#fault-tolerant-retry-recovery","text":"High availability components to tolerate its dependence on the failure of the component.","title":"Fault tolerant - retry - recovery"},{"location":"dev/principals/robustness/#dubbo-service-registry","text":"The service registry using the database to store the information service providers and consumers.Different registry registry cluster through the database to synchronize data, to perceive other providers on the registry.Registry would ensure a provider and consumer data in memory, the database is unavailable, independent of the normal operation of foreign registry, just can't get other registry data.When the database recovery, retry logic will modify memory write data back to the database, and get a new database data.","title":"Dubbo service registry"},{"location":"dev/principals/robustness/#service-consumers","text":"After the message service provider list from the registry, will save the provider list to memory and disk file.Consumers can function properly after this registry is down, even in the registry during outage restart consumers.Consumers started, find the registry is not available, will read the list stored in the disk file provider.Retry logic to ensure the registry after recovery, update the information.","title":"Service consumers"},{"location":"dev/principals/robustness/#retry-delay-strategy","text":"On a bit of the subproblem.Dubbo encountered two related scenario.","title":"Retry delay strategy"},{"location":"dev/principals/robustness/#on-the-database-lock","text":"Registration center will regularly update the database of a record timestamp, such cluster other registry perceive it is alive.Overdue registry and its associated data will be cleared.Database is normal, the mechanism as well.But the database load is high, its every action is slow.This occurs: A registry that B expired, delete B data.B find their data, to write their own data repeatedly.These repeated operation and increase load the database, deterioration. Use the following logic: When data is deleted B found themselves fail (write), choose to wait for this period of time and try again.Can choose to retry time exponentially, such as first class 1 minute, the second for 10 minutes, 100 minutes for the third time. This decrease after operation, ensure database can cooling Down (Cool Down).","title":"On the database lock"},{"location":"dev/principals/robustness/#the-client-reconnection-registry","text":"When a registry downtime, other Client will receive events at the same time, and to reconnect to another registry.The Client number is relatively more, will be the impact of the registry.Avoid method can be a Client reconnection random delay for 3 minutes, when the reconnection spread out.","title":"The Client reconnection registry"},{"location":"developers/developers_dev/","text":"Developers This page shows Dubbo developers. Please file PR to add or change items. Committers Apache ID Name Organization Role TimeZone jmclean Justin Mclean Apache Mentor +11 markt Mark Thomas Apache Mentor +0 wave Dave Fisher Apache Mentor johndament John D. Ament retired Mentor jfclere Jean-Frederic Clere retired Mentor huxing Huxing Zhang Alibaba PMC +8 vongosling Von Gosling Alibaba PMC +8 iluo Ian Luo Alibaba PMC +8 liujun Jun Liu Alibaba PMC +8 zhangliang Liang Zhang Jingdong PMC +8 liujieqin Liujie Qin Alibaba PMC +8 mercyblitz Mercy Ma Alibaba PMC +8 wangxin Xin Wang Weidian PMC +8 yiji Shang Zonghai Youzan PMC +8 jerrick Yong Zhu Alibaba PMC +8 carryxyh Yuhang Xiu Netease PMC +8 hyunkun YunKun Huang Meituan-Dianping PMC +8 min Minxuan Zhuang Alibaba PMC +8 kimmking Kimm King Rongguan PMC +8 leonleeldc Dingcheng Li Alibaba Committer +8 yuyijq Zhaohui Yu Qunar Committer +8 mjk Jinkai Ma Handuyishe Committer +8 yizhenqiang Zhenqiang Yi Didi Committer +8 victory Victory Cao Alibaba Committer +8 purpleforce Liandong Chen Alibaba Committer +8 jefflv Jeff Lv Alibaba Committer +8 tswstarplanet Taosheng Wei NetsUnion Committer +8 kexianjun Xianjun Ke Caocaokeji Committer +8 songkun Kun Song Huawei Committer +8 lixiaojie Xiaojie Li GomeFinance Committer +8 biyuhao Yuhao Bi Asiainfo-sec Committer +8 crazyhzm Zhongming Hua iFlytek Committer +8 kezhenxu94 Zhenxu Ke Lizhi FM Committer +8 LiZhenNet Zhen Li Keep Committer +8 lexburner Jingfeng Xu Alibaba Committer +8 khanimteyaz Imteyaz Khan Committer xxz Xiaoxiang Zhai Souche Committer +8 codingsinger Zechao Zheng iQIYI Committer +8 zouyx Yixian Zou Shein Committer +8 baze Chao Jiang Biosan Committer +8 Contributors Github ID Github URL Organization TimeZone leyou240 https://github.com/leyou240 +8 chenzhiguo https://github.com/chenzhiguo +8 huyuechy https://github.com/huyuechy +8 caojiele https://github.com/caojiele +8","title":"Developers dev"},{"location":"developers/developers_dev/#developers","text":"This page shows Dubbo developers. Please file PR to add or change items.","title":"Developers"},{"location":"developers/developers_dev/#committers","text":"Apache ID Name Organization Role TimeZone jmclean Justin Mclean Apache Mentor +11 markt Mark Thomas Apache Mentor +0 wave Dave Fisher Apache Mentor johndament John D. Ament retired Mentor jfclere Jean-Frederic Clere retired Mentor huxing Huxing Zhang Alibaba PMC +8 vongosling Von Gosling Alibaba PMC +8 iluo Ian Luo Alibaba PMC +8 liujun Jun Liu Alibaba PMC +8 zhangliang Liang Zhang Jingdong PMC +8 liujieqin Liujie Qin Alibaba PMC +8 mercyblitz Mercy Ma Alibaba PMC +8 wangxin Xin Wang Weidian PMC +8 yiji Shang Zonghai Youzan PMC +8 jerrick Yong Zhu Alibaba PMC +8 carryxyh Yuhang Xiu Netease PMC +8 hyunkun YunKun Huang Meituan-Dianping PMC +8 min Minxuan Zhuang Alibaba PMC +8 kimmking Kimm King Rongguan PMC +8 leonleeldc Dingcheng Li Alibaba Committer +8 yuyijq Zhaohui Yu Qunar Committer +8 mjk Jinkai Ma Handuyishe Committer +8 yizhenqiang Zhenqiang Yi Didi Committer +8 victory Victory Cao Alibaba Committer +8 purpleforce Liandong Chen Alibaba Committer +8 jefflv Jeff Lv Alibaba Committer +8 tswstarplanet Taosheng Wei NetsUnion Committer +8 kexianjun Xianjun Ke Caocaokeji Committer +8 songkun Kun Song Huawei Committer +8 lixiaojie Xiaojie Li GomeFinance Committer +8 biyuhao Yuhao Bi Asiainfo-sec Committer +8 crazyhzm Zhongming Hua iFlytek Committer +8 kezhenxu94 Zhenxu Ke Lizhi FM Committer +8 LiZhenNet Zhen Li Keep Committer +8 lexburner Jingfeng Xu Alibaba Committer +8 khanimteyaz Imteyaz Khan Committer xxz Xiaoxiang Zhai Souche Committer +8 codingsinger Zechao Zheng iQIYI Committer +8 zouyx Yixian Zou Shein Committer +8 baze Chao Jiang Biosan Committer +8","title":"Committers"},{"location":"developers/developers_dev/#contributors","text":"Github ID Github URL Organization TimeZone leyou240 https://github.com/leyou240 +8 chenzhiguo https://github.com/chenzhiguo +8 huyuechy https://github.com/huyuechy +8 caojiele https://github.com/caojiele +8","title":"Contributors"},{"location":"developers/guide_dev/","text":"Contributing to Dubbo Dubbo is released under the non-restrictive Apache 2.0 license, and follows a very standard Github development process, using Github tracker for issues and merging pull requests into master. If you want to contribute even something trivial please do not hesitate, but follow the guidelines below. Sign the Contributor License Agreement Before we accept a non-trivial patch or pull request we will need you to sign the Contributor License Agreement. Signing the contributor\u2019s agreement does not grant anyone commit rights to the main repository, but it does mean that we can accept your contributions, and you will get an author credit if we do. Active contributors might be asked to join the core team, and given the ability to merge pull requests. Contact Mailing list The mailing list is the recommended way for discussing almost anything that related to Dubbo. Please refer to this guide for detailed documentation on how to subscribe. dev@dubbo.apache.org : the develop mailing list, you can ask question here if you have encountered any problem when using or developing Dubbo. commits@dubbo.apache.org : all the commits will be sent to this mailing list. You can subscribe to it if you are interested in Dubbo's development. notification@dubbo.apache.org : all the Github issue updates and pull request updates will be sent to this mailing list. Reporting issue Please follow the template for reporting any issues. Code Conventions Our code style is almost in line with the standard java conventions (Popular IDE's default setting satisfy this), with the following additional restricts: * If there are more than 120 characters in current line, start a new line. Make sure all new .java files to have a simple Javadoc class comment with at least a @date tag identifying birth, and preferably at least a paragraph on what the class is for. Add the ASF license header comment to all new .java files (copy from existing files in the project) Make sure no @author tag added to the file you contribute since @author tag is not used at Apache, other ways such as cvs will record all your contributions fairly. Add some Javadocs and, if you change the namespace, some XSD doc elements. A few unit tests should be added for a new feature or an important bugfix. If no-one else is using your branch, please rebase it against the current master (or other target branch in the main project). When writing a commit message please follow these conventions, if you are fixing an existing issue please add Fixes #XXX at the end of the commit message (where XXX is the issue number). Contribution flow This is a rough outline of what a contributor's workflow looks like: Fork the current repository Create a topic branch from where to base the contribution. This is usually master. Make commits of logical units. Make sure commit messages are in the proper format (see below). Push changes in a topic branch to your forked repository. Follow the checklist in the pull request template Before you sending out the pull request, please sync your forked repository with remote repository, this will make your pull request simple and clear. See guide below: git remote add upstream git@github.com:apache/dubbo.git git fetch upstream git rebase upstream/master git checkout -b your_awesome_patch ... add some work git push origin your_awesome_patch Submit a pull request to apache/dubbo and wait for the reply. Thanks for contributing! Code style We provide a template file dubbo_codestyle_for_idea.xml for IntelliJ idea, you can import it to you IDE. If you use Eclipse you can config manually by referencing the same file. NOTICE It is very important to set the dubbo_codestyle_for_idea.xml, otherwise you will fail to pass the Travis CI. Steps to set the code style are as below: Enter Editor Code Style To manage a code style scheme, in the Code Style page, select the desired scheme from the drop-down list, and click . From the drop-down list, select Import Scheme , then select this option IntelliJ IDEA code style XML to import scheme In the Scheme field, type the name of the new scheme and press \u23ce to save the changes.","title":"Guide dev"},{"location":"developers/guide_dev/#contributing-to-dubbo","text":"Dubbo is released under the non-restrictive Apache 2.0 license, and follows a very standard Github development process, using Github tracker for issues and merging pull requests into master. If you want to contribute even something trivial please do not hesitate, but follow the guidelines below.","title":"Contributing to Dubbo"},{"location":"developers/guide_dev/#sign-the-contributor-license-agreement","text":"Before we accept a non-trivial patch or pull request we will need you to sign the Contributor License Agreement. Signing the contributor\u2019s agreement does not grant anyone commit rights to the main repository, but it does mean that we can accept your contributions, and you will get an author credit if we do. Active contributors might be asked to join the core team, and given the ability to merge pull requests.","title":"Sign the Contributor License Agreement"},{"location":"developers/guide_dev/#contact","text":"","title":"Contact"},{"location":"developers/guide_dev/#mailing-list","text":"The mailing list is the recommended way for discussing almost anything that related to Dubbo. Please refer to this guide for detailed documentation on how to subscribe. dev@dubbo.apache.org : the develop mailing list, you can ask question here if you have encountered any problem when using or developing Dubbo. commits@dubbo.apache.org : all the commits will be sent to this mailing list. You can subscribe to it if you are interested in Dubbo's development. notification@dubbo.apache.org : all the Github issue updates and pull request updates will be sent to this mailing list.","title":"Mailing list"},{"location":"developers/guide_dev/#reporting-issue","text":"Please follow the template for reporting any issues.","title":"Reporting issue"},{"location":"developers/guide_dev/#code-conventions","text":"Our code style is almost in line with the standard java conventions (Popular IDE's default setting satisfy this), with the following additional restricts: * If there are more than 120 characters in current line, start a new line. Make sure all new .java files to have a simple Javadoc class comment with at least a @date tag identifying birth, and preferably at least a paragraph on what the class is for. Add the ASF license header comment to all new .java files (copy from existing files in the project) Make sure no @author tag added to the file you contribute since @author tag is not used at Apache, other ways such as cvs will record all your contributions fairly. Add some Javadocs and, if you change the namespace, some XSD doc elements. A few unit tests should be added for a new feature or an important bugfix. If no-one else is using your branch, please rebase it against the current master (or other target branch in the main project). When writing a commit message please follow these conventions, if you are fixing an existing issue please add Fixes #XXX at the end of the commit message (where XXX is the issue number).","title":"Code Conventions"},{"location":"developers/guide_dev/#contribution-flow","text":"This is a rough outline of what a contributor's workflow looks like: Fork the current repository Create a topic branch from where to base the contribution. This is usually master. Make commits of logical units. Make sure commit messages are in the proper format (see below). Push changes in a topic branch to your forked repository. Follow the checklist in the pull request template Before you sending out the pull request, please sync your forked repository with remote repository, this will make your pull request simple and clear. See guide below: git remote add upstream git@github.com:apache/dubbo.git git fetch upstream git rebase upstream/master git checkout -b your_awesome_patch ... add some work git push origin your_awesome_patch Submit a pull request to apache/dubbo and wait for the reply. Thanks for contributing!","title":"Contribution flow"},{"location":"developers/guide_dev/#code-style","text":"We provide a template file dubbo_codestyle_for_idea.xml for IntelliJ idea, you can import it to you IDE. If you use Eclipse you can config manually by referencing the same file. NOTICE It is very important to set the dubbo_codestyle_for_idea.xml, otherwise you will fail to pass the Travis CI. Steps to set the code style are as below: Enter Editor Code Style To manage a code style scheme, in the Code Style page, select the desired scheme from the drop-down list, and click . From the drop-down list, select Import Scheme , then select this option IntelliJ IDEA code style XML to import scheme In the Scheme field, type the name of the new scheme and press \u23ce to save the changes.","title":"Code style"},{"location":"developers/committer-guide/apache-dubbo-page_dev/","text":"Apache Official Dubbo Page Maintenance Apache has an official website that maintains information about all incubation projects. Each incubation project has an information page under this website. Dubbo's information page address is https://incubator.apache.org/projects/dubbo.html. When the project has undergone major changes, such as the addition of a new committer, the election of a new PMC, or a new version of Release, etc, these updates need to be maintained on this page. The project address for this official website is https://svn.apache.org/repos/asf/incubator/public/trunk. Here's how to maintain this page: Install the SVN. If it is a Mac OS X system or a Linux system, it comes with SVN. If it is a Windows system, please install SVN first. Check out the project with SVN. Modify the content/projects/dubbo.xml file and save it. Install ANT. And execute the ant command in the trunk directory to build. After the build is complete, open the target/site/projects/dubbo.html file with your browser to see if the changes take effect. Use the commit command of SVN to submit the dubbo.xml file to the server, and do not submit the dubbo.html file (because the server will automatically build it at regular intervals). This process will ask for the Apache id and password. References: 1.http://incubator.apache.org/guides/website.html 2.https://svn.apache.org/repos/asf/incubator/public/trunk/README.txt","title":"Apache Official Dubbo Page Maintenance"},{"location":"developers/committer-guide/apache-dubbo-page_dev/#apache-official-dubbo-page-maintenance","text":"Apache has an official website that maintains information about all incubation projects. Each incubation project has an information page under this website. Dubbo's information page address is https://incubator.apache.org/projects/dubbo.html. When the project has undergone major changes, such as the addition of a new committer, the election of a new PMC, or a new version of Release, etc, these updates need to be maintained on this page. The project address for this official website is https://svn.apache.org/repos/asf/incubator/public/trunk. Here's how to maintain this page: Install the SVN. If it is a Mac OS X system or a Linux system, it comes with SVN. If it is a Windows system, please install SVN first. Check out the project with SVN. Modify the content/projects/dubbo.xml file and save it. Install ANT. And execute the ant command in the trunk directory to build. After the build is complete, open the target/site/projects/dubbo.html file with your browser to see if the changes take effect. Use the commit command of SVN to submit the dubbo.xml file to the server, and do not submit the dubbo.html file (because the server will automatically build it at regular intervals). This process will ask for the Apache id and password. References: 1.http://incubator.apache.org/guides/website.html 2.https://svn.apache.org/repos/asf/incubator/public/trunk/README.txt","title":"Apache Official Dubbo Page Maintenance"},{"location":"developers/committer-guide/label-an-issue-guide_dev/","text":"Label an Issue If you are handling an issue, remember to mark the issue cearly with one or more labels whenever you think it's meaningful. With labels on, other developers can easily recognize problems, classify them or track progress. For issues or pull requests that need coding and further version release to fix, you should always mark it with a milestone . Some frequently used labels: * Help Wanted * help wanted * good first issue Prority priority/blocker priority/high priority/low priority/normal Status status/need-triage status/DO-NOT-MERGE status/READY-TO-MERGE status/invalid status/wontfix Type type/bug type/documentation type/enhancement type/feature","title":"Label an Issue"},{"location":"developers/committer-guide/label-an-issue-guide_dev/#label-an-issue","text":"If you are handling an issue, remember to mark the issue cearly with one or more labels whenever you think it's meaningful. With labels on, other developers can easily recognize problems, classify them or track progress. For issues or pull requests that need coding and further version release to fix, you should always mark it with a milestone . Some frequently used labels: * Help Wanted * help wanted * good first issue Prority priority/blocker priority/high priority/low priority/normal Status status/need-triage status/DO-NOT-MERGE status/READY-TO-MERGE status/invalid status/wontfix Type type/bug type/documentation type/enhancement type/feature","title":"Label an Issue"},{"location":"developers/committer-guide/new-committer-guide_dev/","text":"Apache Committer Guide First: How to become a committer Initial committers at the project incubator stage At the project incubator stage, there will be an initial committers list in the proposal of the incubator project. Confirm that you are one of the initial committers. After the vote is passed in the Apache incubator community, these committers can start preparing their account. See incubator wiki for details. The active contributor is elected as a committer At the late development stage, an active contributor can be elected as a committer. See how to become a committer Second: The individual contributor signs ICLA 1, Apache ID Choose a Apache ID not in the apache committers list page . 2, Individual Contributor License Agreement (ICLA): Download the ICLA template . After filling the icla.pdf with personal information correctly, print, sign, scan, and send it in mail as an attachment to the secretary secretary@apache.org, the secretary will help to create the Apache user ID. At the same time, a your-id@apache.org mailbox will be created. You can see if the user has been created on the [apache committers list page (http://people.apache.org/committer-index.html). Third: Join The Apache Developer Group 1, login via the Apache account tool , when you login at the first time, you can select the \"Change password?\" checkbox to get the initial password. Then the initial password will be sent to the forward mailbox (the developer mail recorded in the project incubator proposal) 2, about Apache mailbox: does not have its own mail content storage server. It needs to borrow the mail content storage and mail sending functions of other mail providers. In many voting sessions, Apache mailbox is recommended. There is a question about how to configure the apache.org mailbox forwarding function using other mailboxes. 1) inbox: to receive mails that sent to youer-id@apache.org mailbox. The forward mailbox configured in the Apache account tool in the first step can use the forward mailbox to pick up incoming mail. 2) the Outbox: emails sent out will show the sender as your-id@apache.org account. Please refer to: set up Apache mailbox guide and Gmail mailbox setting . In other mailbox service settings, this forwarding mode is not easy to find. Gmail is the most convenient, which is recommended (no advertising). 3, Modify the homepage URL option in the edit page, homepage link of your account can be added in apache committer index page 4, Modify the GitHub account in the edit page, and an email will be sent to invite you to join the github.com/apache-commiiters group. Now, please learn from the way ASF works to do some basic preparation of ASF development. Fourth: To obtain write permission of the project Operation of the GitBox account link tool 1, Apache account authorization According to the prompt, the OAuth protocol of Apache account is authorized to login. 2, Github account authorization According to the prompt, the OAuth protocol of Github account is authorized to login. 3, Set up GitHub account in github.com, two-factors authorization (2FA) 1) install \"Google Authenticator\" app on your cell phone 2), Following the authorized GitHub 2FA wiki , you can operation step by step . In the two-factors authorization authentication (2. Scan this barcode with your app.) page, it is not recommended to select a two-dimensional code with a cell phone, because some of the cell phones will not be able to scan. Please open the cell phone \"Google Authenticator\" app, click \"+\" to select \"input the secret key\": write the GitHub account in the account name input box. In your \"secret key\" input box, write the text of the \"enter this text code\" link in the open web page. After clicking \"add\" in app, 6 digit dynamic will be generated for this account. Write the 6 digit number to the text box in the web page, and then click \"Enable\". In this way, the 2fa is set successfully. 3), logout and login to Github again, and one more step will appear after entering user name and password. Fill in the 6 digit number dynamic password generated by the app 4),It will take about half an hour, and you will be notified by mail that you have joined the XX project-committers developer group. You can also check it in the [apache teams] (https://github.com/orgs/apache/teams) page yourself. 5), After the 2fa has been submitted, you will have the permission check problem for the cloned projects. The solution is one of below two: A. Apply for Access Token When access token is generated on GitHub, the token where the instruction line needs a password is pasted. Refer to website referenced link one and referenced link two B. switch to SSH ssh-keygen then paste the content in the pub file into GitHub. Note : ensure that GitHub's 2fa is \"enabled\". When you set 2fa to \"off\", it will be delisted by the corresponding Apache committer write permission group until you set it up again. Fifth: other The Apache way See wiki . The community is more important than the code If not discussed in the community (mailing list), just as it did not happen. Add your name Please update Dubbo incubator status page to add your name. See this guide for instructions. Please update Dubbo offiical website to update your name. A small benefit Jetbrains company gives Apache committers a small benefit, which is free to use IDEA's full series products. The specific address is: https://www.jetbrains.com/shop/eform/apache?Product=ALL Reference wiki https://www.apache.org/dev/new-committers-guide.html","title":"Apache Committer Guide"},{"location":"developers/committer-guide/new-committer-guide_dev/#apache-committer-guide","text":"","title":"Apache Committer Guide"},{"location":"developers/committer-guide/new-committer-guide_dev/#first-how-to-become-a-committer","text":"","title":"First: How to become a committer"},{"location":"developers/committer-guide/new-committer-guide_dev/#initial-committers-at-the-project-incubator-stage","text":"At the project incubator stage, there will be an initial committers list in the proposal of the incubator project. Confirm that you are one of the initial committers. After the vote is passed in the Apache incubator community, these committers can start preparing their account. See incubator wiki for details.","title":"Initial committers at the project incubator stage"},{"location":"developers/committer-guide/new-committer-guide_dev/#the-active-contributor-is-elected-as-a-committer","text":"At the late development stage, an active contributor can be elected as a committer. See how to become a committer","title":"The active contributor is elected as a committer"},{"location":"developers/committer-guide/new-committer-guide_dev/#second-the-individual-contributor-signs-icla","text":"","title":"Second: The individual contributor signs ICLA"},{"location":"developers/committer-guide/new-committer-guide_dev/#1-apache-id","text":"Choose a Apache ID not in the apache committers list page .","title":"1, Apache ID"},{"location":"developers/committer-guide/new-committer-guide_dev/#2-individual-contributor-license-agreement-icla","text":"Download the ICLA template . After filling the icla.pdf with personal information correctly, print, sign, scan, and send it in mail as an attachment to the secretary secretary@apache.org, the secretary will help to create the Apache user ID. At the same time, a your-id@apache.org mailbox will be created. You can see if the user has been created on the [apache committers list page (http://people.apache.org/committer-index.html).","title":"2, Individual Contributor License Agreement  (ICLA):"},{"location":"developers/committer-guide/new-committer-guide_dev/#third-join-the-apache-developer-group","text":"1, login via the Apache account tool , when you login at the first time, you can select the \"Change password?\" checkbox to get the initial password. Then the initial password will be sent to the forward mailbox (the developer mail recorded in the project incubator proposal) 2, about Apache mailbox: does not have its own mail content storage server. It needs to borrow the mail content storage and mail sending functions of other mail providers. In many voting sessions, Apache mailbox is recommended. There is a question about how to configure the apache.org mailbox forwarding function using other mailboxes. 1) inbox: to receive mails that sent to youer-id@apache.org mailbox. The forward mailbox configured in the Apache account tool in the first step can use the forward mailbox to pick up incoming mail. 2) the Outbox: emails sent out will show the sender as your-id@apache.org account. Please refer to: set up Apache mailbox guide and Gmail mailbox setting . In other mailbox service settings, this forwarding mode is not easy to find. Gmail is the most convenient, which is recommended (no advertising). 3, Modify the homepage URL option in the edit page, homepage link of your account can be added in apache committer index page 4, Modify the GitHub account in the edit page, and an email will be sent to invite you to join the github.com/apache-commiiters group. Now, please learn from the way ASF works to do some basic preparation of ASF development.","title":"Third: Join The Apache Developer Group"},{"location":"developers/committer-guide/new-committer-guide_dev/#fourth-to-obtain-write-permission-of-the-project","text":"Operation of the GitBox account link tool","title":"Fourth: To obtain write permission of the project"},{"location":"developers/committer-guide/new-committer-guide_dev/#1-apache-account-authorization","text":"According to the prompt, the OAuth protocol of Apache account is authorized to login.","title":"1, Apache account authorization"},{"location":"developers/committer-guide/new-committer-guide_dev/#2-github-account-authorization","text":"According to the prompt, the OAuth protocol of Github account is authorized to login.","title":"2, Github account authorization"},{"location":"developers/committer-guide/new-committer-guide_dev/#3-set-up-github-account-in-githubcom-two-factors-authorization-2fa","text":"1) install \"Google Authenticator\" app on your cell phone 2), Following the authorized GitHub 2FA wiki , you can operation step by step . In the two-factors authorization authentication (2. Scan this barcode with your app.) page, it is not recommended to select a two-dimensional code with a cell phone, because some of the cell phones will not be able to scan. Please open the cell phone \"Google Authenticator\" app, click \"+\" to select \"input the secret key\": write the GitHub account in the account name input box. In your \"secret key\" input box, write the text of the \"enter this text code\" link in the open web page. After clicking \"add\" in app, 6 digit dynamic will be generated for this account. Write the 6 digit number to the text box in the web page, and then click \"Enable\". In this way, the 2fa is set successfully. 3), logout and login to Github again, and one more step will appear after entering user name and password. Fill in the 6 digit number dynamic password generated by the app 4),It will take about half an hour, and you will be notified by mail that you have joined the XX project-committers developer group. You can also check it in the [apache teams] (https://github.com/orgs/apache/teams) page yourself. 5), After the 2fa has been submitted, you will have the permission check problem for the cloned projects. The solution is one of below two: A. Apply for Access Token When access token is generated on GitHub, the token where the instruction line needs a password is pasted. Refer to website referenced link one and referenced link two B. switch to SSH ssh-keygen then paste the content in the pub file into GitHub. Note : ensure that GitHub's 2fa is \"enabled\". When you set 2fa to \"off\", it will be delisted by the corresponding Apache committer write permission group until you set it up again.","title":"3, Set up GitHub account in github.com, two-factors authorization (2FA)"},{"location":"developers/committer-guide/new-committer-guide_dev/#fifth-other","text":"","title":"Fifth: other"},{"location":"developers/committer-guide/new-committer-guide_dev/#the-apache-way","text":"See wiki . The community is more important than the code If not discussed in the community (mailing list), just as it did not happen.","title":"The Apache way"},{"location":"developers/committer-guide/new-committer-guide_dev/#add-your-name","text":"Please update Dubbo incubator status page to add your name. See this guide for instructions. Please update Dubbo offiical website to update your name.","title":"Add your name"},{"location":"developers/committer-guide/new-committer-guide_dev/#a-small-benefit","text":"Jetbrains company gives Apache committers a small benefit, which is free to use IDEA's full series products. The specific address is: https://www.jetbrains.com/shop/eform/apache?Product=ALL","title":"A small benefit"},{"location":"developers/committer-guide/new-committer-guide_dev/#reference-wiki","text":"https://www.apache.org/dev/new-committers-guide.html","title":"Reference wiki"},{"location":"developers/committer-guide/release-guide_dev/","text":"Understanding the Apache Release Cycle In general, Source Release is the key and the required content of Apache. But Binary Release is optional, Dubbo can choose whether to release binary packages to the Apache repository or to the Maven central repository. Please refer to the following links for more information on ASF's release guide: Apache Release Guide Apache Release Policy Maven Release Info Preparation of Local Building Environment Mainly including the related preparation of signature utilities and Maven repository certification Install GPG,refer to https://www.gnupg.org/download/index.html For example, in Mac OS sh $ brew install gpg $ gpg --version #check version,should be 2.x Generate the key with GPG Generate the key according to the prompt ```shell $ gpg2 --full-gen-key gpg (GnuPG) 2.0.12; Copyright (C) 2009 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) Your selection? 1 RSA keys may be between 1024 and 4096 bits long. What keysize do you want? (2048) 4096 Requested keysize is 4096 bits Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y GnuPG needs to construct a user ID to identify your key. Real name: Robert Burrell Donkin Email address: rdonkin@apache.org Comment: CODE SIGNING KEY You selected this USER-ID: \"Robert Burrell Donkin (CODE SIGNING KEY) \" Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O You need a Passphrase to protect your secret key. # enter the password, which will be used frequently when packaging. ``` View key id ```sh $ gpg --list-keys pub rsa4096/28681CB1 2018-04-26 # 28681CB1 is the key id uid [ultimate] liujun (apache-dubbo) sub rsa4096/D3D6984B 2018-04-26 ##### Note: Different diaplay for different version. $ gpg --list-keys pub rsa4096 2018-11-12 [SC] 63AAE9838F4A303E40BAF5FEA3A1CA7A5D4A3981 # Last 8 character(5D4A3981) as key id\uff0cit will be used when send public key to keyserver uid [ \u7edd\u5bf9 ] Victory Cao (CODE SIGNING KEY) sub rsa4096 2018-11-12 [E] send public key to keyserver via key id $ gpg --keyserver pgpkeys.mit.edu --send-key 28681CB1 Here pgpkeys.mit.edu is a random selection of keyserver. Any key server from the list https://sks-keyservers.net/status/ is acceptable because they are automatically synchronized. ``` If there are multiple public keys\uff0cyou can set the default key ~/.gnupg/gpg.conf ```proper If you have more than 1 secret key in your keyring, you may want to uncomment the following option and set your preferred keyid. default-key 28681CB1 ``` If there are multiple public keys, you can also delete unuseful key\uff1a ```sh Delete the private key first, then delete the public key. $ gpg --yes --delete-secret-keys shenglicao2@gmail.com ### indicate email address $ gpg --delete-keys 1808C6444C781C0AEA0AAD4C4D6A8007D20DB8A4 ``` config your fingerprint. sh ### Show fingerprint info\uff1a $ gpg --fingerprint liujun pub rsa4096 2019-10-17 [SC] 1376 A2FF 67E4 C477 5739 09BD 7DB6 8550 D366 E4C0 uid [ultimate] liujun (CODE SIGNING KEY) liujun@apache.org sub rsa4096 2019-10-17 [E] Save the fingerprint, as above 1376 A2FF 67E4 C477 5739 09BD 7DB6 8550 D366 E4C0 , to the field OpenPGP Public Key Primary Fingerprint in you profile page at https://id.apache.org. Set up Apache central repository. The parent pom of Dubbo project is apache pom xml parent groupId org.apache /groupId artifactId apache /artifactId version 19 /version /parent Add the following contents to .m2/settings.xml Enter the passwords after encrypting by maven-encryption-plugin xml settings ... servers !-- To publish a snapshot of some part of Maven -- server id apache.snapshots.https /id username !-- YOUR APACHE LDAP USERNAME -- /username password !-- YOUR APACHE LDAP PASSWORD (encrypted) -- /password /server !-- To stage a release of some part of Maven -- server id apache.releases.https /id username !-- YOUR APACHE LDAP USERNAME -- /username password !-- YOUR APACHE LDAP PASSWORD (encrypted) -- /password /server ... !-- gpg passphrase used when generate key -- server id gpg.passphrase /id passphrase !-- yourKeyPassword -- /passphrase /server /servers /settings Pack Upload Pull the new branch from the master branch as the release branch. If you want to release the ${release_version} version now, pull the new branch ${release_version}-release from 2.6.x. Then the modifications and taggings related to ${release_version} Release Candidates are applied to ${release_version}-release branch, and is merged into the master branch after the final release. First of all, verify that the maven component packing, source packing, signature, etc are working properly on the ${release_version}-release branch. shell $ mvn clean install -Papache-release $ mvn deploy This push the snapshot package to the maven central repository. ~~Release with maven-release-plugin~~ ( Deprecated \uff0cSkip this step and refer to next step) ~~verify with dryRun~~ shell $ mvn release:prepare -Prelease -Darguments=\"-Dmaven.test.skip=true\" -DautoVersionSubmodules=true -Dusername=YOUR GITHUB ID -DdryRun=true ~~After verification, run release:prepare~~ shell $ mvn release:clean $ mvn release:prepare -Prelease -Darguments=\"-Dmaven.test.skip=true\" -DautoVersionSubmodules=true -Dusername=YOUR GITHUB ID -DpushChanges=false If you are promted to input password for pushing to GitHub (basically including adding new commits and tags), do not input your login password of GitHub. Use Personal access tokens instead. You can go to https://github.com/settings/profile, click Developer settings - Personal access tokens , and generate a new token if not. Please refer to this guide for more infomation. you need to choose the release artifactId, next artifactId and the release tag, the default tag is dubbo-parent-xxxx, you need to change it to dubbo-xxxx After executing the above commands, you will find that: 1. source-release.zip and bin-release.zip are generated under dubbo-distribution directory, please unzip it and check the file structure 2. -DpushChanges=false tells maven not to push the commits and tags to the remote repostiroy. If not specified, the version tag will be pushed to github repository, you will see a commit called [maven-release-plugin] prepare release dubbo-x.x.x added. 3. The branch version is upgraded to ${release_version+1}-SNAPSHOT automatically. If -DpushChanges=true is specified, the modifications will be pushed to the remote repository, you will see a commit called [maven-release-plugin] prepare for next development iteration added. If -DpushChanges=false is specified, you will have to manually push the commit to remote repository before go to next step. ~~Run release:perform~~ shell $ mvn release:perform -Prelease -Darguments=\"-Dmaven.test.skip=true\" -DautoVersionSubmodules=true -Dusername=YOUR GITHUB ID Maven will download the source code from the tag you just pushed, compile it, and deploy to remote maven repsoitry in staging state. use mvn deploy to deploy Requirement\uff1amaven 3.5+ modify pom version from 2.7.x-SNAPSHOT to 2.7.x . You can search the full-text in the dubbo project. $ mvn clean install -Prelease $ mvn deploy -Prelease -DskipTests After this, maven will deploy jar to remote maven repsoitry in staging state. Note When you deploy the package into repository, it will be interrupted for network. So you must restart to desploy. The problem is that missing package occurred many times at deploying. So you should check the quantity of package, especially parent package. Prepare Apache Release Prepare the svn local environment (Apache hosting the release content of project by svn) Checkout dubbo to local directory shell $ svn checkout https://dist.apache.org/repos/dist/dev/dubbo Assume that the local directory is ~/apache/dubbo The current release version is ${release_version}, new directory shell $ cd ~/apache/dubbo # dubbo svn root directory $ mkdir ${release_version} Add public key to KEYS file if you are the first time to be a release manager. KEYS is mainly used to allow people who participate in the voting to be imported locally to verify the correctness of the sign. shell $ (gpg --list-sigs your name gpg --armor --export your name ) KEYS For more information on how to get your key id, please refer to this guide Copy the source.zip package from the Dubbo root directory to the svn local repository dubbo/${release_version} Generate sha512 sign For source-release.zip shell $ shasum -a 512 apache-dubbo-${release_version}-source-release.zip apache-dubbo-${release_version}-source-release.zip.sha512 For bin-release.zip Please add -b paramter when generating sha512 for bin-release.zip, which indicates it is a binary file. shell $ shasum -b -a 512 apache-dubbo-${release_version}-bin-release.zip apache-dubbo-${release_version}-bin-release.zip.sha512 You should generate something like this: b8f13d1df6d6c9a1facc72fafc00b2d22bea1e600517c507467d8fca2f776a7a3877101742da53114bfa629ca5b941eb4d9ef989de43f0833e2a794e7ccf5c8a *apache-dubbo-spring-boot-project-2.7.0-bin-release.zip Note there is a * sign before the file name. If the binary release is accompanied with the source release. Run the following command in the dubbo-distribution module: shell $ mvn install Go to target directory, copy bin-release.zip and bin-release.zip.asc to svn local repository dubbo/${release_version}, and refer to step 6 to generate sha512 sign. Commit to Apache svn shell $ svn status $ svn commit -m 'prepare for ${release_version} RC1' Close the maven staging repository This step is required when prepare for a 2.7.0+ release, where package name has been changed to org.apache. Before that, please make sure all the maven artifacts look good. Login to http://repository.apache.org, click the Staging repositories on the left bar, search with keyword Dubbo, and you will see a list of repositories. Find the one you just uploaded, and then click the close button in the top area. This will do some sannity check, such as gpg signature check, and checksum check. After that, a link will be shown in the summary tab in the bottom. Please copy that link, it will be used for release vote. The link should look like this: https://repository.apache.org/content/repositories/orgapachedubbo-1015. Please be aware that it may fail when you close the repository, this is normally due to network issues, please try again if it failed. You can confirm it by clicking the Activiey tab next to Summary . Verify Release Candidates A full check list can be found here The verification link includes but is not limited to the following contents and forms: Check signatures and hashes are good check the sha512 sum $ shasum -c apache-dubbo-${release_version}-source-release.zip.sha512 $ shasum -c apache-dubbo-${release_version}-bin-release.zip.sha512 check the gpg signarure If it's your first time verify a release candidte, you should import public keys first. $ curl https://dist.apache.org/repos/dist/dev/dubbo/KEYS KEYS # download public keys to local directory $ gpg --import KEYS # import keys $ gpg \u2014edit-key liujun trust # type trust command ``` Now, you can verify signature with command ```sh gpg --verify apache-dubbo-2.6.3-source-release.zip.asc apache-dubbo-2.6.3-source-release.zip gpg --verify apache-dubbo-2.6.3-bin-release.zip.asc apache-dubbo-2.6.3-bin-release.zip ``` ### Check source release file content Unzip apache-dubbo-${release_version}-source-release.zip to the default directory and check the following: - DISCLAIMER exists - LICENSE and NOTICE exists and contents are good - All files and no binary files exist - All files has standard ASF License header - Can compile from source - All unit tests can pass ```sh mvn clean test # This will run all unit tests # you can also open rat and style plugin to check if every file meets requirements. mvn clean test -Drat.skip=false -Dcheckstyle.skip=false ``` - Release candidates match with corresponding tags, you can find tag link and hash in vote email. - check the version number in pom.xml are the same - check there are no extra files or directories in the source package, for example, no empty directories or useless log files. `diff -r rc_dir tag_dir` - check the top n tag commits, dive into the related files and check if the source package has the same changes ### check third party dependencies According to ASF policy, any [Category X](https://www.apache.org/legal/resolved.html#what-can-we-not-include-in-an-asf-project-category-x) dependency can not be included in ASF product, this includes common LGPL/GPL licensed dependencies. Even transitive dependencies are not allowed. Therefore we need to run the following command to ensure no such dependencies are included. ```sh mvn license:add-third-party -Dlicense.useMissingFile find . -name THIRD-PARTY.txt | xargs grep -E 'GPL|General Public License' | grep -v Apache | grep -v MIT | grep -v CDDL If one dependency is dual/multiple licensed, just choose the most permissive one. Check binary distribution file content Unzip apache-dubbo-${release_version}-bin-release.zip and check: Check signatures are good LICENSE and NOTICE exists and contents are good Note that if the binary distribution contains third party files, you may need to update LICENSE file by adding the 3rd party license files. If these dependency is Apache License 2.0, and it contains NOTICE file, you may also need to update NOTICE file as well. Release vote The voting just only one round: Dubbo community votes and sends the voting email to dev@dubbo.apache.org. After reviewing by community developers and winning 3 binding tickets that agree to release, you can go to the next stage of voting. The mail template for Apache Dubbo vote\uff1a Hello Dubbo Community, This is a call for vote to release Apache Dubbo version 2.7.2. The release candidates: https://dist.apache.org/repos/dist/dev/dubbo/2.7.2/ The staging repo: https://repository.apache.org/content/repositories/orgapachedubbo-1005 Git tag for the release: https://github.com/apache/dubbo/tree/dubbo-2.6.2 Hash for the release tag: afab04c53edab38d52275d2a198ea1aff7a4f41e Release Notes: https://github.com/apache/dubbo/releases/tag/untagged-4775c0a22c60fca55118 The artifacts have been signed with Key : 28681CB1, which can be found in the keys file: https://dist.apache.org/repos/dist/dev/dubbo/KEYS The vote will be open for at least 72 hours or until necessary number of votes are reached. Please vote accordingly: [ ] +1 approve [ ] +0 no opinion [ ] -1 disapprove with the reason Thanks, The Apache Dubbo Team The mail template to announce the vote result: We\u2019ve received 3 +1 binding votes and one +1 non-binding vote: +1 binding, Ian Luo +1 binding, Huxing Zhang +1 binding, Jun Liu +1 non-binding, Jerrick I will release this version today. Best regards, The Apache Dubbo Team Official Release When the release vote has passed, Add the release files to official release directory Remove the release files in dev directory Remove the the release file for the previous release under official release directory , which will be archived and can be found here Publish release notes on Github. Update the recommend dependency on Github to the latest version, also update the version in other place if necessary. Add the download link to official website http://dubbo.apache.org/en-us/blog/download.html, using the ASF mirror system. The latest release download link should be something like this . The download link for the previous release version should be changed like this . Please refer to the download page for more details. Make sure all the commits in the release branch are merged into master branch, and then remove the remote release branch. For example: git push origin --delete 2.7.0-release Send mail to dev@dubbo.apache.org , notify the community that the release is completed. The mail template to announce release: Hello Community, The Apache Dubbo team is pleased to announce that the 2.6.6 has just been released. Apache Dubbo\u2122 is a high-performance, java based, open source RPC framework. Dubbo offers three key functionalities, which include interface based remote call, fault tolerance load balancing, and automatic service registration discovery. Both the source release[1] and the maven binary release[2] are available now, you can also find the detailed release notes here[3]. If you have any usage questions, or have problems when upgrading or find any problems about enhancements included in this release, please don\u2019t hesitate to let us know by sending feedback to this mailing list or filing an issue on GitHub[4]. [1] http://dubbo.apache.org/en-us/blog/download.html [2] https://repo1.maven.org/maven2/org/apache/dubbo/dubbo [3] https://github.com/apache/dubbo/releases [4] https://github.com/apache/dubbo/issues Complete Maven Convenient Binary release repository.apache.org The permissions of the nexus repository have been applied, see jira \u3002 To release the maven artifacts, go to repository.apache.org , and choose the staging repository, click the release button. Wait for a moment and verify it at here , make sure your artifacts are there and correct. It will take some time to sync to maven central repository. You can verify it at here FAQ gpg: signing failed: Inappropriate ioctl for device If you've encoutered this error, try the following commands: export GPG_TTY=$(tty)","title":"Understanding the Apache Release Cycle"},{"location":"developers/committer-guide/release-guide_dev/#understanding-the-apache-release-cycle","text":"In general, Source Release is the key and the required content of Apache. But Binary Release is optional, Dubbo can choose whether to release binary packages to the Apache repository or to the Maven central repository. Please refer to the following links for more information on ASF's release guide: Apache Release Guide Apache Release Policy Maven Release Info","title":"Understanding the Apache Release Cycle"},{"location":"developers/committer-guide/release-guide_dev/#preparation-of-local-building-environment","text":"Mainly including the related preparation of signature utilities and Maven repository certification Install GPG,refer to https://www.gnupg.org/download/index.html For example, in Mac OS sh $ brew install gpg $ gpg --version #check version,should be 2.x Generate the key with GPG Generate the key according to the prompt ```shell $ gpg2 --full-gen-key gpg (GnuPG) 2.0.12; Copyright (C) 2009 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) Your selection? 1 RSA keys may be between 1024 and 4096 bits long. What keysize do you want? (2048) 4096 Requested keysize is 4096 bits Please specify how long the key should be valid. 0 = key does not expire = key expires in n days w = key expires in n weeks m = key expires in n months y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y GnuPG needs to construct a user ID to identify your key. Real name: Robert Burrell Donkin Email address: rdonkin@apache.org Comment: CODE SIGNING KEY You selected this USER-ID: \"Robert Burrell Donkin (CODE SIGNING KEY) \" Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O You need a Passphrase to protect your secret key. # enter the password, which will be used frequently when packaging. ``` View key id ```sh $ gpg --list-keys pub rsa4096/28681CB1 2018-04-26 # 28681CB1 is the key id uid [ultimate] liujun (apache-dubbo) sub rsa4096/D3D6984B 2018-04-26","title":"Preparation of Local Building Environment"},{"location":"developers/committer-guide/release-guide_dev/#note-different-diaplay-for-different-version","text":"$ gpg --list-keys pub rsa4096 2018-11-12 [SC] 63AAE9838F4A303E40BAF5FEA3A1CA7A5D4A3981 # Last 8 character(5D4A3981) as key id\uff0cit will be used when send public key to keyserver uid [ \u7edd\u5bf9 ] Victory Cao (CODE SIGNING KEY) sub rsa4096 2018-11-12 [E]","title":"##### Note: Different diaplay for different version."},{"location":"developers/committer-guide/release-guide_dev/#send-public-key-to-keyserver-via-key-id","text":"$ gpg --keyserver pgpkeys.mit.edu --send-key 28681CB1","title":"send public key to keyserver via key id"},{"location":"developers/committer-guide/release-guide_dev/#here-pgpkeysmitedu-is-a-random-selection-of-keyserver-any-key-server-from-the-list-httpssks-keyserversnetstatus-is-acceptable-because-they-are-automatically-synchronized","text":"``` If there are multiple public keys\uff0cyou can set the default key ~/.gnupg/gpg.conf ```proper","title":"Here pgpkeys.mit.edu is a random selection of keyserver. Any key server from the list https://sks-keyservers.net/status/ is acceptable because they are automatically synchronized."},{"location":"developers/committer-guide/release-guide_dev/#if-you-have-more-than-1-secret-key-in-your-keyring-you-may-want-to","text":"","title":"If you have more than 1 secret key in your keyring, you may want to"},{"location":"developers/committer-guide/release-guide_dev/#uncomment-the-following-option-and-set-your-preferred-keyid","text":"default-key 28681CB1 ``` If there are multiple public keys, you can also delete unuseful key\uff1a ```sh","title":"uncomment the following option and set your preferred keyid."},{"location":"developers/committer-guide/release-guide_dev/#delete-the-private-key-first-then-delete-the-public-key","text":"$ gpg --yes --delete-secret-keys shenglicao2@gmail.com ### indicate email address $ gpg --delete-keys 1808C6444C781C0AEA0AAD4C4D6A8007D20DB8A4 ``` config your fingerprint. sh ### Show fingerprint info\uff1a $ gpg --fingerprint liujun pub rsa4096 2019-10-17 [SC] 1376 A2FF 67E4 C477 5739 09BD 7DB6 8550 D366 E4C0 uid [ultimate] liujun (CODE SIGNING KEY) liujun@apache.org sub rsa4096 2019-10-17 [E] Save the fingerprint, as above 1376 A2FF 67E4 C477 5739 09BD 7DB6 8550 D366 E4C0 , to the field OpenPGP Public Key Primary Fingerprint in you profile page at https://id.apache.org. Set up Apache central repository. The parent pom of Dubbo project is apache pom xml parent groupId org.apache /groupId artifactId apache /artifactId version 19 /version /parent Add the following contents to .m2/settings.xml Enter the passwords after encrypting by maven-encryption-plugin xml settings ... servers !-- To publish a snapshot of some part of Maven -- server id apache.snapshots.https /id username !-- YOUR APACHE LDAP USERNAME -- /username password !-- YOUR APACHE LDAP PASSWORD (encrypted) -- /password /server !-- To stage a release of some part of Maven -- server id apache.releases.https /id username !-- YOUR APACHE LDAP USERNAME -- /username password !-- YOUR APACHE LDAP PASSWORD (encrypted) -- /password /server ... !-- gpg passphrase used when generate key -- server id gpg.passphrase /id passphrase !-- yourKeyPassword -- /passphrase /server /servers /settings","title":"Delete the private key first, then delete the public key."},{"location":"developers/committer-guide/release-guide_dev/#pack-upload","text":"Pull the new branch from the master branch as the release branch. If you want to release the ${release_version} version now, pull the new branch ${release_version}-release from 2.6.x. Then the modifications and taggings related to ${release_version} Release Candidates are applied to ${release_version}-release branch, and is merged into the master branch after the final release. First of all, verify that the maven component packing, source packing, signature, etc are working properly on the ${release_version}-release branch. shell $ mvn clean install -Papache-release $ mvn deploy This push the snapshot package to the maven central repository. ~~Release with maven-release-plugin~~ ( Deprecated \uff0cSkip this step and refer to next step) ~~verify with dryRun~~ shell $ mvn release:prepare -Prelease -Darguments=\"-Dmaven.test.skip=true\" -DautoVersionSubmodules=true -Dusername=YOUR GITHUB ID -DdryRun=true ~~After verification, run release:prepare~~ shell $ mvn release:clean $ mvn release:prepare -Prelease -Darguments=\"-Dmaven.test.skip=true\" -DautoVersionSubmodules=true -Dusername=YOUR GITHUB ID -DpushChanges=false If you are promted to input password for pushing to GitHub (basically including adding new commits and tags), do not input your login password of GitHub. Use Personal access tokens instead. You can go to https://github.com/settings/profile, click Developer settings - Personal access tokens , and generate a new token if not. Please refer to this guide for more infomation. you need to choose the release artifactId, next artifactId and the release tag, the default tag is dubbo-parent-xxxx, you need to change it to dubbo-xxxx After executing the above commands, you will find that: 1. source-release.zip and bin-release.zip are generated under dubbo-distribution directory, please unzip it and check the file structure 2. -DpushChanges=false tells maven not to push the commits and tags to the remote repostiroy. If not specified, the version tag will be pushed to github repository, you will see a commit called [maven-release-plugin] prepare release dubbo-x.x.x added. 3. The branch version is upgraded to ${release_version+1}-SNAPSHOT automatically. If -DpushChanges=true is specified, the modifications will be pushed to the remote repository, you will see a commit called [maven-release-plugin] prepare for next development iteration added. If -DpushChanges=false is specified, you will have to manually push the commit to remote repository before go to next step. ~~Run release:perform~~ shell $ mvn release:perform -Prelease -Darguments=\"-Dmaven.test.skip=true\" -DautoVersionSubmodules=true -Dusername=YOUR GITHUB ID Maven will download the source code from the tag you just pushed, compile it, and deploy to remote maven repsoitry in staging state.","title":"Pack &amp; Upload"},{"location":"developers/committer-guide/release-guide_dev/#use-mvn-deploy-to-deploy","text":"Requirement\uff1amaven 3.5+ modify pom version from 2.7.x-SNAPSHOT to 2.7.x . You can search the full-text in the dubbo project. $ mvn clean install -Prelease $ mvn deploy -Prelease -DskipTests After this, maven will deploy jar to remote maven repsoitry in staging state.","title":"use mvn deploy to deploy"},{"location":"developers/committer-guide/release-guide_dev/#note","text":"When you deploy the package into repository, it will be interrupted for network. So you must restart to desploy. The problem is that missing package occurred many times at deploying. So you should check the quantity of package, especially parent package.","title":"Note"},{"location":"developers/committer-guide/release-guide_dev/#prepare-apache-release","text":"Prepare the svn local environment (Apache hosting the release content of project by svn) Checkout dubbo to local directory shell $ svn checkout https://dist.apache.org/repos/dist/dev/dubbo Assume that the local directory is ~/apache/dubbo The current release version is ${release_version}, new directory shell $ cd ~/apache/dubbo # dubbo svn root directory $ mkdir ${release_version} Add public key to KEYS file if you are the first time to be a release manager. KEYS is mainly used to allow people who participate in the voting to be imported locally to verify the correctness of the sign. shell $ (gpg --list-sigs your name gpg --armor --export your name ) KEYS For more information on how to get your key id, please refer to this guide Copy the source.zip package from the Dubbo root directory to the svn local repository dubbo/${release_version} Generate sha512 sign For source-release.zip shell $ shasum -a 512 apache-dubbo-${release_version}-source-release.zip apache-dubbo-${release_version}-source-release.zip.sha512 For bin-release.zip Please add -b paramter when generating sha512 for bin-release.zip, which indicates it is a binary file. shell $ shasum -b -a 512 apache-dubbo-${release_version}-bin-release.zip apache-dubbo-${release_version}-bin-release.zip.sha512 You should generate something like this: b8f13d1df6d6c9a1facc72fafc00b2d22bea1e600517c507467d8fca2f776a7a3877101742da53114bfa629ca5b941eb4d9ef989de43f0833e2a794e7ccf5c8a *apache-dubbo-spring-boot-project-2.7.0-bin-release.zip Note there is a * sign before the file name. If the binary release is accompanied with the source release. Run the following command in the dubbo-distribution module: shell $ mvn install Go to target directory, copy bin-release.zip and bin-release.zip.asc to svn local repository dubbo/${release_version}, and refer to step 6 to generate sha512 sign. Commit to Apache svn shell $ svn status $ svn commit -m 'prepare for ${release_version} RC1' Close the maven staging repository This step is required when prepare for a 2.7.0+ release, where package name has been changed to org.apache. Before that, please make sure all the maven artifacts look good. Login to http://repository.apache.org, click the Staging repositories on the left bar, search with keyword Dubbo, and you will see a list of repositories. Find the one you just uploaded, and then click the close button in the top area. This will do some sannity check, such as gpg signature check, and checksum check. After that, a link will be shown in the summary tab in the bottom. Please copy that link, it will be used for release vote. The link should look like this: https://repository.apache.org/content/repositories/orgapachedubbo-1015. Please be aware that it may fail when you close the repository, this is normally due to network issues, please try again if it failed. You can confirm it by clicking the Activiey tab next to Summary .","title":"Prepare Apache Release"},{"location":"developers/committer-guide/release-guide_dev/#verify-release-candidates","text":"A full check list can be found here The verification link includes but is not limited to the following contents and forms:","title":"Verify Release Candidates"},{"location":"developers/committer-guide/release-guide_dev/#check-signatures-and-hashes-are-good","text":"","title":"Check signatures and hashes are good"},{"location":"developers/committer-guide/release-guide_dev/#check-the-sha512-sum","text":"$ shasum -c apache-dubbo-${release_version}-source-release.zip.sha512 $ shasum -c apache-dubbo-${release_version}-bin-release.zip.sha512","title":"check the sha512 sum"},{"location":"developers/committer-guide/release-guide_dev/#check-the-gpg-signarure","text":"If it's your first time verify a release candidte, you should import public keys first. $ curl https://dist.apache.org/repos/dist/dev/dubbo/KEYS KEYS # download public keys to local directory $ gpg --import KEYS # import keys $ gpg \u2014edit-key liujun trust # type trust command ``` Now, you can verify signature with command ```sh gpg --verify apache-dubbo-2.6.3-source-release.zip.asc apache-dubbo-2.6.3-source-release.zip gpg --verify apache-dubbo-2.6.3-bin-release.zip.asc apache-dubbo-2.6.3-bin-release.zip ``` ### Check source release file content Unzip apache-dubbo-${release_version}-source-release.zip to the default directory and check the following: - DISCLAIMER exists - LICENSE and NOTICE exists and contents are good - All files and no binary files exist - All files has standard ASF License header - Can compile from source - All unit tests can pass ```sh mvn clean test # This will run all unit tests # you can also open rat and style plugin to check if every file meets requirements. mvn clean test -Drat.skip=false -Dcheckstyle.skip=false ``` - Release candidates match with corresponding tags, you can find tag link and hash in vote email. - check the version number in pom.xml are the same - check there are no extra files or directories in the source package, for example, no empty directories or useless log files. `diff -r rc_dir tag_dir` - check the top n tag commits, dive into the related files and check if the source package has the same changes ### check third party dependencies According to ASF policy, any [Category X](https://www.apache.org/legal/resolved.html#what-can-we-not-include-in-an-asf-project-category-x) dependency can not be included in ASF product, this includes common LGPL/GPL licensed dependencies. Even transitive dependencies are not allowed. Therefore we need to run the following command to ensure no such dependencies are included. ```sh mvn license:add-third-party -Dlicense.useMissingFile find . -name THIRD-PARTY.txt | xargs grep -E 'GPL|General Public License' | grep -v Apache | grep -v MIT | grep -v CDDL If one dependency is dual/multiple licensed, just choose the most permissive one.","title":"check the gpg signarure"},{"location":"developers/committer-guide/release-guide_dev/#check-binary-distribution-file-content","text":"Unzip apache-dubbo-${release_version}-bin-release.zip and check: Check signatures are good LICENSE and NOTICE exists and contents are good Note that if the binary distribution contains third party files, you may need to update LICENSE file by adding the 3rd party license files. If these dependency is Apache License 2.0, and it contains NOTICE file, you may also need to update NOTICE file as well.","title":"Check binary distribution file content"},{"location":"developers/committer-guide/release-guide_dev/#release-vote","text":"The voting just only one round: Dubbo community votes and sends the voting email to dev@dubbo.apache.org. After reviewing by community developers and winning 3 binding tickets that agree to release, you can go to the next stage of voting. The mail template for Apache Dubbo vote\uff1a Hello Dubbo Community, This is a call for vote to release Apache Dubbo version 2.7.2. The release candidates: https://dist.apache.org/repos/dist/dev/dubbo/2.7.2/ The staging repo: https://repository.apache.org/content/repositories/orgapachedubbo-1005 Git tag for the release: https://github.com/apache/dubbo/tree/dubbo-2.6.2 Hash for the release tag: afab04c53edab38d52275d2a198ea1aff7a4f41e Release Notes: https://github.com/apache/dubbo/releases/tag/untagged-4775c0a22c60fca55118 The artifacts have been signed with Key : 28681CB1, which can be found in the keys file: https://dist.apache.org/repos/dist/dev/dubbo/KEYS The vote will be open for at least 72 hours or until necessary number of votes are reached. Please vote accordingly: [ ] +1 approve [ ] +0 no opinion [ ] -1 disapprove with the reason Thanks, The Apache Dubbo Team The mail template to announce the vote result: We\u2019ve received 3 +1 binding votes and one +1 non-binding vote: +1 binding, Ian Luo +1 binding, Huxing Zhang +1 binding, Jun Liu +1 non-binding, Jerrick I will release this version today. Best regards, The Apache Dubbo Team","title":"Release vote"},{"location":"developers/committer-guide/release-guide_dev/#official-release","text":"When the release vote has passed, Add the release files to official release directory Remove the release files in dev directory Remove the the release file for the previous release under official release directory , which will be archived and can be found here Publish release notes on Github. Update the recommend dependency on Github to the latest version, also update the version in other place if necessary. Add the download link to official website http://dubbo.apache.org/en-us/blog/download.html, using the ASF mirror system. The latest release download link should be something like this . The download link for the previous release version should be changed like this . Please refer to the download page for more details. Make sure all the commits in the release branch are merged into master branch, and then remove the remote release branch. For example: git push origin --delete 2.7.0-release Send mail to dev@dubbo.apache.org , notify the community that the release is completed. The mail template to announce release: Hello Community, The Apache Dubbo team is pleased to announce that the 2.6.6 has just been released. Apache Dubbo\u2122 is a high-performance, java based, open source RPC framework. Dubbo offers three key functionalities, which include interface based remote call, fault tolerance load balancing, and automatic service registration discovery. Both the source release[1] and the maven binary release[2] are available now, you can also find the detailed release notes here[3]. If you have any usage questions, or have problems when upgrading or find any problems about enhancements included in this release, please don\u2019t hesitate to let us know by sending feedback to this mailing list or filing an issue on GitHub[4]. [1] http://dubbo.apache.org/en-us/blog/download.html [2] https://repo1.maven.org/maven2/org/apache/dubbo/dubbo [3] https://github.com/apache/dubbo/releases [4] https://github.com/apache/dubbo/issues","title":"Official Release"},{"location":"developers/committer-guide/release-guide_dev/#complete-maven-convenient-binary-release","text":"repository.apache.org The permissions of the nexus repository have been applied, see jira \u3002 To release the maven artifacts, go to repository.apache.org , and choose the staging repository, click the release button. Wait for a moment and verify it at here , make sure your artifacts are there and correct. It will take some time to sync to maven central repository. You can verify it at here","title":"Complete Maven Convenient Binary release"},{"location":"developers/committer-guide/release-guide_dev/#faq","text":"","title":"FAQ"},{"location":"developers/committer-guide/release-guide_dev/#gpg-signing-failed-inappropriate-ioctl-for-device","text":"If you've encoutered this error, try the following commands: export GPG_TTY=$(tty)","title":"gpg: signing failed: Inappropriate ioctl for device"},{"location":"developers/committer-guide/website-guide_dev/","text":"Website Guide The website repository of Apache Dubbo is https://github.com/apache/dubbo-website After building the website, it'll be published to dubbo.apache.org automatically, you can also trigger it manually via https://selfserve.apache.org (need to login with Apache account)","title":"Website Guide"},{"location":"developers/committer-guide/website-guide_dev/#website-guide","text":"The website repository of Apache Dubbo is https://github.com/apache/dubbo-website After building the website, it'll be published to dubbo.apache.org automatically, you can also trigger it manually via https://selfserve.apache.org (need to login with Apache account)","title":"Website Guide"},{"location":"developers/contributor-guide/become-a-committer_dev/","text":"How to become a Dubbo committer Anyone can be a contributor to an Apache project. Being a contributor simply means that you take an interest in the project and contribute in some way, ranging from asking sensible questions (which documents the project and provides feedback to developers) through to providing new features as patches. If you become a valuable contributor to the project you may well be invited to become a committer. Committer is a term used at the ASF to signify someone who is committed to a particular project. It brings with it the privilege of write access to the project repository and resources. In Dubbo community, if a committers who have earned even more merit, can be invited to be a part of the Project Management Committee (PMC). One thing that is sometimes hard to understand when you are new to the open development process used at the ASF, is that we value the community more than the code. A strong and healthy community will be respectful and be a fun and rewarding place. More importantly, a diverse and healthy community can continue to support the code over the longer term, even as individual companies come and go from the field. More details could be found here . What can I contribute? Please refer to the new contributor guide .","title":"How to become a Dubbo committer"},{"location":"developers/contributor-guide/become-a-committer_dev/#how-to-become-a-dubbo-committer","text":"Anyone can be a contributor to an Apache project. Being a contributor simply means that you take an interest in the project and contribute in some way, ranging from asking sensible questions (which documents the project and provides feedback to developers) through to providing new features as patches. If you become a valuable contributor to the project you may well be invited to become a committer. Committer is a term used at the ASF to signify someone who is committed to a particular project. It brings with it the privilege of write access to the project repository and resources. In Dubbo community, if a committers who have earned even more merit, can be invited to be a part of the Project Management Committee (PMC). One thing that is sometimes hard to understand when you are new to the open development process used at the ASF, is that we value the community more than the code. A strong and healthy community will be respectful and be a fun and rewarding place. More importantly, a diverse and healthy community can continue to support the code over the longer term, even as individual companies come and go from the field. More details could be found here .","title":"How to become a Dubbo committer"},{"location":"developers/contributor-guide/become-a-committer_dev/#what-can-i-contribute","text":"Please refer to the new contributor guide .","title":"What can I contribute?"},{"location":"developers/contributor-guide/cla-signing-guide_dev/","text":"CLA Signing Guide You are required to sign the Apache ICLA under the following condition: * You have made lots of contribution to Dubbo before Dubbo get donated to Apache, and you haven't sign the Alibaba-CLA before. * You have made lots of contribution to Dubbo, and you are invited to become committer of Dubbo, and you have not signed Alibaba-CLA or Apache ICLA before. Steps Download this pdf Fill in the necessary blanks Print it out Sign the printed file Scan it Send an email to secretary@apache.org and cc private@dubbo.apache.org: entitled with \"ICLA submission\" please also provide the link to your github account in the email body remember to add you ICLA as attachment. Explanation to the fields Mailing address: Your company address in English is preferred. preferred apache id(s): if you are invited to become committers, you have to choose one apache id, otherwise you can leave it blank. notify project: Dubbo (This means Dubbo is the project who notifies you to sign the ICLA)","title":"CLA Signing Guide"},{"location":"developers/contributor-guide/cla-signing-guide_dev/#cla-signing-guide","text":"You are required to sign the Apache ICLA under the following condition: * You have made lots of contribution to Dubbo before Dubbo get donated to Apache, and you haven't sign the Alibaba-CLA before. * You have made lots of contribution to Dubbo, and you are invited to become committer of Dubbo, and you have not signed Alibaba-CLA or Apache ICLA before.","title":"CLA Signing Guide"},{"location":"developers/contributor-guide/cla-signing-guide_dev/#steps","text":"Download this pdf Fill in the necessary blanks Print it out Sign the printed file Scan it Send an email to secretary@apache.org and cc private@dubbo.apache.org: entitled with \"ICLA submission\" please also provide the link to your github account in the email body remember to add you ICLA as attachment.","title":"Steps"},{"location":"developers/contributor-guide/cla-signing-guide_dev/#explanation-to-the-fields","text":"Mailing address: Your company address in English is preferred. preferred apache id(s): if you are invited to become committers, you have to choose one apache id, otherwise you can leave it blank. notify project: Dubbo (This means Dubbo is the project who notifies you to sign the ICLA)","title":"Explanation to the fields"},{"location":"developers/contributor-guide/dubbo-extension-guide_dev/","text":"Extension guide Dubbo Use microkernel + plugin design pattern. Microkernel is only responsible for assembling plugins, the functions of Dubbo are implemented by extension points(plugins), which means that all functions of Dubbo can be replaced by user customized extension. Dubbo Ecosystem We recommend you to put extension to Dubbo ecosystem . Using this pattern will keep the core repository cleaner and decrease the maintains work. With less code also speed up core repository build process. Dependency Implement your own Dubbo extension, in general is just dependence on API jar correspond to what you want. For example: dependency groupId org.apache.dubbo /groupId artifactId dubbo-serialization-api /artifactId version ${dubbo.version} /version /dependency Src Guide Usually, implement special extension, just need reference the Developer Guide docs. Implement necessary interface and adapt extension to dubbo. Besides, some others should be considered: 1. Well tested. You should write unit test and mock test to eliminate potential bugs. 2. No warning, if some warning cannot to avoid, use @SuppressWarnings to suppress it, but do not abuse it. 3. README. Add necessary readme to show how to use your extension, and something to take notice. 4. License. Make sure of use Apache License 2.0. Notify the Community Commit your code to GitHub . Join the mail list (recommended). HowTo Send email to dev@incubator.dubbo.apache.org to notify the community Usually, after sending email, community will discuss your extension, and Administrators of dubbo group will contact you for transfer project to dubbo ecosystem. Transfer Project to Dubbo Group Administrators of dubbo group will ask you, grant your project owner to dubbo. Administrators of dubbo group will create a new project under dubbo group and invite you join the project. Once you accept the invitation, you can transfer your project to new project under dubbo group. Existing members of dubbo group will do the code review. After that you may make some improvement to code.","title":"Extension guide"},{"location":"developers/contributor-guide/dubbo-extension-guide_dev/#extension-guide","text":"Dubbo Use microkernel + plugin design pattern. Microkernel is only responsible for assembling plugins, the functions of Dubbo are implemented by extension points(plugins), which means that all functions of Dubbo can be replaced by user customized extension.","title":"Extension guide"},{"location":"developers/contributor-guide/dubbo-extension-guide_dev/#dubbo-ecosystem","text":"We recommend you to put extension to Dubbo ecosystem . Using this pattern will keep the core repository cleaner and decrease the maintains work. With less code also speed up core repository build process.","title":"Dubbo Ecosystem"},{"location":"developers/contributor-guide/dubbo-extension-guide_dev/#dependency","text":"Implement your own Dubbo extension, in general is just dependence on API jar correspond to what you want. For example: dependency groupId org.apache.dubbo /groupId artifactId dubbo-serialization-api /artifactId version ${dubbo.version} /version /dependency","title":"Dependency"},{"location":"developers/contributor-guide/dubbo-extension-guide_dev/#src-guide","text":"Usually, implement special extension, just need reference the Developer Guide docs. Implement necessary interface and adapt extension to dubbo. Besides, some others should be considered: 1. Well tested. You should write unit test and mock test to eliminate potential bugs. 2. No warning, if some warning cannot to avoid, use @SuppressWarnings to suppress it, but do not abuse it. 3. README. Add necessary readme to show how to use your extension, and something to take notice. 4. License. Make sure of use Apache License 2.0.","title":"Src Guide"},{"location":"developers/contributor-guide/dubbo-extension-guide_dev/#notify-the-community","text":"Commit your code to GitHub . Join the mail list (recommended). HowTo Send email to dev@incubator.dubbo.apache.org to notify the community Usually, after sending email, community will discuss your extension, and Administrators of dubbo group will contact you for transfer project to dubbo ecosystem.","title":"Notify the Community"},{"location":"developers/contributor-guide/dubbo-extension-guide_dev/#transfer-project-to-dubbo-group","text":"Administrators of dubbo group will ask you, grant your project owner to dubbo. Administrators of dubbo group will create a new project under dubbo group and invite you join the project. Once you accept the invitation, you can transfer your project to new project under dubbo group. Existing members of dubbo group will do the code review. After that you may make some improvement to code.","title":"Transfer Project to Dubbo Group"},{"location":"developers/contributor-guide/mailing-list-subscription-guide_dev/","text":"Mailing list subscription guide The Dubbo developer mailing list (dev@dubbo.apache.org) for Apache Incubator has been established, please feel free to subscribe and refer to [^1] for more details. You can also view the archive of the mailing list Here is a brief guide specific to Dubbo: Send an email to dev-subscribe@dubbo.apache.org, you can have empty subject and empty content. You will receive an email with the following content: from: dev-help@dubbo.apache.org reply-to: dev-sc.xxxxxxx.xxxxxxxx-hello=example.com@dubbo.apache.org to: hello@example.com date: Sat, Feb 24, 2018 at 3:12 PM subject: confirm subscribe to dev@dubbo.apache.org mailed-by: apache.org Hi! This is the ezmlm program. I'm managing the dev@dubbo.apache.org mailing list. I'm working for my owner, who can be reached at dev-owner@dubbo.apache.org. To confirm that you would like hello@example.com added to the dev mailing list, please send a short reply to this address: dev-sc.xxxxxxx.xxxxxxxx-hello=example.com@dubbo.apache.org Usually, this happens when you just hit the reply button. If this does not work, simply copy the address and paste it into the To: field of a new message. or click here: mailto:dev-sc.xxxxxxx.xxxxxxxx-hello=example.com@dubbo.apache.org ... Reply the email directly, you can have empty subject and empty content. You will receive an email with the following content: from: dev-help@dubbo.apache.org to: hello@example.com date: Sat, Feb 24, 2018 at 3:14 PM subject: WELCOME to dev@dubbo.apache.org mailed-by: apache.org Hi! This is the ezmlm program. I'm managing the dev@dubbo.apache.org mailing list. I'm working for my owner, who can be reached at dev-owner@dubbo.apache.org. Acknowledgment: I have added the address hello@example.com to the dev mailing list. Welcome to dev@dubbo.apache.org! Please save this message so that you know the address you are subscribed under, in case you later want to unsubscribe or change your subscription address. ... After that, you will receive any email that is posted to this mailing list. If you have any further questions, just send email to dev@dubbo.apache.org and hopefully someone will answer your questions. If you want to unsubscribe, just send an email to dev-unsubscribe@dubbo.apache.org, and follow the steps once you get an reply. Note that both dev@dubbo.apache.org and dev@dubbo.apache.org should work, you can pick any of it. [^1] http://apache.org/foundation/mailinglists.html#subscribing","title":"Mailing list subscription guide"},{"location":"developers/contributor-guide/mailing-list-subscription-guide_dev/#mailing-list-subscription-guide","text":"The Dubbo developer mailing list (dev@dubbo.apache.org) for Apache Incubator has been established, please feel free to subscribe and refer to [^1] for more details. You can also view the archive of the mailing list Here is a brief guide specific to Dubbo: Send an email to dev-subscribe@dubbo.apache.org, you can have empty subject and empty content. You will receive an email with the following content: from: dev-help@dubbo.apache.org reply-to: dev-sc.xxxxxxx.xxxxxxxx-hello=example.com@dubbo.apache.org to: hello@example.com date: Sat, Feb 24, 2018 at 3:12 PM subject: confirm subscribe to dev@dubbo.apache.org mailed-by: apache.org Hi! This is the ezmlm program. I'm managing the dev@dubbo.apache.org mailing list. I'm working for my owner, who can be reached at dev-owner@dubbo.apache.org. To confirm that you would like hello@example.com added to the dev mailing list, please send a short reply to this address: dev-sc.xxxxxxx.xxxxxxxx-hello=example.com@dubbo.apache.org Usually, this happens when you just hit the reply button. If this does not work, simply copy the address and paste it into the To: field of a new message. or click here: mailto:dev-sc.xxxxxxx.xxxxxxxx-hello=example.com@dubbo.apache.org ... Reply the email directly, you can have empty subject and empty content. You will receive an email with the following content: from: dev-help@dubbo.apache.org to: hello@example.com date: Sat, Feb 24, 2018 at 3:14 PM subject: WELCOME to dev@dubbo.apache.org mailed-by: apache.org Hi! This is the ezmlm program. I'm managing the dev@dubbo.apache.org mailing list. I'm working for my owner, who can be reached at dev-owner@dubbo.apache.org. Acknowledgment: I have added the address hello@example.com to the dev mailing list. Welcome to dev@dubbo.apache.org! Please save this message so that you know the address you are subscribed under, in case you later want to unsubscribe or change your subscription address. ... After that, you will receive any email that is posted to this mailing list. If you have any further questions, just send email to dev@dubbo.apache.org and hopefully someone will answer your questions. If you want to unsubscribe, just send an email to dev-unsubscribe@dubbo.apache.org, and follow the steps once you get an reply. Note that both dev@dubbo.apache.org and dev@dubbo.apache.org should work, you can pick any of it. [^1] http://apache.org/foundation/mailinglists.html#subscribing","title":"Mailing list subscription guide"},{"location":"developers/contributor-guide/new-contributor-guide_dev/","text":"New contributor guide This is a guide for new comers who wants to contribute to Dubbo. Subscribe to the mailing list The mailing list is the recommended way for discussing almost anything that related to Dubbo. Please refer to this issue for detailed documentation on how to subscribe. To subscribe to the following mailing list, please refer to Mailing list subscription guide dev@dubbo.apache.org: the develop mailing list, you can ask question here if you have encountered any problem when using or developing Dubbo. commits@dubbo.apache.org: all the commits will be sent to this mailing list. You can subscribe to it if you are interested in Dubbo's development. issues@dubbo.apache.org: all the JIRA issues and updates will be sent to this mailing list. The Dubbo community has decided to use github issues rather than JIRA issues, therefore it is expected that most of the issues will be tracked by github issues. The JIRA issues are used to track ASF related issues. Reporting issue You can always reporting an issue to Dubbo via Github Issues . If you are reporting bugs, please refer to the issue report template . If you are reporting regualur issues, like raise an question, you can open an regular issue Sending pull request Follow the checklist in the pull request template Before you sending out the pull request, please sync your forked repository with remote repository, this will make your pull request simple and clear. See guide below: git remote add upstream git@github.com:apache/dubbo.git git fetch upstream git rebase upstream/master git checkout -b your_awesome_patch ... add some work git push origin your_awesome_patch Code convention Please check the CONTRIBUTING.md for code convention. Participate in the release vote Participate in the release vote is an important way to contribute to Dubbo. The Dubbo community welcomes everyone to partipate, you can check the release vote using this check list . If you have any question regarding the check list, please feel free to ask on dev@dubbo.apache.org. What can I contribute? Take a look at issues with tag called Good first issue or Help wanted . Join the discussion on mailing list, subscription guide . Answer questions on issues . Fix bugs reported on issues , and send us pull request. Review the existing pull request . Improve the website , typically we need blog post translation on documentation use cases about how Dubbo is being used in enterprise system. Improve the dubbo-admin/dubbo-monitor . Contribute to the projects listed in ecosystem . Any form of contribution that is not mentioned above. If you would like to contribute, please send an email to dev@dubbo.apache.org to let us know!","title":"New contributor guide"},{"location":"developers/contributor-guide/new-contributor-guide_dev/#new-contributor-guide","text":"This is a guide for new comers who wants to contribute to Dubbo.","title":"New contributor guide"},{"location":"developers/contributor-guide/new-contributor-guide_dev/#subscribe-to-the-mailing-list","text":"The mailing list is the recommended way for discussing almost anything that related to Dubbo. Please refer to this issue for detailed documentation on how to subscribe. To subscribe to the following mailing list, please refer to Mailing list subscription guide dev@dubbo.apache.org: the develop mailing list, you can ask question here if you have encountered any problem when using or developing Dubbo. commits@dubbo.apache.org: all the commits will be sent to this mailing list. You can subscribe to it if you are interested in Dubbo's development. issues@dubbo.apache.org: all the JIRA issues and updates will be sent to this mailing list. The Dubbo community has decided to use github issues rather than JIRA issues, therefore it is expected that most of the issues will be tracked by github issues. The JIRA issues are used to track ASF related issues.","title":"Subscribe to the mailing list"},{"location":"developers/contributor-guide/new-contributor-guide_dev/#reporting-issue","text":"You can always reporting an issue to Dubbo via Github Issues . If you are reporting bugs, please refer to the issue report template . If you are reporting regualur issues, like raise an question, you can open an regular issue","title":"Reporting issue"},{"location":"developers/contributor-guide/new-contributor-guide_dev/#sending-pull-request","text":"Follow the checklist in the pull request template Before you sending out the pull request, please sync your forked repository with remote repository, this will make your pull request simple and clear. See guide below: git remote add upstream git@github.com:apache/dubbo.git git fetch upstream git rebase upstream/master git checkout -b your_awesome_patch ... add some work git push origin your_awesome_patch","title":"Sending pull request"},{"location":"developers/contributor-guide/new-contributor-guide_dev/#code-convention","text":"Please check the CONTRIBUTING.md for code convention.","title":"Code convention"},{"location":"developers/contributor-guide/new-contributor-guide_dev/#participate-in-the-release-vote","text":"Participate in the release vote is an important way to contribute to Dubbo. The Dubbo community welcomes everyone to partipate, you can check the release vote using this check list . If you have any question regarding the check list, please feel free to ask on dev@dubbo.apache.org.","title":"Participate in the release vote"},{"location":"developers/contributor-guide/new-contributor-guide_dev/#what-can-i-contribute","text":"Take a look at issues with tag called Good first issue or Help wanted . Join the discussion on mailing list, subscription guide . Answer questions on issues . Fix bugs reported on issues , and send us pull request. Review the existing pull request . Improve the website , typically we need blog post translation on documentation use cases about how Dubbo is being used in enterprise system. Improve the dubbo-admin/dubbo-monitor . Contribute to the projects listed in ecosystem . Any form of contribution that is not mentioned above. If you would like to contribute, please send an email to dev@dubbo.apache.org to let us know!","title":"What can I contribute?"},{"location":"developers/contributor-guide/reporting-security-issues_dev/","text":"Reporting Security Issues The Apache Software Foundation takes a rigorous standpoint in annihilating the security issues in its software projects. Apache Dubbo is highly sensitive and forthcoming to issues pertaining to its features and functionality. REPORTING VULNERABILITY If you have apprehensions regarding Dubbo's security or you discover vulnerability or potential threat, don\u2019t hesitate to get in touch with the Apache Dubbo Security Team by dropping a mail at security@dubbo.apache.org. In the mail, specify the description of the issue or potential threat. You are also urged to recommend the way to reproduce and replicate the issue. The Dubbo community will get back to you after assessing and analysing the findings. PLEASE PAY ATTENTION to report the security issue on the security email before disclosing it on public domain. VULNERABILITY HANDLING An overview of the vulnerability handling process is: The reporter reports the vulnerability privately to Apache. The appropriate project's security team works privately with the reporter to resolve the vulnerability. A new release of the Apache product concerned is made that includes the fix. The vulnerability is publically announced. A more detailed description of the process can be found here","title":"Reporting Security Issues"},{"location":"developers/contributor-guide/reporting-security-issues_dev/#reporting-security-issues","text":"The Apache Software Foundation takes a rigorous standpoint in annihilating the security issues in its software projects. Apache Dubbo is highly sensitive and forthcoming to issues pertaining to its features and functionality.","title":"Reporting Security Issues"},{"location":"developers/contributor-guide/reporting-security-issues_dev/#reporting-vulnerability","text":"If you have apprehensions regarding Dubbo's security or you discover vulnerability or potential threat, don\u2019t hesitate to get in touch with the Apache Dubbo Security Team by dropping a mail at security@dubbo.apache.org. In the mail, specify the description of the issue or potential threat. You are also urged to recommend the way to reproduce and replicate the issue. The Dubbo community will get back to you after assessing and analysing the findings. PLEASE PAY ATTENTION to report the security issue on the security email before disclosing it on public domain.","title":"REPORTING VULNERABILITY"},{"location":"developers/contributor-guide/reporting-security-issues_dev/#vulnerability-handling","text":"An overview of the vulnerability handling process is: The reporter reports the vulnerability privately to Apache. The appropriate project's security team works privately with the reporter to resolve the vulnerability. A new release of the Apache product concerned is made that includes the fix. The vulnerability is publically announced. A more detailed description of the process can be found here","title":"VULNERABILITY HANDLING"},{"location":"developers/contributor-guide/software-donation-guide_dev/","text":"Software donation guide Before you go through this guide, make sure you have confirmed with PMC that a SGA is actually needed. If you are donating significant amount of code or documentation to Apache Dubbo , you will be required to sign a Software Grant before your code/doc could be merged. Steps Download this pdf Print it out Fill in the blanks (see below as an example) Request your boss to sign it Scan it Send an email to secretary@apache.org and cc private@dubbo.apache.org Example: Below is an text versioned example , original text could be found here License Agreement This License Agreement is entered into as of the _12th_ day of ___April____, __2018__ by ___ABC Software Co., Ltd.____ ( Licensor ), in favor of The Apache Software Foundation, a Delaware nonstock membership corporation (the Foundation ). WHEREAS, Licensor owns or has sufficient rights to contribute the software source code and other related intellectual property as itemized on Exhibit A ( Software ) under the terms of this agreement to the Foundation for use within Foundation software development projects ( Projects ). NOW, THEREFORE, FOR GOOD AND VALUABLE CONSIDERATION, the receipt and legal sufficiency of which are hereby acknowledged, the parties hereto, intending to be legally bound, agree as follows: 1. Subject to the terms and conditions of this License, Licensor hereby grants to the Foundation: a) a non-exclusive, worldwide, royalty-free, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, distribute and sublicense, internally and externally, the Software and such derivative works, in source code and object code form; and, b) a non-exclusive, worldwide, royalty-free, irrevocable patent license under Licensed Patents to make, use, sell, offer to sell, import and otherwise transfer the Software in source code and object code form. Licensed Patents mean patent claims owned by Licensor which are necessarily infringed by the use or sale of the Software alone. 2. Licensor represents that, to Licensor's knowledge, Licensor is legally entitled to grant the above license. Licensor agrees to notify the Foundation of any facts or circumstances of which Licensor becomes aware and which makes or would make Licensor's representations in this License Agreement inaccurate in any respect. 3. This Software is provided AS-IS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. NEITHER THE LICENSOR NOR ITS SUPPLIERS WILL BE LIABLE TO THE FOUNDATION OR ITS LICENSEES FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION OF THE WORK OR THE EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. This License Agreement is the entire agreement of the parties with respect to its subject matter, and may only be amended by a writing signed by each party. This License Agreement may be executed in one or more counterparts, each of which shall be considered an original. IN WITNESS WHEREOF, Licensor has executed this License Agreement as of the date first written above. LICENSOR: Signed By: _____________________________________ --- Your boss's sign here Print Name: _____Lei Li_________________________ --- Your boss's name here Title: ____Director_____________________________ --- Your boss's title here Representing: ____ABC Software Co., Ltd. _______ ________________________________________________ Contact Name: ____Lei Li________________________ --- Your boss's name here Contact Email: ____lilei@abc.com________________ --- Your boss's email here Exhibit A List of software and other intellectual property covered by this agreement: * Github address where your code is hosted * Pull request link","title":"Software donation guide"},{"location":"developers/contributor-guide/software-donation-guide_dev/#software-donation-guide","text":"Before you go through this guide, make sure you have confirmed with PMC that a SGA is actually needed. If you are donating significant amount of code or documentation to Apache Dubbo , you will be required to sign a Software Grant before your code/doc could be merged.","title":"Software donation guide"},{"location":"developers/contributor-guide/software-donation-guide_dev/#steps","text":"Download this pdf Print it out Fill in the blanks (see below as an example) Request your boss to sign it Scan it Send an email to secretary@apache.org and cc private@dubbo.apache.org","title":"Steps"},{"location":"developers/contributor-guide/software-donation-guide_dev/#example","text":"Below is an text versioned example , original text could be found here License Agreement This License Agreement is entered into as of the _12th_ day of ___April____, __2018__ by ___ABC Software Co., Ltd.____ ( Licensor ), in favor of The Apache Software Foundation, a Delaware nonstock membership corporation (the Foundation ). WHEREAS, Licensor owns or has sufficient rights to contribute the software source code and other related intellectual property as itemized on Exhibit A ( Software ) under the terms of this agreement to the Foundation for use within Foundation software development projects ( Projects ). NOW, THEREFORE, FOR GOOD AND VALUABLE CONSIDERATION, the receipt and legal sufficiency of which are hereby acknowledged, the parties hereto, intending to be legally bound, agree as follows: 1. Subject to the terms and conditions of this License, Licensor hereby grants to the Foundation: a) a non-exclusive, worldwide, royalty-free, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, distribute and sublicense, internally and externally, the Software and such derivative works, in source code and object code form; and, b) a non-exclusive, worldwide, royalty-free, irrevocable patent license under Licensed Patents to make, use, sell, offer to sell, import and otherwise transfer the Software in source code and object code form. Licensed Patents mean patent claims owned by Licensor which are necessarily infringed by the use or sale of the Software alone. 2. Licensor represents that, to Licensor's knowledge, Licensor is legally entitled to grant the above license. Licensor agrees to notify the Foundation of any facts or circumstances of which Licensor becomes aware and which makes or would make Licensor's representations in this License Agreement inaccurate in any respect. 3. This Software is provided AS-IS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. NEITHER THE LICENSOR NOR ITS SUPPLIERS WILL BE LIABLE TO THE FOUNDATION OR ITS LICENSEES FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION OF THE WORK OR THE EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. This License Agreement is the entire agreement of the parties with respect to its subject matter, and may only be amended by a writing signed by each party. This License Agreement may be executed in one or more counterparts, each of which shall be considered an original. IN WITNESS WHEREOF, Licensor has executed this License Agreement as of the date first written above. LICENSOR: Signed By: _____________________________________ --- Your boss's sign here Print Name: _____Lei Li_________________________ --- Your boss's name here Title: ____Director_____________________________ --- Your boss's title here Representing: ____ABC Software Co., Ltd. _______ ________________________________________________ Contact Name: ____Lei Li________________________ --- Your boss's name here Contact Email: ____lilei@abc.com________________ --- Your boss's email here Exhibit A List of software and other intellectual property covered by this agreement: * Github address where your code is hosted * Pull request link","title":"Example:"},{"location":"developers/contributor-guide/test-coverage-guide_dev/","text":"Test coverage guide 1.The benefits of unit testing Unit test code can help everyone to go into details and understand the function of the code. We can find bugs by test case, and then enhance the robustness of the code. Test case code is also the demo usage of the core code. 2.Some design principle of unit test case Steps, fine-grained and combination conditions should be well designed. Attention to boundary condition test Test code should also be designed without writing useless code. When you find a method that is hard to write unit test, if you can be sure the method is \"smelly code\", then refactor it with the committer. The mock framework in dubbo is: mockito . Some tutorials: mockito tutorial , mockito refcard TDD\uff08optional\uff09\uff1aWhen you start a new issue, you can try to write test case at first 3.The specified value of the test coverage In the stage, the test coverage specified value of delta changed codes is \uff1a =60%. The higher, the better. We can see the coverage report in this page: https://codecov.io/gh/apache/dubbo","title":"Test coverage guide"},{"location":"developers/contributor-guide/test-coverage-guide_dev/#test-coverage-guide","text":"","title":"Test coverage guide"},{"location":"developers/contributor-guide/test-coverage-guide_dev/#1the-benefits-of-unit-testing","text":"Unit test code can help everyone to go into details and understand the function of the code. We can find bugs by test case, and then enhance the robustness of the code. Test case code is also the demo usage of the core code.","title":"1.The benefits of unit testing"},{"location":"developers/contributor-guide/test-coverage-guide_dev/#2some-design-principle-of-unit-test-case","text":"Steps, fine-grained and combination conditions should be well designed. Attention to boundary condition test Test code should also be designed without writing useless code. When you find a method that is hard to write unit test, if you can be sure the method is \"smelly code\", then refactor it with the committer. The mock framework in dubbo is: mockito . Some tutorials: mockito tutorial , mockito refcard TDD\uff08optional\uff09\uff1aWhen you start a new issue, you can try to write test case at first","title":"2.Some design principle of unit test case"},{"location":"developers/contributor-guide/test-coverage-guide_dev/#3the-specified-value-of-the-test-coverage","text":"In the stage, the test coverage specified value of delta changed codes is \uff1a =60%. The higher, the better. We can see the coverage report in this page: https://codecov.io/gh/apache/dubbo","title":"3.The specified value of the test coverage"},{"location":"developers/user-guide/faq_dev/","text":"FAQ Where is dubbo-admin? dubbo-admin has been moved from core repository to https://github.com/apache/dubbo-admin since 2.6.1 Which version should I choose? Currently, dubbo keeps 3 versions evolve in parallel: 2.7.x (master): requires Java 1.8, major feature branch. 2.6.x: requires Java 1.6, minor feature bugfix branch, GA, production ready. 2.5.x: requires Java 1.6, maintenance branch, only accept security vulnerability and critical bugfix, the support will end on 2019-6-15, please upgrade to 2.6.x as soon as possible. check this for detailed version management plan. For contributors, please make sure all changes on the right branch, that is, most of the pull request should go to 2.7.x, and be backported to 2.6.x and 2.5.x if necessary. If the fix is specific to a branch, please make sure your pull request goes to the right branch. For committers, make sure select the right label and target branch for every PR, and don't forget to back port the fix to lower version is necessary. How to register ip correctly in docker? Example question Dubbo supports specifying ip/port via system environment variables, examples can be found here .","title":"FAQ"},{"location":"developers/user-guide/faq_dev/#faq","text":"","title":"FAQ"},{"location":"developers/user-guide/faq_dev/#where-is-dubbo-admin","text":"dubbo-admin has been moved from core repository to https://github.com/apache/dubbo-admin since 2.6.1","title":"Where is dubbo-admin?"},{"location":"developers/user-guide/faq_dev/#which-version-should-i-choose","text":"Currently, dubbo keeps 3 versions evolve in parallel: 2.7.x (master): requires Java 1.8, major feature branch. 2.6.x: requires Java 1.6, minor feature bugfix branch, GA, production ready. 2.5.x: requires Java 1.6, maintenance branch, only accept security vulnerability and critical bugfix, the support will end on 2019-6-15, please upgrade to 2.6.x as soon as possible. check this for detailed version management plan. For contributors, please make sure all changes on the right branch, that is, most of the pull request should go to 2.7.x, and be backported to 2.6.x and 2.5.x if necessary. If the fix is specific to a branch, please make sure your pull request goes to the right branch. For committers, make sure select the right label and target branch for every PR, and don't forget to back port the fix to lower version is necessary.","title":"Which version should I choose?"},{"location":"developers/user-guide/faq_dev/#how-to-register-ip-correctly-in-docker","text":"Example question Dubbo supports specifying ip/port via system environment variables, examples can be found here .","title":"How to register ip correctly in docker?"},{"location":"user/","text":"dubbo-user-book The dubbo cookbook, covering almost all features of dubbo framework.","title":"dubbo-user-book"},{"location":"user/#dubbo-user-book","text":"The dubbo cookbook, covering almost all features of dubbo framework.","title":"dubbo-user-book"},{"location":"user/SUMMARY/","text":"Summary 1 Preface 1.1 Background 1.2 Requirements 1.3 Architecture 1.4 Usage 2 Quick start 3 Dependencies 4 Maturity 5 Configuration 5.1 XML configuration 5.2 Properties configuration 5.3 API configuration 5.4 Annotation configuration 6 Demos 6.1 Start check 6.2 Fault-tolerent strategy 6.3 Load balance 6.4 Thread model 6.5 Connecting certain provider straightly 6.6 Subscribe only 6.7 Registry only 6.8 Static service 6.9 Multi-protocols 6.10 Multi-registries 6.11 Service group 6.12 Multi-versions 6.13 Group merger 6.14 Parameter validation 6.15 Result cache 6.16 Generic reference 6.17 Generic service 6.18 Echo service 6.19 Context 6.20 Attachment 6.21 Asynchronous call 6.22 Local call 6.23 Callback parameter 6.24 Events notify 6.25 Local stub 6.26 Local mock 6.27 Delay publish 6.28 Concurrency control 6.29 Connections limitation 6.30 Lazy connect 6.31 Stickness connections 6.32 Token authorization 6.33 Routing rule 6.34 Configuration rule 6.35 Service downgrade 6.36 Graceful shutdown 6.37 Hostname binding 6.38 Logger strategy 6.39 Accesslog 6.40 Service container 6.41 Reference config cache 6.42 Distributed transaction 6.43 Dumping thread stack automatically 6.44 Netty4 7 API introduction 8 Schema configuration introduction 8.1 dubbo:service 8.2 dubbo:reference 8.3 dubbo:protocol 8.4 dubbo:registry 8.5 dubbo:monitor 8.6 dubbo:application 8.7 dubbo:module 8.8 dubbo:provider 8.9 dubbo:consumer 8.10 dubbo:method 8.11 dubbo:argument 8.12 dubbo:parameter 9 Protocol introduction 9.1 dubbo:// 9.2 rmi// 9.3 hessian:// 9.4 http:// 9.5 webservice:// 9.6 thrift:// 9.7 memcached:// 9.8 redis:// 10 registry introduction 10.1 Multicast registry 10.2 Zookeeper registry 10.3 Redis registry 10.4 Simple registry 11 Telnet command 12 maven plugins 13 Servitization best practice 14 Recommended usage 15 Capacity plan 16 Performance testing reports 17 Test coverage report","title":"Summary"},{"location":"user/SUMMARY/#summary","text":"1 Preface 1.1 Background 1.2 Requirements 1.3 Architecture 1.4 Usage 2 Quick start 3 Dependencies 4 Maturity 5 Configuration 5.1 XML configuration 5.2 Properties configuration 5.3 API configuration 5.4 Annotation configuration 6 Demos 6.1 Start check 6.2 Fault-tolerent strategy 6.3 Load balance 6.4 Thread model 6.5 Connecting certain provider straightly 6.6 Subscribe only 6.7 Registry only 6.8 Static service 6.9 Multi-protocols 6.10 Multi-registries 6.11 Service group 6.12 Multi-versions 6.13 Group merger 6.14 Parameter validation 6.15 Result cache 6.16 Generic reference 6.17 Generic service 6.18 Echo service 6.19 Context 6.20 Attachment 6.21 Asynchronous call 6.22 Local call 6.23 Callback parameter 6.24 Events notify 6.25 Local stub 6.26 Local mock 6.27 Delay publish 6.28 Concurrency control 6.29 Connections limitation 6.30 Lazy connect 6.31 Stickness connections 6.32 Token authorization 6.33 Routing rule 6.34 Configuration rule 6.35 Service downgrade 6.36 Graceful shutdown 6.37 Hostname binding 6.38 Logger strategy 6.39 Accesslog 6.40 Service container 6.41 Reference config cache 6.42 Distributed transaction 6.43 Dumping thread stack automatically 6.44 Netty4 7 API introduction 8 Schema configuration introduction 8.1 dubbo:service 8.2 dubbo:reference 8.3 dubbo:protocol 8.4 dubbo:registry 8.5 dubbo:monitor 8.6 dubbo:application 8.7 dubbo:module 8.8 dubbo:provider 8.9 dubbo:consumer 8.10 dubbo:method 8.11 dubbo:argument 8.12 dubbo:parameter 9 Protocol introduction 9.1 dubbo:// 9.2 rmi// 9.3 hessian:// 9.4 http:// 9.5 webservice:// 9.6 thrift:// 9.7 memcached:// 9.8 redis:// 10 registry introduction 10.1 Multicast registry 10.2 Zookeeper registry 10.3 Redis registry 10.4 Simple registry 11 Telnet command 12 maven plugins 13 Servitization best practice 14 Recommended usage 15 Capacity plan 16 Performance testing reports 17 Test coverage report","title":"Summary"},{"location":"user/benchmark-tool/","text":"Beanchmark testing tool installer download\uff1a git clone https://github.com/apache/dubbo.git compile benchmark: cd dubbo/dubbo-test/dubbo-test-benchmark; mvn clean install uncompress benchmark\uff1a dubbo/dubbo-test/dubbo-test-benchmark/target/dubbo-test-benchmark-2.6.2-SNAPSHOT.tar.gz Read ReadMe.txt (the contents are as follows, in the compressed package.) Build a new benchmark project, such as demo.benchmark Import the your own interface api jar and dubbo.benchmark.jar (Unzip dubbo.benchmark.tar.gz, under the lib directory ) Create a new class to implement AbstractClientRunnable Implement the constructor of the parent class Implement the invoke method and create a local interface proxy by serviceFactory\uff0cand finish your own business logic, as follows: java public Object invoke(ServiceFactory serviceFactory) { DemoService demoService = (DemoService) serviceFactory.get(DemoService.class); return demoService.sendRequest(\"hello\"); } Make your own benchmark project into a jar package, such as demo.benchmark.jar Put the demo.benchmark.jar and service API jar into directory dubbo.benchmark/lib Configuring dubbo.properties Run run.bat(windows) or run.sh(linux) If you want to test the different versions of Dubbo, you can replace the jar of the Dubbo.","title":"Beanchmark testing tool installer"},{"location":"user/benchmark-tool/#beanchmark-testing-tool-installer","text":"download\uff1a git clone https://github.com/apache/dubbo.git compile benchmark: cd dubbo/dubbo-test/dubbo-test-benchmark; mvn clean install uncompress benchmark\uff1a dubbo/dubbo-test/dubbo-test-benchmark/target/dubbo-test-benchmark-2.6.2-SNAPSHOT.tar.gz Read ReadMe.txt (the contents are as follows, in the compressed package.) Build a new benchmark project, such as demo.benchmark Import the your own interface api jar and dubbo.benchmark.jar (Unzip dubbo.benchmark.tar.gz, under the lib directory ) Create a new class to implement AbstractClientRunnable Implement the constructor of the parent class Implement the invoke method and create a local interface proxy by serviceFactory\uff0cand finish your own business logic, as follows: java public Object invoke(ServiceFactory serviceFactory) { DemoService demoService = (DemoService) serviceFactory.get(DemoService.class); return demoService.sendRequest(\"hello\"); } Make your own benchmark project into a jar package, such as demo.benchmark.jar Put the demo.benchmark.jar and service API jar into directory dubbo.benchmark/lib Configuring dubbo.properties Run run.bat(windows) or run.sh(linux) If you want to test the different versions of Dubbo, you can replace the jar of the Dubbo.","title":"Beanchmark testing tool installer"},{"location":"user/best-practice/","text":"Servitization best practice Modularization It is recommended to put service interfaces, service models, service exceptions, and so on in the API package,Because the service model and exception are part of the API, it is also in conformity with the modularization principle:Reusing the publish equivalence principle (REP) and the Common Reuse Principle (CRP). If you need, you can also consider placing a spring reference configuration in the API package, so that the user can only use the configuration in the spring loading process, and the configuration suggestion is placed in the package directory of the module, so as not to conflict, eg: com/alibaba/china/xxx/dubbo-reference.xml \u3002 Granularity The service interface should have large granularity as possible.Each service method should represent a function rather than a step of a function, otherwise it will be faced with distributed transaction problem. Dubbo does not provide distributed transaction support at present. The service interface recommends the division of the business scene as a unit and abstract the similar business to prevent the explosion of the number of interfaces. It is not recommended to use an too abstract universal interface, such as Map query (Map), which has no explicit semantics, which will inconvenience later maintenance. Version Each interface should define a version number to provide possible subsequent incompatible upgrades,eg: dubbo:service interface=\"com.xxx.XxxService\" version=\"1.0\" / \u3002 It is recommended to use a two bit version number, because the third - bit version number is usually compatible with a compatible upgrade, and a change of service version is required only when incompatible. When incompatible, half of the provider is upgraded to a new version, and all the consumers are upgraded to a new version, and the remaining half providers are upgraded to a new version. Compatibility The service interface adds method or the service model adds fields. It can be backward compatible, delete methods or delete fields, and will not be compatible. The new fields of the enumerated type are not compatible, so we need to upgrade by changing the version number. The compatibility of each protocol is different, see: Protocol introduction Enumeration type If it is a complete set, you can use Enum, eg: ENABLE , DISABLE \u3002 If it is the type of business, there will be an obvious type of increase in the future, and it is not recommended to use Enum , and it is not recommended to use Enum and can be replaced by String . If you use Enum in the return value,And add the Enum value,suggestions to upgrade the service consumption, so that the service provider does not return a new value. If the Enum value is used in the incoming parameter,and add the Enum value,it is suggested that the service provider be upgraded first, so that the service consumer will not pass the new value. Serialization The service parameters and return values suggest that the POJO object is used, that is, the object of the attribute is represented by the setter , getter method. Service parameters and return values do not recommend the use of interfaces, because data model abstraction is of little significance, and serialization requires interfaces to implement meta information of classes, and can not play the purpose of hiding implementation. Service parameters and return values must be byValue, but not byReference. The reference or return values of consumers and providers are not the same, but the values are the same. Dubbo does not support remote objects. Exception It is suggested that abnormal reporting errors are used rather than return error codes, and exception information can carry more information and have more semantic friendliness. If you are worried about performance problems, you can use the override () method of fillInStackTrace () out of the exception class as an empty method to make it not a copy of the stack information when necessary. Query method is not recommended throws checked, otherwise the caller in the query will be too much try...catch, and can not be processed. Service providers should not throw the exception of DAO or SQL to the consumer side. They should package the exception that consumers do not care about in service implementation, otherwise consumers may not be able to serialize the corresponding exception. Call Not just because it is a Dubbo call, wrap the call logic eith try...catch clause. try...catch should be added to the appropriate rollback boundary. The check logic for the input parameters should be available at the Provider side. For performance considerations, the service implementer may consider adding a service Stub class to the API package to complete the test.","title":"Best practice"},{"location":"user/best-practice/#servitization-best-practice","text":"","title":"Servitization best practice"},{"location":"user/best-practice/#modularization","text":"It is recommended to put service interfaces, service models, service exceptions, and so on in the API package,Because the service model and exception are part of the API, it is also in conformity with the modularization principle:Reusing the publish equivalence principle (REP) and the Common Reuse Principle (CRP). If you need, you can also consider placing a spring reference configuration in the API package, so that the user can only use the configuration in the spring loading process, and the configuration suggestion is placed in the package directory of the module, so as not to conflict, eg: com/alibaba/china/xxx/dubbo-reference.xml \u3002","title":"Modularization"},{"location":"user/best-practice/#granularity","text":"The service interface should have large granularity as possible.Each service method should represent a function rather than a step of a function, otherwise it will be faced with distributed transaction problem. Dubbo does not provide distributed transaction support at present. The service interface recommends the division of the business scene as a unit and abstract the similar business to prevent the explosion of the number of interfaces. It is not recommended to use an too abstract universal interface, such as Map query (Map), which has no explicit semantics, which will inconvenience later maintenance.","title":"Granularity"},{"location":"user/best-practice/#version","text":"Each interface should define a version number to provide possible subsequent incompatible upgrades,eg: dubbo:service interface=\"com.xxx.XxxService\" version=\"1.0\" / \u3002 It is recommended to use a two bit version number, because the third - bit version number is usually compatible with a compatible upgrade, and a change of service version is required only when incompatible. When incompatible, half of the provider is upgraded to a new version, and all the consumers are upgraded to a new version, and the remaining half providers are upgraded to a new version.","title":"Version"},{"location":"user/best-practice/#compatibility","text":"The service interface adds method or the service model adds fields. It can be backward compatible, delete methods or delete fields, and will not be compatible. The new fields of the enumerated type are not compatible, so we need to upgrade by changing the version number. The compatibility of each protocol is different, see: Protocol introduction","title":"Compatibility"},{"location":"user/best-practice/#enumeration-type","text":"If it is a complete set, you can use Enum, eg: ENABLE , DISABLE \u3002 If it is the type of business, there will be an obvious type of increase in the future, and it is not recommended to use Enum , and it is not recommended to use Enum and can be replaced by String . If you use Enum in the return value,And add the Enum value,suggestions to upgrade the service consumption, so that the service provider does not return a new value. If the Enum value is used in the incoming parameter,and add the Enum value,it is suggested that the service provider be upgraded first, so that the service consumer will not pass the new value.","title":"Enumeration type"},{"location":"user/best-practice/#serialization","text":"The service parameters and return values suggest that the POJO object is used, that is, the object of the attribute is represented by the setter , getter method. Service parameters and return values do not recommend the use of interfaces, because data model abstraction is of little significance, and serialization requires interfaces to implement meta information of classes, and can not play the purpose of hiding implementation. Service parameters and return values must be byValue, but not byReference. The reference or return values of consumers and providers are not the same, but the values are the same. Dubbo does not support remote objects.","title":"Serialization"},{"location":"user/best-practice/#exception","text":"It is suggested that abnormal reporting errors are used rather than return error codes, and exception information can carry more information and have more semantic friendliness. If you are worried about performance problems, you can use the override () method of fillInStackTrace () out of the exception class as an empty method to make it not a copy of the stack information when necessary. Query method is not recommended throws checked, otherwise the caller in the query will be too much try...catch, and can not be processed. Service providers should not throw the exception of DAO or SQL to the consumer side. They should package the exception that consumers do not care about in service implementation, otherwise consumers may not be able to serialize the corresponding exception.","title":"Exception"},{"location":"user/best-practice/#call","text":"Not just because it is a Dubbo call, wrap the call logic eith try...catch clause. try...catch should be added to the appropriate rollback boundary. The check logic for the input parameters should be available at the Provider side. For performance considerations, the service implementer may consider adding a service Stub class to the API package to complete the test.","title":"Call"},{"location":"user/capacity-plan/","text":"Capacity plan The following data for reference\uff1a Use member service project of Dubbo Receive 400,000,000 remote calls one day Use 12 standard servers to provide services (CPU:8 core, memory: 8G) The average load is less than 1 (For 8 core CPU, the load is very low) The average response time is 2.3 to 2.5 ms\uff0cNetwork cost about 1.5 to 1.6 ms(Related to the size of the packet ) Use product authorization service project of Dubbo Receive 300,000,000 remote calls one day Use 8 standard servers to provide services (CPU:8 core, memory: 8G) The average load is less than 1 (For 8 core CPU, the load is very low) The average response time is 1.4 to 2.8 ms\uff0cNetwork cost about 1.0 to 1.1 ms(Related to the size of the packet )","title":"Capacity plan"},{"location":"user/capacity-plan/#capacity-plan","text":"The following data for reference\uff1a","title":"Capacity plan"},{"location":"user/capacity-plan/#use-member-service-project-of-dubbo","text":"Receive 400,000,000 remote calls one day Use 12 standard servers to provide services (CPU:8 core, memory: 8G) The average load is less than 1 (For 8 core CPU, the load is very low) The average response time is 2.3 to 2.5 ms\uff0cNetwork cost about 1.5 to 1.6 ms(Related to the size of the packet )","title":"Use member service project of Dubbo"},{"location":"user/capacity-plan/#use-product-authorization-service-project-of-dubbo","text":"Receive 300,000,000 remote calls one day Use 8 standard servers to provide services (CPU:8 core, memory: 8G) The average load is less than 1 (For 8 core CPU, the load is very low) The average response time is 1.4 to 2.8 ms\uff0cNetwork cost about 1.0 to 1.1 ms(Related to the size of the packet )","title":"Use product authorization service project of Dubbo"},{"location":"user/coveragence/","text":"Test coverage report v2.0 Codecov report , Statistics since 2017-12-29 The test coverage is : , we can get the report in https://codecov.io/gh/apache/dubbo v1.0 Based on version 2.0.12 \uff0cStatistics on 2012-02-03","title":"Test coverage report"},{"location":"user/coveragence/#test-coverage-report","text":"v2.0 Codecov report , Statistics since 2017-12-29 The test coverage is : , we can get the report in https://codecov.io/gh/apache/dubbo v1.0 Based on version 2.0.12 \uff0cStatistics on 2012-02-03","title":"Test coverage report"},{"location":"user/dependencies/","text":"Dependencies Necessary dependencies JDK 1.6+ [^1] Default dependencies use mvn dependency:tree dep.log command to analysis\uff0cDubbo default depends on the following 3rd party libraries\uff1a [INFO] +- com.alibaba:dubbo:jar:2.5.9-SNAPSHOT:compile [INFO] | +- org.springframework:spring-context:jar:4.3.10.RELEASE:compile [INFO] | +- org.javassist:javassist:jar:3.21.0-GA:compile [INFO] | \\- org.jboss.netty:netty:jar:3.2.5.Final:compile All dependencies here are selected for the default configuration of the Dubbo, which are based on stability and performance considerations. javassist.jar [^3]: if dubbo:provider proxy=\"jdk\" / or dubbo:consumer proxy=\"jdk\" / \uff0cor dubbo:application compiler=\"jdk\" / \uff0c is not required. spring-context.jar [^4]: If you are using ServiceConfig and ReferenceConfig API calls, is not required. netty.jar [^5]: if dubbo:protocol server=\"mina\"/ or dubbo:protocol server=\"grizzly\"/ \uff0cThen change to mina.jar or grizzly.jar. If protocol name=\"rmi\"/ \uff0c is not required. Optinal dependencies These dependencies needs to be added to project manually\uff0cwhen you need them. netty-all 4.0.35.Final mina: 1.1.7 grizzly: 2.1.4 httpclient: 4.5.3 hessian_lite: 3.2.1-fixed fastjson: 1.2.31 zookeeper: 3.4.9 jedis: 2.9.0 xmemcached: 1.3.6 hessian: 4.0.38 jetty: 6.1.26 hibernate-validator: 5.4.1.Final zkclient: 0.2 curator: 2.12.0 cxf: 3.0.14 thrift: 0.8.0 servlet: 3.0 ^6 validation-api: 1.1.0.GA ^6 jcache: 1.0.0 ^6 javax.el: 3.0.1-b08 ^6 kryo: 4.0.1 kryo-serializers: 0.42 fst: 2.48-jdk-6 resteasy: 3.0.19.Final tomcat-embed-core: 8.0.11 slf4j: 1.7.25 log4j: 1.2.16 [^1]: In theory, Dubbo only depend on JDK, not depend on any 3rd party libs, you can finish logic by using JDK. [^2]: Log output jar [^3]: Bytecode generation [^4]: Configuration parsing [^5]: Network transmission","title":"Dependencies"},{"location":"user/dependencies/#dependencies","text":"","title":"Dependencies"},{"location":"user/dependencies/#necessary-dependencies","text":"JDK 1.6+ [^1]","title":"Necessary dependencies"},{"location":"user/dependencies/#default-dependencies","text":"use mvn dependency:tree dep.log command to analysis\uff0cDubbo default depends on the following 3rd party libraries\uff1a [INFO] +- com.alibaba:dubbo:jar:2.5.9-SNAPSHOT:compile [INFO] | +- org.springframework:spring-context:jar:4.3.10.RELEASE:compile [INFO] | +- org.javassist:javassist:jar:3.21.0-GA:compile [INFO] | \\- org.jboss.netty:netty:jar:3.2.5.Final:compile All dependencies here are selected for the default configuration of the Dubbo, which are based on stability and performance considerations. javassist.jar [^3]: if dubbo:provider proxy=\"jdk\" / or dubbo:consumer proxy=\"jdk\" / \uff0cor dubbo:application compiler=\"jdk\" / \uff0c is not required. spring-context.jar [^4]: If you are using ServiceConfig and ReferenceConfig API calls, is not required. netty.jar [^5]: if dubbo:protocol server=\"mina\"/ or dubbo:protocol server=\"grizzly\"/ \uff0cThen change to mina.jar or grizzly.jar. If protocol name=\"rmi\"/ \uff0c is not required.","title":"Default dependencies"},{"location":"user/dependencies/#optinal-dependencies","text":"These dependencies needs to be added to project manually\uff0cwhen you need them. netty-all 4.0.35.Final mina: 1.1.7 grizzly: 2.1.4 httpclient: 4.5.3 hessian_lite: 3.2.1-fixed fastjson: 1.2.31 zookeeper: 3.4.9 jedis: 2.9.0 xmemcached: 1.3.6 hessian: 4.0.38 jetty: 6.1.26 hibernate-validator: 5.4.1.Final zkclient: 0.2 curator: 2.12.0 cxf: 3.0.14 thrift: 0.8.0 servlet: 3.0 ^6 validation-api: 1.1.0.GA ^6 jcache: 1.0.0 ^6 javax.el: 3.0.1-b08 ^6 kryo: 4.0.1 kryo-serializers: 0.42 fst: 2.48-jdk-6 resteasy: 3.0.19.Final tomcat-embed-core: 8.0.11 slf4j: 1.7.25 log4j: 1.2.16 [^1]: In theory, Dubbo only depend on JDK, not depend on any 3rd party libs, you can finish logic by using JDK. [^2]: Log output jar [^3]: Bytecode generation [^4]: Configuration parsing [^5]: Network transmission","title":"Optinal dependencies"},{"location":"user/maturity/","text":"Maturity Function maturity Feature Maturity Strength Problem Advise User Concurrency control Tested concurrency control On trial Connection control Tested connection number control On trial Connecting certain provider straightly Tested Provider service for point-to-point connecting straightly, for test Can be used in the test environment Alibaba Grouping polymerization Tested Return value of grouping polymerization, service for menu aggregation and other services Used in special scenes Can be used in the production environment Parameters validator Tested parameters validator, JSR303 validation framework integration Have effect on Performance On trial LaiWang Result cache Tested result cache, for accelerating requests On trial Generic reference Stable Generic reference, remote call without a business interface class\uff0cfor test platforms, open api proxy service, and so on Can be used in the production environment Alibaba Generic service Stable Generic service, no interface class is required to implement any interface, for mock platform Can be used in the production environment Alibaba Echo test Tested echo test On trial Attachment Stable Attachment Can be used in the production environment Asynchronous call Tested Unavailable asynchronous call On trial Local call Tested Local call On trial Callback parameter Tested Callback parameter Used in special scenes On trial Registry Events notify Tested Events notify, triggering before and after the remote call is executed On trial Local stub Stable Performing part of the logic on the client side Can be used in the production environment Alibaba Local mock Stable Forged return results, which can be executed when failed or directly executed, for service degradation Need support of registry Can be used in the production environment Alibaba Delay publish Stable Delay publish, used to wait for the application to load warmup data or wait for spring context to load completely Can be used in the production environment Alibaba Lazy connect Tested Delay setting up connections, when invocation is set up On trial Registry Stickness connections Tested Stickness connections, always make a request to the same provider service unless the service is down, and then switch to another On trial Registry Token authorization Tested Token authorization, is used for service authorization Need support of registry On trial Routing rule Tested Dynamically determining the call relationship Need support of registry On trial Configuration rule Tested Distribute the configuration dynamically, is the switch of business logic Need support of registry On trial Accesslog Tested Accesslog, used to record call information Local storage, impact performance, limited by disk size On trial Distributed transaction Research JTA/XA three phase submission transaction(TCC) Unstable Unavailable Strategy maturity Feature Maturity Strength Problem Advise User Zookeeper registry Stable Support the cluster, have various of related open source products, dubbo-2.3.3 and above versions are recommended Depended on the stability of zookeeper Can be used in the production environment Redis registry Stable Support the client - based double - write clustering method with high performance Please ensure server time synchronization, be used to check the expired dirty data of heartbeat Can be used in the production environment Multicast registry Tested Decentration, no registry needs to be installed Depending on the network topology and routing, there is a risk across the server rooms Can be used in a small range, in development/test environment Simple registry Tested Dogfooding, the registry itself is also a standard RPC service No cluster support, may occur single-point failure On trial Feature Maturity Strength Problem Advise User Simple monitor system Stable Support JFreeChart statistics report No cluster support, may occur single-point failure, but the failure does not affect the RPC call Can be used in the production environment Feature Maturity Strength Problem Advise User Dubbo protocol Stable Use NIO to reuse a single long connection and use a thread pool to process requests concurrently, Reduce handshake and increase concurrency efficiency, good performance A single connection will become a bottleneck in the transmission of large files Can be used in the production environment Alibaba Rmi protocol Stable Interoperable with native RMI, based on the TCP protocol Occasionally the connection fails, and the stub needs to be rebuilt Can be used in the production environment Alibaba Hessian protocol Stable Interoperable with native Hessian, based on the HTTP protocol Hessian.jar support is required, and the overhead of HTTP short connections is large Can be used in the production environment Feature Maturity Strength Problem Advise User Netty Transporter Stable The NIO framework of JBoss, has good performance A request sends two events and needs to shield useless events Can be used in the production environment Alibaba Mina Transporter Stable Classic NIO framework\uff0cstable The dispatch of the message queue is not timely, under great pressure, there will be FullGC Can be used in the production environment Alibaba Grizzly Transporter Tested The NIO framework of Sun, applied in the GlassFish container The thread pool is not extensible, and Filter can't intercept the next filter On trial Feature Maturity Strength Problem Advise User Hessian Serialization Stable Good performance, multilingual support (recommended) The compatibility of various versions of Hessian is not good, it may be in conflict with the Hessian used in the application, and the Dubbo is embedded with the source code of the hessian3.2.1 Can be used in the production environment Alibaba Dubbo Serialization Tested The performance is better in a large number of POJO transmission by not transmitting the class information of POJO. When a field is added to the parameter object, an external file declaration is required On trial Json Serialization Tested pure text, can be cross-language parsed, default using FastJson Poor performance On trial Java Serialization Stable Java native support Poor performance Can be used in the production environment Feature Maturity Strength Problem Advise User Javassist ProxyFactory Stable Bytecode generation instead of reflection, good performance(recommended) Depending on the javassist.jar and taking up the JVM's Perm memory, the Perm may have to be larger:java -XX:PermSize=128m Can be used in the production environment Alibaba Jdk ProxyFactory Stable JDK native support Poor performance Can be used in the production environment Feature Maturity Strength Problem Advise User Failover Cluster Stable Failure automatically switches, when failure occurs, retries other servers, usually used for read operations.(recommended) Retry will lead to longer delays Can be used in the production environment Alibaba Failfast Cluster Stable Fast failure, only one call, failure to be reported immediately, usually used for non idempotent writing. If a server is being restarted, a call failure may occur Can be used in the production environment Alibaba Failsafe Cluster Stable Failsafe, when abnormal, directly ignored, usually used to write to the audit log and other operations Call information loss Can be used in the production environment Monitor Failback Cluster Tested Failure auto recovery, backstage record failure request, regular retransmission, usually used for message notification operations Unreliable, lost when restart the server Can be used in the production environment Registry Forking Cluster Tested Multiple servers are invoked in parallel, as long as one success is returned, often used for high real-time reading operations. Need to waste more service resources Can be used in the production environment Broadcast Cluster Tested A broadcast calls all providers, one by one, and any error is wrongly reported, usually used to update the provider's local state The speed is slow, and any false report is wrong. Can be used in the production environment Feature Maturity Strength Problem Advise User Random LoadBalance Stable Random probability, set random probability according to weight(recommended) The probability of a collision on a cross section is high. When retrying, there may be an unequal instantaneous pressure. Can be used in the production environment Alibaba RoundRobin LoadBalance Stable Round Robin, setting wheel based ratio according to the weight after the Convention There is a slow machine accumulation request problem, and extreme circumstances may cause an avalanche Can be used in the production environment LeastActive LoadBalance Stable The least active call number, the random number of the same active number, the active number is the count difference before and after the call, making the slow machine receive less request. Do not support the weight, in the capacity planning, not to pressure a machine oriented pressure measurement by weight capacity Can be used in the production environment ConsistentHash LoadBalance Stable The consistency hash, the same parameters always request to the same provider, when one provider hung, originally sent to the provider's request, based on virtual nodes, spread to other providers, will not cause dramatic changes Uneven distribution of pressure Can be used in the production environment Feature Maturity Strength Problem Advise User Condition routing rule Stable Routing rules based on conditional expressions, simple and easy to use There are some complex multi branch conditions, and the rules are difficult to describe Can be used in the production environment Alibaba Script routing rules Tested Routing rules based on the script engine, powerful No sandbox is running, scripting ability is too powerful and may be the back door On trial Feature Maturity Strength Problem Advise User Spring Container Stable Automatically load all Spring configurations under the META-INF/spring directory Can be used in the production environment Alibaba Jetty Container Stable Start an embedded Jetty for reporting state When a large number of pages are accessed, the threads and memory of the server are affected Can be used in the production environment Alibaba Log4j Container Stable Configuring the configuration of the log4j automatically, automatically subdirecting the log files by process at the startup of multiple processes The user can't control the configuration of log4j, inflexible Can be used in the production environment Alibaba","title":"Maturity"},{"location":"user/maturity/#maturity","text":"","title":"Maturity"},{"location":"user/maturity/#function-maturity","text":"Feature Maturity Strength Problem Advise User Concurrency control Tested concurrency control On trial Connection control Tested connection number control On trial Connecting certain provider straightly Tested Provider service for point-to-point connecting straightly, for test Can be used in the test environment Alibaba Grouping polymerization Tested Return value of grouping polymerization, service for menu aggregation and other services Used in special scenes Can be used in the production environment Parameters validator Tested parameters validator, JSR303 validation framework integration Have effect on Performance On trial LaiWang Result cache Tested result cache, for accelerating requests On trial Generic reference Stable Generic reference, remote call without a business interface class\uff0cfor test platforms, open api proxy service, and so on Can be used in the production environment Alibaba Generic service Stable Generic service, no interface class is required to implement any interface, for mock platform Can be used in the production environment Alibaba Echo test Tested echo test On trial Attachment Stable Attachment Can be used in the production environment Asynchronous call Tested Unavailable asynchronous call On trial Local call Tested Local call On trial Callback parameter Tested Callback parameter Used in special scenes On trial Registry Events notify Tested Events notify, triggering before and after the remote call is executed On trial Local stub Stable Performing part of the logic on the client side Can be used in the production environment Alibaba Local mock Stable Forged return results, which can be executed when failed or directly executed, for service degradation Need support of registry Can be used in the production environment Alibaba Delay publish Stable Delay publish, used to wait for the application to load warmup data or wait for spring context to load completely Can be used in the production environment Alibaba Lazy connect Tested Delay setting up connections, when invocation is set up On trial Registry Stickness connections Tested Stickness connections, always make a request to the same provider service unless the service is down, and then switch to another On trial Registry Token authorization Tested Token authorization, is used for service authorization Need support of registry On trial Routing rule Tested Dynamically determining the call relationship Need support of registry On trial Configuration rule Tested Distribute the configuration dynamically, is the switch of business logic Need support of registry On trial Accesslog Tested Accesslog, used to record call information Local storage, impact performance, limited by disk size On trial Distributed transaction Research JTA/XA three phase submission transaction(TCC) Unstable Unavailable","title":"Function maturity"},{"location":"user/maturity/#strategy-maturity","text":"Feature Maturity Strength Problem Advise User Zookeeper registry Stable Support the cluster, have various of related open source products, dubbo-2.3.3 and above versions are recommended Depended on the stability of zookeeper Can be used in the production environment Redis registry Stable Support the client - based double - write clustering method with high performance Please ensure server time synchronization, be used to check the expired dirty data of heartbeat Can be used in the production environment Multicast registry Tested Decentration, no registry needs to be installed Depending on the network topology and routing, there is a risk across the server rooms Can be used in a small range, in development/test environment Simple registry Tested Dogfooding, the registry itself is also a standard RPC service No cluster support, may occur single-point failure On trial Feature Maturity Strength Problem Advise User Simple monitor system Stable Support JFreeChart statistics report No cluster support, may occur single-point failure, but the failure does not affect the RPC call Can be used in the production environment Feature Maturity Strength Problem Advise User Dubbo protocol Stable Use NIO to reuse a single long connection and use a thread pool to process requests concurrently, Reduce handshake and increase concurrency efficiency, good performance A single connection will become a bottleneck in the transmission of large files Can be used in the production environment Alibaba Rmi protocol Stable Interoperable with native RMI, based on the TCP protocol Occasionally the connection fails, and the stub needs to be rebuilt Can be used in the production environment Alibaba Hessian protocol Stable Interoperable with native Hessian, based on the HTTP protocol Hessian.jar support is required, and the overhead of HTTP short connections is large Can be used in the production environment Feature Maturity Strength Problem Advise User Netty Transporter Stable The NIO framework of JBoss, has good performance A request sends two events and needs to shield useless events Can be used in the production environment Alibaba Mina Transporter Stable Classic NIO framework\uff0cstable The dispatch of the message queue is not timely, under great pressure, there will be FullGC Can be used in the production environment Alibaba Grizzly Transporter Tested The NIO framework of Sun, applied in the GlassFish container The thread pool is not extensible, and Filter can't intercept the next filter On trial Feature Maturity Strength Problem Advise User Hessian Serialization Stable Good performance, multilingual support (recommended) The compatibility of various versions of Hessian is not good, it may be in conflict with the Hessian used in the application, and the Dubbo is embedded with the source code of the hessian3.2.1 Can be used in the production environment Alibaba Dubbo Serialization Tested The performance is better in a large number of POJO transmission by not transmitting the class information of POJO. When a field is added to the parameter object, an external file declaration is required On trial Json Serialization Tested pure text, can be cross-language parsed, default using FastJson Poor performance On trial Java Serialization Stable Java native support Poor performance Can be used in the production environment Feature Maturity Strength Problem Advise User Javassist ProxyFactory Stable Bytecode generation instead of reflection, good performance(recommended) Depending on the javassist.jar and taking up the JVM's Perm memory, the Perm may have to be larger:java -XX:PermSize=128m Can be used in the production environment Alibaba Jdk ProxyFactory Stable JDK native support Poor performance Can be used in the production environment Feature Maturity Strength Problem Advise User Failover Cluster Stable Failure automatically switches, when failure occurs, retries other servers, usually used for read operations.(recommended) Retry will lead to longer delays Can be used in the production environment Alibaba Failfast Cluster Stable Fast failure, only one call, failure to be reported immediately, usually used for non idempotent writing. If a server is being restarted, a call failure may occur Can be used in the production environment Alibaba Failsafe Cluster Stable Failsafe, when abnormal, directly ignored, usually used to write to the audit log and other operations Call information loss Can be used in the production environment Monitor Failback Cluster Tested Failure auto recovery, backstage record failure request, regular retransmission, usually used for message notification operations Unreliable, lost when restart the server Can be used in the production environment Registry Forking Cluster Tested Multiple servers are invoked in parallel, as long as one success is returned, often used for high real-time reading operations. Need to waste more service resources Can be used in the production environment Broadcast Cluster Tested A broadcast calls all providers, one by one, and any error is wrongly reported, usually used to update the provider's local state The speed is slow, and any false report is wrong. Can be used in the production environment Feature Maturity Strength Problem Advise User Random LoadBalance Stable Random probability, set random probability according to weight(recommended) The probability of a collision on a cross section is high. When retrying, there may be an unequal instantaneous pressure. Can be used in the production environment Alibaba RoundRobin LoadBalance Stable Round Robin, setting wheel based ratio according to the weight after the Convention There is a slow machine accumulation request problem, and extreme circumstances may cause an avalanche Can be used in the production environment LeastActive LoadBalance Stable The least active call number, the random number of the same active number, the active number is the count difference before and after the call, making the slow machine receive less request. Do not support the weight, in the capacity planning, not to pressure a machine oriented pressure measurement by weight capacity Can be used in the production environment ConsistentHash LoadBalance Stable The consistency hash, the same parameters always request to the same provider, when one provider hung, originally sent to the provider's request, based on virtual nodes, spread to other providers, will not cause dramatic changes Uneven distribution of pressure Can be used in the production environment Feature Maturity Strength Problem Advise User Condition routing rule Stable Routing rules based on conditional expressions, simple and easy to use There are some complex multi branch conditions, and the rules are difficult to describe Can be used in the production environment Alibaba Script routing rules Tested Routing rules based on the script engine, powerful No sandbox is running, scripting ability is too powerful and may be the back door On trial Feature Maturity Strength Problem Advise User Spring Container Stable Automatically load all Spring configurations under the META-INF/spring directory Can be used in the production environment Alibaba Jetty Container Stable Start an embedded Jetty for reporting state When a large number of pages are accessed, the threads and memory of the server are affected Can be used in the production environment Alibaba Log4j Container Stable Configuring the configuration of the log4j automatically, automatically subdirecting the log files by process at the startup of multiple processes The user can't control the configuration of log4j, inflexible Can be used in the production environment Alibaba","title":"Strategy maturity"},{"location":"user/perf-test/","text":"Performance test report Test instructions In this performance test, the performance of all Dubbo 2.0 supported protocols in different sizes and data types is tested and compared with the Dubbo 1.0. The overall performance is increased by 1.0 compared with 10%, and the average increase is 10%. The performance improvement of 10%~50% can also be achieved by using the new Dubbo serialization of Dubbo 2.0 . In the stability test, because the underlying communication framework is changed from Mina to netty, the growth of objects in old area is greatly reduced, and the 50 hour operation increases less than 200m and no fullgc. There is a problem: performance of 2.0 is less than 1.0 in 50K data, and it is doubted that it may be a buffer setting problem, and the next version will be further confirmed. Test environment Hardware deployment and parameter adjustment Model CPU Memory Network Disk Kernel Tecal BH620 model name : Intel(R) Xeon(R) CPU E5520 @ 2.27GHz cache size : 8192 KB processor_count : 16 Total System Memory: 6G Hardware Memory Info: Size: 4096MB eth0: Link is up at 1000 Mbps, full duplex. peth0: Link is up at 1000 Mbps, full duplex. /dev/sda: 597.9 GB 2.6.18-128.el5xen x86_64 Software architecture Software name and version key parameter java version \"1.6.0_18\" Java(TM) SE Runtime Environment (build 1.6.0_18-b07) Java HotSpot(TM) 64-Bit Server VM (build 16.0-b13, mixed mode) -server -Xmx2g -Xms2g -Xmn256m -XX:PermSize=128m -Xss256k -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 jboss-4.0.5.GA httpd-2.0.61 KeepAlive On MaxKeepAliveRequests 100000 KeepAliveTimeout 180 MaxRequestsPerChild 1000000 StartServers 5 MaxClients 1024 MinSpareThreads 25 MaxSpareThreads 75 ThreadsPerChild 64 ThreadLimit 128 ServerLimit 16 Test purpose Expected performance indicators (quantized) Scene name Corresponding index name Range of expected values Actual value Whether or not to meet expectations (yes / no) 1k data Response time 0.9ms 0.79ms Yes 1k data TPS 10000 11994 Yes Expected operating conditions (non quantified, optional) The performance of 2.0 is not less than 1, and the performance of the intermodulation of 2.0 and 1.0 is not significantly reduced. In addition to 50K string, the rest are passed JVM memory is running stable, no OOM, and there is no reasonable large object in the heap memory. Passed CPU, memory, network, disk, file handle are occupied smoothly. Passed There is no frequent thread lock, and the number of threads is stable. Passed Business thread load balance. Passed Test script Performance test scence (10 concurrency) Pass in 1K String, do not do anything, return the original Pass in 50K String, do not do anything, return the original Pass in 200K String, do not do anything, return the original Incoming 1K POJO (nested complex person objects) without any processing, return to the original The above scenario is tested for 10 minutes in Dubbo 1.0, Dubbo 2.0 (hessian2 serialization), Dubbo 2.0 (Dubbo serialization), RMI, Hessian 3.2.0, HTTP (JSON serialization). It mainly examines the performance of serialization and network IO, so the server has no business logic. 10 is to consider the concurrent HTTP protocol in high with the use of CPU high rate may hit the bottleneck. 1. Concurrent scene (20 concurrency) 1K String is introduced into the server segment for 1W times, and a random number is regenerated each time and then assembled. Examine whether business threads can be assigned to each CPU. Stability scence (20 concurrency) At the same time, we call the 1 parameter String (5K) method, the 1 parameter is the person object method, the 1 parameter is map (the value is 3 person), and it runs for 50 hours continuously. High pressure scene (20 concurrency) On the basis of the stability scenario, the providers and consumers are arranged into 2 sets (one machine and 2 instances), and the parameters of String are 20byte to 200K, and are randomly transformed every 10 minutes. Test result Scene name: scence POJO TPS success avg value Response time avg value(ms) dubbo1 (hessian2 serialization+mina) 10813.5 0.9 dubbo2 (hessian2 serialization+netty) 11994 0.79 dubbo2 (dubbo serialization+netty) 13620 0.67 rmi 2461.79 4 hessian 2417.7 4.1 http\uff08json serialization\uff09 8179.08 1.15 The default percentage of 2.0 and 1.0 10.92 -12.22 Dubbo serialization compared to the percentage of hessian2 serialization 13.56 -15.19 POJO TPS POJO Response Scene name: scence 1k string TPS success avg value Response time avg value(ms) dubbo1\uff08hessian2 serialization+mina\uff09 11940 0.8 dubbo2 (hessian2 serialization+netty) 14402 0.64 dubbo2 (dubbo serialization+netty) 15096 0.6 rmi 11136.02 0.81 hessian 11426.83 0.79 http\uff08json serialization\uff09 8919.27 1.04 The default percentage of 2.0 and 1.0 20.62 -20.00 Dubbo serialization compared to the percentage of hessian2 serialization 4.82 -6.25 1k TPS 1k Response Scene name: scence 50k string TPS success avg value Response time avg value(ms) dubbo1\uff08hessian2 serialization+mina 1962.7 dubbo2 (hessian2 serialization+netty) 1293 dubbo2 (dubbo serialization+netty) 1966 rmi 3349.88 hessian 1925.33 http\uff08json serialization\uff09 3247.1 The default percentage of 2.0 and 1.0 -34.12 Dubbo serialization compared to the percentage of hessian2 serialization 52.05 50K TPS 50K Response Scene name: scence 200k string TPS success avg value Response time avg value(ms) dubbo1\uff08hessian2 serialization+mina\uff09 324.2 dubbo2 (hessian2 serialization+netty) 362.92 dubbo2 (dubbo serialization+netty) 569.5 rmi 1031.28 hessian 628.06 http\uff08json serialization\uff09 1011.97 The default percentage of 2.0 and 1.0 11.94 Dubbo serialization compared to the percentage of hessian2 serialization 56.92 200K TPS 200K Response Test analysis Performance analysis and evaluation The performance test conclusion of Dubbo 2 has been improved and improved from performance, memory footprint and stability. Because of its memory management, the change of Mina into netty greatly reduces the 1 version of the large memory sawtooth in high concurrency and large data. Performance comparison analysis (new and old environment, different data magnitude, etc.) The performance of Dubbo 2 is compared with that of Dubbo 1, which is all hessian2 serialization. The performance is improved (except for 50K String). See the performance data of the fifth chapter in detail. For compatibility default serialization and 1 consistent with hessian2, such as have higher requirements on the performance of Dubbo serialization can be used, which is in the process of complicated object, can be obtained in 50% large data upgrade (but it is not recommended for use Dubbo protocol). The purpose of Dubbo is to meet the RPC calls with high concurrent and small data volume. The performance is not good under large data volume. It is recommended to use RMI or HTTP protocol. Test limitation analysis (optional) This performance test examines the performance of the Dubbo itself, and the performance of the actual use needs to be verified. Because the performance of Dubbo itself is in millisecond and the base number is small, performance improvement may not change the performance of the application as a whole. All the monitoring charts are not listed because of the limit of length.","title":"Benchmark"},{"location":"user/perf-test/#performance-test-report","text":"","title":"Performance test report"},{"location":"user/perf-test/#test-instructions","text":"In this performance test, the performance of all Dubbo 2.0 supported protocols in different sizes and data types is tested and compared with the Dubbo 1.0. The overall performance is increased by 1.0 compared with 10%, and the average increase is 10%. The performance improvement of 10%~50% can also be achieved by using the new Dubbo serialization of Dubbo 2.0 . In the stability test, because the underlying communication framework is changed from Mina to netty, the growth of objects in old area is greatly reduced, and the 50 hour operation increases less than 200m and no fullgc. There is a problem: performance of 2.0 is less than 1.0 in 50K data, and it is doubted that it may be a buffer setting problem, and the next version will be further confirmed.","title":"Test instructions"},{"location":"user/perf-test/#test-environment","text":"","title":"Test environment"},{"location":"user/perf-test/#hardware-deployment-and-parameter-adjustment","text":"Model CPU Memory Network Disk Kernel Tecal BH620 model name : Intel(R) Xeon(R) CPU E5520 @ 2.27GHz cache size : 8192 KB processor_count : 16 Total System Memory: 6G Hardware Memory Info: Size: 4096MB eth0: Link is up at 1000 Mbps, full duplex. peth0: Link is up at 1000 Mbps, full duplex. /dev/sda: 597.9 GB 2.6.18-128.el5xen x86_64","title":"Hardware deployment and parameter adjustment"},{"location":"user/perf-test/#software-architecture","text":"Software name and version key parameter java version \"1.6.0_18\" Java(TM) SE Runtime Environment (build 1.6.0_18-b07) Java HotSpot(TM) 64-Bit Server VM (build 16.0-b13, mixed mode) -server -Xmx2g -Xms2g -Xmn256m -XX:PermSize=128m -Xss256k -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 jboss-4.0.5.GA httpd-2.0.61 KeepAlive On MaxKeepAliveRequests 100000 KeepAliveTimeout 180 MaxRequestsPerChild 1000000 StartServers 5 MaxClients 1024 MinSpareThreads 25 MaxSpareThreads 75 ThreadsPerChild 64 ThreadLimit 128 ServerLimit 16","title":"Software architecture"},{"location":"user/perf-test/#test-purpose","text":"","title":"Test purpose"},{"location":"user/perf-test/#expected-performance-indicators-quantized","text":"Scene name Corresponding index name Range of expected values Actual value Whether or not to meet expectations (yes / no) 1k data Response time 0.9ms 0.79ms Yes 1k data TPS 10000 11994 Yes","title":"Expected performance indicators (quantized)"},{"location":"user/perf-test/#expected-operating-conditions-non-quantified-optional","text":"The performance of 2.0 is not less than 1, and the performance of the intermodulation of 2.0 and 1.0 is not significantly reduced. In addition to 50K string, the rest are passed JVM memory is running stable, no OOM, and there is no reasonable large object in the heap memory. Passed CPU, memory, network, disk, file handle are occupied smoothly. Passed There is no frequent thread lock, and the number of threads is stable. Passed Business thread load balance. Passed","title":"Expected operating conditions (non quantified, optional)"},{"location":"user/perf-test/#test-script","text":"Performance test scence (10 concurrency) Pass in 1K String, do not do anything, return the original Pass in 50K String, do not do anything, return the original Pass in 200K String, do not do anything, return the original Incoming 1K POJO (nested complex person objects) without any processing, return to the original The above scenario is tested for 10 minutes in Dubbo 1.0, Dubbo 2.0 (hessian2 serialization), Dubbo 2.0 (Dubbo serialization), RMI, Hessian 3.2.0, HTTP (JSON serialization). It mainly examines the performance of serialization and network IO, so the server has no business logic. 10 is to consider the concurrent HTTP protocol in high with the use of CPU high rate may hit the bottleneck. 1. Concurrent scene (20 concurrency) 1K String is introduced into the server segment for 1W times, and a random number is regenerated each time and then assembled. Examine whether business threads can be assigned to each CPU. Stability scence (20 concurrency) At the same time, we call the 1 parameter String (5K) method, the 1 parameter is the person object method, the 1 parameter is map (the value is 3 person), and it runs for 50 hours continuously. High pressure scene (20 concurrency) On the basis of the stability scenario, the providers and consumers are arranged into 2 sets (one machine and 2 instances), and the parameters of String are 20byte to 200K, and are randomly transformed every 10 minutes.","title":"Test script"},{"location":"user/perf-test/#test-result","text":"","title":"Test result"},{"location":"user/perf-test/#scene-name-scence-pojo","text":"TPS success avg value Response time avg value(ms) dubbo1 (hessian2 serialization+mina) 10813.5 0.9 dubbo2 (hessian2 serialization+netty) 11994 0.79 dubbo2 (dubbo serialization+netty) 13620 0.67 rmi 2461.79 4 hessian 2417.7 4.1 http\uff08json serialization\uff09 8179.08 1.15 The default percentage of 2.0 and 1.0 10.92 -12.22 Dubbo serialization compared to the percentage of hessian2 serialization 13.56 -15.19 POJO TPS POJO Response","title":"Scene name: scence POJO"},{"location":"user/perf-test/#scene-name-scence-1k-string","text":"TPS success avg value Response time avg value(ms) dubbo1\uff08hessian2 serialization+mina\uff09 11940 0.8 dubbo2 (hessian2 serialization+netty) 14402 0.64 dubbo2 (dubbo serialization+netty) 15096 0.6 rmi 11136.02 0.81 hessian 11426.83 0.79 http\uff08json serialization\uff09 8919.27 1.04 The default percentage of 2.0 and 1.0 20.62 -20.00 Dubbo serialization compared to the percentage of hessian2 serialization 4.82 -6.25 1k TPS 1k Response","title":"Scene name: scence 1k string"},{"location":"user/perf-test/#scene-name-scence-50k-string","text":"TPS success avg value Response time avg value(ms) dubbo1\uff08hessian2 serialization+mina 1962.7 dubbo2 (hessian2 serialization+netty) 1293 dubbo2 (dubbo serialization+netty) 1966 rmi 3349.88 hessian 1925.33 http\uff08json serialization\uff09 3247.1 The default percentage of 2.0 and 1.0 -34.12 Dubbo serialization compared to the percentage of hessian2 serialization 52.05 50K TPS 50K Response","title":"Scene name: scence 50k string"},{"location":"user/perf-test/#scene-name-scence-200k-string","text":"TPS success avg value Response time avg value(ms) dubbo1\uff08hessian2 serialization+mina\uff09 324.2 dubbo2 (hessian2 serialization+netty) 362.92 dubbo2 (dubbo serialization+netty) 569.5 rmi 1031.28 hessian 628.06 http\uff08json serialization\uff09 1011.97 The default percentage of 2.0 and 1.0 11.94 Dubbo serialization compared to the percentage of hessian2 serialization 56.92 200K TPS 200K Response","title":"Scene name: scence 200k string"},{"location":"user/perf-test/#test-analysis","text":"","title":"Test analysis"},{"location":"user/perf-test/#performance-analysis-and-evaluation","text":"The performance test conclusion of Dubbo 2 has been improved and improved from performance, memory footprint and stability. Because of its memory management, the change of Mina into netty greatly reduces the 1 version of the large memory sawtooth in high concurrency and large data.","title":"Performance analysis and evaluation"},{"location":"user/perf-test/#performance-comparison-analysis-new-and-old-environment-different-data-magnitude-etc","text":"The performance of Dubbo 2 is compared with that of Dubbo 1, which is all hessian2 serialization. The performance is improved (except for 50K String). See the performance data of the fifth chapter in detail. For compatibility default serialization and 1 consistent with hessian2, such as have higher requirements on the performance of Dubbo serialization can be used, which is in the process of complicated object, can be obtained in 50% large data upgrade (but it is not recommended for use Dubbo protocol). The purpose of Dubbo is to meet the RPC calls with high concurrent and small data volume. The performance is not good under large data volume. It is recommended to use RMI or HTTP protocol.","title":"Performance comparison analysis (new and old environment, different data magnitude, etc.)"},{"location":"user/perf-test/#test-limitation-analysis-optional","text":"This performance test examines the performance of the Dubbo itself, and the performance of the actual use needs to be verified. Because the performance of Dubbo itself is in millisecond and the base number is small, performance improvement may not change the performance of the application as a whole. All the monitoring charts are not listed because of the limit of length.","title":"Test limitation analysis (optional)"},{"location":"user/quick-start/","text":"Quick start The most common way to use Dubbo is to run it in Spring framework. The following content will guide you to develop a Dubbo application with Spring framework's XML configuration . If you don't want to rely on Spring, you can try using API configuration . First let's create a root directory called dubbo-demo: mkdir dubbo-demo cd dubbo-demo Next, we are going to create 3 sub-directories under root directory: dubbo-demo-api: the common service api dubbo-demo-provider: the demo provider codes dubbo-demo-consumer: the demo consumer codes Service provider Defining service interfaces DemoService.java [^1]\uff1a package org.apache.dubbo.demo; public interface DemoService { String sayHello(String name); } The project structure should look like this: . \u251c\u2500\u2500 dubbo-demo-api \u2502 \u251c\u2500\u2500 pom.xml \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 main \u2502 \u2514\u2500\u2500 java \u2502 \u2514\u2500\u2500 org \u2502 \u2514\u2500\u2500 apache \u2502 \u2514\u2500\u2500 dubbo \u2502 \u2514\u2500\u2500 demo \u2502 \u2514\u2500\u2500 DemoService.java Implement interface in service provider DemoServiceImpl.java [^2]\uff1a package org.apache.dubbo.demo.provider; import org.apache.dubbo.demo.DemoService; public class DemoServiceImpl implements DemoService { public String sayHello(String name) { return Hello + name; } } Exposing service with Spring configuration provider.xml\uff1a beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xmlns= http://www.springframework.org/schema/beans xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd !-- provider's application name, used for tracing dependency relationship -- dubbo:application name= demo-provider / !-- use multicast registry center to export service -- dubbo:registry address= multicast://224.5.6.7:1234 / !-- use dubbo protocol to export service on port 20880 -- dubbo:protocol name= dubbo port= 20880 / !-- service implementation, as same as regular local bean -- bean id= demoService class= org.apache.dubbo.demo.provider.DemoServiceImpl / !-- declare the service interface to be exported -- dubbo:service interface= org.apache.dubbo.demo.DemoService ref= demoService / /beans The demo uses multicast as the registry since it is simple and does not require to extra installation. If you prefer a registry like zookeeper, please check out examples here . Configure the logging system Dubbo use log4j as logging system by default, it also support slf4j, Apache Commons Logging, and JUL logging. Following is a sample configuration: log4j.properties ###set log levels### log4j.rootLogger=info, stdout ###output to the console### log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target=System.out log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=[%d{dd/MM/yy hh:mm:ss:sss z}] %t %5p %c{2}: %m%n Bootstrap the service provider Provider.java package org.apache.dubbo.demo.provider; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Provider { public static void main(String[] args) throws Exception { System.setProperty( java.net.preferIPv4Stack , true ); ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{ META-INF/spring/dubbo-demo-provider.xml }); context.start(); System.out.println( Provider started. ); System.in.read(); // press any key to exit } } Finally, the project structure should look like this: \u251c\u2500\u2500 dubbo-demo-provider \u2502 \u251c\u2500\u2500 pom.xml \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 main \u2502 \u251c\u2500\u2500 java \u2502 \u2502 \u2514\u2500\u2500 org \u2502 \u2502 \u2514\u2500\u2500 apache \u2502 \u2502 \u2514\u2500\u2500 dubbo \u2502 \u2502 \u2514\u2500\u2500 demo \u2502 \u2502 \u2514\u2500\u2500 provider \u2502 \u2502 \u251c\u2500\u2500 DemoServiceImpl.java \u2502 \u2502 \u2514\u2500\u2500 Provider.java \u2502 \u2514\u2500\u2500 resources \u2502 \u251c\u2500\u2500 META-INF \u2502 \u2502 \u2514\u2500\u2500 spring \u2502 \u2502 \u2514\u2500\u2500 dubbo-demo-provider.xml \u2502 \u2514\u2500\u2500 log4j.properties Service consumer Complete installation steps, see\uff1a Consumer demo installation Using the Spring configuration to reference a remote service consumer.xml\uff1a ?xml version= 1.0 encoding= UTF-8 ? beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xmlns= http://www.springframework.org/schema/beans xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd !-- consumer's application name, used for tracing dependency relationship (not a matching criterion), don't set it same as provider -- dubbo:application name= demo-consumer / !-- use multicast registry center to discover service -- dubbo:registry address= multicast://224.5.6.7:1234 / !-- generate proxy for the remote service, then demoService can be used in the same way as the local regular interface -- dubbo:reference id= demoService check= false interface= org.apache.dubbo.demo.DemoService / /beans Bootstrap the consumer Consumer.java [^3]\uff1a import org.springframework.context.support.ClassPathXmlApplicationContext; import org.apache.dubbo.demo.DemoService; public class Consumer { public static void main(String[] args) throws Exception { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] { META-INF/spring/dubbo-demo-consumer.xml }); context.start(); // Obtaining a remote service proxy DemoService demoService = (DemoService)context.getBean( demoService ); // Executing remote methods String hello = demoService.sayHello( world ); // Display the call result System.out.println(hello); } } Config the logging system This is the same as how to config it on provider side. Finally, the project structure should be look like this: \u251c\u2500\u2500 dubbo-demo-consumer \u2502 \u251c\u2500\u2500 pom.xml \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 main \u2502 \u251c\u2500\u2500 java \u2502 \u2502 \u2514\u2500\u2500 org \u2502 \u2502 \u2514\u2500\u2500 apache \u2502 \u2502 \u2514\u2500\u2500 dubbo \u2502 \u2502 \u2514\u2500\u2500 demo \u2502 \u2502 \u2514\u2500\u2500 consumer \u2502 \u2502 \u2514\u2500\u2500 Consumer.java \u2502 \u2514\u2500\u2500 resources \u2502 \u251c\u2500\u2500 META-INF \u2502 \u2502 \u2514\u2500\u2500 spring \u2502 \u2502 \u2514\u2500\u2500 dubbo-demo-consumer.xml \u2502 \u2514\u2500\u2500 log4j.properties Start the demo Start service provider Run the org.apache.dubbo.demo.provider.Provider class to start the provider. Start service consumer Run the org.apache.dubbo.demo.provider.Consumer class to start the consumer, and you should be able to see the following result: Hello world Complete example You can find the complete example code in the Github repository. Provider demo Consumer demo [^1]: The interface needs to be packaged separately, shared by the service provider and the consumer [^2]: Hidden realization of service consumer [^3]: IoC injection can also be used","title":"Quick Start"},{"location":"user/quick-start/#quick-start","text":"The most common way to use Dubbo is to run it in Spring framework. The following content will guide you to develop a Dubbo application with Spring framework's XML configuration . If you don't want to rely on Spring, you can try using API configuration . First let's create a root directory called dubbo-demo: mkdir dubbo-demo cd dubbo-demo Next, we are going to create 3 sub-directories under root directory: dubbo-demo-api: the common service api dubbo-demo-provider: the demo provider codes dubbo-demo-consumer: the demo consumer codes","title":"Quick start"},{"location":"user/quick-start/#service-provider","text":"","title":"Service provider"},{"location":"user/quick-start/#defining-service-interfaces","text":"DemoService.java [^1]\uff1a package org.apache.dubbo.demo; public interface DemoService { String sayHello(String name); } The project structure should look like this: . \u251c\u2500\u2500 dubbo-demo-api \u2502 \u251c\u2500\u2500 pom.xml \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 main \u2502 \u2514\u2500\u2500 java \u2502 \u2514\u2500\u2500 org \u2502 \u2514\u2500\u2500 apache \u2502 \u2514\u2500\u2500 dubbo \u2502 \u2514\u2500\u2500 demo \u2502 \u2514\u2500\u2500 DemoService.java","title":"Defining service interfaces"},{"location":"user/quick-start/#implement-interface-in-service-provider","text":"DemoServiceImpl.java [^2]\uff1a package org.apache.dubbo.demo.provider; import org.apache.dubbo.demo.DemoService; public class DemoServiceImpl implements DemoService { public String sayHello(String name) { return Hello + name; } }","title":"Implement interface in service provider"},{"location":"user/quick-start/#exposing-service-with-spring-configuration","text":"provider.xml\uff1a beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xmlns= http://www.springframework.org/schema/beans xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd !-- provider's application name, used for tracing dependency relationship -- dubbo:application name= demo-provider / !-- use multicast registry center to export service -- dubbo:registry address= multicast://224.5.6.7:1234 / !-- use dubbo protocol to export service on port 20880 -- dubbo:protocol name= dubbo port= 20880 / !-- service implementation, as same as regular local bean -- bean id= demoService class= org.apache.dubbo.demo.provider.DemoServiceImpl / !-- declare the service interface to be exported -- dubbo:service interface= org.apache.dubbo.demo.DemoService ref= demoService / /beans The demo uses multicast as the registry since it is simple and does not require to extra installation. If you prefer a registry like zookeeper, please check out examples here .","title":"Exposing service with Spring configuration"},{"location":"user/quick-start/#configure-the-logging-system","text":"Dubbo use log4j as logging system by default, it also support slf4j, Apache Commons Logging, and JUL logging. Following is a sample configuration: log4j.properties ###set log levels### log4j.rootLogger=info, stdout ###output to the console### log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target=System.out log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=[%d{dd/MM/yy hh:mm:ss:sss z}] %t %5p %c{2}: %m%n","title":"Configure the logging system"},{"location":"user/quick-start/#bootstrap-the-service-provider","text":"Provider.java package org.apache.dubbo.demo.provider; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Provider { public static void main(String[] args) throws Exception { System.setProperty( java.net.preferIPv4Stack , true ); ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{ META-INF/spring/dubbo-demo-provider.xml }); context.start(); System.out.println( Provider started. ); System.in.read(); // press any key to exit } } Finally, the project structure should look like this: \u251c\u2500\u2500 dubbo-demo-provider \u2502 \u251c\u2500\u2500 pom.xml \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 main \u2502 \u251c\u2500\u2500 java \u2502 \u2502 \u2514\u2500\u2500 org \u2502 \u2502 \u2514\u2500\u2500 apache \u2502 \u2502 \u2514\u2500\u2500 dubbo \u2502 \u2502 \u2514\u2500\u2500 demo \u2502 \u2502 \u2514\u2500\u2500 provider \u2502 \u2502 \u251c\u2500\u2500 DemoServiceImpl.java \u2502 \u2502 \u2514\u2500\u2500 Provider.java \u2502 \u2514\u2500\u2500 resources \u2502 \u251c\u2500\u2500 META-INF \u2502 \u2502 \u2514\u2500\u2500 spring \u2502 \u2502 \u2514\u2500\u2500 dubbo-demo-provider.xml \u2502 \u2514\u2500\u2500 log4j.properties","title":"Bootstrap the service provider"},{"location":"user/quick-start/#service-consumer","text":"Complete installation steps, see\uff1a Consumer demo installation","title":"Service consumer"},{"location":"user/quick-start/#using-the-spring-configuration-to-reference-a-remote-service","text":"consumer.xml\uff1a ?xml version= 1.0 encoding= UTF-8 ? beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xmlns= http://www.springframework.org/schema/beans xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd !-- consumer's application name, used for tracing dependency relationship (not a matching criterion), don't set it same as provider -- dubbo:application name= demo-consumer / !-- use multicast registry center to discover service -- dubbo:registry address= multicast://224.5.6.7:1234 / !-- generate proxy for the remote service, then demoService can be used in the same way as the local regular interface -- dubbo:reference id= demoService check= false interface= org.apache.dubbo.demo.DemoService / /beans","title":"Using the Spring configuration to reference a remote service"},{"location":"user/quick-start/#bootstrap-the-consumer","text":"Consumer.java [^3]\uff1a import org.springframework.context.support.ClassPathXmlApplicationContext; import org.apache.dubbo.demo.DemoService; public class Consumer { public static void main(String[] args) throws Exception { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] { META-INF/spring/dubbo-demo-consumer.xml }); context.start(); // Obtaining a remote service proxy DemoService demoService = (DemoService)context.getBean( demoService ); // Executing remote methods String hello = demoService.sayHello( world ); // Display the call result System.out.println(hello); } }","title":"Bootstrap the consumer"},{"location":"user/quick-start/#config-the-logging-system","text":"This is the same as how to config it on provider side. Finally, the project structure should be look like this: \u251c\u2500\u2500 dubbo-demo-consumer \u2502 \u251c\u2500\u2500 pom.xml \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 main \u2502 \u251c\u2500\u2500 java \u2502 \u2502 \u2514\u2500\u2500 org \u2502 \u2502 \u2514\u2500\u2500 apache \u2502 \u2502 \u2514\u2500\u2500 dubbo \u2502 \u2502 \u2514\u2500\u2500 demo \u2502 \u2502 \u2514\u2500\u2500 consumer \u2502 \u2502 \u2514\u2500\u2500 Consumer.java \u2502 \u2514\u2500\u2500 resources \u2502 \u251c\u2500\u2500 META-INF \u2502 \u2502 \u2514\u2500\u2500 spring \u2502 \u2502 \u2514\u2500\u2500 dubbo-demo-consumer.xml \u2502 \u2514\u2500\u2500 log4j.properties","title":"Config the logging system"},{"location":"user/quick-start/#start-the-demo","text":"","title":"Start the demo"},{"location":"user/quick-start/#start-service-provider","text":"Run the org.apache.dubbo.demo.provider.Provider class to start the provider.","title":"Start service provider"},{"location":"user/quick-start/#start-service-consumer","text":"Run the org.apache.dubbo.demo.provider.Consumer class to start the consumer, and you should be able to see the following result: Hello world","title":"Start service consumer"},{"location":"user/quick-start/#complete-example","text":"You can find the complete example code in the Github repository. Provider demo Consumer demo [^1]: The interface needs to be packaged separately, shared by the service provider and the consumer [^2]: Hidden realization of service consumer [^3]: IoC injection can also be used","title":"Complete example"},{"location":"user/recommend/","text":"Recommended usage Configuring the attributes of the consumer side as much as possible on the provider side the reason is\uff1a Service providers are more aware of service performance parameters than service users\uff0cSuch as the timeout time of the call, the reasonable retry times, and so on. If a attribute is configurated in provider side, not configurated in consumer side, consumer service will use the attribute in provider side. That is to say, the provider side's attribute can be used as consumer's default value [^1]. Otherwise, consumer service will use consumer-side's attribute\uff0cbut can't cnotrol the provider service,it's usually unreasonable. Configuring the attributes of the consumer side as much as possible on the provider side\uff0cMake the provider service developer think more about the characteristics and quality of the provider side service. Examples\uff1a dubbo:service interface= com.alibaba.hello.api.HelloService version= 1.0.0 ref= helloService timeout= 300 retry= 2 loadbalance= random actives= 0 / dubbo:service interface= com.alibaba.hello.api.WorldService version= 1.0.0 ref= helloService timeout= 300 retry= 2 loadbalance= random actives= 0 dubbo:method name= findAllPerson timeout= 10000 retries= 9 loadbalance= leastactive actives= 5 / dubbo:service/ The consumer side properties that can be configured on provider are\uff1a timeout Method call timeout retries The number of failed retries, default value is 1 [^2] loadbalance Load balance algorithm [^3]\uff0cdefault algorithm is random random ,and polling roundrobin \u3001least active [^4] leastactive actives Consumer side, maximum concurrent call limitation. That is , when the concurrent requests of consumer service reach maximum configuration,the new call will wait until to catch a timeout error. Configurated in dubbo:method (method level configuration) , then the concurrent limitation point at method.Configurated in dubbo:service (service level configuration),then the concurrent limitation point at service. Detailed configuration instructions see\uff1a Dubbo configuration introduction Configuring reasonable provider end properties on provider dubbo:protocol threads= 200 / dubbo:service interface= com.alibaba.hello.api.HelloService version= 1.0.0 ref= helloService executes= 200 dubbo:method name= findAllPerson executes= 50 / /dubbo:service The provider side properties that can be configured on provider service are\uff1a threads service thread pool size executes If concurrent requests number that a provider service handled reach the maximum thead pool count , the new call will wait,then the consumer call may catch a timeout error. Configurated in dubbo:method (method level configuration) , then the concurrent limitation point at method.Configurated in dubbo:service (service level configuration),then the concurrent limitation point at service. Configuration management information Now we have the owner information and organization infomation to differentiate the sites\u3002It's easy to contact with the service owners when there is a problem, please write at least two persons for backup. The information of owners and organizations can be seen in the registry. application configuration owners,organizations: dubbo:application owner=\u201dding.lid,william.liangf\u201d organization=\u201dintl\u201d / service configuration owners: dubbo:service owner=\u201dding.lid,william.liangf\u201d / reference configuration owners: dubbo:reference owner=\u201dding.lid,william.liangf\u201d / dubbo:service \u3001 dubbo:reference have no configuration owner, then use the owner configured in dubbo:application . Set up the Dubbo cache file Provider service list caching file: dubbo:registry file=\u201d${user.home}/output/dubbo.cache\u201d / Notations: You can modify the cahe file path of the application according to the needs. Ensure that the file will not be cleared during the release process. If there are more than one application process, do not use the same file path to avoid the content being overwritten. This file caches the list of the registry and the list of service providers. With this configuration, when the application is restarted , if the Dubbo registry is not available, the application will read the information from the service provider list from the cache file. That can ensure the availability of the application. Monitor configuration Expose service with a fixed port, instead of using a random port In this way, when there is a delay in the registry push, the consumer can also call the original provider service address hrough the cache list and succeed\u3002 Use Dragoon's HTTP monitoring item to monitor the service provider on the registry The state of Dragoon monitoring service in the registry : http://dubbo-reg1.hst.xyi.cn.alidc.net:8080/status/com.alibaba.morgan.member.MemberService:1.0.5 Ensure that the service exists on the registry . Service provider,use Dragoon's telnet mommand or shell monitor command Monitoring service provider port status \uff1a echo status | nc -i 1 20880 | grep OK | wc -l , 20880 is the service port Service consumer side, cast the service to EchoService\uff0cand call $echo() to test whether the provider of the service is available eg: assertEqauls(\u201cOK\u201d, ((EchoService)memberService).$echo(\u201cOK\u201d)); Don't use the configuration of dubbo.properties file, suggeset to use the configuration of XML All of the configuration items in the dubbo can be configured in the spring configuration file,and can be configured for a single service. The Dubbo default value is used if completely not set up , please see the instructions in the article Dubbo configuration introduction . The relation between attribute name of dubbo.properties and XML application name dubbo.application.name xml dubbo:application name=\"myalibaba\" registry address dubbo.registry.address xml dubbo:registry address=\"11.22.33.44:9090\" call timeout dubbo.service.*.timeout Timeout can be set in multiple configuration items timeout ,cover from top to bottom \uff08The top one have a higher priority \uff09[^5]\uff0cThe coverage strategy of other parameters\uff08 retries \u3001 loadbalance \u3001 actives and so on\uff09is\uff1a Certain method Configuration of a provider service xml dubbo:service interface=\"com.alibaba.xxx.XxxService\" dubbo:method name=\"findPerson\" timeout=\"1000\" / /dubbo:service Configuration of a provider specific interface xml dubbo:service interface=\"com.alibaba.xxx.XxxService\" timeout=\"200\" / Service provider protocol dubbo.service.protocol \u3001Service monitor port dubbo.service.server.port xml dubbo:protocol name=\"dubbo\" port=\"20880\" / Service thread pool size dubbo.service.max.thread.threads.size xml dubbo:protocol threads=\"100\" / No provider throws exceptions (Fast-Fail) when the consumer is started () alibaba.intl.commons.dubbo.service.allow.no.provider xml dubbo:reference interface=\"com.alibaba.xxx.XxxService\" check=\"false\" / [^1]: Overlay rules for configuration: 1) The method level configuration has a higher priority than the interface level, that is to say,small scope have a high priority 2) Consumer side configuration has a higher priority than provider side, better than global configuration, the last one is the Dubbo hard coded configuration value\uff08 Dubbo configuration introduction \uff09 [^2]: With the first call, the call will be called 3 times [^3]: How to select a service to call when there are multiple Provider services [^4]: It means that consumer service can call the best provider service, and reduce to call the the slow provider service. [^5]: timeout Can be set in multiple places, configuration items and overlay rules\uff1a Dubbo Schema configuration introduction","title":"Recommendation"},{"location":"user/recommend/#recommended-usage","text":"","title":"Recommended usage"},{"location":"user/recommend/#configuring-the-attributes-of-the-consumer-side-as-much-as-possible-on-the-provider-side","text":"the reason is\uff1a Service providers are more aware of service performance parameters than service users\uff0cSuch as the timeout time of the call, the reasonable retry times, and so on. If a attribute is configurated in provider side, not configurated in consumer side, consumer service will use the attribute in provider side. That is to say, the provider side's attribute can be used as consumer's default value [^1]. Otherwise, consumer service will use consumer-side's attribute\uff0cbut can't cnotrol the provider service,it's usually unreasonable. Configuring the attributes of the consumer side as much as possible on the provider side\uff0cMake the provider service developer think more about the characteristics and quality of the provider side service. Examples\uff1a dubbo:service interface= com.alibaba.hello.api.HelloService version= 1.0.0 ref= helloService timeout= 300 retry= 2 loadbalance= random actives= 0 / dubbo:service interface= com.alibaba.hello.api.WorldService version= 1.0.0 ref= helloService timeout= 300 retry= 2 loadbalance= random actives= 0 dubbo:method name= findAllPerson timeout= 10000 retries= 9 loadbalance= leastactive actives= 5 / dubbo:service/ The consumer side properties that can be configured on provider are\uff1a timeout Method call timeout retries The number of failed retries, default value is 1 [^2] loadbalance Load balance algorithm [^3]\uff0cdefault algorithm is random random ,and polling roundrobin \u3001least active [^4] leastactive actives Consumer side, maximum concurrent call limitation. That is , when the concurrent requests of consumer service reach maximum configuration,the new call will wait until to catch a timeout error. Configurated in dubbo:method (method level configuration) , then the concurrent limitation point at method.Configurated in dubbo:service (service level configuration),then the concurrent limitation point at service. Detailed configuration instructions see\uff1a Dubbo configuration introduction","title":"Configuring the attributes of the consumer side as much as possible on the provider side"},{"location":"user/recommend/#configuring-reasonable-provider-end-properties-on-provider","text":"dubbo:protocol threads= 200 / dubbo:service interface= com.alibaba.hello.api.HelloService version= 1.0.0 ref= helloService executes= 200 dubbo:method name= findAllPerson executes= 50 / /dubbo:service The provider side properties that can be configured on provider service are\uff1a threads service thread pool size executes If concurrent requests number that a provider service handled reach the maximum thead pool count , the new call will wait,then the consumer call may catch a timeout error. Configurated in dubbo:method (method level configuration) , then the concurrent limitation point at method.Configurated in dubbo:service (service level configuration),then the concurrent limitation point at service.","title":"Configuring reasonable provider end properties on provider"},{"location":"user/recommend/#configuration-management-information","text":"Now we have the owner information and organization infomation to differentiate the sites\u3002It's easy to contact with the service owners when there is a problem, please write at least two persons for backup. The information of owners and organizations can be seen in the registry. application configuration owners,organizations: dubbo:application owner=\u201dding.lid,william.liangf\u201d organization=\u201dintl\u201d / service configuration owners: dubbo:service owner=\u201dding.lid,william.liangf\u201d / reference configuration owners: dubbo:reference owner=\u201dding.lid,william.liangf\u201d / dubbo:service \u3001 dubbo:reference have no configuration owner, then use the owner configured in dubbo:application .","title":"Configuration management information"},{"location":"user/recommend/#set-up-the-dubbo-cache-file","text":"Provider service list caching file: dubbo:registry file=\u201d${user.home}/output/dubbo.cache\u201d / Notations: You can modify the cahe file path of the application according to the needs. Ensure that the file will not be cleared during the release process. If there are more than one application process, do not use the same file path to avoid the content being overwritten. This file caches the list of the registry and the list of service providers. With this configuration, when the application is restarted , if the Dubbo registry is not available, the application will read the information from the service provider list from the cache file. That can ensure the availability of the application.","title":"Set up the Dubbo cache file"},{"location":"user/recommend/#monitor-configuration","text":"Expose service with a fixed port, instead of using a random port In this way, when there is a delay in the registry push, the consumer can also call the original provider service address hrough the cache list and succeed\u3002 Use Dragoon's HTTP monitoring item to monitor the service provider on the registry The state of Dragoon monitoring service in the registry : http://dubbo-reg1.hst.xyi.cn.alidc.net:8080/status/com.alibaba.morgan.member.MemberService:1.0.5 Ensure that the service exists on the registry . Service provider,use Dragoon's telnet mommand or shell monitor command Monitoring service provider port status \uff1a echo status | nc -i 1 20880 | grep OK | wc -l , 20880 is the service port Service consumer side, cast the service to EchoService\uff0cand call $echo() to test whether the provider of the service is available eg: assertEqauls(\u201cOK\u201d, ((EchoService)memberService).$echo(\u201cOK\u201d));","title":"Monitor configuration"},{"location":"user/recommend/#dont-use-the-configuration-of-dubboproperties-file-suggeset-to-use-the-configuration-of-xml","text":"All of the configuration items in the dubbo can be configured in the spring configuration file,and can be configured for a single service. The Dubbo default value is used if completely not set up , please see the instructions in the article Dubbo configuration introduction .","title":"Don't use the configuration of dubbo.properties file, suggeset to use  the configuration of XML"},{"location":"user/recommend/#the-relation-between-attribute-name-of-dubboproperties-and-xml","text":"application name dubbo.application.name xml dubbo:application name=\"myalibaba\" registry address dubbo.registry.address xml dubbo:registry address=\"11.22.33.44:9090\" call timeout dubbo.service.*.timeout Timeout can be set in multiple configuration items timeout ,cover from top to bottom \uff08The top one have a higher priority \uff09[^5]\uff0cThe coverage strategy of other parameters\uff08 retries \u3001 loadbalance \u3001 actives and so on\uff09is\uff1a Certain method Configuration of a provider service xml dubbo:service interface=\"com.alibaba.xxx.XxxService\" dubbo:method name=\"findPerson\" timeout=\"1000\" / /dubbo:service Configuration of a provider specific interface xml dubbo:service interface=\"com.alibaba.xxx.XxxService\" timeout=\"200\" / Service provider protocol dubbo.service.protocol \u3001Service monitor port dubbo.service.server.port xml dubbo:protocol name=\"dubbo\" port=\"20880\" / Service thread pool size dubbo.service.max.thread.threads.size xml dubbo:protocol threads=\"100\" / No provider throws exceptions (Fast-Fail) when the consumer is started () alibaba.intl.commons.dubbo.service.allow.no.provider xml dubbo:reference interface=\"com.alibaba.xxx.XxxService\" check=\"false\" / [^1]: Overlay rules for configuration: 1) The method level configuration has a higher priority than the interface level, that is to say,small scope have a high priority 2) Consumer side configuration has a higher priority than provider side, better than global configuration, the last one is the Dubbo hard coded configuration value\uff08 Dubbo configuration introduction \uff09 [^2]: With the first call, the call will be called 3 times [^3]: How to select a service to call when there are multiple Provider services [^4]: It means that consumer service can call the best provider service, and reduce to call the the slow provider service. [^5]: timeout Can be set in multiple places, configuration items and overlay rules\uff1a Dubbo Schema configuration introduction","title":"The relation between attribute name of dubbo.properties and XML"},{"location":"user/rest/","text":"Developing RESTful Remoting in Dubbo Original author: Li Shen Document copyright: Apache 2.0license Signature - No interpretation Working in progress ... This article is lengthy since REST involves many aspects. Besides, it refers to the document style of Spring and so on. Not only limited to usage of the framework but also strives to present the design concept of the framework and the architectural idea of an excellent application. For people who only want to get a glimpse of Dubbo and REST, all they need is to browse through the Overview to Introduction to Standard Java REST API: JAX-RS . TODO: Generate a clickable directory CONTENT Overview Advantages of REST Application Scenarios Quick Start Introduction to Standard Java REST API: JAX-RS Details of REST Service Provider Implementation of HTTP POST/GET Should Annotation be Placed in the Interface or Implementation Support for Multiple Data Formats (JSON, XML, etc.) Support for Chinese Characters Additional Requirements for XML Format Custom Serialization Configure the Implementation of REST Server Access Context Data Configure the Port Number and Context Path Configure Number of Threads and IO Threads Configure Persistent Connection Configure Maximum Number of HTTP Connections Configure Timeout and HTTP Connections Per Consumer Gzip Data Compression Replace Part of Spring XML Configuration With Annotation Add Custom Filter, Interceptor, etc. Add Custom Exception Handler Configure HTTP Log Output Verification of Input Parameters Should REST Services be Published Transparently Details of REST Service Consumer Scenario 1: Non-Dubbo Consumer Calls Dubbo REST Service Scenario 2: Dubbo Consumer Calls Dubbo REST Service Scenario 3: Dubbo Consumer Calls Non-Dubbo REST Service JAX-RS Restrictions in Dubbo REST FAQ Can Dubbo REST Services be Integrated With Dubbo Registration Center and Monitoring Center? How to Implement Load Balancing and Failover in Dubbo REST? Can Overloaded Methods in JAX-RS Map to Single URL? Can a Method in JAX-RS Receive Multiple Parameters Via POST? Possible shortcomings of Current Dubbo System (Related to REST) Invasiveness of Rpc Context Limitations of Protocol Configuration XML Naming Does Not Conform to the Convention of Spring REST Best Practices Performance Benchmark Test Environment Test Script Test Result Extended Discussion Comparison of REST, Thrift, Protobuf, etc. Comparison Between REST and Traditional Web Services Comparison Between JAX-RS and Spring MVC Future Overview Dubbo supports a variety of remote calling methods, such as Dubbo RPC (Binary Serialization + TCP), HTTP Invoker (Binary Serialization + HTTP, at least there is no support for Text Serialization in the open source version), Hessian (Binary Serialization + HTTP), Web Services (Text Serialization + HTTP), etc., but lacks support for trending RESTful Remote Calls (Text Serialization + HTTP). Therefore, based on the standard Java REST API: JAX-RS 2.0 (Abbreviation of Java API for RESTful Web Services), we provide a mostly transparent REST Call support for Dubbo. Since it is fully compatible with the Standard Java API, all REST services developed for Dubbo may normally work without Dubbo or any specific underlying REST implementation. It is particularly worth noting that we do not need to strictly adhere to the original definition and architectural style of REST. Even the famous Twitter REST API will make modest adjustments according to the situations, rather than mechanically follow the original REST style. Note: We call this feature RESTful Remoting (abstracted remote process or call) rather than a RESTful RPC (specific remote \"procedure\" call) because REST and RPC can be thought of two different styles. In Dubbo's REST implementation, there are two aspects, one is to provide or consume regular REST services, the other is to make REST a protocol implementation in the Dubbo RPC system, and RESTful Remoting covers both aspects. Advantages of REST The following is quoted from Wikipedia: REST can use cache to improve response speed more efficiently. The stateless nature of the communication allows a set of servers to handle different requests in series, resulting in the increment of server scalability. Browser can be used as a client to simplify software requirements. REST software dependency is smaller than other mechanisms superimposed on HTTP. REST does not require additional resource discovery mechanism. REST's long-term compatibility is better in software technology evolution. Here I also want to add a particular advantage of REST: REST bases on simple text format messages and universal HTTP. Therefore, it has a broad applicability and is supported by almost all languages and platforms, together with a lower threshold in using and learning. Application scenarios Because of the advantages of REST in applicability, supporting REST in Dubbo can bring (significant) benefits to most of current mainstream remoting call scenarios: Significantly simplify (cross-language) calls between heterogeneous systems within the enterprise. This is mainly for the following scene: Dubbo acts as a service provider, and systems that are written by other languages (including some java systems that do not base on Dubbo) works as service consumers. The two systems communicate through HTTP and text messages. REST has its unique advantages even comparing to binary cross-language RPC frameworks such as Thrift and ProtoBuf. (See discussion below) Significantly simplify the development of the external Open API (Open Platform). You can use Dubbo to develop a specific Open API application, or you can directly publish the internal Dubbo service as a \"transparent\" REST API (Of course, it's better for Dubbo itself to provide more features transparently, for example, permission control, frequency control, billing and so on). Significantly simplify the development of mobile (tablet) apps or desktop clients. Similar to point 2, you can use Dubbo to develop a specialized server for the applications, or transparently expose the internal Dubbo service. Of course in some projects, mobile or desktop applications can directly access the Open API described in point 2. Significantly simplify the development of AJAX applications on the browser. Similar to point 2, you can use Dubbo to develop a specialized server for AJAX, or transparently expose the internal Dubbo service directly to JavaScript in the browser. Of course, many AJAX applications work better with web frameworks, so direct access to the Dubbo service may not be an exquisite architecture in many web projects. Provide a text-based, easy-to-read remote call method for Dubbo systems within the enterprise (that is, both the service provider and the consumer are Dubbo-based systems). Simplify the call from the Dubbo system to other heterogeneous systems. You can use a simple way like Dubbo to \"transparently\" call REST services provided by Non-Dubbo systems (regardless of whether the service provider is inside or outside the enterprise) It should be pointed out that I think that 1~3 are the most valuable application scenarios for Dubbo's REST call. And the main purpose why we add REST calls for Dubbo is to provide a service-oriented provider. In other words, to develop REST services for Non-Dubbo (heterogeneous) consumers. To sum up, all application scenarios are shown below: Borrowing the most famous slogan of Java in the past, by adding REST calls to Dubbo, you can implement the \"Write once, access everywhere\" service, which can theoretically be accessed all over the world, thus truly achieving an idealized Service-oriented Architecture (SOA). Of course, traditional Web Services (WSDL/SOAP) can meet the requirements (even those that require enterprise-level features) of the above scenarios (except for scenario 4). But due to the complexity and other issues, they are less and less used. Quick Start Developing a RESTful service in Dubbo is relatively straightforward. Let's take a simple user registration service for example. The function to be implemented by this service is to provide the following URL (Note: This URL is not entirely RESTful, but more straightforward and more practical): http://localhost:8080/users/register Any client can POST a JSON string containing the user's information to the above URL to complete the user registration. First, implement the interface of the service: public class UserService { void registerUser(User user); } Then, implement the service: @Path( users ) public class UserServiceImpl implements UserService { @POST @Path( register ) @Consumes({MediaType.APPLICATION_JSON}) public void registerUser(User user) { // save the user... } } The above implementation code for the service is very simple, but since the REST service is to be published to a specific HTTP URL so they can be accessed by clients written by any language or even a browser, there are a few additional JAX-RS standard annotations to be added for the relevant configuration: @Path(\"users\"): Specify that the relative path for UserService is /users , standing for http://localhost:8080/users @Path(\"register\"): Specify that the relative path for registerUser() is /register . Combining the previous @Path specified for UserService , the URL to call UserService.register() is HTTP://localhost:8080/users/register @POST: Specify that registerUser() should be accessed with HTTP POST method @Consumes({MediaType.APPLICATION_JSON}): Specify that registerUser() receives data in JSON format. The REST framework will automatically deserialize JSON data into a User object. Finally, add this service to the spring configuration file and finish all service development work: ```xml ## Introduction to Standard Java REST API: JAX-RS JAX-RS is a standard Java REST API that has been widely supported and applied in the industry. There are many well-known open source implementations, including Oracle's Jersey, RedHat's RestEasy, Apache's CXF and Wink, restlet, etc. In addition, all commercial JavaEE application servers that support the JavaEE 6.0 specifications or above support JAX-RS. Therefore, JAX-RS is a very mature solution, and it does not have any so-called vendor lock-in problems. JAX-RS has a wealth of information on the web, such as the following introductory tutorial: * Oracle official tutorial: http://docs.oracle.com/javaee/7/tutorial/doc/jaxrs.htm * Article on IBM developerWorks China: http://www.ibm.com/developerworks/cn/java/j-lo-jaxrs/ For more information, please feel free to Google or Baidu. As far as learning JAX-RS is concerned, it is generally enough to master the usage of various annotations. Note: Dubbo is based on the JAX-RS 2.0, and sometimes you need to pay attention to the version of the reference material or REST implementation. ## REST Service Provider Details In this section, we will expand the `UserService` in the Quick Start to further demonstrate the development points of the REST service provider in Dubbo. ### Implementation of HTTP POST/GET Although it's recommended to use the four standard methods (POST, DELETE, PUT and GET) in the HTTP protocol to implement common CRUD in REST services, but in practice, we generally use POST to implement create and update, and use GET to implement delete and read (DELETE and PUT will even be blocked by some firewalls). The implementation of POST has already been briefly demonstrated. Here, we will add a function to get the registered user data to `UserService`, in order to demonstrate the implementation of GET. This function is to enable the client to obtain user data of different IDs by accessing different URLs as follows: http://localhost:8080/users/1001 http://localhost:8080/users/1002 http://localhost:8080/users/1003 Of course, you can use other forms of URLs to access user data of different IDs, for example: http://localhost:8080/users/load?id=1001 JAX-RS itself can support all of these forms. However, the first form of including query parameters in the URL path (http://localhost:8080/users/1001) is more in line with the general habit of REST, so it is recommended to use. Below we will add a `getUser()` method to the `UserService` to implement this form of URL access: ```java @GET @Path( {id : \\\\d+} ) @Produces({MediaType.APPLICATION_JSON}) public User getUser(@PathParam( id ) Long id) { // ... } @GET: Specify that the method shoule be accessed with HTTP GET method @Path(\"{id : \\d+}\"): According to the above functional requirements, the URL to access getUser() should be \"http://localhost:8080/users/ + any number\", and this number should passed to getUser() method as parameter passed to the getUser() method. In the annotation here, the {id: xxx} in @Path specifies that the relative path contains the id parameter, and its value will be automatically passed to the method parameter id annotated with @PathParam(\"id\"). \\d+ following {id: is a regular expression specifies that the id parameter must be a number. @Produces({MediaType.APPLICATION_JSON}): Specify that getUser() outputs data in JSON format. The REST framework automatically serializes the User object into JSON data. Is annotation put in interface class or implementation class? The development of REST services based on Dubbo is mainly configured through JAX-RS annotations. In the above example, we put the annotation in the implementation class of the service. But in fact, we can completely put the annotation in the interface of the service. These two methods are completely equivalent, for example: @Path( users ) public interface UserService { @GET @Path( {id : \\\\d+} ) @Produces({MediaType.APPLICATION_JSON}) User getUser(@PathParam( id ) Long id); } In a typical application, we recommend put the annotation in the service implementation class. Then, annotations are closer to Java implementation code and easier to develop and maintain. More importantly, we generally tend to avoid contamination of the interface, maintaining the purity and wide applicability of the interface. However, as will be described later, if we access this service by using the consumer directly developed by Dubbo, the annotation must be put in the interface. If the interface and the implementation class are both added annotation at the same time, the implementation configuration of the implementation class will take effect, and the annotation on the interface will be ignored. Support for JSON, XML and other data formats The dubbo REST services can support the transmission of data in multiple formats to provide maximum flexibility to the client. And we add extra functions to the JSON and XML formats which is most commonly used. For example, we want the getUser() method in the above example support returning JSON and XML format data separately, just need to include two formats in the annotation: @Produces({MediaType.APPLICATION_JSON, MediaType.TEXT_XML}) User getUser(@PathParam( id ) Long id); Or you can directly represent a MediaType with a string (also supports wildcards): @Produces({ application/json , text/xml }) User getUser(@PathParam( id ) Long id); If all methods support the same type of input and output data format, then we do not need to make configure on each method, just add annotation to the service class: @Path( users ) @Consumes({MediaType.APPLICATION_JSON, MediaType.TEXT_XML}) @Produces({MediaType.APPLICATION_JSON, MediaType.TEXT_XML}) public class UserServiceImpl implements UserService { // ... } In the case where a REST service supports multiple data formats, according to the JAX-RS standard, the MIME header (content-type and accept) in HTTP is generally used to specify which format data is currently used. But in dubbo, we also automatically support the current common use of the industry, that is, use a URL suffix (.json and .xml) to specify the data format you want to use. For example, after adding the above annotation, directly accessing http://localhost:8888/users/1001.json means using the json format, and directly accessing http://localhost:8888/users/1002.xml means using the xml format. It's simpler and more intuitive than using HTTP Header. This way is used by the REST APIs of Twitter, Weibo, etc. If you don't add HTTP header or suffix, the REST of dubbo will give priority to enable the top ranked data format in the above definition of annotation. Note: To support XML format data, you can use either MediaType.TEXT_XML or MediaType.APPLICATION_XML in annotation, but TEXT_XML is more commonly used, and if you want to use the above URL suffix to specify the data format, you can only configure it as TEXT_XML to take effect. Chinese character support In order to output Chinese characters normally in dubbo REST, as with the usual Java web applications, we need to set the contentType of the HTTP response to UTF-8 encoding. Based on the standard usage of JAX-RS, we only need to do the following annotation configuration: @Produces({ application/json; charset=UTF-8 , text/xml; charset=UTF-8 }) User getUser(@PathParam( id ) Long id); For the convenience of users, we add a support class directly in dubbo REST to define the above constants, which can be used directly and reduce the possibility of error. @Produces({ContentType.APPLICATION_JSON_UTF_8, ContentType.TEXT_XML_UTF_8}) User getUser(@PathParam( id ) Long id); Additional requirements for XML data format Because the implementation of JAX-RS generally use standard JAXB (Java API for XML Binding) to serialize and deserialize XML format data, we need to add a class-level JAXB annotation for each object to be transferred in XML. Otherwise serialization will report an error. For example, add follows to the User returned in getUser() : @XmlRootElement public class User implements Serializable { // ... } In addition, if the return value in the service method is Java primitive type (such as int, long, float, double, etc.), it is best to add a wrapper object to them, because JAXB can not directly serialize the primitive type. For example, we want the above registerUser() method to return the ID number generated by the server for the user: long registerUser(User user); Because the primitive type is not supported by JAXB serialization, add a wrapper object: @XmlRootElement public class RegistrationResult implements Serializable { private Long id; public RegistrationResult() { } public RegistrationResult(Long id) { this.id = id; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } } And modify the service method: RegistrationResult registerUser(User user); This not only solves the problem of XML serialization, but also makes the returned data conform to the specifications of XML and JSON. For example, in JSON, the returned form would be as follows: { id : 1001} If you do not add a wrapper, the JSON return value will be directly 1001 In XML, the return value after adding wrapper will be: registrationResult id 1002 /id /registrationResult This wrapper object actually uses the so-called Data Transfer Object (DTO) mode, and DTO can also make more useful customizations for transferring data. While in XML, after adding wrapper, the return value will be registrationResult id 1002 /id /registrationResult In fact, this wrapper object uses the so-called Data Transfer Object (DTO) mode. DTO can also be used to make more useful customizations to transfer data. Custom Serialization As mentioned above, the underlying implementation of REST will automatically serialize/deserialize between the service object and the JSON/XML data format. The REST implementation in Dubbo uses JAXB for XML serialization and Jackson for JSON serialization,so you can customize the mapping by adding JAXB or Jackson's annotation to the object. For example, customizing the object properties to map to the names of the XML elements: @XmlRootElement @XmlAccessorType(XmlAccessType.FIELD) public class User implements Serializable { @XmlElement(name= username ) private String name; } Customizing the object properties to map to the names of the JSON field: public class User implements Serializable { @JsonProperty( username ) private String name; } For more information, please refer to the official documentation of JAXB and Jackson, or google yourself. Configuring REST Server implementation Currently in dubbo, we support the implementation of five embedded rest servers. The implementation of the rest server is selected by the following XML attribute of the server: dubbo:protocol name= rest server= jetty / The above configuration uses the embedded jetty to do the rest server. At the same time, if you do not configure the server attribute, the rest protocol also uses jetty by default. jetty is a very mature java servlet container and has a good integration with dubbob (Among the five embedded servers, Only jetty and later tomcat\u3001tjws, complete seamless integration with Dubbo monitoring system.), so, if your dubbo system is a separate process, you can use jetty by default. dubbo:protocol name= rest server= tomcat / The above configuration uses the embedded tomcat to do the rest server.On embedded tomcat, REST performance is much better than jetty (See the benchmark below). It is recommended that Tomcat is used in scenarios where high performance is required. dubbo:protocol name= rest server= netty / The above configuration uses embedded netty to do the rest server. (TODO more contents to add) dubbo:protocol name= rest server= tjws / (tjws is now deprecated) dubbo:protocol name= rest server= sunhttp / The above configuration uses embedded tjws or Sun HTTP server to do the rest server. These two server implementations are very lightweight, it is very convenient for quick start-up in integration testing, of course, it can also be used in a production environment with low load. Note: tjws is currently deprecated because it does not work well with the servlet 3.1 API. If your dubbo system is not a separate process, instead of deploying to a Java application server, we recommend the following configuration: dubbo:protocol name= rest server= servlet / By setting the server as the servlet, dubbo will use the servlet container of the external application server to do the rest server. At the same time, add the following configuration to the web.xml of the dubbo system: web-app context-param param-name contextConfigLocation /param-name param-value /WEB-INF/classes/META-INF/spring/dubbo-demo-provider.xml /param-value /context-param listener listener-class org.apache.dubbo.remoting.http.servlet.BootstrapListener /listener-class /listener listener listener-class org.springframework.web.context.ContextLoaderListener /listener-class /listener servlet servlet-name dispatcher /servlet-name servlet-class org.apache.dubbo.remoting.http.servlet.DispatcherServlet /servlet-class load-on-startup 1 /load-on-startup /servlet servlet-mapping servlet-name dispatcher /servlet-name url-pattern /* /url-pattern /servlet-mapping /web-app In other words, you must add dubbo's BootstrapListener and DispatherServlet to web.xml to complete the integration of dubbo's REST functionality with the external servlet container. Note:If you are using spring's ContextLoaderListener to load spring, you must ensure that the BootstrapListener is configured before the ContextLoaderListener, otherwise the dubbo initialization will fail. In fact, you can still stick to the embedded server in this scenario, but the servlet container of the external application server is often more powerful than the embedded server(Especially if you are deploying to a more robust and scalable WebLogic, WebSphere, etc.). In addition, it is sometimes convenient to do unified management, monitoring, and so on in the application server. Get Context Information Varieties of context information are valuable when calling procedures remotely. For instance, the IP address from the Client. We provide two methods to get the Client's IP in dubbo. The first one is using @Context annotation from JAX-RS: public User getUser(@PathParam( id ) Long id, @Context HttpServletRequest request) { System.out.println( Client address is + request.getRemoteAddr()); } After decorating a parameter of getUser() with Context, we can inject the current HttpServletRequest and then call the servlet api to get the IP. Notice: This method can only be used when the server is one of the followings: twjs, tomecat, jetty or servlet. All of them provide servlet container. In addition, standard JAX-RS also allow us to get HttpServletRequest using an instance field in service Class decorated by @Context . The second method is to use RpcContext, which is commonly seen in dubbo: public User getUser(@PathParam( id ) Long id) { System.out.println( Client address is + RpcContext.getContext().getRemoteAddressString()); } Notice: Similarly, this method only works in the jetty, tomcat, servlet or tjws server. In dubbo, the usage of RpcContext is rather invasive. We are likely to refactor it in the future. The first method is suggested when your project may run without dubbo and need the compatibility with JAX-RS. But if you want a more elegant service interface definition, the second method would be the better choice. What's more, in the newest version of dubbo REST service, RpcContext could be used to get HttpServletRequest and HttpServletResponse, providing great flexibility for users to implement some complex functions. The following is an example: if (RpcContext.getContext().getRequest() != null RpcContext.getContext().getRequest() instanceof HttpServletRequest) { System.out.println( Client address is + ((HttpServletRequest) RpcContext.getContext().getRequest()).getRemoteAddr()); } if (RpcContext.getContext().getResponse() != null RpcContext.getContext().getResponse() instanceof HttpServletResponse) { System.out.println( Response object from RpcContext: + RpcContext.getContext().getResponse()); } Notice: In order to maintain the neutrality of the protocol, RpcContext.getRequest() and RpcContext.getResponse() only return an Object which could be null. Therefore, you have to check the type on your own. Notice: only when you use jetty, tomcat, servlet as the server can you get the HttpServletRequest and HttpServletResponse as expected. Because only these server implemented the servlet container. To simplify the programme, you can also use generic to get a specific type of request/response: if (RpcContext.getContext().getRequest(HttpServletRequest.class) != null) { System.out.println( Client address is + RpcContext.getContext().getRequest(HttpServletRequest.class).getRemoteAddr()); } if (RpcContext.getContext().getResponse(HttpServletResponse.class) != null) { System.out.println( Response object from RpcContext: + RpcContext.getContext().getResponse(HttpServletResponse.class)); } If request/response does not correspond to the specific type, it would return null. Configure The Port Number and Context Path The REST protocol in dubbo use 80 as the default port. But you are also allowed to modify it: dubbo:protocol name= rest port= 8888 / As what have been metioned before, we can use @Path to configure relative URL path in single REST service. In fact, we can also set a basic relative path which is known as context path for all REST service. All we need to do is to add the contextpath property: dubbo:protocol name= rest port= 8888 contextpath= services / Let's have a look at the previous code: @Path( users ) public class UserServiceImpl implements UserService { @POST @Path( register ) @Consumes({MediaType.APPLICATION_JSON}) public void registerUser(User user) { // save the user... } } Now the complete path would be: http://localhost:8888/services/users/register Notice: If you use external server as REST server, you should configure as followings, dubbo:protocol name= rest port= 8888 contextpath= services server= servlet / meaning that you should keep the config of port and contextpath are the same with the port and DispatcherServlet's context path (webapp path + servlet url pattern) in external server. For example, when we are configuring the application on tomcat Root path, we need to make sure the contextpath here is totally the same with the url-pattern/ of DispacherServlet in web.xml: servlet-mapping servlet-name dispatcher /servlet-name url-pattern /services/* /url-pattern /servlet-mapping Configure the number of threads and IO threads We can set the number of threads of rest service: dubbo:protocol name= rest threads= 500 / Notice: Currently, the setting only works when the server is netty, jetty or tomcat. If you use servlet as the server, you are using the external server as the REST server which is out of dubboes' control, so the setting would not work expectedly. You can also set threads number of IO worker of netty server: dubbo:protocol name= rest iothreads= 5 threads= 100 / Configure long connections The REST service in Dubbo is accessed by default with http long connection, if you want to switch to short connection, you can configure it as below: dubbo:protocol name= rest keepalive= false / Notice: This configuration only works in netty and tomcat. Configure the maximum number of HTTP connections Configuring the maximum number of HTTP connections can prevent REST server from overload as the basic self-protection mechanism. dubbo:protocol name= rest accepts= 500 server= tomcat/ Notice: Currently, it only works in tomcat. Configuring the timeout and HTTP connections for each consumer If the consumer of the rest service is also a dubbo system, you can configure the maximum timeout for the consumer to call the rest service, and the maximum number of HTTP connections that each consumer can initiate, just like other dubbo RPC mechanisms. dubbo:service interface= xxx ref= xxx protocol= rest timeout= 2000 connections= 10 / Of course, since this configuration is valid for the consumer, it can also be configured on the consumer side: dubbo:reference id= xxx interface= xxx timeout= 2000 connections= 10 / However, we generally recommend configuring the service provider to provide such a configuration. According to the official dubbo documentation, \u201cProvider should configure the properties of the Consumer side as much as possible. Let the Provider implementer think about the service features and service quality of the Provider from the beginning.\u201d Note: If dubbo REST service is released to non-dubbo clients, the configuration on dubbo:service/ is completely invalid because the client is not under dubbo control. GZIP data compresssion Dubbo RESTful Remoting supports the use of Gzip to compress request and response data to reduce network transmission time and bandwidth consumption, but this will also increase CPU overhead. TODO more contents to add. Replacing part of the spring XML configuration with annotation Above discussions are based on the XML configuration of Dubbo in spring. However, dubbo/spring itself supports the use of annotation for configuration, so we can also follow the steps in the Dubbo document and add the relevant annotation to the REST service implementation, replacing some XML configurations, such as: @Service(protocol = rest ) @Path( users ) public class UserServiceImpl implements UserService { @Autowired private UserRepository userRepository; @POST @Path( register ) @Consumes({MediaType.APPLICATION_JSON}) public void registerUser(User user) { // save the user userRepository.save(user); } } Annotation-based configuration is more concise and precise, and often easier to maintain (modern IDE can support such things as class name refactoring in XML, and therefore the maintenance of XML is good for specific use cases here). XML is less intrusive to code, especially for dynamically modifying configurations, especially when you want to modify the timeout for connection of a single service configuration, the maximum number of connections per client, cluster policy, weights, and so on. In addition, for complex applications or modules, XML provides a central point to cover all the components and configurations. It is at a glance, and generally more convenient for long term maintenance of the project. Of course, there's no right or wrong of different choices of configuration method. Sometimes it's just personal preference. Adding a custom Filter, Interceptor, etc Dubbo RESTful Remoting also supports JAX-RS standard Filter and Interceptor to facilitate customized interception of REST request and response processes. Here, Filter is mainly used to access and set parameters, URIs for HTTP request and response, and so on, for example, setting the cache header for HTTP response: public class CacheControlFilter implements ContainerResponseFilter { public void filter(ContainerRequestContext req, ContainerResponseContext res) { if (req.getMethod().equals( GET )) { res.getHeaders().add( Cache-Control , someValue ); } } } Interceptor is mainly used to access and modify the input and output byte streams, for example, manually adding GZIP compression: public class GZIPWriterInterceptor implements WriterInterceptor { @Override public void aroundWriteTo(WriterInterceptorContext context) throws IOException, WebApplicationException { OutputStream outputStream = context.getOutputStream(); context.setOutputStream(new GZIPOutputStream(outputStream)); context.proceed(); } } In standard JAX-RS applications, we generally add @Provider annotations to Filter and Interceptor, and JAX-RS runtime will automatically discover and enable them. In Dubbo, we register Filter and Interceptor by adding an XML configuration: dubbo:protocol name= rest port= 8888 extension= xxx.TraceInterceptor, xxx.TraceFilter / Here, we can add these three types of objects, Filter, Interceptor and DynamicFeature, to the extension attributes, separated by commas. (DynamicFeature is another interface that allows us to enable Filter and Interceptor more dynamically. Please feel free to google.) Of course, Dubbo itself also supports Filter, but the Filter and Interceptor we discuss here are more like the bottom of the protocol implementation. Compared to Dubbo's filter, you can do a lower level of customization here. Note: The XML attribute here is called extension, not interceptor or filter. That is because we will add more extension types in addition to Interceptor and Filter in the future. If the REST consumer is also a Dubbo system (see discussion below), you can also configure the Interceptor and Filter for the consumer in a similar way. However, it should be noted that the consumer-side Filter and the provider-side Filter in JAX-RS are two different interfaces. For example, in the previous example, the server is the ContainerResponseFilter interface, and the consumer side corresponds to the ClientResponseFilter: public class LoggingFilter implements ClientResponseFilter { public void filter(ClientRequestContext reqCtx, ClientResponseContext resCtx) throws IOException { System.out.println( status: + resCtx.getStatus()); System.out.println( date: + resCtx.getDate()); System.out.println( last-modified: + resCtx.getLastModified()); System.out.println( location: + resCtx.getLocation()); System.out.println( headers: ); for (Entry String, List String header : resCtx.getHeaders().entrySet()) { System.out.print( \\t + header.getKey() + : ); for (String value : header.getValue()) { System.out.print(value + , ); } System.out.print( \\n ); } System.out.println( media-type: + resCtx.getMediaType().getType()); } } Adding custom Exception handler Dubbo RESTful Remoting also supports JAX-RS standard ExceptionMapper, which can be used to customize the HTTP response after a particular exception occurs. public class CustomExceptionMapper implements ExceptionMapper NotFoundException { public Response toResponse(NotFoundException e) { return Response.status(Response.Status.NOT_FOUND).entity( Oops! the requested resource is not found! ).type( text/plain ).build(); } } Similar to Interceptor and Filter, it can be enabled by adding it to an XML configuration file: dubbo:protocol name= rest port= 8888 extension= xxx.CustomExceptiionMapper / Configuring HTTP log output Dubbo RESTful Remoting supports outputting the header and body in all HTTP requests/responses. Add the following REST filter to the XML configuration: dubbo:protocol name= rest port= 8888 extension= org.apache.dubbo.rpc.protocol.rest.support.LoggingFilter / Then turn on at least INFO level log output for org.apache.dubbo.rpc.protocol.rest.support in the logging configuration ,for example,in log4j.xml: logger name= org.apache.dubbo.rpc.protocol.rest.support level value= INFO / appender-ref ref= CONSOLE / /logger Of course, you can also turn on INFO level log output directly in the ROOT logger: root level value= INFO / appender-ref ref= CONSOLE / /root Then there will be something like the following output in the log: The HTTP headers are: accept: application/json;charset=UTF-8 accept-encoding: gzip, deflate connection: Keep-Alive content-length: 22 content-type: application/json host: 192.168.1.100:8888 user-agent: Apache-HttpClient/4.2.1 (java 1.5) The contents of request body is: { id :1, name : dang } After the HTTP log output is turned on, in addition to the performance overhead of the normal log output, additional overhead is generated in, for example, HTTP request parsing, because an additional memory buffer needs to be allocated to prepare the data for the log output. Inputing parameter validation Dubbo RESTful Remoting supports the use of the Java standard bean validation annotation(JSR 303) for input validation http://beanvalidation.org/. In order to be consistent with other Dubbo remote invocation protocols, the annotations that are checked for rest must be placed on the interface of the service, for example: public interface UserService { User getUser(@Min(value=1L, message= User ID must be greater than 1 ) Long id); } Of course, in many other bean validation scenarios, annotations are placed on implementation classes rather than interfaces. At least one advantage of placing an annotation on an interface is that the Dubbo client can share information about the interface. The input validation can be done locally even without RPC. Then turn on the validation in the XML configuration in the same way as Dubbo: dubbo:service interface=xxx.UserService ref= userService protocol= rest validation= true / In many other RPC protocols of Dubbo, if the input validation error occurs, the RpcException is directly thrown to the client, but in the rest, since the client is often non-Dubbo or even non-Java system, it is inconvenient to directly throw a Java exception. Therefore, at present we will return the validation error in XML format: violationReport constraintViolations path getUserArgument0 /path message User ID must be greater than 1 /message value 0 /value /constraintViolations /violationReport The return values of other data formats will also be supported later. As for how to internationalize the verification error message, refer directly to the relevant documentation of the bean validation. If you think that the default validation error return format does not meet your requirements, you can add custom ExceptionMapper to custom error return format freely as described in the previous section. It should be noted that this ExceptionMapper must use the generic declaration to capture the RpcException of Dubbo in order to successfully override the default exception handling strategy of Dubbo rest. In order to simplify the operation, the easiest way to do this is to directly inherit the RpcExceptionMapper of Dubbo rest and override the method that handles the validation exception: public class MyValidationExceptionMapper extends RpcExceptionMapper { protected Response handleConstraintViolationException(ConstraintViolationException cve) { ViolationReport report = new ViolationReport(); for (ConstraintViolation cv : cve.getConstraintViolations()) { report.addConstraintViolation(new RestConstraintViolation( cv.getPropertyPath().toString(), cv.getMessage(), cv.getInvalidValue() == null ? null : cv.getInvalidValue().toString())); } // Use json output instead of xml output return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(report).type(ContentType.APPLICATION_JSON_UTF_8).build(); } } Then add this ExceptionMapper to the XML configuration: dubbo:protocol name= rest port= 8888 extension= xxx.MyValidationExceptionMapper / Whether to transparently publish REST service Dubbo RESTful Remoting differs from some other RPCs in Dubbo in that you need to add JAX-RS annotations (and JAXB, Jackson's annotation) to your service code. If you think these annotations \"pollute\" your service code to a certain extent,you can consider writing additional Facade and DTO classes, adding annotations to that, and Facade forwards the calls to the real service implementation class. Of course, adding annotations directly to the service code basically has no negative effects, and this is itself a standard usage in Java EE. In addition, JAX-RS and JAXB annotations belong to the Java standard. Compared with spring, Dubbo, etc., which we often use, annotations have no problem with vendor lock-in, so there is usually no need to introduce additional objects. In addition,when you want to use the @Context annotation mentioned above, injecting HttpServletRequest through method parameters (such as public User getUser(@PathParam(\"id\") Long id, @Context HttpServletRequest request) ), the method signature of service is changed and HttpServletRequest is a REST-specific parameter, you should introduce additional Facade classes if your service supports multiple RPC mechanisms. Of course, your service code may already act as a Facade and DTO before adding RESTful Remoting (as to why some scenarios require these roles, and if you are interested, you can refer to [Micro-SOA: Service Design Principles and Practices] Http://www.infoq.com/cn/articles/micro-soa-1). In this case, after adding REST, if you add additional REST-related Facade and DTO, it is equivalent to wrapping the original code again, which forms the following call chain: RestFacade/RestDTO - Facade/DTO - Service This kind of system is cumbersome, and the workload of data conversion is not small, so it should be avoided if possible. Consumer of RESTful Remoting Here we use three scenarios: The non-Dubbo consumer calls Dubbo REST service (non-Dubbo -- Dubbo) The Dubbo consumer calls Dubbo REST service (Dubbo -- Dubbo) The consumer of Dubbo calls the non-Dubbo REST service (Dubbo -- non-Dubbo) Scenario 1: Non-Dubbo consumer calls Dubbo REST Service The client of this scenario has nothing to do with Dubbo itself, and it can be directly selected in the appropriate language and framework. If it is still a Java client (but not using Dubbo), consider using the standard JAX-RS Client API or a specific REST-implemented Client API to invoke the REST service. The following is the registerUser() that uses the JAX-RS Client API to access the above UserService: User user = new User(); user.setName( Larry ); Client client = ClientBuilder.newClient(); WebTarget target = client.target( http://localhost:8080/services/users/register.json ); Response response = target.request().post(Entity.entity(user, MediaType.APPLICATION_JSON_TYPE)); try { if (response.getStatus() != 200) { throw new RuntimeException( Failed with HTTP error code : + response.getStatus()); } System.out.println( The generated id is + response.readEntity(RegistrationResult.class).getId()); } finally { response.close(); client.close(); //Do not close the client every time in real development, such as HTTP long connection is held by the client } The User and RegistrationResult classes in the code snippet above are written by the consumer itself, and the JAX-RS Client API automatically serializes/deserializes them. Of course, in Java, you can also use the familiar technologies such as HttpClient, FastJson, XStream, etc. to implement the REST client, which will not be detailed here. Scenario 2: Dubbo consumer calls Dubbo RESTful Remoting In this scenario, same as other Dubbo remote calling methods, the Java service interface is shared directly between the service provider and the service consumer, and the Spring XML configuration is added (of course, the Spring/Dubbo annotation configuration can also be used),the remote REST service can be called transparently: dubbo:reference id= userService interface= xxx.UserService / As mentioned earlier, in this scenario, JAX-RS annotations must be added to the service interface, so that the corresponding REST configuration information can be shared on the consumer side of Dubbo and remotely called accordingly: @Path( users ) public interface UserService { @GET @Path( {id : \\\\d+} ) @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) User getUser(@PathParam( id ) Long id); } If a variety of data formats are configured in the annotation of the service interface, since both ends are Dubbo systems, a lot of details of REST are blocked, so there is no possibility to select a data format using the aforementioned URL suffix. Currently in this case, the top ranked data format will be used directly. Therefore, we recommend that you put the most appropriate data format in front of defining an annotation. For example, we put JSON in front of XML because JSON's transmission performance is better than XML. Scenario 3: The consumer of Dubbo calls a non-Dubbo RESTful Remoting In this scenario, the REST service can be called directly using the Java method described in Scenario 1. But in fact, you can also use the way described in Scenario 2, that is, calling the REST service more transparently, even if this service is not provided by Dubbo. If the scenario 2 is used, since the REST service is not provided by Dubbo, there is generally no shared Java service interface mentioned above, so we need to write the Java interface and the corresponding parameter class according to the external REST service. Add JAX-RS, JAXB, Jackson and other annotations, Dubbo's REST underlying implementation will automatically generate request messages, automatically parse response messages, etc., so as to transparently make remote calls. Or this way can also be understood as, we try to use JAX-RS to copy the implementation of the external REST service provider, and then put the written service interface to the client to use directly, Dubbo REST underlying implementation can call other REST services as it calls Dubbo's REST service . For example, we want to call the following external service. http://api.foo.com/services/users/1001 http://api.foo.com/services/users/1002 Get user data of different IDs, the return format is JSON { id : 1001, name : Larry } We can write service interfaces and parameter classes based on this information: @Path( users ) public interface UserService { @GET @Path( {id : \\\\d+} ) @Produces({MediaType.APPLICATION_JSON}) User getUser(@PathParam( id ) Long id); } public class User implements Serializable { private Long id; private String name; // \u2026 } For the configuration in Spring, because the REST service is not provided by Dubbo, you can not use the Dubbo registry to directly configure the url address of the external REST service (such as multiple addresses separated by commas): dubbo:reference id= userService interface= xxx.UserService url= rest://api.foo.com/services/ / Note: The protocol here must use rest:// instead of http://. If the external REST service has a context path, it must also be added to the url (unless you have a context path in the @Path annotation for each service interface), such as /services/ above. At the same time, the services here must be followed by /, in order to make Dubbo work properly. In addition, you can still configure the maximum number of connections and timeouts that the client can start: dubbo:reference id= userService interface= xxx.UserService url= rest://api.foo.com/services/ timeout= 2000 connections= 10 / JAX-RS restrictions in Dubbo The REST development in Dubbo is fully compatible with standard JAX-RS, but the features it supports are currently a subset of full JAX-RS, in part because it is limited to the specific architecture of Dubbo and Spring. The limitations of JAX-RS used in Dubbo include but are not limited to: Service implementation can only be singleton, and it can not support per-request scope and per-lookup scope It is not supported to inject into ServletConfig, ServletContext, HttpServletRequest, HttpServletResponse, etc. with the @Context annotation for the instance field of the service, but it can support the injection of service method parameters. However, for certain REST server implementations (see the previous section), injection of service method parameters is not supported. REST FAQ Can Dubbo REST services be integrated with Dubbo Registry and Monitor? Yes, and it will integrate automatically. That is, all the REST services you develop in Dubbo are automatically registered to the Registry and Monitor, by which you can managed your services. However, many of the service governance operations in the Registry can only be fully functional when the REST consumer is based on Dubbo. If the consumer side is non-Dubbo, it is naturally not managed by the Registry, so that many of the operations will not work for the consumer. How to implement load balancing and failover in Dubbo REST? If the consumer side of Dubbo REST is based on Dubbo, then Dubbo REST is basically the same as other Dubbo remote call protocols: Dubbo framework transparently performs load balancing, failover, etc. on the consumer side. If the consumer side of Dubbo REST is non-Dubbo or even non-Java, it is better to configure the soft load balancing mechanism on the service provider. Currently, you can consider LVS, HAProxy, Nginx, and so on to achieve load balancing for HTTP requests. Can overloaded method in JAX-RS maps to the same URL address? http://stackoverflow.com/questions/17196766/can-resteasy-choose-method-based-on-query-params Can a POST method in JAX-RS receive multiple parameters? http://stackoverflow.com/questions/5553218/jax-rs-post-multiple-objects The shortcomings of Dubbo's current system (related to REST) I think there are obviously a lot of deficiencies in Dubbo's current system. Here are a few REST-related issues that affect users (not including internal implementation issues) for reference and comments, which can help prepare for the refactoring later. Invasiveness of RpcContext We have already mentioned the intrusiveness of RpcContext(See above). Because it uses a singleton to access context information, which is completely inconsistent with the general style of spring applications as well as not conducive to application extension and unit testing. In the future, we may inject an interface with dependency injection, and then use it to access the context information in ThreadLocal. limitations of Protocol configuration Dubbo supports multiple remote call methods, but all call methods are configured with , for example: Dubbo:protocol name= Dubbo port= 9090 server= netty client= netty codec= Dubbo serialization= hessian2 charset= UTF-8 threadpool= fixed threads= 100 queues= 0 iothreads= 9 buffer= 8192 accepts= 1000 payload= 8388608 / Dubbo supports multiple remote call methods, but all call methods are configured with , for example: In fact, many of the above properties are uniquely held by the Dubbo RPC remote call method and many other remote call methods in Dubbo do not support server, client, codec, iothreads, accepts, payload, etc. (of course, some are not supported because of limited conditions, some have no need to be supported at all). This adds a lot of confusions to users when they use Dubbo, and they actually do not know that some attributes (such as performance tuning) will not work after adding them. On the other hand, various remote call methods often have a large number of unique configuration requirements, especially as we gradually add much richer and more advanced functions to each kind of remote call method, which cause the expands in attributes inevitably (for example, we have added keepalive and extension two attributes in REST at the moment) and then lead to bloated and user confusion. Of course, there is a way to expand in Dubbo by using , but this method is obviously very limited, the usage is complicated and the schema verification is lacking. So that the best method is to set your own protocol elements for each remote call, such as , , etc. Each element specifies its own attributes using XML Schema. (Of course, it is best to use common attributes between a variety of remote call methods) In this way, a freer way can be used when doing the extension configuration mentioned above, so that it can be much clearer and more extensible (the following is just an example, of course there may be a better way): Dubbo:protocol-rest port= 8080 Dubbo:extension someInterceptor /Dubbo:extension Dubbo:extension someFilter /Dubbo:extension Dubbo:extension someDynamicFeature /Dubbo:extension Dubbo:extension someEntityProvider /Dubbo:extension /Dubbo:protocol-rest XML naming does not conform to the spring specification A lot of naming in XML configuration of Dubbo dose not conform to the spring specification, such as: Dubbo:protocol name= Dubbo port= 9090 server= netty client= netty codec= Dubbo serialization= hessian2 charset= UTF-8 threadpool= fixed threads= 100 queues= 0 iothreads= 9 buffer= 8192 accepts= 1000 payload= 8388608 / The above threadpool should be changed to thread-pool, iothreads should be changed to io-threads, and words should be separated by \"-\". While this may seem like a minor issue, it also involves readability, especially scalability, because sometimes we will inevitably use more words to describe XML elements and attributes. In fact, Dubbo itself also recommended to follow the naming convention of spring to XML. Best practices of REST TODO Performance benchmark Test Environment Roughly as follows: 4-core Intel(R) Xeon(R) CPU E5-2603 0 @ 1.80GHz 8G memory The network between servers passes through a 100 Mbps switch CentOS 5 JDK 7 Tomcat 7 JVM parameter -server -Xms1g -Xmx1g -XX:PermSize=64M -XX:+UseConcMarkSweepGC Test Script Similar to Dubbo's own benchmarks: 10 concurrent clients send requests continuously: \u2022 Pass in nested complex objects (single data is small), do nothing and return \u2022 Pass in a 50K string, do nothing and return (TODO: the result is not listed yet) Excute a five-minute performance test. (Reference to Dubbo's own test considerations: \"Mainly consider the serialization and performance of network IO, so that the server side does not have any business logic. Take 10 to run simultaneously because of the consideration that the bottleneck can be hit first when the high CPU usage rate is reached by HTTP protocol under the high concurrency situation.\") Test Result The following results are mainly from the comparison between to the two remote call methods, REST and Dubbo RPC which are configured differently, for example: \u201cREST: Jetty + XML + GZIP\u201d means: Test REST, use jetty server and XML data format, and enable GZIP compression. \u201cDubbo: hessian2\u201d means: test Dubbo RPC and use hessian2 serialization. The results for complex objects are as follows (the smaller Response Time and the larger TPS, the better results): Remote Call Mode Average Response Time Average TPS\uff08Num of transactions per second\uff09 REST: Jetty + JSON 7.806 1280 REST: Jetty + JSON + GZIP TODO TODO REST: Jetty + XML TODO TODO REST: Jetty + XML + GZIP TODO TODO REST: Tomcat + JSON 2.082 4796 REST: Netty + JSON 2.182 4576 Dubbo: FST 1.211 8244 Dubbo: kyro 1.182 8444 Dubbo: Dubbo serialization 1.43 6982 Dubbo: hessian2 1.49 6701 Dubbo: fastjson 1.572 6352 Just a brief summary of the current results: Dubbo RPC (especially when based on efficient java serialization methods such as kryo and fst) has a significant advantage response time and throughput over REST. Dubbo RPC is preferred in the intranet Dubbo systems. When choosinf REST implementation, tomcat7 and netty are optimal (of course, the current versions of jetty and netty are lower) currently only considering performance. Tjws and sun http server performed extremely poorly in performance tests, with an average response time of more than 200ms and an average tps of only about 50 (to avoid affecting the picture effect, the results are not listed above). Performance of JSON data format is better than XML in REST (data is not listed above). Enabling GZIP in REST has little to do with complex objects with small data volume in the intranet, but performance has declined (data is not listed above). Performance Optimization Recommendations If you deploy Dubbo REST to an external Tomcat and configure server=\"servlet\", that is, enable external tomcat as the underlying implementation of rest server, it is best to add the following configuration to tomcat: Connector port= 8080 protocol= org.apache.coyote.http11.Http11NioProtocol connectionTimeout= 20000 redirectPort= 8443 minSpareThreads= 20 enableLookups= false maxThreads= 100 maxKeepAliveRequests= -1 keepAliveTimeout= 60000 / Especially the configuration maxKeepAliveRequests=\"-1\" ,which is mainly to ensure that tomcat always enables http long connection, in order to improve the performance of REST call. Note, however, that if the REST consumer side is not continuously call REST services, it is not always best to enable long connections all time. In addition, the way to always enable long connections is generally not suitable for ordinary webapps, but more suitable for such rpc-like scenarios. So that in order to get high performance, Dubbo REST applications and ordinary web applications are best not to be mixed deployment, but should use a separate instance in tomcat. Extended discussion Comparison among Rest, Thrift, Protobuf and so on TODO Comparison between REST and traditional Webservers TODO Comparison of JAX-RS Between Spring MVC A preliminary view from http://www.infoq.com/cn/news/2014/10/Dubbox-open-source?utm_source=infoq utm_medium=popular_links_homepage#theCommentsSection Thank you, in fact, for jax-rs and Spring MVC, I do not have a deep look at the rest support of Spring MVC. I would like to give you some preliminary ideas. Please correct me: Spring MVC also supports configuration using annotation, which actually looks very similar to jax-rs. Personally, I think Spring MVC is better suited to restful services of web applications, such as being invoked by AJAX, or possibly outputting HTML or something like page jump processes in applications. Spring MVC can handle both normal web page requests and rest requests at the same time. But in general, the restful service is implemented in the presentation layer or the web layer. But Jax-rs is more suitable for pure service-oriented applications, that is, the middle-tier services in traditional Java EE, for example, it can publish traditional EJB as restful services. In a Spring application, the bean that acts as a service in the Spring is directly published as a restful service. In general, the restful service is at the business layer, application layer, or facade layer. And MVC hierarchies and concepts are often of little value in such (back-end) applications. Of course, some implementations of jax-rs, such as jersey, also try to include MVC to better accommodate the web applications described above, but not as well as Spring MVC. In Dubbo applications, I think a lot of people prefer to publish a local Spring service bean (or manager) as a remote service directly and transparently, so that it is more straightforward to use JAX-RS here, and there is no need to introduce the MVC concept. Of course, we do not discuss whether transparent publishing of remote services is a best practice or whether to add facade things here first. Of course, I know that many people use Spring MVC restful to call Dubbo (spring) service to publish restful services under the situation that Dubbo does not support rest now. It\u2019s a good method also in my opinion, but if you do not modify Spring MVC and integrate it deeply with Dubbo, restful services cannot enjoy many advanced services such as registering to the Dubbo Registry, monitoring the number of calls, TPS, response time through the Dubbo Monitor, controlling the size of the thread pool and the maximum number of connections through the unified configuration of Dubbo, and controlling the service flow, authority and frequency through Dubbo unified mode like other remote call protocol such as webservices, Dubbo rpc, hessian and so on in Dubbo system. In addition, Spring MVC only works in server side and Spring restTemplate are usually used on consumer side. If restTemplate is not integrated with Dubbo, the service can be downgraded by Dubbo client automatically or manually. If the server and consumer are all Dubbo system, you cannot use unified routing and other functions in Dubbo if the Spring rest is not deeply integrated into Dubbo through interaction of Spring and rest. Of course, I personally think that these things are not necessarily to be one or the other. I heard that Rod Johnson, the founder of spring usually says \u2018the customer is always right,\u2019 In fact, it is better to support both ways at the same time rather than discuss which way is better, so that originally I wrote in the document that we plan to support Spring rest annotation, but the feasibility is unknown. Future Functions may be supported later: Rest annotation for Spring MVC Safety System OAuth Asynchronous calls Gzip Payload maxsize","title":"Developing RESTful Remoting in Dubbo"},{"location":"user/rest/#developing-restful-remoting-in-dubbo","text":"Original author: Li Shen Document copyright: Apache 2.0license Signature - No interpretation Working in progress ... This article is lengthy since REST involves many aspects. Besides, it refers to the document style of Spring and so on. Not only limited to usage of the framework but also strives to present the design concept of the framework and the architectural idea of an excellent application. For people who only want to get a glimpse of Dubbo and REST, all they need is to browse through the Overview to Introduction to Standard Java REST API: JAX-RS . TODO: Generate a clickable directory","title":"Developing RESTful Remoting in Dubbo"},{"location":"user/rest/#content","text":"Overview Advantages of REST Application Scenarios Quick Start Introduction to Standard Java REST API: JAX-RS Details of REST Service Provider Implementation of HTTP POST/GET Should Annotation be Placed in the Interface or Implementation Support for Multiple Data Formats (JSON, XML, etc.) Support for Chinese Characters Additional Requirements for XML Format Custom Serialization Configure the Implementation of REST Server Access Context Data Configure the Port Number and Context Path Configure Number of Threads and IO Threads Configure Persistent Connection Configure Maximum Number of HTTP Connections Configure Timeout and HTTP Connections Per Consumer Gzip Data Compression Replace Part of Spring XML Configuration With Annotation Add Custom Filter, Interceptor, etc. Add Custom Exception Handler Configure HTTP Log Output Verification of Input Parameters Should REST Services be Published Transparently Details of REST Service Consumer Scenario 1: Non-Dubbo Consumer Calls Dubbo REST Service Scenario 2: Dubbo Consumer Calls Dubbo REST Service Scenario 3: Dubbo Consumer Calls Non-Dubbo REST Service JAX-RS Restrictions in Dubbo REST FAQ Can Dubbo REST Services be Integrated With Dubbo Registration Center and Monitoring Center? How to Implement Load Balancing and Failover in Dubbo REST? Can Overloaded Methods in JAX-RS Map to Single URL? Can a Method in JAX-RS Receive Multiple Parameters Via POST? Possible shortcomings of Current Dubbo System (Related to REST) Invasiveness of Rpc Context Limitations of Protocol Configuration XML Naming Does Not Conform to the Convention of Spring REST Best Practices Performance Benchmark Test Environment Test Script Test Result Extended Discussion Comparison of REST, Thrift, Protobuf, etc. Comparison Between REST and Traditional Web Services Comparison Between JAX-RS and Spring MVC Future","title":"CONTENT"},{"location":"user/rest/#overview","text":"Dubbo supports a variety of remote calling methods, such as Dubbo RPC (Binary Serialization + TCP), HTTP Invoker (Binary Serialization + HTTP, at least there is no support for Text Serialization in the open source version), Hessian (Binary Serialization + HTTP), Web Services (Text Serialization + HTTP), etc., but lacks support for trending RESTful Remote Calls (Text Serialization + HTTP). Therefore, based on the standard Java REST API: JAX-RS 2.0 (Abbreviation of Java API for RESTful Web Services), we provide a mostly transparent REST Call support for Dubbo. Since it is fully compatible with the Standard Java API, all REST services developed for Dubbo may normally work without Dubbo or any specific underlying REST implementation. It is particularly worth noting that we do not need to strictly adhere to the original definition and architectural style of REST. Even the famous Twitter REST API will make modest adjustments according to the situations, rather than mechanically follow the original REST style. Note: We call this feature RESTful Remoting (abstracted remote process or call) rather than a RESTful RPC (specific remote \"procedure\" call) because REST and RPC can be thought of two different styles. In Dubbo's REST implementation, there are two aspects, one is to provide or consume regular REST services, the other is to make REST a protocol implementation in the Dubbo RPC system, and RESTful Remoting covers both aspects.","title":"Overview"},{"location":"user/rest/#advantages-of-rest","text":"The following is quoted from Wikipedia: REST can use cache to improve response speed more efficiently. The stateless nature of the communication allows a set of servers to handle different requests in series, resulting in the increment of server scalability. Browser can be used as a client to simplify software requirements. REST software dependency is smaller than other mechanisms superimposed on HTTP. REST does not require additional resource discovery mechanism. REST's long-term compatibility is better in software technology evolution. Here I also want to add a particular advantage of REST: REST bases on simple text format messages and universal HTTP. Therefore, it has a broad applicability and is supported by almost all languages and platforms, together with a lower threshold in using and learning.","title":"Advantages of REST"},{"location":"user/rest/#application-scenarios","text":"Because of the advantages of REST in applicability, supporting REST in Dubbo can bring (significant) benefits to most of current mainstream remoting call scenarios: Significantly simplify (cross-language) calls between heterogeneous systems within the enterprise. This is mainly for the following scene: Dubbo acts as a service provider, and systems that are written by other languages (including some java systems that do not base on Dubbo) works as service consumers. The two systems communicate through HTTP and text messages. REST has its unique advantages even comparing to binary cross-language RPC frameworks such as Thrift and ProtoBuf. (See discussion below) Significantly simplify the development of the external Open API (Open Platform). You can use Dubbo to develop a specific Open API application, or you can directly publish the internal Dubbo service as a \"transparent\" REST API (Of course, it's better for Dubbo itself to provide more features transparently, for example, permission control, frequency control, billing and so on). Significantly simplify the development of mobile (tablet) apps or desktop clients. Similar to point 2, you can use Dubbo to develop a specialized server for the applications, or transparently expose the internal Dubbo service. Of course in some projects, mobile or desktop applications can directly access the Open API described in point 2. Significantly simplify the development of AJAX applications on the browser. Similar to point 2, you can use Dubbo to develop a specialized server for AJAX, or transparently expose the internal Dubbo service directly to JavaScript in the browser. Of course, many AJAX applications work better with web frameworks, so direct access to the Dubbo service may not be an exquisite architecture in many web projects. Provide a text-based, easy-to-read remote call method for Dubbo systems within the enterprise (that is, both the service provider and the consumer are Dubbo-based systems). Simplify the call from the Dubbo system to other heterogeneous systems. You can use a simple way like Dubbo to \"transparently\" call REST services provided by Non-Dubbo systems (regardless of whether the service provider is inside or outside the enterprise) It should be pointed out that I think that 1~3 are the most valuable application scenarios for Dubbo's REST call. And the main purpose why we add REST calls for Dubbo is to provide a service-oriented provider. In other words, to develop REST services for Non-Dubbo (heterogeneous) consumers. To sum up, all application scenarios are shown below: Borrowing the most famous slogan of Java in the past, by adding REST calls to Dubbo, you can implement the \"Write once, access everywhere\" service, which can theoretically be accessed all over the world, thus truly achieving an idealized Service-oriented Architecture (SOA). Of course, traditional Web Services (WSDL/SOAP) can meet the requirements (even those that require enterprise-level features) of the above scenarios (except for scenario 4). But due to the complexity and other issues, they are less and less used.","title":"Application scenarios"},{"location":"user/rest/#quick-start","text":"Developing a RESTful service in Dubbo is relatively straightforward. Let's take a simple user registration service for example. The function to be implemented by this service is to provide the following URL (Note: This URL is not entirely RESTful, but more straightforward and more practical): http://localhost:8080/users/register Any client can POST a JSON string containing the user's information to the above URL to complete the user registration. First, implement the interface of the service: public class UserService { void registerUser(User user); } Then, implement the service: @Path( users ) public class UserServiceImpl implements UserService { @POST @Path( register ) @Consumes({MediaType.APPLICATION_JSON}) public void registerUser(User user) { // save the user... } } The above implementation code for the service is very simple, but since the REST service is to be published to a specific HTTP URL so they can be accessed by clients written by any language or even a browser, there are a few additional JAX-RS standard annotations to be added for the relevant configuration: @Path(\"users\"): Specify that the relative path for UserService is /users , standing for http://localhost:8080/users @Path(\"register\"): Specify that the relative path for registerUser() is /register . Combining the previous @Path specified for UserService , the URL to call UserService.register() is HTTP://localhost:8080/users/register @POST: Specify that registerUser() should be accessed with HTTP POST method @Consumes({MediaType.APPLICATION_JSON}): Specify that registerUser() receives data in JSON format. The REST framework will automatically deserialize JSON data into a User object. Finally, add this service to the spring configuration file and finish all service development work: ```xml ## Introduction to Standard Java REST API: JAX-RS JAX-RS is a standard Java REST API that has been widely supported and applied in the industry. There are many well-known open source implementations, including Oracle's Jersey, RedHat's RestEasy, Apache's CXF and Wink, restlet, etc. In addition, all commercial JavaEE application servers that support the JavaEE 6.0 specifications or above support JAX-RS. Therefore, JAX-RS is a very mature solution, and it does not have any so-called vendor lock-in problems. JAX-RS has a wealth of information on the web, such as the following introductory tutorial: * Oracle official tutorial: http://docs.oracle.com/javaee/7/tutorial/doc/jaxrs.htm * Article on IBM developerWorks China: http://www.ibm.com/developerworks/cn/java/j-lo-jaxrs/ For more information, please feel free to Google or Baidu. As far as learning JAX-RS is concerned, it is generally enough to master the usage of various annotations. Note: Dubbo is based on the JAX-RS 2.0, and sometimes you need to pay attention to the version of the reference material or REST implementation. ## REST Service Provider Details In this section, we will expand the `UserService` in the Quick Start to further demonstrate the development points of the REST service provider in Dubbo. ### Implementation of HTTP POST/GET Although it's recommended to use the four standard methods (POST, DELETE, PUT and GET) in the HTTP protocol to implement common CRUD in REST services, but in practice, we generally use POST to implement create and update, and use GET to implement delete and read (DELETE and PUT will even be blocked by some firewalls). The implementation of POST has already been briefly demonstrated. Here, we will add a function to get the registered user data to `UserService`, in order to demonstrate the implementation of GET. This function is to enable the client to obtain user data of different IDs by accessing different URLs as follows: http://localhost:8080/users/1001 http://localhost:8080/users/1002 http://localhost:8080/users/1003 Of course, you can use other forms of URLs to access user data of different IDs, for example: http://localhost:8080/users/load?id=1001 JAX-RS itself can support all of these forms. However, the first form of including query parameters in the URL path (http://localhost:8080/users/1001) is more in line with the general habit of REST, so it is recommended to use. Below we will add a `getUser()` method to the `UserService` to implement this form of URL access: ```java @GET @Path( {id : \\\\d+} ) @Produces({MediaType.APPLICATION_JSON}) public User getUser(@PathParam( id ) Long id) { // ... } @GET: Specify that the method shoule be accessed with HTTP GET method @Path(\"{id : \\d+}\"): According to the above functional requirements, the URL to access getUser() should be \"http://localhost:8080/users/ + any number\", and this number should passed to getUser() method as parameter passed to the getUser() method. In the annotation here, the {id: xxx} in @Path specifies that the relative path contains the id parameter, and its value will be automatically passed to the method parameter id annotated with @PathParam(\"id\"). \\d+ following {id: is a regular expression specifies that the id parameter must be a number. @Produces({MediaType.APPLICATION_JSON}): Specify that getUser() outputs data in JSON format. The REST framework automatically serializes the User object into JSON data.","title":"Quick Start"},{"location":"user/rest/#is-annotation-put-in-interface-class-or-implementation-class","text":"The development of REST services based on Dubbo is mainly configured through JAX-RS annotations. In the above example, we put the annotation in the implementation class of the service. But in fact, we can completely put the annotation in the interface of the service. These two methods are completely equivalent, for example: @Path( users ) public interface UserService { @GET @Path( {id : \\\\d+} ) @Produces({MediaType.APPLICATION_JSON}) User getUser(@PathParam( id ) Long id); } In a typical application, we recommend put the annotation in the service implementation class. Then, annotations are closer to Java implementation code and easier to develop and maintain. More importantly, we generally tend to avoid contamination of the interface, maintaining the purity and wide applicability of the interface. However, as will be described later, if we access this service by using the consumer directly developed by Dubbo, the annotation must be put in the interface. If the interface and the implementation class are both added annotation at the same time, the implementation configuration of the implementation class will take effect, and the annotation on the interface will be ignored.","title":"Is annotation put in interface class or implementation class?"},{"location":"user/rest/#support-for-json-xml-and-other-data-formats","text":"The dubbo REST services can support the transmission of data in multiple formats to provide maximum flexibility to the client. And we add extra functions to the JSON and XML formats which is most commonly used. For example, we want the getUser() method in the above example support returning JSON and XML format data separately, just need to include two formats in the annotation: @Produces({MediaType.APPLICATION_JSON, MediaType.TEXT_XML}) User getUser(@PathParam( id ) Long id); Or you can directly represent a MediaType with a string (also supports wildcards): @Produces({ application/json , text/xml }) User getUser(@PathParam( id ) Long id); If all methods support the same type of input and output data format, then we do not need to make configure on each method, just add annotation to the service class: @Path( users ) @Consumes({MediaType.APPLICATION_JSON, MediaType.TEXT_XML}) @Produces({MediaType.APPLICATION_JSON, MediaType.TEXT_XML}) public class UserServiceImpl implements UserService { // ... } In the case where a REST service supports multiple data formats, according to the JAX-RS standard, the MIME header (content-type and accept) in HTTP is generally used to specify which format data is currently used. But in dubbo, we also automatically support the current common use of the industry, that is, use a URL suffix (.json and .xml) to specify the data format you want to use. For example, after adding the above annotation, directly accessing http://localhost:8888/users/1001.json means using the json format, and directly accessing http://localhost:8888/users/1002.xml means using the xml format. It's simpler and more intuitive than using HTTP Header. This way is used by the REST APIs of Twitter, Weibo, etc. If you don't add HTTP header or suffix, the REST of dubbo will give priority to enable the top ranked data format in the above definition of annotation. Note: To support XML format data, you can use either MediaType.TEXT_XML or MediaType.APPLICATION_XML in annotation, but TEXT_XML is more commonly used, and if you want to use the above URL suffix to specify the data format, you can only configure it as TEXT_XML to take effect.","title":"Support for JSON, XML and other data formats"},{"location":"user/rest/#chinese-character-support","text":"In order to output Chinese characters normally in dubbo REST, as with the usual Java web applications, we need to set the contentType of the HTTP response to UTF-8 encoding. Based on the standard usage of JAX-RS, we only need to do the following annotation configuration: @Produces({ application/json; charset=UTF-8 , text/xml; charset=UTF-8 }) User getUser(@PathParam( id ) Long id); For the convenience of users, we add a support class directly in dubbo REST to define the above constants, which can be used directly and reduce the possibility of error. @Produces({ContentType.APPLICATION_JSON_UTF_8, ContentType.TEXT_XML_UTF_8}) User getUser(@PathParam( id ) Long id);","title":"Chinese character support"},{"location":"user/rest/#additional-requirements-for-xml-data-format","text":"Because the implementation of JAX-RS generally use standard JAXB (Java API for XML Binding) to serialize and deserialize XML format data, we need to add a class-level JAXB annotation for each object to be transferred in XML. Otherwise serialization will report an error. For example, add follows to the User returned in getUser() : @XmlRootElement public class User implements Serializable { // ... } In addition, if the return value in the service method is Java primitive type (such as int, long, float, double, etc.), it is best to add a wrapper object to them, because JAXB can not directly serialize the primitive type. For example, we want the above registerUser() method to return the ID number generated by the server for the user: long registerUser(User user); Because the primitive type is not supported by JAXB serialization, add a wrapper object: @XmlRootElement public class RegistrationResult implements Serializable { private Long id; public RegistrationResult() { } public RegistrationResult(Long id) { this.id = id; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } } And modify the service method: RegistrationResult registerUser(User user); This not only solves the problem of XML serialization, but also makes the returned data conform to the specifications of XML and JSON. For example, in JSON, the returned form would be as follows: { id : 1001} If you do not add a wrapper, the JSON return value will be directly 1001 In XML, the return value after adding wrapper will be: registrationResult id 1002 /id /registrationResult This wrapper object actually uses the so-called Data Transfer Object (DTO) mode, and DTO can also make more useful customizations for transferring data. While in XML, after adding wrapper, the return value will be registrationResult id 1002 /id /registrationResult In fact, this wrapper object uses the so-called Data Transfer Object (DTO) mode. DTO can also be used to make more useful customizations to transfer data.","title":"Additional requirements for XML data format"},{"location":"user/rest/#custom-serialization","text":"As mentioned above, the underlying implementation of REST will automatically serialize/deserialize between the service object and the JSON/XML data format. The REST implementation in Dubbo uses JAXB for XML serialization and Jackson for JSON serialization,so you can customize the mapping by adding JAXB or Jackson's annotation to the object. For example, customizing the object properties to map to the names of the XML elements: @XmlRootElement @XmlAccessorType(XmlAccessType.FIELD) public class User implements Serializable { @XmlElement(name= username ) private String name; } Customizing the object properties to map to the names of the JSON field: public class User implements Serializable { @JsonProperty( username ) private String name; } For more information, please refer to the official documentation of JAXB and Jackson, or google yourself.","title":"Custom Serialization"},{"location":"user/rest/#configuring-rest-server-implementation","text":"Currently in dubbo, we support the implementation of five embedded rest servers. The implementation of the rest server is selected by the following XML attribute of the server: dubbo:protocol name= rest server= jetty / The above configuration uses the embedded jetty to do the rest server. At the same time, if you do not configure the server attribute, the rest protocol also uses jetty by default. jetty is a very mature java servlet container and has a good integration with dubbob (Among the five embedded servers, Only jetty and later tomcat\u3001tjws, complete seamless integration with Dubbo monitoring system.), so, if your dubbo system is a separate process, you can use jetty by default. dubbo:protocol name= rest server= tomcat / The above configuration uses the embedded tomcat to do the rest server.On embedded tomcat, REST performance is much better than jetty (See the benchmark below). It is recommended that Tomcat is used in scenarios where high performance is required. dubbo:protocol name= rest server= netty / The above configuration uses embedded netty to do the rest server. (TODO more contents to add) dubbo:protocol name= rest server= tjws / (tjws is now deprecated) dubbo:protocol name= rest server= sunhttp / The above configuration uses embedded tjws or Sun HTTP server to do the rest server. These two server implementations are very lightweight, it is very convenient for quick start-up in integration testing, of course, it can also be used in a production environment with low load. Note: tjws is currently deprecated because it does not work well with the servlet 3.1 API. If your dubbo system is not a separate process, instead of deploying to a Java application server, we recommend the following configuration: dubbo:protocol name= rest server= servlet / By setting the server as the servlet, dubbo will use the servlet container of the external application server to do the rest server. At the same time, add the following configuration to the web.xml of the dubbo system: web-app context-param param-name contextConfigLocation /param-name param-value /WEB-INF/classes/META-INF/spring/dubbo-demo-provider.xml /param-value /context-param listener listener-class org.apache.dubbo.remoting.http.servlet.BootstrapListener /listener-class /listener listener listener-class org.springframework.web.context.ContextLoaderListener /listener-class /listener servlet servlet-name dispatcher /servlet-name servlet-class org.apache.dubbo.remoting.http.servlet.DispatcherServlet /servlet-class load-on-startup 1 /load-on-startup /servlet servlet-mapping servlet-name dispatcher /servlet-name url-pattern /* /url-pattern /servlet-mapping /web-app In other words, you must add dubbo's BootstrapListener and DispatherServlet to web.xml to complete the integration of dubbo's REST functionality with the external servlet container. Note:If you are using spring's ContextLoaderListener to load spring, you must ensure that the BootstrapListener is configured before the ContextLoaderListener, otherwise the dubbo initialization will fail. In fact, you can still stick to the embedded server in this scenario, but the servlet container of the external application server is often more powerful than the embedded server(Especially if you are deploying to a more robust and scalable WebLogic, WebSphere, etc.). In addition, it is sometimes convenient to do unified management, monitoring, and so on in the application server.","title":"Configuring REST Server implementation"},{"location":"user/rest/#get-context-information","text":"Varieties of context information are valuable when calling procedures remotely. For instance, the IP address from the Client. We provide two methods to get the Client's IP in dubbo. The first one is using @Context annotation from JAX-RS: public User getUser(@PathParam( id ) Long id, @Context HttpServletRequest request) { System.out.println( Client address is + request.getRemoteAddr()); } After decorating a parameter of getUser() with Context, we can inject the current HttpServletRequest and then call the servlet api to get the IP. Notice: This method can only be used when the server is one of the followings: twjs, tomecat, jetty or servlet. All of them provide servlet container. In addition, standard JAX-RS also allow us to get HttpServletRequest using an instance field in service Class decorated by @Context . The second method is to use RpcContext, which is commonly seen in dubbo: public User getUser(@PathParam( id ) Long id) { System.out.println( Client address is + RpcContext.getContext().getRemoteAddressString()); } Notice: Similarly, this method only works in the jetty, tomcat, servlet or tjws server. In dubbo, the usage of RpcContext is rather invasive. We are likely to refactor it in the future. The first method is suggested when your project may run without dubbo and need the compatibility with JAX-RS. But if you want a more elegant service interface definition, the second method would be the better choice. What's more, in the newest version of dubbo REST service, RpcContext could be used to get HttpServletRequest and HttpServletResponse, providing great flexibility for users to implement some complex functions. The following is an example: if (RpcContext.getContext().getRequest() != null RpcContext.getContext().getRequest() instanceof HttpServletRequest) { System.out.println( Client address is + ((HttpServletRequest) RpcContext.getContext().getRequest()).getRemoteAddr()); } if (RpcContext.getContext().getResponse() != null RpcContext.getContext().getResponse() instanceof HttpServletResponse) { System.out.println( Response object from RpcContext: + RpcContext.getContext().getResponse()); } Notice: In order to maintain the neutrality of the protocol, RpcContext.getRequest() and RpcContext.getResponse() only return an Object which could be null. Therefore, you have to check the type on your own. Notice: only when you use jetty, tomcat, servlet as the server can you get the HttpServletRequest and HttpServletResponse as expected. Because only these server implemented the servlet container. To simplify the programme, you can also use generic to get a specific type of request/response: if (RpcContext.getContext().getRequest(HttpServletRequest.class) != null) { System.out.println( Client address is + RpcContext.getContext().getRequest(HttpServletRequest.class).getRemoteAddr()); } if (RpcContext.getContext().getResponse(HttpServletResponse.class) != null) { System.out.println( Response object from RpcContext: + RpcContext.getContext().getResponse(HttpServletResponse.class)); } If request/response does not correspond to the specific type, it would return null.","title":"Get Context Information"},{"location":"user/rest/#configure-the-port-number-and-context-path","text":"The REST protocol in dubbo use 80 as the default port. But you are also allowed to modify it: dubbo:protocol name= rest port= 8888 / As what have been metioned before, we can use @Path to configure relative URL path in single REST service. In fact, we can also set a basic relative path which is known as context path for all REST service. All we need to do is to add the contextpath property: dubbo:protocol name= rest port= 8888 contextpath= services / Let's have a look at the previous code: @Path( users ) public class UserServiceImpl implements UserService { @POST @Path( register ) @Consumes({MediaType.APPLICATION_JSON}) public void registerUser(User user) { // save the user... } } Now the complete path would be: http://localhost:8888/services/users/register Notice: If you use external server as REST server, you should configure as followings, dubbo:protocol name= rest port= 8888 contextpath= services server= servlet / meaning that you should keep the config of port and contextpath are the same with the port and DispatcherServlet's context path (webapp path + servlet url pattern) in external server. For example, when we are configuring the application on tomcat Root path, we need to make sure the contextpath here is totally the same with the url-pattern/ of DispacherServlet in web.xml: servlet-mapping servlet-name dispatcher /servlet-name url-pattern /services/* /url-pattern /servlet-mapping","title":"Configure The Port Number and Context Path"},{"location":"user/rest/#configure-the-number-of-threads-and-io-threads","text":"We can set the number of threads of rest service: dubbo:protocol name= rest threads= 500 / Notice: Currently, the setting only works when the server is netty, jetty or tomcat. If you use servlet as the server, you are using the external server as the REST server which is out of dubboes' control, so the setting would not work expectedly. You can also set threads number of IO worker of netty server: dubbo:protocol name= rest iothreads= 5 threads= 100 /","title":"Configure the number of threads and IO threads"},{"location":"user/rest/#configure-long-connections","text":"The REST service in Dubbo is accessed by default with http long connection, if you want to switch to short connection, you can configure it as below: dubbo:protocol name= rest keepalive= false / Notice: This configuration only works in netty and tomcat.","title":"Configure long connections"},{"location":"user/rest/#configure-the-maximum-number-of-http-connections","text":"Configuring the maximum number of HTTP connections can prevent REST server from overload as the basic self-protection mechanism. dubbo:protocol name= rest accepts= 500 server= tomcat/ Notice: Currently, it only works in tomcat.","title":"Configure the maximum number of HTTP connections"},{"location":"user/rest/#configuring-the-timeout-and-http-connections-for-each-consumer","text":"If the consumer of the rest service is also a dubbo system, you can configure the maximum timeout for the consumer to call the rest service, and the maximum number of HTTP connections that each consumer can initiate, just like other dubbo RPC mechanisms. dubbo:service interface= xxx ref= xxx protocol= rest timeout= 2000 connections= 10 / Of course, since this configuration is valid for the consumer, it can also be configured on the consumer side: dubbo:reference id= xxx interface= xxx timeout= 2000 connections= 10 / However, we generally recommend configuring the service provider to provide such a configuration. According to the official dubbo documentation, \u201cProvider should configure the properties of the Consumer side as much as possible. Let the Provider implementer think about the service features and service quality of the Provider from the beginning.\u201d Note: If dubbo REST service is released to non-dubbo clients, the configuration on dubbo:service/ is completely invalid because the client is not under dubbo control.","title":"Configuring the timeout and HTTP connections for each consumer"},{"location":"user/rest/#gzip-data-compresssion","text":"Dubbo RESTful Remoting supports the use of Gzip to compress request and response data to reduce network transmission time and bandwidth consumption, but this will also increase CPU overhead. TODO more contents to add.","title":"GZIP data compresssion"},{"location":"user/rest/#replacing-part-of-the-spring-xml-configuration-with-annotation","text":"Above discussions are based on the XML configuration of Dubbo in spring. However, dubbo/spring itself supports the use of annotation for configuration, so we can also follow the steps in the Dubbo document and add the relevant annotation to the REST service implementation, replacing some XML configurations, such as: @Service(protocol = rest ) @Path( users ) public class UserServiceImpl implements UserService { @Autowired private UserRepository userRepository; @POST @Path( register ) @Consumes({MediaType.APPLICATION_JSON}) public void registerUser(User user) { // save the user userRepository.save(user); } } Annotation-based configuration is more concise and precise, and often easier to maintain (modern IDE can support such things as class name refactoring in XML, and therefore the maintenance of XML is good for specific use cases here). XML is less intrusive to code, especially for dynamically modifying configurations, especially when you want to modify the timeout for connection of a single service configuration, the maximum number of connections per client, cluster policy, weights, and so on. In addition, for complex applications or modules, XML provides a central point to cover all the components and configurations. It is at a glance, and generally more convenient for long term maintenance of the project. Of course, there's no right or wrong of different choices of configuration method. Sometimes it's just personal preference.","title":"Replacing part of the spring XML configuration with annotation"},{"location":"user/rest/#adding-a-custom-filter-interceptor-etc","text":"Dubbo RESTful Remoting also supports JAX-RS standard Filter and Interceptor to facilitate customized interception of REST request and response processes. Here, Filter is mainly used to access and set parameters, URIs for HTTP request and response, and so on, for example, setting the cache header for HTTP response: public class CacheControlFilter implements ContainerResponseFilter { public void filter(ContainerRequestContext req, ContainerResponseContext res) { if (req.getMethod().equals( GET )) { res.getHeaders().add( Cache-Control , someValue ); } } } Interceptor is mainly used to access and modify the input and output byte streams, for example, manually adding GZIP compression: public class GZIPWriterInterceptor implements WriterInterceptor { @Override public void aroundWriteTo(WriterInterceptorContext context) throws IOException, WebApplicationException { OutputStream outputStream = context.getOutputStream(); context.setOutputStream(new GZIPOutputStream(outputStream)); context.proceed(); } } In standard JAX-RS applications, we generally add @Provider annotations to Filter and Interceptor, and JAX-RS runtime will automatically discover and enable them. In Dubbo, we register Filter and Interceptor by adding an XML configuration: dubbo:protocol name= rest port= 8888 extension= xxx.TraceInterceptor, xxx.TraceFilter / Here, we can add these three types of objects, Filter, Interceptor and DynamicFeature, to the extension attributes, separated by commas. (DynamicFeature is another interface that allows us to enable Filter and Interceptor more dynamically. Please feel free to google.) Of course, Dubbo itself also supports Filter, but the Filter and Interceptor we discuss here are more like the bottom of the protocol implementation. Compared to Dubbo's filter, you can do a lower level of customization here. Note: The XML attribute here is called extension, not interceptor or filter. That is because we will add more extension types in addition to Interceptor and Filter in the future. If the REST consumer is also a Dubbo system (see discussion below), you can also configure the Interceptor and Filter for the consumer in a similar way. However, it should be noted that the consumer-side Filter and the provider-side Filter in JAX-RS are two different interfaces. For example, in the previous example, the server is the ContainerResponseFilter interface, and the consumer side corresponds to the ClientResponseFilter: public class LoggingFilter implements ClientResponseFilter { public void filter(ClientRequestContext reqCtx, ClientResponseContext resCtx) throws IOException { System.out.println( status: + resCtx.getStatus()); System.out.println( date: + resCtx.getDate()); System.out.println( last-modified: + resCtx.getLastModified()); System.out.println( location: + resCtx.getLocation()); System.out.println( headers: ); for (Entry String, List String header : resCtx.getHeaders().entrySet()) { System.out.print( \\t + header.getKey() + : ); for (String value : header.getValue()) { System.out.print(value + , ); } System.out.print( \\n ); } System.out.println( media-type: + resCtx.getMediaType().getType()); } }","title":"Adding a custom Filter, Interceptor, etc"},{"location":"user/rest/#adding-custom-exception-handler","text":"Dubbo RESTful Remoting also supports JAX-RS standard ExceptionMapper, which can be used to customize the HTTP response after a particular exception occurs. public class CustomExceptionMapper implements ExceptionMapper NotFoundException { public Response toResponse(NotFoundException e) { return Response.status(Response.Status.NOT_FOUND).entity( Oops! the requested resource is not found! ).type( text/plain ).build(); } } Similar to Interceptor and Filter, it can be enabled by adding it to an XML configuration file: dubbo:protocol name= rest port= 8888 extension= xxx.CustomExceptiionMapper /","title":"Adding custom Exception handler"},{"location":"user/rest/#configuring-http-log-output","text":"Dubbo RESTful Remoting supports outputting the header and body in all HTTP requests/responses. Add the following REST filter to the XML configuration: dubbo:protocol name= rest port= 8888 extension= org.apache.dubbo.rpc.protocol.rest.support.LoggingFilter / Then turn on at least INFO level log output for org.apache.dubbo.rpc.protocol.rest.support in the logging configuration ,for example,in log4j.xml: logger name= org.apache.dubbo.rpc.protocol.rest.support level value= INFO / appender-ref ref= CONSOLE / /logger Of course, you can also turn on INFO level log output directly in the ROOT logger: root level value= INFO / appender-ref ref= CONSOLE / /root Then there will be something like the following output in the log: The HTTP headers are: accept: application/json;charset=UTF-8 accept-encoding: gzip, deflate connection: Keep-Alive content-length: 22 content-type: application/json host: 192.168.1.100:8888 user-agent: Apache-HttpClient/4.2.1 (java 1.5) The contents of request body is: { id :1, name : dang } After the HTTP log output is turned on, in addition to the performance overhead of the normal log output, additional overhead is generated in, for example, HTTP request parsing, because an additional memory buffer needs to be allocated to prepare the data for the log output.","title":"Configuring HTTP log output"},{"location":"user/rest/#inputing-parameter-validation","text":"Dubbo RESTful Remoting supports the use of the Java standard bean validation annotation(JSR 303) for input validation http://beanvalidation.org/. In order to be consistent with other Dubbo remote invocation protocols, the annotations that are checked for rest must be placed on the interface of the service, for example: public interface UserService { User getUser(@Min(value=1L, message= User ID must be greater than 1 ) Long id); } Of course, in many other bean validation scenarios, annotations are placed on implementation classes rather than interfaces. At least one advantage of placing an annotation on an interface is that the Dubbo client can share information about the interface. The input validation can be done locally even without RPC. Then turn on the validation in the XML configuration in the same way as Dubbo: dubbo:service interface=xxx.UserService ref= userService protocol= rest validation= true / In many other RPC protocols of Dubbo, if the input validation error occurs, the RpcException is directly thrown to the client, but in the rest, since the client is often non-Dubbo or even non-Java system, it is inconvenient to directly throw a Java exception. Therefore, at present we will return the validation error in XML format: violationReport constraintViolations path getUserArgument0 /path message User ID must be greater than 1 /message value 0 /value /constraintViolations /violationReport The return values of other data formats will also be supported later. As for how to internationalize the verification error message, refer directly to the relevant documentation of the bean validation. If you think that the default validation error return format does not meet your requirements, you can add custom ExceptionMapper to custom error return format freely as described in the previous section. It should be noted that this ExceptionMapper must use the generic declaration to capture the RpcException of Dubbo in order to successfully override the default exception handling strategy of Dubbo rest. In order to simplify the operation, the easiest way to do this is to directly inherit the RpcExceptionMapper of Dubbo rest and override the method that handles the validation exception: public class MyValidationExceptionMapper extends RpcExceptionMapper { protected Response handleConstraintViolationException(ConstraintViolationException cve) { ViolationReport report = new ViolationReport(); for (ConstraintViolation cv : cve.getConstraintViolations()) { report.addConstraintViolation(new RestConstraintViolation( cv.getPropertyPath().toString(), cv.getMessage(), cv.getInvalidValue() == null ? null : cv.getInvalidValue().toString())); } // Use json output instead of xml output return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(report).type(ContentType.APPLICATION_JSON_UTF_8).build(); } } Then add this ExceptionMapper to the XML configuration: dubbo:protocol name= rest port= 8888 extension= xxx.MyValidationExceptionMapper /","title":"Inputing parameter validation"},{"location":"user/rest/#whether-to-transparently-publish-rest-service","text":"Dubbo RESTful Remoting differs from some other RPCs in Dubbo in that you need to add JAX-RS annotations (and JAXB, Jackson's annotation) to your service code. If you think these annotations \"pollute\" your service code to a certain extent,you can consider writing additional Facade and DTO classes, adding annotations to that, and Facade forwards the calls to the real service implementation class. Of course, adding annotations directly to the service code basically has no negative effects, and this is itself a standard usage in Java EE. In addition, JAX-RS and JAXB annotations belong to the Java standard. Compared with spring, Dubbo, etc., which we often use, annotations have no problem with vendor lock-in, so there is usually no need to introduce additional objects. In addition,when you want to use the @Context annotation mentioned above, injecting HttpServletRequest through method parameters (such as public User getUser(@PathParam(\"id\") Long id, @Context HttpServletRequest request) ), the method signature of service is changed and HttpServletRequest is a REST-specific parameter, you should introduce additional Facade classes if your service supports multiple RPC mechanisms. Of course, your service code may already act as a Facade and DTO before adding RESTful Remoting (as to why some scenarios require these roles, and if you are interested, you can refer to [Micro-SOA: Service Design Principles and Practices] Http://www.infoq.com/cn/articles/micro-soa-1). In this case, after adding REST, if you add additional REST-related Facade and DTO, it is equivalent to wrapping the original code again, which forms the following call chain: RestFacade/RestDTO - Facade/DTO - Service This kind of system is cumbersome, and the workload of data conversion is not small, so it should be avoided if possible.","title":"Whether to transparently publish REST service"},{"location":"user/rest/#consumer-of-restful-remoting","text":"Here we use three scenarios: The non-Dubbo consumer calls Dubbo REST service (non-Dubbo -- Dubbo) The Dubbo consumer calls Dubbo REST service (Dubbo -- Dubbo) The consumer of Dubbo calls the non-Dubbo REST service (Dubbo -- non-Dubbo)","title":"Consumer of RESTful Remoting"},{"location":"user/rest/#scenario-1-non-dubbo-consumer-calls-dubbo-rest-service","text":"The client of this scenario has nothing to do with Dubbo itself, and it can be directly selected in the appropriate language and framework. If it is still a Java client (but not using Dubbo), consider using the standard JAX-RS Client API or a specific REST-implemented Client API to invoke the REST service. The following is the registerUser() that uses the JAX-RS Client API to access the above UserService: User user = new User(); user.setName( Larry ); Client client = ClientBuilder.newClient(); WebTarget target = client.target( http://localhost:8080/services/users/register.json ); Response response = target.request().post(Entity.entity(user, MediaType.APPLICATION_JSON_TYPE)); try { if (response.getStatus() != 200) { throw new RuntimeException( Failed with HTTP error code : + response.getStatus()); } System.out.println( The generated id is + response.readEntity(RegistrationResult.class).getId()); } finally { response.close(); client.close(); //Do not close the client every time in real development, such as HTTP long connection is held by the client } The User and RegistrationResult classes in the code snippet above are written by the consumer itself, and the JAX-RS Client API automatically serializes/deserializes them. Of course, in Java, you can also use the familiar technologies such as HttpClient, FastJson, XStream, etc. to implement the REST client, which will not be detailed here.","title":"Scenario 1: Non-Dubbo consumer calls Dubbo REST Service"},{"location":"user/rest/#scenario-2-dubbo-consumer-calls-dubbo-restful-remoting","text":"In this scenario, same as other Dubbo remote calling methods, the Java service interface is shared directly between the service provider and the service consumer, and the Spring XML configuration is added (of course, the Spring/Dubbo annotation configuration can also be used),the remote REST service can be called transparently: dubbo:reference id= userService interface= xxx.UserService / As mentioned earlier, in this scenario, JAX-RS annotations must be added to the service interface, so that the corresponding REST configuration information can be shared on the consumer side of Dubbo and remotely called accordingly: @Path( users ) public interface UserService { @GET @Path( {id : \\\\d+} ) @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) User getUser(@PathParam( id ) Long id); } If a variety of data formats are configured in the annotation of the service interface, since both ends are Dubbo systems, a lot of details of REST are blocked, so there is no possibility to select a data format using the aforementioned URL suffix. Currently in this case, the top ranked data format will be used directly. Therefore, we recommend that you put the most appropriate data format in front of defining an annotation. For example, we put JSON in front of XML because JSON's transmission performance is better than XML.","title":"Scenario 2: Dubbo consumer calls Dubbo RESTful Remoting"},{"location":"user/rest/#scenario-3-the-consumer-of-dubbo-calls-a-non-dubbo-restful-remoting","text":"In this scenario, the REST service can be called directly using the Java method described in Scenario 1. But in fact, you can also use the way described in Scenario 2, that is, calling the REST service more transparently, even if this service is not provided by Dubbo. If the scenario 2 is used, since the REST service is not provided by Dubbo, there is generally no shared Java service interface mentioned above, so we need to write the Java interface and the corresponding parameter class according to the external REST service. Add JAX-RS, JAXB, Jackson and other annotations, Dubbo's REST underlying implementation will automatically generate request messages, automatically parse response messages, etc., so as to transparently make remote calls. Or this way can also be understood as, we try to use JAX-RS to copy the implementation of the external REST service provider, and then put the written service interface to the client to use directly, Dubbo REST underlying implementation can call other REST services as it calls Dubbo's REST service . For example, we want to call the following external service. http://api.foo.com/services/users/1001 http://api.foo.com/services/users/1002 Get user data of different IDs, the return format is JSON { id : 1001, name : Larry } We can write service interfaces and parameter classes based on this information: @Path( users ) public interface UserService { @GET @Path( {id : \\\\d+} ) @Produces({MediaType.APPLICATION_JSON}) User getUser(@PathParam( id ) Long id); } public class User implements Serializable { private Long id; private String name; // \u2026 } For the configuration in Spring, because the REST service is not provided by Dubbo, you can not use the Dubbo registry to directly configure the url address of the external REST service (such as multiple addresses separated by commas): dubbo:reference id= userService interface= xxx.UserService url= rest://api.foo.com/services/ / Note: The protocol here must use rest:// instead of http://. If the external REST service has a context path, it must also be added to the url (unless you have a context path in the @Path annotation for each service interface), such as /services/ above. At the same time, the services here must be followed by /, in order to make Dubbo work properly. In addition, you can still configure the maximum number of connections and timeouts that the client can start: dubbo:reference id= userService interface= xxx.UserService url= rest://api.foo.com/services/ timeout= 2000 connections= 10 /","title":"Scenario 3: The consumer of Dubbo calls a non-Dubbo RESTful Remoting"},{"location":"user/rest/#jax-rs-restrictions-in-dubbo","text":"The REST development in Dubbo is fully compatible with standard JAX-RS, but the features it supports are currently a subset of full JAX-RS, in part because it is limited to the specific architecture of Dubbo and Spring. The limitations of JAX-RS used in Dubbo include but are not limited to: Service implementation can only be singleton, and it can not support per-request scope and per-lookup scope It is not supported to inject into ServletConfig, ServletContext, HttpServletRequest, HttpServletResponse, etc. with the @Context annotation for the instance field of the service, but it can support the injection of service method parameters. However, for certain REST server implementations (see the previous section), injection of service method parameters is not supported.","title":"JAX-RS restrictions in Dubbo"},{"location":"user/rest/#rest-faq","text":"","title":"REST FAQ"},{"location":"user/rest/#can-dubbo-rest-services-be-integrated-with-dubbo-registry-and-monitor","text":"Yes, and it will integrate automatically. That is, all the REST services you develop in Dubbo are automatically registered to the Registry and Monitor, by which you can managed your services. However, many of the service governance operations in the Registry can only be fully functional when the REST consumer is based on Dubbo. If the consumer side is non-Dubbo, it is naturally not managed by the Registry, so that many of the operations will not work for the consumer.","title":"Can Dubbo REST services be integrated with Dubbo Registry and Monitor?"},{"location":"user/rest/#how-to-implement-load-balancing-and-failover-in-dubbo-rest","text":"If the consumer side of Dubbo REST is based on Dubbo, then Dubbo REST is basically the same as other Dubbo remote call protocols: Dubbo framework transparently performs load balancing, failover, etc. on the consumer side. If the consumer side of Dubbo REST is non-Dubbo or even non-Java, it is better to configure the soft load balancing mechanism on the service provider. Currently, you can consider LVS, HAProxy, Nginx, and so on to achieve load balancing for HTTP requests.","title":"How to implement load balancing and failover in Dubbo REST?"},{"location":"user/rest/#can-overloaded-method-in-jax-rs-maps-to-the-same-url-address","text":"http://stackoverflow.com/questions/17196766/can-resteasy-choose-method-based-on-query-params","title":"Can overloaded method in JAX-RS maps to the same URL address?"},{"location":"user/rest/#can-a-post-method-in-jax-rs-receive-multiple-parameters","text":"http://stackoverflow.com/questions/5553218/jax-rs-post-multiple-objects","title":"Can a POST method in JAX-RS receive multiple parameters?"},{"location":"user/rest/#the-shortcomings-of-dubbos-current-system-related-to-rest","text":"I think there are obviously a lot of deficiencies in Dubbo's current system. Here are a few REST-related issues that affect users (not including internal implementation issues) for reference and comments, which can help prepare for the refactoring later.","title":"The shortcomings of Dubbo's current system (related to REST)"},{"location":"user/rest/#invasiveness-of-rpccontext","text":"We have already mentioned the intrusiveness of RpcContext(See above). Because it uses a singleton to access context information, which is completely inconsistent with the general style of spring applications as well as not conducive to application extension and unit testing. In the future, we may inject an interface with dependency injection, and then use it to access the context information in ThreadLocal.","title":"Invasiveness of RpcContext"},{"location":"user/rest/#limitations-of-protocol-configuration","text":"Dubbo supports multiple remote call methods, but all call methods are configured with , for example: Dubbo:protocol name= Dubbo port= 9090 server= netty client= netty codec= Dubbo serialization= hessian2 charset= UTF-8 threadpool= fixed threads= 100 queues= 0 iothreads= 9 buffer= 8192 accepts= 1000 payload= 8388608 / Dubbo supports multiple remote call methods, but all call methods are configured with , for example: In fact, many of the above properties are uniquely held by the Dubbo RPC remote call method and many other remote call methods in Dubbo do not support server, client, codec, iothreads, accepts, payload, etc. (of course, some are not supported because of limited conditions, some have no need to be supported at all). This adds a lot of confusions to users when they use Dubbo, and they actually do not know that some attributes (such as performance tuning) will not work after adding them. On the other hand, various remote call methods often have a large number of unique configuration requirements, especially as we gradually add much richer and more advanced functions to each kind of remote call method, which cause the expands in attributes inevitably (for example, we have added keepalive and extension two attributes in REST at the moment) and then lead to bloated and user confusion. Of course, there is a way to expand in Dubbo by using , but this method is obviously very limited, the usage is complicated and the schema verification is lacking. So that the best method is to set your own protocol elements for each remote call, such as , , etc. Each element specifies its own attributes using XML Schema. (Of course, it is best to use common attributes between a variety of remote call methods) In this way, a freer way can be used when doing the extension configuration mentioned above, so that it can be much clearer and more extensible (the following is just an example, of course there may be a better way): Dubbo:protocol-rest port= 8080 Dubbo:extension someInterceptor /Dubbo:extension Dubbo:extension someFilter /Dubbo:extension Dubbo:extension someDynamicFeature /Dubbo:extension Dubbo:extension someEntityProvider /Dubbo:extension /Dubbo:protocol-rest","title":"limitations of Protocol configuration"},{"location":"user/rest/#xml-naming-does-not-conform-to-the-spring-specification","text":"A lot of naming in XML configuration of Dubbo dose not conform to the spring specification, such as: Dubbo:protocol name= Dubbo port= 9090 server= netty client= netty codec= Dubbo serialization= hessian2 charset= UTF-8 threadpool= fixed threads= 100 queues= 0 iothreads= 9 buffer= 8192 accepts= 1000 payload= 8388608 / The above threadpool should be changed to thread-pool, iothreads should be changed to io-threads, and words should be separated by \"-\". While this may seem like a minor issue, it also involves readability, especially scalability, because sometimes we will inevitably use more words to describe XML elements and attributes. In fact, Dubbo itself also recommended to follow the naming convention of spring to XML.","title":"XML naming does not conform to the spring specification"},{"location":"user/rest/#best-practices-of-rest","text":"TODO","title":"Best practices of REST"},{"location":"user/rest/#performance-benchmark","text":"","title":"Performance benchmark"},{"location":"user/rest/#test-environment","text":"Roughly as follows: 4-core Intel(R) Xeon(R) CPU E5-2603 0 @ 1.80GHz 8G memory The network between servers passes through a 100 Mbps switch CentOS 5 JDK 7 Tomcat 7 JVM parameter -server -Xms1g -Xmx1g -XX:PermSize=64M -XX:+UseConcMarkSweepGC","title":"Test Environment"},{"location":"user/rest/#test-script","text":"Similar to Dubbo's own benchmarks: 10 concurrent clients send requests continuously: \u2022 Pass in nested complex objects (single data is small), do nothing and return \u2022 Pass in a 50K string, do nothing and return (TODO: the result is not listed yet) Excute a five-minute performance test. (Reference to Dubbo's own test considerations: \"Mainly consider the serialization and performance of network IO, so that the server side does not have any business logic. Take 10 to run simultaneously because of the consideration that the bottleneck can be hit first when the high CPU usage rate is reached by HTTP protocol under the high concurrency situation.\")","title":"Test Script"},{"location":"user/rest/#test-result","text":"The following results are mainly from the comparison between to the two remote call methods, REST and Dubbo RPC which are configured differently, for example: \u201cREST: Jetty + XML + GZIP\u201d means: Test REST, use jetty server and XML data format, and enable GZIP compression. \u201cDubbo: hessian2\u201d means: test Dubbo RPC and use hessian2 serialization. The results for complex objects are as follows (the smaller Response Time and the larger TPS, the better results): Remote Call Mode Average Response Time Average TPS\uff08Num of transactions per second\uff09 REST: Jetty + JSON 7.806 1280 REST: Jetty + JSON + GZIP TODO TODO REST: Jetty + XML TODO TODO REST: Jetty + XML + GZIP TODO TODO REST: Tomcat + JSON 2.082 4796 REST: Netty + JSON 2.182 4576 Dubbo: FST 1.211 8244 Dubbo: kyro 1.182 8444 Dubbo: Dubbo serialization 1.43 6982 Dubbo: hessian2 1.49 6701 Dubbo: fastjson 1.572 6352 Just a brief summary of the current results: Dubbo RPC (especially when based on efficient java serialization methods such as kryo and fst) has a significant advantage response time and throughput over REST. Dubbo RPC is preferred in the intranet Dubbo systems. When choosinf REST implementation, tomcat7 and netty are optimal (of course, the current versions of jetty and netty are lower) currently only considering performance. Tjws and sun http server performed extremely poorly in performance tests, with an average response time of more than 200ms and an average tps of only about 50 (to avoid affecting the picture effect, the results are not listed above). Performance of JSON data format is better than XML in REST (data is not listed above). Enabling GZIP in REST has little to do with complex objects with small data volume in the intranet, but performance has declined (data is not listed above).","title":"Test Result"},{"location":"user/rest/#performance-optimization-recommendations","text":"If you deploy Dubbo REST to an external Tomcat and configure server=\"servlet\", that is, enable external tomcat as the underlying implementation of rest server, it is best to add the following configuration to tomcat: Connector port= 8080 protocol= org.apache.coyote.http11.Http11NioProtocol connectionTimeout= 20000 redirectPort= 8443 minSpareThreads= 20 enableLookups= false maxThreads= 100 maxKeepAliveRequests= -1 keepAliveTimeout= 60000 / Especially the configuration maxKeepAliveRequests=\"-1\" ,which is mainly to ensure that tomcat always enables http long connection, in order to improve the performance of REST call. Note, however, that if the REST consumer side is not continuously call REST services, it is not always best to enable long connections all time. In addition, the way to always enable long connections is generally not suitable for ordinary webapps, but more suitable for such rpc-like scenarios. So that in order to get high performance, Dubbo REST applications and ordinary web applications are best not to be mixed deployment, but should use a separate instance in tomcat.","title":"Performance Optimization Recommendations"},{"location":"user/rest/#extended-discussion","text":"","title":"Extended discussion"},{"location":"user/rest/#comparison-among-rest-thrift-protobuf-and-so-on","text":"TODO","title":"Comparison among Rest, Thrift, Protobuf and so on"},{"location":"user/rest/#comparison-between-rest-and-traditional-webservers","text":"TODO","title":"Comparison between REST and traditional Webservers"},{"location":"user/rest/#comparison-of-jax-rs-between-spring-mvc","text":"A preliminary view from http://www.infoq.com/cn/news/2014/10/Dubbox-open-source?utm_source=infoq utm_medium=popular_links_homepage#theCommentsSection Thank you, in fact, for jax-rs and Spring MVC, I do not have a deep look at the rest support of Spring MVC. I would like to give you some preliminary ideas. Please correct me: Spring MVC also supports configuration using annotation, which actually looks very similar to jax-rs. Personally, I think Spring MVC is better suited to restful services of web applications, such as being invoked by AJAX, or possibly outputting HTML or something like page jump processes in applications. Spring MVC can handle both normal web page requests and rest requests at the same time. But in general, the restful service is implemented in the presentation layer or the web layer. But Jax-rs is more suitable for pure service-oriented applications, that is, the middle-tier services in traditional Java EE, for example, it can publish traditional EJB as restful services. In a Spring application, the bean that acts as a service in the Spring is directly published as a restful service. In general, the restful service is at the business layer, application layer, or facade layer. And MVC hierarchies and concepts are often of little value in such (back-end) applications. Of course, some implementations of jax-rs, such as jersey, also try to include MVC to better accommodate the web applications described above, but not as well as Spring MVC. In Dubbo applications, I think a lot of people prefer to publish a local Spring service bean (or manager) as a remote service directly and transparently, so that it is more straightforward to use JAX-RS here, and there is no need to introduce the MVC concept. Of course, we do not discuss whether transparent publishing of remote services is a best practice or whether to add facade things here first. Of course, I know that many people use Spring MVC restful to call Dubbo (spring) service to publish restful services under the situation that Dubbo does not support rest now. It\u2019s a good method also in my opinion, but if you do not modify Spring MVC and integrate it deeply with Dubbo, restful services cannot enjoy many advanced services such as registering to the Dubbo Registry, monitoring the number of calls, TPS, response time through the Dubbo Monitor, controlling the size of the thread pool and the maximum number of connections through the unified configuration of Dubbo, and controlling the service flow, authority and frequency through Dubbo unified mode like other remote call protocol such as webservices, Dubbo rpc, hessian and so on in Dubbo system. In addition, Spring MVC only works in server side and Spring restTemplate are usually used on consumer side. If restTemplate is not integrated with Dubbo, the service can be downgraded by Dubbo client automatically or manually. If the server and consumer are all Dubbo system, you cannot use unified routing and other functions in Dubbo if the Spring rest is not deeply integrated into Dubbo through interaction of Spring and rest. Of course, I personally think that these things are not necessarily to be one or the other. I heard that Rod Johnson, the founder of spring usually says \u2018the customer is always right,\u2019 In fact, it is better to support both ways at the same time rather than discuss which way is better, so that originally I wrote in the document that we plan to support Spring rest annotation, but the feasibility is unknown.","title":"Comparison of JAX-RS Between Spring MVC"},{"location":"user/rest/#future","text":"Functions may be supported later: Rest annotation for Spring MVC Safety System OAuth Asynchronous calls Gzip Payload maxsize","title":"Future"},{"location":"user/simple-monitor/","text":"Monitor service is a standard Dubbo service\uff0ccan be exported to the registry\uff0calso can be connected straightly\u3002 Install the simple registry export a simple monitor service to the registry: (If you use the installer, you don't need to write this configuration yourself. if you implement the monitor service yourself\uff0cneed it) ```xml ``` Discovery the monitor service int the registry: xml dubbo:monitor protocol=\"registry\" / or dubbo.properties xml dubbo.monitor.protocol=registry Export a simple monitor service \uff0cbut don't register it to th registry: (If you use the installer, you don't need to write this configuration yourself. if you implement the monitor service yourself\uff0cneed it) ```xml ``` connected to the monitor service straightly xml dubbo:monitor address=\"dubbo://127.0.0.1:7070/org.apache.dubbo.monitor.MonitorService\" / or\uff1a sh dubbo:monitor address=\"127.0.0.1:7070\" / or\uff1a dubbo.properties sh dubbo.monitor.address=127.0.0.1:7070","title":"Simple monitor"},{"location":"user/configuration/","text":"Configuration","title":"Configuration"},{"location":"user/configuration/#configuration","text":"","title":"Configuration"},{"location":"user/configuration/annotation/","text":"Annotation Configuration Requires 2.6.3 or higher click here to view the complete sample Provider Side Service annotation for exporting @Service public class AnnotationServiceImpl implements AnnotationService { @Override public String sayHello(String name) { return annotation: hello, + name; } } Add application sharing configuration # dubbo-provider.properties dubbo.application.name=annotation-provider dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.protocol.name=dubbo dubbo.protocol.port=20880 Spring scan path @Configuration @EnableDubbo(scanBasePackages = org.apache.dubbo.samples.simple.annotation.impl ) @PropertySource( classpath:/spring/dubbo-provider.properties ) static public class ProviderConfiguration { } Consumer Side Reference annotation for reference @Component( annotationAction ) public class AnnotationAction { @Reference private AnnotationService annotationService; public String doSayHello(String name) { return annotationService.sayHello(name); } } Add application sharing configuration # dubbo-consumer.properties dubbo.application.name=annotation-consumer dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.consumer.timeout=3000 Spring scan path @Configuration @EnableDubbo(scanBasePackages = org.apache.dubbo.samples.simple.annotation.action ) @PropertySource( classpath:/spring/dubbo-consumer.properties ) @ComponentScan(value = { org.apache.dubbo.samples.simple.annotation.action }) static public class ConsumerConfiguration { } Invoke service public static void main(String[] args) throws Exception { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConsumerConfiguration.class); context.start(); final AnnotationAction annotationAction = (AnnotationAction) context.getBean( annotationAction ); String hello = annotationAction.doSayHello( world ); }","title":"Annotation Configuration"},{"location":"user/configuration/annotation/#annotation-configuration","text":"Requires 2.6.3 or higher click here to view the complete sample","title":"Annotation Configuration"},{"location":"user/configuration/annotation/#provider-side","text":"","title":"Provider Side"},{"location":"user/configuration/annotation/#service-annotation-for-exporting","text":"@Service public class AnnotationServiceImpl implements AnnotationService { @Override public String sayHello(String name) { return annotation: hello, + name; } }","title":"Service annotation for exporting"},{"location":"user/configuration/annotation/#add-application-sharing-configuration","text":"# dubbo-provider.properties dubbo.application.name=annotation-provider dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.protocol.name=dubbo dubbo.protocol.port=20880","title":"Add application sharing configuration"},{"location":"user/configuration/annotation/#spring-scan-path","text":"@Configuration @EnableDubbo(scanBasePackages = org.apache.dubbo.samples.simple.annotation.impl ) @PropertySource( classpath:/spring/dubbo-provider.properties ) static public class ProviderConfiguration { }","title":"Spring scan path"},{"location":"user/configuration/annotation/#consumer-side","text":"","title":"Consumer Side"},{"location":"user/configuration/annotation/#reference-annotation-for-reference","text":"@Component( annotationAction ) public class AnnotationAction { @Reference private AnnotationService annotationService; public String doSayHello(String name) { return annotationService.sayHello(name); } }","title":"Reference annotation for reference"},{"location":"user/configuration/annotation/#add-application-sharing-configuration_1","text":"# dubbo-consumer.properties dubbo.application.name=annotation-consumer dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.consumer.timeout=3000","title":"Add application sharing configuration"},{"location":"user/configuration/annotation/#spring-scan-path_1","text":"@Configuration @EnableDubbo(scanBasePackages = org.apache.dubbo.samples.simple.annotation.action ) @PropertySource( classpath:/spring/dubbo-consumer.properties ) @ComponentScan(value = { org.apache.dubbo.samples.simple.annotation.action }) static public class ConsumerConfiguration { }","title":"Spring scan path"},{"location":"user/configuration/annotation/#invoke-service","text":"public static void main(String[] args) throws Exception { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConsumerConfiguration.class); context.start(); final AnnotationAction annotationAction = (AnnotationAction) context.getBean( annotationAction ); String hello = annotationAction.doSayHello( world ); }","title":"Invoke service"},{"location":"user/configuration/api/","text":"API Configuration All API properties have counterparts in XML, see XML References for details. For example ApplicationConfig.setName(\"xxx\") equals to dubbo:application name=\"xxx\" / [^1] Provider Side import org.apache.dubbo.rpc.config.ApplicationConfig; import org.apache.dubbo.rpc.config.RegistryConfig; import org.apache.dubbo.rpc.config.ProviderConfig; import org.apache.dubbo.rpc.config.ServiceConfig; import com.xxx.XxxService; import com.xxx.XxxServiceImpl; // Implementation XxxService xxxService = new XxxServiceImpl(); // Application Info ApplicationConfig application = new ApplicationConfig(); application.setName( xxx ); // Registry Info RegistryConfig registry = new RegistryConfig(); registry.setAddress( 10.20.130.230:9090 ); registry.setUsername( aaa ); registry.setPassword( bbb ); // Protocol ProtocolConfig protocol = new ProtocolConfig(); protocol.setName( dubbo ); protocol.setPort(12345); protocol.setThreads(200); // NOTES: ServiceConfig holds the serversocket instance and keeps connections to registry, please cache it for performance. // Exporting ServiceConfig XxxService service = new ServiceConfig XxxService (); // In case of memory leak, please cache. service.setApplication(application); service.setRegistry(registry); // Use setRegistries() for multi-registry case service.setProtocol(protocol); // Use setProtocols() for multi-protocol case service.setInterface(XxxService.class); service.setRef(xxxService); service.setVersion( 1.0.0 ); // Local export and register service.export(); Consumer Side import org.apache.dubbo.rpc.config.ApplicationConfig; import org.apache.dubbo.rpc.config.RegistryConfig; import org.apache.dubbo.rpc.config.ConsumerConfig; import org.apache.dubbo.rpc.config.ReferenceConfig; import com.xxx.XxxService; // Application Info ApplicationConfig application = new ApplicationConfig(); application.setName( yyy ); // Registry Info RegistryConfig registry = new RegistryConfig(); registry.setAddress( 10.20.130.230:9090 ); registry.setUsername( aaa ); registry.setPassword( bbb ); // NOTES: ReferenceConfig holds the connections to registry and providers, please cache it for performance. // Refer remote service ReferenceConfig XxxService reference = new ReferenceConfig XxxService (); // In case of memory leak, please cache. reference.setApplication(application); reference.setRegistry(registry); reference.setInterface(XxxService.class); reference.setVersion( 1.0.0 ); // Use xxxService just like a local bean XxxService xxxService = reference.get(); // NOTES: Please cache this proxy instance. Specials Only care about the differences: Configuration of Method level ... // Method level config List MethodConfig methods = new ArrayList MethodConfig (); MethodConfig method = new MethodConfig(); method.setName( createXxx ); method.setTimeout(10000); method.setRetries(0); methods.add(method); // Referring ReferenceConfig XxxService reference = new ReferenceConfig XxxService (); ... reference.setMethods(methods); ... Peer to Peer ... ReferenceConfig XxxService reference = new ReferenceConfig XxxService (); // If you know the address of the provider and want to bypass the registry, use `reference.setUrl()` to specify the provider directly. Refer [How to Invoke a specific provider](../demos/explicit-target.md) for details. reference.setUrl( dubbo://10.20.130.230:20880/com.xxx.XxxService ); ... [^1]: When should we usd API: API is very useful for integrating with systems like OpenAPI, ESB, Test, Mock, etc. General Providers and Consumers, we still recommend use XML Configuration .","title":"API Configuration"},{"location":"user/configuration/api/#api-configuration","text":"All API properties have counterparts in XML, see XML References for details. For example ApplicationConfig.setName(\"xxx\") equals to dubbo:application name=\"xxx\" / [^1]","title":"API Configuration"},{"location":"user/configuration/api/#provider-side","text":"import org.apache.dubbo.rpc.config.ApplicationConfig; import org.apache.dubbo.rpc.config.RegistryConfig; import org.apache.dubbo.rpc.config.ProviderConfig; import org.apache.dubbo.rpc.config.ServiceConfig; import com.xxx.XxxService; import com.xxx.XxxServiceImpl; // Implementation XxxService xxxService = new XxxServiceImpl(); // Application Info ApplicationConfig application = new ApplicationConfig(); application.setName( xxx ); // Registry Info RegistryConfig registry = new RegistryConfig(); registry.setAddress( 10.20.130.230:9090 ); registry.setUsername( aaa ); registry.setPassword( bbb ); // Protocol ProtocolConfig protocol = new ProtocolConfig(); protocol.setName( dubbo ); protocol.setPort(12345); protocol.setThreads(200); // NOTES: ServiceConfig holds the serversocket instance and keeps connections to registry, please cache it for performance. // Exporting ServiceConfig XxxService service = new ServiceConfig XxxService (); // In case of memory leak, please cache. service.setApplication(application); service.setRegistry(registry); // Use setRegistries() for multi-registry case service.setProtocol(protocol); // Use setProtocols() for multi-protocol case service.setInterface(XxxService.class); service.setRef(xxxService); service.setVersion( 1.0.0 ); // Local export and register service.export();","title":"Provider Side"},{"location":"user/configuration/api/#consumer-side","text":"import org.apache.dubbo.rpc.config.ApplicationConfig; import org.apache.dubbo.rpc.config.RegistryConfig; import org.apache.dubbo.rpc.config.ConsumerConfig; import org.apache.dubbo.rpc.config.ReferenceConfig; import com.xxx.XxxService; // Application Info ApplicationConfig application = new ApplicationConfig(); application.setName( yyy ); // Registry Info RegistryConfig registry = new RegistryConfig(); registry.setAddress( 10.20.130.230:9090 ); registry.setUsername( aaa ); registry.setPassword( bbb ); // NOTES: ReferenceConfig holds the connections to registry and providers, please cache it for performance. // Refer remote service ReferenceConfig XxxService reference = new ReferenceConfig XxxService (); // In case of memory leak, please cache. reference.setApplication(application); reference.setRegistry(registry); reference.setInterface(XxxService.class); reference.setVersion( 1.0.0 ); // Use xxxService just like a local bean XxxService xxxService = reference.get(); // NOTES: Please cache this proxy instance.","title":"Consumer Side"},{"location":"user/configuration/api/#specials","text":"Only care about the differences:","title":"Specials"},{"location":"user/configuration/api/#configuration-of-method-level","text":"... // Method level config List MethodConfig methods = new ArrayList MethodConfig (); MethodConfig method = new MethodConfig(); method.setName( createXxx ); method.setTimeout(10000); method.setRetries(0); methods.add(method); // Referring ReferenceConfig XxxService reference = new ReferenceConfig XxxService (); ... reference.setMethods(methods); ...","title":"Configuration of Method level"},{"location":"user/configuration/api/#peer-to-peer","text":"... ReferenceConfig XxxService reference = new ReferenceConfig XxxService (); // If you know the address of the provider and want to bypass the registry, use `reference.setUrl()` to specify the provider directly. Refer [How to Invoke a specific provider](../demos/explicit-target.md) for details. reference.setUrl( dubbo://10.20.130.230:20880/com.xxx.XxxService ); ... [^1]: When should we usd API: API is very useful for integrating with systems like OpenAPI, ESB, Test, Mock, etc. General Providers and Consumers, we still recommend use XML Configuration .","title":"Peer to Peer"},{"location":"user/configuration/configuration-load-process/","text":"Configuration Loading Process This document focuses on how the Dubbo framework collects the required configuration (including application configuration, registry configuration, service configuration, etc.) during the application startup phase to complete the process of service exposure and reference. Depending on how you drive it (such as Spring or naked API programming), the configuration form will certainly vary, for detail please refer to XML Configuration , Annotation Configuration and API Configuration . In addition to the differences in peripheral drivers, Dubbo's configuration reads generally follow the following principles: Dubbo supports multiple levels of configuration and automatically override configurations according to predetermined priorities. Eventually, all configurations are aggregated to the data bus URL to drive subsequent service exposure, reference and other processes. ApplicationConfig, ServiceConfig and ReferenceConfig can be regarded as configuration sources, which collect configuration by directly user-oriented programming. The configuration format is mainly Properties , and the configuration content follows conventions The configuration format is mainly Properties, and the configuration content follows the agreed path-based naming specification . Configuration Source First, starting with the configuration sources that Dubbo supports, there are four default configuration sources: JVM System Properties\uff0c-Dproperty Externalized Configuration ServiceConfig, ReferenceConfig and other programming interface collected configuration Local configuration file dubbo.properties Override Priority The figure below shows the priority of configuration override, decreasing from top to bottom: click here to view Externalize configuration details Configuration Format Currently, all configurations supported by Dubbo are in the format of .properties , including -D , Externalized Configuration , etc., and all configuration items in .properties follow a path-based Configuration format: # Application level dubbo.{config-type}[.{config-id}].{config-item}={config-item-value} # Service level dubbo.service.{interface-name}[.{method-name}].{config-item}={config-item-value} dubbo.reference.{interface-name}[.{method-name}].{config-item}={config-item-value} # Multiple configuration items dubbo.{config-type}s.{config-id}.{config-item}={config-item-value} Application level dubbo.application.name=demo-provider dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.protocol.port=-1 Service level dubbo.service.org.apache.dubbo.samples.api.DemoService.timeout=5000 dubbo.reference.org.apache.dubbo.samples.api.DemoService.timeout=6000 dubbo.reference.org.apache.dubbo.samples.api.DemoService.sayHello.timeout=7000 Multiple configuration items dubbo.registries.unit1.address=zookeeper://127.0.0.1:2181 dubbo.registries.unit2.address=zookeeper://127.0.0.1:2182 dubbo.protocols.dubbo.name=dubbo dubbo.protocols.dubbo.port=20880 dubbo.protocols.hessian.name=hessian dubbo.protocols.hessian.port=8089 Extended configuration dubbo.application.parameters.item1=value1 dubbo.application.parameters.item2=value2 dubbo.registry.parameters.item3=value3 dubbo.reference.org.apache.dubbo.samples.api.DemoService.parameters.item4=value4 Several programming approaches of configuration Next, let's look at the changes corresponding to ServiceConfig, ReferenceConfig and other programming interface collected configuration when selecting different development methods. Spring XML Refer to the sample !-- dubbo-provier.xml -- dubbo:application name= demo-provider / dubbo:config-center address= zookeeper://127.0.0.1:2181 / dubbo:registry address= zookeeper://127.0.0.1:2181 simplified= true / dubbo:metadata-report address= redis://127.0.0.1:6379 / dubbo:protocol name= dubbo port= 20880 / bean id= demoService class= org.apache.dubbo.samples.basic.impl.DemoServiceImpl / dubbo:service interface= org.apache.dubbo.samples.basic.api.DemoService ref= demoService / ``` - Annotation Refer to [the sample](https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-annotation) ```java // AnnotationService implementation @Service public class AnnotationServiceImpl implements AnnotationService { @Override public String sayHello(String name) { System.out.println( async provider received: + name); return annotation: hello, + name; } } ``` ```properties ## dubbo.properties dubbo.application.name=annotation-provider dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.protocol.name=dubbo dubbo.protocol.port=20880 Spring Boot Refer to the sample ## application.properties # Spring boot application spring.application.name=dubbo-externalized-configuration-provider-sample # Base packages to scan Dubbo Component: @com.alibaba.dubbo.config.annotation.Service dubbo.scan.base-packages=com.alibaba.boot.dubbo.demo.provider.service # Dubbo Application ## The default value of dubbo.application.name is ${spring.application.name} ## dubbo.application.name=${spring.application.name} # Dubbo Protocol dubbo.protocol.name=dubbo dubbo.protocol.port=12345 ## Dubbo Registry dubbo.registry.address=N/A ## DemoService version demo.service.version=1.0.0 API public static void main(String[] args) throws IOException { ServiceConfig GreetingsService service = new ServiceConfig (); service.setApplication(new ApplicationConfig( first-dubbo-provider )); service.setRegistry(new RegistryConfig( multicast://224.5.6.7:1234 )); service.setInterface(GreetingsService.class); service.setRef(new GreetingsServiceImpl()); service.export(); System.out.println( first-dubbo-provider is running. ); System.in.read(); } Refer to the sample","title":"Configuration Loading Process"},{"location":"user/configuration/configuration-load-process/#configuration-loading-process","text":"This document focuses on how the Dubbo framework collects the required configuration (including application configuration, registry configuration, service configuration, etc.) during the application startup phase to complete the process of service exposure and reference. Depending on how you drive it (such as Spring or naked API programming), the configuration form will certainly vary, for detail please refer to XML Configuration , Annotation Configuration and API Configuration . In addition to the differences in peripheral drivers, Dubbo's configuration reads generally follow the following principles: Dubbo supports multiple levels of configuration and automatically override configurations according to predetermined priorities. Eventually, all configurations are aggregated to the data bus URL to drive subsequent service exposure, reference and other processes. ApplicationConfig, ServiceConfig and ReferenceConfig can be regarded as configuration sources, which collect configuration by directly user-oriented programming. The configuration format is mainly Properties , and the configuration content follows conventions The configuration format is mainly Properties, and the configuration content follows the agreed path-based naming specification .","title":"Configuration Loading Process"},{"location":"user/configuration/configuration-load-process/#configuration-source","text":"First, starting with the configuration sources that Dubbo supports, there are four default configuration sources: JVM System Properties\uff0c-Dproperty Externalized Configuration ServiceConfig, ReferenceConfig and other programming interface collected configuration Local configuration file dubbo.properties","title":"Configuration Source"},{"location":"user/configuration/configuration-load-process/#override-priority","text":"The figure below shows the priority of configuration override, decreasing from top to bottom: click here to view Externalize configuration details","title":"Override Priority"},{"location":"user/configuration/configuration-load-process/#configuration-format","text":"Currently, all configurations supported by Dubbo are in the format of .properties , including -D , Externalized Configuration , etc., and all configuration items in .properties follow a path-based Configuration format: # Application level dubbo.{config-type}[.{config-id}].{config-item}={config-item-value} # Service level dubbo.service.{interface-name}[.{method-name}].{config-item}={config-item-value} dubbo.reference.{interface-name}[.{method-name}].{config-item}={config-item-value} # Multiple configuration items dubbo.{config-type}s.{config-id}.{config-item}={config-item-value} Application level dubbo.application.name=demo-provider dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.protocol.port=-1 Service level dubbo.service.org.apache.dubbo.samples.api.DemoService.timeout=5000 dubbo.reference.org.apache.dubbo.samples.api.DemoService.timeout=6000 dubbo.reference.org.apache.dubbo.samples.api.DemoService.sayHello.timeout=7000 Multiple configuration items dubbo.registries.unit1.address=zookeeper://127.0.0.1:2181 dubbo.registries.unit2.address=zookeeper://127.0.0.1:2182 dubbo.protocols.dubbo.name=dubbo dubbo.protocols.dubbo.port=20880 dubbo.protocols.hessian.name=hessian dubbo.protocols.hessian.port=8089 Extended configuration dubbo.application.parameters.item1=value1 dubbo.application.parameters.item2=value2 dubbo.registry.parameters.item3=value3 dubbo.reference.org.apache.dubbo.samples.api.DemoService.parameters.item4=value4","title":"Configuration Format"},{"location":"user/configuration/configuration-load-process/#several-programming-approaches-of-configuration","text":"Next, let's look at the changes corresponding to ServiceConfig, ReferenceConfig and other programming interface collected configuration when selecting different development methods.","title":"Several programming approaches of configuration"},{"location":"user/configuration/configuration-load-process/#spring","text":"XML Refer to the sample !-- dubbo-provier.xml -- dubbo:application name= demo-provider / dubbo:config-center address= zookeeper://127.0.0.1:2181 / dubbo:registry address= zookeeper://127.0.0.1:2181 simplified= true / dubbo:metadata-report address= redis://127.0.0.1:6379 / dubbo:protocol name= dubbo port= 20880 / bean id= demoService class= org.apache.dubbo.samples.basic.impl.DemoServiceImpl / dubbo:service interface= org.apache.dubbo.samples.basic.api.DemoService ref= demoService / ``` - Annotation Refer to [the sample](https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-annotation) ```java // AnnotationService implementation @Service public class AnnotationServiceImpl implements AnnotationService { @Override public String sayHello(String name) { System.out.println( async provider received: + name); return annotation: hello, + name; } } ``` ```properties ## dubbo.properties dubbo.application.name=annotation-provider dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.protocol.name=dubbo dubbo.protocol.port=20880 Spring Boot Refer to the sample ## application.properties # Spring boot application spring.application.name=dubbo-externalized-configuration-provider-sample # Base packages to scan Dubbo Component: @com.alibaba.dubbo.config.annotation.Service dubbo.scan.base-packages=com.alibaba.boot.dubbo.demo.provider.service # Dubbo Application ## The default value of dubbo.application.name is ${spring.application.name} ## dubbo.application.name=${spring.application.name} # Dubbo Protocol dubbo.protocol.name=dubbo dubbo.protocol.port=12345 ## Dubbo Registry dubbo.registry.address=N/A ## DemoService version demo.service.version=1.0.0","title":"Spring"},{"location":"user/configuration/configuration-load-process/#api","text":"public static void main(String[] args) throws IOException { ServiceConfig GreetingsService service = new ServiceConfig (); service.setApplication(new ApplicationConfig( first-dubbo-provider )); service.setRegistry(new RegistryConfig( multicast://224.5.6.7:1234 )); service.setInterface(GreetingsService.class); service.setRef(new GreetingsServiceImpl()); service.export(); System.out.println( first-dubbo-provider is running. ); System.in.read(); } Refer to the sample","title":"API"},{"location":"user/configuration/properties/","text":"Properties Configuration If your application is simple enough, say, you do not need multi-registries or multi-protocols, and you want to share configuration among Spring containers. You can use dubbo.properties as default configuration. Dubbo will load dubbo.properties under the root of classpath automatically, you can also specify the path for loading this file by using JVM parameter: -Ddubbo.properties.file=xxx.properties . Mapping Rules Combine the tag name and attribute name of the XML tag, use . to split. One property per line. dubbo.application.name=foo equals to dubbo:application name=\"foo\" / dubbo.registry.address=10.20.153.10:9090 equals to dubbo:registry address=\"10.20.153.10:9090\" / If you have more than one tags in a XML configuration, you can use the id value to distinguish. If you don't specify a id, ti will applied to all tags. dubbo.protocol.rmi.port=1099 equals to dubbo:protocol id=\"rmi\" name=\"rmi\" port=\"1099\" / dubbo.registry.china.address=10.20.153.10:9090 equals to dubbo:registry id=\"china\" address=\"10.20.153.10:9090\" / Here is a typical dubbo.properties demo configuration\uff1a dubbo.application.name=foo dubbo.application.owner=bar dubbo.registry.address=10.20.153.10:9090 Overrides and Priorities Priorities from high to low: JVM -D parameters, you can easily override configuration when deploying or starting applications, e.g., change the port of dubbo protocol. XML, the properties present in XML will override that in dubbo.properties. Properties, the default value, only works when it is not configured with XML or JVM. 1: If more than one dubbo.properties under classpath, say, two jars contains dubbo.properties separately, Dubbo will arbitarily choose one to to load, and log Error info. 2: If id not configured on protocol , will use name property as default","title":"Properties Configuration"},{"location":"user/configuration/properties/#properties-configuration","text":"If your application is simple enough, say, you do not need multi-registries or multi-protocols, and you want to share configuration among Spring containers. You can use dubbo.properties as default configuration. Dubbo will load dubbo.properties under the root of classpath automatically, you can also specify the path for loading this file by using JVM parameter: -Ddubbo.properties.file=xxx.properties .","title":"Properties Configuration"},{"location":"user/configuration/properties/#mapping-rules","text":"Combine the tag name and attribute name of the XML tag, use . to split. One property per line. dubbo.application.name=foo equals to dubbo:application name=\"foo\" / dubbo.registry.address=10.20.153.10:9090 equals to dubbo:registry address=\"10.20.153.10:9090\" / If you have more than one tags in a XML configuration, you can use the id value to distinguish. If you don't specify a id, ti will applied to all tags. dubbo.protocol.rmi.port=1099 equals to dubbo:protocol id=\"rmi\" name=\"rmi\" port=\"1099\" / dubbo.registry.china.address=10.20.153.10:9090 equals to dubbo:registry id=\"china\" address=\"10.20.153.10:9090\" / Here is a typical dubbo.properties demo configuration\uff1a dubbo.application.name=foo dubbo.application.owner=bar dubbo.registry.address=10.20.153.10:9090","title":"Mapping Rules"},{"location":"user/configuration/properties/#overrides-and-priorities","text":"Priorities from high to low: JVM -D parameters, you can easily override configuration when deploying or starting applications, e.g., change the port of dubbo protocol. XML, the properties present in XML will override that in dubbo.properties. Properties, the default value, only works when it is not configured with XML or JVM. 1: If more than one dubbo.properties under classpath, say, two jars contains dubbo.properties separately, Dubbo will arbitarily choose one to to load, and log Error info. 2: If id not configured on protocol , will use name property as default","title":"Overrides and Priorities"},{"location":"user/configuration/xml/","text":"XML Configuration About the XML configuration items, see\uff1a XML References . If you prefer use API directly instead of using Spring, see API Configuration . Want a example of how to use configuration, see Quick Start \u3002 provider.xml demo ?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd dubbo:application name= hello-world-app / dubbo:registry address= multicast://224.5.6.7:1234 / dubbo:protocol name= dubbo port= 20880 / dubbo:service interface= org.apache.dubbo.demo.DemoService ref= demoServiceLocal / dubbo:reference id= demoServiceRemote interface= org.apache.dubbo.demo.DemoService / /beans All tags support custom parameters, so we can meet the special config requirements at different extension points, such as: dubbo:protocol name= jms dubbo:parameter key= queue value= your_queue / /dubbo:protocol Or: beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xmlns:p= http://www.springframework.org/schema/p xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd dubbo:protocol name= jms p:queue= your_queue / /beans The relations between configuration tags tag purpose introduction dubbo:service/ Service Export Used to export service, define service metadata, export service with multiple protocols, register service to multiple registries dubbo:reference/ Service Reference Used to create a remote proxy, subscribe to multiple registries dubbo:protocol/ Protocol Config Configure the protocol for services on provider side, the consumer side follows. dubbo:application/ Application Config Applies to both provider and consumer. dubbo:module/ Module Config Optional. dubbo:registry/ Registry Center Registry info: address, protocol, etc. dubbo:monitor/ Monitor Center Monitor info: address, address, etc. Optional. dubbo:provider/ Default Config for Providers Default Config for ServiceConfigs. Optional. dubbo:consumer/ Default Config for Consumers Default Config for ReferenceConfigs. Optional. dubbo:method/ Method level Config Method level Config for ServiceConfig and ReferenceConfig. dubbo:argument/ Argument Config Used to specify the method parameter configuration. Overrides and Priorities Take timeout as an example, here is the priorities, from high to low (retries, loadbalance, actives also applies the same rule): method level\uff0cinterface level\uff0cdefault/global level\u3002 at the same level, consumer has higher priority than provider Configurations on the provider side are passed to the consumer side through registry in the form of URL. It is recommended that the provider set a timeout for every service, because the provider knows exactly how long a method needs to be executed. If a consumer cites multiple services at the same time, it doesn't need to care about the timeout settings of each service. Theoretically, almost all configuration items supported in ReferenceConfig can be configured with a default value using ConsumerConfig, ServiceConfig, ProviderConfig. 1: Requires spring 3.2.16+ , see announcement for details\uff1a xmlns:p=\"http://www.springframework.org/schema/p\" 2: The reference bean obeys lazy init by default, only if it is refered by other beans or other instance try to get its instance using getBean() method will the reference be initialized. If you need eager init, config this way: dubbo:reference ... init=\"true\" /","title":"XML Configuration"},{"location":"user/configuration/xml/#xml-configuration","text":"About the XML configuration items, see\uff1a XML References . If you prefer use API directly instead of using Spring, see API Configuration . Want a example of how to use configuration, see Quick Start \u3002","title":"XML Configuration"},{"location":"user/configuration/xml/#providerxml-demo","text":"?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd dubbo:application name= hello-world-app / dubbo:registry address= multicast://224.5.6.7:1234 / dubbo:protocol name= dubbo port= 20880 / dubbo:service interface= org.apache.dubbo.demo.DemoService ref= demoServiceLocal / dubbo:reference id= demoServiceRemote interface= org.apache.dubbo.demo.DemoService / /beans All tags support custom parameters, so we can meet the special config requirements at different extension points, such as: dubbo:protocol name= jms dubbo:parameter key= queue value= your_queue / /dubbo:protocol Or: beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xmlns:p= http://www.springframework.org/schema/p xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd dubbo:protocol name= jms p:queue= your_queue / /beans","title":"provider.xml demo"},{"location":"user/configuration/xml/#the-relations-between-configuration-tags","text":"tag purpose introduction dubbo:service/ Service Export Used to export service, define service metadata, export service with multiple protocols, register service to multiple registries dubbo:reference/ Service Reference Used to create a remote proxy, subscribe to multiple registries dubbo:protocol/ Protocol Config Configure the protocol for services on provider side, the consumer side follows. dubbo:application/ Application Config Applies to both provider and consumer. dubbo:module/ Module Config Optional. dubbo:registry/ Registry Center Registry info: address, protocol, etc. dubbo:monitor/ Monitor Center Monitor info: address, address, etc. Optional. dubbo:provider/ Default Config for Providers Default Config for ServiceConfigs. Optional. dubbo:consumer/ Default Config for Consumers Default Config for ReferenceConfigs. Optional. dubbo:method/ Method level Config Method level Config for ServiceConfig and ReferenceConfig. dubbo:argument/ Argument Config Used to specify the method parameter configuration.","title":"The relations between configuration tags"},{"location":"user/configuration/xml/#overrides-and-priorities","text":"Take timeout as an example, here is the priorities, from high to low (retries, loadbalance, actives also applies the same rule): method level\uff0cinterface level\uff0cdefault/global level\u3002 at the same level, consumer has higher priority than provider Configurations on the provider side are passed to the consumer side through registry in the form of URL. It is recommended that the provider set a timeout for every service, because the provider knows exactly how long a method needs to be executed. If a consumer cites multiple services at the same time, it doesn't need to care about the timeout settings of each service. Theoretically, almost all configuration items supported in ReferenceConfig can be configured with a default value using ConsumerConfig, ServiceConfig, ProviderConfig. 1: Requires spring 3.2.16+ , see announcement for details\uff1a xmlns:p=\"http://www.springframework.org/schema/p\" 2: The reference bean obeys lazy init by default, only if it is refered by other beans or other instance try to get its instance using getBean() method will the reference be initialized. If you need eager init, config this way: dubbo:reference ... init=\"true\" /","title":"Overrides and Priorities"},{"location":"user/demos/","text":"Example","title":"Example"},{"location":"user/demos/#example","text":"","title":"Example"},{"location":"user/demos/accesslog/","text":"Access Log If you want to logging the access information for each provide service,you can turn on the accesslog switch,which like the access log of Apache . Note: The size of the access log maybe too much,please check the disk capacity. Now I will show you how to config the access log. Logging by logging framework dubbo:protocol accesslog= true .../ The above configuration will turn on accesslog switch for all provide services,and logging the access log with logging framework(log4j/logback/slf4j...).You can config the logging framework of logger and appender for logging the access log.The simplest way is config logger name with dubbo.accesslog . The Example: appender name= accesslogAppender class= ch.qos.logback.core.rolling.RollingFileAppender file ${loggingRoot}/accesslog/logging.log /file encoding ${loggingCharset} /encoding append true /append rollingPolicy class= ch.qos.logback.core.rolling.TimeBasedRollingPolicy FileNamePattern ${loggingRoot}/accesslog/%d{yyyyMMdd}/logging.log.%d{yyyyMMdd}%i.gz /FileNamePattern MaxHistory 15 /MaxHistory TimeBasedFileNamingAndTriggeringPolicy class= ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP MaxFileSize 1024MB /MaxFileSize /TimeBasedFileNamingAndTriggeringPolicy /rollingPolicy layout class= ch.qos.logback.classic.PatternLayout pattern ![CDATA[%level|%d{yyyy-MM-dd HH:mm:ss}|%m%n}]] /pattern /layout /appender logger name= dubbo.accesslog level= INFO additivity= false appender-ref ref= accesslogAppender / /logger The above is the demonstration of logback framework.Other logging framework is same too. It will logging the access log of all provide services into single file( accesslog/logging.log ). And you can also config the access log of each provide service to logging separately,Only change name attribute of the logger tag,set the name attribute to dubbo.accesslog.serviceInterfaceClassFullName .The Example: logger name= dubbo.accesslog.com.dubbo.FooServiceInterface level= INFO additivity= false appender-ref ref= fooServiceAccesslogAppender / /logger If you only want logging the access log of specified provide service,but not all services, it's supported too.The Example: dubbo:service accesslog= true .../ Logging by specified file path You can specify the file path with the accesslog attribute.The Example: dubbo:protocol accesslog= /home/admin/logs/service/accesslog.log .../ OR dubbo:service accesslog= /home/admin/logs/service/accesslog.log .../","title":"Accesslog"},{"location":"user/demos/accesslog/#access-log","text":"If you want to logging the access information for each provide service,you can turn on the accesslog switch,which like the access log of Apache . Note: The size of the access log maybe too much,please check the disk capacity. Now I will show you how to config the access log.","title":"Access Log"},{"location":"user/demos/accesslog/#logging-by-logging-framework","text":"dubbo:protocol accesslog= true .../ The above configuration will turn on accesslog switch for all provide services,and logging the access log with logging framework(log4j/logback/slf4j...).You can config the logging framework of logger and appender for logging the access log.The simplest way is config logger name with dubbo.accesslog . The Example: appender name= accesslogAppender class= ch.qos.logback.core.rolling.RollingFileAppender file ${loggingRoot}/accesslog/logging.log /file encoding ${loggingCharset} /encoding append true /append rollingPolicy class= ch.qos.logback.core.rolling.TimeBasedRollingPolicy FileNamePattern ${loggingRoot}/accesslog/%d{yyyyMMdd}/logging.log.%d{yyyyMMdd}%i.gz /FileNamePattern MaxHistory 15 /MaxHistory TimeBasedFileNamingAndTriggeringPolicy class= ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP MaxFileSize 1024MB /MaxFileSize /TimeBasedFileNamingAndTriggeringPolicy /rollingPolicy layout class= ch.qos.logback.classic.PatternLayout pattern ![CDATA[%level|%d{yyyy-MM-dd HH:mm:ss}|%m%n}]] /pattern /layout /appender logger name= dubbo.accesslog level= INFO additivity= false appender-ref ref= accesslogAppender / /logger The above is the demonstration of logback framework.Other logging framework is same too. It will logging the access log of all provide services into single file( accesslog/logging.log ). And you can also config the access log of each provide service to logging separately,Only change name attribute of the logger tag,set the name attribute to dubbo.accesslog.serviceInterfaceClassFullName .The Example: logger name= dubbo.accesslog.com.dubbo.FooServiceInterface level= INFO additivity= false appender-ref ref= fooServiceAccesslogAppender / /logger If you only want logging the access log of specified provide service,but not all services, it's supported too.The Example: dubbo:service accesslog= true .../","title":"Logging by logging framework"},{"location":"user/demos/accesslog/#logging-by-specified-file-path","text":"You can specify the file path with the accesslog attribute.The Example: dubbo:protocol accesslog= /home/admin/logs/service/accesslog.log .../ OR dubbo:service accesslog= /home/admin/logs/service/accesslog.log .../","title":"Logging by specified file path"},{"location":"user/demos/async-call-deprecated/","text":"# Asynchronous call NIO-based non-blocking parallel call, the client does not need to start multi-threading to complete multiple remote services in parallel, and the relative multi-threading overhead is small.\u3002 [^1] ![/user-guide/images/future.jpg](../sources/images/future.jpg) Configured in consumer.xml: ```xml dubbo:reference id= fooService interface= com.alibaba.foo.FooService dubbo:method name= findFoo async= true / /dubbo:reference dubbo:reference id= barService interface= com.alibaba.bar.BarService dubbo:method name= findBar async= true / /dubbo:reference Call code: // This call will return null immediately fooService.findFoo(fooId); // Get the called Future reference, when the result is returned, it will be notified and set to this Future Future Foo fooFuture = RpcContext.getContext().getFuture(); // This call will return null immediately barService.findBar(barId); // Get the called Future reference, when the result is returned, it will be notified and set to this Future Future Bar barFuture = RpcContext.getContext().getFuture(); // At this time, the requests of findFoo and findBar are executed at the same time. The client does not need to start multi-threading to support parallelism, but completes the non-blocking of NIO. / / If foo has returned, get the return value directly, otherwise the thread waits, waiting for foo to return, the thread will be wake up by notify Foo foo = fooFuture.get(); // Same as waiting for bar to return Bar bar = barFuture.get(); // If foo needs 5 seconds to return, bar needs 6 seconds to return. In fact, it only takes 6 seconds to get foo and bar for the next processing. You can also set whether to wait for the message to be sent: [^2] sent=\"true\" Wait for a message to be sent, and a message failure will throw an exception. sent=\"false\" Do not wait for the message to be sent, put the message into the IO queue, and return immediately. dubbo:method name= findFoo async= true sent= true / If you just want to be asynchronous and completely ignore the return value, you can configure return=\"false\" to reduce the creation and management cost of the Future object: dubbo:method name= findFoo async= true return= false / [^1]: Supported by 2.0.6 and above [^2]: Asynchronous always does not wait to return ```","title":"Async call deprecated"},{"location":"user/demos/async-call/","text":"Asynchronous Call As dubbo is based on a non-blocking NIO network layer, the client can start parallel call to multiple remote services without explicitly starting mulithreads, which costs relatively fewer resources. You can config at consumer.xml for setup asynchronous call some remote service. dubbo:reference id= fooService interface= com.alibaba.foo.FooService dubbo:method name= findFoo async= true / /dubbo:reference dubbo:reference id= barService interface= com.alibaba.bar.BarService dubbo:method name= findBar async= true / /dubbo:reference Configure the above configuration information,you can invoke the remote service in your code. // the invoke will return null immediately fooService.findFoo(fooId); // get current invoke Future instance,when the remote service has return result,will notify this Future instance. Future Foo fooFuture = RpcContext.getContext().getFuture(); // the invoke will return null immediately barService.findBar(barId); // get current invoke Future instance,when the remote service has return result,will notify this Future instance. Future Bar barFuture = RpcContext.getContext().getFuture(); // now the request of findFoo and findBar was executed at same time,The client not need setup multithreading for parallel call, which is NIO-based non-blocking implementation of parallel calls // Current thread will be blocking,and wait findFoo has return. when remote service has return findFoo result,the current thread will be wake up. Foo foo = fooFuture.get(); // same to findFoo Bar bar = barFuture.get(); // if findFoo expend five second for wait remote service return result,and findBar expend six second. Actually,only expend six second will get findFoo and findBar result,and proceed to the next step. You can also set whether to wait for the message to be sent: sent=\"true\" wait for the message to be send,if send failure\uff0cwill throw exception. sent=\"false\" do not wait for the message to be send,when the message will push into io queue,will return immediately. The Example: dubbo:method name= findFoo async= true sent= true / if you only want to asynchronous call,and don't care the return.you can config return=\"false\" ,To reduce the cost of creating and managing Future objects. dubbo:method name= findFoo async= true return= false / Note 2.0.6+ version supported.","title":"Async call"},{"location":"user/demos/async-call/#asynchronous-call","text":"As dubbo is based on a non-blocking NIO network layer, the client can start parallel call to multiple remote services without explicitly starting mulithreads, which costs relatively fewer resources. You can config at consumer.xml for setup asynchronous call some remote service. dubbo:reference id= fooService interface= com.alibaba.foo.FooService dubbo:method name= findFoo async= true / /dubbo:reference dubbo:reference id= barService interface= com.alibaba.bar.BarService dubbo:method name= findBar async= true / /dubbo:reference Configure the above configuration information,you can invoke the remote service in your code. // the invoke will return null immediately fooService.findFoo(fooId); // get current invoke Future instance,when the remote service has return result,will notify this Future instance. Future Foo fooFuture = RpcContext.getContext().getFuture(); // the invoke will return null immediately barService.findBar(barId); // get current invoke Future instance,when the remote service has return result,will notify this Future instance. Future Bar barFuture = RpcContext.getContext().getFuture(); // now the request of findFoo and findBar was executed at same time,The client not need setup multithreading for parallel call, which is NIO-based non-blocking implementation of parallel calls // Current thread will be blocking,and wait findFoo has return. when remote service has return findFoo result,the current thread will be wake up. Foo foo = fooFuture.get(); // same to findFoo Bar bar = barFuture.get(); // if findFoo expend five second for wait remote service return result,and findBar expend six second. Actually,only expend six second will get findFoo and findBar result,and proceed to the next step. You can also set whether to wait for the message to be sent: sent=\"true\" wait for the message to be send,if send failure\uff0cwill throw exception. sent=\"false\" do not wait for the message to be send,when the message will push into io queue,will return immediately. The Example: dubbo:method name= findFoo async= true sent= true / if you only want to asynchronous call,and don't care the return.you can config return=\"false\" ,To reduce the cost of creating and managing Future objects. dubbo:method name= findFoo async= true return= false / Note 2.0.6+ version supported.","title":"Asynchronous Call"},{"location":"user/demos/async-execute-on-provider/","text":"Asynchronous Execution The asynchronous execute on provider switches the blocked service from the internal thread pool of Dubbo to the service custom thread to avoid over-occupation of the Dubbo thread pool, which helps to avoid mutual influence between different services.Asynchronous-Execution is not conducive to saving resources or improving RPC responsiveness, because if business execution needs to be blocked, there is always a thread to be responsible for execution. Note: Asynchronous execute on provider and asynchronous execute on consumer are independent of each other. You can configure ends of any orthogonal combination. Synchronous Execution On Consumer - Synchronous Execution On Provider Asynchronous Executio On Consumer - Synchronous Execution On Provider Synchronous Execution On Consumer - Asynchronous Executio On Provider Asynchronous Execution On Consumer - Asynchronous Executio On Provider Interface that defines the CompletableFuture signature Service interface definition\uff1a public interface AsyncService { CompletableFuture String sayHello(String name); } Service implementation\uff1a public class AsyncServiceImpl implements AsyncService { @Override public CompletableFuture String sayHello(String name) { RpcContext savedContext = RpcContext.getContext(); // It is recommended to provide a custom thread pool for supplyAsync to avoid using the JDK common thread pool. return CompletableFuture.supplyAsync(() - { System.out.println(savedContext.getAttachment( consumer-key1 )); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } return async response from provider. ; }); } } The business execution has been switched from the Dubbo thread to the business thread by return CompletableFuture.supplyAsync() , avoiding blocking of the Dubbo thread pool. Use AsyncContext Dubbo provides an asynchronous interface AsyncContext similar to Serverlet 3.0. It can also implement asynchronous execution of the Provider without the CompletableFuture signature interface. Service interface definition\uff1a public interface AsyncService { String sayHello(String name); } Service export, exactly the same as ordinary service\uff1a bean id= asyncService class= org.apache.dubbo.samples.governance.impl.AsyncServiceImpl / dubbo:service interface= org.apache.dubbo.samples.governance.api.AsyncService ref= asyncService / Service implementation\uff1a public class AsyncServiceImpl implements AsyncService { public String sayHello(String name) { final AsyncContext asyncContext = RpcContext.startAsync(); new Thread(() - { // If you want to use context, you must do it at the very beginning asyncContext.signalContextSwitch(); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } // Write to response asyncContext.write( Hello + name + , response from provider. ); }).start(); return null; } }","title":"Asynchronous Execution"},{"location":"user/demos/async-execute-on-provider/#asynchronous-execution","text":"The asynchronous execute on provider switches the blocked service from the internal thread pool of Dubbo to the service custom thread to avoid over-occupation of the Dubbo thread pool, which helps to avoid mutual influence between different services.Asynchronous-Execution is not conducive to saving resources or improving RPC responsiveness, because if business execution needs to be blocked, there is always a thread to be responsible for execution. Note: Asynchronous execute on provider and asynchronous execute on consumer are independent of each other. You can configure ends of any orthogonal combination. Synchronous Execution On Consumer - Synchronous Execution On Provider Asynchronous Executio On Consumer - Synchronous Execution On Provider Synchronous Execution On Consumer - Asynchronous Executio On Provider Asynchronous Execution On Consumer - Asynchronous Executio On Provider","title":"Asynchronous Execution"},{"location":"user/demos/async-execute-on-provider/#interface-that-defines-the-completablefuture-signature","text":"Service interface definition\uff1a public interface AsyncService { CompletableFuture String sayHello(String name); } Service implementation\uff1a public class AsyncServiceImpl implements AsyncService { @Override public CompletableFuture String sayHello(String name) { RpcContext savedContext = RpcContext.getContext(); // It is recommended to provide a custom thread pool for supplyAsync to avoid using the JDK common thread pool. return CompletableFuture.supplyAsync(() - { System.out.println(savedContext.getAttachment( consumer-key1 )); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } return async response from provider. ; }); } } The business execution has been switched from the Dubbo thread to the business thread by return CompletableFuture.supplyAsync() , avoiding blocking of the Dubbo thread pool.","title":"Interface that defines the CompletableFuture signature"},{"location":"user/demos/async-execute-on-provider/#use-asynccontext","text":"Dubbo provides an asynchronous interface AsyncContext similar to Serverlet 3.0. It can also implement asynchronous execution of the Provider without the CompletableFuture signature interface. Service interface definition\uff1a public interface AsyncService { String sayHello(String name); } Service export, exactly the same as ordinary service\uff1a bean id= asyncService class= org.apache.dubbo.samples.governance.impl.AsyncServiceImpl / dubbo:service interface= org.apache.dubbo.samples.governance.api.AsyncService ref= asyncService / Service implementation\uff1a public class AsyncServiceImpl implements AsyncService { public String sayHello(String name) { final AsyncContext asyncContext = RpcContext.startAsync(); new Thread(() - { // If you want to use context, you must do it at the very beginning asyncContext.signalContextSwitch(); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } // Write to response asyncContext.write( Hello + name + , response from provider. ); }).start(); return null; } }","title":"Use AsyncContext"},{"location":"user/demos/attachment/","text":"Implicit parameters You can implicitly pass parameters between service consumers and providers via setAttachment and getAttachment on RpcContext . Set the implicit parameters at service consumer side Via setAttachment on RpcContext set key/value pair for implicitly pass parameters.When finished once remote invoke,will be clear,so multi-invoke must set multi-times. RpcContext.getContext().setAttachment( index , 1 ); // implicitly pass parameters,behind the remote call will implicitly send these parameters to the server side, similar to the cookie, for the framework of integration, not recommended for regular business use xxxService.xxx(); // remote call // ... Fetch the implicit parameters at service provider side public class XxxServiceImpl implements XxxService { public void xxx() { // get parameters which passed by the consumer side,for the framework of integration, not recommended for regular business use String index = RpcContext.getContext().getAttachment( index ); } }","title":"Attachment"},{"location":"user/demos/attachment/#implicit-parameters","text":"You can implicitly pass parameters between service consumers and providers via setAttachment and getAttachment on RpcContext .","title":"Implicit parameters"},{"location":"user/demos/attachment/#set-the-implicit-parameters-at-service-consumer-side","text":"Via setAttachment on RpcContext set key/value pair for implicitly pass parameters.When finished once remote invoke,will be clear,so multi-invoke must set multi-times. RpcContext.getContext().setAttachment( index , 1 ); // implicitly pass parameters,behind the remote call will implicitly send these parameters to the server side, similar to the cookie, for the framework of integration, not recommended for regular business use xxxService.xxx(); // remote call // ...","title":"Set the implicit parameters at service consumer side"},{"location":"user/demos/attachment/#fetch-the-implicit-parameters-at-service-provider-side","text":"public class XxxServiceImpl implements XxxService { public void xxx() { // get parameters which passed by the consumer side,for the framework of integration, not recommended for regular business use String index = RpcContext.getContext().getAttachment( index ); } }","title":"Fetch the implicit parameters at service provider side"},{"location":"user/demos/callback-parameter/","text":"Callback parameter The parameter callback is the same as calling a local callback or listener, just declare which parameter is a callback type in Spring's configuration file, and Dubbo will generate a reverse proxy based on the long connection so that client logic can be called from the server.Can ref to Sample code in the dubbo project . Example of service interface CallbackService.java package com.callback; public interface CallbackService { void addListener(String key, CallbackListener listener); } CallbackListener.java package com.callback; public interface CallbackListener { void changed(String msg); } Example of service provider interface implementation package com.callback.impl; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Map; import java.util.concurrent.ConcurrentHashMap; import com.callback.CallbackListener; import com.callback.CallbackService; public class CallbackServiceImpl implements CallbackService { private final Map String, CallbackListener listeners = new ConcurrentHashMap String, CallbackListener (); public CallbackServiceImpl() { Thread t = new Thread(new Runnable() { public void run() { while(true) { try { for(Map.Entry String, CallbackListener entry : listeners.entrySet()){ try { entry.getValue().changed(getChanged(entry.getKey())); } catch (Throwable t) { listeners.remove(entry.getKey()); } } Thread.sleep(5000); // Timed trigger change notification } catch (Throwable t) { // Defense fault tolerance t.printStackTrace(); } } } }); t.setDaemon(true); t.start(); } public void addListener(String key, CallbackListener listener) { listeners.put(key, listener); listener.changed(getChanged(key)); // send change notification } private String getChanged(String key) { return Changed: + new SimpleDateFormat( yyyy-MM-dd HH:mm:ss ).format(new Date()); } } Example of service provider configuration bean id= callbackService class= com.callback.impl.CallbackServiceImpl / dubbo:service interface= com.callback.CallbackService ref= callbackService connections= 1 callbacks= 1000 dubbo:method name= addListener dubbo:argument index= 1 callback= true / !--also can via specified argument type-- !-- dubbo:argument type= com.demo.CallbackListener callback= true / -- /dubbo:method /dubbo:service Example of service consumer configuration dubbo:reference id= callbackService interface= com.callback.CallbackService / Example of service consumer call ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext( classpath:consumer.xml ); context.start(); CallbackService callbackService = (CallbackService) context.getBean( callbackService ); callbackService.addListener( foo.bar , new CallbackListener(){ public void changed(String msg) { System.out.println( callback1: + msg); } }); NOTE 2.0.6+ version supported.","title":"Parameter callback"},{"location":"user/demos/callback-parameter/#callback-parameter","text":"The parameter callback is the same as calling a local callback or listener, just declare which parameter is a callback type in Spring's configuration file, and Dubbo will generate a reverse proxy based on the long connection so that client logic can be called from the server.Can ref to Sample code in the dubbo project .","title":"Callback parameter"},{"location":"user/demos/callback-parameter/#example-of-service-interface","text":"","title":"Example of service interface"},{"location":"user/demos/callback-parameter/#callbackservicejava","text":"package com.callback; public interface CallbackService { void addListener(String key, CallbackListener listener); }","title":"CallbackService.java"},{"location":"user/demos/callback-parameter/#callbacklistenerjava","text":"package com.callback; public interface CallbackListener { void changed(String msg); }","title":"CallbackListener.java"},{"location":"user/demos/callback-parameter/#example-of-service-provider-interface-implementation","text":"package com.callback.impl; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Map; import java.util.concurrent.ConcurrentHashMap; import com.callback.CallbackListener; import com.callback.CallbackService; public class CallbackServiceImpl implements CallbackService { private final Map String, CallbackListener listeners = new ConcurrentHashMap String, CallbackListener (); public CallbackServiceImpl() { Thread t = new Thread(new Runnable() { public void run() { while(true) { try { for(Map.Entry String, CallbackListener entry : listeners.entrySet()){ try { entry.getValue().changed(getChanged(entry.getKey())); } catch (Throwable t) { listeners.remove(entry.getKey()); } } Thread.sleep(5000); // Timed trigger change notification } catch (Throwable t) { // Defense fault tolerance t.printStackTrace(); } } } }); t.setDaemon(true); t.start(); } public void addListener(String key, CallbackListener listener) { listeners.put(key, listener); listener.changed(getChanged(key)); // send change notification } private String getChanged(String key) { return Changed: + new SimpleDateFormat( yyyy-MM-dd HH:mm:ss ).format(new Date()); } }","title":"Example of service provider interface implementation"},{"location":"user/demos/callback-parameter/#example-of-service-provider-configuration","text":"bean id= callbackService class= com.callback.impl.CallbackServiceImpl / dubbo:service interface= com.callback.CallbackService ref= callbackService connections= 1 callbacks= 1000 dubbo:method name= addListener dubbo:argument index= 1 callback= true / !--also can via specified argument type-- !-- dubbo:argument type= com.demo.CallbackListener callback= true / -- /dubbo:method /dubbo:service","title":"Example of service provider configuration"},{"location":"user/demos/callback-parameter/#example-of-service-consumer-configuration","text":"dubbo:reference id= callbackService interface= com.callback.CallbackService /","title":"Example of service consumer configuration"},{"location":"user/demos/callback-parameter/#example-of-service-consumer-call","text":"ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext( classpath:consumer.xml ); context.start(); CallbackService callbackService = (CallbackService) context.getBean( callbackService ); callbackService.addListener( foo.bar , new CallbackListener(){ public void changed(String msg) { System.out.println( callback1: + msg); } }); NOTE 2.0.6+ version supported.","title":"Example of service consumer call"},{"location":"user/demos/concurrency-control/","text":"Parallel control Example of configuration Example 1: Control the concurrency of all method for a specified service interface at server-side Limit each method of com.foo.BarService to no more than 10 concurrent server-side executions (or take up thread pool threads): dubbo:service interface= com.foo.BarService executes= 10 / Example 2: Control the concurrency of specified method for a specified service interface at server-side Limit the sayHello method of com.foo.BarService to no more than 10 concurrent server-side executions(or take up thread pool threads): dubbo:service interface= com.foo.BarService dubbo:method name= sayHello executes= 10 / /dubbo:service Example 3: Control the concurrency of all method for a specified service interface at client-side Limit each method of com.foo.BarService to no more than 10 concurrent client-side executions (or take up thread pool threads): dubbo:service interface= com.foo.BarService actives= 10 / OR dubbo:reference interface= com.foo.BarService actives= 10 / Example 4: Control the concurrency of specified method for a specified service interface at client-side Limit the sayHello method of com.foo.BarService to no more than 10 concurrent client-side executions(or take up thread pool threads): dubbo:service interface= com.foo.BarService dubbo:method name= sayHello actives= 10 / /dubbo:service OR dubbo:reference interface= com.foo.BarService dubbo:method name= sayHello actives= 10 / /dubbo:service If dubbo:service and dubbo:reference are both configured with actives , dubbo:reference is preferred.Ref to: Configuration coverage strategy . Load Balance You can config the loadbalance attribute with leastactive at server-side or client-side,then the framework will make consumer call the minimum number of concurrent one. dubbo:reference interface= com.foo.BarService loadbalance= leastactive / OR dubbo:service interface= com.foo.BarService loadbalance= leastactive /","title":"Concurrency limit"},{"location":"user/demos/concurrency-control/#parallel-control","text":"","title":"Parallel control"},{"location":"user/demos/concurrency-control/#example-of-configuration","text":"Example 1: Control the concurrency of all method for a specified service interface at server-side Limit each method of com.foo.BarService to no more than 10 concurrent server-side executions (or take up thread pool threads): dubbo:service interface= com.foo.BarService executes= 10 / Example 2: Control the concurrency of specified method for a specified service interface at server-side Limit the sayHello method of com.foo.BarService to no more than 10 concurrent server-side executions(or take up thread pool threads): dubbo:service interface= com.foo.BarService dubbo:method name= sayHello executes= 10 / /dubbo:service Example 3: Control the concurrency of all method for a specified service interface at client-side Limit each method of com.foo.BarService to no more than 10 concurrent client-side executions (or take up thread pool threads): dubbo:service interface= com.foo.BarService actives= 10 / OR dubbo:reference interface= com.foo.BarService actives= 10 / Example 4: Control the concurrency of specified method for a specified service interface at client-side Limit the sayHello method of com.foo.BarService to no more than 10 concurrent client-side executions(or take up thread pool threads): dubbo:service interface= com.foo.BarService dubbo:method name= sayHello actives= 10 / /dubbo:service OR dubbo:reference interface= com.foo.BarService dubbo:method name= sayHello actives= 10 / /dubbo:service If dubbo:service and dubbo:reference are both configured with actives , dubbo:reference is preferred.Ref to: Configuration coverage strategy .","title":"Example of configuration"},{"location":"user/demos/concurrency-control/#load-balance","text":"You can config the loadbalance attribute with leastactive at server-side or client-side,then the framework will make consumer call the minimum number of concurrent one. dubbo:reference interface= com.foo.BarService loadbalance= leastactive / OR dubbo:service interface= com.foo.BarService loadbalance= leastactive /","title":"Load Balance"},{"location":"user/demos/config-connections/","text":"Config connections Control connections at server-side Limit server-side accept to no more than 10 connections dubbo:provider protocol= dubbo accepts= 10 / OR dubbo:protocol name= dubbo accepts= 10 / Control connections at client-side Limit client-side creating connection to no more than 10 connections for interface com.foo.BarService . dubbo:reference interface= com.foo.BarService connections= 10 / OR dubbo:service interface= com.foo.BarService connections= 10 / NOTE: If used default protocol( dubbo protocol), and the value of connections attribute is great than 0,then each service reference will has itself connection,else all service which belong to same remote server will share only one connection. In this framework,we called private connection or share connection. If dubbo:service and dubbo:reference are both configured accepts/connections, dubbo:reference is preferred,Ref to Configuration coverage strategy . : Because connection is connect on Server,so configure at Provider.","title":"Config connections"},{"location":"user/demos/config-connections/#config-connections","text":"","title":"Config connections"},{"location":"user/demos/config-connections/#control-connections-at-server-side","text":"Limit server-side accept to no more than 10 connections dubbo:provider protocol= dubbo accepts= 10 / OR dubbo:protocol name= dubbo accepts= 10 /","title":"Control connections at server-side"},{"location":"user/demos/config-connections/#control-connections-at-client-side","text":"Limit client-side creating connection to no more than 10 connections for interface com.foo.BarService . dubbo:reference interface= com.foo.BarService connections= 10 / OR dubbo:service interface= com.foo.BarService connections= 10 / NOTE: If used default protocol( dubbo protocol), and the value of connections attribute is great than 0,then each service reference will has itself connection,else all service which belong to same remote server will share only one connection. In this framework,we called private connection or share connection. If dubbo:service and dubbo:reference are both configured accepts/connections, dubbo:reference is preferred,Ref to Configuration coverage strategy . : Because connection is connect on Server,so configure at Provider.","title":"Control connections at client-side"},{"location":"user/demos/config-rule-deprecated/","text":"Configure rule Write then dynamic configuration to the registry center,This feature is usually done by the monitoring center or the center's page. RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf( zookeeper://10.20.153.10:2181 )); registry.register(URL.valueOf( override://0.0.0.0/com.foo.BarService?category=configurators dynamic=false application=foo timeout=1000 )); In the config override url\uff1a * override:// Indicates that the data is overwritten,support override and absent \uff0ccan extends\uff0c Required . * 0.0.0.0 Indicates that the configurations is valid for all IP addresses\uff0cIf only want to overwritten specified ip data,you can replace that specified ip address. Required . * com.foo.BarService Indicates that is valid for specified service, Required . * category=configurators Indicates that the data is dynamic configuration, Required \u3002 * dynamic=false Indicates that the data is persistent,When the registered party withdraws,the data is still stored in the registry Required \u3002 * enabled=true override strategy is enable,can absent,if absent,then enable. * application=foo Indicates that is valid for specified application,can absent,if absent,then valid for all application. * timeout=1000 Indicates that the value of the timeout parameter that satisfies the above conditions is overwritten by 1000,if want to override another parameters, add directly to the override URL parameter. Example\uff1a Disable service provider.(Usually used to temporarily kick off a provider machine, similar to the prohibition of consumer access, please use the routing rules) override://10.20.153.10/com.foo.BarService?category=configurators dynamic=false disbaled=true Adjustment weight:(Usually used to capacity assessment,default is 100) override://10.20.153.10/com.foo.BarService?category=configurators dynamic=false weight=200 Adjustment load balance strategy.(default random) override://10.20.153.10/com.foo.BarService?category=configurators dynamic=false loadbalance=leastactive Service downgrade:(Usually used to temporarily mask an error of non-critical services) override://0.0.0.0/com.foo.BarService?category=configurators dynamic=false application=foo mock=force:return+null NOTE : 2.2.0+ version supported.","title":"Configure rule"},{"location":"user/demos/config-rule-deprecated/#configure-rule","text":"Write then dynamic configuration to the registry center,This feature is usually done by the monitoring center or the center's page. RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf( zookeeper://10.20.153.10:2181 )); registry.register(URL.valueOf( override://0.0.0.0/com.foo.BarService?category=configurators dynamic=false application=foo timeout=1000 )); In the config override url\uff1a * override:// Indicates that the data is overwritten,support override and absent \uff0ccan extends\uff0c Required . * 0.0.0.0 Indicates that the configurations is valid for all IP addresses\uff0cIf only want to overwritten specified ip data,you can replace that specified ip address. Required . * com.foo.BarService Indicates that is valid for specified service, Required . * category=configurators Indicates that the data is dynamic configuration, Required \u3002 * dynamic=false Indicates that the data is persistent,When the registered party withdraws,the data is still stored in the registry Required \u3002 * enabled=true override strategy is enable,can absent,if absent,then enable. * application=foo Indicates that is valid for specified application,can absent,if absent,then valid for all application. * timeout=1000 Indicates that the value of the timeout parameter that satisfies the above conditions is overwritten by 1000,if want to override another parameters, add directly to the override URL parameter. Example\uff1a Disable service provider.(Usually used to temporarily kick off a provider machine, similar to the prohibition of consumer access, please use the routing rules) override://10.20.153.10/com.foo.BarService?category=configurators dynamic=false disbaled=true Adjustment weight:(Usually used to capacity assessment,default is 100) override://10.20.153.10/com.foo.BarService?category=configurators dynamic=false weight=200 Adjustment load balance strategy.(default random) override://10.20.153.10/com.foo.BarService?category=configurators dynamic=false loadbalance=leastactive Service downgrade:(Usually used to temporarily mask an error of non-critical services) override://0.0.0.0/com.foo.BarService?category=configurators dynamic=false application=foo mock=force:return+null NOTE : 2.2.0+ version supported.","title":"Configure rule"},{"location":"user/demos/config-rule/","text":"Configure rule Write then dynamic configuration to the registry center,This feature is usually done by the monitoring center or the center's page. RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf( zookeeper://10.20.153.10:2181 )); registry.register(URL.valueOf( override://0.0.0.0/com.foo.BarService?category=configurators dynamic=false application=foo timeout=1000 )); In the config override url\uff1a * override:// Indicates that the data is overwritten,support override and absent \uff0ccan extends\uff0c Required . * 0.0.0.0 Indicates that the configurations is valid for all IP addresses\uff0cIf only want to overwritten specified ip data,you can replace that specified ip address. Required . * com.foo.BarService Indicates that is valid for specified service, Required . * category=configurators Indicates that the data is dynamic configuration, Required \u3002 * dynamic=false Indicates that the data is persistent,When the registered party withdraws,the data is still stored in the registry Required \u3002 * enabled=true override strategy is enable,can absent,if absent,then enable. * application=foo Indicates that is valid for specified application,can absent,if absent,then valid for all application. * timeout=1000 Indicates that the value of the timeout parameter that satisfies the above conditions is overwritten by 1000,if want to override another parameters, add directly to the override URL parameter. Example\uff1a Disable service provider.(Usually used to temporarily kick off a provider machine, similar to the prohibition of consumer access, please use the routing rules) override://10.20.153.10/com.foo.BarService?category=configurators dynamic=false disbaled=true Adjustment weight:(Usually used to capacity assessment,default is 100) override://10.20.153.10/com.foo.BarService?category=configurators dynamic=false weight=200 Adjustment load balance strategy.(default random) override://10.20.153.10/com.foo.BarService?category=configurators dynamic=false loadbalance=leastactive Service downgrade:(Usually used to temporarily mask an error of non-critical services) override://0.0.0.0/com.foo.BarService?category=configurators dynamic=false application=foo mock=force:return+null NOTE : 2.2.0+ version supported.","title":"Config rule"},{"location":"user/demos/config-rule/#configure-rule","text":"Write then dynamic configuration to the registry center,This feature is usually done by the monitoring center or the center's page. RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf( zookeeper://10.20.153.10:2181 )); registry.register(URL.valueOf( override://0.0.0.0/com.foo.BarService?category=configurators dynamic=false application=foo timeout=1000 )); In the config override url\uff1a * override:// Indicates that the data is overwritten,support override and absent \uff0ccan extends\uff0c Required . * 0.0.0.0 Indicates that the configurations is valid for all IP addresses\uff0cIf only want to overwritten specified ip data,you can replace that specified ip address. Required . * com.foo.BarService Indicates that is valid for specified service, Required . * category=configurators Indicates that the data is dynamic configuration, Required \u3002 * dynamic=false Indicates that the data is persistent,When the registered party withdraws,the data is still stored in the registry Required \u3002 * enabled=true override strategy is enable,can absent,if absent,then enable. * application=foo Indicates that is valid for specified application,can absent,if absent,then valid for all application. * timeout=1000 Indicates that the value of the timeout parameter that satisfies the above conditions is overwritten by 1000,if want to override another parameters, add directly to the override URL parameter. Example\uff1a Disable service provider.(Usually used to temporarily kick off a provider machine, similar to the prohibition of consumer access, please use the routing rules) override://10.20.153.10/com.foo.BarService?category=configurators dynamic=false disbaled=true Adjustment weight:(Usually used to capacity assessment,default is 100) override://10.20.153.10/com.foo.BarService?category=configurators dynamic=false weight=200 Adjustment load balance strategy.(default random) override://10.20.153.10/com.foo.BarService?category=configurators dynamic=false loadbalance=leastactive Service downgrade:(Usually used to temporarily mask an error of non-critical services) override://0.0.0.0/com.foo.BarService?category=configurators dynamic=false application=foo mock=force:return+null NOTE : 2.2.0+ version supported.","title":"Configure rule"},{"location":"user/demos/context/","text":"Context Information All environment information of during the current call will put into the context,and all configuration information will convert the parameters of URL instance,Ref to the column of URL parameters at the schema configuration reference book RpcContext is a temporary status recorder of ThreadLocal ,when accept RPC request or send RPC request,The RpcContext will be changed.Such as: A call B and B call C . On B machine,before B call C ,the RpcContext will record the information of A call B .After B call C ,the RpcContext record the information of B call C . At service consumer // remote invoke xxxService.xxx(); // if return true,then the current side is consumer. boolean isConsumerSide = RpcContext.getContext().isConsumerSide(); // get the provider ip address of the last invoke. String serverIP = RpcContext.getContext().getRemoteHost(); // because all configuration information has convert the URL's parameters,so at this place can get the application parameter value. String application = RpcContext.getContext().getUrl().getParameter( application ); // Note:every rpc invoke,then context will be changed. yyyService.yyy(); At service provider public class XxxServiceImpl implements XxxService { public void xxx() { // if return true,then the current side is provider. boolean isProviderSide = RpcContext.getContext().isProviderSide(); // get the invoker ip String clientIP = RpcContext.getContext().getRemoteHost(); // because all configuration information has convert the URL's parameters,so at this place can get the application parameter value. String application = RpcContext.getContext().getUrl().getParameter( application ); // Note:every rpc invoke,then context will be changed. yyyService.yyy();; } }","title":"Context"},{"location":"user/demos/context/#context-information","text":"All environment information of during the current call will put into the context,and all configuration information will convert the parameters of URL instance,Ref to the column of URL parameters at the schema configuration reference book RpcContext is a temporary status recorder of ThreadLocal ,when accept RPC request or send RPC request,The RpcContext will be changed.Such as: A call B and B call C . On B machine,before B call C ,the RpcContext will record the information of A call B .After B call C ,the RpcContext record the information of B call C .","title":"Context Information"},{"location":"user/demos/context/#at-service-consumer","text":"// remote invoke xxxService.xxx(); // if return true,then the current side is consumer. boolean isConsumerSide = RpcContext.getContext().isConsumerSide(); // get the provider ip address of the last invoke. String serverIP = RpcContext.getContext().getRemoteHost(); // because all configuration information has convert the URL's parameters,so at this place can get the application parameter value. String application = RpcContext.getContext().getUrl().getParameter( application ); // Note:every rpc invoke,then context will be changed. yyyService.yyy();","title":"At service consumer"},{"location":"user/demos/context/#at-service-provider","text":"public class XxxServiceImpl implements XxxService { public void xxx() { // if return true,then the current side is provider. boolean isProviderSide = RpcContext.getContext().isProviderSide(); // get the invoker ip String clientIP = RpcContext.getContext().getRemoteHost(); // because all configuration information has convert the URL's parameters,so at this place can get the application parameter value. String application = RpcContext.getContext().getUrl().getParameter( application ); // Note:every rpc invoke,then context will be changed. yyyService.yyy();; } }","title":"At service provider"},{"location":"user/demos/delay-publish/","text":"Delay publish service If your services need time to warm up, such as: initialization cache or another reference resources has to be ready. You can use the delay feature to delay publishing services. We fine-tuned the service delay exposure logic in Dubbo 2.6.5, delaying the countdown of services that require delayed exposure until Spring initialization is complete. You won't be aware of this change while using Dubbo, so please be assured that use. Prior to Dubbo-2.6.5 Delay five second publish dubbo:service delay= 5000 / Delay until Spring initialization is complete before exposing the service dubbo:service delay= -1 / Dubbo-2.6.5 and later All services will be exposed after Spring initialization is complete, and you don't need to configure delay if you don't need to delay exposing the service. Delay five second publish dubbo:service delay= 5000 / The initialization deadlock problem of Spring 2.x Trigger condition The service has already published when Spring parse the dubbo:service / element,but the Spring is still initializing other beans.If there is a request coming in, and the service implementation class has a call to applicationContext.getBean () usage. Request thread applicationContext.getBean() call, the first synchronization singletonObjects determine whether the existence of the bean, the synchronization does not exist to initialize the beanDefinitionMap , and re-synchronize singletonObjects write Bean instance cache. But the Spring initialization thread,because need to determine the Bean is exist,Directly synchronize beanDefinitionMap to initialize, and synchronize singletonObjects write Bean instance cache. This will cause the getBean thread to lock the singletonObjects first, then lock the beanDefinitionMap, and lock the singletonObjects again.The Spring initialization thread, the first lock beanDefinitionMap, then lock singletonObjects. Reverse lock thread deadlock, can not provide services, can not start. Avoid ways It is highly recommended not to call applicationContext.getBean() in the service implementation class, all using Spring's beans using IoC injection. If you really want to tune getBean(), you can put the configuration of Dubbo Spring final loading. If you do not want to rely on the configuration order, you can use dubbo:provider delay =\"-1\"/ to make Dubbo expose the service after the Spring container has been initialized. If you use getBean() extensively, the equivalent of degenerating Spring to factory mode is to isolate Dubbo's service from a separate Spring container. [^1]: Base on the ContextRefreshedEvent event of the Spring to trigger publish service.","title":"Delay publish"},{"location":"user/demos/delay-publish/#delay-publish-service","text":"If your services need time to warm up, such as: initialization cache or another reference resources has to be ready. You can use the delay feature to delay publishing services. We fine-tuned the service delay exposure logic in Dubbo 2.6.5, delaying the countdown of services that require delayed exposure until Spring initialization is complete. You won't be aware of this change while using Dubbo, so please be assured that use.","title":"Delay publish service"},{"location":"user/demos/delay-publish/#prior-to-dubbo-265","text":"","title":"Prior to Dubbo-2.6.5"},{"location":"user/demos/delay-publish/#delay-five-second-publish","text":"dubbo:service delay= 5000 /","title":"Delay five second publish"},{"location":"user/demos/delay-publish/#delay-until-spring-initialization-is-complete-before-exposing-the-service","text":"dubbo:service delay= -1 /","title":"Delay until Spring initialization is complete before exposing the service"},{"location":"user/demos/delay-publish/#dubbo-265-and-later","text":"All services will be exposed after Spring initialization is complete, and you don't need to configure delay if you don't need to delay exposing the service.","title":"Dubbo-2.6.5 and later"},{"location":"user/demos/delay-publish/#delay-five-second-publish_1","text":"dubbo:service delay= 5000 /","title":"Delay five second publish"},{"location":"user/demos/delay-publish/#the-initialization-deadlock-problem-of-spring-2x","text":"","title":"The initialization deadlock problem of Spring 2.x"},{"location":"user/demos/delay-publish/#trigger-condition","text":"The service has already published when Spring parse the dubbo:service / element,but the Spring is still initializing other beans.If there is a request coming in, and the service implementation class has a call to applicationContext.getBean () usage. Request thread applicationContext.getBean() call, the first synchronization singletonObjects determine whether the existence of the bean, the synchronization does not exist to initialize the beanDefinitionMap , and re-synchronize singletonObjects write Bean instance cache. But the Spring initialization thread,because need to determine the Bean is exist,Directly synchronize beanDefinitionMap to initialize, and synchronize singletonObjects write Bean instance cache. This will cause the getBean thread to lock the singletonObjects first, then lock the beanDefinitionMap, and lock the singletonObjects again.The Spring initialization thread, the first lock beanDefinitionMap, then lock singletonObjects. Reverse lock thread deadlock, can not provide services, can not start.","title":"Trigger condition"},{"location":"user/demos/delay-publish/#avoid-ways","text":"It is highly recommended not to call applicationContext.getBean() in the service implementation class, all using Spring's beans using IoC injection. If you really want to tune getBean(), you can put the configuration of Dubbo Spring final loading. If you do not want to rely on the configuration order, you can use dubbo:provider delay =\"-1\"/ to make Dubbo expose the service after the Spring container has been initialized. If you use getBean() extensively, the equivalent of degenerating Spring to factory mode is to isolate Dubbo's service from a separate Spring container. [^1]: Base on the ContextRefreshedEvent event of the Spring to trigger publish service.","title":"Avoid ways"},{"location":"user/demos/distributed-transaction/","text":"Distributed transaction Distributed transactions are based on the JTA / XA specification(this feature has not yet been implemented) Two-phase commit:","title":"Transaction"},{"location":"user/demos/distributed-transaction/#distributed-transaction","text":"Distributed transactions are based on the JTA / XA specification(this feature has not yet been implemented) Two-phase commit:","title":"Distributed transaction"},{"location":"user/demos/dump/","text":"Dump When the business thread pool is full, we need to know what resources/conditions are waiting for the thread , to find the bottleneck point of the system or abnormal point. dubbo automatically export thread stack through Jstack to keep the scene for easy to troubleshoot the problem. Default policy: Export file path\uff0cuser.home directory Export interval\uff0cThe shortest interval allows you to export every 10 minutes Specified export file path: # dubbo.properties dubbo.application.dump.directory=/tmp dubbo:application ... dubbo:parameter key= dump.directory value= /tmp / /dubbo:application","title":"Thread dump"},{"location":"user/demos/dump/#dump","text":"When the business thread pool is full, we need to know what resources/conditions are waiting for the thread , to find the bottleneck point of the system or abnormal point. dubbo automatically export thread stack through Jstack to keep the scene for easy to troubleshoot the problem. Default policy: Export file path\uff0cuser.home directory Export interval\uff0cThe shortest interval allows you to export every 10 minutes Specified export file path: # dubbo.properties dubbo.application.dump.directory=/tmp dubbo:application ... dubbo:parameter key= dump.directory value= /tmp / /dubbo:application","title":"Dump"},{"location":"user/demos/echo-service/","text":"Echo Testing Echo testing is used for check the service is available,Echo testing is performed according to the normal request flow and is able to test whether the entire call is unobstructed and can be used for monitoring. All the services will be automatically implemented EchoService interface,just cast any service reference to EchoService to use it. Spring configuration: dubbo:reference id= memberService interface= com.xxx.MemberService / The java code\uff1a // reference the remote service MemberService memberService = ctx.getBean( memberService ); // case the service reference to EchoService EchoService echoService = (EchoService) memberService; // Echo test usability String status = echoService.$echo( OK ); assert(status.equals( OK ));","title":"Echo service"},{"location":"user/demos/echo-service/#echo-testing","text":"Echo testing is used for check the service is available,Echo testing is performed according to the normal request flow and is able to test whether the entire call is unobstructed and can be used for monitoring. All the services will be automatically implemented EchoService interface,just cast any service reference to EchoService to use it. Spring configuration: dubbo:reference id= memberService interface= com.xxx.MemberService / The java code\uff1a // reference the remote service MemberService memberService = ctx.getBean( memberService ); // case the service reference to EchoService EchoService echoService = (EchoService) memberService; // Echo test usability String status = echoService.$echo( OK ); assert(status.equals( OK ));","title":"Echo Testing"},{"location":"user/demos/events-notify/","text":"Event Notify Before calling, after calling, when an exception occurs,will trigger oninvoke , onreturn , onthrow events.You can configure which method to notify when an event occurs. Service Interface interface IDemoService { public Person get(int id); } Service provider implement the service. class NormalDemoService implements IDemoService { public Person get(int id) { return new Person(id, charles`son , 4); } } Service provider configure the service which it provided. dubbo:application name= rpc-callback-demo / dubbo:registry address= zookeeper://127.0.0.1:2181 / bean id= demoService class= org.apache.dubbo.callback.implicit.NormalDemoService / dubbo:service interface= org.apache.dubbo.callback.implicit.IDemoService ref= demoService version= 1.0.0 group= cn / Declare the Callback interface at service consumer-side. interface Notify { public void onreturn(Person msg, Integer id); public void onthrow(Throwable ex, Integer id); } Implement the Callback at service consumer-side. class NotifyImpl implements Notify { public Map Integer, Person ret = new HashMap Integer, Person (); public Map Integer, Throwable errors = new HashMap Integer, Throwable (); public void onreturn(Person msg, Integer id) { System.out.println( onreturn: + msg); ret.put(id, msg); } public void onthrow(Throwable ex, Integer id) { errors.put(id, ex); } } Configure the Callback at service consumer-side. bean id = demoCallback class = org.apache.dubbo.callback.implicit.NofifyImpl / dubbo:reference id= demoService interface= org.apache.dubbo.callback.implicit.IDemoService version= 1.0.0 group= cn dubbo:method name= get async= true onreturn = demoCallback.onreturn onthrow= demoCallback.onthrow / /dubbo:reference callback and async functions are orthogonally decomposed. async = true means that the result is returned immediately. onreturn means that a callback is required. There are several situations with the tow attributes[^2]. Asynchronous callback mode: async=true onreturn=\"xxx\" Synchronous callback mode: async=false onreturn=\"xxx\" Asynchronous no callback: async=true Synchronous no callback: async=true Testing code IDemoService demoService = (IDemoService) context.getBean( demoService ); NofifyImpl notify = (NofifyImpl) context.getBean( demoCallback ); int requestId = 2; Person ret = demoService.get(requestId); Assert.assertEquals(null, ret); //for Test:Just used to illustrate the normal callback callback, the specific business decisions. for (int i = 0; i 10; i++) { if (!notify.ret.containsKey(requestId)) { Thread.sleep(200); } else { break; } } Assert.assertEquals(requestId, notify.ret.get(requestId).getId()); NOTE 2.0.7+ version, async=false is default.","title":"Event callback"},{"location":"user/demos/events-notify/#event-notify","text":"Before calling, after calling, when an exception occurs,will trigger oninvoke , onreturn , onthrow events.You can configure which method to notify when an event occurs.","title":"Event Notify"},{"location":"user/demos/events-notify/#service-interface","text":"interface IDemoService { public Person get(int id); }","title":"Service Interface"},{"location":"user/demos/events-notify/#service-provider-implement-the-service","text":"class NormalDemoService implements IDemoService { public Person get(int id) { return new Person(id, charles`son , 4); } }","title":"Service provider implement the service."},{"location":"user/demos/events-notify/#service-provider-configure-the-service-which-it-provided","text":"dubbo:application name= rpc-callback-demo / dubbo:registry address= zookeeper://127.0.0.1:2181 / bean id= demoService class= org.apache.dubbo.callback.implicit.NormalDemoService / dubbo:service interface= org.apache.dubbo.callback.implicit.IDemoService ref= demoService version= 1.0.0 group= cn /","title":"Service provider configure the service which it provided."},{"location":"user/demos/events-notify/#declare-the-callback-interface-at-service-consumer-side","text":"interface Notify { public void onreturn(Person msg, Integer id); public void onthrow(Throwable ex, Integer id); }","title":"Declare the Callback interface at service consumer-side."},{"location":"user/demos/events-notify/#implement-the-callback-at-service-consumer-side","text":"class NotifyImpl implements Notify { public Map Integer, Person ret = new HashMap Integer, Person (); public Map Integer, Throwable errors = new HashMap Integer, Throwable (); public void onreturn(Person msg, Integer id) { System.out.println( onreturn: + msg); ret.put(id, msg); } public void onthrow(Throwable ex, Integer id) { errors.put(id, ex); } }","title":"Implement the Callback at service consumer-side."},{"location":"user/demos/events-notify/#configure-the-callback-at-service-consumer-side","text":"bean id = demoCallback class = org.apache.dubbo.callback.implicit.NofifyImpl / dubbo:reference id= demoService interface= org.apache.dubbo.callback.implicit.IDemoService version= 1.0.0 group= cn dubbo:method name= get async= true onreturn = demoCallback.onreturn onthrow= demoCallback.onthrow / /dubbo:reference callback and async functions are orthogonally decomposed. async = true means that the result is returned immediately. onreturn means that a callback is required. There are several situations with the tow attributes[^2]. Asynchronous callback mode: async=true onreturn=\"xxx\" Synchronous callback mode: async=false onreturn=\"xxx\" Asynchronous no callback: async=true Synchronous no callback: async=true","title":"Configure the Callback at service consumer-side."},{"location":"user/demos/events-notify/#testing-code","text":"IDemoService demoService = (IDemoService) context.getBean( demoService ); NofifyImpl notify = (NofifyImpl) context.getBean( demoCallback ); int requestId = 2; Person ret = demoService.get(requestId); Assert.assertEquals(null, ret); //for Test:Just used to illustrate the normal callback callback, the specific business decisions. for (int i = 0; i 10; i++) { if (!notify.ret.containsKey(requestId)) { Thread.sleep(200); } else { break; } } Assert.assertEquals(requestId, notify.ret.get(requestId).getId()); NOTE 2.0.7+ version, async=false is default.","title":"Testing code"},{"location":"user/demos/explicit-target/","text":"Explicit target In the development and testing environment, it is often necessary to bypass the registry and test only designated service providers. In this case, point-to-point direct connection may be required, and the service provider will ignore the list of provider registration providers. The interface A configure Point-to-point, does not affect the B interface to obtain a list from the registry. Configure with XML If it is online demand needs the point-to-point feature,You can configure the specified provider url at dubbo:reference .it will bypass the registry, multiple addresses separated by semicolons, the following configuration: dubbo:reference id= xxxService interface= com.alibaba.xxx.XxxService url= dubbo://localhost:20890 / Configure with the -D argument Add the -D parameter mapping service address to the JVM startup parameters\uff1a java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890 Configure with the .properties file If you have more services, you can also use file mapping to specify the mapping file path with -Ddubbo.resolve.file . This configuration takes precedence over the configuration in dubbo: reference , for example: java -Ddubbo.resolve.file=xxx.properties Then add the configuration in the mapping file xxx.properties , where key is the service name and value is the service provider URL: com.alibaba.xxx.XxxService=dubbo://localhost:20890 NOTE To avoid complicating the online environment, do not use this feature online and should only be used during the testing phase","title":"Connecting certain provider straightly"},{"location":"user/demos/explicit-target/#explicit-target","text":"In the development and testing environment, it is often necessary to bypass the registry and test only designated service providers. In this case, point-to-point direct connection may be required, and the service provider will ignore the list of provider registration providers. The interface A configure Point-to-point, does not affect the B interface to obtain a list from the registry.","title":"Explicit target"},{"location":"user/demos/explicit-target/#configure-with-xml","text":"If it is online demand needs the point-to-point feature,You can configure the specified provider url at dubbo:reference .it will bypass the registry, multiple addresses separated by semicolons, the following configuration: dubbo:reference id= xxxService interface= com.alibaba.xxx.XxxService url= dubbo://localhost:20890 /","title":"Configure with XML"},{"location":"user/demos/explicit-target/#configure-with-the-d-argument","text":"Add the -D parameter mapping service address to the JVM startup parameters\uff1a java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890","title":"Configure with the -D argument"},{"location":"user/demos/explicit-target/#configure-with-the-properties-file","text":"If you have more services, you can also use file mapping to specify the mapping file path with -Ddubbo.resolve.file . This configuration takes precedence over the configuration in dubbo: reference , for example: java -Ddubbo.resolve.file=xxx.properties Then add the configuration in the mapping file xxx.properties , where key is the service name and value is the service provider URL: com.alibaba.xxx.XxxService=dubbo://localhost:20890 NOTE To avoid complicating the online environment, do not use this feature online and should only be used during the testing phase","title":"Configure with the .properties file"},{"location":"user/demos/fault-tolerent-strategy/","text":"Fault Tolerance Strategy Dubbo offers a variety of fault-tolerant scenarios when a cluster call fails, with a default failover retry. The relationship between nodes: This Invoker is the callable Service's abstract of the Provider , and the Invoker packaging the Provider 's address and Service 's interface. The Directory represent multiple Invoker ,You can think of it as List Invoker ,But unlike List ,its value can be dynamically changing.such as registry push changes The Cluster disguises multiple Invoker in Directory as a Invoker ,The upper transparent, masquerade process contains fault-tolerant logic, call failed, try another The Router is responsible for selecting subsets according to routing rules from multiple Invoker s, such as read-write separation, application isolation, etc. LoadBalance is responsible for selecting a specific one from multiple Invoker for this call. The selection process includes the load balancing algorithm. If the call fails, it needs to be re-selected Cluster fault-tolerant mode You can also customize the cluster fault tolerance strategy, see Cluster extension for more details. Failover Cluster Failure automatically switch, when there is failure, retry the other server (default). Usually used for read operations, but retries can result in longer delays. The times of retries can be set via retries =2 (excluding the first time). The times of retries is configured as follows: dubbo:service retries= 2 / OR dubbo:reference retries= 2 / OR dubbo:reference dubbo:method name= findFoo retries= 2 / /dubbo:reference Failfast Cluster Fast failure, only made a call, failure immediately error. Usually used for non-idempotent write operations, such as adding records Failsafe Cluster Failure of security, anomalies, directly ignored. Usually used to write audit logs and other operations. Failback Cluster Failure automatically restored, failed to record the background request, regular retransmission. Usually used for message notification operations. Forking Cluster Multiple servers are invoked in parallel, returning as soon as one succeeds. Usually used for real-time demanding read operations, but need to waste more service resources. The maximum number of parallelism can be set with forks=2 . Broadcast Cluster Calling all providers broadcast, one by one call, any error is reported ( 2.1.0+ ). It is usually used to notify all providers to update local resource information such as caches or logs. Cluster mode configuration Follow the example below to configure cluster mode on service providers and consumers dubbo:service cluster= failsafe / OR dubbo:reference cluster= failsafe /","title":"Fault tolerance"},{"location":"user/demos/fault-tolerent-strategy/#fault-tolerance-strategy","text":"Dubbo offers a variety of fault-tolerant scenarios when a cluster call fails, with a default failover retry. The relationship between nodes: This Invoker is the callable Service's abstract of the Provider , and the Invoker packaging the Provider 's address and Service 's interface. The Directory represent multiple Invoker ,You can think of it as List Invoker ,But unlike List ,its value can be dynamically changing.such as registry push changes The Cluster disguises multiple Invoker in Directory as a Invoker ,The upper transparent, masquerade process contains fault-tolerant logic, call failed, try another The Router is responsible for selecting subsets according to routing rules from multiple Invoker s, such as read-write separation, application isolation, etc. LoadBalance is responsible for selecting a specific one from multiple Invoker for this call. The selection process includes the load balancing algorithm. If the call fails, it needs to be re-selected","title":"Fault Tolerance Strategy"},{"location":"user/demos/fault-tolerent-strategy/#cluster-fault-tolerant-mode","text":"You can also customize the cluster fault tolerance strategy, see Cluster extension for more details.","title":"Cluster fault-tolerant mode"},{"location":"user/demos/fault-tolerent-strategy/#failover-cluster","text":"Failure automatically switch, when there is failure, retry the other server (default). Usually used for read operations, but retries can result in longer delays. The times of retries can be set via retries =2 (excluding the first time). The times of retries is configured as follows: dubbo:service retries= 2 / OR dubbo:reference retries= 2 / OR dubbo:reference dubbo:method name= findFoo retries= 2 / /dubbo:reference","title":"Failover Cluster"},{"location":"user/demos/fault-tolerent-strategy/#failfast-cluster","text":"Fast failure, only made a call, failure immediately error. Usually used for non-idempotent write operations, such as adding records","title":"Failfast Cluster"},{"location":"user/demos/fault-tolerent-strategy/#failsafe-cluster","text":"Failure of security, anomalies, directly ignored. Usually used to write audit logs and other operations.","title":"Failsafe Cluster"},{"location":"user/demos/fault-tolerent-strategy/#failback-cluster","text":"Failure automatically restored, failed to record the background request, regular retransmission. Usually used for message notification operations.","title":"Failback Cluster"},{"location":"user/demos/fault-tolerent-strategy/#forking-cluster","text":"Multiple servers are invoked in parallel, returning as soon as one succeeds. Usually used for real-time demanding read operations, but need to waste more service resources. The maximum number of parallelism can be set with forks=2 .","title":"Forking Cluster"},{"location":"user/demos/fault-tolerent-strategy/#broadcast-cluster","text":"Calling all providers broadcast, one by one call, any error is reported ( 2.1.0+ ). It is usually used to notify all providers to update local resource information such as caches or logs.","title":"Broadcast Cluster"},{"location":"user/demos/fault-tolerent-strategy/#cluster-mode-configuration","text":"Follow the example below to configure cluster mode on service providers and consumers dubbo:service cluster= failsafe / OR dubbo:reference cluster= failsafe /","title":"Cluster mode configuration"},{"location":"user/demos/generic-reference/","text":"Generic Reference Generic invocation is mainly used when the client does not have API interface or model class, all POJOs in parameters and return values are represented by Map .Commonly used for framework integration such as: implementing a common service testing framework, all service implementations can be invoked via GenericService . Use generic invocation via Spring Declared in the Spring configuration file generic =\" true \" \uff1a dubbo:reference id= barService interface= com.foo.BarService generic= true / In Java code, get barService and start generic invocation: GenericService barService = (GenericService) applicationContext.getBean( barService ); Object result = barService.$invoke( sayHello , new String[] { java.lang.String }, new Object[] { World }); Use generic invocation via API import org.apache.dubbo.rpc.service.GenericService; ... // reference remote service // The instance is very heavy, which encapsulates all the registration center and service provider connection, please cache ReferenceConfig GenericService reference = new ReferenceConfig GenericService (); // weak type service interface name reference.setInterface( com.xxx.XxxService ); reference.setVersion( 1.0.0 ); // declared as generic service reference.setGeneric(true); // service stub type is also the org.apache.dubbo.rpc.service.GenericService GenericService genericService = reference.get(); // basic types and Date, List, Map, etc. do not need conversion, direct use them Object result = genericService.$invoke( sayHello , new String[] { java.lang.String }, new Object[] { world }); // map POJO parameters, if the return value is POJO will automatically turn into map Map String, Object person = new HashMap String, Object (); person.put( name , xxx ); person.put( password , yyy ); // if the return value is POJO will automatically turn into map Object result = genericService.$invoke( findPerson , new String[] { com.xxx.Person }, new Object[]{person}); ... Further explanation of generalized types Consider POJO like this\uff1a package com.xxx; public class PersonImpl implements Person { private String name; private String password; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } The POJO data\uff1a Person person = new PersonImpl(); person.setName( xxx ); person.setPassword( yyy ); Data represented by Map \uff1a Map String, Object map = new HashMap String, Object (); // Note: If the parameter type is an interface, or List lost the generic class, you can specify the type of the class attribute map.put( class , com.xxx.PersonImpl ); map.put( name , xxx ); map.put( password , yyy );","title":"Generic call"},{"location":"user/demos/generic-reference/#generic-reference","text":"Generic invocation is mainly used when the client does not have API interface or model class, all POJOs in parameters and return values are represented by Map .Commonly used for framework integration such as: implementing a common service testing framework, all service implementations can be invoked via GenericService .","title":"Generic Reference"},{"location":"user/demos/generic-reference/#use-generic-invocation-via-spring","text":"Declared in the Spring configuration file generic =\" true \" \uff1a dubbo:reference id= barService interface= com.foo.BarService generic= true / In Java code, get barService and start generic invocation: GenericService barService = (GenericService) applicationContext.getBean( barService ); Object result = barService.$invoke( sayHello , new String[] { java.lang.String }, new Object[] { World });","title":"Use generic invocation via Spring"},{"location":"user/demos/generic-reference/#use-generic-invocation-via-api","text":"import org.apache.dubbo.rpc.service.GenericService; ... // reference remote service // The instance is very heavy, which encapsulates all the registration center and service provider connection, please cache ReferenceConfig GenericService reference = new ReferenceConfig GenericService (); // weak type service interface name reference.setInterface( com.xxx.XxxService ); reference.setVersion( 1.0.0 ); // declared as generic service reference.setGeneric(true); // service stub type is also the org.apache.dubbo.rpc.service.GenericService GenericService genericService = reference.get(); // basic types and Date, List, Map, etc. do not need conversion, direct use them Object result = genericService.$invoke( sayHello , new String[] { java.lang.String }, new Object[] { world }); // map POJO parameters, if the return value is POJO will automatically turn into map Map String, Object person = new HashMap String, Object (); person.put( name , xxx ); person.put( password , yyy ); // if the return value is POJO will automatically turn into map Object result = genericService.$invoke( findPerson , new String[] { com.xxx.Person }, new Object[]{person}); ...","title":"Use generic invocation via API"},{"location":"user/demos/generic-reference/#further-explanation-of-generalized-types","text":"Consider POJO like this\uff1a package com.xxx; public class PersonImpl implements Person { private String name; private String password; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } The POJO data\uff1a Person person = new PersonImpl(); person.setName( xxx ); person.setPassword( yyy ); Data represented by Map \uff1a Map String, Object map = new HashMap String, Object (); // Note: If the parameter type is an interface, or List lost the generic class, you can specify the type of the class attribute map.put( class , com.xxx.PersonImpl ); map.put( name , xxx ); map.put( password , yyy );","title":"Further explanation of generalized types"},{"location":"user/demos/generic-service/","text":"Generic Service The implementation of the generic interface is mainly used when there is no API interface and model class on the server side. All POJOs in the parameters and return values are represented by the Map and are usually used for framework integration. For example, to implement a universal remote service Mock framework, handle all service requests by implementing the GenericService interface. In Java code, implement GenericService interface\uff1a package com.foo; public class MyGenericService implements GenericService { public Object $invoke(String methodName, String[] parameterTypes, Object[] args) throws GenericException { if ( sayHello .equals(methodName)) { return Welcome + args[0]; } } } Export generic implements via Spring Declared in the Spring configuration file\uff1a bean id= genericService class= com.foo.MyGenericService / dubbo:service interface= com.foo.BarService ref= genericService / Export generic implements via API ... // use org.apache.dubbo.rpc.service.GenericService can replace all implements GenericService xxxService = new XxxGenericService(); // The instance is very heavy, which encapsulates all the registration center and service provider connection, please cache ServiceConfig GenericService service = new ServiceConfig GenericService (); // weak type service interface name service.setInterface( com.xxx.XxxService ); service.setVersion( 1.0.0 ); // point to a generic serivce instance service.setRef(xxxService); // export service to registration center service.export();","title":"Generic implementation"},{"location":"user/demos/generic-service/#generic-service","text":"The implementation of the generic interface is mainly used when there is no API interface and model class on the server side. All POJOs in the parameters and return values are represented by the Map and are usually used for framework integration. For example, to implement a universal remote service Mock framework, handle all service requests by implementing the GenericService interface. In Java code, implement GenericService interface\uff1a package com.foo; public class MyGenericService implements GenericService { public Object $invoke(String methodName, String[] parameterTypes, Object[] args) throws GenericException { if ( sayHello .equals(methodName)) { return Welcome + args[0]; } } }","title":"Generic Service"},{"location":"user/demos/generic-service/#export-generic-implements-via-spring","text":"Declared in the Spring configuration file\uff1a bean id= genericService class= com.foo.MyGenericService / dubbo:service interface= com.foo.BarService ref= genericService /","title":"Export generic implements via Spring"},{"location":"user/demos/generic-service/#export-generic-implements-via-api","text":"... // use org.apache.dubbo.rpc.service.GenericService can replace all implements GenericService xxxService = new XxxGenericService(); // The instance is very heavy, which encapsulates all the registration center and service provider connection, please cache ServiceConfig GenericService service = new ServiceConfig GenericService (); // weak type service interface name service.setInterface( com.xxx.XxxService ); service.setVersion( 1.0.0 ); // point to a generic serivce instance service.setRef(xxxService); // export service to registration center service.export();","title":"Export generic implements via API"},{"location":"user/demos/graceful-shutdown/","text":"Graceful Shutdown Dubbo is graceful shutdown through the ShutdownHook of the JDK, so graceful shutdowns are not performed if you force shutdown the command, such as kill -9 PID , and will only be executed if kill PID is passed. Howto Service provider When stop, first marked as not receiving new requests, the new request directly return the error, so that the client retries other machines. Then check thread pool thread is running, if any, waiting for all threads to complete execution, unless overtime, then forced to close. Service consumer When stop, No longer initiate a new request, all request on the client that got an error. Then check the request has not returned the response, waiting for the response to return, unless overtime, then forced to close. Configuration shutdown wait time Set graceful shutdown timeout, the default timeout is 10 seconds, if the overtime is forced to close. # dubbo.properties dubbo.service.shutdown.wait=15000 If ShutdownHook does not take effect, you can call it yourself, in tomcat, it is recommended by extending the ContextListener and call the following code for graceful shutdown \uff1a DubboShutdownHook.destroyAll();","title":"Graceful shutdown"},{"location":"user/demos/graceful-shutdown/#graceful-shutdown","text":"Dubbo is graceful shutdown through the ShutdownHook of the JDK, so graceful shutdowns are not performed if you force shutdown the command, such as kill -9 PID , and will only be executed if kill PID is passed.","title":"Graceful Shutdown"},{"location":"user/demos/graceful-shutdown/#howto","text":"","title":"Howto"},{"location":"user/demos/graceful-shutdown/#service-provider","text":"When stop, first marked as not receiving new requests, the new request directly return the error, so that the client retries other machines. Then check thread pool thread is running, if any, waiting for all threads to complete execution, unless overtime, then forced to close.","title":"Service provider"},{"location":"user/demos/graceful-shutdown/#service-consumer","text":"When stop, No longer initiate a new request, all request on the client that got an error. Then check the request has not returned the response, waiting for the response to return, unless overtime, then forced to close.","title":"Service consumer"},{"location":"user/demos/graceful-shutdown/#configuration-shutdown-wait-time","text":"Set graceful shutdown timeout, the default timeout is 10 seconds, if the overtime is forced to close. # dubbo.properties dubbo.service.shutdown.wait=15000 If ShutdownHook does not take effect, you can call it yourself, in tomcat, it is recommended by extending the ContextListener and call the following code for graceful shutdown \uff1a DubboShutdownHook.destroyAll();","title":"Configuration shutdown wait time"},{"location":"user/demos/group-merger/","text":"Group Merger According to the group to invoke server and return the merge result [^1], such as the menu service, the same interface, but there are a variety of implementations, using group distinction, consumers call each group and get the results, the merger can merge the resules, so that you can achieve aggregation Menu Item. Related code can refer to dubbo project example Configuration Merge all groups dubbo:reference interface= com.xxx.MenuService group= * merger= true / Merge the specified group dubbo:reference interface= com.xxx.MenuService group= aaa,bbb merger= true / The specified method to merge the results, other unspecified methods, will only call one group dubbo:reference interface= com.xxx.MenuService group= * dubbo:method name= getMenuItems merger= true / /dubbo:reference The Specified a method does not merge the results, others merge the results dubbo:reference interface= com.xxx.MenuService group= * merger= true dubbo:method name= getMenuItems merger= false / /dubbo:reference Specify the merge strategy, the default according to the type of return value automatically match, if the same type has two mergers, you need to specify the name of the merger[^2] dubbo:reference interface= com.xxx.MenuService group= * dubbo:method name= getMenuItems merger= mymerge / /dubbo:reference Specify the merge method, it will call the return type's method for merging, the merging method parameter type must be the return type dubbo:reference interface= com.xxx.MenuService group= * dubbo:method name= getMenuItems merger= .addAll / /dubbo:reference [^1]: since 2.1.0 began to support [^2]: See also\uff1a merger extensions","title":"Group merger"},{"location":"user/demos/group-merger/#group-merger","text":"According to the group to invoke server and return the merge result [^1], such as the menu service, the same interface, but there are a variety of implementations, using group distinction, consumers call each group and get the results, the merger can merge the resules, so that you can achieve aggregation Menu Item. Related code can refer to dubbo project example","title":"Group Merger"},{"location":"user/demos/group-merger/#configuration","text":"Merge all groups dubbo:reference interface= com.xxx.MenuService group= * merger= true / Merge the specified group dubbo:reference interface= com.xxx.MenuService group= aaa,bbb merger= true / The specified method to merge the results, other unspecified methods, will only call one group dubbo:reference interface= com.xxx.MenuService group= * dubbo:method name= getMenuItems merger= true / /dubbo:reference The Specified a method does not merge the results, others merge the results dubbo:reference interface= com.xxx.MenuService group= * merger= true dubbo:method name= getMenuItems merger= false / /dubbo:reference Specify the merge strategy, the default according to the type of return value automatically match, if the same type has two mergers, you need to specify the name of the merger[^2] dubbo:reference interface= com.xxx.MenuService group= * dubbo:method name= getMenuItems merger= mymerge / /dubbo:reference Specify the merge method, it will call the return type's method for merging, the merging method parameter type must be the return type dubbo:reference interface= com.xxx.MenuService group= * dubbo:method name= getMenuItems merger= .addAll / /dubbo:reference [^1]: since 2.1.0 began to support [^2]: See also\uff1a merger extensions","title":"Configuration"},{"location":"user/demos/hostname-binding/","text":"Hostname Binding Lookup order Default host IP lookup order\uff1a Get local address via LocalHost.getLocalHost() . If it is 127. * loopback address, then scan the network for host IP Host configuration Registered address if it is not correct, such as the need to register public address, you can do this: edit /etc/hosts : add machinename and public ip, such as: test1 205.182.23.201 in dubbo.xml add host address configuration: xml dubbo:protocol host=\"205.182.23.201\" or config that in dubbo.properties : properties dubbo.protocol.host=205.182.23.201 Port configuration The default port and protocol: Protocol Port dubbo 20880 rmi 1099 http 80 hessian 80 webservice 80 memcached 11211 redis 6379 You can configure the port as follows: in dubbo.xml add port configuration: xml dubbo:protocol name=\"dubbo\" port=\"20880\" or config that in dubbo.properties : properties dubbo.protocol.dubbo.port=20880","title":"Host binding"},{"location":"user/demos/hostname-binding/#hostname-binding","text":"","title":"Hostname Binding"},{"location":"user/demos/hostname-binding/#lookup-order","text":"Default host IP lookup order\uff1a Get local address via LocalHost.getLocalHost() . If it is 127. * loopback address, then scan the network for host IP","title":"Lookup order"},{"location":"user/demos/hostname-binding/#host-configuration","text":"Registered address if it is not correct, such as the need to register public address, you can do this: edit /etc/hosts : add machinename and public ip, such as: test1 205.182.23.201 in dubbo.xml add host address configuration: xml dubbo:protocol host=\"205.182.23.201\" or config that in dubbo.properties : properties dubbo.protocol.host=205.182.23.201","title":"Host configuration"},{"location":"user/demos/hostname-binding/#port-configuration","text":"The default port and protocol: Protocol Port dubbo 20880 rmi 1099 http 80 hessian 80 webservice 80 memcached 11211 redis 6379 You can configure the port as follows: in dubbo.xml add port configuration: xml dubbo:protocol name=\"dubbo\" port=\"20880\" or config that in dubbo.properties : properties dubbo.protocol.dubbo.port=20880","title":"Port configuration"},{"location":"user/demos/introduction/","text":"To complete run, please see: Quickstart , here just lists the configuration of various scenarios The following examples are all based on Spring configuration: Xml configuration for reference, if you do not want to use Spring, but want to be use it via the directly API, please see: API configuration","title":"Introduction"},{"location":"user/demos/lazy-connect/","text":"Lazy Connect Lazy connect can reduce the number of keep-alive connections. When a call is initiated, create a keep-alive connection.[^1] dubbo:protocol name= dubbo lazy= true / [^1]: Note: This configuration takes effect only for dubbo protocols that use keep-alive connections.","title":"Lazy connec"},{"location":"user/demos/lazy-connect/#lazy-connect","text":"Lazy connect can reduce the number of keep-alive connections. When a call is initiated, create a keep-alive connection.[^1] dubbo:protocol name= dubbo lazy= true / [^1]: Note: This configuration takes effect only for dubbo protocols that use keep-alive connections.","title":"Lazy Connect"},{"location":"user/demos/loadbalance/","text":"LoadBalance Dubbo offers a number of balancing strategies for cluster load balancing, which defaults to random . You can extend the load balancing strategy by yourself, see: LoadBalance extension LoadBalance strategy Random LoadBalance Ramdom , set random probabilities by weight. The probability of collisions on one section is high, but the larger the amount of calls, the more uniform the distribution. And when use weight based on probability the distribution turns out to be uniform, which also helps to dynamically adjust the provider weights. RoundRobin LoadBalance RoundRobin , use the weight's common advisor to determine round robin ratio. Traffic flow to slower providers may cause requests piled up, e.g., if there's a provider processing requests in a very slow speed, but it's still alive, which means it can receive request as normal. According to RoundRobin policy, consumers will continuously send requests to this provider on predetermined pace, have no aware of the provider's bad status. Finally, we will get many requests stuck on this unhealthy provider. LeastActive LoadBalance LeastActive , a random mechanism based on actives, actives means the num of requests a consumer have sent but not return yet\u3002 Slower providers will receive fewer requests, cause slower provider have higher actives . ConsistentHash LoadBalance ConsistentHash , the same parameters of the request is always sent to the same provider. When a provider fails, the original request to the provider, based on the virtual node algorithm, averages to other providers, does not cause drastic changes. Algorithm reference\uff1ahttp://en.wikipedia.org/wiki/Consistent_hashing By default only the first parameter Hash, if you want to modify, please configure dubbo:parameter key=\"hash.arguments\" value=\"0,1\" / By default 160 virtual nodes, if you want to modify, please configure dubbo:parameter key=\"hash.nodes\" value=\"320\" / See the algorithm at http://en.wikipedia.org/wiki/Consistent_hashing Configuration Server service level dubbo:service interface= ... loadbalance= roundrobin / Client service level dubbo:reference interface= ... loadbalance= roundrobin / Server method level dubbo:service interface= ... dubbo:method name= ... loadbalance= roundrobin / /dubbo:service Client method level dubbo:reference interface= ... dubbo:method name= ... loadbalance= roundrobin / /dubbo:reference","title":"Load balance"},{"location":"user/demos/loadbalance/#loadbalance","text":"Dubbo offers a number of balancing strategies for cluster load balancing, which defaults to random . You can extend the load balancing strategy by yourself, see: LoadBalance extension","title":"LoadBalance"},{"location":"user/demos/loadbalance/#loadbalance-strategy","text":"","title":"LoadBalance strategy"},{"location":"user/demos/loadbalance/#random-loadbalance","text":"Ramdom , set random probabilities by weight. The probability of collisions on one section is high, but the larger the amount of calls, the more uniform the distribution. And when use weight based on probability the distribution turns out to be uniform, which also helps to dynamically adjust the provider weights.","title":"Random LoadBalance"},{"location":"user/demos/loadbalance/#roundrobin-loadbalance","text":"RoundRobin , use the weight's common advisor to determine round robin ratio. Traffic flow to slower providers may cause requests piled up, e.g., if there's a provider processing requests in a very slow speed, but it's still alive, which means it can receive request as normal. According to RoundRobin policy, consumers will continuously send requests to this provider on predetermined pace, have no aware of the provider's bad status. Finally, we will get many requests stuck on this unhealthy provider.","title":"RoundRobin LoadBalance"},{"location":"user/demos/loadbalance/#leastactive-loadbalance","text":"LeastActive , a random mechanism based on actives, actives means the num of requests a consumer have sent but not return yet\u3002 Slower providers will receive fewer requests, cause slower provider have higher actives .","title":"LeastActive LoadBalance"},{"location":"user/demos/loadbalance/#consistenthash-loadbalance","text":"ConsistentHash , the same parameters of the request is always sent to the same provider. When a provider fails, the original request to the provider, based on the virtual node algorithm, averages to other providers, does not cause drastic changes. Algorithm reference\uff1ahttp://en.wikipedia.org/wiki/Consistent_hashing By default only the first parameter Hash, if you want to modify, please configure dubbo:parameter key=\"hash.arguments\" value=\"0,1\" / By default 160 virtual nodes, if you want to modify, please configure dubbo:parameter key=\"hash.nodes\" value=\"320\" / See the algorithm at http://en.wikipedia.org/wiki/Consistent_hashing","title":"ConsistentHash LoadBalance"},{"location":"user/demos/loadbalance/#configuration","text":"","title":"Configuration"},{"location":"user/demos/loadbalance/#server-service-level","text":"dubbo:service interface= ... loadbalance= roundrobin /","title":"Server service level"},{"location":"user/demos/loadbalance/#client-service-level","text":"dubbo:reference interface= ... loadbalance= roundrobin /","title":"Client service level"},{"location":"user/demos/loadbalance/#server-method-level","text":"dubbo:service interface= ... dubbo:method name= ... loadbalance= roundrobin / /dubbo:service","title":"Server method level"},{"location":"user/demos/loadbalance/#client-method-level","text":"dubbo:reference interface= ... dubbo:method name= ... loadbalance= roundrobin / /dubbo:reference","title":"Client method level"},{"location":"user/demos/local-call/","text":"Local call The local call uses the injvm protocol, a pseudo-protocol that does not turn on the port, does not initiate remote calls, is directly associated within the JVM, but executes the Dubbo Filter chain. Configuration Configure injvm protocol dubbo:protocol name= injvm / Configure default provider dubbo:provider protocol= injvm / Configure default service dubbo:service protocol= injvm / Use injvm first dubbo:consumer injvm= true .../ dubbo:provider injvm= true .../ or dubbo:reference injvm= true .../ dubbo:service injvm= true .../ Note: Dubbo services are exposed locally from 2.2.0 by default. It can be referenced locally without any configuration. If you don't want the service to be exposed remotely, you only need to set the protocol to injvm in the provider. Automatically exposed, local service references 2.2.0 or later, each service is exposed locally by default. When referring to the service, the local service is referenced by default. If you want to reference a remote service, you can use the following configuration to force a reference to a remote service. dubbo:reference ... scope= remote /","title":"Local call"},{"location":"user/demos/local-call/#local-call","text":"The local call uses the injvm protocol, a pseudo-protocol that does not turn on the port, does not initiate remote calls, is directly associated within the JVM, but executes the Dubbo Filter chain.","title":"Local call"},{"location":"user/demos/local-call/#configuration","text":"Configure injvm protocol dubbo:protocol name= injvm / Configure default provider dubbo:provider protocol= injvm / Configure default service dubbo:service protocol= injvm / Use injvm first dubbo:consumer injvm= true .../ dubbo:provider injvm= true .../ or dubbo:reference injvm= true .../ dubbo:service injvm= true .../ Note: Dubbo services are exposed locally from 2.2.0 by default. It can be referenced locally without any configuration. If you don't want the service to be exposed remotely, you only need to set the protocol to injvm in the provider.","title":"Configuration"},{"location":"user/demos/local-call/#automatically-exposed-local-service-references","text":"2.2.0 or later, each service is exposed locally by default. When referring to the service, the local service is referenced by default. If you want to reference a remote service, you can use the following configuration to force a reference to a remote service. dubbo:reference ... scope= remote /","title":"Automatically exposed, local service references"},{"location":"user/demos/local-mock/","text":"Local mock Local mock [^1] is usually used for service downgrade, such as a verification service, the client does not throw an exception when the service provider hangs up all the time, but returns the authorization failed through the Mock data. Configured in the spring configuration file as follows: dubbo:reference interface= com.foo.BarService mock= true / or dubbo:reference interface= com.foo.BarService mock= com.foo.BarServiceMock / Mock implementation in the project [^2]\uff1a package com.foo; public class BarServiceMock implements BarService { public String sayHello(String name) { // You can return mock data, this method is only executed when an RpcException is thrown. return mock data ; } } If the service consumer often needs try-catch to catch exceptions, such as: Offer offer = null; try { offer = offerService.findOffer(offerId); } catch (RpcException e) { logger.error(e); } Consider changing to Mock implementation and return null in Mock implementation. If you just want to simply ignore the exception, 2.0.11 version or later version is available: dubbo:reference interface= com.foo.BarService mock= return null / Advanced Usage return return can be used to return an object's string representation as the mocked return value. The legal values incude: * empty : empty value, default value for primary type, and empty value for collections. * null : null * true : true * false : false * JSON format : a mocked return value in JSON format, will be deserialized at runtime throw throw can be used to throw an exception object as the mocked return value. Throw a default RPCException when invocation gets wrong: dubbo:reference interface= com.foo.BarService mock= throw / Throw a specified exception when invocation gets wrong: dubbo:reference interface= com.foo.BarService mock= throw com.foo.MockException / force fail Since 2.6.6 and above, it is possible to use fail: and force: in Spring's XML configuration to define mock behavior. force: means the mocked value is forced to use no matter the invocation gets wrong or not, in fact, the remote invocation will not happen at all. fail: is consistent with the default behavior, that is, mock happens only when invocation gets wrong. Futhermore, both force: and fail: can be used together with throw or return to define the mock behavior further. Force to return the specified value: dubbo:reference interface= com.foo.BarService mock= force:return fake / Force to throw the specified exception: dubbo:reference interface= com.foo.BarService mock= force:throw com.foo.MockException / Specify Mock For Particular Method Only Mock behavior can be specified on the method level. Assume there are a couple of methods on com.foo.BarService , we can specify the mock behavior for one particular method only, say sayHello() . In the example below, \"fake\" is forced to return everytime when sayHello() is called, but other methods will not be effected: dubbo:reference id= demoService check= false interface= com.foo.BarService dubbo:parameter key= sayHello.mock value= force:return fake / /dubbo:reference [^1]: Mock is a subset of the Stub. If you use Stub, you may need to rely on the RpcException class. If you use Mock, you do not need to rely on RpcException, when throwing RpcException, it will callback Mock implementation class. [^2]: BarServiceMock implements BarService and has a no-argument constructor.","title":"Local mock"},{"location":"user/demos/local-mock/#local-mock","text":"Local mock [^1] is usually used for service downgrade, such as a verification service, the client does not throw an exception when the service provider hangs up all the time, but returns the authorization failed through the Mock data. Configured in the spring configuration file as follows: dubbo:reference interface= com.foo.BarService mock= true / or dubbo:reference interface= com.foo.BarService mock= com.foo.BarServiceMock / Mock implementation in the project [^2]\uff1a package com.foo; public class BarServiceMock implements BarService { public String sayHello(String name) { // You can return mock data, this method is only executed when an RpcException is thrown. return mock data ; } } If the service consumer often needs try-catch to catch exceptions, such as: Offer offer = null; try { offer = offerService.findOffer(offerId); } catch (RpcException e) { logger.error(e); } Consider changing to Mock implementation and return null in Mock implementation. If you just want to simply ignore the exception, 2.0.11 version or later version is available: dubbo:reference interface= com.foo.BarService mock= return null /","title":"Local mock"},{"location":"user/demos/local-mock/#advanced-usage","text":"","title":"Advanced Usage"},{"location":"user/demos/local-mock/#return","text":"return can be used to return an object's string representation as the mocked return value. The legal values incude: * empty : empty value, default value for primary type, and empty value for collections. * null : null * true : true * false : false * JSON format : a mocked return value in JSON format, will be deserialized at runtime","title":"return"},{"location":"user/demos/local-mock/#throw","text":"throw can be used to throw an exception object as the mocked return value. Throw a default RPCException when invocation gets wrong: dubbo:reference interface= com.foo.BarService mock= throw / Throw a specified exception when invocation gets wrong: dubbo:reference interface= com.foo.BarService mock= throw com.foo.MockException /","title":"throw"},{"location":"user/demos/local-mock/#force-fail","text":"Since 2.6.6 and above, it is possible to use fail: and force: in Spring's XML configuration to define mock behavior. force: means the mocked value is forced to use no matter the invocation gets wrong or not, in fact, the remote invocation will not happen at all. fail: is consistent with the default behavior, that is, mock happens only when invocation gets wrong. Futhermore, both force: and fail: can be used together with throw or return to define the mock behavior further. Force to return the specified value: dubbo:reference interface= com.foo.BarService mock= force:return fake / Force to throw the specified exception: dubbo:reference interface= com.foo.BarService mock= force:throw com.foo.MockException /","title":"force &amp; fail"},{"location":"user/demos/local-mock/#specify-mock-for-particular-method-only","text":"Mock behavior can be specified on the method level. Assume there are a couple of methods on com.foo.BarService , we can specify the mock behavior for one particular method only, say sayHello() . In the example below, \"fake\" is forced to return everytime when sayHello() is called, but other methods will not be effected: dubbo:reference id= demoService check= false interface= com.foo.BarService dubbo:parameter key= sayHello.mock value= force:return fake / /dubbo:reference [^1]: Mock is a subset of the Stub. If you use Stub, you may need to rely on the RpcException class. If you use Mock, you do not need to rely on RpcException, when throwing RpcException, it will callback Mock implementation class. [^2]: BarServiceMock implements BarService and has a no-argument constructor.","title":"Specify Mock For Particular Method Only"},{"location":"user/demos/local-stub/","text":"Local stub When using rpc, the client usually only the interface, but sometimes the client also want to perform part of the logic in the client. For example: do ThreadLocal cache, verify parameters, return mock data when call fails., etc. To solve this problem, you can configure the stub in the API, so that when the client generates the proxy instance, it passes the proxy to the Stub via the constructor [^1], and then you can implement your logic in the stub implementation code. Configured in the spring configuration file as follows: dubbo:service interface= com.foo.BarService stub= true / or dubbo:service interface= com.foo.BarService stub= com.foo.BarServiceStub / Provide Stub implementation [^2]\uff1a package com.foo; public class BarServiceStub implements BarService { private final BarService barService; // The real remote proxy object is passed in through the constructor public BarServiceStub(BarService barService){ this.barService = barService; } public String sayHello(String name) { // The following code is executed on the client. You can do local ThreadLocal caching on the client side, or verify parameters, etc. try { return barService.sayHello(name); } catch (Exception e) { // You can return the mock data. return MockData ; } } } [^1]: The Stub must have a constructor that can pass in the proxy. [^2]: BarServiceStub implements BarService \uff0cit has a constructor passed in the remote BarService instance","title":"Local stub"},{"location":"user/demos/local-stub/#local-stub","text":"When using rpc, the client usually only the interface, but sometimes the client also want to perform part of the logic in the client. For example: do ThreadLocal cache, verify parameters, return mock data when call fails., etc. To solve this problem, you can configure the stub in the API, so that when the client generates the proxy instance, it passes the proxy to the Stub via the constructor [^1], and then you can implement your logic in the stub implementation code. Configured in the spring configuration file as follows: dubbo:service interface= com.foo.BarService stub= true / or dubbo:service interface= com.foo.BarService stub= com.foo.BarServiceStub / Provide Stub implementation [^2]\uff1a package com.foo; public class BarServiceStub implements BarService { private final BarService barService; // The real remote proxy object is passed in through the constructor public BarServiceStub(BarService barService){ this.barService = barService; } public String sayHello(String name) { // The following code is executed on the client. You can do local ThreadLocal caching on the client side, or verify parameters, etc. try { return barService.sayHello(name); } catch (Exception e) { // You can return the mock data. return MockData ; } } } [^1]: The Stub must have a constructor that can pass in the proxy. [^2]: BarServiceStub implements BarService \uff0cit has a constructor passed in the remote BarService instance","title":"Local stub"},{"location":"user/demos/logger-strategy/","text":"Logger adapter 2.2.1 or later, dubbo support log4j\u3001slf4j\u3001jcl\u3001jdk adapters [^1], you can also explicitly configure the log output policy in the following ways: Command sh java -Ddubbo.application.logger=log4j Configure in dubbo.properties properties dubbo.application.logger=log4j Configure in dubbo.xml xml dubbo:application logger=\"log4j\" / [^1]: Custom Extensions logger-adapter","title":"Logger"},{"location":"user/demos/logger-strategy/#logger-adapter","text":"2.2.1 or later, dubbo support log4j\u3001slf4j\u3001jcl\u3001jdk adapters [^1], you can also explicitly configure the log output policy in the following ways: Command sh java -Ddubbo.application.logger=log4j Configure in dubbo.properties properties dubbo.application.logger=log4j Configure in dubbo.xml xml dubbo:application logger=\"log4j\" / [^1]: Custom Extensions logger-adapter","title":"Logger adapter"},{"location":"user/demos/multi-protocols/","text":"Multiple protocols Dubbo allows you to configure multiple protocols, support different protocols on different services, or support multiple protocols on the same service. Every service export to one specific protocol separately Different protocol performance is not the same. Such as big data should use short connection protocol, small data and concurrent should use long connection protocol. ?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd dubbo:application name= world / dubbo:registry id= registry address= 10.20.141.150:9090 username= admin password= hello1234 / !-- multiple protocols -- dubbo:protocol name= dubbo port= 20880 / dubbo:protocol name= rmi port= 1099 / !-- Use dubbo protocol to expose the service -- dubbo:service interface= com.alibaba.hello.api.HelloService version= 1.0.0 ref= helloService protocol= dubbo / !-- Use rmi protocol to expose services -- dubbo:service interface= com.alibaba.hello.api.DemoService version= 1.0.0 ref= demoService protocol= rmi / /beans One service export to several protocols ?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd dubbo:application name= world / dubbo:registry id= registry address= 10.20.141.150:9090 username= admin password= hello1234 / !-- multiple protocols-- dubbo:protocol name= dubbo port= 20880 / dubbo:protocol name= hessian port= 8080 / !-- Service exposes multiple protocols -- dubbo:service id= helloService interface= com.alibaba.hello.api.HelloService version= 1.0.0 protocol= dubbo,hessian / /beans [^1]: custom protocol, see: protocol extension","title":"Multi-protocols"},{"location":"user/demos/multi-protocols/#multiple-protocols","text":"Dubbo allows you to configure multiple protocols, support different protocols on different services, or support multiple protocols on the same service.","title":"Multiple protocols"},{"location":"user/demos/multi-protocols/#every-service-export-to-one-specific-protocol-separately","text":"Different protocol performance is not the same. Such as big data should use short connection protocol, small data and concurrent should use long connection protocol. ?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd dubbo:application name= world / dubbo:registry id= registry address= 10.20.141.150:9090 username= admin password= hello1234 / !-- multiple protocols -- dubbo:protocol name= dubbo port= 20880 / dubbo:protocol name= rmi port= 1099 / !-- Use dubbo protocol to expose the service -- dubbo:service interface= com.alibaba.hello.api.HelloService version= 1.0.0 ref= helloService protocol= dubbo / !-- Use rmi protocol to expose services -- dubbo:service interface= com.alibaba.hello.api.DemoService version= 1.0.0 ref= demoService protocol= rmi / /beans","title":"Every service export to one specific protocol separately"},{"location":"user/demos/multi-protocols/#one-service-export-to-several-protocols","text":"?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd dubbo:application name= world / dubbo:registry id= registry address= 10.20.141.150:9090 username= admin password= hello1234 / !-- multiple protocols-- dubbo:protocol name= dubbo port= 20880 / dubbo:protocol name= hessian port= 8080 / !-- Service exposes multiple protocols -- dubbo:service id= helloService interface= com.alibaba.hello.api.HelloService version= 1.0.0 protocol= dubbo,hessian / /beans [^1]: custom protocol, see: protocol extension","title":"One service export to several protocols"},{"location":"user/demos/multi-registry/","text":"Multiple registries Dubbo supports the same service to register multiple registries, or different services were registered to different registries, or even reference the same name service from different registries. In addition, the registry supports custom extensions [^1]\u3002 One service register to multiple registries For example: Alibaba some services are not deployed in Qingdao, only deployed in Hangzhou. While other applications in Qingdao need to reference this service, you can register your services to both registries at the same time. ?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd dubbo:application name= world / !-- Multi registries -- dubbo:registry id= hangzhouRegistry address= 10.20.141.150:9090 / dubbo:registry id= qingdaoRegistry address= 10.20.141.151:9010 default= false / !-- Service register to multiple registries -- dubbo:service interface= com.alibaba.hello.api.HelloService version= 1.0.0 ref= helloService registry= hangzhouRegistry,qingdaoRegistry / /beans Different services register to different registries For example: Some CRM services are specifically designed for international stations, and some services are specifically designed for Chinese stations. ?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd dubbo:application name= world / !-- Multi registries -- dubbo:registry id= chinaRegistry address= 10.20.141.150:9090 / dubbo:registry id= intlRegistry address= 10.20.154.177:9010 default= false / !-- Service register to Chinese station registry -- dubbo:service interface= com.alibaba.hello.api.HelloService version= 1.0.0 ref= helloService registry= chinaRegistry / !-- Service register to international station registry -- dubbo:service interface= com.alibaba.hello.api.DemoService version= 1.0.0 ref= demoService registry= intlRegistry / /beans Reference services from multiple registries For example: CRM needs to call the PC2 service of Chinese station and international station at the same time. PC2 is deployed in both Chinese station and international station. The interfaces and version numbers are the same, but the database used is different. ?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd dubbo:application name= world / !-- Multi registries -- dubbo:registry id= chinaRegistry address= 10.20.141.150:9090 / dubbo:registry id= intlRegistry address= 10.20.154.177:9010 default= false / !-- Reference Chinese station service -- dubbo:reference id= chinaHelloService interface= com.alibaba.hello.api.HelloService version= 1.0.0 registry= chinaRegistry / !-- Reference international station service -- dubbo:reference id= intlHelloService interface= com.alibaba.hello.api.HelloService version= 1.0.0 registry= intlRegistry / /beans When testing, the service needs to be temporarily register to two registries, which can use vertical signs to separate multiple different registry addresses: ?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd dubbo:application name= world / !-- The vertical separation means that multiple registries are connected at the same time. Multiple cluster addresses of the same registry are separated by commas -- dubbo:registry address= 10.20.141.150:9090|10.20.154.177:9010 / !-- service reference -- dubbo:reference id= helloService interface= com.alibaba.hello.api.HelloService version= 1.0.0 / /beans [^1]: custom registry, see\uff1a registry extension","title":"Multi-registries"},{"location":"user/demos/multi-registry/#multiple-registries","text":"Dubbo supports the same service to register multiple registries, or different services were registered to different registries, or even reference the same name service from different registries. In addition, the registry supports custom extensions [^1]\u3002","title":"Multiple registries"},{"location":"user/demos/multi-registry/#one-service-register-to-multiple-registries","text":"For example: Alibaba some services are not deployed in Qingdao, only deployed in Hangzhou. While other applications in Qingdao need to reference this service, you can register your services to both registries at the same time. ?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd dubbo:application name= world / !-- Multi registries -- dubbo:registry id= hangzhouRegistry address= 10.20.141.150:9090 / dubbo:registry id= qingdaoRegistry address= 10.20.141.151:9010 default= false / !-- Service register to multiple registries -- dubbo:service interface= com.alibaba.hello.api.HelloService version= 1.0.0 ref= helloService registry= hangzhouRegistry,qingdaoRegistry / /beans","title":"One service register to multiple registries"},{"location":"user/demos/multi-registry/#different-services-register-to-different-registries","text":"For example: Some CRM services are specifically designed for international stations, and some services are specifically designed for Chinese stations. ?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd dubbo:application name= world / !-- Multi registries -- dubbo:registry id= chinaRegistry address= 10.20.141.150:9090 / dubbo:registry id= intlRegistry address= 10.20.154.177:9010 default= false / !-- Service register to Chinese station registry -- dubbo:service interface= com.alibaba.hello.api.HelloService version= 1.0.0 ref= helloService registry= chinaRegistry / !-- Service register to international station registry -- dubbo:service interface= com.alibaba.hello.api.DemoService version= 1.0.0 ref= demoService registry= intlRegistry / /beans","title":"Different services register to different registries"},{"location":"user/demos/multi-registry/#reference-services-from-multiple-registries","text":"For example: CRM needs to call the PC2 service of Chinese station and international station at the same time. PC2 is deployed in both Chinese station and international station. The interfaces and version numbers are the same, but the database used is different. ?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd dubbo:application name= world / !-- Multi registries -- dubbo:registry id= chinaRegistry address= 10.20.141.150:9090 / dubbo:registry id= intlRegistry address= 10.20.154.177:9010 default= false / !-- Reference Chinese station service -- dubbo:reference id= chinaHelloService interface= com.alibaba.hello.api.HelloService version= 1.0.0 registry= chinaRegistry / !-- Reference international station service -- dubbo:reference id= intlHelloService interface= com.alibaba.hello.api.HelloService version= 1.0.0 registry= intlRegistry / /beans When testing, the service needs to be temporarily register to two registries, which can use vertical signs to separate multiple different registry addresses: ?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd dubbo:application name= world / !-- The vertical separation means that multiple registries are connected at the same time. Multiple cluster addresses of the same registry are separated by commas -- dubbo:registry address= 10.20.141.150:9090|10.20.154.177:9010 / !-- service reference -- dubbo:reference id= helloService interface= com.alibaba.hello.api.HelloService version= 1.0.0 / /beans [^1]: custom registry, see\uff1a registry extension","title":"Reference services from multiple registries"},{"location":"user/demos/multi-versions/","text":"Multi versions When an interface to achieve an incompatible upgrade, you can use the version number transition. Different versions of the services do not reference each other. You can follow the steps below for version migration: In the low pressure period, upgrade to half of the provider to the new version Then upgrade all consumers to the new version Then upgrade the remaining half providers to the new version Old version of the service provider configuration: dubbo:service interface= com.foo.BarService version= 1.0.0 / New version of the service provider configuration: dubbo:service interface= com.foo.BarService version= 2.0.0 / Old version of the service consumer configuration: dubbo:reference id= barService interface= com.foo.BarService version= 1.0.0 / New version of the service consumer configuration: dubbo:reference id= barService interface= com.foo.BarService version= 2.0.0 / If you do not need to distinguish between versions, can be configured as follows [^1]\uff1a dubbo:reference id= barService interface= com.foo.BarService version= * / [^1]: 2.2.0 or later support","title":"Versions"},{"location":"user/demos/multi-versions/#multi-versions","text":"When an interface to achieve an incompatible upgrade, you can use the version number transition. Different versions of the services do not reference each other. You can follow the steps below for version migration: In the low pressure period, upgrade to half of the provider to the new version Then upgrade all consumers to the new version Then upgrade the remaining half providers to the new version Old version of the service provider configuration: dubbo:service interface= com.foo.BarService version= 1.0.0 / New version of the service provider configuration: dubbo:service interface= com.foo.BarService version= 2.0.0 / Old version of the service consumer configuration: dubbo:reference id= barService interface= com.foo.BarService version= 1.0.0 / New version of the service consumer configuration: dubbo:reference id= barService interface= com.foo.BarService version= 2.0.0 / If you do not need to distinguish between versions, can be configured as follows [^1]\uff1a dubbo:reference id= barService interface= com.foo.BarService version= * / [^1]: 2.2.0 or later support","title":"Multi versions"},{"location":"user/demos/netty4/","text":"Add support for netty4 communication module in 2.5.6 version of dubbo, enabled as follows: provider\uff1a dubbo:protocol server= netty4 / or dubbo:provider server= netty4 / consumer\uff1a dubbo:consumer client= netty4 / NOTES 1. If provider need to use different communication layer framework for different protocols , please configure multiple protocols separately. 2. consumer configuration as follow\uff1a xml dubbo:consumer client=\"netty\" dubbo:reference / /dubbo:consumer xml dubbo:consumer client=\"netty4\" dubbo:reference / /dubbo:consumer Next we will continue to do something\uff1a 1. We will provide a reference data on the performance test indicators and performance test comparison with the version of netty 3.","title":"Netty4"},{"location":"user/demos/parameter-validation/","text":"Parameter Validation The parameter validation [^1] is based on [JSR303] (https://jcp.org/en/jsr/detail?id=303). The user simply add the validation annotation of the JSR303 and declares the filter for validation [^2]. Maven Dependency dependency groupId javax.validation /groupId artifactId validation-api /artifactId version 1.0.0.GA /version /dependency dependency groupId org.hibernate /groupId artifactId hibernate-validator /artifactId version 4.2.0.Final /version /dependency Sample Example of Parameter Annotation import java.io.Serializable; import java.util.Date; import javax.validation.constraints.Future; import javax.validation.constraints.Max; import javax.validation.constraints.Min; import javax.validation.constraints.NotNull; import javax.validation.constraints.Past; import javax.validation.constraints.Pattern; import javax.validation.constraints.Size; public class ValidationParameter implements Serializable { private static final long serialVersionUID = 7158911668568000392L; @NotNull // Required @Size(min = 1, max = 20) // range private String name; @NotNull(groups = ValidationService.Save.class) // It is not allowed to be blank when saving. When it is updated, it is allowed to be blank, indicating that the field is not updated @Pattern(regexp = ^\\\\s*\\\\w+(?:\\\\.{0,1}[\\\\w-]+)*@[a-zA-Z0-9]+(?:[-.][a-zA-Z0-9]+)*\\\\.[a-zA-Z]+\\\\s*$ ) private String email; @Min(18) // min value @Max(100) // max value private int age; @Past // Must be a past time private Date loginDate; @Future // Must be a future time private Date expiryDate; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Date getLoginDate() { return loginDate; } public void setLoginDate(Date loginDate) { this.loginDate = loginDate; } public Date getExpiryDate() { return expiryDate; } public void setExpiryDate(Date expiryDate) { this.expiryDate = expiryDate; } } Example of group validation public interface ValidationService { // By default, service interfaces are used to differentiate authentication scenarios. For example\uff1a@NotNull(groups = ValidationService.class) @interface Save{} // The same name as the method interface, the first letter capitalized, used to distinguish between authentication scene. For example\uff1a@NotNull(groups = ValidationService.Save.class)\uff0coption void save(ValidationParameter parameter); void update(ValidationParameter parameter); } Example of Cascading Validation import javax.validation.GroupSequence; public interface ValidationService { @GroupSequence(Update.class) // validate the Update group rules at the same time @interface Save{} void save(ValidationParameter parameter); @interface Update{} void update(ValidationParameter parameter); } Example of parameter validation import javax.validation.constraints.Min; import javax.validation.constraints.NotNull; public interface ValidationService { void save(@NotNull ValidationParameter parameter); // Param must not be null void delete(@Min(1) int id); // validate the range } Configuration Validate Parameter on the client dubbo:reference id= validationService interface= org.apache.dubbo.examples.validation.api.ValidationService validation= true / Validate Parameter on the server dubbo:service interface= org.apache.dubbo.examples.validation.api.ValidationService ref= validationService validation= true / Validate Exception import javax.validation.ConstraintViolationException; import javax.validation.ConstraintViolationException; import org.springframework.context.support.ClassPathXmlApplicationContext; import org.apache.dubbo.examples.validation.api.ValidationParameter; import org.apache.dubbo.examples.validation.api.ValidationService; import org.apache.dubbo.rpc.RpcException; public class ValidationConsumer { public static void main(String[] args) throws Exception { String config = ValidationConsumer.class.getPackage().getName().replace('.', '/') + /validation-consumer.xml ; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(config); context.start(); ValidationService validationService = (ValidationService)context.getBean( validationService ); // Error try { parameter = new ValidationParameter(); validationService.save(parameter); System.out.println( Validation ERROR ); } catch (RpcException e) { // throw RpcException ConstraintViolationException ve = (ConstraintViolationException) e.getCause(); // Inside a ConstraintViolationException Set ConstraintViolation ? violations = ve.getConstraintViolations(); // You can get the collection of validation error details System.out.println(violations); } } } [^1]: Support since 2.1.0 version. If you want to know how to use it, refer to [Sample code in dubbo project] (https://github.com/apache/dubbo-samples/tree/master/java/dubbo-samples-validation) [^2]: The validation method is extensible, refer to Developer Extension in the developer's manual.","title":"Parameter validation"},{"location":"user/demos/parameter-validation/#parameter-validation","text":"The parameter validation [^1] is based on [JSR303] (https://jcp.org/en/jsr/detail?id=303). The user simply add the validation annotation of the JSR303 and declares the filter for validation [^2].","title":"Parameter Validation"},{"location":"user/demos/parameter-validation/#maven-dependency","text":"dependency groupId javax.validation /groupId artifactId validation-api /artifactId version 1.0.0.GA /version /dependency dependency groupId org.hibernate /groupId artifactId hibernate-validator /artifactId version 4.2.0.Final /version /dependency","title":"Maven Dependency"},{"location":"user/demos/parameter-validation/#sample","text":"","title":"Sample"},{"location":"user/demos/parameter-validation/#example-of-parameter-annotation","text":"import java.io.Serializable; import java.util.Date; import javax.validation.constraints.Future; import javax.validation.constraints.Max; import javax.validation.constraints.Min; import javax.validation.constraints.NotNull; import javax.validation.constraints.Past; import javax.validation.constraints.Pattern; import javax.validation.constraints.Size; public class ValidationParameter implements Serializable { private static final long serialVersionUID = 7158911668568000392L; @NotNull // Required @Size(min = 1, max = 20) // range private String name; @NotNull(groups = ValidationService.Save.class) // It is not allowed to be blank when saving. When it is updated, it is allowed to be blank, indicating that the field is not updated @Pattern(regexp = ^\\\\s*\\\\w+(?:\\\\.{0,1}[\\\\w-]+)*@[a-zA-Z0-9]+(?:[-.][a-zA-Z0-9]+)*\\\\.[a-zA-Z]+\\\\s*$ ) private String email; @Min(18) // min value @Max(100) // max value private int age; @Past // Must be a past time private Date loginDate; @Future // Must be a future time private Date expiryDate; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Date getLoginDate() { return loginDate; } public void setLoginDate(Date loginDate) { this.loginDate = loginDate; } public Date getExpiryDate() { return expiryDate; } public void setExpiryDate(Date expiryDate) { this.expiryDate = expiryDate; } }","title":"Example of Parameter Annotation"},{"location":"user/demos/parameter-validation/#example-of-group-validation","text":"public interface ValidationService { // By default, service interfaces are used to differentiate authentication scenarios. For example\uff1a@NotNull(groups = ValidationService.class) @interface Save{} // The same name as the method interface, the first letter capitalized, used to distinguish between authentication scene. For example\uff1a@NotNull(groups = ValidationService.Save.class)\uff0coption void save(ValidationParameter parameter); void update(ValidationParameter parameter); }","title":"Example of group validation"},{"location":"user/demos/parameter-validation/#example-of-cascading-validation","text":"import javax.validation.GroupSequence; public interface ValidationService { @GroupSequence(Update.class) // validate the Update group rules at the same time @interface Save{} void save(ValidationParameter parameter); @interface Update{} void update(ValidationParameter parameter); }","title":"Example of Cascading Validation"},{"location":"user/demos/parameter-validation/#example-of-parameter-validation","text":"import javax.validation.constraints.Min; import javax.validation.constraints.NotNull; public interface ValidationService { void save(@NotNull ValidationParameter parameter); // Param must not be null void delete(@Min(1) int id); // validate the range }","title":"Example of parameter validation"},{"location":"user/demos/parameter-validation/#configuration","text":"","title":"Configuration"},{"location":"user/demos/parameter-validation/#validate-parameter-on-the-client","text":"dubbo:reference id= validationService interface= org.apache.dubbo.examples.validation.api.ValidationService validation= true /","title":"Validate Parameter on the client"},{"location":"user/demos/parameter-validation/#validate-parameter-on-the-server","text":"dubbo:service interface= org.apache.dubbo.examples.validation.api.ValidationService ref= validationService validation= true /","title":"Validate Parameter on the server"},{"location":"user/demos/parameter-validation/#validate-exception","text":"import javax.validation.ConstraintViolationException; import javax.validation.ConstraintViolationException; import org.springframework.context.support.ClassPathXmlApplicationContext; import org.apache.dubbo.examples.validation.api.ValidationParameter; import org.apache.dubbo.examples.validation.api.ValidationService; import org.apache.dubbo.rpc.RpcException; public class ValidationConsumer { public static void main(String[] args) throws Exception { String config = ValidationConsumer.class.getPackage().getName().replace('.', '/') + /validation-consumer.xml ; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(config); context.start(); ValidationService validationService = (ValidationService)context.getBean( validationService ); // Error try { parameter = new ValidationParameter(); validationService.save(parameter); System.out.println( Validation ERROR ); } catch (RpcException e) { // throw RpcException ConstraintViolationException ve = (ConstraintViolationException) e.getCause(); // Inside a ConstraintViolationException Set ConstraintViolation ? violations = ve.getConstraintViolations(); // You can get the collection of validation error details System.out.println(violations); } } } [^1]: Support since 2.1.0 version. If you want to know how to use it, refer to [Sample code in dubbo project] (https://github.com/apache/dubbo-samples/tree/master/java/dubbo-samples-validation) [^2]: The validation method is extensible, refer to Developer Extension in the developer's manual.","title":"Validate Exception"},{"location":"user/demos/preflight-check/","text":"Check on start up By default dubbo will check if the dependent service is available at startup . It will throw an exception to prevent Spring complete initialization when it is not available, so that you can find the problems early before publishing you application, the default setting: check=true . You can turn off checking by check=false . For example, some services do not care it when you run testing, or you must have one started firstly because of circular dependency. In addition, if your Spring bean is lazy-loaded or you delay reference service with API programming, turn off the check, otherwise the service will throw an exception when the service is temporarily unavailable ,then get a null reference. If you configure check=false ,you can get a reference . When the service is restored, the service can automatically reconnect. Example Use the spring configuration file Disable the startup check of a service (throw some exception/error when no provider is provided): dubbo:reference interface = com.foo.BarService check = false / Disable startup checking for all services (throw some exception/error when not provided): dubbo:consumer check = false / Disable the registration center startup check (registration subscription failed error): dubbo:registry check= false / Use dubbo.properties dubbo.reference.com.foo.BarService.check = false dubbo.reference.check = false dubbo.consumer.check = false dubbo.registry.check = false Use the -D parameter java -Ddubbo.reference.com.foo.BarService.check = false java -Ddubbo.reference.check = false java -Ddubbo.consumer.check = false java -Ddubbo.registry.check = false Configuration Meaning dubbo.reference.check=false , Change the check value of all references forcibly, even if the configuration has a declaration, it also will be overwritten. dubbo.consumer.check=false The default value of check . It will not be affected if there is an explicit declaration in the configuration such as `. dubbo.registry.check=false , The two configuration above is to express success of the subscription. If the subscription is also allowed to start when the registration fails for the provider list is empty, you need to use this configuration. The system will try again in the background regularly.","title":"Check on start"},{"location":"user/demos/preflight-check/#check-on-start-up","text":"By default dubbo will check if the dependent service is available at startup . It will throw an exception to prevent Spring complete initialization when it is not available, so that you can find the problems early before publishing you application, the default setting: check=true . You can turn off checking by check=false . For example, some services do not care it when you run testing, or you must have one started firstly because of circular dependency. In addition, if your Spring bean is lazy-loaded or you delay reference service with API programming, turn off the check, otherwise the service will throw an exception when the service is temporarily unavailable ,then get a null reference. If you configure check=false ,you can get a reference . When the service is restored, the service can automatically reconnect.","title":"Check on start up"},{"location":"user/demos/preflight-check/#example","text":"","title":"Example"},{"location":"user/demos/preflight-check/#use-the-spring-configuration-file","text":"Disable the startup check of a service (throw some exception/error when no provider is provided): dubbo:reference interface = com.foo.BarService check = false / Disable startup checking for all services (throw some exception/error when not provided): dubbo:consumer check = false / Disable the registration center startup check (registration subscription failed error): dubbo:registry check= false /","title":"Use the spring configuration file"},{"location":"user/demos/preflight-check/#use-dubboproperties","text":"dubbo.reference.com.foo.BarService.check = false dubbo.reference.check = false dubbo.consumer.check = false dubbo.registry.check = false","title":"Use dubbo.properties"},{"location":"user/demos/preflight-check/#use-the-d-parameter","text":"java -Ddubbo.reference.com.foo.BarService.check = false java -Ddubbo.reference.check = false java -Ddubbo.consumer.check = false java -Ddubbo.registry.check = false","title":"Use the -D parameter"},{"location":"user/demos/preflight-check/#configuration-meaning","text":"dubbo.reference.check=false , Change the check value of all references forcibly, even if the configuration has a declaration, it also will be overwritten. dubbo.consumer.check=false The default value of check . It will not be affected if there is an explicit declaration in the configuration such as `. dubbo.registry.check=false , The two configuration above is to express success of the subscription. If the subscription is also allowed to start when the registration fails for the provider list is empty, you need to use this configuration. The system will try again in the background regularly.","title":"Configuration Meaning"},{"location":"user/demos/reference-config-cache/","text":"ReferenceConfig Cache The instance of ReferenceConfig is heavy. It encapsulates the connection to the registry and the connection to the provider, so it need to be cached. Otherwise, repeatedly generating ReferenceConfig may cause performance problems , memory and connection leaks. This problem is easy to ignored when programming in API mode. Therefore, since 2.4.0 , dubbo provides a simple utility ReferenceConfigCache for caching instances of ReferenceConfig . Use as follows\uff1a ReferenceConfig XxxService reference = new ReferenceConfig XxxService (); reference.setInterface(XxxService.class); reference.setVersion( 1.0.0 ); ...... ReferenceConfigCache cache = ReferenceConfigCache.getCache(); // cache.get will cache the instance of Reference \uff0cand call ReferenceConfig.get method to start ReferenceConfig XxxService xxxService = cache.get(reference); // Note: Cache will hold ReferenceConfig, do not call destroy method of ReferenceConfig outside. If you do this, it will invalidate ReferenceConfig in Cache! // Use xxxService instance xxxService.sayHello(); Destroy ReferenceConfig in the Cache, it also remove ReferenceConfig and release the corresponding resources\u3002 ReferenceConfigCache cache = ReferenceConfigCache.getCache(); cache.destroy(reference); By default , ReferenceConfigCache caches one ReferenceConfig for the same service Group, interface, version. The key of ReferenceConfigCache is from the group of service Group, interface, and the version. You can modify the strategy. Define an instance of KeyGenerator, pass it as parameter of getCache method. Refer to ReferenceConfigCache for information\u3002 KeyGenerator keyGenerator = new ... ReferenceConfigCache cache = ReferenceConfigCache.getCache(keyGenerator );","title":"ReferenceConfig Cache"},{"location":"user/demos/reference-config-cache/#referenceconfig-cache","text":"The instance of ReferenceConfig is heavy. It encapsulates the connection to the registry and the connection to the provider, so it need to be cached. Otherwise, repeatedly generating ReferenceConfig may cause performance problems , memory and connection leaks. This problem is easy to ignored when programming in API mode. Therefore, since 2.4.0 , dubbo provides a simple utility ReferenceConfigCache for caching instances of ReferenceConfig . Use as follows\uff1a ReferenceConfig XxxService reference = new ReferenceConfig XxxService (); reference.setInterface(XxxService.class); reference.setVersion( 1.0.0 ); ...... ReferenceConfigCache cache = ReferenceConfigCache.getCache(); // cache.get will cache the instance of Reference \uff0cand call ReferenceConfig.get method to start ReferenceConfig XxxService xxxService = cache.get(reference); // Note: Cache will hold ReferenceConfig, do not call destroy method of ReferenceConfig outside. If you do this, it will invalidate ReferenceConfig in Cache! // Use xxxService instance xxxService.sayHello(); Destroy ReferenceConfig in the Cache, it also remove ReferenceConfig and release the corresponding resources\u3002 ReferenceConfigCache cache = ReferenceConfigCache.getCache(); cache.destroy(reference); By default , ReferenceConfigCache caches one ReferenceConfig for the same service Group, interface, version. The key of ReferenceConfigCache is from the group of service Group, interface, and the version. You can modify the strategy. Define an instance of KeyGenerator, pass it as parameter of getCache method. Refer to ReferenceConfigCache for information\u3002 KeyGenerator keyGenerator = new ... ReferenceConfigCache cache = ReferenceConfigCache.getCache(keyGenerator );","title":"ReferenceConfig Cache"},{"location":"user/demos/registry-only/","text":"Register only You have two mirroring environments, two registries. You have deployed one service at only one of the registries, another registries have not had time to deploy, and other applications at both registries need to rely on the service. At this time, the service provider registers service to another registrar, but the service consumers do not consume the service from another registrar. Disable subscription configuration dubbo:registry id= hzRegistry address= 10.20.153.10:9090 / dubbo:registry id= qdRegistry address= 10.20.141.150:9090 subscribe= false / or dubbo:registry id= hzRegistry address= 10.20.153.10:9090 / dubbo:registry id= qdRegistry address= 10.20.141.150:9090?subscribe=false /","title":"Register only"},{"location":"user/demos/registry-only/#register-only","text":"You have two mirroring environments, two registries. You have deployed one service at only one of the registries, another registries have not had time to deploy, and other applications at both registries need to rely on the service. At this time, the service provider registers service to another registrar, but the service consumers do not consume the service from another registrar. Disable subscription configuration dubbo:registry id= hzRegistry address= 10.20.153.10:9090 / dubbo:registry id= qdRegistry address= 10.20.141.150:9090 subscribe= false / or dubbo:registry id= hzRegistry address= 10.20.153.10:9090 / dubbo:registry id= qdRegistry address= 10.20.141.150:9090?subscribe=false /","title":"Register only"},{"location":"user/demos/result-cache/","text":"Cache Result Cache Result [^1] is used to speed up access to popular data. Dubbo provides declarative caching to reduce the user work of adding cache ^2 \u3002 Cache Type lru Delete excess cache Based on the principle of least recently used. The hottest data is cached. threadlocal The current thread cache. For example, a page have a lot of portal and each portal need to check user information, you can reduce this redundant visit with this cache. jcache integrate with JSR107 , you can bridge a variety of cache implementation\u3002 Caching type can be extended\uff0crefer to\uff1a Cache extension Configuration dubbo:reference interface= com.foo.BarService cache= lru / or\uff1a dubbo:reference interface= com.foo.BarService dubbo:method name= findBar cache= lru / /dubbo:reference [^1]: Support since 2.1.0","title":"Result cache"},{"location":"user/demos/result-cache/#cache-result","text":"Cache Result [^1] is used to speed up access to popular data. Dubbo provides declarative caching to reduce the user work of adding cache ^2 \u3002","title":"Cache Result"},{"location":"user/demos/result-cache/#cache-type","text":"lru Delete excess cache Based on the principle of least recently used. The hottest data is cached. threadlocal The current thread cache. For example, a page have a lot of portal and each portal need to check user information, you can reduce this redundant visit with this cache. jcache integrate with JSR107 , you can bridge a variety of cache implementation\u3002 Caching type can be extended\uff0crefer to\uff1a Cache extension","title":"Cache Type"},{"location":"user/demos/result-cache/#configuration","text":"dubbo:reference interface= com.foo.BarService cache= lru / or\uff1a dubbo:reference interface= com.foo.BarService dubbo:method name= findBar cache= lru / /dubbo:reference [^1]: Support since 2.1.0","title":"Configuration"},{"location":"user/demos/routing-rule/","text":"Routing Rules The routing rules [^1] determine the target server of one service call. It has two kinds of routing rules: conditional routing rules and script routing rules. It also support extension[^2]. Write Routing Rules Writing routing rules to the registry is usually done by the monitoring center or the console page. RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf( zookeeper://10.20.153.10:2181 )); registry.register(URL.valueOf( route://0.0.0.0/com.foo.BarService?category=routers dynamic=false rule= + URL.encode( host = 10.20.153.10 = host = 10.20.153.11 ))); \u5176\u4e2d\uff1a route:// It indicates the type of routing rules, supports routing rules and script routing rules, and can be extended. Required \u3002 0.0.0.0 It indicates that all IP addresses are valid. If you want to take effect for only one IP address, fill in the IP address. Required \u3002 com.foo.BarService It indicates that the specified service is effective. Required \u3002 group=foo It indicates that the specified service in specified group is effective. When absent, the specified service which dosen't configure group is effective. version=1.0 It indicates that the specified service in specified version is effective. When absent, the specified service which dosen't configure version is effective. category=routers It indicates that the data is a dynamic configuration type. Required \u3002 dynamic=false It indicates that it is persistent data. When the registrant exits, the data is still stored in the registry. Required \u3002 enabled=true It indicates whether this routing rules is effective. Option, and default effective. force=false It indicates whether it is forced to be executed when the routing result is null. If it is not enforced, the route will be automatically invalidated. Option, and default false . runtime=false It indicates whether to execute routing rules at every call. If not, the result is only pre-executed and cached when the provider's address list changes. It will get routing result from cache when the service is invoked. If you use parameter routing, you must to configure it as true . Be careful that the configuration will affect the performance. Option, and default false . priority=1 The priority of the routing rules. it is used for sorting, the greater the priority, the more front execution. Option, and default 0 \u3002 rule=URL.encode(\"host = 10.20.153.10 = host = 10.20.153.11\") It indicates the content of routing rule\uff0c Required \u3002 Conditional routing rules Routing rules based on conditional expressions, such as\uff1a host = 10.20.153.10 = host = 10.20.153.11 Rules\uff1a The previous of = is matched condition for consumer. All parameters compare with URL of consumers. When the consumer meet the condition, it will continue to execute the behind filter rules for consumer. After the = aims to filter the provider address list. All the parameters are compared against the provider's URL, and consumer get only the filtered address list at finally. If the previous condition for consumer is empty, it means all consumers can matched. such as : = host != 10.20.153.11 If the filter condition for provider is empty, it means it is forbidden to visit. such as : host = 10.20.153.10 = Expressions\uff1a Parameter Support\uff1a Service call information, such as: method, argument etc. Parameter routing is currently not supported URL field (On URL own), such as: protocol, host, port etc. All parameters on the URL. such as: application, organization etc. Condition Support\uff1a Equal sign = indicates match. such as: host = 10.20.153.10 Not equal sign != indicates \"does not match\". such as: host != 10.20.153.10 . Value Support\uff1a Separate multiple values with a comma , . Such as\uff1a host != 10.20.153.10,10.20.153.11 End with * to indicate wildcard. Such as\uff1a host != 10.20.* Start with $ to indicate reference to consumer parameters. Such as: host = $host Samples Exclude pre-release machine\uff1a = host != 172.22.3.91 1. Whitelist [^3]\uff1a host != 10.20.153.10,10.20.153.11 = 2. Blacklist\uff1a host = 10.20.153.10,10.20.153.11 = 3. Service boarding application only expose part of the machine to prevent the entire cluster hanging up: = host = 172.22.3.1*,172.22.3.2* 4. Additional machines for important applications\uff1a application != kylin = host != 172.22.3.95,172.22.3.96 5. Read and write separation\uff1a method = find*,list*,get*,is* = host = 172.22.3.94,172.22.3.95,172.22.3.96 method != find*,list*,get*,is* = host = 172.22.3.97,172.22.3.98 Separation of Front and Background Application\uff1a application = bops = host = 172.22.3.91,172.22.3.92,172.22.3.93 application != bops = host = 172.22.3.94,172.22.3.95,172.22.3.96 Isolate different network segments\uff1a host != 172.22.3.* = host != 172.22.3.* Providers and consumers deployed in the same cluster, the machine only visit the local service\uff1a = host = $host Script routing rules Script routing rules [^4] support all scripts of JDK script engine. such as: javascript, jruby, groovy, etc. Configure the script type by type=javascript , the default is javascript. script://0.0.0.0/com.foo.BarService?category=routers dynamic=false rule= + URL.encode( (function route(invokers) { ... } (invokers)) ) Routing rules that base on script engine is as follow\uff1a (function route(invokers) { var result = new java.util.ArrayList(invokers.size()); for (i = 0; i invokers.size(); i ++) { if ( 10.20.153.10 .equals(invokers.get(i).getUrl().getHost())) { result.add(invokers.get(i)); } } return result; } (invokers)); // Indicates that the method is executed immediately Tag routing rules Tag routing rules [^5] , when the application configures the TagRouter , a tagged dubbo invocation can intelligently route to the service provider which has the corresponding tag. Provider configure TagRouter for the application @Bean public ApplicationConfig applicationConfig() { ApplicationConfig applicationConfig = new ApplicationConfig(); applicationConfig.setName( provider-book ); applicationConfig.setQosEnable(false); // instruct tag router Map String,String parameters = new HashMap (); parameters.put(Constants.ROUTER_KEY, tag ); applicationConfig.setParameters(parameters); return applicationConfig; } configure specfic tag for the provider @Bean public ProviderConfig providerConfig(){ ProviderConfig providerConfig = new ProviderConfig(); providerConfig.setTag( red ); return providerConfig; } The application which configures no tag will be considered as the default application, and these default apps will be treated as downgrades when the invocation fails to match the provider. Consumer RpcContext.getContext().setAttachment(Constants.REQUEST_TAG_KEY, red ); The scope of the request.tag is for each invocation, using the attachment to pass the request tag. Note that the value stored in the attachment will be passed continuously in a complete remote invocation, thanks to this feature, we only need to set the tag at the beginning of a invocation. Currently, only hardcoding is supported to set requestTag. Note that RpcContext is thread-bound, elegantly using the TagRouter feature, it is recommended to set the request tag via a servlet filter (in the web environment) or a custom dubbo SPI filter. Rules: request.tag=red will firstlt choose the provider which configures as tag=red . If there is no service corresponding to the request tag in the cluster, it will downgrade to tag=null provider, seen as default provider\u3002 when request.tag=null , only tag=null provider will be matched. Even if there are services available in the cluster, the tags do not match, they cannot be called. This is different from rule 1. Tagged invocation can be downgraded to untagged services, but invocations that do not carry tags/carry other types of tags can never be accessed other tag services. [^1]: Support since 2.2.0 [^2]: Routing Rules Extension Point: Route Extension [^3]: Note: A service can only have one whitelist rule, otherwise the two rules will be filtered out. [^4]: Note: Scripts have no sandbox constraints, can execute arbitrary code, and poses a backdoor risk. [^5]: Support since 2.7.0","title":"Routing rule"},{"location":"user/demos/routing-rule/#routing-rules","text":"The routing rules [^1] determine the target server of one service call. It has two kinds of routing rules: conditional routing rules and script routing rules. It also support extension[^2].","title":"Routing Rules"},{"location":"user/demos/routing-rule/#write-routing-rules","text":"Writing routing rules to the registry is usually done by the monitoring center or the console page. RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf( zookeeper://10.20.153.10:2181 )); registry.register(URL.valueOf( route://0.0.0.0/com.foo.BarService?category=routers dynamic=false rule= + URL.encode( host = 10.20.153.10 = host = 10.20.153.11 ))); \u5176\u4e2d\uff1a route:// It indicates the type of routing rules, supports routing rules and script routing rules, and can be extended. Required \u3002 0.0.0.0 It indicates that all IP addresses are valid. If you want to take effect for only one IP address, fill in the IP address. Required \u3002 com.foo.BarService It indicates that the specified service is effective. Required \u3002 group=foo It indicates that the specified service in specified group is effective. When absent, the specified service which dosen't configure group is effective. version=1.0 It indicates that the specified service in specified version is effective. When absent, the specified service which dosen't configure version is effective. category=routers It indicates that the data is a dynamic configuration type. Required \u3002 dynamic=false It indicates that it is persistent data. When the registrant exits, the data is still stored in the registry. Required \u3002 enabled=true It indicates whether this routing rules is effective. Option, and default effective. force=false It indicates whether it is forced to be executed when the routing result is null. If it is not enforced, the route will be automatically invalidated. Option, and default false . runtime=false It indicates whether to execute routing rules at every call. If not, the result is only pre-executed and cached when the provider's address list changes. It will get routing result from cache when the service is invoked. If you use parameter routing, you must to configure it as true . Be careful that the configuration will affect the performance. Option, and default false . priority=1 The priority of the routing rules. it is used for sorting, the greater the priority, the more front execution. Option, and default 0 \u3002 rule=URL.encode(\"host = 10.20.153.10 = host = 10.20.153.11\") It indicates the content of routing rule\uff0c Required \u3002","title":"Write Routing Rules"},{"location":"user/demos/routing-rule/#conditional-routing-rules","text":"Routing rules based on conditional expressions, such as\uff1a host = 10.20.153.10 = host = 10.20.153.11","title":"Conditional routing rules"},{"location":"user/demos/routing-rule/#rules","text":"The previous of = is matched condition for consumer. All parameters compare with URL of consumers. When the consumer meet the condition, it will continue to execute the behind filter rules for consumer. After the = aims to filter the provider address list. All the parameters are compared against the provider's URL, and consumer get only the filtered address list at finally. If the previous condition for consumer is empty, it means all consumers can matched. such as : = host != 10.20.153.11 If the filter condition for provider is empty, it means it is forbidden to visit. such as : host = 10.20.153.10 =","title":"Rules\uff1a"},{"location":"user/demos/routing-rule/#expressions","text":"Parameter Support\uff1a Service call information, such as: method, argument etc. Parameter routing is currently not supported URL field (On URL own), such as: protocol, host, port etc. All parameters on the URL. such as: application, organization etc. Condition Support\uff1a Equal sign = indicates match. such as: host = 10.20.153.10 Not equal sign != indicates \"does not match\". such as: host != 10.20.153.10 . Value Support\uff1a Separate multiple values with a comma , . Such as\uff1a host != 10.20.153.10,10.20.153.11 End with * to indicate wildcard. Such as\uff1a host != 10.20.* Start with $ to indicate reference to consumer parameters. Such as: host = $host","title":"Expressions\uff1a"},{"location":"user/demos/routing-rule/#samples","text":"Exclude pre-release machine\uff1a = host != 172.22.3.91 1. Whitelist [^3]\uff1a host != 10.20.153.10,10.20.153.11 = 2. Blacklist\uff1a host = 10.20.153.10,10.20.153.11 = 3. Service boarding application only expose part of the machine to prevent the entire cluster hanging up: = host = 172.22.3.1*,172.22.3.2* 4. Additional machines for important applications\uff1a application != kylin = host != 172.22.3.95,172.22.3.96 5. Read and write separation\uff1a method = find*,list*,get*,is* = host = 172.22.3.94,172.22.3.95,172.22.3.96 method != find*,list*,get*,is* = host = 172.22.3.97,172.22.3.98 Separation of Front and Background Application\uff1a application = bops = host = 172.22.3.91,172.22.3.92,172.22.3.93 application != bops = host = 172.22.3.94,172.22.3.95,172.22.3.96 Isolate different network segments\uff1a host != 172.22.3.* = host != 172.22.3.* Providers and consumers deployed in the same cluster, the machine only visit the local service\uff1a = host = $host","title":"Samples"},{"location":"user/demos/routing-rule/#script-routing-rules","text":"Script routing rules [^4] support all scripts of JDK script engine. such as: javascript, jruby, groovy, etc. Configure the script type by type=javascript , the default is javascript. script://0.0.0.0/com.foo.BarService?category=routers dynamic=false rule= + URL.encode( (function route(invokers) { ... } (invokers)) ) Routing rules that base on script engine is as follow\uff1a (function route(invokers) { var result = new java.util.ArrayList(invokers.size()); for (i = 0; i invokers.size(); i ++) { if ( 10.20.153.10 .equals(invokers.get(i).getUrl().getHost())) { result.add(invokers.get(i)); } } return result; } (invokers)); // Indicates that the method is executed immediately","title":"Script routing rules"},{"location":"user/demos/routing-rule/#tag-routing-rules","text":"Tag routing rules [^5] , when the application configures the TagRouter , a tagged dubbo invocation can intelligently route to the service provider which has the corresponding tag.","title":"Tag routing rules"},{"location":"user/demos/routing-rule/#provider","text":"configure TagRouter for the application @Bean public ApplicationConfig applicationConfig() { ApplicationConfig applicationConfig = new ApplicationConfig(); applicationConfig.setName( provider-book ); applicationConfig.setQosEnable(false); // instruct tag router Map String,String parameters = new HashMap (); parameters.put(Constants.ROUTER_KEY, tag ); applicationConfig.setParameters(parameters); return applicationConfig; } configure specfic tag for the provider @Bean public ProviderConfig providerConfig(){ ProviderConfig providerConfig = new ProviderConfig(); providerConfig.setTag( red ); return providerConfig; } The application which configures no tag will be considered as the default application, and these default apps will be treated as downgrades when the invocation fails to match the provider.","title":"Provider"},{"location":"user/demos/routing-rule/#consumer","text":"RpcContext.getContext().setAttachment(Constants.REQUEST_TAG_KEY, red ); The scope of the request.tag is for each invocation, using the attachment to pass the request tag. Note that the value stored in the attachment will be passed continuously in a complete remote invocation, thanks to this feature, we only need to set the tag at the beginning of a invocation. Currently, only hardcoding is supported to set requestTag. Note that RpcContext is thread-bound, elegantly using the TagRouter feature, it is recommended to set the request tag via a servlet filter (in the web environment) or a custom dubbo SPI filter.","title":"Consumer"},{"location":"user/demos/routing-rule/#rules_1","text":"request.tag=red will firstlt choose the provider which configures as tag=red . If there is no service corresponding to the request tag in the cluster, it will downgrade to tag=null provider, seen as default provider\u3002 when request.tag=null , only tag=null provider will be matched. Even if there are services available in the cluster, the tags do not match, they cannot be called. This is different from rule 1. Tagged invocation can be downgraded to untagged services, but invocations that do not carry tags/carry other types of tags can never be accessed other tag services. [^1]: Support since 2.2.0 [^2]: Routing Rules Extension Point: Route Extension [^3]: Note: A service can only have one whitelist rule, otherwise the two rules will be filtered out. [^4]: Note: Scripts have no sandbox constraints, can execute arbitrary code, and poses a backdoor risk. [^5]: Support since 2.7.0","title":"Rules:"},{"location":"user/demos/serialization/","text":"Using Efficient Java Serialization in Dubbo (Kryo and FST) Start Kryo and FST Using Kryo and FST is very simple, just add an attribute to the dubbo RPC XML configurition: dubbo:protocol name= dubbo serialization= kryo / dubbo:protocol name= dubbo serialization= fst / Register serialized class For releasing the high ability of Kryo and FST, it's best to register the classes that need serializing into the dubbo system. For example, we can implement the following callback interface: public class SerializationOptimizerImpl implements SerializationOptimizer { public Collection Class getSerializableClasses() { List Class classes = new LinkedList Class (); classes.add(BidRequest.class); classes.add(BidResponse.class); classes.add(Device.class); classes.add(Geo.class); classes.add(Impression.class); classes.add(SeatBid.class); return classes; } } Then add in the XML configuration: dubbo:protocol name= dubbo serialization= kryo optimizer= org.apache.dubbo.demo.SerializationOptimizerImpl / After registering these classes, serialization performance can be greatly improved, especially for small numbers of nested objects. Of course, when serializing a class, you might also cascade references to many classes, such as Java collection classes. In this case, we've automatically registered common classes in the JDK, so you don't need to register them repeatedly (and of course, it doesn't matter if you register them again), including: GregorianCalendar InvocationHandler BigDecimal BigInteger Pattern BitSet URI UUID HashMap ArrayList LinkedList HashSet TreeSet Hashtable Date Calendar ConcurrentHashMap SimpleDateFormat Vector BitSet StringBuffer StringBuilder Object Object[] String[] byte[] char[] int[] float[] double[] Since registering serialized classes is only for performance optimization purposes, it doesn't matter if you forget to register some classes. In fact, Kryo and FST generally perform better than Hessian and Dubbo serializations even if no classes are registered.","title":"Kryo&FST serialization"},{"location":"user/demos/serialization/#using-efficient-java-serialization-in-dubbo-kryo-and-fst","text":"","title":"Using Efficient Java Serialization in Dubbo (Kryo and FST)"},{"location":"user/demos/serialization/#start-kryo-and-fst","text":"Using Kryo and FST is very simple, just add an attribute to the dubbo RPC XML configurition: dubbo:protocol name= dubbo serialization= kryo / dubbo:protocol name= dubbo serialization= fst /","title":"Start Kryo and FST"},{"location":"user/demos/serialization/#register-serialized-class","text":"For releasing the high ability of Kryo and FST, it's best to register the classes that need serializing into the dubbo system. For example, we can implement the following callback interface: public class SerializationOptimizerImpl implements SerializationOptimizer { public Collection Class getSerializableClasses() { List Class classes = new LinkedList Class (); classes.add(BidRequest.class); classes.add(BidResponse.class); classes.add(Device.class); classes.add(Geo.class); classes.add(Impression.class); classes.add(SeatBid.class); return classes; } } Then add in the XML configuration: dubbo:protocol name= dubbo serialization= kryo optimizer= org.apache.dubbo.demo.SerializationOptimizerImpl / After registering these classes, serialization performance can be greatly improved, especially for small numbers of nested objects. Of course, when serializing a class, you might also cascade references to many classes, such as Java collection classes. In this case, we've automatically registered common classes in the JDK, so you don't need to register them repeatedly (and of course, it doesn't matter if you register them again), including: GregorianCalendar InvocationHandler BigDecimal BigInteger Pattern BitSet URI UUID HashMap ArrayList LinkedList HashSet TreeSet Hashtable Date Calendar ConcurrentHashMap SimpleDateFormat Vector BitSet StringBuffer StringBuilder Object Object[] String[] byte[] char[] int[] float[] double[] Since registering serialized classes is only for performance optimization purposes, it doesn't matter if you forget to register some classes. In fact, Kryo and FST generally perform better than Hessian and Dubbo serializations even if no classes are registered.","title":"Register serialized class"},{"location":"user/demos/service-container/","text":"Service container The service container is a standalone launcher because the backend service does not require the functionality of a Web container ,such as Tomcat or JBoss. If you insist on using web containers to load service providers, that increase complexity and is waste of resources. The service container is just a simple Main method and loads a simple Spring container to expose the service. The content of Service container can be extended, built-in spring, jetty, log4j etc.. This can be expanded with Container Extension Points . Configure it with the -D parameter in the java command or dubbo.properties . Container type Spring Container Automatically load all spring configurations in the META-INF/spring . properties dubbo.spring.config=classpath*:META-INF/spring/*.xml Jetty Container Start an embedded Jetty for reporting status. Configure: dubbo.jetty.port=8080 : configure jetty start up port dubbo.jetty.directory=/foo/bar : static file that can be visited by jetty directly. dubbo.jetty.page=log,status,system : configure the displayed page, loading all pages by default Log4j Container Automatic configuration log4j configuration. At the start of the multi-process, log files automatically by process sub-directory. Configure: dubbo.log4j.file=/foo/bar.log : configure log file path dubbo.log4j.level=WARN : configure log level dubbo.log4j.subdirectory=20880 : configure log sub directory for multi-process startup and avoiding conflict Container startup load spring by default. java org.apache.dubbo.container.Main Load the container that passed in by the main method java org.apache.dubbo.container.Main spring jetty log4j Load the container that passed in by the JVM option. java org.apache.dubbo.container.Main -Ddubbo.container=spring,jetty,log4j Load the container that passed in by dubbo.properties in the classpath. dubbo.container=spring,jetty,log4j","title":"Container"},{"location":"user/demos/service-container/#service-container","text":"The service container is a standalone launcher because the backend service does not require the functionality of a Web container ,such as Tomcat or JBoss. If you insist on using web containers to load service providers, that increase complexity and is waste of resources. The service container is just a simple Main method and loads a simple Spring container to expose the service. The content of Service container can be extended, built-in spring, jetty, log4j etc.. This can be expanded with Container Extension Points . Configure it with the -D parameter in the java command or dubbo.properties .","title":"Service container"},{"location":"user/demos/service-container/#container-type","text":"","title":"Container type"},{"location":"user/demos/service-container/#spring-container","text":"Automatically load all spring configurations in the META-INF/spring . properties dubbo.spring.config=classpath*:META-INF/spring/*.xml","title":"Spring Container"},{"location":"user/demos/service-container/#jetty-container","text":"Start an embedded Jetty for reporting status. Configure: dubbo.jetty.port=8080 : configure jetty start up port dubbo.jetty.directory=/foo/bar : static file that can be visited by jetty directly. dubbo.jetty.page=log,status,system : configure the displayed page, loading all pages by default","title":"Jetty Container"},{"location":"user/demos/service-container/#log4j-container","text":"Automatic configuration log4j configuration. At the start of the multi-process, log files automatically by process sub-directory. Configure: dubbo.log4j.file=/foo/bar.log : configure log file path dubbo.log4j.level=WARN : configure log level dubbo.log4j.subdirectory=20880 : configure log sub directory for multi-process startup and avoiding conflict","title":"Log4j Container"},{"location":"user/demos/service-container/#container-startup","text":"load spring by default. java org.apache.dubbo.container.Main Load the container that passed in by the main method java org.apache.dubbo.container.Main spring jetty log4j Load the container that passed in by the JVM option. java org.apache.dubbo.container.Main -Ddubbo.container=spring,jetty,log4j Load the container that passed in by dubbo.properties in the classpath. dubbo.container=spring,jetty,log4j","title":"Container startup"},{"location":"user/demos/service-downgrade/","text":"Service-Downgrade You can temporarilly shield a non-critical service through the service downgrade and define the return policy for it. Publish dynamic configuration rule to the registry: RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf( zookeeper://10.20.153.10:2181 )); registry.register(URL.valueOf( override://0.0.0.0/com.foo.BarService?category=configurators dynamic=false application=foo mock=force:return+null )); The configuration mock=force:return+null means that all calls of this service will return null value directly,without making remote calls.Usually used to reduce the effect of some slow non-critical services. Also you can change that configuration to mock=fail:return+null .Then you will get null value after a failed call.Consumer will try to make a remote call to get the truely result if succeed,and if the call failed you will get null value.Usually used to tolerate some non-critical services. [^1]: supported after version 2.2.0","title":"Service downgrade"},{"location":"user/demos/service-downgrade/#service-downgrade","text":"You can temporarilly shield a non-critical service through the service downgrade and define the return policy for it. Publish dynamic configuration rule to the registry: RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf( zookeeper://10.20.153.10:2181 )); registry.register(URL.valueOf( override://0.0.0.0/com.foo.BarService?category=configurators dynamic=false application=foo mock=force:return+null )); The configuration mock=force:return+null means that all calls of this service will return null value directly,without making remote calls.Usually used to reduce the effect of some slow non-critical services. Also you can change that configuration to mock=fail:return+null .Then you will get null value after a failed call.Consumer will try to make a remote call to get the truely result if succeed,and if the call failed you will get null value.Usually used to tolerate some non-critical services. [^1]: supported after version 2.2.0","title":"Service-Downgrade"},{"location":"user/demos/service-group/","text":"Service Group When you have multi-impls of a interface,you can distinguish them with the group. Service dubbo:service group= feedback interface= com.xxx.IndexService / dubbo:service group= member interface= com.xxx.IndexService / Reference dubbo:reference id= feedbackIndexService group= feedback interface= com.xxx.IndexService / dubbo:reference id= memberIndexService group= member interface= com.xxx.IndewxService / Any group [^1]\uff1a dubbo:reference id= barService interface= com.foo.BarService group= * / [^1]: supported after version 2.2.0 ,always select only one available group of implementations to invoke.","title":"Grouping"},{"location":"user/demos/service-group/#service-group","text":"When you have multi-impls of a interface,you can distinguish them with the group.","title":"Service Group"},{"location":"user/demos/service-group/#service","text":"dubbo:service group= feedback interface= com.xxx.IndexService / dubbo:service group= member interface= com.xxx.IndexService /","title":"Service"},{"location":"user/demos/service-group/#reference","text":"dubbo:reference id= feedbackIndexService group= feedback interface= com.xxx.IndexService / dubbo:reference id= memberIndexService group= member interface= com.xxx.IndewxService / Any group [^1]\uff1a dubbo:reference id= barService interface= com.foo.BarService group= * / [^1]: supported after version 2.2.0 ,always select only one available group of implementations to invoke.","title":"Reference"},{"location":"user/demos/static-service/","text":"Static Service Sometimes we want to manually manage the registration and deregistration for service provider, we need to set registry to non-dynamoic mode. dubbo:registry address= 10.20.141.150:9090 dynamic= false / Or dubbo:registry address= 10.20.141.150:9090?dynamic=false / dynamic mode is disabled when service provider initially registers, then we need to enable it manually. When disconnects, the setting will not be deleted automatically, need to disable it manually. For a third party service provider like \u201cmemcachd\u201d, it can directly write the address information of service provider to registry, which can be used by consumer. RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf( zookeeper://10.20.153.10:2181 )); registry.register(URL.valueOf( memcached://10.20.153.11/com.foo.BarService?category=providers dynamic=false application=foo )); [^1]: usually called by monitor system","title":"Static service"},{"location":"user/demos/static-service/#static-service","text":"Sometimes we want to manually manage the registration and deregistration for service provider, we need to set registry to non-dynamoic mode. dubbo:registry address= 10.20.141.150:9090 dynamic= false / Or dubbo:registry address= 10.20.141.150:9090?dynamic=false / dynamic mode is disabled when service provider initially registers, then we need to enable it manually. When disconnects, the setting will not be deleted automatically, need to disable it manually. For a third party service provider like \u201cmemcachd\u201d, it can directly write the address information of service provider to registry, which can be used by consumer. RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf( zookeeper://10.20.153.10:2181 )); registry.register(URL.valueOf( memcached://10.20.153.11/com.foo.BarService?category=providers dynamic=false application=foo )); [^1]: usually called by monitor system","title":"Static Service"},{"location":"user/demos/stickiness/","text":"stickiness Sticky connections are used for stateful services, as much as possible so that clients always make calls to the same provider, unless the provider hangs up and connects to the other one. Sticky connections will automatically open Delayed Connections to reduce the number of long connections. dubbo:reference id= xxxService interface= com.xxx.XxxService sticky= true / Dubbo supports method-level sticky connection, and if you want more granular control, you can also configure as follow. dubbo:reference id= xxxService interface= com.xxx.XxxService dubbo:mothod name= sayHello sticky= true / /dubbo:reference","title":"Stickness connection"},{"location":"user/demos/stickiness/#stickiness","text":"Sticky connections are used for stateful services, as much as possible so that clients always make calls to the same provider, unless the provider hangs up and connects to the other one. Sticky connections will automatically open Delayed Connections to reduce the number of long connections. dubbo:reference id= xxxService interface= com.xxx.XxxService sticky= true / Dubbo supports method-level sticky connection, and if you want more granular control, you can also configure as follow. dubbo:reference id= xxxService interface= com.xxx.XxxService dubbo:mothod name= sayHello sticky= true / /dubbo:reference","title":"stickiness"},{"location":"user/demos/subscribe-only/","text":"Subscribe only To facilitate the development of tests, it is common to have a registry of all services available in develop environment.And the registration of a service provider under development may affect consumers' inability to run. You can let service provider developers only subscribe to services only (services developed may rely on other services) ,don't register services under development and testing services under development with directly connection. User configuration: dubbo:registry address= 10.20.153.10:9090 register= false / or dubbo:registry address= 10.20.153.10:9090?register=false /","title":"Subscribe only"},{"location":"user/demos/subscribe-only/#subscribe-only","text":"To facilitate the development of tests, it is common to have a registry of all services available in develop environment.And the registration of a service provider under development may affect consumers' inability to run. You can let service provider developers only subscribe to services only (services developed may rely on other services) ,don't register services under development and testing services under development with directly connection. User configuration: dubbo:registry address= 10.20.153.10:9090 register= false / or dubbo:registry address= 10.20.153.10:9090?register=false /","title":"Subscribe only"},{"location":"user/demos/thread-model/","text":"Thread Model Thread Model If events handing can be executed quickly without sending new request like marking in memory. Events should be handled by I/O thread since it reduces thread dispatching. If event handling will be executed slowly or needs to send new I/O request like querying from database, events should be handled in thread pool. Otherwise, I/O thread will be blocked and then will be not able to receive requests. If events are handled by I/O thread, and send new I/O requests during the handling like sending a l login request during connect event, it will alert with \u201cPotentially leading to deadlock\u201d, but deadlock will not happen actually. Thus, we need different dispatch strategies and different thread pool configurations to face difference scenarios. dubbo:protocol name= dubbo dispatcher= all threadpool= fixed threads= 100 / Dispatcher all: All messages will be dispatched to thread pool, including request, response, connect event, disconnect event and heartbeat. direct: All messages will not be dispatched to thread pool and will be executed directly by I/O thread. message: Only request, response messages will be dispatched to I/O thread. Other messages like disconnect, connect, heartbeat messages will be executed by I/O thread. execution: Only request message will be dispatched to thread pool. Other messages like response, connect, disconnect, heartbeat will be directly executed by I/O thread. connection: I/O thread will put disconnect and connect events in the queue and execute them sequentially, other messages will be dispatched to the thread pool. Thread pool fixed: A fixed size of thread pool. It creates threads when starts, never shut down.\uff08default). cached: A cached thread pool. Automatically delete the thread when it\u2019s in idle for one minute. Recreate when needed. limit: elastic thread pool. But it can only increase the size of the thread pool. The reason is to avoid performance issue caused by traffic spike when decrease the size of the thread pool.","title":"Thread model"},{"location":"user/demos/thread-model/#thread-model","text":"","title":"Thread Model"},{"location":"user/demos/thread-model/#thread-model_1","text":"If events handing can be executed quickly without sending new request like marking in memory. Events should be handled by I/O thread since it reduces thread dispatching. If event handling will be executed slowly or needs to send new I/O request like querying from database, events should be handled in thread pool. Otherwise, I/O thread will be blocked and then will be not able to receive requests. If events are handled by I/O thread, and send new I/O requests during the handling like sending a l login request during connect event, it will alert with \u201cPotentially leading to deadlock\u201d, but deadlock will not happen actually. Thus, we need different dispatch strategies and different thread pool configurations to face difference scenarios. dubbo:protocol name= dubbo dispatcher= all threadpool= fixed threads= 100 /","title":"Thread Model"},{"location":"user/demos/thread-model/#dispatcher","text":"all: All messages will be dispatched to thread pool, including request, response, connect event, disconnect event and heartbeat. direct: All messages will not be dispatched to thread pool and will be executed directly by I/O thread. message: Only request, response messages will be dispatched to I/O thread. Other messages like disconnect, connect, heartbeat messages will be executed by I/O thread. execution: Only request message will be dispatched to thread pool. Other messages like response, connect, disconnect, heartbeat will be directly executed by I/O thread. connection: I/O thread will put disconnect and connect events in the queue and execute them sequentially, other messages will be dispatched to the thread pool.","title":"Dispatcher"},{"location":"user/demos/thread-model/#thread-pool","text":"fixed: A fixed size of thread pool. It creates threads when starts, never shut down.\uff08default). cached: A cached thread pool. Automatically delete the thread when it\u2019s in idle for one minute. Recreate when needed. limit: elastic thread pool. But it can only increase the size of the thread pool. The reason is to avoid performance issue caused by traffic spike when decrease the size of the thread pool.","title":"Thread pool"},{"location":"user/demos/token-authorization/","text":"Token Authorization Through the token authorization control center at the registry to decide whether to issue tokens to consumers, you can prevent consumers from bypassing the registry access provider, another through the registry can flexibly change the authorization without modification or upgrade provider You can turn on token authentication globally: !--Random token , generated using a UUID-- dubbo:provider interface= com.foo.BarService token= true / or !--Fixed token, equivalent to the password-- dubbo:provider interface= com.foo.BarService token= 123456 / Of course can turn on token authentication at service level: !--Random token , generated using a UUID-- dubbo:service interface= com.foo.BarService token= true / or !--Fixed token, equivalent to the password-- dubbo:service interface= com.foo.BarService token= 123456 / Also can turn on token authentication at protocol level: !--Random token , generated using a UUID-- dubbo:protocol name= dubbo token= true / or !--Fixed token, equivalent to the password-- dubbo:protocol name= dubbo token= 123456 /","title":"Token authorization"},{"location":"user/demos/token-authorization/#token-authorization","text":"Through the token authorization control center at the registry to decide whether to issue tokens to consumers, you can prevent consumers from bypassing the registry access provider, another through the registry can flexibly change the authorization without modification or upgrade provider You can turn on token authentication globally: !--Random token , generated using a UUID-- dubbo:provider interface= com.foo.BarService token= true / or !--Fixed token, equivalent to the password-- dubbo:provider interface= com.foo.BarService token= 123456 / Of course can turn on token authentication at service level: !--Random token , generated using a UUID-- dubbo:service interface= com.foo.BarService token= true / or !--Fixed token, equivalent to the password-- dubbo:service interface= com.foo.BarService token= 123456 / Also can turn on token authentication at protocol level: !--Random token , generated using a UUID-- dubbo:protocol name= dubbo token= true / or !--Fixed token, equivalent to the password-- dubbo:protocol name= dubbo token= 123456 /","title":"Token Authorization"},{"location":"user/languages/erlang/reference/","text":"Consumer Configurations Base Config Consumer config is under the dubboerl application with sys.config {dubboerl,[ %% other config ... {consumer,[ { interface fullname ,[Option]}, %% eg: { org.apache.dubbo.erlang.sample.service.facade.UserOperator ,[]}, ]} ]} Option is to be added.","title":"Consumer Configurations"},{"location":"user/languages/erlang/reference/#consumer-configurations","text":"","title":"Consumer Configurations"},{"location":"user/languages/erlang/reference/#base-config","text":"Consumer config is under the dubboerl application with sys.config {dubboerl,[ %% other config ... {consumer,[ { interface fullname ,[Option]}, %% eg: { org.apache.dubbo.erlang.sample.service.facade.UserOperator ,[]}, ]} ]} Option is to be added.","title":"Base Config"},{"location":"user/languages/erlang/serialization/","text":"Protocol Configurations The library now only supports hessian and json serialization. Configuration example Protocol config is under the dubboerl application with sys.config {dubboerl,[ %% other config ... {protocol,hessian} ]} ConfigName Type DefaultValue Remarks protocol atom() hessian hessian,json","title":"Protocol Configurations"},{"location":"user/languages/erlang/serialization/#protocol-configurations","text":"The library now only supports hessian and json serialization.","title":"Protocol Configurations"},{"location":"user/languages/erlang/serialization/#configuration-example","text":"Protocol config is under the dubboerl application with sys.config {dubboerl,[ %% other config ... {protocol,hessian} ]} ConfigName Type DefaultValue Remarks protocol atom() hessian hessian,json","title":"Configuration example"},{"location":"user/languages/erlang/service/","text":"Provider Configurations Base Config Provider config is under the dubboerl application with sys.config {dubboerl,[ %% other config ... {provider,[ {module_implements,interface_module,interface_fullname,[Options]}, %% eg: {userOperator_impl,userOperator, org.apache.dubbo.erlang.sample.service.facade.UserOperator ,[Option]} ]} ]} ConfigName Type DefaultValue Remarks module_implements atom() - The service implements module name interface_module atom() - Interface module name is transfer form java jar interface_fullname binary() - Interface full name is the java class name Option is to be added.","title":"Provider Configurations"},{"location":"user/languages/erlang/service/#provider-configurations","text":"","title":"Provider Configurations"},{"location":"user/languages/erlang/service/#base-config","text":"Provider config is under the dubboerl application with sys.config {dubboerl,[ %% other config ... {provider,[ {module_implements,interface_module,interface_fullname,[Options]}, %% eg: {userOperator_impl,userOperator, org.apache.dubbo.erlang.sample.service.facade.UserOperator ,[Option]} ]} ]} ConfigName Type DefaultValue Remarks module_implements atom() - The service implements module name interface_module atom() - Interface module name is transfer form java jar interface_fullname binary() - Interface full name is the java class name Option is to be added.","title":"Base Config"},{"location":"user/languages/erlang/start/","text":"Quick Start We recommend using java to define the Dubbo interface. And use erlanalysis tool parse java interface transfer to erlang lib. Import Dependency Lib Using Rebar Build Tool Add dubblerl to rebar.config with your project {deps, [ {dubboerl, {git, https://github.com/apache/dubbo-erlang.git , {branch, master }}} ]}. User erlang.mk Build Tool Waiting for improvement Import interface lib Suppose the interface lib you exported is called dubbo_service. If you didn't upload your lib to your git repository, It is recommended that you copy the dubbo_service lib into the project's apps directory. If it is upload to your git repository, you can import like this: {deps, [ {dubboerl, {git, https://github.com/apache/dubbo-erlang.git , {branch, master }}}, {dubbo_service,{git, ${INTERFACE_LIB_URL} ,{branch, master }}} %% replace ${INTERFACE_LIB_URL} with your lib git repos url ]}. Consumer Configuration Please reference Reference Config Init dubbolib in your project It is need you dubboerl:init(). How to invoke? Sync Call Request = #userInfoRequest{requestId = 123, username = testname }, {ok,RequestRef,Response,RpcContent} = userOperator:queryUserInfo(Request,#{sync= true}). If it occur error, is reponse {error,Reason} . Async Call Default is Async call. Request = #userInfoRequest{requestId = 123, username = testname }, {ok,RequestRef} = userOperator:queryUserInfo(Request). %% you can receive the message after. {msg_back,RequestRef,Response,RpcContent}. Sample Reference the demo project dubboerl_demo","title":"Quick Start"},{"location":"user/languages/erlang/start/#quick-start","text":"We recommend using java to define the Dubbo interface. And use erlanalysis tool parse java interface transfer to erlang lib.","title":"Quick Start"},{"location":"user/languages/erlang/start/#import-dependency-lib","text":"","title":"Import Dependency Lib"},{"location":"user/languages/erlang/start/#using-rebar-build-tool","text":"Add dubblerl to rebar.config with your project {deps, [ {dubboerl, {git, https://github.com/apache/dubbo-erlang.git , {branch, master }}} ]}.","title":"Using Rebar Build Tool"},{"location":"user/languages/erlang/start/#user-erlangmk-build-tool","text":"Waiting for improvement","title":"User erlang.mk Build Tool"},{"location":"user/languages/erlang/start/#import-interface-lib","text":"Suppose the interface lib you exported is called dubbo_service. If you didn't upload your lib to your git repository, It is recommended that you copy the dubbo_service lib into the project's apps directory. If it is upload to your git repository, you can import like this: {deps, [ {dubboerl, {git, https://github.com/apache/dubbo-erlang.git , {branch, master }}}, {dubbo_service,{git, ${INTERFACE_LIB_URL} ,{branch, master }}} %% replace ${INTERFACE_LIB_URL} with your lib git repos url ]}.","title":"Import interface lib"},{"location":"user/languages/erlang/start/#consumer-configuration","text":"Please reference Reference Config","title":"Consumer Configuration"},{"location":"user/languages/erlang/start/#init-dubbolib-in-your-project","text":"It is need you dubboerl:init().","title":"Init dubbolib in your project"},{"location":"user/languages/erlang/start/#how-to-invoke","text":"","title":"How to invoke?"},{"location":"user/languages/erlang/start/#sync-call","text":"Request = #userInfoRequest{requestId = 123, username = testname }, {ok,RequestRef,Response,RpcContent} = userOperator:queryUserInfo(Request,#{sync= true}). If it occur error, is reponse {error,Reason} .","title":"Sync Call"},{"location":"user/languages/erlang/start/#async-call","text":"Default is Async call. Request = #userInfoRequest{requestId = 123, username = testname }, {ok,RequestRef} = userOperator:queryUserInfo(Request). %% you can receive the message after. {msg_back,RequestRef,Response,RpcContent}.","title":"Async Call"},{"location":"user/languages/erlang/start/#sample","text":"Reference the demo project dubboerl_demo","title":"Sample"},{"location":"user/preface/","text":"Introduction","title":"Introduction"},{"location":"user/preface/#introduction","text":"","title":"Introduction"},{"location":"user/preface/architecture/","text":"Architecture Specification of Node's Role Node Role Spec Provider The provider exposes remote services Consumer The consumer calls the remote services Registry The registry is responsible for service discovery and configuration Monitor The monitor counts the number of service invocations and time-consuming Container The container manages the services's lifetime Service relationship Container is responsible for launching, loading, and running the service Provider . Provider registers its services to Register at the time it starts. Consumer subscribes the services it needs from the Register when it starts. Register returns the Provider s list to Consumer , when it changes, the Register will push the changed data to Consumer through long connection. Consumer selects one of the Provider s based on soft load balancing algorithm and executes the invocation, if fails, it will choose another Provider . Both Consumer and Provider will count the number service invocations and time-consuming in memory, and send the statistics to Monitor every minute. Dubbo has the following features: Connectivity, Robustness, Scalability and Upgradeability. Connectivity Register is responsible for the registration and search of service addresses, like directory services, Provider and Consumer only interact with the registry during startup, and the registry does not forward requests, so it is less stressed 'Monitor' is responsible for counting the number of service invocations and time-consuming, the statistics will assembles in Provider 's and Consumer 's memory first and then sent to Monitor 'Provider' registers services to 'Register' and report time-consuming statistic(not include network overhead) to 'Monitor' 'Consumer' gets a list of service provider addresses from Registry , call the provider directly according to the LB algorithm, report the time-consuming statistic to Monitor , which includes network overhead The connections between Register , Provider and Consumer are long connections, Moniter is an exception Register is aware of the existence of Provider through the long connection, when Provider gets down, Register will push the event to Consumer It doesn't affect the already running instances of Provider and Consumer even all of the Register and Monitor get down, since Consumer got a cache of Provider s list Register and Monitor are optional, Consumer can connect Provider directly Robustness Monitor 's downtime doesn't affect the usage, only lose some sampling data When the DB server goes down, Register can return service Provider s list to Consumer by checking its cache, but new Provider cannot register any services Register is a peer cluster, it will automatically switch to another when any instance goes down Even all Register 's instances go down, Provider and Consumer can still conmunicate by checking their local cache Service Provider s are stateless, one instance's downtime doesn't affect the usage After all the Provider s of one service go down, Consumer can not use the that service, and infinitely reconnect to wait for service Provider to recover Scalability Register is a peer cluster that can dynamically increases its instances, all clients will automatically discover the new instances. Provider is stateless, it can dynamically increases the deployment instances, and the registry will push the new service provider information to the Consumer . Upgradeablity When the service cluster is further expanded and the IT governance structure is further upgraded, dynamic deployment is needed, and the current distributed service architecture will not bring resistance. Here is a possible future architecture: Specification of Node's Role Node Role Spec Deployer Local proxy for automatic services deployment Repository The repository is used to store application packages Scheduler The scheduler automatically increases or decreases service providers based on the access pressure Admin Unified management console Registry the registry is responsible for service discovery and configuration Monitor The monitor counts the service call times and time-consuming","title":"Architecture"},{"location":"user/preface/architecture/#architecture","text":"","title":"Architecture"},{"location":"user/preface/architecture/#specification-of-nodes-role","text":"Node Role Spec Provider The provider exposes remote services Consumer The consumer calls the remote services Registry The registry is responsible for service discovery and configuration Monitor The monitor counts the number of service invocations and time-consuming Container The container manages the services's lifetime","title":"Specification of Node's Role"},{"location":"user/preface/architecture/#service-relationship","text":"Container is responsible for launching, loading, and running the service Provider . Provider registers its services to Register at the time it starts. Consumer subscribes the services it needs from the Register when it starts. Register returns the Provider s list to Consumer , when it changes, the Register will push the changed data to Consumer through long connection. Consumer selects one of the Provider s based on soft load balancing algorithm and executes the invocation, if fails, it will choose another Provider . Both Consumer and Provider will count the number service invocations and time-consuming in memory, and send the statistics to Monitor every minute. Dubbo has the following features: Connectivity, Robustness, Scalability and Upgradeability.","title":"Service relationship"},{"location":"user/preface/architecture/#connectivity","text":"Register is responsible for the registration and search of service addresses, like directory services, Provider and Consumer only interact with the registry during startup, and the registry does not forward requests, so it is less stressed 'Monitor' is responsible for counting the number of service invocations and time-consuming, the statistics will assembles in Provider 's and Consumer 's memory first and then sent to Monitor 'Provider' registers services to 'Register' and report time-consuming statistic(not include network overhead) to 'Monitor' 'Consumer' gets a list of service provider addresses from Registry , call the provider directly according to the LB algorithm, report the time-consuming statistic to Monitor , which includes network overhead The connections between Register , Provider and Consumer are long connections, Moniter is an exception Register is aware of the existence of Provider through the long connection, when Provider gets down, Register will push the event to Consumer It doesn't affect the already running instances of Provider and Consumer even all of the Register and Monitor get down, since Consumer got a cache of Provider s list Register and Monitor are optional, Consumer can connect Provider directly","title":"Connectivity"},{"location":"user/preface/architecture/#robustness","text":"Monitor 's downtime doesn't affect the usage, only lose some sampling data When the DB server goes down, Register can return service Provider s list to Consumer by checking its cache, but new Provider cannot register any services Register is a peer cluster, it will automatically switch to another when any instance goes down Even all Register 's instances go down, Provider and Consumer can still conmunicate by checking their local cache Service Provider s are stateless, one instance's downtime doesn't affect the usage After all the Provider s of one service go down, Consumer can not use the that service, and infinitely reconnect to wait for service Provider to recover","title":"Robustness"},{"location":"user/preface/architecture/#scalability","text":"Register is a peer cluster that can dynamically increases its instances, all clients will automatically discover the new instances. Provider is stateless, it can dynamically increases the deployment instances, and the registry will push the new service provider information to the Consumer .","title":"Scalability"},{"location":"user/preface/architecture/#upgradeablity","text":"When the service cluster is further expanded and the IT governance structure is further upgraded, dynamic deployment is needed, and the current distributed service architecture will not bring resistance. Here is a possible future architecture:","title":"Upgradeablity"},{"location":"user/preface/architecture/#specification-of-nodes-role_1","text":"Node Role Spec Deployer Local proxy for automatic services deployment Repository The repository is used to store application packages Scheduler The scheduler automatically increases or decreases service providers based on the access pressure Admin Unified management console Registry the registry is responsible for service discovery and configuration Monitor The monitor counts the service call times and time-consuming","title":"Specification of Node's Role"},{"location":"user/preface/background/","text":"Background With the fast development of Internet, the scale of web applications expands unceasingly, and finally we find that the traditional vertical architecture(monolithic) can not handle this any more. Distributed service architecture and the flow computing architecture are imperative, and a governance system is urgently needed to ensure an orderly evolution of the architecture. Monolithic architecture When the traffic is very low, there is only one application, all the features are deployed together to reduce the deployment node and cost. At this point, the data access framework (ORM) is the key to simplifying the workload of the CRUD. Vertical architecture When the traffic gets heavier, add monolithic application instances can not accelerate the access very well, one way to improve efficiency is to split the monolithic into discrete applications. At this point, the Web framework (MVC) used to accelerate front-end page development is the key. Distributed service architecture When there are more and more vertical applications, the interaction between applications is inevitable, some core businesses are extracted and served as independent services, which gradually forms a stable service center\uff0cthis way the front-end application can respond to the changeable market demand more quickly. At this point, the distributed service framework (RPC) for business reuse and integration is the key. Flow computing architecture When there are more and more services, capacity evaluation becomes difficult, and also services with small scales often causes waste of resources. To solve these problems, a scheduling center should be added to manage the cluster capacity based on traffics and to improve the utilization of the cluster. At this time, the resource scheduling and governance centers (SOA), which are used to improve machine utilization, are the keys.","title":"Requirements"},{"location":"user/preface/background/#background","text":"With the fast development of Internet, the scale of web applications expands unceasingly, and finally we find that the traditional vertical architecture(monolithic) can not handle this any more. Distributed service architecture and the flow computing architecture are imperative, and a governance system is urgently needed to ensure an orderly evolution of the architecture.","title":"Background"},{"location":"user/preface/background/#monolithic-architecture","text":"When the traffic is very low, there is only one application, all the features are deployed together to reduce the deployment node and cost. At this point, the data access framework (ORM) is the key to simplifying the workload of the CRUD.","title":"Monolithic architecture"},{"location":"user/preface/background/#vertical-architecture","text":"When the traffic gets heavier, add monolithic application instances can not accelerate the access very well, one way to improve efficiency is to split the monolithic into discrete applications. At this point, the Web framework (MVC) used to accelerate front-end page development is the key.","title":"Vertical architecture"},{"location":"user/preface/background/#distributed-service-architecture","text":"When there are more and more vertical applications, the interaction between applications is inevitable, some core businesses are extracted and served as independent services, which gradually forms a stable service center\uff0cthis way the front-end application can respond to the changeable market demand more quickly. At this point, the distributed service framework (RPC) for business reuse and integration is the key.","title":"Distributed service architecture"},{"location":"user/preface/background/#flow-computing-architecture","text":"When there are more and more services, capacity evaluation becomes difficult, and also services with small scales often causes waste of resources. To solve these problems, a scheduling center should be added to manage the cluster capacity based on traffics and to improve the utilization of the cluster. At this time, the resource scheduling and governance centers (SOA), which are used to improve machine utilization, are the keys.","title":"Flow computing architecture"},{"location":"user/preface/requirements/","text":"Requirements Before the advent of large-scare services, an application might just exposes or references remote service by using RMI or Hessian, the call is done by configuring service URL, and load balance is done through hardwares, like F5. When there are more and more services, it becomes very difficult to configure the service URL, the single point pressure of F5 hardware load balancer is also increasing. At this point, a service registry is needed to dynamically register and discover services to make the service's location transparent. By obtaining the list of service provider addresses in the consumer side, the soft load balancing and Failover can be realized, this reduces the dependence on the F5 hardware load balacer and some of the costs. When things go further, the service dependencies become so complex that it can't even tell which applications to start before, even the architect can't fully describe the application architecture relationships . At this time, automatically draw the dependency diagram of the applications is needed to help the architect to be clear of the relationship. Then, the traffic becomes even heavier, the capacity problem of the service is exposed, how many machines are needed to support this service? When should the machine be added? To solve these problems, first, the daily service calls and the amount of response time should be counted as a reference for capacity planning. Second, dynamically adjust the weight, increase the weight of an online machine, and recorded the response time changes until it reaches the threshold, record the visits times at this time, then multiply this number of visits by the total number of machines to calculate the capacity in turn. Above are the most basic requirements of Dubbo.","title":"Requirements"},{"location":"user/preface/requirements/#requirements","text":"Before the advent of large-scare services, an application might just exposes or references remote service by using RMI or Hessian, the call is done by configuring service URL, and load balance is done through hardwares, like F5. When there are more and more services, it becomes very difficult to configure the service URL, the single point pressure of F5 hardware load balancer is also increasing. At this point, a service registry is needed to dynamically register and discover services to make the service's location transparent. By obtaining the list of service provider addresses in the consumer side, the soft load balancing and Failover can be realized, this reduces the dependence on the F5 hardware load balacer and some of the costs. When things go further, the service dependencies become so complex that it can't even tell which applications to start before, even the architect can't fully describe the application architecture relationships . At this time, automatically draw the dependency diagram of the applications is needed to help the architect to be clear of the relationship. Then, the traffic becomes even heavier, the capacity problem of the service is exposed, how many machines are needed to support this service? When should the machine be added? To solve these problems, first, the daily service calls and the amount of response time should be counted as a reference for capacity planning. Second, dynamically adjust the weight, increase the weight of an online machine, and recorded the response time changes until it reaches the threshold, record the visits times at this time, then multiply this number of visits by the total number of machines to calculate the capacity in turn. Above are the most basic requirements of Dubbo.","title":"Requirements"},{"location":"user/preface/usage/","text":"Usage Spring configuration of local service local.xml: bean id=\u201cxxxService\u201d class=\u201ccom.xxx.XxxServiceImpl\u201d / bean id=\u201cxxxAction\u201d class=\u201ccom.xxx.XxxAction\u201d property name=\u201cxxxService\u201d ref=\u201cxxxService\u201d / /bean Spring configuration of remote service The remote configuration can be done by very little change based on the local configuration: split the local.xml into two part, put the service define part into remote-privider.xml (exists in the provider node), meanwhile the refrence part into remote-consumer.xml (exists in the consumer node). add dubbo:service to the provider's configuration, and dubbo:reference to the consumer's configuration. remote-provider.xml: !-- define remote service bean the same way as local service bean -- bean id=\u201cxxxService\u201d class=\u201ccom.xxx.XxxServiceImpl\u201d / !-- expose the remote service -- dubbo:service interface=\u201ccom.xxx.XxxService\u201d ref=\u201cxxxService\u201d / remote-consumer.xml: !-- reference the remote service -- dubbo:reference id=\u201cxxxService\u201d interface=\u201ccom.xxx.XxxService\u201d / !-- use remote service the same say as local service -- bean id=\u201cxxxAction\u201d class=\u201ccom.xxx.XxxAction\u201d property name=\u201cxxxService\u201d ref=\u201cxxxService\u201d / /bean","title":"Usage"},{"location":"user/preface/usage/#usage","text":"","title":"Usage"},{"location":"user/preface/usage/#spring-configuration-of-local-service","text":"local.xml: bean id=\u201cxxxService\u201d class=\u201ccom.xxx.XxxServiceImpl\u201d / bean id=\u201cxxxAction\u201d class=\u201ccom.xxx.XxxAction\u201d property name=\u201cxxxService\u201d ref=\u201cxxxService\u201d / /bean","title":"Spring configuration of local service"},{"location":"user/preface/usage/#spring-configuration-of-remote-service","text":"The remote configuration can be done by very little change based on the local configuration: split the local.xml into two part, put the service define part into remote-privider.xml (exists in the provider node), meanwhile the refrence part into remote-consumer.xml (exists in the consumer node). add dubbo:service to the provider's configuration, and dubbo:reference to the consumer's configuration. remote-provider.xml: !-- define remote service bean the same way as local service bean -- bean id=\u201cxxxService\u201d class=\u201ccom.xxx.XxxServiceImpl\u201d / !-- expose the remote service -- dubbo:service interface=\u201ccom.xxx.XxxService\u201d ref=\u201cxxxService\u201d / remote-consumer.xml: !-- reference the remote service -- dubbo:reference id=\u201cxxxService\u201d interface=\u201ccom.xxx.XxxService\u201d / !-- use remote service the same say as local service -- bean id=\u201cxxxAction\u201d class=\u201ccom.xxx.XxxAction\u201d property name=\u201cxxxService\u201d ref=\u201cxxxService\u201d / /bean","title":"Spring configuration of remote service"},{"location":"user/references/api/","text":"API Reference Generally speaking, dubbo keeps its functionality no intrusive as much as possible, but for some particular features, there's no other way not only API can achieve. [^1] These APIs are summarized here below: Configuration API org.apache.dubbo.config.ServiceConfig org.apache.dubbo.config.ReferenceConfig org.apache.dubbo.config.ProtocolConfig org.apache.dubbo.config.RegistryConfig org.apache.dubbo.config.MonitorConfig org.apache.dubbo.config.ApplicationConfig org.apache.dubbo.config.ModuleConfig org.apache.dubbo.config.ProviderConfig org.apache.dubbo.config.ConsumerConfig org.apache.dubbo.config.MethodConfig org.apache.dubbo.config.ArgumentConfig Pls. refer to API Configuration for further information. Annotation API org.apache.dubbo.config.annotation.Service org.apache.dubbo.config.annotation.Reference Pls. refer to Annotation Configuration for further information. Model API org.apache.dubbo.common.URL org.apache.dubbo.rpc.RpcException Context API org.apache.dubbo.rpc.RpcContext Pls. refer to context pass parameter in attachment asynchronous call for further information. Service API org.apache.dubbo.rpc.service.GenericService org.apache.dubbo.rpc.service.GenericException Pls. refer to generic reference generic service for further information. org.apache.dubbo.rpc.service.EchoService Pls. refer to test via echo service for further details. [^1]: Attention: do not rely on APIs other than what're mentioned here, otherwise your application may face the risk of incompatibility after upgrade dubbo.","title":"API Reference"},{"location":"user/references/api/#api-reference","text":"Generally speaking, dubbo keeps its functionality no intrusive as much as possible, but for some particular features, there's no other way not only API can achieve. [^1] These APIs are summarized here below:","title":"API Reference"},{"location":"user/references/api/#configuration-api","text":"org.apache.dubbo.config.ServiceConfig org.apache.dubbo.config.ReferenceConfig org.apache.dubbo.config.ProtocolConfig org.apache.dubbo.config.RegistryConfig org.apache.dubbo.config.MonitorConfig org.apache.dubbo.config.ApplicationConfig org.apache.dubbo.config.ModuleConfig org.apache.dubbo.config.ProviderConfig org.apache.dubbo.config.ConsumerConfig org.apache.dubbo.config.MethodConfig org.apache.dubbo.config.ArgumentConfig Pls. refer to API Configuration for further information.","title":"Configuration API"},{"location":"user/references/api/#annotation-api","text":"org.apache.dubbo.config.annotation.Service org.apache.dubbo.config.annotation.Reference Pls. refer to Annotation Configuration for further information.","title":"Annotation API"},{"location":"user/references/api/#model-api","text":"org.apache.dubbo.common.URL org.apache.dubbo.rpc.RpcException","title":"Model API"},{"location":"user/references/api/#context-api","text":"org.apache.dubbo.rpc.RpcContext Pls. refer to context pass parameter in attachment asynchronous call for further information.","title":"Context API"},{"location":"user/references/api/#service-api","text":"org.apache.dubbo.rpc.service.GenericService org.apache.dubbo.rpc.service.GenericException Pls. refer to generic reference generic service for further information. org.apache.dubbo.rpc.service.EchoService Pls. refer to test via echo service for further details. [^1]: Attention: do not rely on APIs other than what're mentioned here, otherwise your application may face the risk of incompatibility after upgrade dubbo.","title":"Service API"},{"location":"user/references/maven/","text":"Maven Plugin Reference Start a simple registry server Start a simple registry server listening on port 9099 [^1]: mvn dubbo:registry -Dport=9099 Generate a service provider demo application Generate a service provider with the specified interface and version: mvn dubbo:create -Dapplication=xxx -Dpackage=com.alibaba.xxx -Dservice=XxxService,YyyService -Dversion=1.0.0 [^1]: Default port is 9090 if the port is not specified","title":"Maven plugin reference"},{"location":"user/references/maven/#maven-plugin-reference","text":"","title":"Maven Plugin Reference"},{"location":"user/references/maven/#start-a-simple-registry-server","text":"Start a simple registry server listening on port 9099 [^1]: mvn dubbo:registry -Dport=9099","title":"Start a simple registry server"},{"location":"user/references/maven/#generate-a-service-provider-demo-application","text":"Generate a service provider with the specified interface and version: mvn dubbo:create -Dapplication=xxx -Dpackage=com.alibaba.xxx -Dservice=XxxService,YyyService -Dversion=1.0.0 [^1]: Default port is 9090 if the port is not specified","title":"Generate a service provider demo application"},{"location":"user/references/qos/","text":"Telnet (new version) Command Usage In dubbo 2.5.8 a new QOS module is introduced, to provide new telnet command support. Port the port of new version telnet is different from the port of dubbo protocol. The default port is 22222 , which can be changed by modifying configuration file dubbo.properties dubbo.application.qos.port=33333 or by modifying the JVM parameter -Ddubbo.application.qos.port=33333 Safety By default, dubbo can receive any command sent from the host, which can be changed by modifying the configuration file dubbo.properties dubbo.application.qos.accept.foreign.ip=false or by configuring the JVM parameter -Ddubbo.application.qos.accept.foreign.ip=false to reject command sent from the remote host, allowing only the local server to run the command Telnet and HTTP protocol The telnet module supports both http and telnet protocol, in order to facilitate the use of various situations For example, \u279c ~ telnet localhost 22222 Trying ::1... telnet: connect to address ::1: Connection refused Trying 127.0.0.1... Connected to localhost. Escape character is '^]'. \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584 \u2588\u2588\u2588 \u2588\u2584 \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584 \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584 \u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2584 \u2588\u2588\u2588 \u2580\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2584\u2588\u2588\u2588\u2584\u2584\u2584\u2588\u2588\u2580 \u2584\u2588\u2588\u2588\u2584\u2584\u2584\u2588\u2588\u2580 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2580\u2580\u2588\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2584 \u2580\u2580\u2588\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2584 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2584 \u2588\u2588\u2588 \u2588\u2588\u2584 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2584\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2580 dubbo ls As Provider side: +----------------------------------+---+ | Provider Service Name |PUB| +----------------------------------+---+ |org.apache.dubbo.demo.DemoService| N | +----------------------------------+---+ As Consumer side: +---------------------+---+ |Consumer Service Name|NUM| +---------------------+---+ dubbo \u279c ~ curl localhost:22222/ls?arg1=xxx arg2=xxxx As Provider side: +----------------------------------+---+ | Provider Service Name |PUB| +----------------------------------+---+ |org.apache.dubbo.demo.DemoService| N | +----------------------------------+---+ As Consumer side: +---------------------+---+ |Consumer Service Name|NUM| +---------------------+---+ Supported Commands ls List consumers and providers dubbo ls As Provider side: +----------------------------------+---+ | Provider Service Name |PUB| +----------------------------------+---+ |org.apache.dubbo.demo.DemoService| Y | +----------------------------------+---+ As Consumer side: +---------------------+---+ |Consumer Service Name|NUM| +---------------------+---+ List the services of the provides and the consumers that dubbo provide Online service command When using delay publishing function(org.apache.dubbo.config.AbstractServiceConfig#register set as false), you can use \u201conline\u201d command to online the service //online all services dubbo online OK //online part of servies according to regularity. dubbo online com.* OK Common usage situations: - Because there is no JIT or the related resources warm-up, when the machine is restarted and the online QPS is relatively high , a large amount of timeout situations may occur. At this time,the problem can be solved by distributing the batch service and increasing the traffic gradually. - A machine needs to be back online after going offline due to some reasons. Offline service Command Offline command can be used if temporary offline service is needed when fault occurs. //offline all service dubbo offline OK //offline some services according to regular rules dubbo offline com.* OK help command //list all commands dubbo help //list the specific use case of a command dubbo help online +--------------+----------------------------------------------------------------------------------+ | COMMAND NAME | online | +--------------+----------------------------------------------------------------------------------+ | EXAMPLE | online dubbo | | | online xx.xx.xxx.service | +--------------+----------------------------------------------------------------------------------+ dubbo QoS' Parameters You can use parameters that QoS provides to config its startup. These parameters include: Parameter Explanation Default qosEnable Activate QoS or not true qosPort The port QoS would bind to 22222 qosAcceptForeignIp Enable remote access or not false Attention. From 2.6.4/2.7.0, qosAcceptForeignIp is set to false by default, because it's risky if this property is set to true . Think twice before you turn it on. You can configure these parameters in the following ways: System property dubbo.properties XML Spring-boot auto configuration They have priority in the following order: system property dubbo.properties XML spring-boot. System Property -Ddubbo.application.qos.enable=true -Ddubbo.application.qos.port=33333 -Ddubbo.application.qos.accept.foreign.ip=false Dubbo.properties Create a dubbo.properties file in this directory src/main/resources in your project, and copy the following codes into it: dubbo.application.qos.enable=true dubbo.application.qos.port=33333 dubbo.application.qos.accept.foreign.ip=false XML If you are going to config using XML, you can try this: ?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd dubbo:application name= demo-provider dubbo:parameter key= qos.enable value= true / dubbo:parameter key= qos.accept.foreign.ip value= false / dubbo:parameter key= qos.port value= 33333 / /dubbo:application dubbo:registry address= multicast://224.5.6.7:1234 / dubbo:protocol name= dubbo port= 20880 / dubbo:service interface= org.apache.dubbo.demo.provider.DemoService ref= demoService / bean id= demoService class= org.apache.dubbo.demo.provider.DemoServiceImpl / /beans spring-boot auto configuration If you are developing a spring-boot application, you can configure in application.properties or application.yml : dubbo.application.qosEnable=true dubbo.application.qosPort=33333 dubbo.application.qosAcceptForeignIp=false","title":"Telnet (new version) Command Usage"},{"location":"user/references/qos/#telnet-new-version-command-usage","text":"In dubbo 2.5.8 a new QOS module is introduced, to provide new telnet command support.","title":"Telnet (new version) Command Usage"},{"location":"user/references/qos/#port","text":"the port of new version telnet is different from the port of dubbo protocol. The default port is 22222 , which can be changed by modifying configuration file dubbo.properties dubbo.application.qos.port=33333 or by modifying the JVM parameter -Ddubbo.application.qos.port=33333","title":"Port"},{"location":"user/references/qos/#safety","text":"By default, dubbo can receive any command sent from the host, which can be changed by modifying the configuration file dubbo.properties dubbo.application.qos.accept.foreign.ip=false or by configuring the JVM parameter -Ddubbo.application.qos.accept.foreign.ip=false to reject command sent from the remote host, allowing only the local server to run the command","title":"Safety"},{"location":"user/references/qos/#telnet-and-http-protocol","text":"The telnet module supports both http and telnet protocol, in order to facilitate the use of various situations For example, \u279c ~ telnet localhost 22222 Trying ::1... telnet: connect to address ::1: Connection refused Trying 127.0.0.1... Connected to localhost. Escape character is '^]'. \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584 \u2588\u2588\u2588 \u2588\u2584 \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584 \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584 \u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2584 \u2588\u2588\u2588 \u2580\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2584\u2588\u2588\u2588\u2584\u2584\u2584\u2588\u2588\u2580 \u2584\u2588\u2588\u2588\u2584\u2584\u2584\u2588\u2588\u2580 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2580\u2580\u2588\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2584 \u2580\u2580\u2588\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2584 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2584 \u2588\u2588\u2588 \u2588\u2588\u2584 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2584\u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580 \u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2580 dubbo ls As Provider side: +----------------------------------+---+ | Provider Service Name |PUB| +----------------------------------+---+ |org.apache.dubbo.demo.DemoService| N | +----------------------------------+---+ As Consumer side: +---------------------+---+ |Consumer Service Name|NUM| +---------------------+---+ dubbo \u279c ~ curl localhost:22222/ls?arg1=xxx arg2=xxxx As Provider side: +----------------------------------+---+ | Provider Service Name |PUB| +----------------------------------+---+ |org.apache.dubbo.demo.DemoService| N | +----------------------------------+---+ As Consumer side: +---------------------+---+ |Consumer Service Name|NUM| +---------------------+---+","title":"Telnet and HTTP protocol"},{"location":"user/references/qos/#supported-commands","text":"","title":"Supported Commands"},{"location":"user/references/qos/#ls-list-consumers-and-providers","text":"dubbo ls As Provider side: +----------------------------------+---+ | Provider Service Name |PUB| +----------------------------------+---+ |org.apache.dubbo.demo.DemoService| Y | +----------------------------------+---+ As Consumer side: +---------------------+---+ |Consumer Service Name|NUM| +---------------------+---+ List the services of the provides and the consumers that dubbo provide","title":"ls List consumers and providers"},{"location":"user/references/qos/#online-service-command","text":"When using delay publishing function(org.apache.dubbo.config.AbstractServiceConfig#register set as false), you can use \u201conline\u201d command to online the service //online all services dubbo online OK //online part of servies according to regularity. dubbo online com.* OK Common usage situations: - Because there is no JIT or the related resources warm-up, when the machine is restarted and the online QPS is relatively high , a large amount of timeout situations may occur. At this time,the problem can be solved by distributing the batch service and increasing the traffic gradually. - A machine needs to be back online after going offline due to some reasons.","title":"Online service command"},{"location":"user/references/qos/#offline-service-command","text":"Offline command can be used if temporary offline service is needed when fault occurs. //offline all service dubbo offline OK //offline some services according to regular rules dubbo offline com.* OK","title":"Offline service Command"},{"location":"user/references/qos/#help-command","text":"//list all commands dubbo help //list the specific use case of a command dubbo help online +--------------+----------------------------------------------------------------------------------+ | COMMAND NAME | online | +--------------+----------------------------------------------------------------------------------+ | EXAMPLE | online dubbo | | | online xx.xx.xxx.service | +--------------+----------------------------------------------------------------------------------+ dubbo","title":"help command"},{"location":"user/references/qos/#qos-parameters","text":"You can use parameters that QoS provides to config its startup. These parameters include: Parameter Explanation Default qosEnable Activate QoS or not true qosPort The port QoS would bind to 22222 qosAcceptForeignIp Enable remote access or not false Attention. From 2.6.4/2.7.0, qosAcceptForeignIp is set to false by default, because it's risky if this property is set to true . Think twice before you turn it on. You can configure these parameters in the following ways: System property dubbo.properties XML Spring-boot auto configuration They have priority in the following order: system property dubbo.properties XML spring-boot.","title":"QoS' Parameters"},{"location":"user/references/qos/#system-property","text":"-Ddubbo.application.qos.enable=true -Ddubbo.application.qos.port=33333 -Ddubbo.application.qos.accept.foreign.ip=false","title":"System Property"},{"location":"user/references/qos/#dubboproperties","text":"Create a dubbo.properties file in this directory src/main/resources in your project, and copy the following codes into it: dubbo.application.qos.enable=true dubbo.application.qos.port=33333 dubbo.application.qos.accept.foreign.ip=false","title":"Dubbo.properties"},{"location":"user/references/qos/#xml","text":"If you are going to config using XML, you can try this: ?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd dubbo:application name= demo-provider dubbo:parameter key= qos.enable value= true / dubbo:parameter key= qos.accept.foreign.ip value= false / dubbo:parameter key= qos.port value= 33333 / /dubbo:application dubbo:registry address= multicast://224.5.6.7:1234 / dubbo:protocol name= dubbo port= 20880 / dubbo:service interface= org.apache.dubbo.demo.provider.DemoService ref= demoService / bean id= demoService class= org.apache.dubbo.demo.provider.DemoServiceImpl / /beans","title":"XML"},{"location":"user/references/qos/#spring-boot-auto-configuration","text":"If you are developing a spring-boot application, you can configure in application.properties or application.yml : dubbo.application.qosEnable=true dubbo.application.qosPort=33333 dubbo.application.qosAcceptForeignIp=false","title":"spring-boot auto configuration"},{"location":"user/references/telnet/","text":"Telnet Command Reference Since 2.0.5 dubbo starts supporting to use telnet command to govern services. How To Use telnet localhost 20880 Or: echo status | nc -i 1 localhost 20880 It is possible to extend command status to check more resources, pls. refer to extension references for more details. Supported Commands The built-in telnet commands are listed below. Furthermore, it is possible to extend telnet commands, pls. refer to extend telnet command for more details. ls ls : list services ls -l : list services in more details ls XxxService : list methods for the particular service ls -l XxxService : list methods for the particular service in more dtails ps ps : list service ports ps -l : list service addresses ps 20880 : show connection info for the particular port ps -l 20880 : show connection info for the particular port in more details cd cd XxxService : switch default service. When default service is set, service parameter can be ignored in all commands when it's needed cd / : reset default service pwd pwd : show what current default service is trace trace XxxService : trace method invocation once for the given service trace XxxService 10 : trace method invocations 10 times for the given service trace XxxService xxxMethod : trace particular method invocation once for the given service trace XxxService xxxMethod 10 : trace particular method invocations 10 times for the given service count count XxxService : count method invocation once for the given service count XxxService 10 : count method invocations 10 times for the given service count XxxService xxxMethod : count particular method invocation once for the given service count XxxService xxxMethod 10 : count particular method invocation 10 times for the given service invoke invoke XxxService.xxxMethod(1234, \"abcd\", {\"prop\" : \"value\"}) : invoke particular method for the given service invoke com.xxx.XxxService.XxxService.xxxMethod(1234, \"abcd\", {\"prop\" : \"value\"}) : invoke particular method for the given service invoke xxxMethod(1234, \"abcd\", {\"prop\" : \"value\"}) : invoke particular method for the default service invoke xxxMethod({\"name\":\"zhangsan\",\"age\":12,\"class\":\"org.apache.dubbo.qos.legacy.service.Person\"}) :When there is parameter overload, or the type conversion fails, you can specify the class to be converted by adding the class attribute When the parameter is Map and the key type is Integer, it is recommended to specify the type. E.g: invoke com.xxx.xxxApiService({\"3\":0.123, \"class\":\"java.util.HashMap\"}) select [^2] select 1 : used when the invoke command matches multiple methods, select the method to be called according to the prompt list status status : show summarized status. This status summarizes statuses from all resources, and it shows OK when all resources are OK, shows ERROR when any resource has ERROR, and WARN when any has WARN. status -l : show status list log [^1] log debug : modify logger level to debug log 100 : examine the last 100 characters from the file logger help help : show help for telnet commands help xxx : show help for particular telnet command clear clear : clear screen clear 100 : only clear particular lines on the screen exit exit : exit current telnet session shutdown [^2] shutdown : shutdown dubbo application shutdown -t 1000 : delay 1000 ms to shutdown dubbo application [^1]: support since 2.0.6 [^2]: support since 2.7.1","title":"Telnet reference"},{"location":"user/references/telnet/#telnet-command-reference","text":"Since 2.0.5 dubbo starts supporting to use telnet command to govern services.","title":"Telnet Command Reference"},{"location":"user/references/telnet/#how-to-use","text":"telnet localhost 20880 Or: echo status | nc -i 1 localhost 20880 It is possible to extend command status to check more resources, pls. refer to extension references for more details.","title":"How To Use"},{"location":"user/references/telnet/#supported-commands","text":"The built-in telnet commands are listed below. Furthermore, it is possible to extend telnet commands, pls. refer to extend telnet command for more details.","title":"Supported Commands"},{"location":"user/references/telnet/#ls","text":"ls : list services ls -l : list services in more details ls XxxService : list methods for the particular service ls -l XxxService : list methods for the particular service in more dtails","title":"ls"},{"location":"user/references/telnet/#ps","text":"ps : list service ports ps -l : list service addresses ps 20880 : show connection info for the particular port ps -l 20880 : show connection info for the particular port in more details","title":"ps"},{"location":"user/references/telnet/#cd","text":"cd XxxService : switch default service. When default service is set, service parameter can be ignored in all commands when it's needed cd / : reset default service","title":"cd"},{"location":"user/references/telnet/#pwd","text":"pwd : show what current default service is","title":"pwd"},{"location":"user/references/telnet/#trace","text":"trace XxxService : trace method invocation once for the given service trace XxxService 10 : trace method invocations 10 times for the given service trace XxxService xxxMethod : trace particular method invocation once for the given service trace XxxService xxxMethod 10 : trace particular method invocations 10 times for the given service","title":"trace"},{"location":"user/references/telnet/#count","text":"count XxxService : count method invocation once for the given service count XxxService 10 : count method invocations 10 times for the given service count XxxService xxxMethod : count particular method invocation once for the given service count XxxService xxxMethod 10 : count particular method invocation 10 times for the given service","title":"count"},{"location":"user/references/telnet/#invoke","text":"invoke XxxService.xxxMethod(1234, \"abcd\", {\"prop\" : \"value\"}) : invoke particular method for the given service invoke com.xxx.XxxService.XxxService.xxxMethod(1234, \"abcd\", {\"prop\" : \"value\"}) : invoke particular method for the given service invoke xxxMethod(1234, \"abcd\", {\"prop\" : \"value\"}) : invoke particular method for the default service invoke xxxMethod({\"name\":\"zhangsan\",\"age\":12,\"class\":\"org.apache.dubbo.qos.legacy.service.Person\"}) :When there is parameter overload, or the type conversion fails, you can specify the class to be converted by adding the class attribute When the parameter is Map and the key type is Integer, it is recommended to specify the type. E.g: invoke com.xxx.xxxApiService({\"3\":0.123, \"class\":\"java.util.HashMap\"})","title":"invoke"},{"location":"user/references/telnet/#select-2","text":"select 1 : used when the invoke command matches multiple methods, select the method to be called according to the prompt list","title":"select [^2]"},{"location":"user/references/telnet/#status","text":"status : show summarized status. This status summarizes statuses from all resources, and it shows OK when all resources are OK, shows ERROR when any resource has ERROR, and WARN when any has WARN. status -l : show status list","title":"status"},{"location":"user/references/telnet/#log-1","text":"log debug : modify logger level to debug log 100 : examine the last 100 characters from the file logger","title":"log [^1]"},{"location":"user/references/telnet/#help","text":"help : show help for telnet commands help xxx : show help for particular telnet command","title":"help"},{"location":"user/references/telnet/#clear","text":"clear : clear screen clear 100 : only clear particular lines on the screen","title":"clear"},{"location":"user/references/telnet/#exit","text":"exit : exit current telnet session","title":"exit"},{"location":"user/references/telnet/#shutdown-2","text":"shutdown : shutdown dubbo application shutdown -t 1000 : delay 1000 ms to shutdown dubbo application [^1]: support since 2.0.6 [^2]: support since 2.7.1","title":"shutdown [^2]"},{"location":"user/references/metadata/introduction/","text":"Background There are close to 30 configurations in dubbo provider. Excluding registry center governance requirements, a large part of configurations are used by the provider itself and do not need to be delivered to the consumer. This part of the data does not need to be written to the registry, but only needs to be persisted as key-value. There are also 20+ configurations in dubbo consumer. In the registry center, only a few configurations such as application, version, group, ip, dubbo version are needed in the list of service consumers. Other configurations can also be persisted in key-value form. This data is registered into the registry in the service dimension, which leads to the expansion of data volume, and then causes the increased network overhead of the registry (such as zookeeper) and decreased performance. In addition to the storage of the above configuration items, Dubbo service metadata information also needs to be stored. Metadata information includes service interface and method information of interface. This information will be used for service mock, service test. Goal The original data and metadata information in the registry center need to be stored in a separate key-value store, which can be DB, redis or other persistent storage. The core code supports zookeeper, redis(recommended) by default. The format of provider storage content is the storage after gson's serialization of org.apache.dubbo.metadata.definition.model.FullServiceDefinition. Consumer gets parameter information from the URL that it wrote to the registry and stores it in Map. That is, get the Map with URL.getParameterMap() and store it after gson's serialization. For more details, you can refer to the sample below. Configuration The default metadata storage supports the following additional features: * Failed retry * Refresh regularly Failed retry Failed retries can be configured by retrytimes (retry times, default 100), retryperiod (retry cycle, default 3000ms). Refresh regularly It's opening by default and can be turned off by setting cycleReport=false. Complete configurations: dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 dubbo.metadata-report.username=xxx ##Not necessary dubbo.metadata-report.password=xxx ##Not necessary dubbo.metadata-report.retry-times=30 ##Not necessary,default 100 dubbo.metadata-report.retry-period=5000 ##Not necessary,default 3000 dubbo.metadata-report.cycle-report=false ##Not necessary,default true If the metadata address (dubbo.metadata-report.address) is not configured, the writing of the entire metadata will not take effect, but it will not affect the running of the program. Let's look at a few sample configurations. Regardless of the configuration, some maven dependencies need to be introduced: dependency groupId org.apache.dubbo /groupId artifactId dubbo-metadata-report-zookeeper /artifactId /dependency If redis is needed, the corresponding redis dependencies can be introduced: dependency groupId org.apache.dubbo /groupId artifactId dubbo-metadata-report-redis /artifactId /dependency Complete sample\uff0crefer to sample-2.7 Method 1: Config in Configcenter Refer to the sample: dubbo-samples-metadata-report/dubbo-samples-metadata-report-configcenter. Configcenter Configuration Configurations of Configcenter\uff0ccan refer to the document of Configcenter. As follows: dubbo.registry.address=zookeeper://127.0.0.1:2181 ### Notice the hump style dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 ###Address of metadata storage In the sample, Zookeeper is used as the Configcenter. Run directly: org.Apache.Dubbo.Samples.Metadatareport.Configcenter.ZKTools after starting a local zookeeper service, then writing finished. You can also use Nacos, Apollo as the Configcenter. These products themselves support ops configuration. Application Configuration ###dubbo.properties dubbo.config-center.address=zookeeper://127.0.0.1:2181 ... After completing the above two steps, the registry address and metadata address are retrieved from the Configcenter. You can now run the Provider and the Consumer in turn and get the corresponding output in console or view it directly through the client of zookeeper. Provider Configuration The metadata stored on the Provider side is as follows: { parameters : { side : provider , methods : sayHello , dubbo : 2.0.2 , threads : 100 , interface : org.apache.dubbo.samples.metadatareport.configcenter.api.AnnotationService , threadpool : fixed , version : 1.1.1 , generic : false , revision : 1.1.1 , valid : true , application : metadatareport-configcenter-provider , default.timeout : 5000 , group : d-test , anyhost : true }, canonicalName : org.apache.dubbo.samples.metadatareport.configcenter.api.AnnotationService , codeSource : file:/Users/cvictory/workspace/work-mw/dubbo-samples/dubbo-samples-metadata-report/dubbo-samples-metadata-report-configcenter/target/classes/ , methods : [{ name : sayHello , parameterTypes : [ java.lang.String ], returnType : java.lang.String }], types : [{ type : java.lang.String , properties : { value : { type : char[] }, hash : { type : int } } }, { type : int }, { type : char }] } The Provider side stores all the parameters that the Provider service fills in to the registry, as well as the method information of the service (method name, input and output format). Consumer Configuration { valid : true , side : consumer , application : metadatareport-configcenter-consumer , methods : sayHello , default.timeout : 6666 , dubbo : 2.0.2 , interface : org.apache.dubbo.samples.metadatareport.configcenter.api.AnnotationService , version : 1.1.1 , revision : 1.1.1 , group : d-test } The Consumer side stores all the parameters that the Consumer fills in to the registry. The above example is mainly a presentation of the provider side service information and consumer side service information stored in the metadata area by placing the metadata address in the Configcenter. The next two examples focus on configuring in a project: the XML mode and the annotation mode . Method 2: Config project in properties way Refer to the sample: dubbo-samples-metadata-report/dubbo-samples-metadata-report-local-xml. dubbo.properties dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 After setting this configuration, have not to focus on others. You can also view the service information of the corresponding provider and consumer directly. Provider stores: { parameters : { valid : true , async : true , side : provider , application : metadatareport-local-xml-provider , methods : sayHello , dubbo : 2.0.2 , interface : org.apache.dubbo.samples.metadatareport.local.xml.api.DemoService , generic : false , anyhost : true }, canonicalName : org.apache.dubbo.samples.metadatareport.local.xml.api.DemoService , codeSource : file:/Users/cvictory/workspace/work-mw/dubbo-samples/dubbo-samples-metadata-report/dubbo-samples-metadata-report-local-xml/target/classes/ , methods : [{ name : sayHello , parameterTypes : [ java.lang.String ], returnType : java.lang.String }], types : [{ type : int }, { type : char }, { type : java.lang.String , properties : { value : { type : char[] }, hash : { type : int } } }] } Consumer stores: { valid : true , side : consumer , application : metadatareport-local-xml-consumer , methods : sayHello , dubbo : 2.0.2 , interface : org.apache.dubbo.samples.metadatareport.local.xml.api.DemoService } Method 3: Config project in annotation way Refer to the sample: dubbo-samples-metadata-report/dubbo-samples-metadata-report-local-annotaion. @Bean introduce Bean @Bean public MetadataReportConfig metadataReportConfig() { MetadataReportConfig metadataReportConfig = new MetadataReportConfig(); metadataReportConfig.setAddress( zookeeper://127.0.0.1:2181 ); return metadataReportConfig; } After introducing Bean, also have not to set others. View corresponding service information directly: Provider stores: { parameters : { side : provider , methods : sayHello , dubbo : 2.0.2 , interface : org.apache.dubbo.samples.metadatareport.local.annotation.api.AnnotationService , version : 1.1.8 , generic : false , revision : 1.1.8 , valid : true , application : metadatareport-local-annotaion-provider , default.timeout : 1000 , group : d-test , anyhost : true }, canonicalName : org.apache.dubbo.samples.metadatareport.local.annotation.api.AnnotationService , codeSource : file:/Users/cvictory/workspace/work-mw/dubbo-samples/dubbo-samples-metadata-report/dubbo-samples-metadata-report-local-annotaion/target/classes/ , methods : [{ name : sayHello , parameterTypes : [ java.lang.String ], returnType : java.lang.String }], types : [{ type : int }, { type : java.lang.String , properties : { value : { type : char[] }, hash : { type : int } } }, { type : char }] } Consumer stores: { valid : true , side : consumer , application : metadatareport-local-annotaion-consumer , methods : sayHello , dubbo : 2.0.2 , interface : org.apache.dubbo.samples.metadatareport.local.annotation.api.AnnotationService , version : 1.1.8 , revision : 1.1.8 , group : d-test } Extension SPI Definition Refer to: org.apache.dubbo.metadata.store.MetadataReportFactory, org.apache.dubbo.metadata.store.MetadataReport @SPI( redis ) public interface MetadataReportFactory { @Adaptive({ protocol }) MetadataReport getMetadataReport(URL url); } Custom metadata storage Let's take Redis storage as an example to illustrate. Create a new project supporting the following modifications: Extend AbstractMetadataReport public class RedisMetadataReport extends AbstractMetadataReport { private final static Logger logger = LoggerFactory.getLogger(RedisMetadataReport.class); final JedisPool pool; public RedisMetadataReport(URL url) { super(url); pool = new JedisPool(new JedisPoolConfig(), url.getHost(), url.getPort()); } @Override protected void doStoreProviderMetadata(ProviderMetadataIdentifier providerMetadataIdentifier, String serviceDefinitions) { this.storeMetadata(providerMetadataIdentifier, serviceDefinitions); } @Override protected void doStoreConsumerMetadata(ConsumerMetadataIdentifier consumerMetadataIdentifier, String value) { this.storeMetadata(consumerMetadataIdentifier, value); } private void storeMetadata(MetadataIdentifier metadataIdentifier, String v) { try (Jedis jedis = pool.getResource()) { jedis.set(metadataIdentifier.getIdentifierKey() + META_DATA_SOTRE_TAG, v); } catch (Throwable e) { logger.error( Failed to put + metadataIdentifier + to redis + v + , cause: + e.getMessage(), e); throw new RpcException( Failed to put + metadataIdentifier + to redis + v + , cause: + e.getMessage(), e); } } } Extend AbstractMetadataReportFactory public class RedisMetadataReportFactory extends AbstractMetadataReportFactory { @Override public MetadataReport createMetadataReport(URL url) { return new RedisMetadataReport(url); } } New META-INF/dubbo/internal/org.apache.dubbo.metadata.store.MetadataReportFactory redis=org.apache.dubbo.metadata.store.redis.RedisMetadataReportFactory As long as the above modifications along with the project are packaged into a jar, then config metadata center url: redis://10.20.153.10:6379. Up to now, a custom metadata store is ready to run.","title":"Background"},{"location":"user/references/metadata/introduction/#background","text":"There are close to 30 configurations in dubbo provider. Excluding registry center governance requirements, a large part of configurations are used by the provider itself and do not need to be delivered to the consumer. This part of the data does not need to be written to the registry, but only needs to be persisted as key-value. There are also 20+ configurations in dubbo consumer. In the registry center, only a few configurations such as application, version, group, ip, dubbo version are needed in the list of service consumers. Other configurations can also be persisted in key-value form. This data is registered into the registry in the service dimension, which leads to the expansion of data volume, and then causes the increased network overhead of the registry (such as zookeeper) and decreased performance. In addition to the storage of the above configuration items, Dubbo service metadata information also needs to be stored. Metadata information includes service interface and method information of interface. This information will be used for service mock, service test.","title":"Background"},{"location":"user/references/metadata/introduction/#goal","text":"The original data and metadata information in the registry center need to be stored in a separate key-value store, which can be DB, redis or other persistent storage. The core code supports zookeeper, redis(recommended) by default. The format of provider storage content is the storage after gson's serialization of org.apache.dubbo.metadata.definition.model.FullServiceDefinition. Consumer gets parameter information from the URL that it wrote to the registry and stores it in Map. That is, get the Map with URL.getParameterMap() and store it after gson's serialization. For more details, you can refer to the sample below.","title":"Goal"},{"location":"user/references/metadata/introduction/#configuration","text":"The default metadata storage supports the following additional features: * Failed retry * Refresh regularly","title":"Configuration"},{"location":"user/references/metadata/introduction/#failed-retry","text":"Failed retries can be configured by retrytimes (retry times, default 100), retryperiod (retry cycle, default 3000ms).","title":"Failed retry"},{"location":"user/references/metadata/introduction/#refresh-regularly","text":"It's opening by default and can be turned off by setting cycleReport=false.","title":"Refresh regularly"},{"location":"user/references/metadata/introduction/#complete-configurations","text":"dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 dubbo.metadata-report.username=xxx ##Not necessary dubbo.metadata-report.password=xxx ##Not necessary dubbo.metadata-report.retry-times=30 ##Not necessary,default 100 dubbo.metadata-report.retry-period=5000 ##Not necessary,default 3000 dubbo.metadata-report.cycle-report=false ##Not necessary,default true If the metadata address (dubbo.metadata-report.address) is not configured, the writing of the entire metadata will not take effect, but it will not affect the running of the program. Let's look at a few sample configurations. Regardless of the configuration, some maven dependencies need to be introduced: dependency groupId org.apache.dubbo /groupId artifactId dubbo-metadata-report-zookeeper /artifactId /dependency If redis is needed, the corresponding redis dependencies can be introduced: dependency groupId org.apache.dubbo /groupId artifactId dubbo-metadata-report-redis /artifactId /dependency Complete sample\uff0crefer to sample-2.7","title":"Complete configurations:"},{"location":"user/references/metadata/introduction/#method-1-config-in-configcenter","text":"Refer to the sample: dubbo-samples-metadata-report/dubbo-samples-metadata-report-configcenter.","title":"Method 1: Config in Configcenter"},{"location":"user/references/metadata/introduction/#configcenter-configuration","text":"Configurations of Configcenter\uff0ccan refer to the document of Configcenter. As follows: dubbo.registry.address=zookeeper://127.0.0.1:2181 ### Notice the hump style dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 ###Address of metadata storage In the sample, Zookeeper is used as the Configcenter. Run directly: org.Apache.Dubbo.Samples.Metadatareport.Configcenter.ZKTools after starting a local zookeeper service, then writing finished. You can also use Nacos, Apollo as the Configcenter. These products themselves support ops configuration.","title":"Configcenter Configuration"},{"location":"user/references/metadata/introduction/#application-configuration","text":"###dubbo.properties dubbo.config-center.address=zookeeper://127.0.0.1:2181 ... After completing the above two steps, the registry address and metadata address are retrieved from the Configcenter. You can now run the Provider and the Consumer in turn and get the corresponding output in console or view it directly through the client of zookeeper.","title":"Application Configuration"},{"location":"user/references/metadata/introduction/#provider-configuration","text":"The metadata stored on the Provider side is as follows: { parameters : { side : provider , methods : sayHello , dubbo : 2.0.2 , threads : 100 , interface : org.apache.dubbo.samples.metadatareport.configcenter.api.AnnotationService , threadpool : fixed , version : 1.1.1 , generic : false , revision : 1.1.1 , valid : true , application : metadatareport-configcenter-provider , default.timeout : 5000 , group : d-test , anyhost : true }, canonicalName : org.apache.dubbo.samples.metadatareport.configcenter.api.AnnotationService , codeSource : file:/Users/cvictory/workspace/work-mw/dubbo-samples/dubbo-samples-metadata-report/dubbo-samples-metadata-report-configcenter/target/classes/ , methods : [{ name : sayHello , parameterTypes : [ java.lang.String ], returnType : java.lang.String }], types : [{ type : java.lang.String , properties : { value : { type : char[] }, hash : { type : int } } }, { type : int }, { type : char }] } The Provider side stores all the parameters that the Provider service fills in to the registry, as well as the method information of the service (method name, input and output format).","title":"Provider Configuration"},{"location":"user/references/metadata/introduction/#consumer-configuration","text":"{ valid : true , side : consumer , application : metadatareport-configcenter-consumer , methods : sayHello , default.timeout : 6666 , dubbo : 2.0.2 , interface : org.apache.dubbo.samples.metadatareport.configcenter.api.AnnotationService , version : 1.1.1 , revision : 1.1.1 , group : d-test } The Consumer side stores all the parameters that the Consumer fills in to the registry. The above example is mainly a presentation of the provider side service information and consumer side service information stored in the metadata area by placing the metadata address in the Configcenter. The next two examples focus on configuring in a project: the XML mode and the annotation mode .","title":"Consumer Configuration"},{"location":"user/references/metadata/introduction/#method-2-config-project-in-properties-way","text":"Refer to the sample: dubbo-samples-metadata-report/dubbo-samples-metadata-report-local-xml.","title":"Method 2: Config project in properties way"},{"location":"user/references/metadata/introduction/#dubboproperties","text":"dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 After setting this configuration, have not to focus on others. You can also view the service information of the corresponding provider and consumer directly.","title":"dubbo.properties"},{"location":"user/references/metadata/introduction/#provider-stores","text":"{ parameters : { valid : true , async : true , side : provider , application : metadatareport-local-xml-provider , methods : sayHello , dubbo : 2.0.2 , interface : org.apache.dubbo.samples.metadatareport.local.xml.api.DemoService , generic : false , anyhost : true }, canonicalName : org.apache.dubbo.samples.metadatareport.local.xml.api.DemoService , codeSource : file:/Users/cvictory/workspace/work-mw/dubbo-samples/dubbo-samples-metadata-report/dubbo-samples-metadata-report-local-xml/target/classes/ , methods : [{ name : sayHello , parameterTypes : [ java.lang.String ], returnType : java.lang.String }], types : [{ type : int }, { type : char }, { type : java.lang.String , properties : { value : { type : char[] }, hash : { type : int } } }] }","title":"Provider stores:"},{"location":"user/references/metadata/introduction/#consumer-stores","text":"{ valid : true , side : consumer , application : metadatareport-local-xml-consumer , methods : sayHello , dubbo : 2.0.2 , interface : org.apache.dubbo.samples.metadatareport.local.xml.api.DemoService }","title":"Consumer stores:"},{"location":"user/references/metadata/introduction/#method-3-config-project-in-annotation-way","text":"Refer to the sample: dubbo-samples-metadata-report/dubbo-samples-metadata-report-local-annotaion.","title":"Method 3: Config project in annotation way"},{"location":"user/references/metadata/introduction/#bean-introduce-bean","text":"@Bean public MetadataReportConfig metadataReportConfig() { MetadataReportConfig metadataReportConfig = new MetadataReportConfig(); metadataReportConfig.setAddress( zookeeper://127.0.0.1:2181 ); return metadataReportConfig; } After introducing Bean, also have not to set others. View corresponding service information directly:","title":"@Bean introduce Bean"},{"location":"user/references/metadata/introduction/#provider-stores_1","text":"{ parameters : { side : provider , methods : sayHello , dubbo : 2.0.2 , interface : org.apache.dubbo.samples.metadatareport.local.annotation.api.AnnotationService , version : 1.1.8 , generic : false , revision : 1.1.8 , valid : true , application : metadatareport-local-annotaion-provider , default.timeout : 1000 , group : d-test , anyhost : true }, canonicalName : org.apache.dubbo.samples.metadatareport.local.annotation.api.AnnotationService , codeSource : file:/Users/cvictory/workspace/work-mw/dubbo-samples/dubbo-samples-metadata-report/dubbo-samples-metadata-report-local-annotaion/target/classes/ , methods : [{ name : sayHello , parameterTypes : [ java.lang.String ], returnType : java.lang.String }], types : [{ type : int }, { type : java.lang.String , properties : { value : { type : char[] }, hash : { type : int } } }, { type : char }] }","title":"Provider stores:"},{"location":"user/references/metadata/introduction/#consumer-stores_1","text":"{ valid : true , side : consumer , application : metadatareport-local-annotaion-consumer , methods : sayHello , dubbo : 2.0.2 , interface : org.apache.dubbo.samples.metadatareport.local.annotation.api.AnnotationService , version : 1.1.8 , revision : 1.1.8 , group : d-test }","title":"Consumer stores:"},{"location":"user/references/metadata/introduction/#extension","text":"","title":"Extension"},{"location":"user/references/metadata/introduction/#spi-definition","text":"Refer to: org.apache.dubbo.metadata.store.MetadataReportFactory, org.apache.dubbo.metadata.store.MetadataReport @SPI( redis ) public interface MetadataReportFactory { @Adaptive({ protocol }) MetadataReport getMetadataReport(URL url); }","title":"SPI Definition"},{"location":"user/references/metadata/introduction/#custom-metadata-storage","text":"Let's take Redis storage as an example to illustrate. Create a new project supporting the following modifications:","title":"Custom metadata storage"},{"location":"user/references/metadata/introduction/#extend-abstractmetadatareport","text":"public class RedisMetadataReport extends AbstractMetadataReport { private final static Logger logger = LoggerFactory.getLogger(RedisMetadataReport.class); final JedisPool pool; public RedisMetadataReport(URL url) { super(url); pool = new JedisPool(new JedisPoolConfig(), url.getHost(), url.getPort()); } @Override protected void doStoreProviderMetadata(ProviderMetadataIdentifier providerMetadataIdentifier, String serviceDefinitions) { this.storeMetadata(providerMetadataIdentifier, serviceDefinitions); } @Override protected void doStoreConsumerMetadata(ConsumerMetadataIdentifier consumerMetadataIdentifier, String value) { this.storeMetadata(consumerMetadataIdentifier, value); } private void storeMetadata(MetadataIdentifier metadataIdentifier, String v) { try (Jedis jedis = pool.getResource()) { jedis.set(metadataIdentifier.getIdentifierKey() + META_DATA_SOTRE_TAG, v); } catch (Throwable e) { logger.error( Failed to put + metadataIdentifier + to redis + v + , cause: + e.getMessage(), e); throw new RpcException( Failed to put + metadataIdentifier + to redis + v + , cause: + e.getMessage(), e); } } }","title":"Extend AbstractMetadataReport"},{"location":"user/references/metadata/introduction/#extend-abstractmetadatareportfactory","text":"public class RedisMetadataReportFactory extends AbstractMetadataReportFactory { @Override public MetadataReport createMetadataReport(URL url) { return new RedisMetadataReport(url); } }","title":"Extend AbstractMetadataReportFactory"},{"location":"user/references/metadata/introduction/#new-meta-infdubbointernalorgapachedubbometadatastoremetadatareportfactory","text":"redis=org.apache.dubbo.metadata.store.redis.RedisMetadataReportFactory As long as the above modifications along with the project are packaged into a jar, then config metadata center url: redis://10.20.153.10:6379. Up to now, a custom metadata store is ready to run.","title":"New META-INF/dubbo/internal/org.apache.dubbo.metadata.store.MetadataReportFactory"},{"location":"user/references/protocol/dubbo/","text":"dubbo:// Dubbo protocol which is the default protocol of Dubbo RPC Framework uses a single long connection and NIO asynchronous communication,it is suitable for small data but with high concurrency RPC call and the number of consumer machine is much greater than provider On the other hand, the Dubbo protocol is not suitable for transmitting large amounts of data, such as file transmission, video transmission, etc., unless the request is very low. Transporter: mina, netty, grizzy Serialization: dubbo, hessian2, java, json Dispatcher: all, direct, message, execution, connection ThreadPool: fixed, cached Features The default protocol is Dubbo protocol ,based on netty 3.2.5.Final and Hessian2 3.2.1-fixed-2(Alibaba embed version) . Default connection number: single connection Default connection mode: long connection Transmission protocol: TCP Transmission mode: NIO asynchronous transmission Serialization: Hessian2 serialization Scope of application: incoming and outgoing data packets are small (recommended less than 100K),try not to transfer large files or large strings with Dubbo protocol. Applicable scenarios:: most RPC scenarios Constraint Parameters and return values must implement Serializable interface Parameters and return values can not be customized to implement List , Map , Number , Date , Calendar interface, can only be implemented with the JDK, because Hessian2 will do some special treatment, Attribute values in the class will be lost. Hessian serialization:to solve compatibility issues, only serialize class name,all the fields declared by the class,not included static fields,method information Data transformation Cases Result A- B Class A has one more property than Class B It doesn't throw exception \uff0cClass B doesn't have Class A new property,other is normal A- B enum Class A has one more new enum than enum Class B\uff0cwhen use Class A new enum to transfor to B throw exception A- B enum Class A has one more new enum than enum Class B\uff0cwhen don't use Class A new enum to transfor to B It doesn't throw exception A- B Class A and Class B have same property name,but the property type is different throw exception A- B serialId is not same normal The interface new addition method has no effect on the client. If the method is not required by the client, the client does not need to redeploy it. The input parameter and result class add new properties, and if the client does not need new properties, it does not need to be redeployed too. The change of input parameter and result property name has no effect on client serialization, but if the client is not redeployed, no matter the input or output, the value of which property name had change is not available. Summary: the server side and the client do not need to be fully consistent with the domain objects,but you still should know about what would happen. Configuration configure protocol dubbo:protocol name= dubbo port= 20880 / configure provider level default protocol: dubbo:provider protocol= dubbo / configure service level default protocol: dubbo:service protocol= dubbo / configure multiple port\uff1a dubbo:protocol id= dubbo1 name= dubbo port= 20880 / dubbo:protocol id= dubbo2 name= dubbo port= 20881 / configure protocol options: dubbo:protocol name=\u201cdubbo\u201d port=\u201c9090\u201d server=\u201cnetty\u201d client=\u201cnetty\u201d codec=\u201cdubbo\u201d serialization=\u201chessian2\u201d charset=\u201cUTF-8\u201d threadpool=\u201cfixed\u201d threads=\u201c100\u201d queues=\u201c0\u201d iothreads=\u201c9\u201d buffer=\u201c8192\u201d accepts=\u201c1000\u201d payload=\u201c8388608\u201d / configure multiple connectios: Dubbo protocol default uses a single long connection per service per consumer for each service provider,and multiple connections can be used if the amount of data is large dubbo:protocol name= dubbo connections= 2 / dubbo:service connections=\"0\" OR dubbo:reference connections=\"0\" It means that the service uses a share long connection per provider. default dubbo:service connections=\"1\" OR dubbo:reference connections=\"1\" It means that the service uses a separate long connection. dubbo:service connections=\"2\" OR dubbo:reference connections=\"2\" It means that the service uses two separate long connection. To prevent being hung up by a large number of connections, you can limit the number of connections at the service provider side. dubbo:protocol name= dubbo accepts= 1000 / or configure in dubbo.properties \uff1a dubbo.service.protocol=dubbo","title":"dubbo://"},{"location":"user/references/protocol/dubbo/#dubbo","text":"Dubbo protocol which is the default protocol of Dubbo RPC Framework uses a single long connection and NIO asynchronous communication,it is suitable for small data but with high concurrency RPC call and the number of consumer machine is much greater than provider On the other hand, the Dubbo protocol is not suitable for transmitting large amounts of data, such as file transmission, video transmission, etc., unless the request is very low. Transporter: mina, netty, grizzy Serialization: dubbo, hessian2, java, json Dispatcher: all, direct, message, execution, connection ThreadPool: fixed, cached","title":"dubbo://"},{"location":"user/references/protocol/dubbo/#features","text":"The default protocol is Dubbo protocol ,based on netty 3.2.5.Final and Hessian2 3.2.1-fixed-2(Alibaba embed version) . Default connection number: single connection Default connection mode: long connection Transmission protocol: TCP Transmission mode: NIO asynchronous transmission Serialization: Hessian2 serialization Scope of application: incoming and outgoing data packets are small (recommended less than 100K),try not to transfer large files or large strings with Dubbo protocol. Applicable scenarios:: most RPC scenarios","title":"Features"},{"location":"user/references/protocol/dubbo/#constraint","text":"Parameters and return values must implement Serializable interface Parameters and return values can not be customized to implement List , Map , Number , Date , Calendar interface, can only be implemented with the JDK, because Hessian2 will do some special treatment, Attribute values in the class will be lost. Hessian serialization:to solve compatibility issues, only serialize class name,all the fields declared by the class,not included static fields,method information Data transformation Cases Result A- B Class A has one more property than Class B It doesn't throw exception \uff0cClass B doesn't have Class A new property,other is normal A- B enum Class A has one more new enum than enum Class B\uff0cwhen use Class A new enum to transfor to B throw exception A- B enum Class A has one more new enum than enum Class B\uff0cwhen don't use Class A new enum to transfor to B It doesn't throw exception A- B Class A and Class B have same property name,but the property type is different throw exception A- B serialId is not same normal The interface new addition method has no effect on the client. If the method is not required by the client, the client does not need to redeploy it. The input parameter and result class add new properties, and if the client does not need new properties, it does not need to be redeployed too. The change of input parameter and result property name has no effect on client serialization, but if the client is not redeployed, no matter the input or output, the value of which property name had change is not available. Summary: the server side and the client do not need to be fully consistent with the domain objects,but you still should know about what would happen.","title":"Constraint"},{"location":"user/references/protocol/dubbo/#configuration","text":"configure protocol dubbo:protocol name= dubbo port= 20880 / configure provider level default protocol: dubbo:provider protocol= dubbo / configure service level default protocol: dubbo:service protocol= dubbo / configure multiple port\uff1a dubbo:protocol id= dubbo1 name= dubbo port= 20880 / dubbo:protocol id= dubbo2 name= dubbo port= 20881 / configure protocol options: dubbo:protocol name=\u201cdubbo\u201d port=\u201c9090\u201d server=\u201cnetty\u201d client=\u201cnetty\u201d codec=\u201cdubbo\u201d serialization=\u201chessian2\u201d charset=\u201cUTF-8\u201d threadpool=\u201cfixed\u201d threads=\u201c100\u201d queues=\u201c0\u201d iothreads=\u201c9\u201d buffer=\u201c8192\u201d accepts=\u201c1000\u201d payload=\u201c8388608\u201d / configure multiple connectios: Dubbo protocol default uses a single long connection per service per consumer for each service provider,and multiple connections can be used if the amount of data is large dubbo:protocol name= dubbo connections= 2 / dubbo:service connections=\"0\" OR dubbo:reference connections=\"0\" It means that the service uses a share long connection per provider. default dubbo:service connections=\"1\" OR dubbo:reference connections=\"1\" It means that the service uses a separate long connection. dubbo:service connections=\"2\" OR dubbo:reference connections=\"2\" It means that the service uses two separate long connection. To prevent being hung up by a large number of connections, you can limit the number of connections at the service provider side. dubbo:protocol name= dubbo accepts= 1000 / or configure in dubbo.properties \uff1a dubbo.service.protocol=dubbo","title":"Configuration"},{"location":"user/references/protocol/hessian/","text":"hessian:// Hessian protocol is used for integrate Hessian services, and it use http protocol to communicate and expose services by servlet.Dubbo use Jetty server as default servlet container. Dubbo's Hessian protocol interoperates with native Hessian services: Providers use Dubbo's Hessian protocol to expose services that consumers call directly using standard Hessian interfaces Alternatively, the provider exposes the service using standard Hessian and the consumer calls it using Dubbo's Hessian protocol. Features Number of connections: multiple connections Connection: short connection Transmission protocol: HTTP Transmission: synchronous transmission Serialization: Hessian binary serialization Scope of application: Incoming and outgoing parameter packets are large, the number of providers is more than that of consumers and can transfer files. Applicable scenarios: page transfer, file transfer, or interoperability with native hessian services dependency dependency groupId com.caucho /groupId artifactId hessian /artifactId version 4.0.7 /version /dependency Constraint Parameters and return class must implement Serializable interface Parameters and return values can not be customized to implement List , Map , Number , Date , Calendar interface, can only be implemented with the JDK, because Hessian2 will do some special treatment, Attribute values in the class will be lost. Configuration configure hessian protocol\uff1a dubbo:protocol name= hessian port= 8080 server= jetty / configure provider level default protocol: dubbo:provider protocol= hessian / configure service level default protocol: dubbo:service protocol= hessian / configure multiple port\uff1a dubbo:protocol id= hessian1 name= hessian port= 8080 / dubbo:protocol id= hessian2 name= hessian port= 8081 / configure direct connect mode\uff1a dubbo:reference id= helloService interface= HelloWorld url= hessian://10.20.153.10:8080/helloWorld /","title":"hessian://"},{"location":"user/references/protocol/hessian/#hessian","text":"Hessian protocol is used for integrate Hessian services, and it use http protocol to communicate and expose services by servlet.Dubbo use Jetty server as default servlet container. Dubbo's Hessian protocol interoperates with native Hessian services: Providers use Dubbo's Hessian protocol to expose services that consumers call directly using standard Hessian interfaces Alternatively, the provider exposes the service using standard Hessian and the consumer calls it using Dubbo's Hessian protocol.","title":"hessian://"},{"location":"user/references/protocol/hessian/#features","text":"Number of connections: multiple connections Connection: short connection Transmission protocol: HTTP Transmission: synchronous transmission Serialization: Hessian binary serialization Scope of application: Incoming and outgoing parameter packets are large, the number of providers is more than that of consumers and can transfer files. Applicable scenarios: page transfer, file transfer, or interoperability with native hessian services","title":"Features"},{"location":"user/references/protocol/hessian/#dependency","text":"dependency groupId com.caucho /groupId artifactId hessian /artifactId version 4.0.7 /version /dependency","title":"dependency"},{"location":"user/references/protocol/hessian/#constraint","text":"Parameters and return class must implement Serializable interface Parameters and return values can not be customized to implement List , Map , Number , Date , Calendar interface, can only be implemented with the JDK, because Hessian2 will do some special treatment, Attribute values in the class will be lost.","title":"Constraint"},{"location":"user/references/protocol/hessian/#configuration","text":"configure hessian protocol\uff1a dubbo:protocol name= hessian port= 8080 server= jetty / configure provider level default protocol: dubbo:provider protocol= hessian / configure service level default protocol: dubbo:service protocol= hessian / configure multiple port\uff1a dubbo:protocol id= hessian1 name= hessian port= 8080 / dubbo:protocol id= hessian2 name= hessian port= 8081 / configure direct connect mode\uff1a dubbo:reference id= helloService interface= HelloWorld url= hessian://10.20.153.10:8080/helloWorld /","title":"Configuration"},{"location":"user/references/protocol/http/","text":"http:// Dubbo http protocol is base on HTTP form and Spring's HttpInvoker Features Number of connections: multiple connections Connection: short connection Transmission protocol: HTTP Transmission: synchronous transmission Serialization: form serialization Scope of application: Available browser view, the form or URL can be passed parameters, Temporary files are not supported. Applicable scenarios: Services that need to be available to both application and browser Constraint Parameters and return values must be consistent with Bean specifications Configuration configure http protocol\uff1a dubbo:protocol name= http port= 8080 / configure Jetty Server (default)\uff1a dubbo:protocol ... server= jetty / configure Servlet Bridge Server (recommend)\uff1a dubbo:protocol ... server= servlet / configure DispatcherServlet\uff1a servlet servlet-name dubbo /servlet-name servlet-class org.apache.dubbo.remoting.http.servlet.DispatcherServlet /servlet-class load-on-startup 1 /load-on-startup /servlet servlet-mapping servlet-name dubbo /servlet-name url-pattern /* /url-pattern /servlet-mapping Note that if you use servlets to dispatch requests: the port of protocol dubbo:protocol port=\"8080\" / must same as servlet container's. the context path of protocol dubbo:protocol contextpath=\"foo\" / must same as servlet application's.","title":"http://"},{"location":"user/references/protocol/http/#http","text":"Dubbo http protocol is base on HTTP form and Spring's HttpInvoker","title":"http://"},{"location":"user/references/protocol/http/#features","text":"Number of connections: multiple connections Connection: short connection Transmission protocol: HTTP Transmission: synchronous transmission Serialization: form serialization Scope of application: Available browser view, the form or URL can be passed parameters, Temporary files are not supported. Applicable scenarios: Services that need to be available to both application and browser","title":"Features"},{"location":"user/references/protocol/http/#constraint","text":"Parameters and return values must be consistent with Bean specifications","title":"Constraint"},{"location":"user/references/protocol/http/#configuration","text":"configure http protocol\uff1a dubbo:protocol name= http port= 8080 / configure Jetty Server (default)\uff1a dubbo:protocol ... server= jetty / configure Servlet Bridge Server (recommend)\uff1a dubbo:protocol ... server= servlet / configure DispatcherServlet\uff1a servlet servlet-name dubbo /servlet-name servlet-class org.apache.dubbo.remoting.http.servlet.DispatcherServlet /servlet-class load-on-startup 1 /load-on-startup /servlet servlet-mapping servlet-name dubbo /servlet-name url-pattern /* /url-pattern /servlet-mapping Note that if you use servlets to dispatch requests: the port of protocol dubbo:protocol port=\"8080\" / must same as servlet container's. the context path of protocol dubbo:protocol contextpath=\"foo\" / must same as servlet application's.","title":"Configuration"},{"location":"user/references/protocol/introduction/","text":"Protocol reference Book Dubbo protocol is recommended. The performance of each protocol, see: Performance","title":"Protocol reference Book"},{"location":"user/references/protocol/introduction/#protocol-reference-book","text":"Dubbo protocol is recommended. The performance of each protocol, see: Performance","title":"Protocol reference Book"},{"location":"user/references/protocol/memcached/","text":"memcached:// RPC protocol based on memcached implementation. Register memcached service address RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf( zookeeper://10.20.153.10:2181 )); registry.register(URL.valueOf( memcached://10.20.153.11/com.foo.BarService?category=providers dynamic=false application=foo group=member loadbalance=consistenthash )); Use in client get service reference: dubbo:reference id= cache interface= java.util.Map group= member / or direct access by IP: dubbo:reference id= cache interface= java.util.Map url= memcached://10.20.153.10:11211 / you can also use a custom interface\uff1a dubbo:reference id= cache interface= com.foo.CacheService url= memcached://10.20.153.10:11211 / The method name is the same as the standard method name of memcached, just like get(key), set(key, value), delete(key)\u3002 If the method name and the memcached standard method name are not the same, you need to configure the mapping dubbo:reference id= cache interface= com.foo.CacheService url= memcached://10.20.153.10:11211 p:set= putFoo p:get= getFoo p:delete= removeFoo /","title":"memcached://"},{"location":"user/references/protocol/memcached/#memcached","text":"RPC protocol based on memcached implementation.","title":"memcached://"},{"location":"user/references/protocol/memcached/#register-memcached-service-address","text":"RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf( zookeeper://10.20.153.10:2181 )); registry.register(URL.valueOf( memcached://10.20.153.11/com.foo.BarService?category=providers dynamic=false application=foo group=member loadbalance=consistenthash ));","title":"Register memcached service address"},{"location":"user/references/protocol/memcached/#use-in-client","text":"get service reference: dubbo:reference id= cache interface= java.util.Map group= member / or direct access by IP: dubbo:reference id= cache interface= java.util.Map url= memcached://10.20.153.10:11211 / you can also use a custom interface\uff1a dubbo:reference id= cache interface= com.foo.CacheService url= memcached://10.20.153.10:11211 / The method name is the same as the standard method name of memcached, just like get(key), set(key, value), delete(key)\u3002 If the method name and the memcached standard method name are not the same, you need to configure the mapping dubbo:reference id= cache interface= com.foo.CacheService url= memcached://10.20.153.10:11211 p:set= putFoo p:get= getFoo p:delete= removeFoo /","title":"Use in client"},{"location":"user/references/protocol/redis/","text":"redis:// RPC protocol based on redis implementation. Register redis service address RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf( zookeeper://10.20.153.10:2181 )); registry.register(URL.valueOf( redis://10.20.153.11/com.foo.BarService?category=providers dynamic=false application=foo group=member loadbalance=consistenthash )); Use in client get service reference: dubbo:reference id= store interface= java.util.Map group= member / or direct access by IP: dubbo:reference id= store interface= java.util.Map url= redis://10.20.153.10:6379 / you can also use a custom interface\uff1a dubbo:reference id= store interface= com.foo.StoreService url= redis://10.20.153.10:6379 / The method name is the same as the standard method name of memcached, just like get(key), set(key, value), delete(key)\u3002 If the method name and the memcached standard method name are not the same, you need to configure the mapping dubbo:reference id= cache interface= com.foo.CacheService url= memcached://10.20.153.10:11211 p:set= putFoo p:get= getFoo p:delete= removeFoo /","title":"redis://"},{"location":"user/references/protocol/redis/#redis","text":"RPC protocol based on redis implementation.","title":"redis://"},{"location":"user/references/protocol/redis/#register-redis-service-address","text":"RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf( zookeeper://10.20.153.10:2181 )); registry.register(URL.valueOf( redis://10.20.153.11/com.foo.BarService?category=providers dynamic=false application=foo group=member loadbalance=consistenthash ));","title":"Register redis service address"},{"location":"user/references/protocol/redis/#use-in-client","text":"get service reference: dubbo:reference id= store interface= java.util.Map group= member / or direct access by IP: dubbo:reference id= store interface= java.util.Map url= redis://10.20.153.10:6379 / you can also use a custom interface\uff1a dubbo:reference id= store interface= com.foo.StoreService url= redis://10.20.153.10:6379 / The method name is the same as the standard method name of memcached, just like get(key), set(key, value), delete(key)\u3002 If the method name and the memcached standard method name are not the same, you need to configure the mapping dubbo:reference id= cache interface= com.foo.CacheService url= memcached://10.20.153.10:11211 p:set= putFoo p:get= getFoo p:delete= removeFoo /","title":"Use in client"},{"location":"user/references/protocol/rest/","text":"rest:// \u57fa\u4e8e\u6807\u51c6\u7684Java REST API\u2014\u2014JAX-RS 2.0\uff08Java API for RESTful Web Services\u7684\u7b80\u5199\uff09\u5b9e\u73b0\u7684REST\u8c03\u7528\u652f\u6301 \u5feb\u901f\u5165\u95e8 \u5728dubbo\u4e2d\u5f00\u53d1\u4e00\u4e2aREST\u98ce\u683c\u7684\u670d\u52a1\u4f1a\u6bd4\u8f83\u7b80\u5355\uff0c\u4e0b\u9762\u4ee5\u4e00\u4e2a\u6ce8\u518c\u7528\u6237\u7684\u7b80\u5355\u670d\u52a1\u4e3a\u4f8b\u8bf4\u660e\u3002 \u8fd9\u4e2a\u670d\u52a1\u8981\u5b9e\u73b0\u7684\u529f\u80fd\u662f\u63d0\u4f9b\u5982\u4e0bURL\uff08\u6ce8\uff1a\u8fd9\u4e2aURL\u4e0d\u662f\u5b8c\u5168\u7b26\u5408REST\u7684\u98ce\u683c\uff0c\u4f46\u662f\u66f4\u7b80\u5355\u5b9e\u7528\uff09\uff1a http://localhost:8080/users/register \u800c\u4efb\u4f55\u5ba2\u6237\u7aef\u90fd\u53ef\u4ee5\u5c06\u5305\u542b\u7528\u6237\u4fe1\u606f\u7684JSON\u5b57\u7b26\u4e32POST\u5230\u4ee5\u4e0aURL\u6765\u5b8c\u6210\u7528\u6237\u6ce8\u518c\u3002 \u9996\u5148\uff0c\u5f00\u53d1\u670d\u52a1\u7684\u63a5\u53e3\uff1a public class UserService { void registerUser(User user); } \u7136\u540e\uff0c\u5f00\u53d1\u670d\u52a1\u7684\u5b9e\u73b0\uff1a @Path( users ) public class UserServiceImpl implements UserService { @POST @Path( register ) @Consumes({MediaType.APPLICATION_JSON}) public void registerUser(User user) { // save the user... } } \u4e0a\u9762\u7684\u5b9e\u73b0\u975e\u5e38\u7b80\u5355\uff0c\u4f46\u662f\u7531\u4e8e\u8be5 REST \u670d\u52a1\u662f\u8981\u53d1\u5e03\u5230\u6307\u5b9a URL \u4e0a\uff0c\u4f9b\u4efb\u610f\u8bed\u8a00\u7684\u5ba2\u6237\u7aef\u751a\u81f3\u6d4f\u89c8\u5668\u6765\u8bbf\u95ee\uff0c\u6240\u4ee5\u8fd9\u91cc\u989d\u5916\u6dfb\u52a0\u4e86\u51e0\u4e2a JAX-RS \u7684\u6807\u51c6 annotation \u6765\u505a\u76f8\u5173\u7684\u914d\u7f6e\u3002 @Path(\"users\")\uff1a\u6307\u5b9a\u8bbf\u95eeUserService\u7684URL\u76f8\u5bf9\u8def\u5f84\u662f/users\uff0c\u5373http://localhost:8080/users @Path(\"register\")\uff1a\u6307\u5b9a\u8bbf\u95eeregisterUser()\u65b9\u6cd5\u7684URL\u76f8\u5bf9\u8def\u5f84\u662f/register\uff0c\u518d\u7ed3\u5408\u4e0a\u4e00\u4e2a@Path\u4e3aUserService\u6307\u5b9a\u7684\u8def\u5f84\uff0c\u5219\u8c03\u7528UserService.register()\u7684\u5b8c\u6574\u8def\u5f84\u4e3ahttp://localhost:8080/users/register @POST\uff1a\u6307\u5b9a\u8bbf\u95eeregisterUser()\u7528HTTP POST\u65b9\u6cd5 @Consumes({MediaType.APPLICATION_JSON})\uff1a\u6307\u5b9aregisterUser()\u63a5\u6536JSON\u683c\u5f0f\u7684\u6570\u636e\u3002REST\u6846\u67b6\u4f1a\u81ea\u52a8\u5c06JSON\u6570\u636e\u53cd\u5e8f\u5217\u5316\u4e3aUser\u5bf9\u8c61 \u6700\u540e\uff0c\u5728spring\u914d\u7f6e\u6587\u4ef6\u4e2d\u6dfb\u52a0\u6b64\u670d\u52a1\uff0c\u5373\u5b8c\u6210\u6240\u6709\u670d\u52a1\u5f00\u53d1\u5de5\u4f5c\uff1a ```xml ## REST\u670d\u52a1\u63d0\u4f9b\u7aef\u8be6\u89e3 \u4e0b\u9762\u6211\u4eec\u6269\u5145\u201c\u5feb\u901f\u5165\u95e8\u201d\u4e2d\u7684UserService\uff0c\u8fdb\u4e00\u6b65\u5c55\u793a\u5728dubbo\u4e2dREST\u670d\u52a1\u63d0\u4f9b\u7aef\u7684\u5f00\u53d1\u8981\u70b9\u3002 ### HTTP POST/GET\u7684\u5b9e\u73b0 REST\u670d\u52a1\u4e2d\u867d\u7136\u5efa\u8bae\u4f7f\u7528HTTP\u534f\u8bae\u4e2d\u56db\u79cd\u6807\u51c6\u65b9\u6cd5POST\u3001DELETE\u3001PUT\u3001GET\u6765\u5206\u522b\u5b9e\u73b0\u5e38\u89c1\u7684\u201c\u589e\u5220\u6539\u67e5\u201d\uff0c\u4f46\u5b9e\u9645\u4e2d\uff0c\u6211\u4eec\u4e00\u822c\u60c5\u51b5\u76f4\u63a5\u7528POST\u6765\u5b9e\u73b0\u201c\u589e\u6539\u201d\uff0cGET\u6765\u5b9e\u73b0\u201c\u5220\u67e5\u201d\u5373\u53ef\uff08DELETE\u548cPUT\u751a\u81f3\u4f1a\u88ab\u4e00\u4e9b\u9632\u706b\u5899\u963b\u6321\uff09\u3002 \u524d\u9762\u5df2\u7ecf\u7b80\u5355\u6f14\u793a\u4e86POST\u7684\u5b9e\u73b0\uff0c\u5728\u6b64\uff0c\u6211\u4eec\u4e3aUserService\u6dfb\u52a0\u4e00\u4e2a\u83b7\u53d6\u6ce8\u518c\u7528\u6237\u8d44\u6599\u7684\u529f\u80fd\uff0c\u6765\u6f14\u793aGET\u7684\u5b9e\u73b0\u3002 \u8fd9\u4e2a\u529f\u80fd\u5c31\u662f\u8981\u5b9e\u73b0\u5ba2\u6237\u7aef\u901a\u8fc7\u8bbf\u95ee\u5982\u4e0b\u4e0d\u540cURL\u6765\u83b7\u53d6\u4e0d\u540cID\u7684\u7528\u6237\u8d44\u6599\uff1a http://localhost:8080/users/1001 http://localhost:8080/users/1002 http://localhost:8080/users/1003 \u5f53\u7136\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u5176\u4ed6\u5f62\u5f0f\u7684URL\u6765\u8bbf\u95ee\u4e0d\u540cID\u7684\u7528\u6237\u8d44\u6599\uff0c\u4f8b\u5982\uff1a http://localhost:8080/users/load?id=1001 JAX-RS\u672c\u8eab\u53ef\u4ee5\u652f\u6301\u6240\u6709\u8fd9\u4e9b\u5f62\u5f0f\u3002\u4f46\u662f\u4e0a\u9762\u90a3\u79cd\u5728URL\u8def\u5f84\u4e2d\u5305\u542b\u67e5\u8be2\u53c2\u6570\u7684\u5f62\u5f0f\uff08http://localhost:8080/users/1001\uff09 \u66f4\u7b26\u5408REST\u7684\u4e00\u822c\u4e60\u60ef\uff0c\u6240\u4ee5\u66f4\u63a8\u8350\u5927\u5bb6\u6765\u4f7f\u7528\u3002\u4e0b\u9762\u6211\u4eec\u5c31\u4e3aUserService\u6dfb\u52a0\u4e00\u4e2agetUser()\u65b9\u6cd5\u6765\u5b9e\u73b0\u8fd9\u79cd\u5f62\u5f0f\u7684URL\u8bbf\u95ee\uff1a ```java @GET @Path( {id : \\\\d+} ) @Produces({MediaType.APPLICATION_JSON}) public User getUser(@PathParam( id ) Long id) { // ... } @GET\uff1a\u6307\u5b9a\u7528HTTP GET\u65b9\u6cd5\u8bbf\u95ee @Path(\"{id : \\d+}\")\uff1a\u6839\u636e\u4e0a\u9762\u7684\u529f\u80fd\u9700\u6c42\uff0c\u8bbf\u95eegetUser()\u7684URL\u5e94\u5f53\u662f\u201chttp://localhost:8080/users/ + \u4efb\u610f\u6570\u5b57\"\uff0c\u5e76\u4e14\u8fd9\u4e2a\u6570\u5b57\u8981\u88ab\u505a\u4e3a\u53c2\u6570\u4f20\u5165getUser()\u65b9\u6cd5\u3002 \u8fd9\u91cc\u7684annotation\u914d\u7f6e\u4e2d\uff0c@Path\u4e2d\u95f4\u7684{id: xxx}\u6307\u5b9aURL\u76f8\u5bf9\u8def\u5f84\u4e2d\u5305\u542b\u4e86\u540d\u4e3aid\u53c2\u6570\uff0c\u800c\u5b83\u7684\u503c\u4e5f\u5c06\u88ab\u81ea\u52a8\u4f20\u9012\u7ed9\u4e0b\u9762\u7528@PathParam(\"id\")\u4fee\u9970\u7684\u65b9\u6cd5\u53c2\u6570id\u3002{id:\u540e\u9762\u7d27\u8ddf\u7684\\d+\u662f\u4e00\u4e2a\u6b63\u5219\u8868\u8fbe\u5f0f\uff0c\u6307\u5b9a\u4e86id\u53c2\u6570\u5fc5\u987b\u662f\u6570\u5b57\u3002 @Produces({MediaType.APPLICATION_JSON})\uff1a\u6307\u5b9agetUser()\u8f93\u51faJSON\u683c\u5f0f\u7684\u6570\u636e\u3002\u6846\u67b6\u4f1a\u81ea\u52a8\u5c06User\u5bf9\u8c61\u5e8f\u5217\u5316\u4e3aJSON\u6570\u636e\u3002 Annotation\u653e\u5728\u63a5\u53e3\u7c7b\u8fd8\u662f\u5b9e\u73b0\u7c7b \u5728Dubbo\u4e2d\u5f00\u53d1REST\u670d\u52a1\u4e3b\u8981\u90fd\u662f\u901a\u8fc7JAX-RS\u7684annotation\u6765\u5b8c\u6210\u914d\u7f6e\u7684\uff0c\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u6211\u4eec\u90fd\u662f\u5c06annotation\u653e\u5728\u670d\u52a1\u7684\u5b9e\u73b0\u7c7b\u4e2d\u3002\u4f46\u5176\u5b9e\uff0c\u6211\u4eec\u5b8c\u5168\u4e5f\u53ef\u4ee5\u5c06annotation\u653e\u5230\u670d\u52a1\u7684\u63a5\u53e3\u4e0a\uff0c\u8fd9\u4e24\u79cd\u65b9\u5f0f\u662f\u5b8c\u5168\u7b49\u4ef7\u7684\uff0c\u4f8b\u5982\uff1a @Path( users ) public interface UserService { @GET @Path( {id : \\\\d+} ) @Produces({MediaType.APPLICATION_JSON}) User getUser(@PathParam( id ) Long id); } \u5728\u4e00\u822c\u5e94\u7528\u4e2d\uff0c\u6211\u4eec\u5efa\u8bae\u5c06annotation\u653e\u5230\u670d\u52a1\u5b9e\u73b0\u7c7b\uff0c\u8fd9\u6837annotation\u548cjava\u5b9e\u73b0\u4ee3\u7801\u4f4d\u7f6e\u66f4\u63a5\u8fd1\uff0c\u66f4\u4fbf\u4e8e\u5f00\u53d1\u548c\u7ef4\u62a4\u3002\u53e6\u5916\u66f4\u91cd\u8981\u7684\u662f\uff0c\u6211\u4eec\u4e00\u822c\u503e\u5411\u4e8e\u907f\u514d\u5bf9\u63a5\u53e3\u7684\u6c61\u67d3\uff0c\u4fdd\u6301\u63a5\u53e3\u7684\u7eaf\u51c0\u6027\u548c\u5e7f\u6cdb\u9002\u7528\u6027\u3002 \u4f46\u662f\uff0c\u5982\u540e\u6587\u6240\u8ff0\uff0c\u5982\u679c\u6211\u4eec\u8981\u7528dubbo\u76f4\u63a5\u5f00\u53d1\u7684\u6d88\u8d39\u7aef\u6765\u8bbf\u95ee\u6b64\u670d\u52a1\uff0c\u5219annotation\u5fc5\u987b\u653e\u5230\u63a5\u53e3\u4e0a\u3002 \u5982\u679c\u63a5\u53e3\u548c\u5b9e\u73b0\u7c7b\u90fd\u540c\u65f6\u6dfb\u52a0\u4e86annotation\uff0c\u5219\u5b9e\u73b0\u7c7b\u7684annotation\u914d\u7f6e\u4f1a\u751f\u6548\uff0c\u63a5\u53e3\u4e0a\u7684annotation\u88ab\u76f4\u63a5\u5ffd\u7565\u3002 JSON\u3001XML\u7b49\u591a\u6570\u636e\u683c\u5f0f\u7684\u652f\u6301 \u5728dubbo\u4e2d\u5f00\u53d1\u7684REST\u670d\u52a1\u53ef\u4ee5\u540c\u65f6\u652f\u6301\u4f20\u8f93\u591a\u79cd\u683c\u5f0f\u7684\u6570\u636e\uff0c\u4ee5\u7ed9\u5ba2\u6237\u7aef\u63d0\u4f9b\u6700\u5927\u7684\u7075\u6d3b\u6027\u3002\u5176\u4e2d\u6211\u4eec\u76ee\u524d\u5bf9\u6700\u5e38\u7528\u7684JSON\u548cXML\u683c\u5f0f\u7279\u522b\u6dfb\u52a0\u4e86\u989d\u5916\u7684\u529f\u80fd\u3002 \u6bd4\u5982\uff0c\u6211\u4eec\u8981\u8ba9\u4e0a\u4f8b\u4e2d\u7684getUser()\u65b9\u6cd5\u652f\u6301\u5206\u522b\u8fd4\u56deJSON\u548cXML\u683c\u5f0f\u7684\u6570\u636e\uff0c\u53ea\u9700\u8981\u5728annotation\u4e2d\u540c\u65f6\u5305\u542b\u4e24\u79cd\u683c\u5f0f\u5373\u53ef\uff1a @Produces({MediaType.APPLICATION_JSON, MediaType.TEXT_XML}) User getUser(@PathParam( id ) Long id); \u6216\u8005\u4e5f\u53ef\u4ee5\u76f4\u63a5\u7528\u5b57\u7b26\u4e32\uff08\u8fd8\u652f\u6301\u901a\u914d\u7b26\uff09\u8868\u793aMediaType\uff1a @Produces({ application/json , text/xml }) User getUser(@PathParam( id ) Long id); \u5982\u679c\u6240\u6709\u65b9\u6cd5\u90fd\u652f\u6301\u540c\u6837\u7c7b\u578b\u7684\u8f93\u5165\u8f93\u51fa\u6570\u636e\u683c\u5f0f\uff0c\u5219\u6211\u4eec\u65e0\u9700\u5728\u6bcf\u4e2a\u65b9\u6cd5\u4e0a\u505a\u914d\u7f6e\uff0c\u53ea\u9700\u8981\u5728\u670d\u52a1\u7c7b\u4e0a\u6dfb\u52a0annotation\u5373\u53ef\uff1a @Path( users ) @Consumes({MediaType.APPLICATION_JSON, MediaType.TEXT_XML}) @Produces({MediaType.APPLICATION_JSON, MediaType.TEXT_XML}) public class UserServiceImpl implements UserService { // ... } \u5728\u4e00\u4e2aREST\u670d\u52a1\u540c\u65f6\u5bf9\u591a\u79cd\u6570\u636e\u683c\u5f0f\u652f\u6301\u7684\u60c5\u51b5\u4e0b\uff0c\u6839\u636eJAX-RS\u6807\u51c6\uff0c\u4e00\u822c\u662f\u901a\u8fc7HTTP\u4e2d\u7684MIME header\uff08content-type\u548caccept\uff09\u6765\u6307\u5b9a\u5f53\u524d\u60f3\u7528\u7684\u662f\u54ea\u79cd\u683c\u5f0f\u7684\u6570\u636e\u3002 \u4f46\u662f\u5728dubbo\u4e2d\uff0c\u6211\u4eec\u8fd8\u81ea\u52a8\u652f\u6301\u76ee\u524d\u4e1a\u754c\u666e\u904d\u4f7f\u7528\u7684\u65b9\u5f0f\uff0c\u5373\u7528\u4e00\u4e2aURL\u540e\u7f00\uff08.json\u548c.xml\uff09\u6765\u6307\u5b9a\u60f3\u7528\u7684\u6570\u636e\u683c\u5f0f\u3002\u4f8b\u5982\uff0c\u5728\u6dfb\u52a0\u4e0a\u8ff0annotation\u540e\uff0c\u76f4\u63a5\u8bbf\u95eehttp://localhost:8888/users/1001.json\u5219\u8868\u793a\u7528json\u683c\u5f0f\uff0c\u76f4\u63a5\u8bbf\u95eehttp://localhost:8888/users/1002.xml\u5219\u8868\u793a\u7528xml\u683c\u5f0f\uff0c\u6bd4\u7528HTTP Header\u66f4\u7b80\u5355\u76f4\u89c2\u3002Twitter\u3001\u5fae\u535a\u7b49\u7684REST API\u90fd\u662f\u91c7\u7528\u8fd9\u79cd\u65b9\u5f0f\u3002 \u5982\u679c\u4f60\u65e2\u4e0d\u52a0HTTP header\uff0c\u4e5f\u4e0d\u52a0\u540e\u7f00\uff0c\u5219dubbo\u7684REST\u4f1a\u4f18\u5148\u542f\u7528\u5728\u4ee5\u4e0aannotation\u5b9a\u4e49\u4e2d\u6392\u4f4d\u6700\u9760\u524d\u7684\u90a3\u79cd\u6570\u636e\u683c\u5f0f\u3002 \u6ce8\u610f\uff1a\u8fd9\u91cc\u8981\u652f\u6301XML\u683c\u5f0f\u6570\u636e\uff0c\u5728annotation\u4e2d\u65e2\u53ef\u4ee5\u7528MediaType.TEXT_XML\uff0c\u4e5f\u53ef\u4ee5\u7528MediaType.APPLICATION_XML\uff0c\u4f46\u662fTEXT_XML\u662f\u66f4\u5e38\u7528\u7684\uff0c\u5e76\u4e14\u5982\u679c\u8981\u5229\u7528\u4e0a\u8ff0\u7684URL\u540e\u7f00\u65b9\u5f0f\u6765\u6307\u5b9a\u6570\u636e\u683c\u5f0f\uff0c\u53ea\u80fd\u914d\u7f6e\u4e3aTEXT_XML\u624d\u80fd\u751f\u6548\u3002 \u4e2d\u6587\u5b57\u7b26\u652f\u6301 \u4e3a\u4e86\u5728dubbo REST\u4e2d\u6b63\u5e38\u8f93\u51fa\u4e2d\u6587\u5b57\u7b26\uff0c\u548c\u901a\u5e38\u7684Java web\u5e94\u7528\u4e00\u6837\uff0c\u6211\u4eec\u9700\u8981\u5c06HTTP\u54cd\u5e94\u7684contentType\u8bbe\u7f6e\u4e3aUTF-8\u7f16\u7801\u3002 \u57fa\u4e8eJAX-RS\u7684\u6807\u51c6\u7528\u6cd5\uff0c\u6211\u4eec\u53ea\u9700\u8981\u505a\u5982\u4e0bannotation\u914d\u7f6e\u5373\u53ef\uff1a @Produces({ application/json; charset=UTF-8 , text/xml; charset=UTF-8 }) User getUser(@PathParam( id ) Long id); \u4e3a\u4e86\u65b9\u4fbf\u7528\u6237\uff0c\u6211\u4eec\u5728dubbo REST\u4e2d\u76f4\u63a5\u6dfb\u52a0\u4e86\u4e00\u4e2a\u652f\u6301\u7c7b\uff0c\u6765\u5b9a\u4e49\u4ee5\u4e0a\u7684\u5e38\u91cf\uff0c\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\uff0c\u51cf\u5c11\u51fa\u9519\u7684\u53ef\u80fd\u6027\u3002 @Produces({ContentType.APPLICATION_JSON_UTF_8, ContentType.TEXT_XML_UTF_8}) User getUser(@PathParam( id ) Long id); XML\u6570\u636e\u683c\u5f0f\u7684\u989d\u5916\u8981\u6c42 \u7531\u4e8eJAX-RS\u7684\u5b9e\u73b0\u4e00\u822c\u90fd\u7528\u6807\u51c6\u7684JAXB\uff08Java API for XML Binding\uff09\u6765\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316XML\u683c\u5f0f\u6570\u636e\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4e3a\u6bcf\u4e00\u4e2a\u8981\u7528XML\u4f20\u8f93\u7684\u5bf9\u8c61\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u7ea7\u522b\u7684JAXB annotation\uff0c\u5426\u5219\u5e8f\u5217\u5316\u5c06\u62a5\u9519\u3002\u4f8b\u5982\u4e3agetUser()\u4e2d\u8fd4\u56de\u7684User\u6dfb\u52a0\u5982\u4e0b\uff1a @XmlRootElement public class User implements Serializable { // ... } \u6b64\u5916\uff0c\u5982\u679cservice\u65b9\u6cd5\u4e2d\u7684\u8fd4\u56de\u503c\u662fJava\u7684 primitive\u7c7b\u578b\uff08\u5982int\uff0clong\uff0cfloat\uff0cdouble\u7b49\uff09\uff0c\u6700\u597d\u4e3a\u5b83\u4eec\u6dfb\u52a0\u4e00\u5c42wrapper\u5bf9\u8c61\uff0c\u56e0\u4e3aJAXB\u4e0d\u80fd\u76f4\u63a5\u5e8f\u5217\u5316primitive\u7c7b\u578b\u3002 \u4f8b\u5982\uff0c\u6211\u4eec\u60f3\u8ba9\u524d\u8ff0\u7684registerUser()\u65b9\u6cd5\u8fd4\u56de\u670d\u52a1\u5668\u7aef\u4e3a\u7528\u6237\u751f\u6210\u7684ID\u53f7\uff1a long registerUser(User user); \u7531\u4e8eprimitive\u7c7b\u578b\u4e0d\u88abJAXB\u5e8f\u5217\u5316\u652f\u6301\uff0c\u6240\u4ee5\u6dfb\u52a0\u4e00\u4e2awrapper\u5bf9\u8c61\uff1a @XmlRootElement public class RegistrationResult implements Serializable { private Long id; public RegistrationResult() { } public RegistrationResult(Long id) { this.id = id; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } } \u5e76\u4fee\u6539service\u65b9\u6cd5\uff1a RegistrationResult registerUser(User user); \u8fd9\u6837\u4e0d\u4f46\u80fd\u591f\u89e3\u51b3XML\u5e8f\u5217\u5316\u7684\u95ee\u9898\uff0c\u800c\u4e14\u4f7f\u5f97\u8fd4\u56de\u7684\u6570\u636e\u90fd\u7b26\u5408XML\u548cJSON\u7684\u89c4\u8303\u3002\u4f8b\u5982\uff0c\u5728JSON\u4e2d\uff0c\u8fd4\u56de\u7684\u5c06\u662f\u5982\u4e0b\u5f62\u5f0f\uff1a { id : 1001} \u5982\u679c\u4e0d\u52a0wrapper\uff0cJSON\u8fd4\u56de\u503c\u5c06\u76f4\u63a5\u662f 1001 \u800c\u5728XML\u4e2d\uff0c\u52a0wrapper\u540e\u8fd4\u56de\u503c\u5c06\u662f\uff1a registrationResult id 1002 /id /registrationResult \u8fd9\u79cdwrapper\u5bf9\u8c61\u5176\u5b9e\u5229\u7528\u6240\u8c13Data Transfer Object\uff08DTO\uff09\u6a21\u5f0f\uff0c\u91c7\u7528DTO\u8fd8\u80fd\u5bf9\u4f20\u8f93\u6570\u636e\u505a\u66f4\u591a\u6709\u7528\u7684\u5b9a\u5236\u3002 \u5b9a\u5236\u5e8f\u5217\u5316 \u5982\u4e0a\u6240\u8ff0\uff0cREST\u7684\u5e95\u5c42\u5b9e\u73b0\u4f1a\u5728service\u7684\u5bf9\u8c61\u548cJSON/XML\u6570\u636e\u683c\u5f0f\u4e4b\u95f4\u81ea\u52a8\u505a\u5e8f\u5217\u5316/\u53cd\u5e8f\u5217\u5316\u3002\u4f46\u6709\u4e9b\u573a\u666f\u4e0b\uff0c\u5982\u679c\u89c9\u5f97\u8fd9\u79cd\u81ea\u52a8\u8f6c\u6362\u4e0d\u6ee1\u8db3\u8981\u6c42\uff0c\u53ef\u4ee5\u5bf9\u5176\u505a\u5b9a\u5236\u3002 Dubbo\u4e2d\u7684REST\u5b9e\u73b0\u662f\u7528JAXB\u505aXML\u5e8f\u5217\u5316\uff0c\u7528Jackson\u505aJSON\u5e8f\u5217\u5316\uff0c\u6240\u4ee5\u5728\u5bf9\u8c61\u4e0a\u6dfb\u52a0JAXB\u6216Jackson\u7684annotation\u5373\u53ef\u4ee5\u5b9a\u5236\u6620\u5c04\u3002 \u4f8b\u5982\uff0c\u5b9a\u5236\u5bf9\u8c61\u5c5e\u6027\u6620\u5c04\u5230XML\u5143\u7d20\u7684\u540d\u5b57\uff1a @XmlRootElement @XmlAccessorType(XmlAccessType.FIELD) public class User implements Serializable { @XmlElement(name= username ) private String name; } \u5b9a\u5236\u5bf9\u8c61\u5c5e\u6027\u6620\u5c04\u5230JSON\u5b57\u6bb5\u7684\u540d\u5b57\uff1a public class User implements Serializable { @JsonProperty( username ) private String name; } \u66f4\u591a\u8d44\u6599\u8bf7\u53c2\u8003JAXB\u548cJackson\u7684\u5b98\u65b9\u6587\u6863\uff0c\u6216\u81ea\u884cgoogle\u3002 \u914d\u7f6eREST Server\u7684\u5b9e\u73b0 \u76ee\u524d\u5728dubbo\u4e2d\uff0c\u6211\u4eec\u652f\u63015\u79cd\u5d4c\u5165\u5f0frest server\u7684\u5b9e\u73b0\uff0c\u5e76\u540c\u65f6\u652f\u6301\u91c7\u7528\u5916\u90e8\u5e94\u7528\u670d\u52a1\u5668\u6765\u505arest server\u7684\u5b9e\u73b0\u3002rest server\u53ef\u4ee5\u901a\u8fc7\u5982\u4e0b\u914d\u7f6e\u5b9e\u73b0\uff1a dubbo:protocol name= rest server= jetty / \u4ee5\u4e0a\u914d\u7f6e\u9009\u7528\u4e86\u5d4c\u5165\u5f0f\u7684jetty\u6765\u505arest server\uff0c\u540c\u65f6\uff0c\u5982\u679c\u4e0d\u914d\u7f6eserver\u5c5e\u6027\uff0crest\u534f\u8bae\u9ed8\u8ba4\u4e5f\u662f\u9009\u7528jetty\u3002jetty\u662f\u975e\u5e38\u6210\u719f\u7684java servlet\u5bb9\u5668\uff0c\u5e76\u548cdubbo\u5df2\u7ecf\u6709\u8f83\u597d\u7684\u96c6\u6210\uff08\u76ee\u524d5\u79cd\u5d4c\u5165\u5f0fserver\u4e2d\u53ea\u6709jetty\u548c\u540e\u9762\u6240\u8ff0\u7684tomcat\u3001tjws\uff0c\u4e0edubbo\u76d1\u63a7\u7cfb\u7edf\u7b49\u5b8c\u6210\u4e86\u65e0\u7f1d\u7684\u96c6\u6210\uff09\uff0c\u6240\u4ee5\uff0c\u5982\u679c\u4f60\u7684dubbo\u7cfb\u7edf\u662f\u5355\u72ec\u542f\u52a8\u7684\u8fdb\u7a0b\uff0c\u4f60\u53ef\u4ee5\u76f4\u63a5\u9ed8\u8ba4\u91c7\u7528jetty\u5373\u53ef\u3002 dubbo:protocol name= rest server= tomcat / \u4ee5\u4e0a\u914d\u7f6e\u9009\u7528\u4e86\u5d4c\u5165\u5f0f\u7684tomcat\u6765\u505arest server\u3002\u5728\u5d4c\u5165\u5f0ftomcat\u4e0a\uff0cREST\u7684\u6027\u80fd\u6bd4jetty\u4e0a\u8981\u597d\u5f97\u591a\uff08\u53c2\u89c1\u540e\u9762\u7684\u57fa\u51c6\u6d4b\u8bd5\uff09\uff0c\u5efa\u8bae\u5728\u9700\u8981\u9ad8\u6027\u80fd\u7684\u573a\u666f\u4e0b\u91c7\u7528tomcat\u3002 dubbo:protocol name= rest server= netty / \u4ee5\u4e0a\u914d\u7f6e\u9009\u7528\u5d4c\u5165\u5f0f\u7684netty\u6765\u505arest server\u3002\uff08TODO more contents to add\uff09 dubbo:protocol name= rest server= tjws / (tjws is now deprecated) dubbo:protocol name= rest server= sunhttp / \u4ee5\u4e0a\u914d\u7f6e\u9009\u7528\u5d4c\u5165\u5f0f\u7684tjws\u6216Sun HTTP server\u6765\u505arest server\u3002\u8fd9\u4e24\u4e2aserver\u5b9e\u73b0\u975e\u5e38\u8f7b\u91cf\u7ea7\uff0c\u975e\u5e38\u65b9\u4fbf\u5728\u96c6\u6210\u6d4b\u8bd5\u4e2d\u5feb\u901f\u542f\u52a8\u4f7f\u7528\uff0c\u5f53\u7136\u4e5f\u53ef\u4ee5\u5728\u8d1f\u8377\u4e0d\u9ad8\u7684\u751f\u4ea7\u73af\u5883\u4e2d\u4f7f\u7528\u3002 \u6ce8\uff1atjws\u76ee\u524d\u5df2\u7ecf\u88abdeprecated\u6389\u4e86\uff0c\u56e0\u4e3a\u5b83\u4e0d\u80fd\u5f88\u597d\u7684\u548cservlet 3.1 API\u5de5\u4f5c\u3002 \u5982\u679c\u4f60\u7684dubbo\u7cfb\u7edf\u4e0d\u662f\u5355\u72ec\u542f\u52a8\u7684\u8fdb\u7a0b\uff0c\u800c\u662f\u90e8\u7f72\u5230\u4e86Java\u5e94\u7528\u670d\u52a1\u5668\u4e2d\uff0c\u5219\u5efa\u8bae\u4f60\u91c7\u7528\u4ee5\u4e0b\u914d\u7f6e\uff1a dubbo:protocol name= rest server= servlet / \u901a\u8fc7\u5c06server\u8bbe\u7f6e\u4e3aservlet\uff0cdubbo\u5c06\u91c7\u7528\u5916\u90e8\u5e94\u7528\u670d\u52a1\u5668\u7684servlet\u5bb9\u5668\u6765\u505arest server\u3002\u540c\u65f6\uff0c\u8fd8\u8981\u5728dubbo\u7cfb\u7edf\u7684web.xml\u4e2d\u6dfb\u52a0\u5982\u4e0b\u914d\u7f6e\uff1a web-app context-param param-name contextConfigLocation /param-name param-value /WEB-INF/classes/META-INF/spring/dubbo-demo-provider.xml /param-value /context-param listener listener-class org.apache.dubbo.remoting.http.servlet.BootstrapListener /listener-class /listener listener listener-class org.springframework.web.context.ContextLoaderListener /listener-class /listener servlet servlet-name dispatcher /servlet-name servlet-class org.apache.dubbo.remoting.http.servlet.DispatcherServlet /servlet-class load-on-startup 1 /load-on-startup /servlet servlet-mapping servlet-name dispatcher /servlet-name url-pattern /* /url-pattern /servlet-mapping /web-app \u5373\u5fc5\u987b\u5c06dubbo\u7684BootstrapListener\u548cDispatherServlet\u6dfb\u52a0\u5230web.xml\uff0c\u4ee5\u5b8c\u6210dubbo\u7684REST\u529f\u80fd\u4e0e\u5916\u90e8servlet\u5bb9\u5668\u7684\u96c6\u6210\u3002 \u6ce8\u610f\uff1a\u5982\u679c\u4f60\u662f\u7528spring\u7684ContextLoaderListener\u6765\u52a0\u8f7dspring\uff0c\u5219\u5fc5\u987b\u4fdd\u8bc1BootstrapListener\u914d\u7f6e\u5728ContextLoaderListener\u4e4b\u524d\uff0c\u5426\u5219dubbo\u521d\u59cb\u5316\u4f1a\u51fa\u9519\u3002 \u5176\u5b9e\uff0c\u8fd9\u79cd\u573a\u666f\u4e0b\u4f60\u4f9d\u7136\u53ef\u4ee5\u575a\u6301\u7528\u5d4c\u5165\u5f0fserver\uff0c\u4f46\u5916\u90e8\u5e94\u7528\u670d\u52a1\u5668\u7684servlet\u5bb9\u5668\u5f80\u5f80\u6bd4\u5d4c\u5165\u5f0fserver\u66f4\u52a0\u5f3a\u5927\uff08\u7279\u522b\u662f\u5982\u679c\u4f60\u662f\u90e8\u7f72\u5230\u66f4\u5065\u58ee\u66f4\u53ef\u4f38\u7f29\u7684WebLogic\uff0cWebSphere\u7b49\uff09\uff0c\u53e6\u5916\u6709\u65f6\u4e5f\u4fbf\u4e8e\u5728\u5e94\u7528\u670d\u52a1\u5668\u505a\u7edf\u4e00\u7ba1\u7406\u3001\u76d1\u63a7\u7b49\u7b49\u3002 \u83b7\u53d6\u4e0a\u4e0b\u6587\uff08Context\uff09\u4fe1\u606f \u5728\u8fdc\u7a0b\u8c03\u7528\u4e2d\uff0c\u503c\u5f97\u83b7\u53d6\u7684\u4e0a\u4e0b\u6587\u4fe1\u606f\u53ef\u80fd\u6709\u5f88\u591a\u79cd\uff0c\u8fd9\u91cc\u7279\u522b\u4ee5\u83b7\u53d6\u5ba2\u6237\u7aefIP\u4e3a\u4f8b\u3002 \u5728dubbo\u7684REST\u4e2d\uff0c\u6211\u4eec\u6709\u4e24\u79cd\u65b9\u5f0f\u83b7\u53d6\u5ba2\u6237\u7aefIP\u3002 \u7b2c\u4e00\u79cd\u65b9\u5f0f\uff0c\u7528JAX-RS\u6807\u51c6\u7684@Context annotation\uff1a public User getUser(@PathParam( id ) Long id, @Context HttpServletRequest request) { System.out.println( Client address is + request.getRemoteAddr()); } \u7528Context\u4fee\u9970getUser()\u7684\u4e00\u4e2a\u65b9\u6cd5\u53c2\u6570\u540e\uff0c\u5c31\u53ef\u4ee5\u5c06\u5f53\u524d\u7684HttpServletRequest\u6ce8\u5165\u8fdb\u6765\uff0c\u7136\u540e\u76f4\u63a5\u8c03\u7528servlet api\u83b7\u53d6IP\u3002 \u6ce8\u610f\uff1a\u8fd9\u79cd\u65b9\u5f0f\u53ea\u80fd\u5728\u5c06server\u8bbe\u7f6e\u4e3a tjws\u3001tomcat\u3001jetty \u6216\u8005 servlet \u7684\u65f6\u5019\u624d\u80fd\u5de5\u4f5c\uff0c\u56e0\u4e3a\u53ea\u6709\u8fd9\u51e0\u79cd server \u7684\u5b9e\u73b0\u624d\u63d0\u4f9b\u4e86 servlet \u5bb9\u5668\u3002\u53e6\u5916\uff0c\u6807\u51c6\u7684JAX-RS\u8fd8\u652f\u6301\u7528@Context\u4fee\u9970service\u7c7b\u7684\u4e00\u4e2a\u5b9e\u4f8b\u5b57\u6bb5\u6765\u83b7\u53d6HttpServletRequest\uff0c\u4f46\u5728dubbo\u4e2d\u6211\u4eec\u6ca1\u6709\u5bf9\u6b64\u4f5c\u51fa\u652f\u6301\u3002 \u7b2c\u4e8c\u79cd\u65b9\u5f0f\uff0c\u7528dubbo\u4e2d\u5e38\u7528\u7684RpcContext\uff1a public User getUser(@PathParam( id ) Long id) { System.out.println( Client address is + RpcContext.getContext().getRemoteAddressString()); } \u6ce8\u610f\uff1a\u8fd9\u79cd\u65b9\u5f0f\u53ea\u80fd\u5728\u8bbe\u7f6eserver=\"jetty\"\u6216\u8005server=\"tomcat\"\u6216\u8005server=\"servlet\"\u6216\u8005server=\"tjws\"\u7684\u65f6\u5019\u624d\u80fd\u5de5\u4f5c\u3002\u53e6\u5916\uff0c\u76ee\u524ddubbo\u7684RpcContext\u662f\u4e00\u79cd\u6bd4\u8f83\u6709\u4fb5\u5165\u6027\u7684\u7528\u6cd5\uff0c\u672a\u6765\u6211\u4eec\u5f88\u53ef\u80fd\u4f1a\u505a\u51fa\u91cd\u6784\u3002 \u5982\u679c\u4f60\u60f3\u4fdd\u6301\u4f60\u7684\u9879\u76ee\u5bf9JAX-RS\u7684\u517c\u5bb9\u6027\uff0c\u672a\u6765\u8131\u79bbdubbo\u4e5f\u53ef\u4ee5\u8fd0\u884c\uff0c\u8bf7\u9009\u62e9\u7b2c\u4e00\u79cd\u65b9\u5f0f\u3002\u5982\u679c\u4f60\u60f3\u8981\u66f4\u4f18\u96c5\u7684\u670d\u52a1\u63a5\u53e3\u5b9a\u4e49\uff0c\u8bf7\u9009\u7528\u7b2c\u4e8c\u79cd\u65b9\u5f0f\u3002 \u6b64\u5916\uff0c\u5728\u6700\u65b0\u7684dubbo rest\u4e2d\uff0c\u8fd8\u652f\u6301\u901a\u8fc7RpcContext\u6765\u83b7\u53d6HttpServletRequest\u548cHttpServletResponse\uff0c\u4ee5\u63d0\u4f9b\u66f4\u5927\u7684\u7075\u6d3b\u6027\u6765\u65b9\u4fbf\u7528\u6237\u5b9e\u73b0\u67d0\u4e9b\u590d\u6742\u529f\u80fd\uff0c\u6bd4\u5982\u5728dubbo\u6807\u51c6\u7684filter\u4e2d\u8bbf\u95eeHTTP Header\u3002\u7528\u6cd5\u793a\u4f8b\u5982\u4e0b\uff1a if (RpcContext.getContext().getRequest() != null RpcContext.getContext().getRequest() instanceof HttpServletRequest) { System.out.println( Client address is + ((HttpServletRequest) RpcContext.getContext().getRequest()).getRemoteAddr()); } if (RpcContext.getContext().getResponse() != null RpcContext.getContext().getResponse() instanceof HttpServletResponse) { System.out.println( Response object from RpcContext: + RpcContext.getContext().getResponse()); } \u6ce8\u610f\uff1a\u4e3a\u4e86\u4fdd\u6301\u534f\u8bae\u7684\u4e2d\u7acb\u6027\uff0cRpcContext.getRequest()\u548cRpcContext.getResponse()\u8fd4\u56de\u7684\u4ec5\u4ec5\u662f\u4e00\u4e2aObject\u7c7b\uff0c\u800c\u4e14\u53ef\u80fd\u4e3anull\u3002\u6240\u4ee5\uff0c\u4f60\u5fc5\u987b\u81ea\u5df1\u505anull\u548c\u7c7b\u578b\u7684\u68c0\u67e5\u3002 \u6ce8\u610f\uff1a\u53ea\u6709\u5728\u8bbe\u7f6eserver=\"jetty\"\u6216\u8005server=\"tomcat\"\u6216\u8005server=\"servlet\"\u7684\u65f6\u5019\uff0c\u4f60\u624d\u80fd\u901a\u8fc7\u4ee5\u4e0a\u65b9\u6cd5\u6b63\u786e\u7684\u5f97\u5230HttpServletRequest\u548cHttpServletResponse\uff0c\u56e0\u4e3a\u53ea\u6709\u8fd9\u51e0\u79cdserver\u5b9e\u73b0\u4e86servlet\u5bb9\u5668\u3002 \u4e3a\u4e86\u7b80\u5316\u7f16\u7a0b\uff0c\u5728\u6b64\u4f60\u4e5f\u53ef\u4ee5\u7528\u6cdb\u578b\u7684\u65b9\u5f0f\u6765\u76f4\u63a5\u83b7\u53d6\u7279\u5b9a\u7c7b\u578b\u7684request/response\uff1a if (RpcContext.getContext().getRequest(HttpServletRequest.class) != null) { System.out.println( Client address is + RpcContext.getContext().getRequest(HttpServletRequest.class).getRemoteAddr()); } if (RpcContext.getContext().getResponse(HttpServletResponse.class) != null) { System.out.println( Response object from RpcContext: + RpcContext.getContext().getResponse(HttpServletResponse.class)); } \u5982\u679crequest/response\u4e0d\u7b26\u5408\u6307\u5b9a\u7684\u7c7b\u578b\uff0c\u8fd9\u91cc\u4e5f\u4f1a\u8fd4\u56denull\u3002 \u914d\u7f6e\u7aef\u53e3\u53f7\u548cContext Path dubbo\u4e2d\u7684rest\u534f\u8bae\u9ed8\u8ba4\u5c06\u91c7\u752880\u7aef\u53e3\uff0c\u5982\u679c\u60f3\u4fee\u6539\u7aef\u53e3\uff0c\u76f4\u63a5\u914d\u7f6e\uff1a dubbo:protocol name= rest port= 8888 / \u53e6\u5916\uff0c\u5982\u524d\u6240\u8ff0\uff0c\u6211\u4eec\u53ef\u4ee5\u7528@Path\u6765\u914d\u7f6e\u5355\u4e2arest\u670d\u52a1\u7684URL\u76f8\u5bf9\u8def\u5f84\u3002\u4f46\u5176\u5b9e\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u8bbe\u7f6e\u4e00\u4e2a\u6240\u6709rest\u670d\u52a1\u90fd\u9002\u7528\u7684\u57fa\u7840\u76f8\u5bf9\u8def\u5f84\uff0c\u5373java web\u5e94\u7528\u4e2d\u5e38\u8bf4\u7684context path\u3002 \u53ea\u9700\u8981\u6dfb\u52a0\u5982\u4e0bcontextpath\u5c5e\u6027\u5373\u53ef\uff1a dubbo:protocol name= rest port= 8888 contextpath= services / \u4ee5\u524d\u9762\u4ee3\u7801\u4e3a\u4f8b\uff1a @Path( users ) public class UserServiceImpl implements UserService { @POST @Path( register ) @Consumes({MediaType.APPLICATION_JSON}) public void registerUser(User user) { // save the user... } } \u73b0\u5728registerUser()\u7684\u5b8c\u6574\u8bbf\u95ee\u8def\u5f84\u4e3a\uff1a http://localhost:8888/services/users/register \u6ce8\u610f\uff1a\u5982\u679c\u4f60\u662f\u9009\u7528\u5916\u90e8\u5e94\u7528\u670d\u52a1\u5668\u505arest server\uff0c\u5373\u914d\u7f6e: dubbo:protocol name= rest port= 8888 contextpath= services server= servlet / \u5219\u5fc5\u987b\u4fdd\u8bc1\u8fd9\u91cc\u8bbe\u7f6e\u7684port\u3001contextpath\uff0c\u4e0e\u5916\u90e8\u5e94\u7528\u670d\u52a1\u5668\u7684\u7aef\u53e3\u3001DispatcherServlet\u7684\u4e0a\u4e0b\u6587\u8def\u5f84\uff08\u5373webapp path\u52a0\u4e0aservlet url pattern\uff09\u4fdd\u6301\u4e00\u81f4\u3002\u4f8b\u5982\uff0c\u5bf9\u4e8e\u90e8\u7f72\u4e3atomcat ROOT\u8def\u5f84\u7684\u5e94\u7528\uff0c\u8fd9\u91cc\u7684contextpath\u5fc5\u987b\u4e0eweb.xml\u4e2dDispacherServlet\u7684 url-pattern/ \u5b8c\u5168\u4e00\u81f4\uff1a servlet-mapping servlet-name dispatcher /servlet-name url-pattern /services/* /url-pattern /servlet-mapping \u914d\u7f6e\u7ebf\u7a0b\u6570\u548cIO\u7ebf\u7a0b\u6570 \u53ef\u4ee5\u4e3arest\u670d\u52a1\u914d\u7f6e\u7ebf\u7a0b\u6c60\u5927\u5c0f\uff1a dubbo:protocol name= rest threads= 500 / \u6ce8\u610f\uff1a\u76ee\u524d\u7ebf\u7a0b\u6c60\u7684\u8bbe\u7f6e\u53ea\u6709\u5f53server=\"netty\"\u6216\u8005server=\"jetty\"\u6216\u8005server=\"tomcat\"\u7684\u65f6\u5019\u624d\u80fd\u751f\u6548\u3002\u53e6\u5916\uff0c\u5982\u679cserver=\"servlet\"\uff0c\u7531\u4e8e\u8fd9\u65f6\u5019\u542f\u7528\u7684\u662f\u5916\u90e8\u5e94\u7528\u670d\u52a1\u5668\u505arest server\uff0c\u4e0d\u53d7dubbo\u63a7\u5236\uff0c\u6240\u4ee5\u8fd9\u91cc\u7684\u7ebf\u7a0b\u6c60\u8bbe\u7f6e\u4e5f\u65e0\u6548\u3002 \u5982\u679c\u662f\u9009\u7528netty server\uff0c\u8fd8\u53ef\u4ee5\u914d\u7f6eNetty\u7684IO worker\u7ebf\u7a0b\u6570\uff1a dubbo:protocol name= rest iothreads= 5 threads= 100 / \u914d\u7f6e\u957f\u8fde\u63a5 Dubbo\u4e2d\u7684rest\u670d\u52a1\u9ed8\u8ba4\u90fd\u662f\u91c7\u7528http\u957f\u8fde\u63a5\u6765\u8bbf\u95ee\uff0c\u5982\u679c\u60f3\u5207\u6362\u4e3a\u77ed\u8fde\u63a5\uff0c\u76f4\u63a5\u914d\u7f6e\uff1a dubbo:protocol name= rest keepalive= false / \u6ce8\u610f\uff1a\u8fd9\u4e2a\u914d\u7f6e\u76ee\u524d\u53ea\u5bf9server=\"netty\"\u548cserver=\"tomcat\"\u624d\u80fd\u751f\u6548\u3002 \u914d\u7f6e\u6700\u5927\u7684HTTP\u8fde\u63a5\u6570 \u53ef\u4ee5\u914d\u7f6e\u670d\u52a1\u5668\u63d0\u4f9b\u7aef\u6240\u80fd\u540c\u65f6\u63a5\u6536\u7684\u6700\u5927HTTP\u8fde\u63a5\u6570\uff0c\u9632\u6b62REST server\u88ab\u8fc7\u591a\u8fde\u63a5\u6491\u7206\uff0c\u4ee5\u4f5c\u4e3a\u4e00\u79cd\u6700\u57fa\u672c\u7684\u81ea\u6211\u4fdd\u62a4\u673a\u5236\uff1a dubbo:protocol name= rest accepts= 500 server= tomcat/ \u6ce8\u610f\uff1a\u8fd9\u4e2a\u914d\u7f6e\u76ee\u524d\u53ea\u5bf9server=\"tomcat\"\u624d\u80fd\u751f\u6548\u3002 \u914d\u7f6e\u6bcf\u4e2a\u6d88\u8d39\u7aef\u7684\u8d85\u65f6\u65f6\u95f4\u548cHTTP\u8fde\u63a5\u6570 \u5982\u679crest\u670d\u52a1\u7684\u6d88\u8d39\u7aef\u4e5f\u662fdubbo\u7cfb\u7edf\uff0c\u53ef\u4ee5\u50cf\u5176\u4ed6dubbo RPC\u673a\u5236\u4e00\u6837\uff0c\u914d\u7f6e\u6d88\u8d39\u7aef\u8c03\u7528\u6b64rest\u670d\u52a1\u7684\u6700\u5927\u8d85\u65f6\u65f6\u95f4\u4ee5\u53ca\u6bcf\u4e2a\u6d88\u8d39\u7aef\u6240\u80fd\u542f\u52a8\u7684\u6700\u5927HTTP\u8fde\u63a5\u6570\u3002 dubbo:service interface= xxx ref= xxx protocol= rest timeout= 2000 connections= 10 / \u5f53\u7136\uff0c\u7531\u4e8e\u8fd9\u4e2a\u914d\u7f6e\u9488\u5bf9\u6d88\u8d39\u7aef\u751f\u6548\u7684\uff0c\u6240\u4ee5\u4e5f\u53ef\u4ee5\u5728\u6d88\u8d39\u7aef\u914d\u7f6e\uff1a dubbo:reference id= xxx interface= xxx timeout= 2000 connections= 10 / \u4f46\u662f\uff0c\u901a\u5e38\u6211\u4eec\u5efa\u8bae\u914d\u7f6e\u5728\u670d\u52a1\u63d0\u4f9b\u7aef\u63d0\u4f9b\u6b64\u7c7b\u914d\u7f6e\u3002\u6309\u7167dubbo\u5b98\u65b9\u6587\u6863\u7684\u8bf4\u6cd5\uff1a\u201cProvider\u4e0a\u5c3d\u91cf\u591a\u914d\u7f6eConsumer\u7aef\u7684\u5c5e\u6027\uff0c\u8ba9Provider\u5b9e\u73b0\u8005\u4e00\u5f00\u59cb\u5c31\u601d\u8003Provider\u670d\u52a1\u7279\u70b9\u3001\u670d\u52a1\u8d28\u91cf\u7684\u95ee\u9898\u3002\u201d \u6ce8\u610f\uff1a\u5982\u679cdubbo\u7684REST\u670d\u52a1\u662f\u53d1\u5e03\u7ed9\u975edubbo\u7684\u5ba2\u6237\u7aef\u4f7f\u7528\uff0c\u5219\u8fd9\u91cc dubbo:service/ \u4e0a\u7684\u914d\u7f6e\u5b8c\u5168\u65e0\u6548\uff0c\u56e0\u4e3a\u8fd9\u79cd\u5ba2\u6237\u7aef\u4e0d\u53d7dubbo\u63a7\u5236\u3002 \u7528Annotation\u53d6\u4ee3\u90e8\u5206Spring XML\u914d\u7f6e \u4ee5\u4e0a\u6240\u6709\u7684\u8ba8\u8bba\u90fd\u662f\u57fa\u4e8edubbo\u5728spring\u4e2d\u7684xml\u914d\u7f6e\u3002\u4f46\u662f\uff0cdubbo/spring\u672c\u8eab\u4e5f\u652f\u6301\u7528annotation\u6765\u4f5c\u914d\u7f6e\uff0c\u6240\u4ee5\u6211\u4eec\u4e5f\u53ef\u4ee5\u6309dubbo\u5b98\u65b9\u6587\u6863\u4e2d\u7684\u6b65\u9aa4\uff0c\u628a\u76f8\u5173annotation\u52a0\u5230REST\u670d\u52a1\u7684\u5b9e\u73b0\u4e2d\uff0c\u53d6\u4ee3\u4e00\u4e9bxml\u914d\u7f6e\uff0c\u4f8b\u5982\uff1a @Service(protocol = rest ) @Path( users ) public class UserServiceImpl implements UserService { @Autowired private UserRepository userRepository; @POST @Path( register ) @Consumes({MediaType.APPLICATION_JSON}) public void registerUser(User user) { // save the user userRepository.save(user); } } annotation\u7684\u914d\u7f6e\u66f4\u7b80\u5355\u66f4\u7cbe\u786e\uff0c\u901a\u5e38\u4e5f\u66f4\u4fbf\u4e8e\u7ef4\u62a4\uff08\u5f53\u7136\u73b0\u4ee3IDE\u90fd\u53ef\u4ee5\u5728xml\u4e2d\u652f\u6301\u6bd4\u5982\u7c7b\u540d\u91cd\u6784\uff0c\u6240\u4ee5\u5c31\u8fd9\u91cc\u7684\u7279\u5b9a\u7528\u4f8b\u800c\u8a00\uff0cxml\u7684\u7ef4\u62a4\u6027\u4e5f\u5f88\u597d\uff09\u3002\u800cxml\u5bf9\u4ee3\u7801\u7684\u4fb5\u5165\u6027\u66f4\u5c0f\u4e00\u4e9b\uff0c\u5c24\u5176\u6709\u5229\u4e8e\u52a8\u6001\u4fee\u6539\u914d\u7f6e\uff0c\u7279\u522b\u662f\u6bd4\u5982\u4f60\u8981\u9488\u5bf9\u5355\u4e2a\u670d\u52a1\u914d\u7f6e\u8fde\u63a5\u8d85\u65f6\u65f6\u95f4\u3001\u6bcf\u5ba2\u6237\u7aef\u6700\u5927\u8fde\u63a5\u6570\u3001\u96c6\u7fa4\u7b56\u7565\u3001\u6743\u91cd\u7b49\u7b49\u3002\u53e6\u5916\uff0c\u7279\u522b\u5bf9\u590d\u6742\u5e94\u7528\u6216\u8005\u6a21\u5757\u6765\u8bf4\uff0cxml\u63d0\u4f9b\u4e86\u4e00\u4e2a\u4e2d\u5fc3\u70b9\u6765\u6db5\u76d6\u7684\u6240\u6709\u7ec4\u4ef6\u548c\u914d\u7f6e\uff0c\u66f4\u4e00\u76ee\u4e86\u7136\uff0c\u4e00\u822c\u66f4\u4fbf\u4e8e\u9879\u76ee\u957f\u65f6\u671f\u7684\u7ef4\u62a4\u3002 \u5f53\u7136\uff0c\u9009\u62e9\u54ea\u79cd\u914d\u7f6e\u65b9\u5f0f\u6ca1\u6709\u7edd\u5bf9\u7684\u4f18\u52a3\uff0c\u548c\u4e2a\u4eba\u7684\u504f\u597d\u4e5f\u4e0d\u65e0\u5173\u7cfb\u3002 \u6dfb\u52a0\u81ea\u5b9a\u4e49\u7684Filter\u3001Interceptor\u7b49 Dubbo\u7684REST\u4e5f\u652f\u6301JAX-RS\u6807\u51c6\u7684Filter\u548cInterceptor\uff0c\u4ee5\u65b9\u4fbf\u5bf9REST\u7684\u8bf7\u6c42\u4e0e\u54cd\u5e94\u8fc7\u7a0b\u505a\u5b9a\u5236\u5316\u7684\u62e6\u622a\u5904\u7406\u3002 \u5176\u4e2d\uff0cFilter\u4e3b\u8981\u7528\u4e8e\u8bbf\u95ee\u548c\u8bbe\u7f6eHTTP\u8bf7\u6c42\u548c\u54cd\u5e94\u7684\u53c2\u6570\u3001URI\u7b49\u7b49\u3002\u4f8b\u5982\uff0c\u8bbe\u7f6eHTTP\u54cd\u5e94\u7684cache header\uff1a public class CacheControlFilter implements ContainerResponseFilter { public void filter(ContainerRequestContext req, ContainerResponseContext res) { if (req.getMethod().equals( GET )) { res.getHeaders().add( Cache-Control , someValue ); } } } Interceptor\u4e3b\u8981\u7528\u4e8e\u8bbf\u95ee\u548c\u4fee\u6539\u8f93\u5165\u4e0e\u8f93\u51fa\u5b57\u8282\u6d41\uff0c\u4f8b\u5982\uff0c\u624b\u52a8\u6dfb\u52a0GZIP\u538b\u7f29\uff1a public class GZIPWriterInterceptor implements WriterInterceptor { @Override public void aroundWriteTo(WriterInterceptorContext context) throws IOException, WebApplicationException { OutputStream outputStream = context.getOutputStream(); context.setOutputStream(new GZIPOutputStream(outputStream)); context.proceed(); } } \u5728\u6807\u51c6JAX-RS\u5e94\u7528\u4e2d\uff0c\u6211\u4eec\u4e00\u822c\u662f\u4e3aFilter\u548cInterceptor\u6dfb\u52a0@Provider annotation\uff0c\u7136\u540eJAX-RS runtime\u4f1a\u81ea\u52a8\u53d1\u73b0\u5e76\u542f\u7528\u5b83\u4eec\u3002\u800c\u5728dubbo\u4e2d\uff0c\u6211\u4eec\u662f\u901a\u8fc7\u6dfb\u52a0XML\u914d\u7f6e\u7684\u65b9\u5f0f\u6765\u6ce8\u518cFilter\u548cInterceptor\uff1a dubbo:protocol name= rest port= 8888 extension= xxx.TraceInterceptor, xxx.TraceFilter / \u5728\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06Filter\u3001Interceptor\u548cDynamicFeature\u8fd9\u4e09\u79cd\u7c7b\u578b\u7684\u5bf9\u8c61\u90fd\u6dfb\u52a0\u5230 extension \u5c5e\u6027\u4e0a\uff0c\u591a\u4e2a\u4e4b\u95f4\u7528\u9017\u53f7\u5206\u9694\u3002\uff08DynamicFeature\u662f\u53e6\u4e00\u4e2a\u63a5\u53e3\uff0c\u53ef\u4ee5\u65b9\u4fbf\u6211\u4eec\u66f4\u52a8\u6001\u7684\u542f\u7528Filter\u548cInterceptor\uff0c\u611f\u5174\u8da3\u8bf7\u81ea\u884cgoogle\u3002\uff09 \u5f53\u7136\uff0cdubbo\u81ea\u8eab\u4e5f\u652f\u6301Filter\u7684\u6982\u5ff5\uff0c\u4f46\u6211\u4eec\u8fd9\u91cc\u8ba8\u8bba\u7684Filter\u548cInterceptor\u66f4\u52a0\u63a5\u8fd1\u534f\u8bae\u5b9e\u73b0\u7684\u5e95\u5c42\uff0c\u76f8\u6bd4dubbo\u7684filter\uff0c\u53ef\u4ee5\u505a\u66f4\u5e95\u5c42\u7684\u5b9a\u5236\u5316\u3002 \u6ce8\uff1a\u8fd9\u91cc\u7684XML\u5c5e\u6027\u53ebextension\uff0c\u800c\u4e0d\u662f\u53ebinterceptor\u6216\u8005filter\uff0c\u662f\u56e0\u4e3a\u9664\u4e86Interceptor\u548cFilter\uff0c\u672a\u6765\u6211\u4eec\u8fd8\u4f1a\u6dfb\u52a0\u66f4\u591a\u7684\u6269\u5c55\u7c7b\u578b\u3002 \u5982\u679cREST\u7684\u6d88\u8d39\u7aef\u4e5f\u662fdubbo\u7cfb\u7edf\uff08\u53c2\u89c1\u4e0b\u6587\u7684\u8ba8\u8bba\uff09\uff0c\u5219\u4e5f\u53ef\u4ee5\u7528\u7c7b\u4f3c\u65b9\u5f0f\u4e3a\u6d88\u8d39\u7aef\u914d\u7f6eInterceptor\u548cFilter\u3002\u4f46\u6ce8\u610f\uff0cJAX-RS\u4e2d\u6d88\u8d39\u7aef\u7684Filter\u548c\u63d0\u4f9b\u7aef\u7684Filter\u662f\u4e24\u79cd\u4e0d\u540c\u7684\u63a5\u53e3\u3002\u4f8b\u5982\u524d\u9762\u4f8b\u5b50\u4e2d\u670d\u52a1\u7aef\u662fContainerResponseFilter\u63a5\u53e3\uff0c\u800c\u6d88\u8d39\u7aef\u5bf9\u5e94\u7684\u662fClientResponseFilter: public class LoggingFilter implements ClientResponseFilter { public void filter(ClientRequestContext reqCtx, ClientResponseContext resCtx) throws IOException { System.out.println( status: + resCtx.getStatus()); System.out.println( date: + resCtx.getDate()); System.out.println( last-modified: + resCtx.getLastModified()); System.out.println( location: + resCtx.getLocation()); System.out.println( headers: ); for (Entry String, List String header : resCtx.getHeaders().entrySet()) { System.out.print( \\t + header.getKey() + : ); for (String value : header.getValue()) { System.out.print(value + , ); } System.out.print( \\n ); } System.out.println( media-type: + resCtx.getMediaType().getType()); } } \u6dfb\u52a0\u81ea\u5b9a\u4e49\u7684Exception\u5904\u7406 Dubbo\u7684REST\u4e5f\u652f\u6301JAX-RS\u6807\u51c6\u7684ExceptionMapper\uff0c\u53ef\u4ee5\u7528\u6765\u5b9a\u5236\u7279\u5b9aexception\u53d1\u751f\u540e\u5e94\u8be5\u8fd4\u56de\u7684HTTP\u54cd\u5e94\u3002 public class CustomExceptionMapper implements ExceptionMapper NotFoundException { public Response toResponse(NotFoundException e) { return Response.status(Response.Status.NOT_FOUND).entity( Oops! the requested resource is not found! ).type( text/plain ).build(); } } \u548cInterceptor\u3001Filter\u7c7b\u4f3c\uff0c\u5c06\u5176\u6dfb\u52a0\u5230XML\u914d\u7f6e\u6587\u4ef6\u4e2d\u5373\u53ef\u542f\u7528\uff1a dubbo:protocol name= rest port= 8888 extension= xxx.CustomExceptionMapper / \u914d\u7f6eHTTP\u65e5\u5fd7\u8f93\u51fa Dubbo rest\u652f\u6301\u8f93\u51fa\u6240\u6709HTTP\u8bf7\u6c42/\u54cd\u5e94\u4e2d\u7684header\u5b57\u6bb5\u548cbody\u6d88\u606f\u4f53\u3002 \u5728XML\u914d\u7f6e\u4e2d\u6dfb\u52a0\u5982\u4e0b\u81ea\u5e26\u7684REST filter\uff1a dubbo:protocol name= rest port= 8888 extension= org.apache.dubbo.rpc.protocol.rest.support.LoggingFilter / \u7136\u540e\u914d\u7f6e\u5728logging\u914d\u7f6e\u4e2d\u81f3\u5c11\u4e3aorg.apache.dubbo.rpc.protocol.rest.support\u6253\u5f00INFO\u7ea7\u522b\u65e5\u5fd7\u8f93\u51fa\uff0c\u4f8b\u5982\uff0c\u5728log4j.xml\u4e2d\u914d\u7f6e\uff1a logger name= org.apache.dubbo.rpc.protocol.rest.support level value= INFO / appender-ref ref= CONSOLE / /logger \u5f53\u7136\uff0c\u4f60\u4e5f\u53ef\u4ee5\u76f4\u63a5\u5728ROOT logger\u6253\u5f00INFO\u7ea7\u522b\u65e5\u5fd7\u8f93\u51fa\uff1a root level value= INFO / appender-ref ref= CONSOLE / /root \u7136\u540e\u5728\u65e5\u5fd7\u4e2d\u4f1a\u6709\u7c7b\u4f3c\u5982\u4e0b\u7684\u5185\u5bb9\u8f93\u51fa\uff1a The HTTP headers are: accept: application/json;charset=UTF-8 accept-encoding: gzip, deflate connection: Keep-Alive content-length: 22 content-type: application/json host: 192.168.1.100:8888 user-agent: Apache-HttpClient/4.2.1 (java 1.5) The contents of request body is: { id :1, name : dang } \u6253\u5f00HTTP\u65e5\u5fd7\u8f93\u51fa\u540e\uff0c\u9664\u4e86\u6b63\u5e38\u65e5\u5fd7\u8f93\u51fa\u7684\u6027\u80fd\u5f00\u9500\u5916\uff0c\u4e5f\u4f1a\u5728\u6bd4\u5982HTTP\u8bf7\u6c42\u89e3\u6790\u65f6\u4ea7\u751f\u989d\u5916\u7684\u5f00\u9500\uff0c\u56e0\u4e3a\u9700\u8981\u5efa\u7acb\u989d\u5916\u7684\u5185\u5b58\u7f13\u51b2\u533a\u6765\u4e3a\u65e5\u5fd7\u7684\u8f93\u51fa\u505a\u6570\u636e\u51c6\u5907\u3002 \u8f93\u5165\u53c2\u6570\u7684\u6821\u9a8c dubbo\u7684rest\u652f\u6301\u91c7\u7528Java\u6807\u51c6\u7684bean validation annotation\uff08JSR 303)\u6765\u505a\u8f93\u5165\u6821\u9a8chttp://beanvalidation.org/ \u4e3a\u4e86\u548c\u5176\u4ed6dubbo\u8fdc\u7a0b\u8c03\u7528\u534f\u8bae\u4fdd\u6301\u4e00\u81f4\uff0c\u5728rest\u4e2d\u4f5c\u6821\u9a8c\u7684annotation\u5fc5\u987b\u653e\u5728\u670d\u52a1\u7684\u63a5\u53e3\u4e0a\uff0c\u4f8b\u5982\uff1a public interface UserService { User getUser(@Min(value=1L, message= User ID must be greater than 1 ) Long id); } \u5f53\u7136\uff0c\u5728\u5f88\u591a\u5176\u4ed6\u7684bean validation\u7684\u5e94\u7528\u573a\u666f\u90fd\u662f\u5c06annotation\u653e\u5230\u5b9e\u73b0\u7c7b\u800c\u4e0d\u662f\u63a5\u53e3\u4e0a\u3002\u628aannotation\u653e\u5728\u63a5\u53e3\u4e0a\u81f3\u5c11\u6709\u4e00\u4e2a\u597d\u5904\u662f\uff0cdubbo\u7684\u5ba2\u6237\u7aef\u53ef\u4ee5\u5171\u4eab\u8fd9\u4e2a\u63a5\u53e3\u7684\u4fe1\u606f\uff0cdubbo\u751a\u81f3\u4e0d\u9700\u8981\u505a\u8fdc\u7a0b\u8c03\u7528\uff0c\u5728\u672c\u5730\u5c31\u53ef\u4ee5\u5b8c\u6210\u8f93\u5165\u6821\u9a8c\u3002 \u7136\u540e\u6309\u7167dubbo\u7684\u6807\u51c6\u65b9\u5f0f\u5728XML\u914d\u7f6e\u4e2d\u6253\u5f00\u9a8c\u8bc1\uff1a dubbo:service interface=xxx.UserService ref= userService protocol= rest validation= true / \u5728dubbo\u7684\u5176\u4ed6\u5f88\u591a\u8fdc\u7a0b\u8c03\u7528\u534f\u8bae\u4e2d\uff0c\u5982\u679c\u8f93\u5165\u9a8c\u8bc1\u51fa\u9519\uff0c\u662f\u76f4\u63a5\u5c06 RpcException \u629b\u5411\u5ba2\u6237\u7aef\uff0c\u800c\u5728rest\u4e2d\u7531\u4e8e\u5ba2\u6237\u7aef\u7ecf\u5e38\u662f\u975edubbo\uff0c\u751a\u81f3\u975ejava\u7684\u7cfb\u7edf\uff0c\u6240\u4ee5\u4e0d\u4fbf\u76f4\u63a5\u629b\u51faJava\u5f02\u5e38\u3002\u56e0\u6b64\uff0c\u76ee\u524d\u6211\u4eec\u5c06\u6821\u9a8c\u9519\u8bef\u4ee5XML\u7684\u683c\u5f0f\u8fd4\u56de\uff1a violationReport constraintViolations path getUserArgument0 /path message User ID must be greater than 1 /message value 0 /value /constraintViolations /violationReport \u7a0d\u540e\u4e5f\u4f1a\u652f\u6301\u5176\u4ed6\u6570\u636e\u683c\u5f0f\u7684\u8fd4\u56de\u503c\u3002\u81f3\u4e8e\u5982\u4f55\u5bf9\u9a8c\u8bc1\u9519\u8bef\u6d88\u606f\u4f5c\u56fd\u9645\u5316\u5904\u7406\uff0c\u76f4\u63a5\u53c2\u8003bean validation\u7684\u76f8\u5173\u6587\u6863\u5373\u53ef\u3002 \u5982\u679c\u4f60\u8ba4\u4e3a\u9ed8\u8ba4\u7684\u6821\u9a8c\u9519\u8bef\u8fd4\u56de\u683c\u5f0f\u4e0d\u7b26\u5408\u4f60\u7684\u8981\u6c42\uff0c\u53ef\u4ee5\u5982\u4e0a\u9762\u7ae0\u8282\u6240\u8ff0\uff0c\u6dfb\u52a0\u81ea\u5b9a\u4e49\u7684ExceptionMapper\u6765\u81ea\u7531\u7684\u5b9a\u5236\u9519\u8bef\u8fd4\u56de\u683c\u5f0f\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u8fd9\u4e2aExceptionMapper\u5fc5\u987b\u7528\u6cdb\u578b\u58f0\u660e\u6765\u6355\u83b7dubbo\u7684RpcException\uff0c\u624d\u80fd\u6210\u529f\u8986\u76d6dubbo rest\u9ed8\u8ba4\u7684\u5f02\u5e38\u5904\u7406\u7b56\u7565\u3002\u4e3a\u4e86\u7b80\u5316\u64cd\u4f5c\uff0c\u5176\u5b9e\u8fd9\u91cc\u6700\u7b80\u5355\u7684\u65b9\u5f0f\u662f\u76f4\u63a5\u7ee7\u627fdubbo rest\u7684RpcExceptionMapper\uff0c\u5e76\u8986\u76d6\u5176\u4e2d\u5904\u7406\u6821\u9a8c\u5f02\u5e38\u7684\u65b9\u6cd5\u5373\u53ef\uff1a public class MyValidationExceptionMapper extends RpcExceptionMapper { protected Response handleConstraintViolationException(ConstraintViolationException cve) { ViolationReport report = new ViolationReport(); for (ConstraintViolation cv : cve.getConstraintViolations()) { report.addConstraintViolation(new RestConstraintViolation( cv.getPropertyPath().toString(), cv.getMessage(), cv.getInvalidValue() == null ? null : cv.getInvalidValue().toString())); } // \u91c7\u7528json\u8f93\u51fa\u4ee3\u66ffxml\u8f93\u51fa return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(report).type(ContentType.APPLICATION_JSON_UTF_8).build(); } } \u7136\u540e\u5c06\u8fd9\u4e2aExceptionMapper\u6dfb\u52a0\u5230XML\u914d\u7f6e\u4e2d\u5373\u53ef\uff1a dubbo:protocol name= rest port= 8888 extension= xxx.MyValidationExceptionMapper /","title":"rest://"},{"location":"user/references/protocol/rest/#rest","text":"\u57fa\u4e8e\u6807\u51c6\u7684Java REST API\u2014\u2014JAX-RS 2.0\uff08Java API for RESTful Web Services\u7684\u7b80\u5199\uff09\u5b9e\u73b0\u7684REST\u8c03\u7528\u652f\u6301","title":"rest://"},{"location":"user/references/protocol/rest/#_1","text":"\u5728dubbo\u4e2d\u5f00\u53d1\u4e00\u4e2aREST\u98ce\u683c\u7684\u670d\u52a1\u4f1a\u6bd4\u8f83\u7b80\u5355\uff0c\u4e0b\u9762\u4ee5\u4e00\u4e2a\u6ce8\u518c\u7528\u6237\u7684\u7b80\u5355\u670d\u52a1\u4e3a\u4f8b\u8bf4\u660e\u3002 \u8fd9\u4e2a\u670d\u52a1\u8981\u5b9e\u73b0\u7684\u529f\u80fd\u662f\u63d0\u4f9b\u5982\u4e0bURL\uff08\u6ce8\uff1a\u8fd9\u4e2aURL\u4e0d\u662f\u5b8c\u5168\u7b26\u5408REST\u7684\u98ce\u683c\uff0c\u4f46\u662f\u66f4\u7b80\u5355\u5b9e\u7528\uff09\uff1a http://localhost:8080/users/register \u800c\u4efb\u4f55\u5ba2\u6237\u7aef\u90fd\u53ef\u4ee5\u5c06\u5305\u542b\u7528\u6237\u4fe1\u606f\u7684JSON\u5b57\u7b26\u4e32POST\u5230\u4ee5\u4e0aURL\u6765\u5b8c\u6210\u7528\u6237\u6ce8\u518c\u3002 \u9996\u5148\uff0c\u5f00\u53d1\u670d\u52a1\u7684\u63a5\u53e3\uff1a public class UserService { void registerUser(User user); } \u7136\u540e\uff0c\u5f00\u53d1\u670d\u52a1\u7684\u5b9e\u73b0\uff1a @Path( users ) public class UserServiceImpl implements UserService { @POST @Path( register ) @Consumes({MediaType.APPLICATION_JSON}) public void registerUser(User user) { // save the user... } } \u4e0a\u9762\u7684\u5b9e\u73b0\u975e\u5e38\u7b80\u5355\uff0c\u4f46\u662f\u7531\u4e8e\u8be5 REST \u670d\u52a1\u662f\u8981\u53d1\u5e03\u5230\u6307\u5b9a URL \u4e0a\uff0c\u4f9b\u4efb\u610f\u8bed\u8a00\u7684\u5ba2\u6237\u7aef\u751a\u81f3\u6d4f\u89c8\u5668\u6765\u8bbf\u95ee\uff0c\u6240\u4ee5\u8fd9\u91cc\u989d\u5916\u6dfb\u52a0\u4e86\u51e0\u4e2a JAX-RS \u7684\u6807\u51c6 annotation \u6765\u505a\u76f8\u5173\u7684\u914d\u7f6e\u3002 @Path(\"users\")\uff1a\u6307\u5b9a\u8bbf\u95eeUserService\u7684URL\u76f8\u5bf9\u8def\u5f84\u662f/users\uff0c\u5373http://localhost:8080/users @Path(\"register\")\uff1a\u6307\u5b9a\u8bbf\u95eeregisterUser()\u65b9\u6cd5\u7684URL\u76f8\u5bf9\u8def\u5f84\u662f/register\uff0c\u518d\u7ed3\u5408\u4e0a\u4e00\u4e2a@Path\u4e3aUserService\u6307\u5b9a\u7684\u8def\u5f84\uff0c\u5219\u8c03\u7528UserService.register()\u7684\u5b8c\u6574\u8def\u5f84\u4e3ahttp://localhost:8080/users/register @POST\uff1a\u6307\u5b9a\u8bbf\u95eeregisterUser()\u7528HTTP POST\u65b9\u6cd5 @Consumes({MediaType.APPLICATION_JSON})\uff1a\u6307\u5b9aregisterUser()\u63a5\u6536JSON\u683c\u5f0f\u7684\u6570\u636e\u3002REST\u6846\u67b6\u4f1a\u81ea\u52a8\u5c06JSON\u6570\u636e\u53cd\u5e8f\u5217\u5316\u4e3aUser\u5bf9\u8c61 \u6700\u540e\uff0c\u5728spring\u914d\u7f6e\u6587\u4ef6\u4e2d\u6dfb\u52a0\u6b64\u670d\u52a1\uff0c\u5373\u5b8c\u6210\u6240\u6709\u670d\u52a1\u5f00\u53d1\u5de5\u4f5c\uff1a ```xml ## REST\u670d\u52a1\u63d0\u4f9b\u7aef\u8be6\u89e3 \u4e0b\u9762\u6211\u4eec\u6269\u5145\u201c\u5feb\u901f\u5165\u95e8\u201d\u4e2d\u7684UserService\uff0c\u8fdb\u4e00\u6b65\u5c55\u793a\u5728dubbo\u4e2dREST\u670d\u52a1\u63d0\u4f9b\u7aef\u7684\u5f00\u53d1\u8981\u70b9\u3002 ### HTTP POST/GET\u7684\u5b9e\u73b0 REST\u670d\u52a1\u4e2d\u867d\u7136\u5efa\u8bae\u4f7f\u7528HTTP\u534f\u8bae\u4e2d\u56db\u79cd\u6807\u51c6\u65b9\u6cd5POST\u3001DELETE\u3001PUT\u3001GET\u6765\u5206\u522b\u5b9e\u73b0\u5e38\u89c1\u7684\u201c\u589e\u5220\u6539\u67e5\u201d\uff0c\u4f46\u5b9e\u9645\u4e2d\uff0c\u6211\u4eec\u4e00\u822c\u60c5\u51b5\u76f4\u63a5\u7528POST\u6765\u5b9e\u73b0\u201c\u589e\u6539\u201d\uff0cGET\u6765\u5b9e\u73b0\u201c\u5220\u67e5\u201d\u5373\u53ef\uff08DELETE\u548cPUT\u751a\u81f3\u4f1a\u88ab\u4e00\u4e9b\u9632\u706b\u5899\u963b\u6321\uff09\u3002 \u524d\u9762\u5df2\u7ecf\u7b80\u5355\u6f14\u793a\u4e86POST\u7684\u5b9e\u73b0\uff0c\u5728\u6b64\uff0c\u6211\u4eec\u4e3aUserService\u6dfb\u52a0\u4e00\u4e2a\u83b7\u53d6\u6ce8\u518c\u7528\u6237\u8d44\u6599\u7684\u529f\u80fd\uff0c\u6765\u6f14\u793aGET\u7684\u5b9e\u73b0\u3002 \u8fd9\u4e2a\u529f\u80fd\u5c31\u662f\u8981\u5b9e\u73b0\u5ba2\u6237\u7aef\u901a\u8fc7\u8bbf\u95ee\u5982\u4e0b\u4e0d\u540cURL\u6765\u83b7\u53d6\u4e0d\u540cID\u7684\u7528\u6237\u8d44\u6599\uff1a http://localhost:8080/users/1001 http://localhost:8080/users/1002 http://localhost:8080/users/1003 \u5f53\u7136\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u5176\u4ed6\u5f62\u5f0f\u7684URL\u6765\u8bbf\u95ee\u4e0d\u540cID\u7684\u7528\u6237\u8d44\u6599\uff0c\u4f8b\u5982\uff1a http://localhost:8080/users/load?id=1001 JAX-RS\u672c\u8eab\u53ef\u4ee5\u652f\u6301\u6240\u6709\u8fd9\u4e9b\u5f62\u5f0f\u3002\u4f46\u662f\u4e0a\u9762\u90a3\u79cd\u5728URL\u8def\u5f84\u4e2d\u5305\u542b\u67e5\u8be2\u53c2\u6570\u7684\u5f62\u5f0f\uff08http://localhost:8080/users/1001\uff09 \u66f4\u7b26\u5408REST\u7684\u4e00\u822c\u4e60\u60ef\uff0c\u6240\u4ee5\u66f4\u63a8\u8350\u5927\u5bb6\u6765\u4f7f\u7528\u3002\u4e0b\u9762\u6211\u4eec\u5c31\u4e3aUserService\u6dfb\u52a0\u4e00\u4e2agetUser()\u65b9\u6cd5\u6765\u5b9e\u73b0\u8fd9\u79cd\u5f62\u5f0f\u7684URL\u8bbf\u95ee\uff1a ```java @GET @Path( {id : \\\\d+} ) @Produces({MediaType.APPLICATION_JSON}) public User getUser(@PathParam( id ) Long id) { // ... } @GET\uff1a\u6307\u5b9a\u7528HTTP GET\u65b9\u6cd5\u8bbf\u95ee @Path(\"{id : \\d+}\")\uff1a\u6839\u636e\u4e0a\u9762\u7684\u529f\u80fd\u9700\u6c42\uff0c\u8bbf\u95eegetUser()\u7684URL\u5e94\u5f53\u662f\u201chttp://localhost:8080/users/ + \u4efb\u610f\u6570\u5b57\"\uff0c\u5e76\u4e14\u8fd9\u4e2a\u6570\u5b57\u8981\u88ab\u505a\u4e3a\u53c2\u6570\u4f20\u5165getUser()\u65b9\u6cd5\u3002 \u8fd9\u91cc\u7684annotation\u914d\u7f6e\u4e2d\uff0c@Path\u4e2d\u95f4\u7684{id: xxx}\u6307\u5b9aURL\u76f8\u5bf9\u8def\u5f84\u4e2d\u5305\u542b\u4e86\u540d\u4e3aid\u53c2\u6570\uff0c\u800c\u5b83\u7684\u503c\u4e5f\u5c06\u88ab\u81ea\u52a8\u4f20\u9012\u7ed9\u4e0b\u9762\u7528@PathParam(\"id\")\u4fee\u9970\u7684\u65b9\u6cd5\u53c2\u6570id\u3002{id:\u540e\u9762\u7d27\u8ddf\u7684\\d+\u662f\u4e00\u4e2a\u6b63\u5219\u8868\u8fbe\u5f0f\uff0c\u6307\u5b9a\u4e86id\u53c2\u6570\u5fc5\u987b\u662f\u6570\u5b57\u3002 @Produces({MediaType.APPLICATION_JSON})\uff1a\u6307\u5b9agetUser()\u8f93\u51faJSON\u683c\u5f0f\u7684\u6570\u636e\u3002\u6846\u67b6\u4f1a\u81ea\u52a8\u5c06User\u5bf9\u8c61\u5e8f\u5217\u5316\u4e3aJSON\u6570\u636e\u3002","title":"\u5feb\u901f\u5165\u95e8"},{"location":"user/references/protocol/rest/#annotation","text":"\u5728Dubbo\u4e2d\u5f00\u53d1REST\u670d\u52a1\u4e3b\u8981\u90fd\u662f\u901a\u8fc7JAX-RS\u7684annotation\u6765\u5b8c\u6210\u914d\u7f6e\u7684\uff0c\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u6211\u4eec\u90fd\u662f\u5c06annotation\u653e\u5728\u670d\u52a1\u7684\u5b9e\u73b0\u7c7b\u4e2d\u3002\u4f46\u5176\u5b9e\uff0c\u6211\u4eec\u5b8c\u5168\u4e5f\u53ef\u4ee5\u5c06annotation\u653e\u5230\u670d\u52a1\u7684\u63a5\u53e3\u4e0a\uff0c\u8fd9\u4e24\u79cd\u65b9\u5f0f\u662f\u5b8c\u5168\u7b49\u4ef7\u7684\uff0c\u4f8b\u5982\uff1a @Path( users ) public interface UserService { @GET @Path( {id : \\\\d+} ) @Produces({MediaType.APPLICATION_JSON}) User getUser(@PathParam( id ) Long id); } \u5728\u4e00\u822c\u5e94\u7528\u4e2d\uff0c\u6211\u4eec\u5efa\u8bae\u5c06annotation\u653e\u5230\u670d\u52a1\u5b9e\u73b0\u7c7b\uff0c\u8fd9\u6837annotation\u548cjava\u5b9e\u73b0\u4ee3\u7801\u4f4d\u7f6e\u66f4\u63a5\u8fd1\uff0c\u66f4\u4fbf\u4e8e\u5f00\u53d1\u548c\u7ef4\u62a4\u3002\u53e6\u5916\u66f4\u91cd\u8981\u7684\u662f\uff0c\u6211\u4eec\u4e00\u822c\u503e\u5411\u4e8e\u907f\u514d\u5bf9\u63a5\u53e3\u7684\u6c61\u67d3\uff0c\u4fdd\u6301\u63a5\u53e3\u7684\u7eaf\u51c0\u6027\u548c\u5e7f\u6cdb\u9002\u7528\u6027\u3002 \u4f46\u662f\uff0c\u5982\u540e\u6587\u6240\u8ff0\uff0c\u5982\u679c\u6211\u4eec\u8981\u7528dubbo\u76f4\u63a5\u5f00\u53d1\u7684\u6d88\u8d39\u7aef\u6765\u8bbf\u95ee\u6b64\u670d\u52a1\uff0c\u5219annotation\u5fc5\u987b\u653e\u5230\u63a5\u53e3\u4e0a\u3002 \u5982\u679c\u63a5\u53e3\u548c\u5b9e\u73b0\u7c7b\u90fd\u540c\u65f6\u6dfb\u52a0\u4e86annotation\uff0c\u5219\u5b9e\u73b0\u7c7b\u7684annotation\u914d\u7f6e\u4f1a\u751f\u6548\uff0c\u63a5\u53e3\u4e0a\u7684annotation\u88ab\u76f4\u63a5\u5ffd\u7565\u3002","title":"Annotation\u653e\u5728\u63a5\u53e3\u7c7b\u8fd8\u662f\u5b9e\u73b0\u7c7b"},{"location":"user/references/protocol/rest/#jsonxml","text":"\u5728dubbo\u4e2d\u5f00\u53d1\u7684REST\u670d\u52a1\u53ef\u4ee5\u540c\u65f6\u652f\u6301\u4f20\u8f93\u591a\u79cd\u683c\u5f0f\u7684\u6570\u636e\uff0c\u4ee5\u7ed9\u5ba2\u6237\u7aef\u63d0\u4f9b\u6700\u5927\u7684\u7075\u6d3b\u6027\u3002\u5176\u4e2d\u6211\u4eec\u76ee\u524d\u5bf9\u6700\u5e38\u7528\u7684JSON\u548cXML\u683c\u5f0f\u7279\u522b\u6dfb\u52a0\u4e86\u989d\u5916\u7684\u529f\u80fd\u3002 \u6bd4\u5982\uff0c\u6211\u4eec\u8981\u8ba9\u4e0a\u4f8b\u4e2d\u7684getUser()\u65b9\u6cd5\u652f\u6301\u5206\u522b\u8fd4\u56deJSON\u548cXML\u683c\u5f0f\u7684\u6570\u636e\uff0c\u53ea\u9700\u8981\u5728annotation\u4e2d\u540c\u65f6\u5305\u542b\u4e24\u79cd\u683c\u5f0f\u5373\u53ef\uff1a @Produces({MediaType.APPLICATION_JSON, MediaType.TEXT_XML}) User getUser(@PathParam( id ) Long id); \u6216\u8005\u4e5f\u53ef\u4ee5\u76f4\u63a5\u7528\u5b57\u7b26\u4e32\uff08\u8fd8\u652f\u6301\u901a\u914d\u7b26\uff09\u8868\u793aMediaType\uff1a @Produces({ application/json , text/xml }) User getUser(@PathParam( id ) Long id); \u5982\u679c\u6240\u6709\u65b9\u6cd5\u90fd\u652f\u6301\u540c\u6837\u7c7b\u578b\u7684\u8f93\u5165\u8f93\u51fa\u6570\u636e\u683c\u5f0f\uff0c\u5219\u6211\u4eec\u65e0\u9700\u5728\u6bcf\u4e2a\u65b9\u6cd5\u4e0a\u505a\u914d\u7f6e\uff0c\u53ea\u9700\u8981\u5728\u670d\u52a1\u7c7b\u4e0a\u6dfb\u52a0annotation\u5373\u53ef\uff1a @Path( users ) @Consumes({MediaType.APPLICATION_JSON, MediaType.TEXT_XML}) @Produces({MediaType.APPLICATION_JSON, MediaType.TEXT_XML}) public class UserServiceImpl implements UserService { // ... } \u5728\u4e00\u4e2aREST\u670d\u52a1\u540c\u65f6\u5bf9\u591a\u79cd\u6570\u636e\u683c\u5f0f\u652f\u6301\u7684\u60c5\u51b5\u4e0b\uff0c\u6839\u636eJAX-RS\u6807\u51c6\uff0c\u4e00\u822c\u662f\u901a\u8fc7HTTP\u4e2d\u7684MIME header\uff08content-type\u548caccept\uff09\u6765\u6307\u5b9a\u5f53\u524d\u60f3\u7528\u7684\u662f\u54ea\u79cd\u683c\u5f0f\u7684\u6570\u636e\u3002 \u4f46\u662f\u5728dubbo\u4e2d\uff0c\u6211\u4eec\u8fd8\u81ea\u52a8\u652f\u6301\u76ee\u524d\u4e1a\u754c\u666e\u904d\u4f7f\u7528\u7684\u65b9\u5f0f\uff0c\u5373\u7528\u4e00\u4e2aURL\u540e\u7f00\uff08.json\u548c.xml\uff09\u6765\u6307\u5b9a\u60f3\u7528\u7684\u6570\u636e\u683c\u5f0f\u3002\u4f8b\u5982\uff0c\u5728\u6dfb\u52a0\u4e0a\u8ff0annotation\u540e\uff0c\u76f4\u63a5\u8bbf\u95eehttp://localhost:8888/users/1001.json\u5219\u8868\u793a\u7528json\u683c\u5f0f\uff0c\u76f4\u63a5\u8bbf\u95eehttp://localhost:8888/users/1002.xml\u5219\u8868\u793a\u7528xml\u683c\u5f0f\uff0c\u6bd4\u7528HTTP Header\u66f4\u7b80\u5355\u76f4\u89c2\u3002Twitter\u3001\u5fae\u535a\u7b49\u7684REST API\u90fd\u662f\u91c7\u7528\u8fd9\u79cd\u65b9\u5f0f\u3002 \u5982\u679c\u4f60\u65e2\u4e0d\u52a0HTTP header\uff0c\u4e5f\u4e0d\u52a0\u540e\u7f00\uff0c\u5219dubbo\u7684REST\u4f1a\u4f18\u5148\u542f\u7528\u5728\u4ee5\u4e0aannotation\u5b9a\u4e49\u4e2d\u6392\u4f4d\u6700\u9760\u524d\u7684\u90a3\u79cd\u6570\u636e\u683c\u5f0f\u3002 \u6ce8\u610f\uff1a\u8fd9\u91cc\u8981\u652f\u6301XML\u683c\u5f0f\u6570\u636e\uff0c\u5728annotation\u4e2d\u65e2\u53ef\u4ee5\u7528MediaType.TEXT_XML\uff0c\u4e5f\u53ef\u4ee5\u7528MediaType.APPLICATION_XML\uff0c\u4f46\u662fTEXT_XML\u662f\u66f4\u5e38\u7528\u7684\uff0c\u5e76\u4e14\u5982\u679c\u8981\u5229\u7528\u4e0a\u8ff0\u7684URL\u540e\u7f00\u65b9\u5f0f\u6765\u6307\u5b9a\u6570\u636e\u683c\u5f0f\uff0c\u53ea\u80fd\u914d\u7f6e\u4e3aTEXT_XML\u624d\u80fd\u751f\u6548\u3002","title":"JSON\u3001XML\u7b49\u591a\u6570\u636e\u683c\u5f0f\u7684\u652f\u6301"},{"location":"user/references/protocol/rest/#_2","text":"\u4e3a\u4e86\u5728dubbo REST\u4e2d\u6b63\u5e38\u8f93\u51fa\u4e2d\u6587\u5b57\u7b26\uff0c\u548c\u901a\u5e38\u7684Java web\u5e94\u7528\u4e00\u6837\uff0c\u6211\u4eec\u9700\u8981\u5c06HTTP\u54cd\u5e94\u7684contentType\u8bbe\u7f6e\u4e3aUTF-8\u7f16\u7801\u3002 \u57fa\u4e8eJAX-RS\u7684\u6807\u51c6\u7528\u6cd5\uff0c\u6211\u4eec\u53ea\u9700\u8981\u505a\u5982\u4e0bannotation\u914d\u7f6e\u5373\u53ef\uff1a @Produces({ application/json; charset=UTF-8 , text/xml; charset=UTF-8 }) User getUser(@PathParam( id ) Long id); \u4e3a\u4e86\u65b9\u4fbf\u7528\u6237\uff0c\u6211\u4eec\u5728dubbo REST\u4e2d\u76f4\u63a5\u6dfb\u52a0\u4e86\u4e00\u4e2a\u652f\u6301\u7c7b\uff0c\u6765\u5b9a\u4e49\u4ee5\u4e0a\u7684\u5e38\u91cf\uff0c\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\uff0c\u51cf\u5c11\u51fa\u9519\u7684\u53ef\u80fd\u6027\u3002 @Produces({ContentType.APPLICATION_JSON_UTF_8, ContentType.TEXT_XML_UTF_8}) User getUser(@PathParam( id ) Long id);","title":"\u4e2d\u6587\u5b57\u7b26\u652f\u6301"},{"location":"user/references/protocol/rest/#xml","text":"\u7531\u4e8eJAX-RS\u7684\u5b9e\u73b0\u4e00\u822c\u90fd\u7528\u6807\u51c6\u7684JAXB\uff08Java API for XML Binding\uff09\u6765\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316XML\u683c\u5f0f\u6570\u636e\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4e3a\u6bcf\u4e00\u4e2a\u8981\u7528XML\u4f20\u8f93\u7684\u5bf9\u8c61\u6dfb\u52a0\u4e00\u4e2a\u7c7b\u7ea7\u522b\u7684JAXB annotation\uff0c\u5426\u5219\u5e8f\u5217\u5316\u5c06\u62a5\u9519\u3002\u4f8b\u5982\u4e3agetUser()\u4e2d\u8fd4\u56de\u7684User\u6dfb\u52a0\u5982\u4e0b\uff1a @XmlRootElement public class User implements Serializable { // ... } \u6b64\u5916\uff0c\u5982\u679cservice\u65b9\u6cd5\u4e2d\u7684\u8fd4\u56de\u503c\u662fJava\u7684 primitive\u7c7b\u578b\uff08\u5982int\uff0clong\uff0cfloat\uff0cdouble\u7b49\uff09\uff0c\u6700\u597d\u4e3a\u5b83\u4eec\u6dfb\u52a0\u4e00\u5c42wrapper\u5bf9\u8c61\uff0c\u56e0\u4e3aJAXB\u4e0d\u80fd\u76f4\u63a5\u5e8f\u5217\u5316primitive\u7c7b\u578b\u3002 \u4f8b\u5982\uff0c\u6211\u4eec\u60f3\u8ba9\u524d\u8ff0\u7684registerUser()\u65b9\u6cd5\u8fd4\u56de\u670d\u52a1\u5668\u7aef\u4e3a\u7528\u6237\u751f\u6210\u7684ID\u53f7\uff1a long registerUser(User user); \u7531\u4e8eprimitive\u7c7b\u578b\u4e0d\u88abJAXB\u5e8f\u5217\u5316\u652f\u6301\uff0c\u6240\u4ee5\u6dfb\u52a0\u4e00\u4e2awrapper\u5bf9\u8c61\uff1a @XmlRootElement public class RegistrationResult implements Serializable { private Long id; public RegistrationResult() { } public RegistrationResult(Long id) { this.id = id; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } } \u5e76\u4fee\u6539service\u65b9\u6cd5\uff1a RegistrationResult registerUser(User user); \u8fd9\u6837\u4e0d\u4f46\u80fd\u591f\u89e3\u51b3XML\u5e8f\u5217\u5316\u7684\u95ee\u9898\uff0c\u800c\u4e14\u4f7f\u5f97\u8fd4\u56de\u7684\u6570\u636e\u90fd\u7b26\u5408XML\u548cJSON\u7684\u89c4\u8303\u3002\u4f8b\u5982\uff0c\u5728JSON\u4e2d\uff0c\u8fd4\u56de\u7684\u5c06\u662f\u5982\u4e0b\u5f62\u5f0f\uff1a { id : 1001} \u5982\u679c\u4e0d\u52a0wrapper\uff0cJSON\u8fd4\u56de\u503c\u5c06\u76f4\u63a5\u662f 1001 \u800c\u5728XML\u4e2d\uff0c\u52a0wrapper\u540e\u8fd4\u56de\u503c\u5c06\u662f\uff1a registrationResult id 1002 /id /registrationResult \u8fd9\u79cdwrapper\u5bf9\u8c61\u5176\u5b9e\u5229\u7528\u6240\u8c13Data Transfer Object\uff08DTO\uff09\u6a21\u5f0f\uff0c\u91c7\u7528DTO\u8fd8\u80fd\u5bf9\u4f20\u8f93\u6570\u636e\u505a\u66f4\u591a\u6709\u7528\u7684\u5b9a\u5236\u3002","title":"XML\u6570\u636e\u683c\u5f0f\u7684\u989d\u5916\u8981\u6c42"},{"location":"user/references/protocol/rest/#_3","text":"\u5982\u4e0a\u6240\u8ff0\uff0cREST\u7684\u5e95\u5c42\u5b9e\u73b0\u4f1a\u5728service\u7684\u5bf9\u8c61\u548cJSON/XML\u6570\u636e\u683c\u5f0f\u4e4b\u95f4\u81ea\u52a8\u505a\u5e8f\u5217\u5316/\u53cd\u5e8f\u5217\u5316\u3002\u4f46\u6709\u4e9b\u573a\u666f\u4e0b\uff0c\u5982\u679c\u89c9\u5f97\u8fd9\u79cd\u81ea\u52a8\u8f6c\u6362\u4e0d\u6ee1\u8db3\u8981\u6c42\uff0c\u53ef\u4ee5\u5bf9\u5176\u505a\u5b9a\u5236\u3002 Dubbo\u4e2d\u7684REST\u5b9e\u73b0\u662f\u7528JAXB\u505aXML\u5e8f\u5217\u5316\uff0c\u7528Jackson\u505aJSON\u5e8f\u5217\u5316\uff0c\u6240\u4ee5\u5728\u5bf9\u8c61\u4e0a\u6dfb\u52a0JAXB\u6216Jackson\u7684annotation\u5373\u53ef\u4ee5\u5b9a\u5236\u6620\u5c04\u3002 \u4f8b\u5982\uff0c\u5b9a\u5236\u5bf9\u8c61\u5c5e\u6027\u6620\u5c04\u5230XML\u5143\u7d20\u7684\u540d\u5b57\uff1a @XmlRootElement @XmlAccessorType(XmlAccessType.FIELD) public class User implements Serializable { @XmlElement(name= username ) private String name; } \u5b9a\u5236\u5bf9\u8c61\u5c5e\u6027\u6620\u5c04\u5230JSON\u5b57\u6bb5\u7684\u540d\u5b57\uff1a public class User implements Serializable { @JsonProperty( username ) private String name; } \u66f4\u591a\u8d44\u6599\u8bf7\u53c2\u8003JAXB\u548cJackson\u7684\u5b98\u65b9\u6587\u6863\uff0c\u6216\u81ea\u884cgoogle\u3002","title":"\u5b9a\u5236\u5e8f\u5217\u5316"},{"location":"user/references/protocol/rest/#rest-server","text":"\u76ee\u524d\u5728dubbo\u4e2d\uff0c\u6211\u4eec\u652f\u63015\u79cd\u5d4c\u5165\u5f0frest server\u7684\u5b9e\u73b0\uff0c\u5e76\u540c\u65f6\u652f\u6301\u91c7\u7528\u5916\u90e8\u5e94\u7528\u670d\u52a1\u5668\u6765\u505arest server\u7684\u5b9e\u73b0\u3002rest server\u53ef\u4ee5\u901a\u8fc7\u5982\u4e0b\u914d\u7f6e\u5b9e\u73b0\uff1a dubbo:protocol name= rest server= jetty / \u4ee5\u4e0a\u914d\u7f6e\u9009\u7528\u4e86\u5d4c\u5165\u5f0f\u7684jetty\u6765\u505arest server\uff0c\u540c\u65f6\uff0c\u5982\u679c\u4e0d\u914d\u7f6eserver\u5c5e\u6027\uff0crest\u534f\u8bae\u9ed8\u8ba4\u4e5f\u662f\u9009\u7528jetty\u3002jetty\u662f\u975e\u5e38\u6210\u719f\u7684java servlet\u5bb9\u5668\uff0c\u5e76\u548cdubbo\u5df2\u7ecf\u6709\u8f83\u597d\u7684\u96c6\u6210\uff08\u76ee\u524d5\u79cd\u5d4c\u5165\u5f0fserver\u4e2d\u53ea\u6709jetty\u548c\u540e\u9762\u6240\u8ff0\u7684tomcat\u3001tjws\uff0c\u4e0edubbo\u76d1\u63a7\u7cfb\u7edf\u7b49\u5b8c\u6210\u4e86\u65e0\u7f1d\u7684\u96c6\u6210\uff09\uff0c\u6240\u4ee5\uff0c\u5982\u679c\u4f60\u7684dubbo\u7cfb\u7edf\u662f\u5355\u72ec\u542f\u52a8\u7684\u8fdb\u7a0b\uff0c\u4f60\u53ef\u4ee5\u76f4\u63a5\u9ed8\u8ba4\u91c7\u7528jetty\u5373\u53ef\u3002 dubbo:protocol name= rest server= tomcat / \u4ee5\u4e0a\u914d\u7f6e\u9009\u7528\u4e86\u5d4c\u5165\u5f0f\u7684tomcat\u6765\u505arest server\u3002\u5728\u5d4c\u5165\u5f0ftomcat\u4e0a\uff0cREST\u7684\u6027\u80fd\u6bd4jetty\u4e0a\u8981\u597d\u5f97\u591a\uff08\u53c2\u89c1\u540e\u9762\u7684\u57fa\u51c6\u6d4b\u8bd5\uff09\uff0c\u5efa\u8bae\u5728\u9700\u8981\u9ad8\u6027\u80fd\u7684\u573a\u666f\u4e0b\u91c7\u7528tomcat\u3002 dubbo:protocol name= rest server= netty / \u4ee5\u4e0a\u914d\u7f6e\u9009\u7528\u5d4c\u5165\u5f0f\u7684netty\u6765\u505arest server\u3002\uff08TODO more contents to add\uff09 dubbo:protocol name= rest server= tjws / (tjws is now deprecated) dubbo:protocol name= rest server= sunhttp / \u4ee5\u4e0a\u914d\u7f6e\u9009\u7528\u5d4c\u5165\u5f0f\u7684tjws\u6216Sun HTTP server\u6765\u505arest server\u3002\u8fd9\u4e24\u4e2aserver\u5b9e\u73b0\u975e\u5e38\u8f7b\u91cf\u7ea7\uff0c\u975e\u5e38\u65b9\u4fbf\u5728\u96c6\u6210\u6d4b\u8bd5\u4e2d\u5feb\u901f\u542f\u52a8\u4f7f\u7528\uff0c\u5f53\u7136\u4e5f\u53ef\u4ee5\u5728\u8d1f\u8377\u4e0d\u9ad8\u7684\u751f\u4ea7\u73af\u5883\u4e2d\u4f7f\u7528\u3002 \u6ce8\uff1atjws\u76ee\u524d\u5df2\u7ecf\u88abdeprecated\u6389\u4e86\uff0c\u56e0\u4e3a\u5b83\u4e0d\u80fd\u5f88\u597d\u7684\u548cservlet 3.1 API\u5de5\u4f5c\u3002 \u5982\u679c\u4f60\u7684dubbo\u7cfb\u7edf\u4e0d\u662f\u5355\u72ec\u542f\u52a8\u7684\u8fdb\u7a0b\uff0c\u800c\u662f\u90e8\u7f72\u5230\u4e86Java\u5e94\u7528\u670d\u52a1\u5668\u4e2d\uff0c\u5219\u5efa\u8bae\u4f60\u91c7\u7528\u4ee5\u4e0b\u914d\u7f6e\uff1a dubbo:protocol name= rest server= servlet / \u901a\u8fc7\u5c06server\u8bbe\u7f6e\u4e3aservlet\uff0cdubbo\u5c06\u91c7\u7528\u5916\u90e8\u5e94\u7528\u670d\u52a1\u5668\u7684servlet\u5bb9\u5668\u6765\u505arest server\u3002\u540c\u65f6\uff0c\u8fd8\u8981\u5728dubbo\u7cfb\u7edf\u7684web.xml\u4e2d\u6dfb\u52a0\u5982\u4e0b\u914d\u7f6e\uff1a web-app context-param param-name contextConfigLocation /param-name param-value /WEB-INF/classes/META-INF/spring/dubbo-demo-provider.xml /param-value /context-param listener listener-class org.apache.dubbo.remoting.http.servlet.BootstrapListener /listener-class /listener listener listener-class org.springframework.web.context.ContextLoaderListener /listener-class /listener servlet servlet-name dispatcher /servlet-name servlet-class org.apache.dubbo.remoting.http.servlet.DispatcherServlet /servlet-class load-on-startup 1 /load-on-startup /servlet servlet-mapping servlet-name dispatcher /servlet-name url-pattern /* /url-pattern /servlet-mapping /web-app \u5373\u5fc5\u987b\u5c06dubbo\u7684BootstrapListener\u548cDispatherServlet\u6dfb\u52a0\u5230web.xml\uff0c\u4ee5\u5b8c\u6210dubbo\u7684REST\u529f\u80fd\u4e0e\u5916\u90e8servlet\u5bb9\u5668\u7684\u96c6\u6210\u3002 \u6ce8\u610f\uff1a\u5982\u679c\u4f60\u662f\u7528spring\u7684ContextLoaderListener\u6765\u52a0\u8f7dspring\uff0c\u5219\u5fc5\u987b\u4fdd\u8bc1BootstrapListener\u914d\u7f6e\u5728ContextLoaderListener\u4e4b\u524d\uff0c\u5426\u5219dubbo\u521d\u59cb\u5316\u4f1a\u51fa\u9519\u3002 \u5176\u5b9e\uff0c\u8fd9\u79cd\u573a\u666f\u4e0b\u4f60\u4f9d\u7136\u53ef\u4ee5\u575a\u6301\u7528\u5d4c\u5165\u5f0fserver\uff0c\u4f46\u5916\u90e8\u5e94\u7528\u670d\u52a1\u5668\u7684servlet\u5bb9\u5668\u5f80\u5f80\u6bd4\u5d4c\u5165\u5f0fserver\u66f4\u52a0\u5f3a\u5927\uff08\u7279\u522b\u662f\u5982\u679c\u4f60\u662f\u90e8\u7f72\u5230\u66f4\u5065\u58ee\u66f4\u53ef\u4f38\u7f29\u7684WebLogic\uff0cWebSphere\u7b49\uff09\uff0c\u53e6\u5916\u6709\u65f6\u4e5f\u4fbf\u4e8e\u5728\u5e94\u7528\u670d\u52a1\u5668\u505a\u7edf\u4e00\u7ba1\u7406\u3001\u76d1\u63a7\u7b49\u7b49\u3002","title":"\u914d\u7f6eREST Server\u7684\u5b9e\u73b0"},{"location":"user/references/protocol/rest/#context","text":"\u5728\u8fdc\u7a0b\u8c03\u7528\u4e2d\uff0c\u503c\u5f97\u83b7\u53d6\u7684\u4e0a\u4e0b\u6587\u4fe1\u606f\u53ef\u80fd\u6709\u5f88\u591a\u79cd\uff0c\u8fd9\u91cc\u7279\u522b\u4ee5\u83b7\u53d6\u5ba2\u6237\u7aefIP\u4e3a\u4f8b\u3002 \u5728dubbo\u7684REST\u4e2d\uff0c\u6211\u4eec\u6709\u4e24\u79cd\u65b9\u5f0f\u83b7\u53d6\u5ba2\u6237\u7aefIP\u3002 \u7b2c\u4e00\u79cd\u65b9\u5f0f\uff0c\u7528JAX-RS\u6807\u51c6\u7684@Context annotation\uff1a public User getUser(@PathParam( id ) Long id, @Context HttpServletRequest request) { System.out.println( Client address is + request.getRemoteAddr()); } \u7528Context\u4fee\u9970getUser()\u7684\u4e00\u4e2a\u65b9\u6cd5\u53c2\u6570\u540e\uff0c\u5c31\u53ef\u4ee5\u5c06\u5f53\u524d\u7684HttpServletRequest\u6ce8\u5165\u8fdb\u6765\uff0c\u7136\u540e\u76f4\u63a5\u8c03\u7528servlet api\u83b7\u53d6IP\u3002 \u6ce8\u610f\uff1a\u8fd9\u79cd\u65b9\u5f0f\u53ea\u80fd\u5728\u5c06server\u8bbe\u7f6e\u4e3a tjws\u3001tomcat\u3001jetty \u6216\u8005 servlet \u7684\u65f6\u5019\u624d\u80fd\u5de5\u4f5c\uff0c\u56e0\u4e3a\u53ea\u6709\u8fd9\u51e0\u79cd server \u7684\u5b9e\u73b0\u624d\u63d0\u4f9b\u4e86 servlet \u5bb9\u5668\u3002\u53e6\u5916\uff0c\u6807\u51c6\u7684JAX-RS\u8fd8\u652f\u6301\u7528@Context\u4fee\u9970service\u7c7b\u7684\u4e00\u4e2a\u5b9e\u4f8b\u5b57\u6bb5\u6765\u83b7\u53d6HttpServletRequest\uff0c\u4f46\u5728dubbo\u4e2d\u6211\u4eec\u6ca1\u6709\u5bf9\u6b64\u4f5c\u51fa\u652f\u6301\u3002 \u7b2c\u4e8c\u79cd\u65b9\u5f0f\uff0c\u7528dubbo\u4e2d\u5e38\u7528\u7684RpcContext\uff1a public User getUser(@PathParam( id ) Long id) { System.out.println( Client address is + RpcContext.getContext().getRemoteAddressString()); } \u6ce8\u610f\uff1a\u8fd9\u79cd\u65b9\u5f0f\u53ea\u80fd\u5728\u8bbe\u7f6eserver=\"jetty\"\u6216\u8005server=\"tomcat\"\u6216\u8005server=\"servlet\"\u6216\u8005server=\"tjws\"\u7684\u65f6\u5019\u624d\u80fd\u5de5\u4f5c\u3002\u53e6\u5916\uff0c\u76ee\u524ddubbo\u7684RpcContext\u662f\u4e00\u79cd\u6bd4\u8f83\u6709\u4fb5\u5165\u6027\u7684\u7528\u6cd5\uff0c\u672a\u6765\u6211\u4eec\u5f88\u53ef\u80fd\u4f1a\u505a\u51fa\u91cd\u6784\u3002 \u5982\u679c\u4f60\u60f3\u4fdd\u6301\u4f60\u7684\u9879\u76ee\u5bf9JAX-RS\u7684\u517c\u5bb9\u6027\uff0c\u672a\u6765\u8131\u79bbdubbo\u4e5f\u53ef\u4ee5\u8fd0\u884c\uff0c\u8bf7\u9009\u62e9\u7b2c\u4e00\u79cd\u65b9\u5f0f\u3002\u5982\u679c\u4f60\u60f3\u8981\u66f4\u4f18\u96c5\u7684\u670d\u52a1\u63a5\u53e3\u5b9a\u4e49\uff0c\u8bf7\u9009\u7528\u7b2c\u4e8c\u79cd\u65b9\u5f0f\u3002 \u6b64\u5916\uff0c\u5728\u6700\u65b0\u7684dubbo rest\u4e2d\uff0c\u8fd8\u652f\u6301\u901a\u8fc7RpcContext\u6765\u83b7\u53d6HttpServletRequest\u548cHttpServletResponse\uff0c\u4ee5\u63d0\u4f9b\u66f4\u5927\u7684\u7075\u6d3b\u6027\u6765\u65b9\u4fbf\u7528\u6237\u5b9e\u73b0\u67d0\u4e9b\u590d\u6742\u529f\u80fd\uff0c\u6bd4\u5982\u5728dubbo\u6807\u51c6\u7684filter\u4e2d\u8bbf\u95eeHTTP Header\u3002\u7528\u6cd5\u793a\u4f8b\u5982\u4e0b\uff1a if (RpcContext.getContext().getRequest() != null RpcContext.getContext().getRequest() instanceof HttpServletRequest) { System.out.println( Client address is + ((HttpServletRequest) RpcContext.getContext().getRequest()).getRemoteAddr()); } if (RpcContext.getContext().getResponse() != null RpcContext.getContext().getResponse() instanceof HttpServletResponse) { System.out.println( Response object from RpcContext: + RpcContext.getContext().getResponse()); } \u6ce8\u610f\uff1a\u4e3a\u4e86\u4fdd\u6301\u534f\u8bae\u7684\u4e2d\u7acb\u6027\uff0cRpcContext.getRequest()\u548cRpcContext.getResponse()\u8fd4\u56de\u7684\u4ec5\u4ec5\u662f\u4e00\u4e2aObject\u7c7b\uff0c\u800c\u4e14\u53ef\u80fd\u4e3anull\u3002\u6240\u4ee5\uff0c\u4f60\u5fc5\u987b\u81ea\u5df1\u505anull\u548c\u7c7b\u578b\u7684\u68c0\u67e5\u3002 \u6ce8\u610f\uff1a\u53ea\u6709\u5728\u8bbe\u7f6eserver=\"jetty\"\u6216\u8005server=\"tomcat\"\u6216\u8005server=\"servlet\"\u7684\u65f6\u5019\uff0c\u4f60\u624d\u80fd\u901a\u8fc7\u4ee5\u4e0a\u65b9\u6cd5\u6b63\u786e\u7684\u5f97\u5230HttpServletRequest\u548cHttpServletResponse\uff0c\u56e0\u4e3a\u53ea\u6709\u8fd9\u51e0\u79cdserver\u5b9e\u73b0\u4e86servlet\u5bb9\u5668\u3002 \u4e3a\u4e86\u7b80\u5316\u7f16\u7a0b\uff0c\u5728\u6b64\u4f60\u4e5f\u53ef\u4ee5\u7528\u6cdb\u578b\u7684\u65b9\u5f0f\u6765\u76f4\u63a5\u83b7\u53d6\u7279\u5b9a\u7c7b\u578b\u7684request/response\uff1a if (RpcContext.getContext().getRequest(HttpServletRequest.class) != null) { System.out.println( Client address is + RpcContext.getContext().getRequest(HttpServletRequest.class).getRemoteAddr()); } if (RpcContext.getContext().getResponse(HttpServletResponse.class) != null) { System.out.println( Response object from RpcContext: + RpcContext.getContext().getResponse(HttpServletResponse.class)); } \u5982\u679crequest/response\u4e0d\u7b26\u5408\u6307\u5b9a\u7684\u7c7b\u578b\uff0c\u8fd9\u91cc\u4e5f\u4f1a\u8fd4\u56denull\u3002","title":"\u83b7\u53d6\u4e0a\u4e0b\u6587\uff08Context\uff09\u4fe1\u606f"},{"location":"user/references/protocol/rest/#context-path","text":"dubbo\u4e2d\u7684rest\u534f\u8bae\u9ed8\u8ba4\u5c06\u91c7\u752880\u7aef\u53e3\uff0c\u5982\u679c\u60f3\u4fee\u6539\u7aef\u53e3\uff0c\u76f4\u63a5\u914d\u7f6e\uff1a dubbo:protocol name= rest port= 8888 / \u53e6\u5916\uff0c\u5982\u524d\u6240\u8ff0\uff0c\u6211\u4eec\u53ef\u4ee5\u7528@Path\u6765\u914d\u7f6e\u5355\u4e2arest\u670d\u52a1\u7684URL\u76f8\u5bf9\u8def\u5f84\u3002\u4f46\u5176\u5b9e\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u8bbe\u7f6e\u4e00\u4e2a\u6240\u6709rest\u670d\u52a1\u90fd\u9002\u7528\u7684\u57fa\u7840\u76f8\u5bf9\u8def\u5f84\uff0c\u5373java web\u5e94\u7528\u4e2d\u5e38\u8bf4\u7684context path\u3002 \u53ea\u9700\u8981\u6dfb\u52a0\u5982\u4e0bcontextpath\u5c5e\u6027\u5373\u53ef\uff1a dubbo:protocol name= rest port= 8888 contextpath= services / \u4ee5\u524d\u9762\u4ee3\u7801\u4e3a\u4f8b\uff1a @Path( users ) public class UserServiceImpl implements UserService { @POST @Path( register ) @Consumes({MediaType.APPLICATION_JSON}) public void registerUser(User user) { // save the user... } } \u73b0\u5728registerUser()\u7684\u5b8c\u6574\u8bbf\u95ee\u8def\u5f84\u4e3a\uff1a http://localhost:8888/services/users/register \u6ce8\u610f\uff1a\u5982\u679c\u4f60\u662f\u9009\u7528\u5916\u90e8\u5e94\u7528\u670d\u52a1\u5668\u505arest server\uff0c\u5373\u914d\u7f6e: dubbo:protocol name= rest port= 8888 contextpath= services server= servlet / \u5219\u5fc5\u987b\u4fdd\u8bc1\u8fd9\u91cc\u8bbe\u7f6e\u7684port\u3001contextpath\uff0c\u4e0e\u5916\u90e8\u5e94\u7528\u670d\u52a1\u5668\u7684\u7aef\u53e3\u3001DispatcherServlet\u7684\u4e0a\u4e0b\u6587\u8def\u5f84\uff08\u5373webapp path\u52a0\u4e0aservlet url pattern\uff09\u4fdd\u6301\u4e00\u81f4\u3002\u4f8b\u5982\uff0c\u5bf9\u4e8e\u90e8\u7f72\u4e3atomcat ROOT\u8def\u5f84\u7684\u5e94\u7528\uff0c\u8fd9\u91cc\u7684contextpath\u5fc5\u987b\u4e0eweb.xml\u4e2dDispacherServlet\u7684 url-pattern/ \u5b8c\u5168\u4e00\u81f4\uff1a servlet-mapping servlet-name dispatcher /servlet-name url-pattern /services/* /url-pattern /servlet-mapping","title":"\u914d\u7f6e\u7aef\u53e3\u53f7\u548cContext Path"},{"location":"user/references/protocol/rest/#io","text":"\u53ef\u4ee5\u4e3arest\u670d\u52a1\u914d\u7f6e\u7ebf\u7a0b\u6c60\u5927\u5c0f\uff1a dubbo:protocol name= rest threads= 500 / \u6ce8\u610f\uff1a\u76ee\u524d\u7ebf\u7a0b\u6c60\u7684\u8bbe\u7f6e\u53ea\u6709\u5f53server=\"netty\"\u6216\u8005server=\"jetty\"\u6216\u8005server=\"tomcat\"\u7684\u65f6\u5019\u624d\u80fd\u751f\u6548\u3002\u53e6\u5916\uff0c\u5982\u679cserver=\"servlet\"\uff0c\u7531\u4e8e\u8fd9\u65f6\u5019\u542f\u7528\u7684\u662f\u5916\u90e8\u5e94\u7528\u670d\u52a1\u5668\u505arest server\uff0c\u4e0d\u53d7dubbo\u63a7\u5236\uff0c\u6240\u4ee5\u8fd9\u91cc\u7684\u7ebf\u7a0b\u6c60\u8bbe\u7f6e\u4e5f\u65e0\u6548\u3002 \u5982\u679c\u662f\u9009\u7528netty server\uff0c\u8fd8\u53ef\u4ee5\u914d\u7f6eNetty\u7684IO worker\u7ebf\u7a0b\u6570\uff1a dubbo:protocol name= rest iothreads= 5 threads= 100 /","title":"\u914d\u7f6e\u7ebf\u7a0b\u6570\u548cIO\u7ebf\u7a0b\u6570"},{"location":"user/references/protocol/rest/#_4","text":"Dubbo\u4e2d\u7684rest\u670d\u52a1\u9ed8\u8ba4\u90fd\u662f\u91c7\u7528http\u957f\u8fde\u63a5\u6765\u8bbf\u95ee\uff0c\u5982\u679c\u60f3\u5207\u6362\u4e3a\u77ed\u8fde\u63a5\uff0c\u76f4\u63a5\u914d\u7f6e\uff1a dubbo:protocol name= rest keepalive= false / \u6ce8\u610f\uff1a\u8fd9\u4e2a\u914d\u7f6e\u76ee\u524d\u53ea\u5bf9server=\"netty\"\u548cserver=\"tomcat\"\u624d\u80fd\u751f\u6548\u3002","title":"\u914d\u7f6e\u957f\u8fde\u63a5"},{"location":"user/references/protocol/rest/#http","text":"\u53ef\u4ee5\u914d\u7f6e\u670d\u52a1\u5668\u63d0\u4f9b\u7aef\u6240\u80fd\u540c\u65f6\u63a5\u6536\u7684\u6700\u5927HTTP\u8fde\u63a5\u6570\uff0c\u9632\u6b62REST server\u88ab\u8fc7\u591a\u8fde\u63a5\u6491\u7206\uff0c\u4ee5\u4f5c\u4e3a\u4e00\u79cd\u6700\u57fa\u672c\u7684\u81ea\u6211\u4fdd\u62a4\u673a\u5236\uff1a dubbo:protocol name= rest accepts= 500 server= tomcat/ \u6ce8\u610f\uff1a\u8fd9\u4e2a\u914d\u7f6e\u76ee\u524d\u53ea\u5bf9server=\"tomcat\"\u624d\u80fd\u751f\u6548\u3002","title":"\u914d\u7f6e\u6700\u5927\u7684HTTP\u8fde\u63a5\u6570"},{"location":"user/references/protocol/rest/#http_1","text":"\u5982\u679crest\u670d\u52a1\u7684\u6d88\u8d39\u7aef\u4e5f\u662fdubbo\u7cfb\u7edf\uff0c\u53ef\u4ee5\u50cf\u5176\u4ed6dubbo RPC\u673a\u5236\u4e00\u6837\uff0c\u914d\u7f6e\u6d88\u8d39\u7aef\u8c03\u7528\u6b64rest\u670d\u52a1\u7684\u6700\u5927\u8d85\u65f6\u65f6\u95f4\u4ee5\u53ca\u6bcf\u4e2a\u6d88\u8d39\u7aef\u6240\u80fd\u542f\u52a8\u7684\u6700\u5927HTTP\u8fde\u63a5\u6570\u3002 dubbo:service interface= xxx ref= xxx protocol= rest timeout= 2000 connections= 10 / \u5f53\u7136\uff0c\u7531\u4e8e\u8fd9\u4e2a\u914d\u7f6e\u9488\u5bf9\u6d88\u8d39\u7aef\u751f\u6548\u7684\uff0c\u6240\u4ee5\u4e5f\u53ef\u4ee5\u5728\u6d88\u8d39\u7aef\u914d\u7f6e\uff1a dubbo:reference id= xxx interface= xxx timeout= 2000 connections= 10 / \u4f46\u662f\uff0c\u901a\u5e38\u6211\u4eec\u5efa\u8bae\u914d\u7f6e\u5728\u670d\u52a1\u63d0\u4f9b\u7aef\u63d0\u4f9b\u6b64\u7c7b\u914d\u7f6e\u3002\u6309\u7167dubbo\u5b98\u65b9\u6587\u6863\u7684\u8bf4\u6cd5\uff1a\u201cProvider\u4e0a\u5c3d\u91cf\u591a\u914d\u7f6eConsumer\u7aef\u7684\u5c5e\u6027\uff0c\u8ba9Provider\u5b9e\u73b0\u8005\u4e00\u5f00\u59cb\u5c31\u601d\u8003Provider\u670d\u52a1\u7279\u70b9\u3001\u670d\u52a1\u8d28\u91cf\u7684\u95ee\u9898\u3002\u201d \u6ce8\u610f\uff1a\u5982\u679cdubbo\u7684REST\u670d\u52a1\u662f\u53d1\u5e03\u7ed9\u975edubbo\u7684\u5ba2\u6237\u7aef\u4f7f\u7528\uff0c\u5219\u8fd9\u91cc dubbo:service/ \u4e0a\u7684\u914d\u7f6e\u5b8c\u5168\u65e0\u6548\uff0c\u56e0\u4e3a\u8fd9\u79cd\u5ba2\u6237\u7aef\u4e0d\u53d7dubbo\u63a7\u5236\u3002","title":"\u914d\u7f6e\u6bcf\u4e2a\u6d88\u8d39\u7aef\u7684\u8d85\u65f6\u65f6\u95f4\u548cHTTP\u8fde\u63a5\u6570"},{"location":"user/references/protocol/rest/#annotationspring-xml","text":"\u4ee5\u4e0a\u6240\u6709\u7684\u8ba8\u8bba\u90fd\u662f\u57fa\u4e8edubbo\u5728spring\u4e2d\u7684xml\u914d\u7f6e\u3002\u4f46\u662f\uff0cdubbo/spring\u672c\u8eab\u4e5f\u652f\u6301\u7528annotation\u6765\u4f5c\u914d\u7f6e\uff0c\u6240\u4ee5\u6211\u4eec\u4e5f\u53ef\u4ee5\u6309dubbo\u5b98\u65b9\u6587\u6863\u4e2d\u7684\u6b65\u9aa4\uff0c\u628a\u76f8\u5173annotation\u52a0\u5230REST\u670d\u52a1\u7684\u5b9e\u73b0\u4e2d\uff0c\u53d6\u4ee3\u4e00\u4e9bxml\u914d\u7f6e\uff0c\u4f8b\u5982\uff1a @Service(protocol = rest ) @Path( users ) public class UserServiceImpl implements UserService { @Autowired private UserRepository userRepository; @POST @Path( register ) @Consumes({MediaType.APPLICATION_JSON}) public void registerUser(User user) { // save the user userRepository.save(user); } } annotation\u7684\u914d\u7f6e\u66f4\u7b80\u5355\u66f4\u7cbe\u786e\uff0c\u901a\u5e38\u4e5f\u66f4\u4fbf\u4e8e\u7ef4\u62a4\uff08\u5f53\u7136\u73b0\u4ee3IDE\u90fd\u53ef\u4ee5\u5728xml\u4e2d\u652f\u6301\u6bd4\u5982\u7c7b\u540d\u91cd\u6784\uff0c\u6240\u4ee5\u5c31\u8fd9\u91cc\u7684\u7279\u5b9a\u7528\u4f8b\u800c\u8a00\uff0cxml\u7684\u7ef4\u62a4\u6027\u4e5f\u5f88\u597d\uff09\u3002\u800cxml\u5bf9\u4ee3\u7801\u7684\u4fb5\u5165\u6027\u66f4\u5c0f\u4e00\u4e9b\uff0c\u5c24\u5176\u6709\u5229\u4e8e\u52a8\u6001\u4fee\u6539\u914d\u7f6e\uff0c\u7279\u522b\u662f\u6bd4\u5982\u4f60\u8981\u9488\u5bf9\u5355\u4e2a\u670d\u52a1\u914d\u7f6e\u8fde\u63a5\u8d85\u65f6\u65f6\u95f4\u3001\u6bcf\u5ba2\u6237\u7aef\u6700\u5927\u8fde\u63a5\u6570\u3001\u96c6\u7fa4\u7b56\u7565\u3001\u6743\u91cd\u7b49\u7b49\u3002\u53e6\u5916\uff0c\u7279\u522b\u5bf9\u590d\u6742\u5e94\u7528\u6216\u8005\u6a21\u5757\u6765\u8bf4\uff0cxml\u63d0\u4f9b\u4e86\u4e00\u4e2a\u4e2d\u5fc3\u70b9\u6765\u6db5\u76d6\u7684\u6240\u6709\u7ec4\u4ef6\u548c\u914d\u7f6e\uff0c\u66f4\u4e00\u76ee\u4e86\u7136\uff0c\u4e00\u822c\u66f4\u4fbf\u4e8e\u9879\u76ee\u957f\u65f6\u671f\u7684\u7ef4\u62a4\u3002 \u5f53\u7136\uff0c\u9009\u62e9\u54ea\u79cd\u914d\u7f6e\u65b9\u5f0f\u6ca1\u6709\u7edd\u5bf9\u7684\u4f18\u52a3\uff0c\u548c\u4e2a\u4eba\u7684\u504f\u597d\u4e5f\u4e0d\u65e0\u5173\u7cfb\u3002","title":"\u7528Annotation\u53d6\u4ee3\u90e8\u5206Spring XML\u914d\u7f6e"},{"location":"user/references/protocol/rest/#filterinterceptor","text":"Dubbo\u7684REST\u4e5f\u652f\u6301JAX-RS\u6807\u51c6\u7684Filter\u548cInterceptor\uff0c\u4ee5\u65b9\u4fbf\u5bf9REST\u7684\u8bf7\u6c42\u4e0e\u54cd\u5e94\u8fc7\u7a0b\u505a\u5b9a\u5236\u5316\u7684\u62e6\u622a\u5904\u7406\u3002 \u5176\u4e2d\uff0cFilter\u4e3b\u8981\u7528\u4e8e\u8bbf\u95ee\u548c\u8bbe\u7f6eHTTP\u8bf7\u6c42\u548c\u54cd\u5e94\u7684\u53c2\u6570\u3001URI\u7b49\u7b49\u3002\u4f8b\u5982\uff0c\u8bbe\u7f6eHTTP\u54cd\u5e94\u7684cache header\uff1a public class CacheControlFilter implements ContainerResponseFilter { public void filter(ContainerRequestContext req, ContainerResponseContext res) { if (req.getMethod().equals( GET )) { res.getHeaders().add( Cache-Control , someValue ); } } } Interceptor\u4e3b\u8981\u7528\u4e8e\u8bbf\u95ee\u548c\u4fee\u6539\u8f93\u5165\u4e0e\u8f93\u51fa\u5b57\u8282\u6d41\uff0c\u4f8b\u5982\uff0c\u624b\u52a8\u6dfb\u52a0GZIP\u538b\u7f29\uff1a public class GZIPWriterInterceptor implements WriterInterceptor { @Override public void aroundWriteTo(WriterInterceptorContext context) throws IOException, WebApplicationException { OutputStream outputStream = context.getOutputStream(); context.setOutputStream(new GZIPOutputStream(outputStream)); context.proceed(); } } \u5728\u6807\u51c6JAX-RS\u5e94\u7528\u4e2d\uff0c\u6211\u4eec\u4e00\u822c\u662f\u4e3aFilter\u548cInterceptor\u6dfb\u52a0@Provider annotation\uff0c\u7136\u540eJAX-RS runtime\u4f1a\u81ea\u52a8\u53d1\u73b0\u5e76\u542f\u7528\u5b83\u4eec\u3002\u800c\u5728dubbo\u4e2d\uff0c\u6211\u4eec\u662f\u901a\u8fc7\u6dfb\u52a0XML\u914d\u7f6e\u7684\u65b9\u5f0f\u6765\u6ce8\u518cFilter\u548cInterceptor\uff1a dubbo:protocol name= rest port= 8888 extension= xxx.TraceInterceptor, xxx.TraceFilter / \u5728\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06Filter\u3001Interceptor\u548cDynamicFeature\u8fd9\u4e09\u79cd\u7c7b\u578b\u7684\u5bf9\u8c61\u90fd\u6dfb\u52a0\u5230 extension \u5c5e\u6027\u4e0a\uff0c\u591a\u4e2a\u4e4b\u95f4\u7528\u9017\u53f7\u5206\u9694\u3002\uff08DynamicFeature\u662f\u53e6\u4e00\u4e2a\u63a5\u53e3\uff0c\u53ef\u4ee5\u65b9\u4fbf\u6211\u4eec\u66f4\u52a8\u6001\u7684\u542f\u7528Filter\u548cInterceptor\uff0c\u611f\u5174\u8da3\u8bf7\u81ea\u884cgoogle\u3002\uff09 \u5f53\u7136\uff0cdubbo\u81ea\u8eab\u4e5f\u652f\u6301Filter\u7684\u6982\u5ff5\uff0c\u4f46\u6211\u4eec\u8fd9\u91cc\u8ba8\u8bba\u7684Filter\u548cInterceptor\u66f4\u52a0\u63a5\u8fd1\u534f\u8bae\u5b9e\u73b0\u7684\u5e95\u5c42\uff0c\u76f8\u6bd4dubbo\u7684filter\uff0c\u53ef\u4ee5\u505a\u66f4\u5e95\u5c42\u7684\u5b9a\u5236\u5316\u3002 \u6ce8\uff1a\u8fd9\u91cc\u7684XML\u5c5e\u6027\u53ebextension\uff0c\u800c\u4e0d\u662f\u53ebinterceptor\u6216\u8005filter\uff0c\u662f\u56e0\u4e3a\u9664\u4e86Interceptor\u548cFilter\uff0c\u672a\u6765\u6211\u4eec\u8fd8\u4f1a\u6dfb\u52a0\u66f4\u591a\u7684\u6269\u5c55\u7c7b\u578b\u3002 \u5982\u679cREST\u7684\u6d88\u8d39\u7aef\u4e5f\u662fdubbo\u7cfb\u7edf\uff08\u53c2\u89c1\u4e0b\u6587\u7684\u8ba8\u8bba\uff09\uff0c\u5219\u4e5f\u53ef\u4ee5\u7528\u7c7b\u4f3c\u65b9\u5f0f\u4e3a\u6d88\u8d39\u7aef\u914d\u7f6eInterceptor\u548cFilter\u3002\u4f46\u6ce8\u610f\uff0cJAX-RS\u4e2d\u6d88\u8d39\u7aef\u7684Filter\u548c\u63d0\u4f9b\u7aef\u7684Filter\u662f\u4e24\u79cd\u4e0d\u540c\u7684\u63a5\u53e3\u3002\u4f8b\u5982\u524d\u9762\u4f8b\u5b50\u4e2d\u670d\u52a1\u7aef\u662fContainerResponseFilter\u63a5\u53e3\uff0c\u800c\u6d88\u8d39\u7aef\u5bf9\u5e94\u7684\u662fClientResponseFilter: public class LoggingFilter implements ClientResponseFilter { public void filter(ClientRequestContext reqCtx, ClientResponseContext resCtx) throws IOException { System.out.println( status: + resCtx.getStatus()); System.out.println( date: + resCtx.getDate()); System.out.println( last-modified: + resCtx.getLastModified()); System.out.println( location: + resCtx.getLocation()); System.out.println( headers: ); for (Entry String, List String header : resCtx.getHeaders().entrySet()) { System.out.print( \\t + header.getKey() + : ); for (String value : header.getValue()) { System.out.print(value + , ); } System.out.print( \\n ); } System.out.println( media-type: + resCtx.getMediaType().getType()); } }","title":"\u6dfb\u52a0\u81ea\u5b9a\u4e49\u7684Filter\u3001Interceptor\u7b49"},{"location":"user/references/protocol/rest/#exception","text":"Dubbo\u7684REST\u4e5f\u652f\u6301JAX-RS\u6807\u51c6\u7684ExceptionMapper\uff0c\u53ef\u4ee5\u7528\u6765\u5b9a\u5236\u7279\u5b9aexception\u53d1\u751f\u540e\u5e94\u8be5\u8fd4\u56de\u7684HTTP\u54cd\u5e94\u3002 public class CustomExceptionMapper implements ExceptionMapper NotFoundException { public Response toResponse(NotFoundException e) { return Response.status(Response.Status.NOT_FOUND).entity( Oops! the requested resource is not found! ).type( text/plain ).build(); } } \u548cInterceptor\u3001Filter\u7c7b\u4f3c\uff0c\u5c06\u5176\u6dfb\u52a0\u5230XML\u914d\u7f6e\u6587\u4ef6\u4e2d\u5373\u53ef\u542f\u7528\uff1a dubbo:protocol name= rest port= 8888 extension= xxx.CustomExceptionMapper /","title":"\u6dfb\u52a0\u81ea\u5b9a\u4e49\u7684Exception\u5904\u7406"},{"location":"user/references/protocol/rest/#http_2","text":"Dubbo rest\u652f\u6301\u8f93\u51fa\u6240\u6709HTTP\u8bf7\u6c42/\u54cd\u5e94\u4e2d\u7684header\u5b57\u6bb5\u548cbody\u6d88\u606f\u4f53\u3002 \u5728XML\u914d\u7f6e\u4e2d\u6dfb\u52a0\u5982\u4e0b\u81ea\u5e26\u7684REST filter\uff1a dubbo:protocol name= rest port= 8888 extension= org.apache.dubbo.rpc.protocol.rest.support.LoggingFilter / \u7136\u540e\u914d\u7f6e\u5728logging\u914d\u7f6e\u4e2d\u81f3\u5c11\u4e3aorg.apache.dubbo.rpc.protocol.rest.support\u6253\u5f00INFO\u7ea7\u522b\u65e5\u5fd7\u8f93\u51fa\uff0c\u4f8b\u5982\uff0c\u5728log4j.xml\u4e2d\u914d\u7f6e\uff1a logger name= org.apache.dubbo.rpc.protocol.rest.support level value= INFO / appender-ref ref= CONSOLE / /logger \u5f53\u7136\uff0c\u4f60\u4e5f\u53ef\u4ee5\u76f4\u63a5\u5728ROOT logger\u6253\u5f00INFO\u7ea7\u522b\u65e5\u5fd7\u8f93\u51fa\uff1a root level value= INFO / appender-ref ref= CONSOLE / /root \u7136\u540e\u5728\u65e5\u5fd7\u4e2d\u4f1a\u6709\u7c7b\u4f3c\u5982\u4e0b\u7684\u5185\u5bb9\u8f93\u51fa\uff1a The HTTP headers are: accept: application/json;charset=UTF-8 accept-encoding: gzip, deflate connection: Keep-Alive content-length: 22 content-type: application/json host: 192.168.1.100:8888 user-agent: Apache-HttpClient/4.2.1 (java 1.5) The contents of request body is: { id :1, name : dang } \u6253\u5f00HTTP\u65e5\u5fd7\u8f93\u51fa\u540e\uff0c\u9664\u4e86\u6b63\u5e38\u65e5\u5fd7\u8f93\u51fa\u7684\u6027\u80fd\u5f00\u9500\u5916\uff0c\u4e5f\u4f1a\u5728\u6bd4\u5982HTTP\u8bf7\u6c42\u89e3\u6790\u65f6\u4ea7\u751f\u989d\u5916\u7684\u5f00\u9500\uff0c\u56e0\u4e3a\u9700\u8981\u5efa\u7acb\u989d\u5916\u7684\u5185\u5b58\u7f13\u51b2\u533a\u6765\u4e3a\u65e5\u5fd7\u7684\u8f93\u51fa\u505a\u6570\u636e\u51c6\u5907\u3002","title":"\u914d\u7f6eHTTP\u65e5\u5fd7\u8f93\u51fa"},{"location":"user/references/protocol/rest/#_5","text":"dubbo\u7684rest\u652f\u6301\u91c7\u7528Java\u6807\u51c6\u7684bean validation annotation\uff08JSR 303)\u6765\u505a\u8f93\u5165\u6821\u9a8chttp://beanvalidation.org/ \u4e3a\u4e86\u548c\u5176\u4ed6dubbo\u8fdc\u7a0b\u8c03\u7528\u534f\u8bae\u4fdd\u6301\u4e00\u81f4\uff0c\u5728rest\u4e2d\u4f5c\u6821\u9a8c\u7684annotation\u5fc5\u987b\u653e\u5728\u670d\u52a1\u7684\u63a5\u53e3\u4e0a\uff0c\u4f8b\u5982\uff1a public interface UserService { User getUser(@Min(value=1L, message= User ID must be greater than 1 ) Long id); } \u5f53\u7136\uff0c\u5728\u5f88\u591a\u5176\u4ed6\u7684bean validation\u7684\u5e94\u7528\u573a\u666f\u90fd\u662f\u5c06annotation\u653e\u5230\u5b9e\u73b0\u7c7b\u800c\u4e0d\u662f\u63a5\u53e3\u4e0a\u3002\u628aannotation\u653e\u5728\u63a5\u53e3\u4e0a\u81f3\u5c11\u6709\u4e00\u4e2a\u597d\u5904\u662f\uff0cdubbo\u7684\u5ba2\u6237\u7aef\u53ef\u4ee5\u5171\u4eab\u8fd9\u4e2a\u63a5\u53e3\u7684\u4fe1\u606f\uff0cdubbo\u751a\u81f3\u4e0d\u9700\u8981\u505a\u8fdc\u7a0b\u8c03\u7528\uff0c\u5728\u672c\u5730\u5c31\u53ef\u4ee5\u5b8c\u6210\u8f93\u5165\u6821\u9a8c\u3002 \u7136\u540e\u6309\u7167dubbo\u7684\u6807\u51c6\u65b9\u5f0f\u5728XML\u914d\u7f6e\u4e2d\u6253\u5f00\u9a8c\u8bc1\uff1a dubbo:service interface=xxx.UserService ref= userService protocol= rest validation= true / \u5728dubbo\u7684\u5176\u4ed6\u5f88\u591a\u8fdc\u7a0b\u8c03\u7528\u534f\u8bae\u4e2d\uff0c\u5982\u679c\u8f93\u5165\u9a8c\u8bc1\u51fa\u9519\uff0c\u662f\u76f4\u63a5\u5c06 RpcException \u629b\u5411\u5ba2\u6237\u7aef\uff0c\u800c\u5728rest\u4e2d\u7531\u4e8e\u5ba2\u6237\u7aef\u7ecf\u5e38\u662f\u975edubbo\uff0c\u751a\u81f3\u975ejava\u7684\u7cfb\u7edf\uff0c\u6240\u4ee5\u4e0d\u4fbf\u76f4\u63a5\u629b\u51faJava\u5f02\u5e38\u3002\u56e0\u6b64\uff0c\u76ee\u524d\u6211\u4eec\u5c06\u6821\u9a8c\u9519\u8bef\u4ee5XML\u7684\u683c\u5f0f\u8fd4\u56de\uff1a violationReport constraintViolations path getUserArgument0 /path message User ID must be greater than 1 /message value 0 /value /constraintViolations /violationReport \u7a0d\u540e\u4e5f\u4f1a\u652f\u6301\u5176\u4ed6\u6570\u636e\u683c\u5f0f\u7684\u8fd4\u56de\u503c\u3002\u81f3\u4e8e\u5982\u4f55\u5bf9\u9a8c\u8bc1\u9519\u8bef\u6d88\u606f\u4f5c\u56fd\u9645\u5316\u5904\u7406\uff0c\u76f4\u63a5\u53c2\u8003bean validation\u7684\u76f8\u5173\u6587\u6863\u5373\u53ef\u3002 \u5982\u679c\u4f60\u8ba4\u4e3a\u9ed8\u8ba4\u7684\u6821\u9a8c\u9519\u8bef\u8fd4\u56de\u683c\u5f0f\u4e0d\u7b26\u5408\u4f60\u7684\u8981\u6c42\uff0c\u53ef\u4ee5\u5982\u4e0a\u9762\u7ae0\u8282\u6240\u8ff0\uff0c\u6dfb\u52a0\u81ea\u5b9a\u4e49\u7684ExceptionMapper\u6765\u81ea\u7531\u7684\u5b9a\u5236\u9519\u8bef\u8fd4\u56de\u683c\u5f0f\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u8fd9\u4e2aExceptionMapper\u5fc5\u987b\u7528\u6cdb\u578b\u58f0\u660e\u6765\u6355\u83b7dubbo\u7684RpcException\uff0c\u624d\u80fd\u6210\u529f\u8986\u76d6dubbo rest\u9ed8\u8ba4\u7684\u5f02\u5e38\u5904\u7406\u7b56\u7565\u3002\u4e3a\u4e86\u7b80\u5316\u64cd\u4f5c\uff0c\u5176\u5b9e\u8fd9\u91cc\u6700\u7b80\u5355\u7684\u65b9\u5f0f\u662f\u76f4\u63a5\u7ee7\u627fdubbo rest\u7684RpcExceptionMapper\uff0c\u5e76\u8986\u76d6\u5176\u4e2d\u5904\u7406\u6821\u9a8c\u5f02\u5e38\u7684\u65b9\u6cd5\u5373\u53ef\uff1a public class MyValidationExceptionMapper extends RpcExceptionMapper { protected Response handleConstraintViolationException(ConstraintViolationException cve) { ViolationReport report = new ViolationReport(); for (ConstraintViolation cv : cve.getConstraintViolations()) { report.addConstraintViolation(new RestConstraintViolation( cv.getPropertyPath().toString(), cv.getMessage(), cv.getInvalidValue() == null ? null : cv.getInvalidValue().toString())); } // \u91c7\u7528json\u8f93\u51fa\u4ee3\u66ffxml\u8f93\u51fa return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(report).type(ContentType.APPLICATION_JSON_UTF_8).build(); } } \u7136\u540e\u5c06\u8fd9\u4e2aExceptionMapper\u6dfb\u52a0\u5230XML\u914d\u7f6e\u4e2d\u5373\u53ef\uff1a dubbo:protocol name= rest port= 8888 extension= xxx.MyValidationExceptionMapper /","title":"\u8f93\u5165\u53c2\u6570\u7684\u6821\u9a8c"},{"location":"user/references/protocol/rmi/","text":"rmi:// The RMI protocol uses the JDK standard java.rmi.* Implementation, using a block short connection and JDK standard serialization. Features Number of connections: multiple connections Connection: short connection Transmission protocol: HTTP Transmission: synchronous transmission Serialization: Java standard Object Serialization Scope of application:the number of providers is more than that of consumers and can transfer files. Applicable scenarios: Conventional remote service method calls, interoperating with native RMI services Constraint Parameters and return values must implement Serializable interface The timeout configuration for RMI is invalid, you need to use java startup parameter settings: -Dsun.rmi.transport.tcp.responseTimeout=3000 ,see the RMI configuration below Configuration in dubbo.properties dubbo.service.protocol=rmi RMI Configuration java -Dsun.rmi.transport.tcp.responseTimeout=3000 more RMI options please check JDK Document Interface If the service interface implement the java.rmi.Remote interface, it can interoperate with the native RMI, ie: Providers expose services using Dubbo's RMI protocol, consumers call directly with the standard RMI interface, Or the provider exposes services using standard RMI, and consumers invoke with Dubbo's RMI protocol. If the service interface doesn't implement the java.rmi.Remote interface: Default Dubbo will automatically generate a com.xxx.XxxService$Remote interface and implement the java.rmi.Remote interface, expose the service as this interface, But if dubbo: protocol name = 'rmi' codec = 'spring' / is set, the $Remote interface will not be generated, but Spring's RmiInvocationHandler interface will be used to expose services. Configuration configure RMI protocol\uff1a dubbo:protocol name= rmi port= 1099 / configure provider level default protocol: dubbo:provider protocol= rmi / configure service level default protocol: dubbo:service protocol= rmi / configure multiple port\uff1a dubbo:protocol id= rmi1 name= rmi port= 1099 / dubbo:protocol id= rmi2 name= rmi port= 2099 / dubbo:service protocol= rmi1 / Compatible with Spring\uff1a dubbo:protocol name= rmi codec= spring /","title":"rmi://"},{"location":"user/references/protocol/rmi/#rmi","text":"The RMI protocol uses the JDK standard java.rmi.* Implementation, using a block short connection and JDK standard serialization.","title":"rmi://"},{"location":"user/references/protocol/rmi/#features","text":"Number of connections: multiple connections Connection: short connection Transmission protocol: HTTP Transmission: synchronous transmission Serialization: Java standard Object Serialization Scope of application:the number of providers is more than that of consumers and can transfer files. Applicable scenarios: Conventional remote service method calls, interoperating with native RMI services","title":"Features"},{"location":"user/references/protocol/rmi/#constraint","text":"Parameters and return values must implement Serializable interface The timeout configuration for RMI is invalid, you need to use java startup parameter settings: -Dsun.rmi.transport.tcp.responseTimeout=3000 ,see the RMI configuration below","title":"Constraint"},{"location":"user/references/protocol/rmi/#configuration-in-dubboproperties","text":"dubbo.service.protocol=rmi","title":"Configuration in dubbo.properties"},{"location":"user/references/protocol/rmi/#rmi-configuration","text":"java -Dsun.rmi.transport.tcp.responseTimeout=3000 more RMI options please check JDK Document","title":"RMI Configuration"},{"location":"user/references/protocol/rmi/#interface","text":"If the service interface implement the java.rmi.Remote interface, it can interoperate with the native RMI, ie: Providers expose services using Dubbo's RMI protocol, consumers call directly with the standard RMI interface, Or the provider exposes services using standard RMI, and consumers invoke with Dubbo's RMI protocol. If the service interface doesn't implement the java.rmi.Remote interface: Default Dubbo will automatically generate a com.xxx.XxxService$Remote interface and implement the java.rmi.Remote interface, expose the service as this interface, But if dubbo: protocol name = 'rmi' codec = 'spring' / is set, the $Remote interface will not be generated, but Spring's RmiInvocationHandler interface will be used to expose services.","title":"Interface"},{"location":"user/references/protocol/rmi/#configuration","text":"configure RMI protocol\uff1a dubbo:protocol name= rmi port= 1099 / configure provider level default protocol: dubbo:provider protocol= rmi / configure service level default protocol: dubbo:service protocol= rmi / configure multiple port\uff1a dubbo:protocol id= rmi1 name= rmi port= 1099 / dubbo:protocol id= rmi2 name= rmi port= 2099 / dubbo:service protocol= rmi1 / Compatible with Spring\uff1a dubbo:protocol name= rmi codec= spring /","title":"Configuration"},{"location":"user/references/protocol/thrift/","text":"thrift:// The current dubbo support thrift protocol is an extension of the thrift native protocol, adding some additional header information to the native protocol, such as service name, magic number, and so on. The use of dubbo thrift protocol also need to use thrift idl compiler to generate the corresponding java code, follow-up version will do some enhancement in this aspect. dependency dependency groupId org.apache.thrift /groupId artifactId libthrift /artifactId version 0.8.0 /version /dependency Configuration dubbo:protocol name= thrift port= 3030 / Example you can check dubbo thrift example Common problem Thrift does not support null values, that is, you can not pass null values","title":"thrift://"},{"location":"user/references/protocol/thrift/#thrift","text":"The current dubbo support thrift protocol is an extension of the thrift native protocol, adding some additional header information to the native protocol, such as service name, magic number, and so on. The use of dubbo thrift protocol also need to use thrift idl compiler to generate the corresponding java code, follow-up version will do some enhancement in this aspect.","title":"thrift://"},{"location":"user/references/protocol/thrift/#dependency","text":"dependency groupId org.apache.thrift /groupId artifactId libthrift /artifactId version 0.8.0 /version /dependency","title":"dependency"},{"location":"user/references/protocol/thrift/#configuration","text":"dubbo:protocol name= thrift port= 3030 /","title":"Configuration"},{"location":"user/references/protocol/thrift/#example","text":"you can check dubbo thrift example","title":"Example"},{"location":"user/references/protocol/thrift/#common-problem","text":"Thrift does not support null values, that is, you can not pass null values","title":"Common problem"},{"location":"user/references/protocol/webservice/","text":"webservice:// WebService-based remote calling protocol\uff0cbase on Apache CXF frontend-simple and transports-http implements\u3002 Interoperable with native WebService services\uff1a Providers expose services using Dubbo's WebService protocol, which consumers invoke directly using the standard WebService interface, Or the provider exposes the service using the standard WebService, which consumers invoke using the Dubbo WebService protocol. dependency dependency groupId org.apache.cxf /groupId artifactId cxf-rt-frontend-simple /artifactId version 2.6.1 /version /dependency dependency groupId org.apache.cxf /groupId artifactId cxf-rt-transports-http /artifactId version 2.6.1 /version /dependency Features Number of connections: multiple connections Connection: short connection Transmission protocol: HTTP Transmission: synchronous transmission Serialization: SOAP text serialization Applicable scenarios: System integration, cross-language calls Constraint Parameters and return class should implement Serializable interface Parameters should try to use the basic types and POJO Configuration configure webservice protocol\uff1a dubbo:protocol name= webservice port= 8080 server= jetty / configure provider level default protocol: dubbo:provider protocol= webservice / configure service level default protocol: dubbo:service protocol= webservice / configure multiple port\uff1a dubbo:protocol id= webservice1 name= webservice port= 8080 / dubbo:protocol id= webservice2 name= webservice port= 8081 / configure direct connect mode\uff1a dubbo:reference id= helloService interface= HelloWorld url= webservice://10.20.153.10:8080/com.foo.HelloWorld / WSDL\uff1a http://10.20.153.10:8080/com.foo.HelloWorld?wsdl Jetty Server (Default)\uff1a dubbo:protocol ... server= jetty / Servlet Bridge Server (recommend)\uff1a dubbo:protocol ... server= servlet / configure DispatcherServlet\uff1a servlet servlet-name dubbo /servlet-name servlet-class org.apache.dubbo.remoting.http.servlet.DispatcherServlet /servlet-class load-on-startup 1 /load-on-startup /servlet servlet-mapping servlet-name dubbo /servlet-name url-pattern /* /url-pattern /servlet-mapping Note that if you use servlets to dispatch requests: the port of protocol dubbo:protocol port=\"8080\" / must same as servlet container's. the context path of protocol dubbo:protocol contextpath=\"foo\" / must same as servlet application's.","title":"webservice://"},{"location":"user/references/protocol/webservice/#webservice","text":"WebService-based remote calling protocol\uff0cbase on Apache CXF frontend-simple and transports-http implements\u3002 Interoperable with native WebService services\uff1a Providers expose services using Dubbo's WebService protocol, which consumers invoke directly using the standard WebService interface, Or the provider exposes the service using the standard WebService, which consumers invoke using the Dubbo WebService protocol.","title":"webservice://"},{"location":"user/references/protocol/webservice/#dependency","text":"dependency groupId org.apache.cxf /groupId artifactId cxf-rt-frontend-simple /artifactId version 2.6.1 /version /dependency dependency groupId org.apache.cxf /groupId artifactId cxf-rt-transports-http /artifactId version 2.6.1 /version /dependency","title":"dependency"},{"location":"user/references/protocol/webservice/#features","text":"Number of connections: multiple connections Connection: short connection Transmission protocol: HTTP Transmission: synchronous transmission Serialization: SOAP text serialization Applicable scenarios: System integration, cross-language calls","title":"Features"},{"location":"user/references/protocol/webservice/#constraint","text":"Parameters and return class should implement Serializable interface Parameters should try to use the basic types and POJO","title":"Constraint"},{"location":"user/references/protocol/webservice/#configuration","text":"configure webservice protocol\uff1a dubbo:protocol name= webservice port= 8080 server= jetty / configure provider level default protocol: dubbo:provider protocol= webservice / configure service level default protocol: dubbo:service protocol= webservice / configure multiple port\uff1a dubbo:protocol id= webservice1 name= webservice port= 8080 / dubbo:protocol id= webservice2 name= webservice port= 8081 / configure direct connect mode\uff1a dubbo:reference id= helloService interface= HelloWorld url= webservice://10.20.153.10:8080/com.foo.HelloWorld / WSDL\uff1a http://10.20.153.10:8080/com.foo.HelloWorld?wsdl Jetty Server (Default)\uff1a dubbo:protocol ... server= jetty / Servlet Bridge Server (recommend)\uff1a dubbo:protocol ... server= servlet / configure DispatcherServlet\uff1a servlet servlet-name dubbo /servlet-name servlet-class org.apache.dubbo.remoting.http.servlet.DispatcherServlet /servlet-class load-on-startup 1 /load-on-startup /servlet servlet-mapping servlet-name dubbo /servlet-name url-pattern /* /url-pattern /servlet-mapping Note that if you use servlets to dispatch requests: the port of protocol dubbo:protocol port=\"8080\" / must same as servlet container's. the context path of protocol dubbo:protocol contextpath=\"foo\" / must same as servlet application's.","title":"Configuration"},{"location":"user/references/registry/introduction/","text":"Registry Server References It is recommended to use zookeeper registry server","title":"Introduction"},{"location":"user/references/registry/introduction/#registry-server-references","text":"It is recommended to use zookeeper registry server","title":"Registry Server References"},{"location":"user/references/registry/multicast/","text":"Multicast Registry Multicast registry doesn't require to setup any central node. Just like IP address broadcast, dubbo service providers and consumers can discover each other through this mechanism. Service provider broadcasts its address when it boots up. Service consumer broadcasts its subscription request when it boots up. Once service provider receives subscription request, it unicasts its own address to the corresponding consumer, if unicast=false is set, then broadcast will be used instead. When service consumer receives provider's address, it can start RPC invocation on the received address. Multicast is limited to network topology, and is only suitable for development purpose or small deployment. The valid multcast addresses scope is: 224.0.0.0 - 239.255.255.255. Configuration dubbo:registry address= multicast://224.5.6.7:1234 / Or dubbo:registry protocol= multicast address= 224.5.6.7:1234 / In order to avoid multicast as much as possible, dubbo uses unicast for address information from service provider to service consumer, if there are multiple consumer processes on one single machine, consumers need to set unicast=false , otherwise only one consumer can be able to receive the address info: dubbo:registry address= multicast://224.5.6.7:1234?unicast=false / Or dubbo:registry protocol= multicast address= 224.5.6.7:1234 dubbo:parameter key= unicast value= false / /dubbo:registry","title":"Multicast"},{"location":"user/references/registry/multicast/#multicast-registry","text":"Multicast registry doesn't require to setup any central node. Just like IP address broadcast, dubbo service providers and consumers can discover each other through this mechanism. Service provider broadcasts its address when it boots up. Service consumer broadcasts its subscription request when it boots up. Once service provider receives subscription request, it unicasts its own address to the corresponding consumer, if unicast=false is set, then broadcast will be used instead. When service consumer receives provider's address, it can start RPC invocation on the received address. Multicast is limited to network topology, and is only suitable for development purpose or small deployment. The valid multcast addresses scope is: 224.0.0.0 - 239.255.255.255.","title":"Multicast Registry"},{"location":"user/references/registry/multicast/#configuration","text":"dubbo:registry address= multicast://224.5.6.7:1234 / Or dubbo:registry protocol= multicast address= 224.5.6.7:1234 / In order to avoid multicast as much as possible, dubbo uses unicast for address information from service provider to service consumer, if there are multiple consumer processes on one single machine, consumers need to set unicast=false , otherwise only one consumer can be able to receive the address info: dubbo:registry address= multicast://224.5.6.7:1234?unicast=false / Or dubbo:registry protocol= multicast address= 224.5.6.7:1234 dubbo:parameter key= unicast value= false / /dubbo:registry","title":"Configuration"},{"location":"user/references/registry/nacos/","text":"Nacos Registry Center Nacos is a very important registry center for Dubbo ecosystem, dubbo-registry-nacos is the implementation of Nacos integration to Nacos. Prepare Work When you integrate dubbo-registry-nacos into your Dubbo project, please Make sure the Nacos service is started in the background. If you are not familiar with the basic use of Nacos, you can refer to Nacos Quick Start . It is recommended to use the version equal or above Nacos 1.0.0 . Quick Start The steps for Dubbo to integrate Nacos as a registry center are very simple. The general steps can be divided into \"add Maven dependencies\" and \"configure registry center\". Add Maven Dependencies First, you need to add the dubbo-registry-nacos Maven dependency to your project's pom.xml file, and we strongly recommend that you use Dubbo 2.6.5 : dependencies ... !-- Dubbo Nacos registry dependency -- dependency groupId com.alibaba /groupId artifactId dubbo-registry-nacos /artifactId version 0.0.2 /version /dependency !-- Keep latest Nacos client version -- dependency groupId com.alibaba.nacos /groupId artifactId nacos-client /artifactId version [0.6.1,) /version /dependency !-- Dubbo dependency -- dependency groupId com.alibaba /groupId artifactId dubbo /artifactId version 2.6.5 /version /dependency !-- Alibaba Spring Context extension -- dependency groupId com.alibaba.spring /groupId artifactId spring-context-support /artifactId version 1.0.2 /version /dependency ... /dependencies When you add dubbo-registry-nacos to your project, you don't need to explicitly program the service discovery and registration logic. The actual implementation is provided by the three-party package. Configure Registry Center Assuming your Dubbo app uses the Spring Framework assembly, there are two configuration options available: Dubbo Spring Externalization Configuration and the Spring XML configuration file. Dubbo Spring Externalization Configuration The Dubbo Spring externalization configuration is a new feature introduced by Dubbo 2.5.8 that automatically generates and binds Dubbo configuration beans through the Spring Environment property, simplifying configuration and lowering the microservice development threshold. Assuming your Nacos Server is also running on server 10.20.153.10 and using the default Nacos service port 8848 , you only need to adjust the dubbo.registry.address property as follows: ## Other properties remain unchanged ## Nacos registry address dubbo.registry.address = nacos://10.20.153.10:8848 ... Then, restart your Dubbo app, Dubbo's service provider and consumer information can be displayed on the Nacos console: As shown in the figure, the information whose service name prefix is providers: is the meta information of the service provider, and the consumers: represents the meta information of the service consumer. Click on \" Details \" to view service status details: If you are using the Spring XML configuration file to assemble the Dubbo registry, please refer to the next section. Spring XML Configuration File Similar to Dubbo Spring Externalization Configuration , just adjust the address attribute to configure: ?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd !-- Provider application information for calculating dependencies -- dubbo:application name= dubbo-provider-xml-demo / !-- Use Nacos as Registry Center -- dubbo:registry address= nacos://10.20.153.10:8848 / ... /beans After restarting the Dubbo app, you can also find that the registration meta-information of the service provider and consumer is presented on the Nacos console:","title":"Nacos Registry Center"},{"location":"user/references/registry/nacos/#nacos-registry-center","text":"Nacos is a very important registry center for Dubbo ecosystem, dubbo-registry-nacos is the implementation of Nacos integration to Nacos.","title":"Nacos Registry Center"},{"location":"user/references/registry/nacos/#prepare-work","text":"When you integrate dubbo-registry-nacos into your Dubbo project, please Make sure the Nacos service is started in the background. If you are not familiar with the basic use of Nacos, you can refer to Nacos Quick Start . It is recommended to use the version equal or above Nacos 1.0.0 .","title":"Prepare Work"},{"location":"user/references/registry/nacos/#quick-start","text":"The steps for Dubbo to integrate Nacos as a registry center are very simple. The general steps can be divided into \"add Maven dependencies\" and \"configure registry center\".","title":"Quick Start"},{"location":"user/references/registry/nacos/#add-maven-dependencies","text":"First, you need to add the dubbo-registry-nacos Maven dependency to your project's pom.xml file, and we strongly recommend that you use Dubbo 2.6.5 : dependencies ... !-- Dubbo Nacos registry dependency -- dependency groupId com.alibaba /groupId artifactId dubbo-registry-nacos /artifactId version 0.0.2 /version /dependency !-- Keep latest Nacos client version -- dependency groupId com.alibaba.nacos /groupId artifactId nacos-client /artifactId version [0.6.1,) /version /dependency !-- Dubbo dependency -- dependency groupId com.alibaba /groupId artifactId dubbo /artifactId version 2.6.5 /version /dependency !-- Alibaba Spring Context extension -- dependency groupId com.alibaba.spring /groupId artifactId spring-context-support /artifactId version 1.0.2 /version /dependency ... /dependencies When you add dubbo-registry-nacos to your project, you don't need to explicitly program the service discovery and registration logic. The actual implementation is provided by the three-party package.","title":"Add Maven Dependencies"},{"location":"user/references/registry/nacos/#configure-registry-center","text":"Assuming your Dubbo app uses the Spring Framework assembly, there are two configuration options available: Dubbo Spring Externalization Configuration and the Spring XML configuration file.","title":"Configure Registry Center"},{"location":"user/references/registry/nacos/#dubbo-spring-externalization-configuration","text":"The Dubbo Spring externalization configuration is a new feature introduced by Dubbo 2.5.8 that automatically generates and binds Dubbo configuration beans through the Spring Environment property, simplifying configuration and lowering the microservice development threshold. Assuming your Nacos Server is also running on server 10.20.153.10 and using the default Nacos service port 8848 , you only need to adjust the dubbo.registry.address property as follows: ## Other properties remain unchanged ## Nacos registry address dubbo.registry.address = nacos://10.20.153.10:8848 ... Then, restart your Dubbo app, Dubbo's service provider and consumer information can be displayed on the Nacos console: As shown in the figure, the information whose service name prefix is providers: is the meta information of the service provider, and the consumers: represents the meta information of the service consumer. Click on \" Details \" to view service status details: If you are using the Spring XML configuration file to assemble the Dubbo registry, please refer to the next section.","title":"Dubbo Spring Externalization Configuration"},{"location":"user/references/registry/nacos/#spring-xml-configuration-file","text":"Similar to Dubbo Spring Externalization Configuration , just adjust the address attribute to configure: ?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd !-- Provider application information for calculating dependencies -- dubbo:application name= dubbo-provider-xml-demo / !-- Use Nacos as Registry Center -- dubbo:registry address= nacos://10.20.153.10:8848 / ... /beans After restarting the Dubbo app, you can also find that the registration meta-information of the service provider and consumer is presented on the Nacos console:","title":"Spring XML Configuration File"},{"location":"user/references/registry/redis/","text":"Redis Registry Server It is a registry server implementation [^2] based on redis [^1]. Use key/map structure in redis to save the registration info: Main key for service name and type Key in the map is URL address Value in the map is the expiration time. Monitor center uses it to track and remove dirty data [^3] Publish/Subscribe events in redis is leveraged for data change notification: Distinguish event type with event's value: register , unregister , subscribe , unsubscribe . Regular subscriber subscribes the particular key presenting service provider, then will receive register and unregister events fired from the specified service. Monitor center subscribes /dubbo/* via psubscribe , then will receive all change notifications from all services. Procedure: When service provider boots up, it adds its address under Key:/dubbo/com.foo.BarService/providers . Then service provider sends register event to Channel:/dubbo/com.foo.BarService/providers When service consumer boots up, it subscribe events register and unregister from Channel:/dubbo/com.foo.BarService/providers Then service consumer add its address under Key:/dubbo/com.foo.BarService/consumers When service consumer receives events register and unregister , it will fetch provider's addresses from Key:/dubbo/com.foo.BarService/providers When monitor center boots up, it subscribes events register , unregister , subscribe , and unsubsribe . After monitor center receives register and unregister , it fetches provider's addresses from Key:/dubbo/com.foo.BarService/providers After monitor center receives subscribe and unsubscribe , it fetches consumer's addresses from Key:/dubbo/com.foo.BarService/consumers Configuration dubbo:registry address= redis://10.20.153.10:6379 / Or dubbo:registry address= redis://10.20.153.10:6379?backup=10.20.153.11:6379,10.20.153.12:6379 / Or dubbo:registry protocol= redis address= 10.20.153.10:6379 / Or dubbo:registry protocol= redis address= 10.20.153.10:6379,10.20.153.11:6379,10.20.153.12:6379 / Options Config key's prefix in redis via dubbo:registry group=\"dubbo\" / , the default value is dubbo . Config redis cluster strategy via dubbo:registry cluster=\"replicate\" / , the default value is failover : failover : when read/write error happens, try another instance, require the cluster to support data replication. replicate : client writes to all nodes of the cluster, but only peeks a random node for read. The cluster doesn't need to take care of data replication, but may require more nodes and higher performance for each node, compared to option 1. Declaration of Reliability A home-brewed service registry server is used in Alibaba instead of redis server. Redis based registry center does not have long-run practice within Alibaba, therefore we cannot guarantee its reliability. This registry server implementation is provided for dubbo community, and its reliability relies on redis itself largely. Installation Pls. refer to redis install manual for how to install a redis based registry server. To set it up, specify dubbo.registry.address to redis://127.0.0.1:6379 in conf/dubbo.properties for both provider and consumer (you can refer to quick start ) after install a redis server. [^1]: Redis is a high performance KV cache server [^2]: Support since 2.1.0 [^3]: Heartbeat mechanism is used to detect the dirty data in redis. It requires time among servers must be sync in advanced, otherwise expiration check may inaccurate, plus, heartbeats may add extra pressure on servers.","title":"Redis"},{"location":"user/references/registry/redis/#redis-registry-server","text":"It is a registry server implementation [^2] based on redis [^1]. Use key/map structure in redis to save the registration info: Main key for service name and type Key in the map is URL address Value in the map is the expiration time. Monitor center uses it to track and remove dirty data [^3] Publish/Subscribe events in redis is leveraged for data change notification: Distinguish event type with event's value: register , unregister , subscribe , unsubscribe . Regular subscriber subscribes the particular key presenting service provider, then will receive register and unregister events fired from the specified service. Monitor center subscribes /dubbo/* via psubscribe , then will receive all change notifications from all services. Procedure: When service provider boots up, it adds its address under Key:/dubbo/com.foo.BarService/providers . Then service provider sends register event to Channel:/dubbo/com.foo.BarService/providers When service consumer boots up, it subscribe events register and unregister from Channel:/dubbo/com.foo.BarService/providers Then service consumer add its address under Key:/dubbo/com.foo.BarService/consumers When service consumer receives events register and unregister , it will fetch provider's addresses from Key:/dubbo/com.foo.BarService/providers When monitor center boots up, it subscribes events register , unregister , subscribe , and unsubsribe . After monitor center receives register and unregister , it fetches provider's addresses from Key:/dubbo/com.foo.BarService/providers After monitor center receives subscribe and unsubscribe , it fetches consumer's addresses from Key:/dubbo/com.foo.BarService/consumers","title":"Redis Registry Server"},{"location":"user/references/registry/redis/#configuration","text":"dubbo:registry address= redis://10.20.153.10:6379 / Or dubbo:registry address= redis://10.20.153.10:6379?backup=10.20.153.11:6379,10.20.153.12:6379 / Or dubbo:registry protocol= redis address= 10.20.153.10:6379 / Or dubbo:registry protocol= redis address= 10.20.153.10:6379,10.20.153.11:6379,10.20.153.12:6379 /","title":"Configuration"},{"location":"user/references/registry/redis/#options","text":"Config key's prefix in redis via dubbo:registry group=\"dubbo\" / , the default value is dubbo . Config redis cluster strategy via dubbo:registry cluster=\"replicate\" / , the default value is failover : failover : when read/write error happens, try another instance, require the cluster to support data replication. replicate : client writes to all nodes of the cluster, but only peeks a random node for read. The cluster doesn't need to take care of data replication, but may require more nodes and higher performance for each node, compared to option 1.","title":"Options"},{"location":"user/references/registry/redis/#declaration-of-reliability","text":"A home-brewed service registry server is used in Alibaba instead of redis server. Redis based registry center does not have long-run practice within Alibaba, therefore we cannot guarantee its reliability. This registry server implementation is provided for dubbo community, and its reliability relies on redis itself largely.","title":"Declaration of Reliability"},{"location":"user/references/registry/redis/#installation","text":"Pls. refer to redis install manual for how to install a redis based registry server. To set it up, specify dubbo.registry.address to redis://127.0.0.1:6379 in conf/dubbo.properties for both provider and consumer (you can refer to quick start ) after install a redis server. [^1]: Redis is a high performance KV cache server [^2]: Support since 2.1.0 [^3]: Heartbeat mechanism is used to detect the dirty data in redis. It requires time among servers must be sync in advanced, otherwise expiration check may inaccurate, plus, heartbeats may add extra pressure on servers.","title":"Installation"},{"location":"user/references/registry/simple/","text":"Simple Registry Server Simple registry server itself is a regular dubbo service. In this way, third-party dependency is unnecessary, and communication keeps consistent at the same moment. Configuration Register simple registry server as dubbo service: ?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd !-- application info configuration -- dubbo:application name= simple-registry / !-- service protocol configuration -- dubbo:protocol port= 9090 / !-- service configuration -- dubbo:service interface= org.apache.dubbo.registry.RegistryService ref= registryService registry= N/A ondisconnect= disconnect callbacks= 1000 dubbo:method name= subscribe dubbo:argument index= 1 callback= true / /dubbo:method dubbo:method name= unsubscribe dubbo:argument index= 1 callback= false / /dubbo:method /dubbo:service !-- simple registry server implementation, register other implementation if cluster ability is a requirement-- bean id= registryService class= org.apache.dubbo.registry.simple.SimpleRegistryService / /beans Reference simple registry server service: dubbo:registry address= 127.0.0.1:9090 / Or: dubbo:service interface= org.apache.dubbo.registry.RegistryService group= simple version= 1.0.0 ... Or: dubbo:registry address= 127.0.0.1:9090 group= simple version= 1.0.0 / Applicability This SimpleRegistryService is just a simple implementation for register server, and it doesn't have cluster support. It is useful for the implementation reference for the custom registry server, but not suitable for use in production environment directly.","title":"Simple"},{"location":"user/references/registry/simple/#simple-registry-server","text":"Simple registry server itself is a regular dubbo service. In this way, third-party dependency is unnecessary, and communication keeps consistent at the same moment.","title":"Simple Registry Server"},{"location":"user/references/registry/simple/#configuration","text":"Register simple registry server as dubbo service: ?xml version= 1.0 encoding= UTF-8 ? beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:dubbo= http://dubbo.apache.org/schema/dubbo xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd !-- application info configuration -- dubbo:application name= simple-registry / !-- service protocol configuration -- dubbo:protocol port= 9090 / !-- service configuration -- dubbo:service interface= org.apache.dubbo.registry.RegistryService ref= registryService registry= N/A ondisconnect= disconnect callbacks= 1000 dubbo:method name= subscribe dubbo:argument index= 1 callback= true / /dubbo:method dubbo:method name= unsubscribe dubbo:argument index= 1 callback= false / /dubbo:method /dubbo:service !-- simple registry server implementation, register other implementation if cluster ability is a requirement-- bean id= registryService class= org.apache.dubbo.registry.simple.SimpleRegistryService / /beans Reference simple registry server service: dubbo:registry address= 127.0.0.1:9090 / Or: dubbo:service interface= org.apache.dubbo.registry.RegistryService group= simple version= 1.0.0 ... Or: dubbo:registry address= 127.0.0.1:9090 group= simple version= 1.0.0 /","title":"Configuration"},{"location":"user/references/registry/simple/#applicability","text":"This SimpleRegistryService is just a simple implementation for register server, and it doesn't have cluster support. It is useful for the implementation reference for the custom registry server, but not suitable for use in production environment directly.","title":"Applicability"},{"location":"user/references/registry/zookeeper/","text":"Zookeeper Registry Server Zookeeper is the child project of apache hadoop. Since it offers tree-like directory service and supports change notification, it's suitable to use it as dubbo's registry server. It's a field-proven product, therefore it's recommended to use it in the production environment. [^1] Description on registration procedure: When service provider boots up: write service URL address under directory /dubbo/com.foo.BarService/providers When service consumer boots up: subscribe to /dubbo/com.foo.BarService/providers for provider's URL addresses. At the same time, write consumer's URL address under /dubbo/com.foo.BarService/consumers . When monitor center boots up: subscribe to /dubbo/com.foo.BarService for the URL addresses from all providers and consumers. The following abilities are supported: * When provider stops by accident, registry server can remove its info automatically. * When registry server reboots, all registration data and subscription requests can be recovered automatically. * When session is expired, all registration data and subscription requests can be recovered automatically. * When dubbo:registry check=\"false\" / is configured, failed requests for subscription and registration will be recorded and kept retrying in the background. * Configure dubbo:registry username=\"admin\" password=\"1234\" / for zookeeper login. * Configure dubbo:registry group=\"dubbo\" / for dubbo's root node on zookeeper. Default root node will be used if it's not specified. * Support to use wildcard * in dubbo:reference group=\"*\" version=\"*\" / in order to subscribe all groups and all versions for the services to be referenced. How to Use Add zookeeper client dependency in both provider and consumer: dependency groupId org.apache.zookeeper /groupId artifactId zookeeper /artifactId version 3.3.3 /version /dependency Or download directly from apache. Dubbo supports two zookeeper clients: zkclient and curator: Use zkclient Since 2.2.0 dubbo uses zkclient by default, in order to improve the robustness. zkclient is a zookeeper client implementation open-sourced by Datameer. Note: The implementation of zkclient has been removed in the 2.7.x version. If you want to use the zkclient client, you need to extend it yourself. Default configuration: dubbo:registry ... client= zkclient / Or: dubbo.registry.client=zkclient Or: zookeeper://10.20.153.10:2181?client=zkclient In order to use it, need to explicitly declare the following maven dependency or download its client . dependency groupId com.github.sgroschupf /groupId artifactId zkclient /artifactId version 0.1 /version /dependency Use curator Since 2.3.0 dubbo also supports curator but explicit configuration is required. Curator is the zookeeper client open-sourced by Netflix. In order to switch to curator, use the configuration below: dubbo:registry ... client= curator / Or: dubbo.registry.client=curator Or: zookeeper://10.20.153.10:2181?client=curator Also need to explicitly add maven dependency or directly download the jar: dependency groupId com.netflix.curator /groupId artifactId curator-framework /artifactId version 1.1.10 /version /dependency Zookeeper single node configuration: dubbo:registry address= zookeeper://10.20.153.10:2181 / Or: dubbo:registry protocol= zookeeper address= 10.20.153.10:2181 / Zookeeper cluster configuration\uff1a dubbo:registry address= zookeeper://10.20.153.10:2181?backup=10.20.153.11:2181,10.20.153.12:2181 / Or: dubbo:registry protocol= zookeeper address= 10.20.153.10:2181,10.20.153.11:2181,10.20.153.12:2181 / Configure single zookeeper to serve as multiple registry servers: dubbo:registry id= chinaRegistry protocol= zookeeper address= 10.20.153.10:2181 group= china / dubbo:registry id= intlRegistry protocol= zookeeper address= 10.20.153.10:2181 group= intl / Zookeeper Installation Pls. refer to zookeeper install manual for how to install zookeeper based registry server. To set it up, specify dubbo.registry.address to zookeeper://127.0.0.1:2181 in conf/dubbo.properties for both provider and consumer (you can refer to quick start ) after install a zookeeper server. Declaration of Reliability A home-brewed service registry server is used in Alibaba instead of zookeeper server. Zookeeper based registry center does not have long-run practice within Alibaba, therefore we cannot guarantee its reliability. Zookeeper registry server is provided for dubbo community, and its reliability relies on zookeeper itself largely. Declaration of Compatibility The original designed data structure for zookeeper in 2.0.8 has the limitation that data type cannot extended, it's redesigned in 2.0.9 . But at the same time incompatibility is introduced, thereby 2.0.9 is required for all service providers and service consumers. Since 2.2.0 zkclient is used by default, therefore its dependency is needed. Since 2.3.0 curator is supported as alternative option. [^1]: Suggest to use 2.3.3 or above for zookeeper registry client","title":"Zookeeper"},{"location":"user/references/registry/zookeeper/#zookeeper-registry-server","text":"Zookeeper is the child project of apache hadoop. Since it offers tree-like directory service and supports change notification, it's suitable to use it as dubbo's registry server. It's a field-proven product, therefore it's recommended to use it in the production environment. [^1] Description on registration procedure: When service provider boots up: write service URL address under directory /dubbo/com.foo.BarService/providers When service consumer boots up: subscribe to /dubbo/com.foo.BarService/providers for provider's URL addresses. At the same time, write consumer's URL address under /dubbo/com.foo.BarService/consumers . When monitor center boots up: subscribe to /dubbo/com.foo.BarService for the URL addresses from all providers and consumers. The following abilities are supported: * When provider stops by accident, registry server can remove its info automatically. * When registry server reboots, all registration data and subscription requests can be recovered automatically. * When session is expired, all registration data and subscription requests can be recovered automatically. * When dubbo:registry check=\"false\" / is configured, failed requests for subscription and registration will be recorded and kept retrying in the background. * Configure dubbo:registry username=\"admin\" password=\"1234\" / for zookeeper login. * Configure dubbo:registry group=\"dubbo\" / for dubbo's root node on zookeeper. Default root node will be used if it's not specified. * Support to use wildcard * in dubbo:reference group=\"*\" version=\"*\" / in order to subscribe all groups and all versions for the services to be referenced.","title":"Zookeeper Registry Server"},{"location":"user/references/registry/zookeeper/#how-to-use","text":"Add zookeeper client dependency in both provider and consumer: dependency groupId org.apache.zookeeper /groupId artifactId zookeeper /artifactId version 3.3.3 /version /dependency Or download directly from apache. Dubbo supports two zookeeper clients: zkclient and curator:","title":"How to Use"},{"location":"user/references/registry/zookeeper/#use-zkclient","text":"Since 2.2.0 dubbo uses zkclient by default, in order to improve the robustness. zkclient is a zookeeper client implementation open-sourced by Datameer. Note: The implementation of zkclient has been removed in the 2.7.x version. If you want to use the zkclient client, you need to extend it yourself. Default configuration: dubbo:registry ... client= zkclient / Or: dubbo.registry.client=zkclient Or: zookeeper://10.20.153.10:2181?client=zkclient In order to use it, need to explicitly declare the following maven dependency or download its client . dependency groupId com.github.sgroschupf /groupId artifactId zkclient /artifactId version 0.1 /version /dependency","title":"Use zkclient"},{"location":"user/references/registry/zookeeper/#use-curator","text":"Since 2.3.0 dubbo also supports curator but explicit configuration is required. Curator is the zookeeper client open-sourced by Netflix. In order to switch to curator, use the configuration below: dubbo:registry ... client= curator / Or: dubbo.registry.client=curator Or: zookeeper://10.20.153.10:2181?client=curator Also need to explicitly add maven dependency or directly download the jar: dependency groupId com.netflix.curator /groupId artifactId curator-framework /artifactId version 1.1.10 /version /dependency Zookeeper single node configuration: dubbo:registry address= zookeeper://10.20.153.10:2181 / Or: dubbo:registry protocol= zookeeper address= 10.20.153.10:2181 / Zookeeper cluster configuration\uff1a dubbo:registry address= zookeeper://10.20.153.10:2181?backup=10.20.153.11:2181,10.20.153.12:2181 / Or: dubbo:registry protocol= zookeeper address= 10.20.153.10:2181,10.20.153.11:2181,10.20.153.12:2181 / Configure single zookeeper to serve as multiple registry servers: dubbo:registry id= chinaRegistry protocol= zookeeper address= 10.20.153.10:2181 group= china / dubbo:registry id= intlRegistry protocol= zookeeper address= 10.20.153.10:2181 group= intl /","title":"Use curator"},{"location":"user/references/registry/zookeeper/#zookeeper-installation","text":"Pls. refer to zookeeper install manual for how to install zookeeper based registry server. To set it up, specify dubbo.registry.address to zookeeper://127.0.0.1:2181 in conf/dubbo.properties for both provider and consumer (you can refer to quick start ) after install a zookeeper server.","title":"Zookeeper Installation"},{"location":"user/references/registry/zookeeper/#declaration-of-reliability","text":"A home-brewed service registry server is used in Alibaba instead of zookeeper server. Zookeeper based registry center does not have long-run practice within Alibaba, therefore we cannot guarantee its reliability. Zookeeper registry server is provided for dubbo community, and its reliability relies on zookeeper itself largely.","title":"Declaration of Reliability"},{"location":"user/references/registry/zookeeper/#declaration-of-compatibility","text":"The original designed data structure for zookeeper in 2.0.8 has the limitation that data type cannot extended, it's redesigned in 2.0.9 . But at the same time incompatibility is introduced, thereby 2.0.9 is required for all service providers and service consumers. Since 2.2.0 zkclient is used by default, therefore its dependency is needed. Since 2.3.0 curator is supported as alternative option. [^1]: Suggest to use 2.3.3 or above for zookeeper registry client","title":"Declaration of Compatibility"},{"location":"user/references/xml/dubbo-application/","text":"dubbo:application Application configuration. The corresponding class: org.apache.dubbo.config.ApplicationConfig Property Corresponding URL parameter Type Requisite Default Effect Description Compatibility name application string Y service governance Application name is the unique identifier of an application. It is for registry combing the dependencies of applications. Note: Consumer and provider application name should not be the same, and this parameter is not a match condition. As a suggestion, you can name it as your project name. For example, kylin application invokes the service of morgan application, then you can name kylin application as \"kylin\", and morgan application as \"morgan\". Maybe kylin also works as a provider, but kylin should still called \"kylin\". In this way, registry can understand the dependence of applications above 1.0.16 version application.version string N service governance The version of current application above 2.2.0 owner owner string N service governance Application manager. Pls. fill in the mailbox prefix of the person in charge above 2.0.5 organization organization string N service governance Organization name is for registry distinguishing between the source of service. As a suggestion, this property should be written in config file directly. Such as china,intl,itu,crm,asc,dw,aliexpress etc. above 2.0.0 architecture architecture string N service governance The architecture of service layering. Like intl,china and so on. Different architecture use different layer above 2.0.7 environment environment string N service governance Application environment. Like develop,test,product. Work as the limit condition of developing new function above 2.0.0 compiler compiler string N javassist performance optimization Java class compile.It is used for the generating of dynamic class. The options are JDK and javassist above 2.1.0 logger logger string N slf4j performance optimization The format of log output\uff0cThe options are slf4j,jcl,log4j,log4j2 and jdk above 2.2.0","title":"dubbo:application"},{"location":"user/references/xml/dubbo-application/#dubboapplication","text":"Application configuration. The corresponding class: org.apache.dubbo.config.ApplicationConfig Property Corresponding URL parameter Type Requisite Default Effect Description Compatibility name application string Y service governance Application name is the unique identifier of an application. It is for registry combing the dependencies of applications. Note: Consumer and provider application name should not be the same, and this parameter is not a match condition. As a suggestion, you can name it as your project name. For example, kylin application invokes the service of morgan application, then you can name kylin application as \"kylin\", and morgan application as \"morgan\". Maybe kylin also works as a provider, but kylin should still called \"kylin\". In this way, registry can understand the dependence of applications above 1.0.16 version application.version string N service governance The version of current application above 2.2.0 owner owner string N service governance Application manager. Pls. fill in the mailbox prefix of the person in charge above 2.0.5 organization organization string N service governance Organization name is for registry distinguishing between the source of service. As a suggestion, this property should be written in config file directly. Such as china,intl,itu,crm,asc,dw,aliexpress etc. above 2.0.0 architecture architecture string N service governance The architecture of service layering. Like intl,china and so on. Different architecture use different layer above 2.0.7 environment environment string N service governance Application environment. Like develop,test,product. Work as the limit condition of developing new function above 2.0.0 compiler compiler string N javassist performance optimization Java class compile.It is used for the generating of dynamic class. The options are JDK and javassist above 2.1.0 logger logger string N slf4j performance optimization The format of log output\uff0cThe options are slf4j,jcl,log4j,log4j2 and jdk above 2.2.0","title":"dubbo:application"},{"location":"user/references/xml/dubbo-argument/","text":"dubbo:argument Method argument configuration. The corresponding class\uff1a org.apache.dubbo.config.ArgumentConfig . This tag is child of dubbo:method , which is for feature description of method argument, such as: dubbo:method name= findXxx timeout= 3000 retries= 2 dubbo:argument index= 0 callback= true / /dubbo:method Property Corresponding URL parameter Type Requisite Default Effect Description Compatibility index int Y identification method name above 2.0.6 type String Index and type choose one identification Find index of argument by it above 2.0.6 callback metodName index .retries boolean N service governance Mark whether this argument is a callback service. If true, provider will generate reverse proxy,which can invoke consumer in turn. Generally for event pushing above 2.0.6","title":"dubbo:argument"},{"location":"user/references/xml/dubbo-argument/#dubboargument","text":"Method argument configuration. The corresponding class\uff1a org.apache.dubbo.config.ArgumentConfig . This tag is child of dubbo:method , which is for feature description of method argument, such as: dubbo:method name= findXxx timeout= 3000 retries= 2 dubbo:argument index= 0 callback= true / /dubbo:method Property Corresponding URL parameter Type Requisite Default Effect Description Compatibility index int Y identification method name above 2.0.6 type String Index and type choose one identification Find index of argument by it above 2.0.6 callback metodName index .retries boolean N service governance Mark whether this argument is a callback service. If true, provider will generate reverse proxy,which can invoke consumer in turn. Generally for event pushing above 2.0.6","title":"dubbo:argument"},{"location":"user/references/xml/dubbo-config-center/","text":"dubbo:config-center Configuration center. Corresponding configuration class: org.apache.dubbo.config.ConfigCenterConfig property Corresponding URL parameter type required default value description compatibility protocol config.protocol string optional zookeeper Which configuration center to use: apollo, zookeeper, nacos, etc. take zookeeper for example 1. If protocol is specified, address can be simplified to 127.0.0.1:2181 ; 2. If protocol is not specified, address is set to zookeeper://127.0.0.1:2181 2.7.0+ address config.address string required Configuration center address. See protocol description for values 2.7.0+ highest-priority config.highestPriority boolean optional true Configuration items from the configuration center have the highest priority, it means that the local configuration items will be overwritten. 2.7.0+ namespace config.namespace string optional dubbo Using for multi-tenant isolation generally, the actual meaning varies depending on the configuration center. For example: zookeeper - Environment isolation, default dubbo \uff1b apollo - Distinguish between sets of configurations for different domains and use them by default dubbo and application 2.7.0+ cluster config.cluster string optional The meaning varies according to the configuration center selected. For example, it's used to distinguish between different configuration clusters in apollo 2.7.0+ group config.group string optional dubbo The meaning varies according to the configuration center selected. nacos - Isolate different configuration sets zookeeper - Isolate different configuration sets 2.7.0+ check config.check boolean optional true Whether to terminate application startup when the configuration hub connection fails. 2.7.0+ config-file config.configFile string optional dubbo.properties The key mapped to the global level profile zookeeper - $DEFAULT_PATH/dubbo/config/dubbo/dubbo.properties apollo - The dubbo.properties key in dubbo namespace 2.7.0+ timeout config.timeout integer 3000ms Gets the configured timeout 2.7.0+ username string the username if the configuration center requires validation Apollo is not yet enabled 2.7.0+ password string password if configuration center needs to do check Apollo is not yet enabled 2.7.0+ parameters Map Extended parameters to support customized configuration parameters for different configuration centers 2.7.0+ include-spring-env boolean optional false With the Spring framework support, when the value is true , it will automatically reads the configuration from the Spring Environment Read by default Configuration with key dubbo.properties PropertySource with key dubbo.properties 2.7.0+","title":"dubbo:config-center"},{"location":"user/references/xml/dubbo-config-center/#dubboconfig-center","text":"Configuration center. Corresponding configuration class: org.apache.dubbo.config.ConfigCenterConfig property Corresponding URL parameter type required default value description compatibility protocol config.protocol string optional zookeeper Which configuration center to use: apollo, zookeeper, nacos, etc. take zookeeper for example 1. If protocol is specified, address can be simplified to 127.0.0.1:2181 ; 2. If protocol is not specified, address is set to zookeeper://127.0.0.1:2181 2.7.0+ address config.address string required Configuration center address. See protocol description for values 2.7.0+ highest-priority config.highestPriority boolean optional true Configuration items from the configuration center have the highest priority, it means that the local configuration items will be overwritten. 2.7.0+ namespace config.namespace string optional dubbo Using for multi-tenant isolation generally, the actual meaning varies depending on the configuration center. For example: zookeeper - Environment isolation, default dubbo \uff1b apollo - Distinguish between sets of configurations for different domains and use them by default dubbo and application 2.7.0+ cluster config.cluster string optional The meaning varies according to the configuration center selected. For example, it's used to distinguish between different configuration clusters in apollo 2.7.0+ group config.group string optional dubbo The meaning varies according to the configuration center selected. nacos - Isolate different configuration sets zookeeper - Isolate different configuration sets 2.7.0+ check config.check boolean optional true Whether to terminate application startup when the configuration hub connection fails. 2.7.0+ config-file config.configFile string optional dubbo.properties The key mapped to the global level profile zookeeper - $DEFAULT_PATH/dubbo/config/dubbo/dubbo.properties apollo - The dubbo.properties key in dubbo namespace 2.7.0+ timeout config.timeout integer 3000ms Gets the configured timeout 2.7.0+ username string the username if the configuration center requires validation Apollo is not yet enabled 2.7.0+ password string password if configuration center needs to do check Apollo is not yet enabled 2.7.0+ parameters Map Extended parameters to support customized configuration parameters for different configuration centers 2.7.0+ include-spring-env boolean optional false With the Spring framework support, when the value is true , it will automatically reads the configuration from the Spring Environment Read by default Configuration with key dubbo.properties PropertySource with key dubbo.properties 2.7.0+","title":"dubbo:config-center"},{"location":"user/references/xml/dubbo-consumer/","text":"dubbo:consumer Consumer default configuration. The corresponding clas\uff1a org.apache.dubbo.config.ConsumerConfig . It is also default configuration of dubbo:reference . Property Corresponding URL parameter Type Requisite Default Effect Description Compatibility timeout default.timeout int N 1000 performance optimization invoking timeout(ms) above 1.0.16 retries default.retries int N 2 performance optimization Invoking retry times, exclude the first invoking. Set 0 to disable it.Only valid if the cluster's value is failback/failover above 1.0.16 loadbalance default.loadbalance string N random performance optimization Load balancing strategy. Choices\uff1arandom, roundrobin(polling), leastactive(invoking least active service) above 1.0.16 async default.async boolean N false performance optimization Whether invoke asynchronously above 2.0.0 connections default.connections int N 100 performance optimization The maximum number of connections of per service provider. Only short link protocol such as rmi,http,hessian etc. supports. Long link protocol such as dubbo doesn't support above 1.0.16 generic generic boolean N false service governance Whether default generic interface. A instance of GenericService will be got if true. above 2.0.0 check check boolean N true service governance Whether check the survival of provider. If true, throw exception when no provider of some services is alive. Otherwise, just ignore it above 1.0.16 proxy proxy string N javassist performance optimization Java class compile.It is used for the generating of dynamic class. The options are JDK and javassist above 2.0.5 owner owner string N service governance Application manager. Pls. fill in the mailbox prefix of the person in charge above 2.0.5 actives default.actives int N 0 performance optimization The max concurrency of per service method for each corresponding consumer above 2.0.5 cluster default.cluster string N failover performance optimization Cluster tolerance. Choices\uff1afailover/failfast/failsafe/failback/forking above 2.0.5 filter reference.filter string N performance optimization The name of filter which intercepts consumer remote invoke. Multiple names are separated by commas above 2.0.5 listener invoker.listener string N performance optimization The consumer referenced service listener name. Multiple names are separated by commas above 2.0.5 registry string N register with the registry configuration relevant Register with the designated registry. Generally\uff0cfor multiple registries, and value is the \"id\" of dubbo:registry . Multiple registries are separated by commas.If you do not want to register the service to any registry\uff0cpls set \"N/A\" above 2.0.5 layer layer string N service governance The layer of consumer. Such as: biz, dao, intl:web, china:acton above 2.0.7 init init boolean N false performance optimization If true, initialize when \"afterPropertiesSet()\" is invoked. Otherwise wait until the instance is referenced to initialize above 2.0.10 cache cache string/boolean N service governance Cache return result, and key is call parameters. Choices: lru, threadlocal, jcache and so on at least 2.1.0 validation validation boolean N service governance Whether enable JSR303 standard annotation validation at least 2.1.0","title":"dubbo:consumer"},{"location":"user/references/xml/dubbo-consumer/#dubboconsumer","text":"Consumer default configuration. The corresponding clas\uff1a org.apache.dubbo.config.ConsumerConfig . It is also default configuration of dubbo:reference . Property Corresponding URL parameter Type Requisite Default Effect Description Compatibility timeout default.timeout int N 1000 performance optimization invoking timeout(ms) above 1.0.16 retries default.retries int N 2 performance optimization Invoking retry times, exclude the first invoking. Set 0 to disable it.Only valid if the cluster's value is failback/failover above 1.0.16 loadbalance default.loadbalance string N random performance optimization Load balancing strategy. Choices\uff1arandom, roundrobin(polling), leastactive(invoking least active service) above 1.0.16 async default.async boolean N false performance optimization Whether invoke asynchronously above 2.0.0 connections default.connections int N 100 performance optimization The maximum number of connections of per service provider. Only short link protocol such as rmi,http,hessian etc. supports. Long link protocol such as dubbo doesn't support above 1.0.16 generic generic boolean N false service governance Whether default generic interface. A instance of GenericService will be got if true. above 2.0.0 check check boolean N true service governance Whether check the survival of provider. If true, throw exception when no provider of some services is alive. Otherwise, just ignore it above 1.0.16 proxy proxy string N javassist performance optimization Java class compile.It is used for the generating of dynamic class. The options are JDK and javassist above 2.0.5 owner owner string N service governance Application manager. Pls. fill in the mailbox prefix of the person in charge above 2.0.5 actives default.actives int N 0 performance optimization The max concurrency of per service method for each corresponding consumer above 2.0.5 cluster default.cluster string N failover performance optimization Cluster tolerance. Choices\uff1afailover/failfast/failsafe/failback/forking above 2.0.5 filter reference.filter string N performance optimization The name of filter which intercepts consumer remote invoke. Multiple names are separated by commas above 2.0.5 listener invoker.listener string N performance optimization The consumer referenced service listener name. Multiple names are separated by commas above 2.0.5 registry string N register with the registry configuration relevant Register with the designated registry. Generally\uff0cfor multiple registries, and value is the \"id\" of dubbo:registry . Multiple registries are separated by commas.If you do not want to register the service to any registry\uff0cpls set \"N/A\" above 2.0.5 layer layer string N service governance The layer of consumer. Such as: biz, dao, intl:web, china:acton above 2.0.7 init init boolean N false performance optimization If true, initialize when \"afterPropertiesSet()\" is invoked. Otherwise wait until the instance is referenced to initialize above 2.0.10 cache cache string/boolean N service governance Cache return result, and key is call parameters. Choices: lru, threadlocal, jcache and so on at least 2.1.0 validation validation boolean N service governance Whether enable JSR303 standard annotation validation at least 2.1.0","title":"dubbo:consumer"},{"location":"user/references/xml/dubbo-method/","text":"dubbo:method Method level configuration. The corresponding class: org.apache.dubbo.config.MethodConfig . This tag is a child tag of dubbo:service or dubbo:reference , for accuracy to method level. Property Corresponding URL parameter Type Requisite Default Effect Description Compatibility name string Y identifier Method name above 1.0.8 timeout metodName .timeout int N dubbo:reference timeout performance optimization Method call timeout(ms) above 1.0.8 retries metodName .retries int N dubbo:reference retries performance optimization Invoking retry times, exclude the first invoking. Set 0 to disable it above 2.0.0 loadbalance metodName .loadbalance string N dubbo:reference loadbalance performance optimization Load balancing strategy. Choices\uff1arandom, roundrobin(polling), leastactive(invoking least active service) above 2.0.0 async metodName .async boolean N dubbo:reference async performance optimization Whether invoke asynchronously above 1.0.9 sent methodName .sent boolean N true performance optimization Generally used when async is true, and If true, indicate that the network has sent out data above 2.0.6 actives metodName .actives int N 0 performance optimization The max concurrency of per service method for each corresponding consumer above 2.0.5 executes metodName .executes int N 0 performance optimization The maximum number of threads of per service method is limited . Only take effect when dubbo:method is dubbo:service child tag above 2.0.5 deprecated methodName .deprecated boolean N false service governance Whether is deprecated method. Only take effect when dubbo:method is dubbo:service child tag above 2.0.5 sticky methodName .sticky boolean N false service governance If true, all methods on this interface use the same provider. If more complex rules are required, use routing above 2.0.6 return methodName .return boolean N true performance optimization Whether need return value. Only take effect when async is true. If true, return future, or callback such as \"onreturn\" method. Otherwise, return null. above 2.0.6 oninvoke String N performance optimization Intercept before invoke above 2.0.6 onreturn String N performance optimization Intercept after invoke above 2.0.6 onthrow String N performance optimization Intercept when catch exception above 2.0.6 cache methodName .cache string/boolean N service governance Cache return result, and key is call parameters. Choices: lru, threadlocal, jcache and so on at least 2.1.0 validation methodName .validation boolean N service governance Whether enable JSR303 standard annotation validation at least 2.1.0 For example: dubbo:reference interface= com.xxx.XxxService dubbo:method name= findXxx timeout= 3000 retries= 2 / /dubbo:reference","title":"dubbo:method"},{"location":"user/references/xml/dubbo-method/#dubbomethod","text":"Method level configuration. The corresponding class: org.apache.dubbo.config.MethodConfig . This tag is a child tag of dubbo:service or dubbo:reference , for accuracy to method level. Property Corresponding URL parameter Type Requisite Default Effect Description Compatibility name string Y identifier Method name above 1.0.8 timeout metodName .timeout int N dubbo:reference timeout performance optimization Method call timeout(ms) above 1.0.8 retries metodName .retries int N dubbo:reference retries performance optimization Invoking retry times, exclude the first invoking. Set 0 to disable it above 2.0.0 loadbalance metodName .loadbalance string N dubbo:reference loadbalance performance optimization Load balancing strategy. Choices\uff1arandom, roundrobin(polling), leastactive(invoking least active service) above 2.0.0 async metodName .async boolean N dubbo:reference async performance optimization Whether invoke asynchronously above 1.0.9 sent methodName .sent boolean N true performance optimization Generally used when async is true, and If true, indicate that the network has sent out data above 2.0.6 actives metodName .actives int N 0 performance optimization The max concurrency of per service method for each corresponding consumer above 2.0.5 executes metodName .executes int N 0 performance optimization The maximum number of threads of per service method is limited . Only take effect when dubbo:method is dubbo:service child tag above 2.0.5 deprecated methodName .deprecated boolean N false service governance Whether is deprecated method. Only take effect when dubbo:method is dubbo:service child tag above 2.0.5 sticky methodName .sticky boolean N false service governance If true, all methods on this interface use the same provider. If more complex rules are required, use routing above 2.0.6 return methodName .return boolean N true performance optimization Whether need return value. Only take effect when async is true. If true, return future, or callback such as \"onreturn\" method. Otherwise, return null. above 2.0.6 oninvoke String N performance optimization Intercept before invoke above 2.0.6 onreturn String N performance optimization Intercept after invoke above 2.0.6 onthrow String N performance optimization Intercept when catch exception above 2.0.6 cache methodName .cache string/boolean N service governance Cache return result, and key is call parameters. Choices: lru, threadlocal, jcache and so on at least 2.1.0 validation methodName .validation boolean N service governance Whether enable JSR303 standard annotation validation at least 2.1.0 For example: dubbo:reference interface= com.xxx.XxxService dubbo:method name= findXxx timeout= 3000 retries= 2 / /dubbo:reference","title":"dubbo:method"},{"location":"user/references/xml/dubbo-module/","text":"dubbo:module Module configuration. The corresponding class org.apache.dubbo.config.ModuleConfig Property The corresponding class Type Requisite Default Effect Description Compatibility name module string Y service governance Module name is for registry combing the dependencies of modules. above 2.2.0 version module.version string N service governance module version above 2.2.0 owner owner string N service governance Module manager, Pls. fill in the mailbox prefix of the person in charge above 2.2.0 organization organization string N service governance Organization name is for registry distinguishing between the source of service. As a suggestion, this property should be written in config file directly. Such as china,intl,itu,crm,asc,dw,aliexpress etc. above 2.2.0","title":"dubbo:module"},{"location":"user/references/xml/dubbo-module/#dubbomodule","text":"Module configuration. The corresponding class org.apache.dubbo.config.ModuleConfig Property The corresponding class Type Requisite Default Effect Description Compatibility name module string Y service governance Module name is for registry combing the dependencies of modules. above 2.2.0 version module.version string N service governance module version above 2.2.0 owner owner string N service governance Module manager, Pls. fill in the mailbox prefix of the person in charge above 2.2.0 organization organization string N service governance Organization name is for registry distinguishing between the source of service. As a suggestion, this property should be written in config file directly. Such as china,intl,itu,crm,asc,dw,aliexpress etc. above 2.2.0","title":"dubbo:module"},{"location":"user/references/xml/dubbo-monitor/","text":"dubbo:monitor Monitor center configuration. The corresponding class: org.apache.dubbo.config.MonitorConfig Property The corresponding class Type Requisite Default Effect Description Compatibility protocol protocol string N dubbo service governance Monitor center protocol. \"registry\" means looking up monitor center from registry. Others mean communicating to monitor center directly above 2.0.9 address url string N N/A service governance Communicating to monitor center directly. address=\"10.20.130.230:12080\" above 1.0.16","title":"dubbo:monitor"},{"location":"user/references/xml/dubbo-monitor/#dubbomonitor","text":"Monitor center configuration. The corresponding class: org.apache.dubbo.config.MonitorConfig Property The corresponding class Type Requisite Default Effect Description Compatibility protocol protocol string N dubbo service governance Monitor center protocol. \"registry\" means looking up monitor center from registry. Others mean communicating to monitor center directly above 2.0.9 address url string N N/A service governance Communicating to monitor center directly. address=\"10.20.130.230:12080\" above 1.0.16","title":"dubbo:monitor"},{"location":"user/references/xml/dubbo-parameter/","text":"dubbo:parameter Optional parameter configuration. The corresponding class is java.util.Map . This tag is used as a sub tag to configure custom parameters for extending dubbo:protocol , dubbo:service , dubbo:provider , dubbo:reference or dubbo:consumer . Attribute Corresponding URL parameter Type Required Default Value Function Description Compatibility key key string True Service governance routing parameter key Above 2.0.0 value value string True Service governance routing parameter value Above 2.0.0 For example\uff1a dubbo:protocol name= napoli dubbo:parameter key= http://10.20.160.198/wiki/display/dubbo/napoli.queue.name value= xxx / /dubbo:protocol you can also use it like this: dubbo:protocol name= jms p:queue= xxx /","title":"dubbo:parameter"},{"location":"user/references/xml/dubbo-parameter/#dubboparameter","text":"Optional parameter configuration. The corresponding class is java.util.Map . This tag is used as a sub tag to configure custom parameters for extending dubbo:protocol , dubbo:service , dubbo:provider , dubbo:reference or dubbo:consumer . Attribute Corresponding URL parameter Type Required Default Value Function Description Compatibility key key string True Service governance routing parameter key Above 2.0.0 value value string True Service governance routing parameter value Above 2.0.0 For example\uff1a dubbo:protocol name= napoli dubbo:parameter key= http://10.20.160.198/wiki/display/dubbo/napoli.queue.name value= xxx / /dubbo:protocol you can also use it like this: dubbo:protocol name= jms p:queue= xxx /","title":"dubbo:parameter"},{"location":"user/references/xml/dubbo-protocol/","text":"dubbo:protocol Service provider protocol configuration. The corresponding class is org.apache.dubbo.config.ProtocolConfig . If you need to support multiple protocols, you could declare multiple dubbo:protocol tags, and specify the protocol via protocol property. Attribute Corresponding URL parameter Type Required Default Value Function Description Compatibility id string False dubbo Configuration association Bean Id of the protocol, can be referenced in dubbo:service protocol=\"\" The default value is equal to the value of name attribute while id is not filled. If name value has already existed, it will add index to it's suffix. Above 2.0.5 name protocol string True dubbo Performance optimize Protocol name Above 2.0.5 port port int False The default port of dubbo protocol is 20880, rmi protocol is 1099, http and hessian protocol are 80\uff1bIt will allocate the default port if port is not filled; It will allocate an unused port if port equals -1 . To ensure the ports scope is controllable, the port will increase based on the corresponding protocol default port after Dubbo 2.4.0+ Service discovery Service port Above 2.0.5 host host string False Find local IP automatically Service discovery The host name of services, to specify VIP and domain, or having multiple network cards. If null, it will find local IP automatically It's recommended to let Dubbo find local IP automatically Above 2.0.5 threadpool threadpool string False fixed Performance optimize The type of Thread Pool, fixed/cached are available Above 2.0.5 threads threads int False 200 Performance optimize The size of the services' Thread Pool(Fixed) Above 2.0.5 iothreads threads int False The count of CPU + 1 Performance optimize The size of io Thread Pool(Fixed) Above 2.0.5 accepts accepts int False 0 Performance optimize The maximum connection count of the service provider Above 2.0.5 payload payload int False 8388608(=8M) Performance optimize The length limit of request and response, unit is byte Above 2.0.5 codec codec string False dubbo Performance optimize Protocol encoding Above 2.0.5 serialization serialization string False The default serialization of dubbo protocol is hessian2, rmi protocol is java, http protocol is json Performance optimize Protocol serialization, It's used when a protocol has multiple serializations. For example, dubbo protocol has 4 serializations, they are dubbo , hessian2 , java and compactedjava . Above 2.0.5 accesslog accesslog string/boolean False Service discovery true will write access log to logger. Specifying it to a log path, you can write access logs to special log file. Above 2.0.5 path path string False Service discovery Context path, the prefix of the service path Above 2.0.5 transporter transporter string False The default value of dubbo protocol is netty Performance optimize The server and client implements of the protocol. For example, mina and netty for dubbo protocol. You can configure server or client side separately. Above 2.0.5 server server string False The default value of dubbo protocol is netty, http protocol is servlet Performance optimize The server implement of the protocol. For example, mina and netty for dubbo ptotocol, jetty and servlet for http protocol. Above 2.0.5 client client string False The default value of dubbo protocol is netty Performance optimize The client implement of the protocol. For example, mina and netty for dubbo protocol. Above 2.0.5 dispatcher dispatcher string False The default value of dubbo protocol is all Performance optimize specify the thread model of the way to dispatching. Such as all , direct , message , execution , and connection for dubbo protocol. Above 2.1.0 queues queues int False 0 Performance optimize The queue size of the Thread Pool. It's recommended not to specify it in order to invoke other provides rather than queueing unless you have special requirement. Above 2.0.5 charset charset string False UTF-8 Performance optimize Serialization encoding Above 2.0.5 buffer buffer int False 8192 Performance optimize The buffer size of networking IO Above 2.0.5 heartbeat heartbeat int False 0 Performance optimize Heartbeat interval. For long connection, it's difficult to receive closing event while the physical layer is disconnected. So heartbeat is necessary to help checking the connection quality Above 2.0.10 telnet telnet string False Service discovery Supported telnet commands, use , to separate commands. Above 2.0.5 register register boolean False true Service discovery Whether registering the corresponding services to registry center Above 2.0.8 contextpath contextpath String False Default value is an empty string Service discovery Above 2.0.6","title":"dubbo:protocol"},{"location":"user/references/xml/dubbo-protocol/#dubboprotocol","text":"Service provider protocol configuration. The corresponding class is org.apache.dubbo.config.ProtocolConfig . If you need to support multiple protocols, you could declare multiple dubbo:protocol tags, and specify the protocol via protocol property. Attribute Corresponding URL parameter Type Required Default Value Function Description Compatibility id string False dubbo Configuration association Bean Id of the protocol, can be referenced in dubbo:service protocol=\"\" The default value is equal to the value of name attribute while id is not filled. If name value has already existed, it will add index to it's suffix. Above 2.0.5 name protocol string True dubbo Performance optimize Protocol name Above 2.0.5 port port int False The default port of dubbo protocol is 20880, rmi protocol is 1099, http and hessian protocol are 80\uff1bIt will allocate the default port if port is not filled; It will allocate an unused port if port equals -1 . To ensure the ports scope is controllable, the port will increase based on the corresponding protocol default port after Dubbo 2.4.0+ Service discovery Service port Above 2.0.5 host host string False Find local IP automatically Service discovery The host name of services, to specify VIP and domain, or having multiple network cards. If null, it will find local IP automatically It's recommended to let Dubbo find local IP automatically Above 2.0.5 threadpool threadpool string False fixed Performance optimize The type of Thread Pool, fixed/cached are available Above 2.0.5 threads threads int False 200 Performance optimize The size of the services' Thread Pool(Fixed) Above 2.0.5 iothreads threads int False The count of CPU + 1 Performance optimize The size of io Thread Pool(Fixed) Above 2.0.5 accepts accepts int False 0 Performance optimize The maximum connection count of the service provider Above 2.0.5 payload payload int False 8388608(=8M) Performance optimize The length limit of request and response, unit is byte Above 2.0.5 codec codec string False dubbo Performance optimize Protocol encoding Above 2.0.5 serialization serialization string False The default serialization of dubbo protocol is hessian2, rmi protocol is java, http protocol is json Performance optimize Protocol serialization, It's used when a protocol has multiple serializations. For example, dubbo protocol has 4 serializations, they are dubbo , hessian2 , java and compactedjava . Above 2.0.5 accesslog accesslog string/boolean False Service discovery true will write access log to logger. Specifying it to a log path, you can write access logs to special log file. Above 2.0.5 path path string False Service discovery Context path, the prefix of the service path Above 2.0.5 transporter transporter string False The default value of dubbo protocol is netty Performance optimize The server and client implements of the protocol. For example, mina and netty for dubbo protocol. You can configure server or client side separately. Above 2.0.5 server server string False The default value of dubbo protocol is netty, http protocol is servlet Performance optimize The server implement of the protocol. For example, mina and netty for dubbo ptotocol, jetty and servlet for http protocol. Above 2.0.5 client client string False The default value of dubbo protocol is netty Performance optimize The client implement of the protocol. For example, mina and netty for dubbo protocol. Above 2.0.5 dispatcher dispatcher string False The default value of dubbo protocol is all Performance optimize specify the thread model of the way to dispatching. Such as all , direct , message , execution , and connection for dubbo protocol. Above 2.1.0 queues queues int False 0 Performance optimize The queue size of the Thread Pool. It's recommended not to specify it in order to invoke other provides rather than queueing unless you have special requirement. Above 2.0.5 charset charset string False UTF-8 Performance optimize Serialization encoding Above 2.0.5 buffer buffer int False 8192 Performance optimize The buffer size of networking IO Above 2.0.5 heartbeat heartbeat int False 0 Performance optimize Heartbeat interval. For long connection, it's difficult to receive closing event while the physical layer is disconnected. So heartbeat is necessary to help checking the connection quality Above 2.0.10 telnet telnet string False Service discovery Supported telnet commands, use , to separate commands. Above 2.0.5 register register boolean False true Service discovery Whether registering the corresponding services to registry center Above 2.0.8 contextpath contextpath String False Default value is an empty string Service discovery Above 2.0.6","title":"dubbo:protocol"},{"location":"user/references/xml/dubbo-provider/","text":"dubbo:provider The default configuration of service provider. The corresponding class is org.apache.dubbo.config.ProviderConfig . This tag provider default values for dubbo:service and dubbo:protocol . Attribute Corresponding URL parameter Type Required Default Value Function Description Compatibility id string False dubbo Configuration association Bean Id of the protocol, can be referenced in dubbo:service proivder=\"\" Above 1.0.16 protocol protocol string False dubbo Performance optimize Protocol name Above 1.0.16 host host string False Find local IP automatically Service discovery The host name of services, to specify VIP and domain, or having multiple network cards. If null, it will find local IP automatically. It's recommended to let Dubbo find local IP automatically Above 1.0.16 threads threads int False 200 Performance optimize The size of the services' Thread Pool(Fixed) Above 1.0.16 payload payload int False 8388608(=8M) Performance optimize The length limit of request and response, unit is byte Above 2.0.0 path path string False Service discovery Context path of the service provider, the prefix of the service path Above 2.0.0 server server string False Default is netty for dubbo protocol, servlet for http protocol Performance optimize The server implement of the protocol. For example, mina and netty for dubbo ptotocol, jetty and servlet for http protocol. Above 2.0.0 client client string False Default is netty for dubbo protocol Performance optimize The client implement of the protocol. For example, mina and netty for dubbo protocol. Above 2.0.0 codec codec string False dubbo Performance optimize Protocol encoding Above 2.0.0 serialization serialization string False Default is hessian2 for dubbo protocol, json for http protocol Performance optimize Protocol serialization, It's used when a protocol has multiple serializations. For example, dubbo protocol has 4 serializations, they are dubbo , hessian2 , java and compactedjava , http protocol has json and xml . Above 2.0.5 default boolean False false Configuration association To specify the default protocol for support multiple protocols. Above 1.0.16 filter service.filter string False Performance optimize The filter name of the RPC process of the provider, use , to separate multiple filter names. Above 2.0.5 listener exporter.listener string False Performance optimize The listener name of the provider, use , to separate multiple listener names. Above 2.0.5 threadpool threadpool string False fixed Performance optimize The type of Thread Pool, fixed/cached are available Above 2.0.5 accepts accepts int False 0 Performance optimize The maximum connection count of the service provider Above 2.0.5 version version string False 0.0.0 Service discovery Service version. It's recommended to use 2 digitals such as 1.0 . It's necessary to upgrade version only when the service is not compatible. Above 2.0.5 group group string False Service discovery The group of the service providers. It can distinguish services when it has multiple implements. Above 2.0.5 delay delay int False 0 Performance optimize The delay time(ms) for registering services. When set to -1, it indicates that the services will expose to registry after the Spring context is initialized Above 2.0.5 timeout default.timeout int False 1000 Performance optimize The RPC timeout(ms) Above 2.0.5 retries default.retries int False 2 Performance optimize The retry count for RPC, not including the first invoke. Please set it to 0 if don't need to retry. Above 2.0.5 connections default.connections int False 0 Performance optimize The maximum connections of every provider. For short connection such as rmi, http and hessian, it's connection limit, but for long connection such as dubbo, it's connection count. Above 2.0.5 loadbalance default.loadbalance string False random Performance optimize Strategy of load balance, random , roundrobin and leastactive are available. Above 2.0.5 async default.async boolean False false Performance optimize Asynchronous execution, not reliable. It does not block the execution thread just only ignores the return value. Above 2.0.5 stub stub boolean False false Service governance true means use the default proxy class name, which is the interface name with Local as the suffix. Above 2.0.5 mock mock boolean False false Service governance true means use the default mock class name, which is the interface name with Mock suffix. Above 2.0.5 token token boolean False false Service governance Enable token validation. Disable token if it's null. It will generate token randomly when it is enable. Above 2.0.5 registry registry string False By default, register to all registries Configuration association Register services to specified registry while having multiple registries. It is the id value of the dubbo:registry . If don't want to register to any registry, set it as N/A Above 2.0.5 dynamic dynamic boolean False true Service governance Whether the service is registered dynamically. If false, services will be showed as disable , you need to enable it manually. And you also need to disable it when provider shut down. Above 2.0.5 accesslog accesslog string/boolean False false Service governance true will write access log to logger. Specifying it to a log path, you can write access logs to special log file. Above 2.0.5 owner owner string False Service governance The owner of the service. It's used for service governance. Above 2.0.5 document document string False Service governance Service document URL Above 2.0.5 weight weight int False Performance optimize The weight of the service Above 2.0.5 executes executes int False 0 Performance optimize The maximum parallel execution request count per method per service for the provider. Above 2.0.5 actives default.actives int False 0 Performance optimize The maximum concurrent calls per method per service of the consumer. Above 2.0.5 proxy proxy string False javassist Performance optimize The proxy implement, jdk/javassist are available. Above 2.0.5 cluster default.cluster string False failover Performance optimize failover/failfast/failsafe/failback/forking are available. Above 2.0.5 deprecated deprecated boolean False false Service governance Mark the service is deprecated. If true, there will log an error log on the client side. Above 2.0.5 queues queues int False 0 Performance optimize The queue size of the Thread Pool. It's recommended not to specify it in order to invoke other provides rather than queueing unless you have special requirement. Above 2.0.5 charset charset string False UTF-8 Performance optimize Serialization encoding Above 2.0.5 buffer buffer int False 8192 Performance optimize The buffer size of networking IO Above 2.0.5 iothreads iothreads int False CPU + 1 Performance optimize The size of io Thread Pool(Fixed). These threads are used to receive, serialize and deserialize IO data. See threads for configuring business thread pool. It's not recommended to configure this. Above 2.0.5 telnet telnet string False Service governance Supported telnet commands, use , to separate commands. Above 2.0.5 contextpath contextpath String False Empty string Service governance layer layer string False Service governance The biz layer of the service provider, such as biz, dao, intl:web and china:acton. Above 2.0.7","title":"dubbo:provider"},{"location":"user/references/xml/dubbo-provider/#dubboprovider","text":"The default configuration of service provider. The corresponding class is org.apache.dubbo.config.ProviderConfig . This tag provider default values for dubbo:service and dubbo:protocol . Attribute Corresponding URL parameter Type Required Default Value Function Description Compatibility id string False dubbo Configuration association Bean Id of the protocol, can be referenced in dubbo:service proivder=\"\" Above 1.0.16 protocol protocol string False dubbo Performance optimize Protocol name Above 1.0.16 host host string False Find local IP automatically Service discovery The host name of services, to specify VIP and domain, or having multiple network cards. If null, it will find local IP automatically. It's recommended to let Dubbo find local IP automatically Above 1.0.16 threads threads int False 200 Performance optimize The size of the services' Thread Pool(Fixed) Above 1.0.16 payload payload int False 8388608(=8M) Performance optimize The length limit of request and response, unit is byte Above 2.0.0 path path string False Service discovery Context path of the service provider, the prefix of the service path Above 2.0.0 server server string False Default is netty for dubbo protocol, servlet for http protocol Performance optimize The server implement of the protocol. For example, mina and netty for dubbo ptotocol, jetty and servlet for http protocol. Above 2.0.0 client client string False Default is netty for dubbo protocol Performance optimize The client implement of the protocol. For example, mina and netty for dubbo protocol. Above 2.0.0 codec codec string False dubbo Performance optimize Protocol encoding Above 2.0.0 serialization serialization string False Default is hessian2 for dubbo protocol, json for http protocol Performance optimize Protocol serialization, It's used when a protocol has multiple serializations. For example, dubbo protocol has 4 serializations, they are dubbo , hessian2 , java and compactedjava , http protocol has json and xml . Above 2.0.5 default boolean False false Configuration association To specify the default protocol for support multiple protocols. Above 1.0.16 filter service.filter string False Performance optimize The filter name of the RPC process of the provider, use , to separate multiple filter names. Above 2.0.5 listener exporter.listener string False Performance optimize The listener name of the provider, use , to separate multiple listener names. Above 2.0.5 threadpool threadpool string False fixed Performance optimize The type of Thread Pool, fixed/cached are available Above 2.0.5 accepts accepts int False 0 Performance optimize The maximum connection count of the service provider Above 2.0.5 version version string False 0.0.0 Service discovery Service version. It's recommended to use 2 digitals such as 1.0 . It's necessary to upgrade version only when the service is not compatible. Above 2.0.5 group group string False Service discovery The group of the service providers. It can distinguish services when it has multiple implements. Above 2.0.5 delay delay int False 0 Performance optimize The delay time(ms) for registering services. When set to -1, it indicates that the services will expose to registry after the Spring context is initialized Above 2.0.5 timeout default.timeout int False 1000 Performance optimize The RPC timeout(ms) Above 2.0.5 retries default.retries int False 2 Performance optimize The retry count for RPC, not including the first invoke. Please set it to 0 if don't need to retry. Above 2.0.5 connections default.connections int False 0 Performance optimize The maximum connections of every provider. For short connection such as rmi, http and hessian, it's connection limit, but for long connection such as dubbo, it's connection count. Above 2.0.5 loadbalance default.loadbalance string False random Performance optimize Strategy of load balance, random , roundrobin and leastactive are available. Above 2.0.5 async default.async boolean False false Performance optimize Asynchronous execution, not reliable. It does not block the execution thread just only ignores the return value. Above 2.0.5 stub stub boolean False false Service governance true means use the default proxy class name, which is the interface name with Local as the suffix. Above 2.0.5 mock mock boolean False false Service governance true means use the default mock class name, which is the interface name with Mock suffix. Above 2.0.5 token token boolean False false Service governance Enable token validation. Disable token if it's null. It will generate token randomly when it is enable. Above 2.0.5 registry registry string False By default, register to all registries Configuration association Register services to specified registry while having multiple registries. It is the id value of the dubbo:registry . If don't want to register to any registry, set it as N/A Above 2.0.5 dynamic dynamic boolean False true Service governance Whether the service is registered dynamically. If false, services will be showed as disable , you need to enable it manually. And you also need to disable it when provider shut down. Above 2.0.5 accesslog accesslog string/boolean False false Service governance true will write access log to logger. Specifying it to a log path, you can write access logs to special log file. Above 2.0.5 owner owner string False Service governance The owner of the service. It's used for service governance. Above 2.0.5 document document string False Service governance Service document URL Above 2.0.5 weight weight int False Performance optimize The weight of the service Above 2.0.5 executes executes int False 0 Performance optimize The maximum parallel execution request count per method per service for the provider. Above 2.0.5 actives default.actives int False 0 Performance optimize The maximum concurrent calls per method per service of the consumer. Above 2.0.5 proxy proxy string False javassist Performance optimize The proxy implement, jdk/javassist are available. Above 2.0.5 cluster default.cluster string False failover Performance optimize failover/failfast/failsafe/failback/forking are available. Above 2.0.5 deprecated deprecated boolean False false Service governance Mark the service is deprecated. If true, there will log an error log on the client side. Above 2.0.5 queues queues int False 0 Performance optimize The queue size of the Thread Pool. It's recommended not to specify it in order to invoke other provides rather than queueing unless you have special requirement. Above 2.0.5 charset charset string False UTF-8 Performance optimize Serialization encoding Above 2.0.5 buffer buffer int False 8192 Performance optimize The buffer size of networking IO Above 2.0.5 iothreads iothreads int False CPU + 1 Performance optimize The size of io Thread Pool(Fixed). These threads are used to receive, serialize and deserialize IO data. See threads for configuring business thread pool. It's not recommended to configure this. Above 2.0.5 telnet telnet string False Service governance Supported telnet commands, use , to separate commands. Above 2.0.5 contextpath contextpath String False Empty string Service governance layer layer string False Service governance The biz layer of the service provider, such as biz, dao, intl:web and china:acton. Above 2.0.7","title":"dubbo:provider"},{"location":"user/references/xml/dubbo-reference/","text":"dubbo:reference The configuration of service consumer. The corresponding class is org.apache.dubbo.config.ReferenceConfig Attribute Corresponding URL parameter Type Required Default Value Function Description Compatibility id string True Configuration association Bean Id of the service reference Above 1.0.0 interface class True Service discovery Interface name of the service Above 1.0.0 version version string False Service discovery Service version, must be equal to the provider's version Above 1.0.0 group group string False Service discovery The group of the service reference, must be equal to the provider's group. It can distinguish services when it has multiple implements. Above 1.0.7 timeout timeout long False By default, use dubbo:consumer timeout Performance optimize The RPC timeout(ms) Above 1.0.5 retries retries int False By default, use dubbo:consumer retries Performance optimize The retry count for RPC, not including the first invoke. Please set it to 0 if don't need to retry. Above 2.0.0 connections connections int False By default, use dubbo:consumer connections Performance optimize The maximum connections of every provider. For short connection such as rmi, http and hessian, it's connection limit, but for long connection such as dubbo, it's connection count. Above 2.0.0 loadbalance loadbalance string False By default, use dubbo:consumer loadbalance Performance optimize Strategy of load balance, random , roundrobin and leastactive are available. Above 2.0.0 async async boolean False By default, use dubbo:consumer async Performance optimize Asynchronous execution, not reliable. It does not block the execution thread just only ignores the return value. Above 2.0.0 generic generic boolean False By default, use dubbo:consumer generic Service governance Enable generic interface. If true, the reference will return GenericService Above 2.0.0 check check boolean False By default, use dubbo:consumer check Service governance Check the exist of the provider. If true, it will throw exception when provider is not exist. If false, will ignore. Above 2.0.0 url url string False Service governance Connect to the provider directly via this url. It will bypass the registry. Above 1.0.6 stub stub class/boolean False Service governance The local proxy class name of the client, it's used to execute local logic such as caching. The proxy class must have a constructor with the remote proxy object as a parameter, such as public XxxServiceLocal(XxxService xxxService) Above 2.0.0 mock mock class/boolean False Service governance The mock class name. It's called when the RPC is failed, such as timeout or IO exception. The mock class must carry a none parameter constructor. The difference between mock and local proxy is that local proxy is always invoked before RPC but mock is invoked only when exception after RPC. Above 1.0.13 cache cache string/boolean False Service governance lru, threadlocal, jcache\u7b49Using RPC parameters as the key to cache the result. lru , threadlocal and jcache are available. Above 2.1.0 validation validation boolean False Service governance Enable JSR303 annotation validation. If true, it will validate the method parameters' annotations. Above 2.1.0 proxy proxy boolean False javassist Performance optimize The proxy implement, jdk/javassist are available. Above 2.0.2 client client string False Performance optimize The transport type of the client, such as netty and mina for dubbo protocol. Above 2.0.0 registry string False By default, it will merge all the service providers that getting from all registries Configuration association Get provider lists from the specified registry. It is the id value of the dubbo:registry , use , to separate multiple regsitries id. Above 2.0.0 owner owner string False Service governance The owner of the service. It's used for service governance. Above 2.0.5 actives actives int False 0 Performance optimize The maximum concurrent calls per method per service of the consumer. Above 2.0.5 cluster cluster string False failover Performance optimize failover/failfast/failsafe/failback/forking are available. Above 2.0.5 filter reference.filter string False default Performance optimize The filter name of the RPC process of the reference, use , to separate multiple filter names. Above 2.0.5 listener invoker.listener string False default Performance optimize The listener name of the reference, use , to separate multiple listener names. Above 2.0.5 layer layer string False Service governance The biz layer of the service provider, such as biz, dao, intl:web and china:acton. Above 2.0.7 init init boolean False false Performance optimize If true, init the service reference when afterPropertiesSet() is invoked, or it will init later only when it is referenced and autowired. Above 2.0.10 protocol protocol string False Service governance Only invoke the providers with specified protocol, and ignore other protocol providers. Above 2.2.0","title":"dubbo:reference"},{"location":"user/references/xml/dubbo-reference/#dubboreference","text":"The configuration of service consumer. The corresponding class is org.apache.dubbo.config.ReferenceConfig Attribute Corresponding URL parameter Type Required Default Value Function Description Compatibility id string True Configuration association Bean Id of the service reference Above 1.0.0 interface class True Service discovery Interface name of the service Above 1.0.0 version version string False Service discovery Service version, must be equal to the provider's version Above 1.0.0 group group string False Service discovery The group of the service reference, must be equal to the provider's group. It can distinguish services when it has multiple implements. Above 1.0.7 timeout timeout long False By default, use dubbo:consumer timeout Performance optimize The RPC timeout(ms) Above 1.0.5 retries retries int False By default, use dubbo:consumer retries Performance optimize The retry count for RPC, not including the first invoke. Please set it to 0 if don't need to retry. Above 2.0.0 connections connections int False By default, use dubbo:consumer connections Performance optimize The maximum connections of every provider. For short connection such as rmi, http and hessian, it's connection limit, but for long connection such as dubbo, it's connection count. Above 2.0.0 loadbalance loadbalance string False By default, use dubbo:consumer loadbalance Performance optimize Strategy of load balance, random , roundrobin and leastactive are available. Above 2.0.0 async async boolean False By default, use dubbo:consumer async Performance optimize Asynchronous execution, not reliable. It does not block the execution thread just only ignores the return value. Above 2.0.0 generic generic boolean False By default, use dubbo:consumer generic Service governance Enable generic interface. If true, the reference will return GenericService Above 2.0.0 check check boolean False By default, use dubbo:consumer check Service governance Check the exist of the provider. If true, it will throw exception when provider is not exist. If false, will ignore. Above 2.0.0 url url string False Service governance Connect to the provider directly via this url. It will bypass the registry. Above 1.0.6 stub stub class/boolean False Service governance The local proxy class name of the client, it's used to execute local logic such as caching. The proxy class must have a constructor with the remote proxy object as a parameter, such as public XxxServiceLocal(XxxService xxxService) Above 2.0.0 mock mock class/boolean False Service governance The mock class name. It's called when the RPC is failed, such as timeout or IO exception. The mock class must carry a none parameter constructor. The difference between mock and local proxy is that local proxy is always invoked before RPC but mock is invoked only when exception after RPC. Above 1.0.13 cache cache string/boolean False Service governance lru, threadlocal, jcache\u7b49Using RPC parameters as the key to cache the result. lru , threadlocal and jcache are available. Above 2.1.0 validation validation boolean False Service governance Enable JSR303 annotation validation. If true, it will validate the method parameters' annotations. Above 2.1.0 proxy proxy boolean False javassist Performance optimize The proxy implement, jdk/javassist are available. Above 2.0.2 client client string False Performance optimize The transport type of the client, such as netty and mina for dubbo protocol. Above 2.0.0 registry string False By default, it will merge all the service providers that getting from all registries Configuration association Get provider lists from the specified registry. It is the id value of the dubbo:registry , use , to separate multiple regsitries id. Above 2.0.0 owner owner string False Service governance The owner of the service. It's used for service governance. Above 2.0.5 actives actives int False 0 Performance optimize The maximum concurrent calls per method per service of the consumer. Above 2.0.5 cluster cluster string False failover Performance optimize failover/failfast/failsafe/failback/forking are available. Above 2.0.5 filter reference.filter string False default Performance optimize The filter name of the RPC process of the reference, use , to separate multiple filter names. Above 2.0.5 listener invoker.listener string False default Performance optimize The listener name of the reference, use , to separate multiple listener names. Above 2.0.5 layer layer string False Service governance The biz layer of the service provider, such as biz, dao, intl:web and china:acton. Above 2.0.7 init init boolean False false Performance optimize If true, init the service reference when afterPropertiesSet() is invoked, or it will init later only when it is referenced and autowired. Above 2.0.10 protocol protocol string False Service governance Only invoke the providers with specified protocol, and ignore other protocol providers. Above 2.2.0","title":"dubbo:reference"},{"location":"user/references/xml/dubbo-registry/","text":"dubbo:registry The configuration of the registry center. The corresponding class is org.apache.dubbo.config.RegistryConfig . If you have multiple different registries, you can declare multiple dubbo:registry tags, and then reference specified registry with registry property in dubbo:service or dubbo:reference tag. Attribute Corresponding URL parameter Type Required Default Value Function Description Compatibility id string False Configuration association Bean Id of the registry center, can be referenced in dubbo:service registry=\"\" or dubbo:reference registry=\"\" Above 1.0.16 address host:port string True Service discovery The address of the registry center. If the address has no port, default port 9999 will be adopted. Multiple addresses within the same cluster use , to seperate, such as ip:port,ip:port . Multiple registries within different cluster, please configure different dubbo:registry tag. Above 1.0.16 protocol protocol string False dubbo Service discovery The protocol of the registry center. dubbo , multicast , zookeeper , redis , consul(2.7.1) , sofa(2.7.2) , etcd(2.7.2) , nacos(2.7.2) are available. Above 2.0.0 port port int False 9090 Service discovery The default port of the registry. When the address has no port, this default port will be adopted. Above 2.0.0 username username string False Service governance The usename of the registry. Do not set it if the registry doesn't need validation. Above 2.0.0 password password string False Service governance The password of the registry. Do not set it if the registry doesn't need validation. Above 2.0.0 transport registry.transporter string False netty Performance optimize mina, netty are available. Above 2.0.0 timeout registry.timeout int False 5000 Performance optimize The timeout(ms) of the request to registry. Above 2.0.0 session registry.session int False 60000 Performance optimize The session timeout(ms) of the registry. It's used to check whether the providers are alive. It depends on the implement of the registry. For example, for HeartBeat implement, the timeout is the interval of two heart beats. Above 2.1.0 file registry.file string False Service governance The local file to cache the address list of registries and providers. When application restarts, it will restore the registries and providers. Please use different file for different registy. Above 2.0.0 wait registry.wait int False 0 Performance optimize Stop wait for a notice completion time (ms) Above 2.0.0 check check boolean False true Service governance Whether throwing exception while the registry isn't existed. Above 2.0.0 register register boolean False true Service governance whether registering to the registry center. If false, just subscribing, not registering. Above 2.0.5 subscribe subscribe boolean False true Service governance whether subscribing from the registry center. If false, just registering, not subscribing. Above 2.0.5 dynamic dynamic boolean False true Service governance Whether the service is registered dynamically. If false, services will be showed as disable , you need to enable it manually. And you also need to disable it when provider shut down. Above 2.0.5 group group string False dubbo Service governance Service registration grouping, cross-group services will not affect each other, and can not be called each other, suitable for environmental isolation. Above 2.0.5 simplified simplified boolean False false Service governance Registered with the registry URL whether to adopt the lean mode (compatible with low version) Above 2.7.0 extra-keys extraKeys string False Service governance In simplified = true, extraKeys allows you to outside the default arguments put additional key in the URL, format: \"interface, key1, key2\". Above 2.7.0","title":"dubbo:registry"},{"location":"user/references/xml/dubbo-registry/#dubboregistry","text":"The configuration of the registry center. The corresponding class is org.apache.dubbo.config.RegistryConfig . If you have multiple different registries, you can declare multiple dubbo:registry tags, and then reference specified registry with registry property in dubbo:service or dubbo:reference tag. Attribute Corresponding URL parameter Type Required Default Value Function Description Compatibility id string False Configuration association Bean Id of the registry center, can be referenced in dubbo:service registry=\"\" or dubbo:reference registry=\"\" Above 1.0.16 address host:port string True Service discovery The address of the registry center. If the address has no port, default port 9999 will be adopted. Multiple addresses within the same cluster use , to seperate, such as ip:port,ip:port . Multiple registries within different cluster, please configure different dubbo:registry tag. Above 1.0.16 protocol protocol string False dubbo Service discovery The protocol of the registry center. dubbo , multicast , zookeeper , redis , consul(2.7.1) , sofa(2.7.2) , etcd(2.7.2) , nacos(2.7.2) are available. Above 2.0.0 port port int False 9090 Service discovery The default port of the registry. When the address has no port, this default port will be adopted. Above 2.0.0 username username string False Service governance The usename of the registry. Do not set it if the registry doesn't need validation. Above 2.0.0 password password string False Service governance The password of the registry. Do not set it if the registry doesn't need validation. Above 2.0.0 transport registry.transporter string False netty Performance optimize mina, netty are available. Above 2.0.0 timeout registry.timeout int False 5000 Performance optimize The timeout(ms) of the request to registry. Above 2.0.0 session registry.session int False 60000 Performance optimize The session timeout(ms) of the registry. It's used to check whether the providers are alive. It depends on the implement of the registry. For example, for HeartBeat implement, the timeout is the interval of two heart beats. Above 2.1.0 file registry.file string False Service governance The local file to cache the address list of registries and providers. When application restarts, it will restore the registries and providers. Please use different file for different registy. Above 2.0.0 wait registry.wait int False 0 Performance optimize Stop wait for a notice completion time (ms) Above 2.0.0 check check boolean False true Service governance Whether throwing exception while the registry isn't existed. Above 2.0.0 register register boolean False true Service governance whether registering to the registry center. If false, just subscribing, not registering. Above 2.0.5 subscribe subscribe boolean False true Service governance whether subscribing from the registry center. If false, just registering, not subscribing. Above 2.0.5 dynamic dynamic boolean False true Service governance Whether the service is registered dynamically. If false, services will be showed as disable , you need to enable it manually. And you also need to disable it when provider shut down. Above 2.0.5 group group string False dubbo Service governance Service registration grouping, cross-group services will not affect each other, and can not be called each other, suitable for environmental isolation. Above 2.0.5 simplified simplified boolean False false Service governance Registered with the registry URL whether to adopt the lean mode (compatible with low version) Above 2.7.0 extra-keys extraKeys string False Service governance In simplified = true, extraKeys allows you to outside the default arguments put additional key in the URL, format: \"interface, key1, key2\". Above 2.7.0","title":"dubbo:registry"},{"location":"user/references/xml/dubbo-service/","text":"dubbo:service The configuration of the service provider. The corresponding class is org.apache.dubbo.config.ServiceConfig . Attribute Corresponding URL parameter Type Required Default Value Function Description Compatibility interface class True Service discovery The service interface name Above 1.0.0 ref object True Service discovery The reference to the service implementation Above 1.0.0 version version string False 0.0.0 Service discovery Service version. It's recommended to use 2 digitals such as 1.0 . It's necessary to upgrade version only when the service is not compatible. Above 1.0.0 group group string False Service discovery The group of the service providers. It can distinguish services when it has multiple implements. Above 1.0.7 path path string False default value is the interface name Service discovery In 1.0, service path is not supported, it's always equals to the interface name. So it may not compitable when a service reference in 1.0 calls a service provider in 2.0 that specified path. Above 1.0.12 delay delay int False 0 Performance optimize The delay time(ms) for registering services. When set to -1, it indicates that the services will expose to registry after the Spring context is initialized Above 1.0.14 timeout timeout int False 1000 Performance optimize The RPC timeout(ms) Above 2.0.0 retries retries int False 2 Performance optimize The retry count for RPC, not including the first invoke. Please set it to 0 if don't need to retry. Above 2.0.0 connections connections int False 100 Performance optimize The maximum connections of every provider. For short connection such as rmi, http and hessian, it's connection limit, but for long connection such as dubbo, it's connection count. Above 2.0.0 loadbalance loadbalance string False random Performance optimize Strategy of load balance, random , roundrobin and leastactive are available. Above 2.0.0 async async boolean False false Performance optimize Asynchronous execution, not reliable. It does not block the execution thread just only ignores the return value. Above 2.0.0 local local class/boolean False false Service governance true means use the default proxy class name, which is the interface name with Local as the suffix. But it has been marked as @Deprecated.Pleas see also stub. Above 2.0.0 stub stub class/boolean False false Service governance true means use the default proxy class name, which is the interface name with Stub as the suffix. It's used to execute local logic such as caching. The proxy class must have a constructor with the remote proxy object as a parameter, such as public XxxServiceStub(XxxService xxxService) Above 2.0.0 mock mock class/boolean False false Service governance true means use the default mock class name, which is the interface name with Mock suffix. It's called when the RPC is failed, such as timeout or IO exception. The mock class must carry a none parameter constructor. The difference between mock and local proxy is that local proxy is always invoked before RPC but mock is invoked only when exception after RPC. Above 2.0.0 token token string/boolean False false Service governance Enable token validation. Disable token if it's null. It will generate token randomly when enable, or will use static token. The token is designed to prevent consumers from bypassing the registry direct access to provider. If you want peer to peer, token validation must disbable. Above 2.0.0 registry string False register to all registries by default Configuration association Register services to specified registry while having multiple registries. It is the id value of the dubbo:registry . If don't want to register to any registry, set it as N/A Above 2.0.0 provider string False use the first configured provider Configuration association The reference to dubbo:provider Above 2.0.0 deprecated deprecated boolean False false Service governance Mark the service is deprecated. If true, there will log an error log on the client side. Above 2.0.5 dynamic dynamic boolean False true Service governance Whether the service is registered dynamically. If false, services will be showed as disable , you need to enable it manually. And you also need to disable it when provider shut down. Above 2.0.5 accesslog accesslog string/boolean False false Service governance true will write access log to logger. Specifying it to a log path, you can write access logs to special log file. Above 2.0.5 owner owner string False Service governance The owner of the service. It's used for service governance. Above 2.0.5 document document string False Service governance Service document URL Above 2.0.5 weight weight int False Performance optimize The weight of the service Above 2.0.5 executes executes int False 0 Performance optimize The maximum parallel execution request count per method per service for the provider. Above 2.0.5 proxy proxy string False javassist Performance optimize The proxy implement, jdk/javassist are available. Above 2.0.5 cluster cluster string False failover Performance optimize failover/failfast/failsafe/failback/forking are available. Above 2.0.5 filter service.filter string False default Performance optimize The filter name of the RPC process of the provider, use , to separate multiple filter names. Above 2.0.5 listener exporter.listener string False default Performance optimize The listener name of the provider, use , to separate multiple listener names. protocol string False Configuration association Specify the protocol for service provider. It references the id of dubbo:protocol tag. Use , to separate multiple protocols. Above 2.0.5 layer layer string False Service governance The biz layer of the service provider, such as biz, dao, intl:web and china:acton. Above 2.0.7 register register boolean False true Service governance Whether registering service providers to registry. Above 2.0.8","title":"dubbo:service"},{"location":"user/references/xml/dubbo-service/#dubboservice","text":"The configuration of the service provider. The corresponding class is org.apache.dubbo.config.ServiceConfig . Attribute Corresponding URL parameter Type Required Default Value Function Description Compatibility interface class True Service discovery The service interface name Above 1.0.0 ref object True Service discovery The reference to the service implementation Above 1.0.0 version version string False 0.0.0 Service discovery Service version. It's recommended to use 2 digitals such as 1.0 . It's necessary to upgrade version only when the service is not compatible. Above 1.0.0 group group string False Service discovery The group of the service providers. It can distinguish services when it has multiple implements. Above 1.0.7 path path string False default value is the interface name Service discovery In 1.0, service path is not supported, it's always equals to the interface name. So it may not compitable when a service reference in 1.0 calls a service provider in 2.0 that specified path. Above 1.0.12 delay delay int False 0 Performance optimize The delay time(ms) for registering services. When set to -1, it indicates that the services will expose to registry after the Spring context is initialized Above 1.0.14 timeout timeout int False 1000 Performance optimize The RPC timeout(ms) Above 2.0.0 retries retries int False 2 Performance optimize The retry count for RPC, not including the first invoke. Please set it to 0 if don't need to retry. Above 2.0.0 connections connections int False 100 Performance optimize The maximum connections of every provider. For short connection such as rmi, http and hessian, it's connection limit, but for long connection such as dubbo, it's connection count. Above 2.0.0 loadbalance loadbalance string False random Performance optimize Strategy of load balance, random , roundrobin and leastactive are available. Above 2.0.0 async async boolean False false Performance optimize Asynchronous execution, not reliable. It does not block the execution thread just only ignores the return value. Above 2.0.0 local local class/boolean False false Service governance true means use the default proxy class name, which is the interface name with Local as the suffix. But it has been marked as @Deprecated.Pleas see also stub. Above 2.0.0 stub stub class/boolean False false Service governance true means use the default proxy class name, which is the interface name with Stub as the suffix. It's used to execute local logic such as caching. The proxy class must have a constructor with the remote proxy object as a parameter, such as public XxxServiceStub(XxxService xxxService) Above 2.0.0 mock mock class/boolean False false Service governance true means use the default mock class name, which is the interface name with Mock suffix. It's called when the RPC is failed, such as timeout or IO exception. The mock class must carry a none parameter constructor. The difference between mock and local proxy is that local proxy is always invoked before RPC but mock is invoked only when exception after RPC. Above 2.0.0 token token string/boolean False false Service governance Enable token validation. Disable token if it's null. It will generate token randomly when enable, or will use static token. The token is designed to prevent consumers from bypassing the registry direct access to provider. If you want peer to peer, token validation must disbable. Above 2.0.0 registry string False register to all registries by default Configuration association Register services to specified registry while having multiple registries. It is the id value of the dubbo:registry . If don't want to register to any registry, set it as N/A Above 2.0.0 provider string False use the first configured provider Configuration association The reference to dubbo:provider Above 2.0.0 deprecated deprecated boolean False false Service governance Mark the service is deprecated. If true, there will log an error log on the client side. Above 2.0.5 dynamic dynamic boolean False true Service governance Whether the service is registered dynamically. If false, services will be showed as disable , you need to enable it manually. And you also need to disable it when provider shut down. Above 2.0.5 accesslog accesslog string/boolean False false Service governance true will write access log to logger. Specifying it to a log path, you can write access logs to special log file. Above 2.0.5 owner owner string False Service governance The owner of the service. It's used for service governance. Above 2.0.5 document document string False Service governance Service document URL Above 2.0.5 weight weight int False Performance optimize The weight of the service Above 2.0.5 executes executes int False 0 Performance optimize The maximum parallel execution request count per method per service for the provider. Above 2.0.5 proxy proxy string False javassist Performance optimize The proxy implement, jdk/javassist are available. Above 2.0.5 cluster cluster string False failover Performance optimize failover/failfast/failsafe/failback/forking are available. Above 2.0.5 filter service.filter string False default Performance optimize The filter name of the RPC process of the provider, use , to separate multiple filter names. Above 2.0.5 listener exporter.listener string False default Performance optimize The listener name of the provider, use , to separate multiple listener names. protocol string False Configuration association Specify the protocol for service provider. It references the id of dubbo:protocol tag. Use , to separate multiple protocols. Above 2.0.5 layer layer string False Service governance The biz layer of the service provider, such as biz, dao, intl:web and china:acton. Above 2.0.7 register register boolean False true Service governance Whether registering service providers to registry. Above 2.0.8","title":"dubbo:service"},{"location":"user/references/xml/introduction/","text":"schema configuration reference The following pages show all the configuration properties [^2] with XML Config [^1] as an example. For other configurations, please reference: Properties Configuration , Annotation Configuration , API Configuration . All configuration properties fall into three categories, see the \"Function\" in the table below. Service discovery: used for service registration and discovery in order to find providers for consumers. Service governance: used for service management and governance, such as to provide conveninence for dev or test. Performance optinize: used for optimizing performance. Diffenent properties may has different performance impact. All properties will transform into URL [^3] which is generated by provider. The url will be subscribed by consumers through registry. Please see the Corresponding URL parameter in the table below for each property. [^1]: XML Schema: http://dubbo.apache.org/schema/dubbo/dubbo.xsd [^2]: Notice: These three properties, group, interface, and version determine a service. All other properties are used for service governance or performance optimize. [^3]: URL format\uff1a protocol://username:password@host:port/path?key=value key=value","title":"schema configuration reference"},{"location":"user/references/xml/introduction/#schema-configuration-reference","text":"The following pages show all the configuration properties [^2] with XML Config [^1] as an example. For other configurations, please reference: Properties Configuration , Annotation Configuration , API Configuration . All configuration properties fall into three categories, see the \"Function\" in the table below. Service discovery: used for service registration and discovery in order to find providers for consumers. Service governance: used for service management and governance, such as to provide conveninence for dev or test. Performance optinize: used for optimizing performance. Diffenent properties may has different performance impact. All properties will transform into URL [^3] which is generated by provider. The url will be subscribed by consumers through registry. Please see the Corresponding URL parameter in the table below for each property. [^1]: XML Schema: http://dubbo.apache.org/schema/dubbo/dubbo.xsd [^2]: Notice: These three properties, group, interface, and version determine a service. All other properties are used for service governance or performance optimize. [^3]: URL format\uff1a protocol://username:password@host:port/path?key=value key=value","title":"schema configuration reference"}]}