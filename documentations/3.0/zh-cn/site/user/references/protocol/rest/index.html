<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../../../img/favicon.ico">
  <title>rest:// - Dubbo 3.0.0</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "rest://";
    var mkdocs_page_input_path = "user/references/protocol/rest.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../../../.." class="icon icon-home"> Dubbo 3.0.0</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <span class="caption-text">用户手册</span>
    <ul class="subnav">
                <li class="">
                    
    <span class="caption-text">入门</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../../preface/background/">背景</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../preface/background/">需求</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../preface/architecture/">架构</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../preface/usage/">用法</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../../../quick-start/">快速启动</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../dependencies/">依赖</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../maturity/">成熟度</a>
                </li>
                <li class="">
                    
    <span class="caption-text">配置</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../../configuration/xml/">XML 配置</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../configuration/api/">API 配置</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../configuration/annotation/">Annotation 配置</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../configuration/annotation/">动态配置中心</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../configuration/configuration-load-process/">配置加载流程</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../configuration/environment-variables/">自动加载环境变量</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">示例</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/preflight-check/">启动时检查</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/fault-tolerent-strategy/">集群容错</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/loadbalance/">负载均衡</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/thread-model/">线程模型</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/explicit-target/">直连提供者</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/subscribe-only/">只订阅</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/registry-only/">只注册</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/static-service/">静态服务</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/multi-protocols/">多协议</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/multi-registry/">多注册中心</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/service-group/">服务分组</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/multi-versions/">多版本</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/group-merger/">分组聚合</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/parameter-validation/">参数验证</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/result-cache/">结果缓存</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/generic-reference/">泛化引用</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/generic-service/">泛化实现</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/echo-service/">回声测试</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/context/">上下文信息</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/attachment/">隐式参数</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/async-call/">异步调用</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/async-execute-on-provider/">服务端异步</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/local-call/">本地调用</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/callback-parameter/">参数回调</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/events-notify/">事件通知</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/local-stub/">本地存根</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/local-mock/">本地伪装</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/delay-publish/">延迟暴露</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/concurrency-control/">并发控制</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/config-connection.md">连接控制</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/lazy-connect/">延迟连接</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/stickiness/">粘滞连接</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/token-authorization/">令牌验证</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/routing-rule/">路由规则</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/config-rule/">配置规则</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/service-downgrade/">服务降级</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/graceful-shutdown/">优雅停机</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/hostname-binding/">主机绑定</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/logger-strategy/">日志适配</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/accesslog/">访问日志</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/service-container/">服务容器</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/distributed-transaction/">分布式事务</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/dump/">线程栈自动dump</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/netty4/">Netty4</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/serialization/">Kryo和FST序列化</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/simplify-registry-data/">简化注册中心URL</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../demos/api.md">API 参考手册</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">schema 配置参考手册</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../xml/dubbo-service/">dubbo:service</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../xml/dubbo-reference/">dubbo:reference</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../xml/dubbo-protocol/">dubbo:protocol</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../xml/dubbo-registry/">dubbo:registry</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../xml/dubbo-monitor/">dubbo:monitor</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../xml/dubbo-application/">dubbo:application</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../xml/dubbo-module/">dubbo:module</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../xml/dubbo-provider/">dubbo:provider</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../xml/dubbo-consumer/">dubbo:consumer</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../xml/dubbo-method/">dubbo:method</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../xml/dubbo-argument/">dubbo:argument</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../xml/dubbo-parameter/">dubbo:parameter</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../xml/dubbo-config-center/">dubbo:config-center</a>
                </li>
    </ul>
                </li>
                <li class=" current">
                    
    <span class="caption-text">协议参考手册</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../dubbo/">dubbo://</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../rmi/">rmi://</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../hessian/">hessian://</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../http/">http://</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../thrift/">thrift://</a>
                </li>
                <li class="toctree-l3 current">
                    
    <a class="current" href="./">rest://</a>
    <ul class="subnav">
            
    <li class="toctree-l4"><a href="#rest">rest://</a></li>
    
        <ul>
        
            <li><a class="toctree-l5" href="#_1">快速入门</a></li>
        
        </ul>
    

    </ul>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">注册中心参考手册</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../registry/multicast/">Multicast 注册中心</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../registry/zookeeper/">Zookeeper 注册中心</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../registry/redis/">Redis 注册中心</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../registry/simple/">Simple 注册中心</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">元数据中心参考手册</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../metadata/metadata-redis/">Redis 元数据中心</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../registry/metadata-zookeeper.md">Zookeeper 元数据中心</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../../telnet/">telnet 命令参考手册</a>
                </li>
                <li class="">
                    
    <a class="" href="../../qos/">在线运维命令-QOS</a>
                </li>
                <li class="">
                    
    <a class="" href="../../maven/">maven 插件参考手册</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../best-practice/">服务化最佳实践</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../recommend/">推荐用法</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../capacity-plan/">容量规划</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../perf-test/">性能测试报告</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../covergence.md">测试覆盖率报告</a>
                </li>
                <li class="">
                    
    <span class="caption-text">版本与升级</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../../version-270.md">2.7.x升级步骤及注意事项</a>
                </li>
    </ul>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">开发手册</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../../../dev/build/">源码构建</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../../dev/design/">框架设计</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../../dev/SPI/">扩展点加载</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../../dev/implementation/">实现细节</a>
                </li>
                <li class="">
                    
    <span class="caption-text">SPI 扩展实现</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/protocol/">协议扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/filter/">调用拦截扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/invoker-listener/">引用监听扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/exporter-listener/">暴露监听扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/cluster/">集群扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/router/">路由扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/load-balance/">负载均衡扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/merger/">合并结果扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/registry/">注册中心扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/monitor/">监控中心扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/extension-factory/">扩展点加载扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/proxy-factory/">动态代理扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/compiler/">编译器扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/dispatcher/">消息派发扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/threadpool/">线程池扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/serialize/">序列化扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/remoting/">网络传输扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/exchanger/">信息交换扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/networker/">组网扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/telnet-handler/">Telnet 命令扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/status-checker/">状态检查扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/container/">容器扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/page/">页面扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/cache/">缓存扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/validation/">验证扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/logger-adapter/">日志适配扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/impls/config-center/">配置中心</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../../../../dev/contract/">公共契约</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../../dev/coding/">编码约定</a>
                </li>
                <li class="">
                    
    <span class="caption-text">设计原则</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/principals/code-detail/">魔鬼在细节</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/principals/general-knowledge/">一些设计上的基本常识</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/principals/expansibility/">谈谈扩充式扩展与增量式扩展</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/principals/configuration/">配置设计</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/principals/robustness/">设计实现的健壮性</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/principals/dummy/">防痴呆设计</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../../dev/principals/extension/">扩展点重构</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../../../../dev/release/">版本发布</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../../dev/contribution/">贡献代码</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../../dev/checklist/">检查列表</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../../dev/code-smell/">坏味道</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../../dev/TCK/">兼容性测试</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">管理者文档</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../../../dev/introduction/">Dubbo Admin介绍</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../../dev/serviceSearch.md">服务搜索和详情</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../../dev/serviceGovernance.md">服务治理</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../../dev/serviceTest.md">服务测试</a>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../..">Dubbo 3.0.0</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../..">Docs</a> &raquo;</li>
    
      
        
          <li>协议参考手册 &raquo;</li>
        
      
        
          <li>用户手册 &raquo;</li>
        
      
    
    <li>rest://</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/documentations/3.0/zh-cn/docs/user/references/protocol/rest.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="rest">rest://</h1>
<p>基于标准的Java REST API——JAX-RS 2.0（Java API for RESTful Web Services的简写）实现的REST调用支持</p>
<h2 id="_1">快速入门</h2>
<p>在dubbo中开发一个REST风格的服务会比较简单，下面以一个注册用户的简单服务为例说明。</p>
<p>这个服务要实现的功能是提供如下URL（注：这个URL不是完全符合REST的风格，但是更简单实用）：</p>
<pre><code>http://localhost:8080/users/register
</code></pre>

<p>而任何客户端都可以将包含用户信息的JSON字符串POST到以上URL来完成用户注册。</p>
<p>首先，开发服务的接口：</p>
<pre><code class="java">public interface UserService {    
   void registerUser(User user);
}
</code></pre>

<p>然后，开发服务的实现：</p>
<pre><code class="java">@Path(&quot;/users&quot;)
public class UserServiceImpl implements UserService {

    @POST
    @Path(&quot;/register&quot;)
    @Consumes({MediaType.APPLICATION_JSON})
    public void registerUser(User user) {
        // save the user...
    }
}
</code></pre>

<p>上面的实现非常简单，但是由于该 REST 服务是要发布到指定 URL 上，供任意语言的客户端甚至浏览器来访问，所以这里额外添加了几个 JAX-RS 的标准 annotation 来做相关的配置。</p>
<p>@Path("/users")：指定访问UserService的URL相对路径是/users，即http://localhost:8080/users</p>
<p>@Path("/register")：指定访问registerUser()方法的URL相对路径是/register，再结合上一个@Path为UserService指定的路径，则调用UserService.register()的完整路径为http://localhost:8080/users/register</p>
<p>@POST：指定访问registerUser()用HTTP POST方法</p>
<p>@Consumes({MediaType.APPLICATION_JSON})：指定registerUser()接收JSON格式的数据。REST框架会自动将JSON数据反序列化为User对象</p>
<p>最后，在spring配置文件中添加此服务，即完成所有服务开发工作：</p>
<p>```xml
<!-- 用rest协议在8080端口暴露服务 -->
<dubbo:protocol name="rest" port="8080"/></p>
<!-- 声明需要暴露的服务接口 -->

<p><dubbo:service interface="xxx.UserService" ref="userService"/></p>
<!-- 和本地bean一样实现服务 -->

<p><bean id="userService" class="xxx.UserServiceImpl" /></p>
<pre><code>
## REST服务提供端详解

下面我们扩充“快速入门”中的UserService，进一步展示在dubbo中REST服务提供端的开发要点。

### HTTP POST/GET的实现

REST服务中虽然建议使用HTTP协议中四种标准方法POST、DELETE、PUT、GET来分别实现常见的“增删改查”，但实际中，我们一般情况直接用POST来实现“增改”，GET来实现“删查”即可（DELETE和PUT甚至会被一些防火墙阻挡）。

前面已经简单演示了POST的实现，在此，我们为UserService添加一个获取注册用户资料的功能，来演示GET的实现。

这个功能就是要实现客户端通过访问如下不同URL来获取不同ID的用户资料：

</code></pre>

<p>http://localhost:8080/users/1001
http://localhost:8080/users/1002
http://localhost:8080/users/1003</p>
<pre><code>
当然，也可以通过其他形式的URL来访问不同ID的用户资料，例如：

</code></pre>

<p>http://localhost:8080/users/load?id=1001</p>
<pre><code>
JAX-RS本身可以支持所有这些形式。但是上面那种在URL路径中包含查询参数的形式（http://localhost:8080/users/1001） 更符合REST的一般习惯，所以更推荐大家来使用。下面我们就为UserService添加一个getUser()方法来实现这种形式的URL访问：

```java
@GET
@Path(&quot;/{id : \\d+}&quot;)
@Produces({MediaType.APPLICATION_JSON})
public User getUser(@PathParam(&quot;id&quot;) Long id) {
    // ...
}
</code></pre>

<p>@GET：指定用HTTP GET方法访问</p>
<p>@Path("/{id : \d+}")：根据上面的功能需求，访问getUser()的URL应当是“http://localhost:8080/users/ + 任意数字"，并且这个数字要被做为参数传入getUser()方法。 这里的annotation配置中，@Path中间的{id: xxx}指定URL相对路径中包含了名为id参数，而它的值也将被自动传递给下面用@PathParam("id")修饰的方法参数id。{id:后面紧跟的\d+是一个正则表达式，指定了id参数必须是数字。</p>
<p>@Produces({MediaType.APPLICATION_JSON})：指定getUser()输出JSON格式的数据。框架会自动将User对象序列化为JSON数据。</p>
<h3 id="annotation">Annotation放在接口类还是实现类</h3>
<p>在Dubbo中开发REST服务主要都是通过JAX-RS的annotation来完成配置的，在上面的示例中，我们都是将annotation放在服务的实现类中。但其实，我们完全也可以将annotation放到服务的接口上，这两种方式是完全等价的，例如：</p>
<pre><code class="java">@Path(&quot;/users&quot;)
public interface UserService {

    @GET
    @Path(&quot;/{id : \\d+}&quot;)
    @Produces({MediaType.APPLICATION_JSON})
    User getUser(@PathParam(&quot;id&quot;) Long id);
}
</code></pre>

<p>在一般应用中，我们建议将annotation放到服务实现类，这样annotation和java实现代码位置更接近，更便于开发和维护。另外更重要的是，我们一般倾向于避免对接口的污染，保持接口的纯净性和广泛适用性。</p>
<p>但是，如后文所述，如果我们要用dubbo直接开发的消费端来访问此服务，则annotation必须放到接口上。</p>
<p>如果接口和实现类都同时添加了annotation，则实现类的annotation配置会生效，接口上的annotation被直接忽略。</p>
<h3 id="jsonxml">JSON、XML等多数据格式的支持</h3>
<p>在dubbo中开发的REST服务可以同时支持传输多种格式的数据，以给客户端提供最大的灵活性。其中我们目前对最常用的JSON和XML格式特别添加了额外的功能。</p>
<p>比如，我们要让上例中的getUser()方法支持分别返回JSON和XML格式的数据，只需要在annotation中同时包含两种格式即可：</p>
<pre><code class="java">@Produces({MediaType.APPLICATION_JSON, MediaType.TEXT_XML})
User getUser(@PathParam(&quot;id&quot;) Long id);
</code></pre>

<p>或者也可以直接用字符串（还支持通配符）表示MediaType： </p>
<pre><code class="java">@Produces({&quot;application/json&quot;, &quot;text/xml&quot;})
User getUser(@PathParam(&quot;id&quot;) Long id);
</code></pre>

<p>如果所有方法都支持同样类型的输入输出数据格式，则我们无需在每个方法上做配置，只需要在服务类上添加annotation即可：</p>
<pre><code class="java">@Path(&quot;/users&quot;)
@Consumes({MediaType.APPLICATION_JSON, MediaType.TEXT_XML})
@Produces({MediaType.APPLICATION_JSON, MediaType.TEXT_XML})
public class UserServiceImpl implements UserService {
    // ...
}

</code></pre>

<p>在一个REST服务同时对多种数据格式支持的情况下，根据JAX-RS标准，一般是通过HTTP中的MIME header（content-type和accept）来指定当前想用的是哪种格式的数据。</p>
<p>但是在dubbo中，我们还自动支持目前业界普遍使用的方式，即用一个URL后缀（.json和.xml）来指定想用的数据格式。例如，在添加上述annotation后，直接访问http://localhost:8888/users/1001.json则表示用json格式，直接访问http://localhost:8888/users/1002.xml则表示用xml格式，比用HTTP Header更简单直观。Twitter、微博等的REST API都是采用这种方式。</p>
<p>如果你既不加HTTP header，也不加后缀，则dubbo的REST会优先启用在以上annotation定义中排位最靠前的那种数据格式。</p>
<blockquote>
<p>注意：这里要支持XML格式数据，在annotation中既可以用MediaType.TEXT_XML，也可以用MediaType.APPLICATION_XML，但是TEXT_XML是更常用的，并且如果要利用上述的URL后缀方式来指定数据格式，只能配置为TEXT_XML才能生效。</p>
</blockquote>
<h3 id="_2">中文字符支持</h3>
<p>为了在dubbo REST中正常输出中文字符，和通常的Java web应用一样，我们需要将HTTP响应的contentType设置为UTF-8编码。</p>
<p>基于JAX-RS的标准用法，我们只需要做如下annotation配置即可：</p>
<pre><code class="java">@Produces({&quot;application/json; charset=UTF-8&quot;, &quot;text/xml; charset=UTF-8&quot;})
User getUser(@PathParam(&quot;id&quot;) Long id);
</code></pre>

<p>为了方便用户，我们在dubbo REST中直接添加了一个支持类，来定义以上的常量，可以直接使用，减少出错的可能性。</p>
<pre><code class="java">@Produces({ContentType.APPLICATION_JSON_UTF_8, ContentType.TEXT_XML_UTF_8})
User getUser(@PathParam(&quot;id&quot;) Long id);
</code></pre>

<h3 id="xml">XML数据格式的额外要求</h3>
<p>由于JAX-RS的实现一般都用标准的JAXB（Java API for XML Binding）来序列化和反序列化XML格式数据，所以我们需要为每一个要用XML传输的对象添加一个类级别的JAXB annotation，否则序列化将报错。例如为getUser()中返回的User添加如下：</p>
<pre><code class="java">@XmlRootElement
public class User implements Serializable {
    // ...
}
</code></pre>

<p>此外，如果service方法中的返回值是Java的 primitive类型（如int，long，float，double等），最好为它们添加一层wrapper对象，因为JAXB不能直接序列化primitive类型。</p>
<p>例如，我们想让前述的registerUser()方法返回服务器端为用户生成的ID号：</p>
<pre><code class="java">long registerUser(User user);
</code></pre>

<p>由于primitive类型不被JAXB序列化支持，所以添加一个wrapper对象：</p>
<pre><code class="java">@XmlRootElement
public class RegistrationResult implements Serializable {

    private Long id;

    public RegistrationResult() {
    }

    public RegistrationResult(Long id) {
        this.id = id;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }
}
</code></pre>

<p>并修改service方法：</p>
<pre><code class="java">RegistrationResult registerUser(User user);
</code></pre>

<p>这样不但能够解决XML序列化的问题，而且使得返回的数据都符合XML和JSON的规范。例如，在JSON中，返回的将是如下形式：</p>
<pre><code class="javascript">{&quot;id&quot;: 1001}
</code></pre>

<p>如果不加wrapper，JSON返回值将直接是</p>
<pre><code>1001    
</code></pre>

<p>而在XML中，加wrapper后返回值将是：</p>
<pre><code class="xml">&lt;registrationResult&gt;
    &lt;id&gt;1002&lt;/id&gt;
&lt;/registrationResult&gt;
</code></pre>

<p>这种wrapper对象其实利用所谓Data Transfer Object（DTO）模式，采用DTO还能对传输数据做更多有用的定制。  </p>
<h3 id="_3">定制序列化</h3>
<p>如上所述，REST的底层实现会在service的对象和JSON/XML数据格式之间自动做序列化/反序列化。但有些场景下，如果觉得这种自动转换不满足要求，可以对其做定制。</p>
<p>Dubbo中的REST实现是用JAXB做XML序列化，用Jackson做JSON序列化，所以在对象上添加JAXB或Jackson的annotation即可以定制映射。</p>
<p>例如，定制对象属性映射到XML元素的名字：</p>
<pre><code class="java">@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class User implements Serializable {

    @XmlElement(name=&quot;username&quot;) 
    private String name;  
}
</code></pre>

<p>定制对象属性映射到JSON字段的名字：</p>
<pre><code class="java">public class User implements Serializable {

    @JsonProperty(&quot;username&quot;)
    private String name;
}
</code></pre>

<p>更多资料请参考JAXB和Jackson的官方文档，或自行google。</p>
<h3 id="rest-server">配置REST Server的实现</h3>
<p>目前在dubbo中，我们支持5种嵌入式rest server的实现，并同时支持采用外部应用服务器来做rest server的实现。rest server可以通过如下配置实现：</p>
<pre><code class="xml">&lt;dubbo:protocol name=&quot;rest&quot; server=&quot;jetty&quot;/&gt;
</code></pre>

<p>以上配置选用了嵌入式的jetty来做rest server，同时，如果不配置server属性，rest协议默认也是选用jetty。jetty是非常成熟的java servlet容器，并和dubbo已经有较好的集成（目前5种嵌入式server中只有jetty和后面所述的tomcat、tjws，与dubbo监控系统等完成了无缝的集成），所以，如果你的dubbo系统是单独启动的进程，你可以直接默认采用jetty即可。</p>
<pre><code class="xml">&lt;dubbo:protocol name=&quot;rest&quot; server=&quot;tomcat&quot;/&gt;
</code></pre>

<p>以上配置选用了嵌入式的tomcat来做rest server。在嵌入式tomcat上，REST的性能比jetty上要好得多（参见后面的基准测试），建议在需要高性能的场景下采用tomcat。</p>
<pre><code class="xml">&lt;dubbo:protocol name=&quot;rest&quot; server=&quot;netty&quot;/&gt;
</code></pre>

<p>以上配置选用嵌入式的netty来做rest server。（TODO more contents to add）</p>
<pre><code class="xml">&lt;dubbo:protocol name=&quot;rest&quot; server=&quot;tjws&quot;/&gt; (tjws is now deprecated)
&lt;dubbo:protocol name=&quot;rest&quot; server=&quot;sunhttp&quot;/&gt;
</code></pre>

<p>以上配置选用嵌入式的tjws或Sun HTTP server来做rest server。这两个server实现非常轻量级，非常方便在集成测试中快速启动使用，当然也可以在负荷不高的生产环境中使用。   注：tjws目前已经被deprecated掉了，因为它不能很好的和servlet 3.1 API工作。</p>
<p>如果你的dubbo系统不是单独启动的进程，而是部署到了Java应用服务器中，则建议你采用以下配置：</p>
<pre><code class="xml">&lt;dubbo:protocol name=&quot;rest&quot; server=&quot;servlet&quot;/&gt;
</code></pre>

<p>通过将server设置为servlet，dubbo将采用外部应用服务器的servlet容器来做rest server。同时，还要在dubbo系统的web.xml中添加如下配置：</p>
<pre><code class="xml">&lt;web-app&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/classes/META-INF/spring/dubbo-demo-provider.xml&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;org.apache.dubbo.remoting.http.servlet.BootstrapListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.apache.dubbo.remoting.http.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>

<p>即必须将dubbo的BootstrapListener和DispatherServlet添加到web.xml，以完成dubbo的REST功能与外部servlet容器的集成。</p>
<blockquote>
<p>注意：如果你是用spring的ContextLoaderListener来加载spring，则必须保证BootstrapListener配置在ContextLoaderListener之前，否则dubbo初始化会出错。</p>
</blockquote>
<p>其实，这种场景下你依然可以坚持用嵌入式server，但外部应用服务器的servlet容器往往比嵌入式server更加强大（特别是如果你是部署到更健壮更可伸缩的WebLogic，WebSphere等），另外有时也便于在应用服务器做统一管理、监控等等。</p>
<h3 id="context">获取上下文（Context）信息</h3>
<p>在远程调用中，值得获取的上下文信息可能有很多种，这里特别以获取客户端IP为例。</p>
<p>在dubbo的REST中，我们有两种方式获取客户端IP。</p>
<p>第一种方式，用JAX-RS标准的@Context annotation：</p>
<pre><code class="java">public User getUser(@PathParam(&quot;id&quot;) Long id, @Context HttpServletRequest request) {
    System.out.println(&quot;Client address is &quot; + request.getRemoteAddr());
} 
</code></pre>

<p>用Context修饰getUser()的一个方法参数后，就可以将当前的HttpServletRequest注入进来，然后直接调用servlet api获取IP。</p>
<blockquote>
<p>注意：这种方式只能在将server设置为 tjws、tomcat、jetty 或者 servlet 的时候才能工作，因为只有这几种 server 的实现才提供了 servlet 容器。另外，标准的JAX-RS还支持用@Context修饰service类的一个实例字段来获取HttpServletRequest，但在dubbo中我们没有对此作出支持。</p>
</blockquote>
<p>第二种方式，用dubbo中常用的RpcContext：</p>
<pre><code class="java">public User getUser(@PathParam(&quot;id&quot;) Long id) {
    System.out.println(&quot;Client address is &quot; + RpcContext.getContext().getRemoteAddressString());
} 
</code></pre>

<blockquote>
<p>注意：这种方式只能在设置server="jetty"或者server="tomcat"或者server="servlet"或者server="tjws"的时候才能工作。另外，目前dubbo的RpcContext是一种比较有侵入性的用法，未来我们很可能会做出重构。</p>
</blockquote>
<p>如果你想保持你的项目对JAX-RS的兼容性，未来脱离dubbo也可以运行，请选择第一种方式。如果你想要更优雅的服务接口定义，请选用第二种方式。</p>
<p>此外，在最新的dubbo rest中，还支持通过RpcContext来获取HttpServletRequest和HttpServletResponse，以提供更大的灵活性来方便用户实现某些复杂功能，比如在dubbo标准的filter中访问HTTP Header。用法示例如下：</p>
<pre><code class="java">if (RpcContext.getContext().getRequest() != null &amp;&amp; RpcContext.getContext().getRequest() instanceof HttpServletRequest) {
    System.out.println(&quot;Client address is &quot; + ((HttpServletRequest) RpcContext.getContext().getRequest()).getRemoteAddr());
}

if (RpcContext.getContext().getResponse() != null &amp;&amp; RpcContext.getContext().getResponse() instanceof HttpServletResponse) {
    System.out.println(&quot;Response object from RpcContext: &quot; + RpcContext.getContext().getResponse());
}
</code></pre>

<blockquote>
<p>注意：为了保持协议的中立性，RpcContext.getRequest()和RpcContext.getResponse()返回的仅仅是一个Object类，而且可能为null。所以，你必须自己做null和类型的检查。</p>
<p>注意：只有在设置server="jetty"或者server="tomcat"或者server="servlet"的时候，你才能通过以上方法正确的得到HttpServletRequest和HttpServletResponse，因为只有这几种server实现了servlet容器。</p>
</blockquote>
<p>为了简化编程，在此你也可以用泛型的方式来直接获取特定类型的request/response：</p>
<pre><code class="java">if (RpcContext.getContext().getRequest(HttpServletRequest.class) != null) {
    System.out.println(&quot;Client address is &quot; + RpcContext.getContext().getRequest(HttpServletRequest.class).getRemoteAddr());
}

if (RpcContext.getContext().getResponse(HttpServletResponse.class) != null) {
    System.out.println(&quot;Response object from RpcContext: &quot; + RpcContext.getContext().getResponse(HttpServletResponse.class));
}
</code></pre>

<p>如果request/response不符合指定的类型，这里也会返回null。</p>
<h3 id="context-path">配置端口号和Context Path</h3>
<p>dubbo中的rest协议默认将采用80端口，如果想修改端口，直接配置：</p>
<pre><code class="xml">&lt;dubbo:protocol name=&quot;rest&quot; port=&quot;8888&quot;/&gt;
</code></pre>

<p>另外，如前所述，我们可以用@Path来配置单个rest服务的URL相对路径。但其实，我们还可以设置一个所有rest服务都适用的基础相对路径，即java web应用中常说的context path。</p>
<p>只需要添加如下contextpath属性即可：</p>
<pre><code class="xml">&lt;dubbo:protocol name=&quot;rest&quot; port=&quot;8888&quot; contextpath=&quot;services&quot;/&gt;
</code></pre>

<p>以前面代码为例：</p>
<pre><code class="java">@Path(&quot;/users&quot;)
public class UserServiceImpl implements UserService {

    @POST
    @Path(&quot;/register&quot;)
    @Consumes({MediaType.APPLICATION_JSON})
    public void registerUser(User user) {
        // save the user...
    }   
}
</code></pre>

<p>现在registerUser()的完整访问路径为：</p>
<pre><code>http://localhost:8888/services/users/register
</code></pre>

<p>注意：如果你是选用外部应用服务器做rest server，即配置:</p>
<pre><code class="xml">&lt;dubbo:protocol name=&quot;rest&quot; port=&quot;8888&quot; contextpath=&quot;services&quot; server=&quot;servlet&quot;/&gt;
</code></pre>

<p>则必须保证这里设置的port、contextpath，与外部应用服务器的端口、DispatcherServlet的上下文路径（即webapp path加上servlet url pattern）保持一致。例如，对于部署为tomcat ROOT路径的应用，这里的contextpath必须与web.xml中DispacherServlet的<code>&lt;url-pattern/&gt;</code>完全一致：</p>
<pre><code class="xml">&lt;servlet-mapping&gt;
     &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
     &lt;url-pattern&gt;/services/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>

<h3 id="io">配置线程数和IO线程数</h3>
<p>可以为rest服务配置线程池大小：</p>
<pre><code class="xml">&lt;dubbo:protocol name=&quot;rest&quot; threads=&quot;500&quot;/&gt;
</code></pre>

<blockquote>
<p>注意：目前线程池的设置只有当server="netty"或者server="jetty"或者server="tomcat"的时候才能生效。另外，如果server="servlet"，由于这时候启用的是外部应用服务器做rest server，不受dubbo控制，所以这里的线程池设置也无效。</p>
</blockquote>
<p>如果是选用netty server，还可以配置Netty的IO worker线程数：</p>
<pre><code class="xml">&lt;dubbo:protocol name=&quot;rest&quot; iothreads=&quot;5&quot; threads=&quot;100&quot;/&gt;
</code></pre>

<h3 id="_4">配置长连接</h3>
<p>Dubbo中的rest服务默认都是采用http长连接来访问，如果想切换为短连接，直接配置：</p>
<pre><code class="xml">&lt;dubbo:protocol name=&quot;rest&quot; keepalive=&quot;false&quot;/&gt;
</code></pre>

<blockquote>
<p>注意：这个配置目前只对server="netty"和server="tomcat"才能生效。</p>
</blockquote>
<h3 id="http">配置最大的HTTP连接数</h3>
<p>可以配置服务器提供端所能同时接收的最大HTTP连接数，防止REST server被过多连接撑爆，以作为一种最基本的自我保护机制：</p>
<pre><code class="xml">&lt;dubbo:protocol name=&quot;rest&quot; accepts=&quot;500&quot; server=&quot;tomcat/&gt;
</code></pre>

<blockquote>
<p>注意：这个配置目前只对server="tomcat"才能生效。</p>
</blockquote>
<h3 id="http_1">配置每个消费端的超时时间和HTTP连接数</h3>
<p>如果rest服务的消费端也是dubbo系统，可以像其他dubbo RPC机制一样，配置消费端调用此rest服务的最大超时时间以及每个消费端所能启动的最大HTTP连接数。</p>
<pre><code class="xml">&lt;dubbo:service interface=&quot;xxx&quot; ref=&quot;xxx&quot; protocol=&quot;rest&quot; timeout=&quot;2000&quot; connections=&quot;10&quot;/&gt;
</code></pre>

<p>当然，由于这个配置针对消费端生效的，所以也可以在消费端配置：</p>
<pre><code class="xml">&lt;dubbo:reference id=&quot;xxx&quot; interface=&quot;xxx&quot; timeout=&quot;2000&quot; connections=&quot;10&quot;/&gt;
</code></pre>

<p>但是，通常我们建议配置在服务提供端提供此类配置。按照dubbo官方文档的说法：“Provider上尽量多配置Consumer端的属性，让Provider实现者一开始就思考Provider服务特点、服务质量的问题。”</p>
<blockquote>
<p>注意：如果dubbo的REST服务是发布给非dubbo的客户端使用，则这里<code>&lt;dubbo:service/&gt;</code>上的配置完全无效，因为这种客户端不受dubbo控制。</p>
</blockquote>
<h3 id="annotationspring-xml">用Annotation取代部分Spring XML配置</h3>
<p>以上所有的讨论都是基于dubbo在spring中的xml配置。但是，dubbo/spring本身也支持用annotation来作配置，所以我们也可以按dubbo官方文档中的步骤，把相关annotation加到REST服务的实现中，取代一些xml配置，例如：</p>
<pre><code class="java">@Service(protocol = &quot;rest&quot;)
@Path(&quot;/users&quot;)
public class UserServiceImpl implements UserService {

    @Autowired
    private UserRepository userRepository;

    @POST
    @Path(&quot;/register&quot;)
    @Consumes({MediaType.APPLICATION_JSON})
    public void registerUser(User user) {
        // save the user
        userRepository.save(user);
    }   
}
</code></pre>

<p>annotation的配置更简单更精确，通常也更便于维护（当然现代IDE都可以在xml中支持比如类名重构，所以就这里的特定用例而言，xml的维护性也很好）。而xml对代码的侵入性更小一些，尤其有利于动态修改配置，特别是比如你要针对单个服务配置连接超时时间、每客户端最大连接数、集群策略、权重等等。另外，特别对复杂应用或者模块来说，xml提供了一个中心点来涵盖的所有组件和配置，更一目了然，一般更便于项目长时期的维护。</p>
<p>当然，选择哪种配置方式没有绝对的优劣，和个人的偏好也不无关系。</p>
<h3 id="filterinterceptor">添加自定义的Filter、Interceptor等</h3>
<p>Dubbo的REST也支持JAX-RS标准的Filter和Interceptor，以方便对REST的请求与响应过程做定制化的拦截处理。</p>
<p>其中，Filter主要用于访问和设置HTTP请求和响应的参数、URI等等。例如，设置HTTP响应的cache header：</p>
<pre><code class="java">public class CacheControlFilter implements ContainerResponseFilter {

    public void filter(ContainerRequestContext req, ContainerResponseContext res) {
        if (req.getMethod().equals(&quot;GET&quot;)) {
            res.getHeaders().add(&quot;Cache-Control&quot;, &quot;someValue&quot;);
        }
    }
}
</code></pre>

<p>Interceptor主要用于访问和修改输入与输出字节流，例如，手动添加GZIP压缩：</p>
<pre><code class="java">public class GZIPWriterInterceptor implements WriterInterceptor {

    @Override
    public void aroundWriteTo(WriterInterceptorContext context)
                    throws IOException, WebApplicationException {
        OutputStream outputStream = context.getOutputStream();
        context.setOutputStream(new GZIPOutputStream(outputStream));
        context.proceed();
    }
}
</code></pre>

<p>在标准JAX-RS应用中，我们一般是为Filter和Interceptor添加@Provider annotation，然后JAX-RS runtime会自动发现并启用它们。而在dubbo中，我们是通过添加XML配置的方式来注册Filter和Interceptor：</p>
<pre><code class="xml">&lt;dubbo:protocol name=&quot;rest&quot; port=&quot;8888&quot; extension=&quot;xxx.TraceInterceptor, xxx.TraceFilter&quot;/&gt;
</code></pre>

<p>在此，我们可以将Filter、Interceptor和DynamicFeature这三种类型的对象都添加到<code>extension</code>属性上，多个之间用逗号分隔。（DynamicFeature是另一个接口，可以方便我们更动态的启用Filter和Interceptor，感兴趣请自行google。）</p>
<p>当然，dubbo自身也支持Filter的概念，但我们这里讨论的Filter和Interceptor更加接近协议实现的底层，相比dubbo的filter，可以做更底层的定制化。</p>
<blockquote>
<p>注：这里的XML属性叫extension，而不是叫interceptor或者filter，是因为除了Interceptor和Filter，未来我们还会添加更多的扩展类型。</p>
</blockquote>
<p>如果REST的消费端也是dubbo系统（参见下文的讨论），则也可以用类似方式为消费端配置Interceptor和Filter。但注意，JAX-RS中消费端的Filter和提供端的Filter是两种不同的接口。例如前面例子中服务端是ContainerResponseFilter接口，而消费端对应的是ClientResponseFilter:</p>
<pre><code class="java">public class LoggingFilter implements ClientResponseFilter {

    public void filter(ClientRequestContext reqCtx, ClientResponseContext resCtx) throws IOException {
        System.out.println(&quot;status: &quot; + resCtx.getStatus());
        System.out.println(&quot;date: &quot; + resCtx.getDate());
        System.out.println(&quot;last-modified: &quot; + resCtx.getLastModified());
        System.out.println(&quot;location: &quot; + resCtx.getLocation());
        System.out.println(&quot;headers:&quot;);
        for (Entry&lt;String, List&lt;String&gt;&gt; header : resCtx.getHeaders().entrySet()) {
            System.out.print(&quot;\t&quot; + header.getKey() + &quot; :&quot;);
            for (String value : header.getValue()) {
                System.out.print(value + &quot;, &quot;);
            }
            System.out.print(&quot;\n&quot;);
        }
        System.out.println(&quot;media-type: &quot; + resCtx.getMediaType().getType());
    } 
}
</code></pre>

<h3 id="exception">添加自定义的Exception处理</h3>
<p>Dubbo的REST也支持JAX-RS标准的ExceptionMapper，可以用来定制特定exception发生后应该返回的HTTP响应。</p>
<pre><code class="java">public class CustomExceptionMapper implements ExceptionMapper&lt;NotFoundException&gt; {

    public Response toResponse(NotFoundException e) {     
        return Response.status(Response.Status.NOT_FOUND).entity(&quot;Oops! the requested resource is not found!&quot;).type(&quot;text/plain&quot;).build();
    }
}
</code></pre>

<p>和Interceptor、Filter类似，将其添加到XML配置文件中即可启用：</p>
<pre><code class="xml">&lt;dubbo:protocol name=&quot;rest&quot; port=&quot;8888&quot; extension=&quot;xxx.CustomExceptionMapper&quot;/&gt;
</code></pre>

<h3 id="http_2">配置HTTP日志输出</h3>
<p>Dubbo rest支持输出所有HTTP请求/响应中的header字段和body消息体。</p>
<p>在XML配置中添加如下自带的REST filter：</p>
<pre><code class="xml">&lt;dubbo:protocol name=&quot;rest&quot; port=&quot;8888&quot; extension=&quot;org.apache.dubbo.rpc.protocol.rest.support.LoggingFilter&quot;/&gt;
</code></pre>

<p>然后配置在logging配置中至少为org.apache.dubbo.rpc.protocol.rest.support打开INFO级别日志输出，例如，在log4j.xml中配置：</p>
<pre><code class="xml">&lt;logger name=&quot;org.apache.dubbo.rpc.protocol.rest.support&quot;&gt;
    &lt;level value=&quot;INFO&quot;/&gt;
    &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
&lt;/logger&gt;
</code></pre>

<p>当然，你也可以直接在ROOT logger打开INFO级别日志输出：</p>
<pre><code class="xml">&lt;root&gt;
    &lt;level value=&quot;INFO&quot; /&gt;
    &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
&lt;/root&gt;
</code></pre>

<p>然后在日志中会有类似如下的内容输出：</p>
<pre><code>The HTTP headers are: 
accept: application/json;charset=UTF-8
accept-encoding: gzip, deflate
connection: Keep-Alive
content-length: 22
content-type: application/json
host: 192.168.1.100:8888
user-agent: Apache-HttpClient/4.2.1 (java 1.5)
</code></pre>

<pre><code>The contents of request body is: 
{&quot;id&quot;:1,&quot;name&quot;:&quot;dang&quot;}
</code></pre>

<p>打开HTTP日志输出后，除了正常日志输出的性能开销外，也会在比如HTTP请求解析时产生额外的开销，因为需要建立额外的内存缓冲区来为日志的输出做数据准备。</p>
<h3 id="_5">输入参数的校验</h3>
<p>dubbo的rest支持采用Java标准的bean validation annotation（JSR 303)来做输入校验http://beanvalidation.org/</p>
<p>为了和其他dubbo远程调用协议保持一致，在rest中作校验的annotation必须放在服务的接口上，例如：</p>
<pre><code class="java">public interface UserService {

    User getUser(@Min(value=1L, message=&quot;User ID must be greater than 1&quot;) Long id);
}

</code></pre>

<p>当然，在很多其他的bean validation的应用场景都是将annotation放到实现类而不是接口上。把annotation放在接口上至少有一个好处是，dubbo的客户端可以共享这个接口的信息，dubbo甚至不需要做远程调用，在本地就可以完成输入校验。</p>
<p>然后按照dubbo的标准方式在XML配置中打开验证：</p>
<pre><code class="xml">&lt;dubbo:service interface=xxx.UserService&quot; ref=&quot;userService&quot; protocol=&quot;rest&quot; validation=&quot;true&quot;/&gt;
</code></pre>

<p>在dubbo的其他很多远程调用协议中，如果输入验证出错，是直接将<code>RpcException</code>抛向客户端，而在rest中由于客户端经常是非dubbo，甚至非java的系统，所以不便直接抛出Java异常。因此，目前我们将校验错误以XML的格式返回：</p>
<pre><code class="xml">&lt;violationReport&gt;
    &lt;constraintViolations&gt;
        &lt;path&gt;getUserArgument0&lt;/path&gt;
        &lt;message&gt;User ID must be greater than 1&lt;/message&gt;
        &lt;value&gt;0&lt;/value&gt;
    &lt;/constraintViolations&gt;
&lt;/violationReport&gt;
</code></pre>

<p>稍后也会支持其他数据格式的返回值。至于如何对验证错误消息作国际化处理，直接参考bean validation的相关文档即可。</p>
<p>如果你认为默认的校验错误返回格式不符合你的要求，可以如上面章节所述，添加自定义的ExceptionMapper来自由的定制错误返回格式。需要注意的是，这个ExceptionMapper必须用泛型声明来捕获dubbo的RpcException，才能成功覆盖dubbo rest默认的异常处理策略。为了简化操作，其实这里最简单的方式是直接继承dubbo rest的RpcExceptionMapper，并覆盖其中处理校验异常的方法即可：</p>
<pre><code class="java">public class MyValidationExceptionMapper extends RpcExceptionMapper {

    protected Response handleConstraintViolationException(ConstraintViolationException cve) {
        ViolationReport report = new ViolationReport();
        for (ConstraintViolation cv : cve.getConstraintViolations()) {
            report.addConstraintViolation(new RestConstraintViolation(
                    cv.getPropertyPath().toString(),
                    cv.getMessage(),
                    cv.getInvalidValue() == null ? &quot;null&quot; : cv.getInvalidValue().toString()));
        }
        // 采用json输出代替xml输出
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(report).type(ContentType.APPLICATION_JSON_UTF_8).build();
    }
}
</code></pre>

<p>然后将这个ExceptionMapper添加到XML配置中即可：</p>
<pre><code class="xml">&lt;dubbo:protocol name=&quot;rest&quot; port=&quot;8888&quot; extension=&quot;xxx.MyValidationExceptionMapper&quot;/&gt;
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../registry/multicast/" class="btn btn-neutral float-right" title="Multicast 注册中心">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../thrift/" class="btn btn-neutral" title="thrift://"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/apache/dubbo-website/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../thrift/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../../registry/multicast/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../../../..';</script>
    <script src="../../../../js/theme.js" defer></script>
      <script src="../../../../search/main.js" defer></script>

</body>
</html>
