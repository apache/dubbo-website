{
  "filename": "introduction-to-dubbo-spi-2.md",
  "__html": "<h1>Dubbo extensible mechanism source code analysis</h1>\n<p>In the <a href=\"./introduction-to-dubbo-spi.md\">actual implementation of the Dubbo extensibility mechanism</a>, we learned some concepts of the Dubbo extension mechanism, explored the implementation of LoadBalance in Dubbo, and implemented a LoadBalance on our own. Do you think Dubbo's extension mechanism is great? Next, we will go deep into the source code of Dubbo and see what it is.</p>\n<h2>ExtensionLoader</h2>\n<p><code>ExtensionLoader</code> is the core class, which is responsible for the loading and lifecycle management of extension points. Let's start with this class. There are many methods of Extension, and the common methods include:</p>\n<ul>\n<li><code>public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type)</code></li>\n<li><code>public T getExtension(String name)</code></li>\n<li><code>public T getAdaptiveExtension()</code></li>\n</ul>\n<p>The common usages are:</p>\n<ul>\n<li><code>LoadBalance lb = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(loadbalanceName)</code></li>\n<li><code>RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getAdaptiveExtension()</code></li>\n</ul>\n<p>Notice: In the source code shown below, I'll remove extraneous code (such as logging, exception catching, and so on) to make it easy to read and understand.</p>\n<ol>\n<li>getExtensionLoader\nThis is a static factory method that enters an extensible interface and returns an ExtensionLoader entity class for this interface. With this entity class, you can get not only a specific extension based on name, but also an adaptive extension.</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\">ExtensionLoader&lt;T&gt; <span class=\"hljs-title\">getExtensionLoader</span><span class=\"hljs-params\">(Class&lt;T&gt; type)</span> </span>{\n        <span class=\"hljs-comment\">// An extension point must be an interface</span>\n        <span class=\"hljs-keyword\">if</span> (!type.isInterface()) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"Extension type(\"</span> + type + <span class=\"hljs-string\">\") is not interface!\"</span>);\n        }\n        <span class=\"hljs-comment\">// @SPI annotations must be provided</span>\n        <span class=\"hljs-keyword\">if</span> (!withExtensionAnnotation(type)) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"Extension type without @SPI Annotation!\"</span>);\n        }\n        <span class=\"hljs-comment\">// Get the corresponding ExtensionLoader from the cache according to the interface</span>\n        <span class=\"hljs-comment\">// Each extension will only be loaded once</span>\n        ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);\n        <span class=\"hljs-keyword\">if</span> (loader == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-comment\">// Initialize extension</span>\n            EXTENSION_LOADERS.putIfAbsent(type, <span class=\"hljs-keyword\">new</span> ExtensionLoader&lt;T&gt;(type));\n            loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);\n        }\n        <span class=\"hljs-keyword\">return</span> loader;\n}\n    \n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">ExtensionLoader</span><span class=\"hljs-params\">(Class&lt;?&gt; type)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.type = type;\n        objectFactory = (type == ExtensionFactory.class ? <span class=\"hljs-keyword\">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());\n}\n</code></pre>\n<ol start=\"2\">\n<li>getExtension</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> T <span class=\"hljs-title\">getExtension</span><span class=\"hljs-params\">(String name)</span> </span>{\n        Holder&lt;Object&gt; holder = cachedInstances.get(name);\n        <span class=\"hljs-keyword\">if</span> (holder == <span class=\"hljs-keyword\">null</span>) {\n            cachedInstances.putIfAbsent(name, <span class=\"hljs-keyword\">new</span> Holder&lt;Object&gt;());\n            holder = cachedInstances.get(name);\n        }\n        Object instance = holder.get();\n        <span class=\"hljs-comment\">// Get it from the cache. If it does not exist, create</span>\n        <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">synchronized</span> (holder) {\n                instance = holder.get();\n                <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n                    instance = createExtension(name);\n                    holder.set(instance);\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> (T) instance;\n}\n</code></pre>\n<p>Some judgments and caching have been made in the getExtension method, and the main logic is in the createExtension method. Let's move on to the createExtension method.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> T <span class=\"hljs-title\">createExtension</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-comment\">// Get the extension class according to the name of extension point. For example,  for LoadBalance, get the RandomLoadBalance class according to random</span>\n        Class&lt;?&gt; clazz = getExtensionClasses().get(name);\n        \n        T instance = (T) EXTENSION_INSTANCES.get(clazz);\n        <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n              <span class=\"hljs-comment\">// Use reflection to call newInstance to create an example of an extension class</span>\n            EXTENSION_INSTANCES.putIfAbsent(clazz, (T) clazz.newInstance());\n            instance = (T) EXTENSION_INSTANCES.get(clazz);\n        }\n        <span class=\"hljs-comment\">// Make dependency injection for the extended class samples</span>\n        injectExtension(instance);\n        <span class=\"hljs-comment\">// If there is a wrapper, add the wrapper</span>\n        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;\n        <span class=\"hljs-keyword\">if</span> (wrapperClasses != <span class=\"hljs-keyword\">null</span> &amp;&amp; !wrapperClasses.isEmpty()) {\n            <span class=\"hljs-keyword\">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) {\n                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> instance;\n}\n</code></pre>\n<p>The createExtension method has done the following:</p>\n<ol>\n<li>First, get the corresponding extension class according to name. Read the extension point configuration file from the <code>META-INF</code> folder under ClassPath.</li>\n<li>Use reflection to create an instance of an extended class.</li>\n<li>make dependency injection for the attributes of the extended class instance. That is, IoC.</li>\n<li>If there is a wrapper, add the wrapper. That is, AOP.</li>\n</ol>\n<p>Let's focus on these four processes.</p>\n<ol>\n<li>Get the corresponding extension class according to name. Letâ€™s read the code first:</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() {\n        Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();\n        <span class=\"hljs-keyword\">if</span> (classes == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">synchronized</span> (cachedClasses) {\n                classes = cachedClasses.get();\n                <span class=\"hljs-keyword\">if</span> (classes == <span class=\"hljs-keyword\">null</span>) {\n                    classes = loadExtensionClasses();\n                    cachedClasses.set(classes);\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> classes;\n    }\n\n<span class=\"hljs-comment\">// synchronized in getExtensionClasses</span>\n<span class=\"hljs-keyword\">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() {\n        <span class=\"hljs-keyword\">final</span> SPI defaultAnnotation = type.getAnnotation(SPI.class);\n        <span class=\"hljs-keyword\">if</span> (defaultAnnotation != <span class=\"hljs-keyword\">null</span>) {\n            String value = defaultAnnotation.value();\n            <span class=\"hljs-keyword\">if</span> (value != <span class=\"hljs-keyword\">null</span> &amp;&amp; (value = value.trim()).length() &gt; <span class=\"hljs-number\">0</span>) {\n                String[] names = NAME_SEPARATOR.split(value);\n                <span class=\"hljs-keyword\">if</span> (names.length &gt; <span class=\"hljs-number\">1</span>) {\n                    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"more than 1 default extension name on extension \"</span> + type.getName());\n                }\n                <span class=\"hljs-keyword\">if</span> (names.length == <span class=\"hljs-number\">1</span>) cachedDefaultName = names[<span class=\"hljs-number\">0</span>];\n            }\n        }\n\n        Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();\n        loadFile(extensionClasses, DUBBO_INTERNAL_DIRECTORY);\n        loadFile(extensionClasses, DUBBO_DIRECTORY);\n        loadFile(extensionClasses, SERVICES_DIRECTORY);\n        <span class=\"hljs-keyword\">return</span> extensionClasses;\n}\n</code></pre>\n<p>This process is very simple. Get the extension class from the cache first, and if it does not exist, load it from the configuration file. The path of the configuration file has been mentioned before:</p>\n<ul>\n<li><code>META-INF/dubbo/internal</code></li>\n<li><code>META-INF/dubbo</code></li>\n<li><code>META-INF/services</code></li>\n</ul>\n<ol start=\"2\">\n<li>Use reflection to create an extended instance. This process is very simple. We can do this using <code>clazz.newInstance()</code>. The attributes of the extended instance created are all null values.</li>\n<li>Extended instance is automatic assembly. In the actual scenario, there have dependencies between classes. Dependencies are also referenced in the extended instance, such as a simple Java class, an extension of another Dubbo, or a Spring Bean. The situation of dependencies is complex, and Dubbo's processing is relatively complicated. We will have a special chapter to explain it later. Now, we just need to know that Dubbo can correctly inject common dependencies in extension points, Dubbo extension dependencies or Spring dependencies, etc..</li>\n<li>Extended instance is auto-wrapping. Auto-wrapping is about implementing Spring like AOP functionality. Dubbo uses it to implement some common functions internally, such as logging, monitoring, and so on. The contents of the extended instance auto-wrapper will also be explained separately later.</li>\n</ol>\n<p>After the above 4 steps, Dubbo creates and initializes an extended instance. The dependencies of this instance are injected and packaged as needed. At this point, this extended instance can be used.</p>\n<h2>Auto-assembly of Dubbo SPI advanced usage</h2>\n<p>The relevant code for auto-assembly is in the injectExtension method:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> T <span class=\"hljs-title\">injectExtension</span><span class=\"hljs-params\">(T instance)</span> </span>{\n    <span class=\"hljs-keyword\">for</span> (Method method : instance.getClass().getMethods()) {\n        <span class=\"hljs-keyword\">if</span> (method.getName().startsWith(<span class=\"hljs-string\">\"set\"</span>)\n                &amp;&amp; method.getParameterTypes().length == <span class=\"hljs-number\">1</span>\n                &amp;&amp; Modifier.isPublic(method.getModifiers())) {\n            Class&lt;?&gt; pt = method.getParameterTypes()[<span class=\"hljs-number\">0</span>];\n          \n            String property = method.getName().length() &gt; <span class=\"hljs-number\">3</span> ? method.getName().substring(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>).toLowerCase() + method.getName().substring(<span class=\"hljs-number\">4</span>) : <span class=\"hljs-string\">\"\"</span>;\n            Object object = objectFactory.getExtension(pt, property);\n            <span class=\"hljs-keyword\">if</span> (object != <span class=\"hljs-keyword\">null</span>) {\n                method.invoke(instance, object);\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> instance;\n}\n</code></pre>\n<p>To accomplish the automatic assembly of dependencies of the extended instances, you first need to know what the dependencies are and what the types of dependencies are. The solution of Dubbo is to find the Java standard setter method. That is, the method name starting with set has only one parameter. If such a set method exists in an extension class, Dubbo injects it into dependencies, which is similar to the injection of Spring's set method. However, dependency injection in Dubbo is more complicated than that in Spring, because all the methods injected into Spring are Spring beans and managed by the Spring container. In Dubbo's dependency injection, you may need to inject another extension of Dubbo, or a Spring Bean, or a component of Google guice, or a component in any other framework. Dubbo needs to be able to load extensions from any scenario. In the injectExtension method, it is implemented with <code>Object object = objectFactory. getExtension (pt, property)</code>. ObjectFactory is ExtensionFactory type and initialized when creating ExtensionLoader:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">ExtensionLoader</span><span class=\"hljs-params\">(Class&lt;?&gt; type)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.type = type;\n        objectFactory = (type == ExtensionFactory.class ? <span class=\"hljs-keyword\">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());\n}\n</code></pre>\n<p>ObjectFacore is also an extension, obtained through <code>ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()</code>.</p>\n<p><img src=\"https://raw.githubusercontent.com/vangoleo/wiki/master/dubbo/dubbo-extensionfactory.png\" alt=\"Dubbo-ExtensionFactory | left\"></p>\n<p>ExtensionFactory includes three implementations:</p>\n<ol>\n<li>SpiExtensionFactory: use Dubbo's Spi to load Extension.</li>\n<li>SpringExtensionFactory: load Extension from the Spring container.</li>\n<li>AdaptiveExtensionFactory: adaptive AdaptiveExtensionLoader</li>\n</ol>\n<p>Pay attention to the AdaptiveExtensionLoader here, the source code is as follows:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Adaptive</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AdaptiveExtensionFactory</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ExtensionFactory</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> List&lt;ExtensionFactory&gt; factories;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">AdaptiveExtensionFactory</span><span class=\"hljs-params\">()</span> </span>{\n        ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);\n        List&lt;ExtensionFactory&gt; list = <span class=\"hljs-keyword\">new</span> ArrayList&lt;ExtensionFactory&gt;();\n        <span class=\"hljs-keyword\">for</span> (String name : loader.getSupportedExtensions()) {\n            list.add(loader.getExtension(name));\n        }\n        factories = Collections.unmodifiableList(list);\n    }\n\n    <span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">T <span class=\"hljs-title\">getExtension</span><span class=\"hljs-params\">(Class&lt;T&gt; type, String name)</span> </span>{\n        <span class=\"hljs-keyword\">for</span> (ExtensionFactory factory : factories) {\n            T extension = factory.getExtension(type, name);\n            <span class=\"hljs-keyword\">if</span> (extension != <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-keyword\">return</span> extension;\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n    }\n}\n</code></pre>\n<p>The AdaptiveExtensionLoader class has @Adaptive annotations. As mentioned earlier, Dubbo creates an adaptive instance for each extension. If the extension class has @Adaptive annotations, it will use it as an adaptive class. If not, Dubbo will create one for us. So <code>ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension())</code> will return an AdaptiveExtensionLoader instance as an adaptive extension instance.\nThe AdaptiveExtensionLoader will iterate through all the ExtensionFactory implementations and try to load the extensions. If found, return. If not, continue to find it in the next ExtensionFactory. Dubbo has two ExtensionFactory built in, which are searched from Dubbo's own extension mechanism and Spring container. Since ExtensionFactory itself is also an extension point, we can implement our own ExtensionFactory to enable automatic assembly of Dubbo to support our custom components. For example, we used Google's guice as an IoC container in our project. We can implement our own GuiceExtensionFactory to enable Dubbo to load extensions from the guice container.</p>\n<h2>AOP of Dubbo SPI advanced usage</h2>\n<p>We often use AOP functionality when using Spring. Insert other logic before and after the method of the target class. For example, Spring AOP is usually used to implement logging, monitoring, and authentication, and so on.\nDoes Dubbo's extension mechanism also support similar features? The answer is yes. In Dubbo, there is a special class called the Wrapper class. It uses the wrapper class to wrap the original extension point instance through the decorator pattern, and then inserts additional logic before and after the original extension point implementation to implement AOP functionality.</p>\n<h3>What is the Wrapper class</h3>\n<p>So what kind of class is the Wrapper class in the Dubbo extension mechanism? The Wrapper class is a class that has a replication constructor and also is a typical decorator pattern. Here's a Wrapper class:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span>{\n    <span class=\"hljs-keyword\">private</span> A a;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">A</span><span class=\"hljs-params\">(A a)</span></span>{\n        <span class=\"hljs-keyword\">this</span>.a = a;\n    }\n}\n</code></pre>\n<p>Class A has a constructor <code>public A(A a)</code>, and the argument to the constructor is A itself. Such a class can be a Wrapper class in the Dubbo extension mechanism. Such Wrapper classes in Dubbo include ProtocolFilterWrapper, ProtocolListenerWrapper, and so on. You can check the source code to deepen your understanding.</p>\n<h3>How to configure the Wrapper class</h3>\n<p>The Wrapper class in Dubbo is also an extension point. Like other extension points, it is also configured in the <code>META-INF</code> folder. For example, the ProtocolFilterWrapper and ProtocolListenerWrapper in the previous example are configured in the path <code>dubbo-rpc/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/org.apache.dubbo.rpc.Protocol</code>:</p>\n<pre><code class=\"language-text\">filter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper\nlistener=org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper\nmock=org.apache.dubbo.rpc.support.MockProtocol\n</code></pre>\n<p>When Dubbo loads the extension configuration file, there is a piece of code as follows:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">try</span> {  \n  clazz.getConstructor(type);    \n  Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;\n  <span class=\"hljs-keyword\">if</span> (wrappers == <span class=\"hljs-keyword\">null</span>) {\n    cachedWrapperClasses = <span class=\"hljs-keyword\">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();\n    wrappers = cachedWrapperClasses;\n  }\n  wrappers.add(clazz);\n} <span class=\"hljs-keyword\">catch</span> (NoSuchMethodException e) {}\n</code></pre>\n<p>The meaning of this code is that if the extension class has a copy constructor, it will be saved for later use. The class that has the copy constructor is the Wrapper class. The parameter obtained by <code>clazz.getConstructor(type)</code> is the constructor of the extension point interface. Note that the parameter type of the constructor is an extension point interface, not an extension class.\nTake Protocol as an example. The configuration file <code>dubbo-rpc/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/org.apache.dubbo.rpc.Protocol defines filter=org.apache.dubbo.rpc.protocol. ProtocolFilterWrapper</code>.\nThe code of ProtocolFilterWrapper is as follows:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProtocolFilterWrapper</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Protocol</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Protocol protocol;\n\n    <span class=\"hljs-comment\">// One parameter is the copy constructor of Protocol</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ProtocolFilterWrapper</span><span class=\"hljs-params\">(Protocol protocol)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (protocol == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"protocol == null\"</span>);\n        }\n        <span class=\"hljs-keyword\">this</span>.protocol = protocol;\n    }\n}\n</code></pre>\n<p>ProtocolFilterWrapper has a constructor <code>public ProtocolFilterWrapper(Protocol protocol)</code>, and the parameter is the extension point Protocol. So it is a Wrapper class in the Dubbo extension mechanism. The ExtensionLoader will cache it. When creating Extension instances later, the ExtensionLoader use these wrapper classes to wrap the original Extension point in turn.</p>\n<h2>Extension point adaptive</h2>\n<p>As mentioned earlier, Dubbo needs to determine which extension to use based on method parameters at runtime. So there is an extension point adaptive instance. In fact, it is an extension point proxy that delays the selection of extensions from starting Dubbo to calling RPC. Each extension point in Dubbo has an adaptive class. If it is not explicitly provided, Dubbo will automatically create one for us. By default, Javaassist is used.\nLet's first look at the code to create an adaptive extension class:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> T <span class=\"hljs-title\">getAdaptiveExtension</span><span class=\"hljs-params\">()</span> </span>{\n    Object instance = cachedAdaptiveInstance.get();\n    <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">synchronized</span> (cachedAdaptiveInstance) {\n                instance = cachedAdaptiveInstance.get();\n                <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n                      instance = createAdaptiveExtension();\n                      cachedAdaptiveInstance.set(instance); \n                }\n            }        \n    }\n\n    <span class=\"hljs-keyword\">return</span> (T) instance;\n}\n</code></pre>\n<p>Continue to read the createAdaptiveExtension method:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> T <span class=\"hljs-title\">createAdaptiveExtension</span><span class=\"hljs-params\">()</span> </span>{        \n    <span class=\"hljs-keyword\">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());\n}\n</code></pre>\n<p>Continue to read the getAdaptiveExtensionClass method:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() {\n        getExtensionClasses();\n        <span class=\"hljs-keyword\">if</span> (cachedAdaptiveClass != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">return</span> cachedAdaptiveClass;\n        }\n        <span class=\"hljs-keyword\">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();\n}\n</code></pre>\n<p>Continue to read the createAdaptiveExtensionClass method. After a long journey, we finally come to a concrete realization. Look at this createAdaptiveExtensionClass method, which first generates the Java source code for the adaptive class, and then compile the source code into Java bytecode and load it into the JVM.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() {\n        String code = createAdaptiveExtensionClassCode();\n        ClassLoader classLoader = findClassLoader();\n        org.apache.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();\n        <span class=\"hljs-keyword\">return</span> compiler.compile(code, classLoader);\n}\n</code></pre>\n<p>The default implementation of Compiler's code is javassist.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@SPI</span>(<span class=\"hljs-string\">\"javassist\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Compiler</span> </span>{\n    Class&lt;?&gt; compile(String code, ClassLoader classLoader);\n}\n</code></pre>\n<p>The createAdaptiveExtensionClassCode () method uses a StringBuilder to build Java source code for the adaptive class. The method implementation is relatively long, and the code is not posted here. The approach to bytecode generation is also interesting, first generating Java source code, then compiling it and loading it into the jvm. In this way, the generated Java class can be better controlled. And it doesn't have to care about the API of the bytecode generation framework. Because the xxx.java file is universal in Java, it is also the one we are most familiar with. However, the code is not very readable and you need to build xx. Java content bit by bit.\nBelow are the Java code example for Protocol adaptive class created by createAdaptiveExtensionClassCode method:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> org.apache.dubbo.rpc;\n\n<span class=\"hljs-keyword\">import</span> org.apache.dubbo.common.extension.ExtensionLoader;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Protocol</span>$<span class=\"hljs-title\">Adaptive</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">org</span>.<span class=\"hljs-title\">apache</span>.<span class=\"hljs-title\">dubbo</span>.<span class=\"hljs-title\">rpc</span>.<span class=\"hljs-title\">Protocol</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnsupportedOperationException(<span class=\"hljs-string\">\"method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!\"</span>);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getDefaultPort</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnsupportedOperationException(<span class=\"hljs-string\">\"method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!\"</span>);\n    }\n\n    <span class=\"hljs-keyword\">public</span> org.apache.dubbo.rpc.<span class=\"hljs-function\">Exporter <span class=\"hljs-title\">export</span><span class=\"hljs-params\">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class=\"hljs-keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>{\n        <span class=\"hljs-keyword\">if</span> (arg0 == <span class=\"hljs-keyword\">null</span>) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"org.apache.dubbo.rpc.Invoker argument == null\"</span>);\n        <span class=\"hljs-keyword\">if</span> (arg0.getUrl() == <span class=\"hljs-keyword\">null</span>)\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"org.apache.dubbo.rpc.Invoker argument getUrl() == null\"</span>);\n        org.apache.dubbo.common.URL url = arg0.getUrl();\n        String extName = (url.getProtocol() == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-string\">\"dubbo\"</span> : url.getProtocol());\n        <span class=\"hljs-keyword\">if</span> (extName == <span class=\"hljs-keyword\">null</span>)\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url(\"</span> + url.toString() + <span class=\"hljs-string\">\") use keys([protocol])\"</span>);\n        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);\n        <span class=\"hljs-keyword\">return</span> extension.export(arg0);\n    }\n\n    <span class=\"hljs-keyword\">public</span> org.apache.dubbo.rpc.<span class=\"hljs-function\">Invoker <span class=\"hljs-title\">refer</span><span class=\"hljs-params\">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class=\"hljs-keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>{\n        <span class=\"hljs-keyword\">if</span> (arg1 == <span class=\"hljs-keyword\">null</span>) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"url == null\"</span>);\n        org.apache.dubbo.common.URL url = arg1;\n        String extName = (url.getProtocol() == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-string\">\"dubbo\"</span> : url.getProtocol());\n        <span class=\"hljs-keyword\">if</span> (extName == <span class=\"hljs-keyword\">null</span>)\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url(\"</span> + url.toString() + <span class=\"hljs-string\">\") use keys([protocol])\"</span>);\n        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);\n        <span class=\"hljs-keyword\">return</span> extension.refer(arg0, arg1);\n    }\n}\n</code></pre>\n<p>The general logic is the same as at the beginning. The parameters are parsed through the url, and the parsed logic is controlled by the value parameter of @adaptive, and then the extension points implementation are obtained according to the name of the extension point. And then finally make the call. If you want to know the specific construction logic of .Java code, you can see the complete implementation of <code>createAdaptiveExtensionClassCode</code>.\nIn the generated Protocol$Adaptive, both the getDefaultPort and destroy methods are found to throw the exception directly. Why? Take a look at the source code of Protocol:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@SPI</span>(<span class=\"hljs-string\">\"dubbo\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Protocol</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getDefaultPort</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-meta\">@Adaptive</span>\n    &lt;T&gt; <span class=\"hljs-function\">Exporter&lt;T&gt; <span class=\"hljs-title\">export</span><span class=\"hljs-params\">(Invoker&lt;T&gt; invoker)</span> <span class=\"hljs-keyword\">throws</span> RpcException</span>;\n\n    <span class=\"hljs-meta\">@Adaptive</span>\n    &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">refer</span><span class=\"hljs-params\">(Class&lt;T&gt; type, URL url)</span> <span class=\"hljs-keyword\">throws</span> RpcException</span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">()</span></span>;\n}\n</code></pre>\n<p>As you can see, there are four methods in the Protocol interface, but only the methods of export and refer use the @Adaptive annotation. Dubbo automatically generates adaptive instances, and only the methods modified by @Adaptive has a specific implementation. Therefore, in the Protocol$Adaptive class, only the export and refer methods have specific implementations, and the rest of the methods throw exceptions.</p>\n",
  "link": "/en-us/blog/introduction-to-dubbo-spi-2.html",
  "meta": {
    "title": "Dubbo extensible mechanism source code analysis",
    "keywords": "Dubbo, SPI, source code analysis",
    "description": "This article introduces the principles and details of Dubbo's SPI."
  }
}