{
  "filename": "implementation.md",
  "__html": "<h1>Implementation details</h1>\n<h2>Initialization details</h2>\n<h3>Service parsing</h3>\n<p>Based on <code>META-INF/spring.handlers</code> config in dubbo.jar, Spring calls <code>DubboNamespaceHandler</code> when meeting dubbo namespace.</p>\n<p>All Dubbo tags are parsed by <code>DubboBeanDefinitionParser</code>, based on one to one attribute mapping, the XML label is parsed as a Bean object.</p>\n<p>Transfer Bean object to URL, and transfer all attributes of Bean to URL parameters when <code>ServiceConfig.export()</code> or <code>ReferenceConfig.get()</code> initialization.</p>\n<p>Then pase URL to <a href=\"./impls/protocol.md\">Protocol extension point</a>, based on <a href=\"./SPI.md\">Extension point adaptive mechanism</a> of extension point, processing service exposure or reference for different protocols according to URL protocol header.</p>\n<h3>Service Exposure</h3>\n<h4>1. Only expose service port:</h4>\n<p>Direct exposing to provider when have not Registry, <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>, the URL format which parsing by <code>ServiceConfig</code>:\n<code>dubbo://service-host/com.foo.FooService?version=1.0.0</code>.</p>\n<p>Based on extension point adaptive mechanism, call <code>export()</code> method of <code>DubboProtocol</code> and open server port by identifying <code>dubbo://</code> protocol header of URL.</p>\n<h4>2. Expose to Registry:</h4>\n<p>Expose provider address to Registry <sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>, the URL format which parsing by <code>ServiceConfig</code>: <code>registry://registry-host/org.apache.dubbo.registry.RegistryService?export=URL.encode(&quot;dubbo://service-host/com.foo.FooService?version=1.0.0&quot;)</code>，</p>\n<p>Based on extension point adaptive mechanism, call <code>export()</code> method of <code>RegistryProtocol</code> by identifying  <code>registry://</code> protocol header, register the provider URL parameter of <code>export</code> to Registry.</p>\n<p>Resend to <code>Protocol</code> extension point to do exposure: <code>dubbo://service-host/com.foo.FooService?version=1.0.0</code>, then based on extension point adaptive mechanism, call <code>export()</code> method of <code>DubboProtocol</code> and open server port by identifying <code>dubbo://</code> protocol header of provider URL.</p>\n<h3>Service Reference</h3>\n<h4>1. Direct connect service</h4>\n<p>Direct connect provider when have not Registry <sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>, the URL format which parsing by <code>ReferenceConfig</code>: <code>dubbo://service-host/com.foo.FooService?version=1.0.0</code>.</p>\n<p>Based on extension point adaptive mechanism, call <code>refer()</code> method of <code>DubboProtocol</code> by identifying <code>dubbo://</code> protocol header of URL, and return provider reference.</p>\n<h4>2. Service Registry discovery</h4>\n<p>Discover provider address by Registry <sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup>, the URL format which parsing by <code>ReferenceConfig</code>:\n<code>registry://registry-host/org.apache.dubbo.registry.RegistryService?refer=URL.encode(&quot;consumer://consumer-host/com.foo.FooService?version=1.0.0&quot;)</code>.</p>\n<p>Based on extension point adaptive mechanism, call <code>refer()</code> method of <code>RegistryProtocol</code> by identifying <code>registry://</code> protocol header of URL, then based on the condition of parameter of <code>refer</code> to search provider URL, for example: <code>dubbo://service-host/com.foo.FooService?version=1.0.0</code>.</p>\n<p>Then based on extension point adaptive mechanism, call <code>refer()</code> method of <code>DubboProtocol</code> to get provider reference by identifying <code>dubbo://</code> protocol header of provider URL.</p>\n<p>Then <code>RegistryProtocol</code> disguise various provider references to single provider by <code>Cluster</code> extension point and return.</p>\n<h3>Service Filter</h3>\n<p>Based on extension point adaptive mechanism, all <code>Protocol</code> extension points are auto wrapped <code>Wrapper</code> class.</p>\n<p>Based on <code>ProtocolFilterWrapper</code> class, make all <code>Filter</code> as chain, call the real reference at the end of the chain.</p>\n<p>Based on <code>ProtocolListenerWrapper</code> class, make all <code>InvokerListener</code> and <code>ExporterListener</code> as list, perform call back before and after exposure and reference.</p>\n<p>All additional functions would be implementated by <code>Filter</code>, including Monitor.</p>\n<h2>RPC details</h2>\n<h3>The detail process of exposing service by service provider</h3>\n<p><img src=\"sources/images/dubbo_rpc_export.jpg\" alt=\"/dev-guide/images/dubbo_rpc_export.jpg\"></p>\n<p>The above image shows the main process of exposing service by service provider:</p>\n<p>First <code>ServiceConfig</code> class get the actual class <code>ref</code> that provides service(e.g. 如：HelloWorldImpl), then generating a <code>AbstractProxyInvoker</code> instance by the <code>getInvoker</code> method of <code>ProxyFactory</code> class, to this step, complete the transformation of specific service to <code>Invoker</code>, next is the process of converting <code>Invoker</code> to <code>Exporter</code>.</p>\n<p>The key of Dubbo processing service exposure is the process of converting <code>Invoker</code> to <code>Exporter</code>, the red part in the above image. Here we introduce the implementation of the two typical protocols, Dubbo and RMI:</p>\n<h4>Dubbo implementation</h4>\n<p>The transformation from <code>Invoker</code> of Dubbo protocol to <code>Exporter</code> takes place in the <code>export</code> method of <code>DubboProtocol</code> class, it mainly opens the socket to listen service and receive all kinds of requests sent by the client, and the communication details are implementated by Dubbo itself.</p>\n<h4>RMI implementation</h4>\n<p>The transformation from <code>Invoker</code> of RMI protocol to <code>Exporter</code> takes place in the <code>export</code> method of <code>RmiProtocol</code> class, the RMI service is implementated by Spring, Dubbo or JDK, and the communication details are implementated by JDK, which saves a lot of work.</p>\n<h3>The detail process of serving service for service consumer</h3>\n<p><img src=\"sources/images/dubbo_rpc_refer.jpg\" alt=\"/dev-guide/images/dubbo_rpc_refer.jpg\"></p>\n<p>The above image is the main process of service consumption:</p>\n<p>First, the <code>init</code> method of <code>ReferenceConfig</code> class calls the <code>refer</code> method of <code>Protocol</code> to generate <code>Invoker</code> instance(such as the red part in the above image), which is the key of service consumption. Then the <code>Invoker</code> is converted to the interface required by the client (such as: HelloWorld).</p>\n<p>For each protocol such as RMI/Dubbo/Web service, the details they call <code>refer</code> method generate <code>Invoker</code> instance are similar to the previous section.</p>\n<h3>Invoker everywhere</h3>\n<p>Because of <code>Invoker</code> is a very important concept in the Dubbo domain model, many of the design ideas are close to it. This makes <code>Invoker</code> permeate the entire implementation code, and it's really easy to mix up for people who have just started Dubbo.</p>\n<p>Let's use a simple image below to describe the 2 important <code>Invoker</code>: service provider <code>Invoker</code> and service consumer <code>Invoker</code>:</p>\n<p><img src=\"sources/images/dubbo_rpc_invoke.jpg\" alt=\"/dev-guide/images/dubbo_rpc_invoke.jpg\"></p>\n<p>To better explain the above image, we provide the below code examples of service consumption and providers:</p>\n<p>Service consumer code:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoClientAction</span> </span>{\n \n    <span class=\"hljs-keyword\">private</span> DemoService demoService;\n \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setDemoService</span><span class=\"hljs-params\">(DemoService demoService)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.demoService = demoService;\n    }\n \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span> </span>{\n        String hello = demoService.sayHello(<span class=\"hljs-string\">\"world\"</span> + i);\n    }\n}\n</code></pre>\n<p>The <code>DemoService</code> in above code is the proxy of service consumer in above image, user can call <code>Invoker</code> <sup class=\"footnote-ref\"><a href=\"#fn5\" id=\"fnref5\">[5]</a></sup> which implementate the real RPC by the proxy.</p>\n<p>Service provider code:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">DemoService</span> </span>{\n \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span> <span class=\"hljs-keyword\">throws</span> RemoteException </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Hello \"</span> + name;\n    }\n}\n</code></pre>\n<p>The above class would be encapsulated to be a <code>AbstractProxyInvoker</code> instance, and create a new <code>Exporter</code> instance, then find corresponding <code>Exporter</code> instance and call its corresponding <code>AbstractProxyInvoker</code> instance when network communication layer recieve request, so that real call service provider code. There are some other <code>Invoker</code> classes, but the above 2 are the most important.</p>\n<h2>Remote communication details</h2>\n<h3>Protocol header agreement</h3>\n<p><img src=\"sources/images/dubbo_protocol_header.png\" alt=\"/dev-guide/images/dubbo_protocol_header.jpg\"></p>\n<h3>Thread dispatch model</h3>\n<p><img src=\"sources/images/dubbo-protocol.jpg\" alt=\"/dev-guide/images/dubbo-protocol.jpg\"></p>\n<ul>\n<li>Dispather: <code>all</code>, <code>direct</code>, <code>message</code>, <code>execution</code>, <code>connection</code></li>\n<li>ThreadPool: <code>fixed</code>, <code>cached</code></li>\n</ul>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>is <code>&lt;dubbo:service regisrty=&quot;N/A&quot; /&gt;</code> or <code>&lt;dubbo:registry address=&quot;N/A&quot; /&gt;</code> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>is <code>&lt;dubbo:registry address=&quot;zookeeper://10.20.153.10:2181&quot; /&gt;</code> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>is <code>&lt;dubbo:reference url=&quot;dubbo://service-host/com.foo.FooService?version=1.0.0&quot; /&gt;</code> <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p>is <code>&lt;dubbo:registry address=&quot;zookeeper://10.20.153.10:2181&quot; /&gt;</code> <a href=\"#fnref4\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn5\" class=\"footnote-item\"><p>is one of <code>DubboInvoker</code>, <code>HessianRpcInvoker</code>, <code>InjvmInvoker</code>, <code>RmiInvoker</code>, <code>WebServiceInvoker</code> <a href=\"#fnref5\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
  "link": "/en-us/docs/dev/implementation.html",
  "meta": {}
}