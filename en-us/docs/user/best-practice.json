{
  "filename": "best-practice.md",
  "__html": "<h1>Servitization best practice</h1>\n<h2>Modularization</h2>\n<p>It is recommended to put service interfaces, service models, service exceptions, and so on in the API package,Because the service model and exception are part of the API, it is also in conformity with the modularization principle:Reusing the publish equivalence principle (REP) and the Common Reuse Principle (CRP).</p>\n<p>If you need, you can also consider placing a spring reference configuration in the API package, so that the user can only use the configuration in the spring loading process, and the configuration suggestion is placed in the package directory of the module, so as not to conflict, eg:<code>com/alibaba/china/xxx/dubbo-reference.xml</code>。</p>\n<h2>Granularity</h2>\n<p>The service interface should have large granularity as possible.Each service method should represent a function rather than a step of a function, otherwise it will be faced with distributed transaction problem. Dubbo does not provide distributed transaction support at present.</p>\n<p>The service interface recommends the division of the business scene as a unit and abstract the similar business to prevent the explosion of the number of interfaces.</p>\n<p>It is not recommended to use an too abstract universal interface, such as Map query (Map), which has no explicit semantics, which will inconvenience later maintenance.</p>\n<h2>Version</h2>\n<p>Each interface should define a version number to provide possible subsequent incompatible upgrades,eg: <code>&lt;dubbo:service interface=&quot;com.xxx.XxxService&quot; version=&quot;1.0&quot; /&gt;</code>。</p>\n<p>It is recommended to use a two bit version number, because the third - bit version number is usually compatible with a compatible upgrade, and a change of service version is required only when incompatible.</p>\n<p>When incompatible, half of the provider is upgraded to a new version, and all the consumers are upgraded to a new version, and the remaining half providers are upgraded to a new version.</p>\n<h2>Compatibility</h2>\n<p>The service interface adds method or the service model adds fields. It can be backward compatible, delete methods or delete fields, and will not be compatible. The new fields of the enumerated type are not compatible, so we need to upgrade by changing the version number.</p>\n<p>The compatibility of each protocol is different, see: <a href=\"./references/protocol/introduction.md\">Protocol introduction</a></p>\n<h2>Enumeration type</h2>\n<p>If it is a complete set, you can use Enum, eg:<code>ENABLE</code>, <code>DISABLE</code>。</p>\n<p>If it is the type of business, there will be an obvious type of increase in the future, and it is not recommended to use  <code>Enum</code>, and it is not recommended to use Enum and can be replaced by  <code>String</code> .</p>\n<p>If you use<code>Enum</code>in the return value,And add the  <code>Enum</code> value,suggestions to upgrade the service consumption, so that the service provider does not return a new value.</p>\n<p>If the  <code>Enum</code>  value is used in the incoming parameter,and add the <code>Enum</code> value,it is suggested that the service provider be upgraded first, so that the service consumer will not pass the new value.</p>\n<h2>Serialization</h2>\n<p>The service parameters and return values suggest that the POJO object is used, that is, the object of the attribute is represented by the <code>setter</code>, <code>getter</code> method.</p>\n<p>Service parameters and return values do not recommend the use of interfaces, because data model abstraction is of little significance, and serialization requires interfaces to implement meta information of classes, and can not play the purpose of hiding implementation.</p>\n<p>Service parameters and return values must be byValue, but not byReference. The reference or return values of consumers and providers are not the same, but the values are the same. Dubbo does not support remote objects.</p>\n<h2>Exception</h2>\n<p>It is suggested that abnormal reporting errors are used rather than return error codes, and exception information can carry more information and have more semantic friendliness.</p>\n<p>If you are worried about performance problems, you can use the override () method of fillInStackTrace () out of the exception class as an empty method to make it not a copy of the stack information when necessary.</p>\n<p>Query method is not recommended throws checked, otherwise the caller in the query will be too much <code>try...catch, and can not be processed.</code></p>\n<p>Service providers should not throw the exception of DAO or SQL to the consumer side. They should package the exception that consumers do not care about in service implementation, otherwise consumers may not be able to serialize the corresponding exception.</p>\n<h2>Call</h2>\n<p>Not just because it is a Dubbo call, wrap the call logic eith <code>try...catch</code>clause. <code>try...catch</code> should be added to the appropriate rollback boundary.</p>\n<p>The check logic for the input parameters should be available at the Provider side. For performance considerations, the service implementer may consider adding a service Stub class to the API package to complete the test.</p>\n"
}