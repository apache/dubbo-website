<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="rest" />
	<meta name="description" content="rest" />
	<!-- 网页标签标题 -->
	<title>rest</title>
	<link rel="shortcut icon" href="/img/dubbo.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot="" data-reactid="1" data-react-checksum="-125382822"><header class="header-container header-container-normal" data-reactid="2"><div class="header-body" data-reactid="3"><a href="/en-us/index.html" data-reactid="4"><img class="logo" src="/img/dubbo_colorful.png" data-reactid="5"/></a><div class="search search-normal" data-reactid="6"><span class="icon-search" data-reactid="7"></span></div><span class="language-switch language-switch-normal" data-reactid="8">中</span><div class="header-menu" data-reactid="9"><img class="header-menu-toggle" src="/img/menu_gray.png" data-reactid="10"/><ul data-reactid="11"><li class="menu-item menu-item-normal" data-reactid="12"><a href="/en-us/index.html" data-reactid="13">HOME</a></li><li class="menu-item menu-item-normal menu-item-normal-active" data-reactid="14"><a href="/en-us/docs/user/quick-start.html" data-reactid="15">DOCS</a></li><li class="menu-item menu-item-normal" data-reactid="16"><a href="/en-us/docs/developers/developer1_dev.html" data-reactid="17">DEVELOPERS</a></li><li class="menu-item menu-item-normal" data-reactid="18"><a href="/en-us/blog/index.html" data-reactid="19">BLOG</a></li><li class="menu-item menu-item-normal" data-reactid="20"><a href="/en-us/community/index.html" data-reactid="21">COMMUNITY</a></li><li class="menu-item menu-item-normal" data-reactid="22"><a href="/en-us/blog/download.html" data-reactid="23">DOWNLOAD</a></li></ul></div></div></header><div class="bar" data-reactid="24"><div class="bar-body" data-reactid="25"><img src="/img/docs.png" class="front-img" data-reactid="26"/><span data-reactid="27">Documentation</span><img src="/img/docs.png" class="back-img" data-reactid="28"/></div></div><section class="content-section" data-reactid="29"><div class="sidemenu" data-reactid="30"><div class="sidemenu-toggle" data-reactid="31"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png" data-reactid="32"/></div><ul data-reactid="33"><li class="menu-item menu-item-level-1" data-reactid="34"><span data-reactid="35">User doc</span><ul data-reactid="36"><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="37"><span data-reactid="38"><!-- react-text: 39 -->Preface<!-- /react-text --><img style="transform:rotate(-90deg);" class="menu-toggle" src="/img/arrow_down.png" data-reactid="40"/></span><ul data-reactid="41"><li class="menu-item menu-item-level-3" data-reactid="42"><a href="/en-us/docs/user/preface/background.html" target="_self" data-reactid="43">Background</a></li><li class="menu-item menu-item-level-3" data-reactid="44"><a href="/en-us/docs/user/preface/requirements.html" target="_self" data-reactid="45">Requirements</a></li><li class="menu-item menu-item-level-3" data-reactid="46"><a href="/en-us/docs/user/preface/architecture.html" target="_self" data-reactid="47">Architecture</a></li><li class="menu-item menu-item-level-3" data-reactid="48"><a href="/en-us/docs/user/preface/usage.html" target="_self" data-reactid="49">Usage</a></li></ul></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="50"><a href="/en-us/docs/user/quick-start.html" target="_self" data-reactid="51">Quick start</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="52"><a href="/en-us/docs/user/dependencies.html" target="_self" data-reactid="53">Dependencies</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="54"><a href="/en-us/docs/user/maturity.html" target="_self" data-reactid="55">Maturality</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="56"><span data-reactid="57"><!-- react-text: 58 -->Configuration<!-- /react-text --><img style="transform:rotate(-90deg);" class="menu-toggle" src="/img/arrow_down.png" data-reactid="59"/></span><ul data-reactid="60"><li class="menu-item menu-item-level-3" data-reactid="61"><a href="/en-us/docs/user/configuration/xml.html" target="_self" data-reactid="62">XML configuration</a></li><li class="menu-item menu-item-level-3" data-reactid="63"><a href="/en-us/docs/user/configuration/properties.html" target="_self" data-reactid="64">Properties configuration</a></li><li class="menu-item menu-item-level-3" data-reactid="65"><a href="/en-us/docs/user/configuration/api.html" target="_self" data-reactid="66">API configuration</a></li><li class="menu-item menu-item-level-3" data-reactid="67"><a href="/en-us/docs/user/configuration/annotation.html" target="_self" data-reactid="68">Annotation configuration</a></li></ul></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="69"><span data-reactid="70"><!-- react-text: 71 -->Demos<!-- /react-text --><img style="transform:rotate(-90deg);" class="menu-toggle" src="/img/arrow_down.png" data-reactid="72"/></span><ul data-reactid="73"><li class="menu-item menu-item-level-3" data-reactid="74"><a href="/en-us/docs/user/demos/preflight-check.html" target="_self" data-reactid="75">Start check</a></li><li class="menu-item menu-item-level-3" data-reactid="76"><a href="/en-us/docs/user/demos/fault-tolerent-strategy.html" target="_self" data-reactid="77">Fault-tolerent strategy</a></li><li class="menu-item menu-item-level-3" data-reactid="78"><a href="/en-us/docs/user/demos/loadbalance.html" target="_self" data-reactid="79">Load balance</a></li><li class="menu-item menu-item-level-3" data-reactid="80"><a href="/en-us/docs/user/demos/thread-model.html" target="_self" data-reactid="81">Thread model</a></li><li class="menu-item menu-item-level-3" data-reactid="82"><a href="/en-us/docs/user/demos/explicit-target.html" target="_self" data-reactid="83">Connecting certain provider straightly</a></li><li class="menu-item menu-item-level-3" data-reactid="84"><a href="/en-us/docs/user/demos/subscribe-only.html" target="_self" data-reactid="85">Subscribe only</a></li><li class="menu-item menu-item-level-3" data-reactid="86"><a href="/en-us/docs/user/demos/registry-only.html" target="_self" data-reactid="87">Registry only</a></li><li class="menu-item menu-item-level-3" data-reactid="88"><a href="/en-us/docs/user/demos/static-service.html" target="_self" data-reactid="89">Static service</a></li><li class="menu-item menu-item-level-3" data-reactid="90"><a href="/en-us/docs/user/demos/multi-protocols.html" target="_self" data-reactid="91">Multi-protocols</a></li><li class="menu-item menu-item-level-3" data-reactid="92"><a href="/en-us/docs/user/demos/multi-registry.html" target="_self" data-reactid="93">Multi-registries</a></li><li class="menu-item menu-item-level-3" data-reactid="94"><a href="/en-us/docs/user/demos/service-group.html" target="_self" data-reactid="95">Service group</a></li><li class="menu-item menu-item-level-3" data-reactid="96"><a href="/en-us/docs/user/demos/multi-versions.html" target="_self" data-reactid="97">Multi-versions</a></li><li class="menu-item menu-item-level-3" data-reactid="98"><a href="/en-us/docs/user/demos/group-merger.html" target="_self" data-reactid="99">Group merger</a></li><li class="menu-item menu-item-level-3" data-reactid="100"><a href="/en-us/docs/user/demos/parameter-validation.html" target="_self" data-reactid="101">Parameter validation</a></li><li class="menu-item menu-item-level-3" data-reactid="102"><a href="/en-us/docs/user/demos/result-cache.html" target="_self" data-reactid="103">Result cache</a></li><li class="menu-item menu-item-level-3" data-reactid="104"><a href="/en-us/docs/user/demos/generic-reference.html" target="_self" data-reactid="105">Generic reference</a></li><li class="menu-item menu-item-level-3" data-reactid="106"><a href="/en-us/docs/user/demos/generic-service.html" target="_self" data-reactid="107">Generic service</a></li><li class="menu-item menu-item-level-3" data-reactid="108"><a href="/en-us/docs/user/demos/echo-service.html" target="_self" data-reactid="109">Echo service</a></li><li class="menu-item menu-item-level-3" data-reactid="110"><a href="/en-us/docs/user/demos/context.html" target="_self" data-reactid="111">Context</a></li><li class="menu-item menu-item-level-3" data-reactid="112"><a href="/en-us/docs/user/demos/attachment.html" target="_self" data-reactid="113">Attachment</a></li><li class="menu-item menu-item-level-3" data-reactid="114"><a href="/en-us/docs/user/demos/async-call.html" target="_self" data-reactid="115">Asynchronous call</a></li><li class="menu-item menu-item-level-3" data-reactid="116"><a href="/en-us/docs/user/demos/local-call.html" target="_self" data-reactid="117">Local call</a></li><li class="menu-item menu-item-level-3" data-reactid="118"><a href="/en-us/docs/user/demos/callback-parameter.html" target="_self" data-reactid="119">Callback parameter</a></li><li class="menu-item menu-item-level-3" data-reactid="120"><a href="/en-us/docs/user/demos/events-notify.html" target="_self" data-reactid="121">Events notify</a></li><li class="menu-item menu-item-level-3" data-reactid="122"><a href="/en-us/docs/user/demos/local-stub.html" target="_self" data-reactid="123">Local stub</a></li><li class="menu-item menu-item-level-3" data-reactid="124"><a href="/en-us/docs/user/demos/local-mock.html" target="_self" data-reactid="125">Local mock</a></li><li class="menu-item menu-item-level-3" data-reactid="126"><a href="/en-us/docs/user/demos/delay-publish.html" target="_self" data-reactid="127">Delay publish</a></li><li class="menu-item menu-item-level-3" data-reactid="128"><a href="/en-us/docs/user/demos/concurrency-control.html" target="_self" data-reactid="129">Concurrency control</a></li><li class="menu-item menu-item-level-3" data-reactid="130"><a href="/en-us/docs/user/demos/config-connections.html" target="_self" data-reactid="131">Connections limitation</a></li><li class="menu-item menu-item-level-3" data-reactid="132"><a href="/en-us/docs/user/demos/lazy-connect.html" target="_self" data-reactid="133">Lazy connect</a></li><li class="menu-item menu-item-level-3" data-reactid="134"><a href="/en-us/docs/user/demos/stickiness.html" target="_self" data-reactid="135">Stickness connections</a></li><li class="menu-item menu-item-level-3" data-reactid="136"><a href="/en-us/docs/user/demos/token-authorization.html" target="_self" data-reactid="137">Token authorization</a></li><li class="menu-item menu-item-level-3" data-reactid="138"><a href="/en-us/docs/user/demos/routing-rule.html" target="_self" data-reactid="139">Routing rule</a></li><li class="menu-item menu-item-level-3" data-reactid="140"><a href="/en-us/docs/user/demos/config-rule.html" target="_self" data-reactid="141">Configuration rule</a></li><li class="menu-item menu-item-level-3" data-reactid="142"><a href="/en-us/docs/user/demos/service-downgrade.html" target="_self" data-reactid="143">Service downgrade</a></li><li class="menu-item menu-item-level-3" data-reactid="144"><a href="/en-us/docs/user/demos/graceful-shutdown.html" target="_self" data-reactid="145">Graceful shutdown</a></li><li class="menu-item menu-item-level-3" data-reactid="146"><a href="/en-us/docs/user/demos/hostname-binding.html" target="_self" data-reactid="147">Hostname binding</a></li><li class="menu-item menu-item-level-3" data-reactid="148"><a href="/en-us/docs/user/demos/logger-strategy.html" target="_self" data-reactid="149">Logger strategy</a></li><li class="menu-item menu-item-level-3" data-reactid="150"><a href="/en-us/docs/user/demos/accesslog.html" target="_self" data-reactid="151">Accesslog</a></li><li class="menu-item menu-item-level-3" data-reactid="152"><a href="/en-us/docs/user/demos/service-container.html" target="_self" data-reactid="153">Service container</a></li><li class="menu-item menu-item-level-3" data-reactid="154"><a href="/en-us/docs/user/demos/reference-config-cache.html" target="_self" data-reactid="155">Reference config cache</a></li><li class="menu-item menu-item-level-3" data-reactid="156"><a href="/en-us/docs/user/demos/distributed-transaction.html" target="_self" data-reactid="157">Distributed transaction</a></li><li class="menu-item menu-item-level-3" data-reactid="158"><a href="/en-us/docs/user/demos/dump.html" target="_self" data-reactid="159">Automatic thread dump</a></li><li class="menu-item menu-item-level-3" data-reactid="160"><a href="/en-us/docs/user/demos/netty4.html" target="_self" data-reactid="161">Netty4</a></li><li class="menu-item menu-item-level-3" data-reactid="162"><a href="/en-us/docs/user/demos/serialization.html" target="_self" data-reactid="163">Serialization with FST and Kyro</a></li></ul></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="164"><a href="/en-us/docs/user/references/api.html" target="_self" data-reactid="165">API configuration reference</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="166"><span data-reactid="167"><!-- react-text: 168 -->Schema configuration reference<!-- /react-text --><img style="transform:rotate(-90deg);" class="menu-toggle" src="/img/arrow_down.png" data-reactid="169"/></span><ul data-reactid="170"><li class="menu-item menu-item-level-3" data-reactid="171"><a href="/en-us/docs/user/references/xml/introduction.html" target="_self" data-reactid="172">Introduction</a></li><li class="menu-item menu-item-level-3" data-reactid="173"><a href="/en-us/docs/user/references/xml/dubbo-service.html" target="_self" data-reactid="174">dubbo:service</a></li><li class="menu-item menu-item-level-3" data-reactid="175"><a href="/en-us/docs/user/references/xml/dubbo-reference.html" target="_self" data-reactid="176">dubbo:reference</a></li><li class="menu-item menu-item-level-3" data-reactid="177"><a href="/en-us/docs/user/references/xml/dubbo-protocol.html" target="_self" data-reactid="178">dubbo:protocol</a></li><li class="menu-item menu-item-level-3" data-reactid="179"><a href="/en-us/docs/user/references/xml/dubbo-registry.html" target="_self" data-reactid="180">dubbo:registry</a></li><li class="menu-item menu-item-level-3" data-reactid="181"><a href="/en-us/docs/user/references/xml/dubbo-monitor.html" target="_self" data-reactid="182">dubbo:monitor</a></li><li class="menu-item menu-item-level-3" data-reactid="183"><a href="/en-us/docs/user/references/xml/dubbo-application.html" target="_self" data-reactid="184">dubbo:application</a></li><li class="menu-item menu-item-level-3" data-reactid="185"><a href="/en-us/docs/user/references/xml/dubbo-module.html" target="_self" data-reactid="186">dubbo:module</a></li><li class="menu-item menu-item-level-3" data-reactid="187"><a href="/en-us/docs/user/references/xml/dubbo-provider.html" target="_self" data-reactid="188">dubbo:provider</a></li><li class="menu-item menu-item-level-3" data-reactid="189"><a href="/en-us/docs/user/references/xml/dubbo-consumer.html" target="_self" data-reactid="190">dubbo:consumer</a></li><li class="menu-item menu-item-level-3" data-reactid="191"><a href="/en-us/docs/user/references/xml/dubbo-method.html" target="_self" data-reactid="192">dubbo:method</a></li><li class="menu-item menu-item-level-3" data-reactid="193"><a href="/en-us/docs/user/references/xml/dubbo-argument.html" target="_self" data-reactid="194">dubbo:argument</a></li><li class="menu-item menu-item-level-3" data-reactid="195"><a href="/en-us/docs/user/references/xml/dubbo-parameter.html" target="_self" data-reactid="196">dubbo:parameter</a></li></ul></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="197"><span data-reactid="198"><!-- react-text: 199 -->Protocol configuration reference<!-- /react-text --><img style="transform:rotate(-90deg);" class="menu-toggle" src="/img/arrow_down.png" data-reactid="200"/></span><ul data-reactid="201"><li class="menu-item menu-item-level-3" data-reactid="202"><a href="/en-us/docs/user/references/protocol/introduction.html" target="_self" data-reactid="203">Introduction</a></li><li class="menu-item menu-item-level-3" data-reactid="204"><a href="/en-us/docs/user/references/protocol/dubbo.html" target="_self" data-reactid="205">dubbo://</a></li><li class="menu-item menu-item-level-3" data-reactid="206"><a href="/en-us/docs/user/references/protocol/rmi.html" target="_self" data-reactid="207">rmi://</a></li><li class="menu-item menu-item-level-3" data-reactid="208"><a href="/en-us/docs/user/references/protocol/hessian.html" target="_self" data-reactid="209">hessian://</a></li><li class="menu-item menu-item-level-3" data-reactid="210"><a href="/en-us/docs/user/references/protocol/http.html" target="_self" data-reactid="211">http://</a></li><li class="menu-item menu-item-level-3" data-reactid="212"><a href="/en-us/docs/user/references/protocol/webservice.html" target="_self" data-reactid="213">webservice://</a></li><li class="menu-item menu-item-level-3" data-reactid="214"><a href="/en-us/docs/user/references/protocol/thrift.html" target="_self" data-reactid="215">thrift://</a></li><li class="menu-item menu-item-level-3" data-reactid="216"><a href="/en-us/docs/user/references/protocol/memcached.html" target="_self" data-reactid="217">memcached://</a></li><li class="menu-item menu-item-level-3" data-reactid="218"><a href="/en-us/docs/user/references/protocol/redis.html" target="_self" data-reactid="219">redis://</a></li><li class="menu-item menu-item-level-3" data-reactid="220"><a href="/en-us/docs/user/references/protocol/rest.html" target="_self" data-reactid="221">rest://</a></li></ul></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="222"><span data-reactid="223"><!-- react-text: 224 -->Registry configuration reference<!-- /react-text --><img style="transform:rotate(-90deg);" class="menu-toggle" src="/img/arrow_down.png" data-reactid="225"/></span><ul data-reactid="226"><li class="menu-item menu-item-level-3" data-reactid="227"><a href="/en-us/docs/user/references/registry/introduction.html" target="_self" data-reactid="228">Introduction</a></li><li class="menu-item menu-item-level-3" data-reactid="229"><a href="/en-us/docs/user/references/registry/multicast.html" target="_self" data-reactid="230">Multicast registry</a></li><li class="menu-item menu-item-level-3" data-reactid="231"><a href="/en-us/docs/user/references/registry/zookeeper.html" target="_self" data-reactid="232">Zookeeper registry</a></li><li class="menu-item menu-item-level-3" data-reactid="233"><a href="/en-us/docs/user/references/registry/redis.html" target="_self" data-reactid="234">Redis registry</a></li><li class="menu-item menu-item-level-3" data-reactid="235"><a href="/en-us/docs/user/references/registry/simple.html" target="_self" data-reactid="236">Simple registry</a></li></ul></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="237"><a href="/en-us/docs/user/references/telnet.html" target="_self" data-reactid="238">Telnet command</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="239"><a href="/en-us/docs/user/references/maven.html" target="_self" data-reactid="240">Maven plugin</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="241"><a href="/en-us/docs/user/best-practice.html" target="_self" data-reactid="242">Best practice</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="243"><a href="/en-us/docs/user/recommend.html" target="_self" data-reactid="244">Recommended usage</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="245"><a href="/en-us/docs/user/capacity-plan.html" target="_self" data-reactid="246">Capacity plan</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="247"><a href="/en-us/docs/user/perf-test.html" target="_self" data-reactid="248">Performance testing reports</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="249"><a href="/en-us/docs/user/coveragence.html" target="_self" data-reactid="250">Test coverage report</a></li></ul></li><li class="menu-item menu-item-level-1" data-reactid="251"><span data-reactid="252">Developer guide</span><ul data-reactid="253"><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="254"><a href="/en-us/docs/dev/build.html" target="_self" data-reactid="255">How To Build</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="256"><a href="/en-us/docs/dev/design.html" target="_self" data-reactid="257">Architecture</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="258"><a href="/en-us/docs/dev/SPI.html" target="_self" data-reactid="259">How SPI Works</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="260"><a href="/en-us/docs/dev/implementation.html" target="_self" data-reactid="261">Init, Process, Protocols</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="262"><span data-reactid="263"><!-- react-text: 264 -->SPI Extensions<!-- /react-text --><img style="transform:rotate(-90deg);" class="menu-toggle" src="/img/arrow_down.png" data-reactid="265"/></span><ul data-reactid="266"><li class="menu-item menu-item-level-3" data-reactid="267"><a href="/en-us/docs/dev/impls/protocol.html" target="_self" data-reactid="268">Protocol</a></li><li class="menu-item menu-item-level-3" data-reactid="269"><a href="/en-us/docs/dev/impls/filter.html" target="_self" data-reactid="270">Filter</a></li><li class="menu-item menu-item-level-3" data-reactid="271"><a href="/en-us/docs/dev/impls/invoker-listener.html" target="_self" data-reactid="272">InvokerListener</a></li><li class="menu-item menu-item-level-3" data-reactid="273"><a href="/en-us/docs/dev/impls/exporter-listener.html" target="_self" data-reactid="274">ExporterListener</a></li><li class="menu-item menu-item-level-3" data-reactid="275"><a href="/en-us/docs/dev/impls/cluster.html" target="_self" data-reactid="276">Cluster</a></li><li class="menu-item menu-item-level-3" data-reactid="277"><a href="/en-us/docs/dev/impls/router.html" target="_self" data-reactid="278">Router</a></li><li class="menu-item menu-item-level-3" data-reactid="279"><a href="/en-us/docs/dev/impls/load-balance.html" target="_self" data-reactid="280">LoadBalance</a></li><li class="menu-item menu-item-level-3" data-reactid="281"><a href="/en-us/docs/dev/impls/merger.html" target="_self" data-reactid="282">Merger</a></li><li class="menu-item menu-item-level-3" data-reactid="283"><a href="/en-us/docs/dev/impls/registry.html" target="_self" data-reactid="284">Registry</a></li><li class="menu-item menu-item-level-3" data-reactid="285"><a href="/en-us/docs/dev/impls/monitor.html" target="_self" data-reactid="286">Monitor</a></li><li class="menu-item menu-item-level-3" data-reactid="287"><a href="/en-us/docs/dev/impls/extension-factory.html" target="_self" data-reactid="288">ExtensionFactory</a></li><li class="menu-item menu-item-level-3" data-reactid="289"><a href="/en-us/docs/dev/impls/proxy-factory.html" target="_self" data-reactid="290">ProxyFactory</a></li><li class="menu-item menu-item-level-3" data-reactid="291"><a href="/en-us/docs/dev/impls/compiler.html" target="_self" data-reactid="292">Compiler</a></li><li class="menu-item menu-item-level-3" data-reactid="293"><a href="/en-us/docs/dev/impls/dispatcher.html" target="_self" data-reactid="294">Dispatcher</a></li><li class="menu-item menu-item-level-3" data-reactid="295"><a href="/en-us/docs/dev/impls/threadpool.html" target="_self" data-reactid="296">Threadpool</a></li><li class="menu-item menu-item-level-3" data-reactid="297"><a href="/en-us/docs/dev/impls/serialize.html" target="_self" data-reactid="298">Serialization</a></li><li class="menu-item menu-item-level-3" data-reactid="299"><a href="/en-us/docs/dev/impls/remoting.html" target="_self" data-reactid="300">Remoting</a></li><li class="menu-item menu-item-level-3" data-reactid="301"><a href="/en-us/docs/dev/impls/exchanger.html" target="_self" data-reactid="302">Exchanger</a></li><li class="menu-item menu-item-level-3" data-reactid="303"><a href="/en-us/docs/dev/impls/networker.html" target="_self" data-reactid="304">Networker</a></li><li class="menu-item menu-item-level-3" data-reactid="305"><a href="/en-us/docs/dev/impls/telnet-handler.html" target="_self" data-reactid="306">TelnetHandler</a></li><li class="menu-item menu-item-level-3" data-reactid="307"><a href="/en-us/docs/dev/impls/status-checker.html" target="_self" data-reactid="308">StatusChecker</a></li><li class="menu-item menu-item-level-3" data-reactid="309"><a href="/en-us/docs/dev/impls/container.html" target="_self" data-reactid="310">Container</a></li><li class="menu-item menu-item-level-3" data-reactid="311"><a href="/en-us/docs/dev/impls/page.html" target="_self" data-reactid="312">PageHandler</a></li><li class="menu-item menu-item-level-3" data-reactid="313"><a href="/en-us/docs/dev/impls/cache.html" target="_self" data-reactid="314">Cache</a></li><li class="menu-item menu-item-level-3" data-reactid="315"><a href="/en-us/docs/dev/impls/validation.html" target="_self" data-reactid="316">Validation</a></li><li class="menu-item menu-item-level-3" data-reactid="317"><a href="/en-us/docs/dev/impls/logger-adapter.html" target="_self" data-reactid="318">LoggerAdapter</a></li></ul></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="319"><a href="/en-us/docs/dev/contract.html" target="_self" data-reactid="320">Contract</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="321"><a href="/en-us/docs/dev/coding.html" target="_self" data-reactid="322">Code Style</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="323"><a href="/en-us/docs/dev/release.html" target="_self" data-reactid="324">Versions</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="325"><a href="/en-us/docs/dev/contribution.html" target="_self" data-reactid="326">Contribution</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="327"><a href="/en-us/docs/dev/checklist.html" target="_self" data-reactid="328">Checklist</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="329"><a href="/en-us/docs/dev/code-smell.html" target="_self" data-reactid="330">Code Smell</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="331"><a href="/en-us/docs/dev/TCK.html" target="_self" data-reactid="332">TCK</a></li></ul></li><li class="menu-item menu-item-level-1" data-reactid="333"><span data-reactid="334">Admin guide</span><ul data-reactid="335"><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="336"><span data-reactid="337"><!-- react-text: 338 -->Installation<!-- /react-text --><img style="transform:rotate(-90deg);" class="menu-toggle" src="/img/arrow_down.png" data-reactid="339"/></span><ul data-reactid="340"><li class="menu-item menu-item-level-3" data-reactid="341"><a href="/en-us/docs/admin/install/provider-demo.html" target="_self" data-reactid="342">Install provider demo</a></li><li class="menu-item menu-item-level-3" data-reactid="343"><a href="/en-us/docs/admin/install/consumer-demo.html" target="_self" data-reactid="344">Install consumer demo</a></li><li class="menu-item menu-item-level-3" data-reactid="345"><a href="/en-us/docs/admin/install/zookeeper.html" target="_self" data-reactid="346">Install Zookeeper configuration center</a></li><li class="menu-item menu-item-level-3" data-reactid="347"><a href="/en-us/docs/admin/install/redis.html" target="_self" data-reactid="348">Install Redis configuration center</a></li><li class="menu-item menu-item-level-3" data-reactid="349"><a href="/en-us/docs/admin/install/simple-registry-center.html" target="_self" data-reactid="350">Install Simple configuration center</a></li><li class="menu-item menu-item-level-3" data-reactid="351"><a href="/en-us/docs/admin/install/simple-monitor-center.html" target="_self" data-reactid="352">Install Simple monitor center</a></li><li class="menu-item menu-item-level-3" data-reactid="353"><a href="/en-us/docs/admin/install/admin-console.html" target="_self" data-reactid="354">Install admin console</a></li></ul></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="355"><span data-reactid="356"><!-- react-text: 357 -->Operation manual<!-- /react-text --><img style="transform:rotate(-90deg);" class="menu-toggle" src="/img/arrow_down.png" data-reactid="358"/></span><ul data-reactid="359"><li class="menu-item menu-item-level-3" data-reactid="360"><a href="/en-us/docs/admin/ops/dubbo-ops.html" target="_self" data-reactid="361">Admin console operation guide</a></li><li class="menu-item menu-item-level-3" data-reactid="362"><a href="/en-us/docs/admin/ops/pinpoint.html" target="_self" data-reactid="363">Tracking with Pinpoint</a></li><li class="menu-item menu-item-level-3" data-reactid="364"><a href="/en-us/docs/admin/ops/skywalking.html" target="_self" data-reactid="365">Tracking with Skywalking</a></li></ul></li></ul></li></ul></div><div class="doc-content markdown-body" data-reactid="366"><h1>Developing RESTful Remoting in Dubbo</h1>
<p><strong>Original author: Li Shen</strong></p>
<p><strong>Document copyright: <a href="HTTP://www.apache.org/licenses/LICENSE-2.0">Apache 2.0license Signature - No interpretation</a></strong></p>
<p>Working in progress ...</p>
<blockquote>
<p>This article is lengthy since REST involves many aspects. Besides, it refers to the document style of Spring and so on. Not only limited to usage of the framework but also strives to present the design concept of the framework and the architectural idea of an excellent application.</p>
</blockquote>
<blockquote>
<p>For people who only want to get a glimpse of Dubbo and REST, all they need is to browse through the <code>Overview</code> to <code>Introduction to Standard Java REST API: JAX-RS</code>.</p>
</blockquote>
<p>TODO: Generate a clickable directory</p>
<h2>CONTENT</h2>
<ul>
<li>Overview</li>
<li>Advantages of REST</li>
<li>Application Scenarios</li>
<li>Quick Start</li>
<li>Introduction to Standard Java REST API: JAX-RS</li>
<li>Details of REST Service Provider
<ul>
<li>Implementation of HTTP POST/GET</li>
<li>Should Annotation be Placed in the Interface or Implementation</li>
<li>Support for Multiple Data Formats (JSON, XML, etc.)</li>
<li>Support for Chinese Characters</li>
<li>Additional Requirements for XML Format</li>
<li>Custom Serialization</li>
<li>Configure the Implementation of REST Server</li>
<li>Access Context Data</li>
<li>Configure the Port Number and Context Path</li>
<li>Configure Number of Threads and IO Threads</li>
<li>Configure Persistent Connection</li>
<li>Configure Maximum Number of HTTP Connections</li>
<li>Configure Timeout and HTTP Connections Per Consumer</li>
<li>Gzip Data Compression</li>
<li>Replace Part of Spring XML Configuration With Annotation</li>
<li>Add Custom Filter, Interceptor, etc.</li>
<li>Add Custom Exception Handler</li>
<li>Configure HTTP Log Output</li>
<li>Verification of Input Parameters</li>
<li>Should REST Services be Published Transparently</li>
</ul>
</li>
<li>Details of REST Service Consumer
<ul>
<li>Scenario 1: Non-Dubbo Consumer Calls Dubbo REST Service</li>
<li>Scenario 2: Dubbo Consumer Calls Dubbo REST Service</li>
<li>Scenario 3: Dubbo Consumer Calls Non-Dubbo REST Service</li>
</ul>
</li>
<li>JAX-RS Restrictions in Dubbo</li>
<li>REST FAQ
<ul>
<li>Can Dubbo REST Services be Integrated With Dubbo Registration Center and Monitoring Center?</li>
<li>How to Implement Load Balancing and Failover in Dubbo REST?</li>
<li>Can Overloaded Methods in JAX-RS Map to Single URL?</li>
<li>Can a Method in JAX-RS Receive Multiple Parameters Via POST?</li>
</ul>
</li>
<li>Possible shortcomings of Current Dubbo System (Related to REST)
<ul>
<li>Invasiveness of Rpc Context</li>
<li>Limitations of Protocol Configuration</li>
<li>XML Naming Does Not Conform to the Convention of Spring</li>
</ul>
</li>
<li>REST Best Practices</li>
<li>Performance Benchmark
<ul>
<li>Test Environment</li>
<li>Test Script</li>
<li>Test Result</li>
</ul>
</li>
<li>Extended Discussion
<ul>
<li>Comparison of REST, Thrift, Protobuf, etc.</li>
<li>Comparison Between REST and Traditional Web Services</li>
<li>Comparison Between JAX-RS and Spring MVC</li>
</ul>
</li>
<li>Future</li>
</ul>
<h2>Overview</h2>
<p>Dubbo supports a variety of remote calling methods, such as Dubbo RPC (Binary Serialization + TCP), HTTP Invoker (Binary Serialization + HTTP, at least there is no support for Text Serialization in the open source version), Hessian (Binary Serialization + HTTP), Web Services (Text Serialization + HTTP), etc., but lacks support for trending RESTful Remote Calls (Text Serialization + HTTP).</p>
<p>Therefore, based on the standard Java REST API: JAX-RS 2.0 (Abbreviation of Java API for RESTful Web Services), we provide a mostly transparent REST Call support for Dubbo. Since it is fully compatible with the Standard Java API, all REST services developed for Dubbo may normally work without Dubbo or any specific underlying REST implementation.</p>
<p>It is particularly worth noting that we do not need to strictly adhere to the original definition and architectural style of REST. Even the famous Twitter REST API will make modest adjustments according to the situations, rather than mechanically follow the original REST style.</p>
<blockquote>
<p>Note: We call this feature RESTful Remoting (abstracted remote process or call) rather than a RESTful RPC (specific remote &quot;procedure&quot; call) because REST and RPC can be thought of two different styles. In Dubbo's REST implementation, there are two aspects, one is to provide or consume regular REST services, the other is to make REST a protocol implementation in the Dubbo RPC system, and RESTful Remoting covers both aspects.</p>
</blockquote>
<h2>Advantages of REST</h2>
<p>The following is quoted from Wikipedia:</p>
<ul>
<li>REST can use cache to improve response speed more efficiently.</li>
<li>The stateless nature of the communication allows a set of servers to handle different requests in series, resulting in the increment of server scalability.</li>
<li>Browser can be used as a client to simplify software requirements.</li>
<li>REST software dependency is smaller than other mechanisms superimposed on HTTP.</li>
<li>REST does not require additional resource discovery mechanism.</li>
<li>REST's long-term compatibility is better in software technology evolution.</li>
</ul>
<p>Here I also want to add a particular advantage of REST: REST bases on simple text format messages and universal HTTP. Therefore, it has a broad applicability and is supported by almost all languages and platforms, together with a lower threshold in using and learning.</p>
<h2>Application scenarios</h2>
<p>Because of the advantages of REST in applicability, supporting REST in Dubbo can bring (significant) benefits to most of current mainstream remoting call scenarios:</p>
<ol>
<li>
<p>Significantly simplify (cross-language) calls between heterogeneous systems within the enterprise. This is mainly for the following scene: Dubbo acts as a service provider, and systems that are written by other languages (including some java systems that do not base on Dubbo) works as service consumers. The two systems communicate through HTTP and text messages. REST has its unique advantages even comparing to binary cross-language RPC frameworks such as Thrift and ProtoBuf. (See discussion below)</p>
</li>
<li>
<p>Significantly simplify the development of the external Open API (Open Platform). You can use Dubbo to develop a specific Open API application, or you can directly publish the internal Dubbo service as a &quot;transparent&quot; REST API (Of course, it's better for Dubbo itself to provide more features transparently, for example, permission control, frequency control, billing and so on).</p>
</li>
<li>
<p>Significantly simplify the development of mobile (tablet) apps or desktop clients. Similar to point 2, you can use Dubbo to develop a specialized server for the applications, or transparently expose the internal Dubbo service. Of course in some projects, mobile or desktop applications can directly access the Open API described in point 2.</p>
</li>
<li>
<p>Significantly simplify the development of AJAX applications on the browser. Similar to point 2, you can use Dubbo to develop a specialized server for AJAX, or transparently expose the internal Dubbo service directly to JavaScript in the browser. Of course, many AJAX applications work better with web frameworks, so direct access to the Dubbo service may not be an exquisite architecture in many web projects.</p>
</li>
<li>
<p>Provide a text-based, easy-to-read remote call method for Dubbo systems within the enterprise (that is, both the service provider and the consumer are Dubbo-based systems).</p>
</li>
<li>
<p>Simplify the call from the Dubbo system to other heterogeneous systems. You can use a simple way like Dubbo to &quot;transparently&quot; call REST services provided by Non-Dubbo systems (regardless of whether the service provider is inside or outside the enterprise)</p>
</li>
</ol>
<p>It should be pointed out that I think that 1~3 are the most valuable application scenarios for Dubbo's REST call. And the main purpose why we add REST calls for Dubbo is to provide a service-oriented provider. In other words, to develop REST services for Non-Dubbo (heterogeneous) consumers.</p>
<p>To sum up, all application scenarios are shown below:
<img src="images/rest.jpg" alt="no image found"></p>
<p>Borrowing the most famous slogan of Java in the past, by adding REST calls to Dubbo, you can implement the &quot;Write once, access everywhere&quot; service, which can theoretically be accessed all over the world, thus truly achieving an idealized Service-oriented Architecture (SOA).</p>
<p>Of course, traditional Web Services (WSDL/SOAP) can meet the requirements (even those that require enterprise-level features) of the above scenarios (except for scenario 4). But due to the complexity and other issues, they are less and less used.</p>
<h2>Quick Start</h2>
<p>Developing a RESTful service in Dubbo is relatively straightforward. Let's take a simple user registration service for example.</p>
<p>The function to be implemented by this service is to provide the following URL (Note: This URL is not entirely RESTful, but more straightforward and more practical):</p>
<pre><code>http://localhost:8080/users/register
</code></pre>
<p>Any client can POST a JSON string containing the user's information to the above URL to complete the user registration.</p>
<p>First, implement the interface of the service:</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>{    
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerUser</span><span class="hljs-params">(User user)</span></span>;
}
</code></pre>
<p>Then, implement the service:</p>
<pre><code class="language-java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>{
       
    <span class="hljs-meta">@POST</span>
    <span class="hljs-meta">@Path</span>(<span class="hljs-string">"register"</span>)
    <span class="hljs-meta">@Consumes</span>({MediaType.APPLICATION_JSON})
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerUser</span><span class="hljs-params">(User user)</span> </span>{
        <span class="hljs-comment">// save the user...</span>
    }
}
</code></pre>
<p>The above implementation code for the service is very simple, but since the REST service is to be published to a specific HTTP URL so they can be accessed by clients written by any language or even a browser, there are a few additional JAX-RS standard annotations to be added for the relevant configuration:</p>
<p>@Path(&quot;users&quot;): Specify that the relative path for <code>UserService</code> is <code>/users</code>, standing for <a href="http://localhost:8080/users">http://localhost:8080/users</a></p>
<p>@Path(&quot;register&quot;): Specify that the relative path for <code>registerUser()</code> is <code>/register</code>. Combining the previous @Path specified for <code>UserService</code>, the URL to call <code>UserService.register()</code> is <a href="HTTP://localhost:8080/users/register">HTTP://localhost:8080/users/register</a></p>
<p>@POST: Specify that <code>registerUser()</code> should be accessed with HTTP POST method</p>
<p>@Consumes({MediaType.APPLICATION_JSON}): Specify that <code>registerUser()</code> receives data in JSON format. The REST framework will automatically deserialize JSON data into a User object.</p>
<p>Finally, add this service to the spring configuration file and finish all service development work:</p>
<pre><code class="language-xml"><span class="hljs-comment">&lt;!-- Exposure service on port 8080 with rest protocol --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span>/&gt;</span>

<span class="hljs-comment">&lt;!-- Declare the service interface that needs to be exposed --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"xxx.UserService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"userService"</span>/&gt;</span>

<span class="hljs-comment">&lt;!-- Implement the service like the local bean --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"xxx.UserServiceImpl"</span> /&gt;</span>
</code></pre>
<h2>Introduction to Standard Java REST API: JAX-RS</h2>
<p>JAX-RS is a standard Java REST API that has been widely supported and applied in the industry. There are many well-known open source implementations, including Oracle's Jersey, RedHat's RestEasy, Apache's CXF and Wink, restlet, etc. In addition, all commercial JavaEE application servers that support the JavaEE 6.0 specifications or above support JAX-RS. Therefore, JAX-RS is a very mature solution, and it does not have any so-called vendor lock-in problems.</p>
<p>JAX-RS has a wealth of information on the web, such as the following introductory tutorial:</p>
<ul>
<li>Oracle official tutorial: <a href="http://docs.oracle.com/javaee/7/tutorial/doc/jaxrs.htm">http://docs.oracle.com/javaee/7/tutorial/doc/jaxrs.htm</a></li>
<li>Article on IBM developerWorks China: <a href="http://www.ibm.com/developerworks/cn/java/j-lo-jaxrs/">http://www.ibm.com/developerworks/cn/java/j-lo-jaxrs/</a></li>
</ul>
<p>For more information, please feel free to Google or Baidu. As far as learning JAX-RS is concerned, it is generally enough to master the usage of various annotations.</p>
<blockquote>
<p>Note: Dubbo is based on the JAX-RS 2.0, and sometimes you need to pay attention to the version of the reference material or REST implementation.</p>
</blockquote>
<h2>REST Service Provider Details</h2>
<p>In this section, we will expand the <code>UserService</code> in the &quot;Quick Start&quot; to further demonstrate the development points of the REST service provider in Dubbo.</p>
<h3>Implementation of HTTP POST/GET</h3>
<p>Although it's recommended to use the four standard methods (POST, DELETE, PUT and GET) in the HTTP protocol to implement common CRUD in REST services, but in practice, we generally use POST to implement create and update, and use GET to implement delete and read (DELETE and PUT will even be blocked by some firewalls).</p>
<p>The implementation of POST has already been briefly demonstrated. Here, we will add a function to get the registered user data to <code>UserService</code>, in order to demonstrate the implementation of GET.</p>
<p>This function is to enable the client to obtain user data of different IDs by accessing different URLs as follows:</p>
<pre><code>http://localhost:8080/users/1001
http://localhost:8080/users/1002
http://localhost:8080/users/1003
</code></pre>
<p>Of course, you can use other forms of URLs to access user data of different IDs, for example:</p>
<pre><code>http://localhost:8080/users/load?id=1001
</code></pre>
<p>JAX-RS itself can support all of these forms. However, the first form of including query parameters in the URL path (<a href="http://localhost:8080/users/1001">http://localhost:8080/users/1001</a>) is more in line with the general habit of REST, so it is recommended to use. Below we will add a <code>getUser()</code> method to the <code>UserService</code> to implement this form of URL access:</p>
<pre><code class="language-java"><span class="hljs-meta">@GET</span>
<span class="hljs-meta">@Path</span>(<span class="hljs-string">"{id : \\d+}"</span>)
<span class="hljs-meta">@Produces</span>({MediaType.APPLICATION_JSON})
<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id) </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>@GET: Specify that the method shoule be accessed with HTTP GET method</p>
<p>@Path(&quot;{id : \d+}&quot;): According to the above functional requirements, the URL to access <code>getUser()</code> should be &quot;<a href="http://localhost:8080/users/">http://localhost:8080/users/</a> + any number&quot;, and this number should passed to <code>getUser()</code> method as parameter passed to the getUser() method. In the annotation here, the {id: xxx} in @Path specifies that the relative path contains the id parameter, and its value will be automatically passed to the method parameter <code>id</code> annotated with @PathParam(&quot;id&quot;). <code>\d+</code> following <code>{id:</code> is a regular expression specifies that the id parameter must be a number.</p>
<p>@Produces({MediaType.APPLICATION_JSON}): Specify that <code>getUser()</code> outputs data in JSON format. The REST framework automatically serializes the User object into JSON data.</p>
<h3>Is annotation put in interface class or implementation class?</h3>
<p>The development of REST services based on Dubbo is mainly configured through JAX-RS annotations. In the above example, we put the annotation in the implementation class of the service. But in fact, we can completely put the annotation in the interface of the service. These two methods are completely equivalent, for example:</p>
<pre><code class="language-java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>{
    
    <span class="hljs-meta">@GET</span>
    <span class="hljs-meta">@Path</span>(<span class="hljs-string">"{id : \\d+}"</span>)
    <span class="hljs-meta">@Produces</span>({MediaType.APPLICATION_JSON})
    <span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
}
</code></pre>
<p>In a typical application, we recommend put the annotation in the service implementation class. Then, annotations are closer to Java implementation code and easier to develop and maintain. More importantly, we generally tend to avoid contamination of the interface, maintaining the purity and wide applicability of the interface.</p>
<p>However, as will be described later, if we access this service by using the consumer directly developed by Dubbo, the annotation must be put in the interface.</p>
<p>If the interface and the implementation class are both added annotation at the same time, the implementation configuration of the implementation class will take effect, and the annotation on the interface will be ignored.</p>
<h3>Support for JSON, XML and other data formats</h3>
<p>The dubbo REST services can support the transmission of data in multiple formats to provide maximum flexibility to the client. And we add extra functions to the JSON and XML formats which is most commonly used.</p>
<p>For example, we want the <code>getUser()</code> method in the above example support returning JSON and XML format data separately, just need to include two formats in the annotation:</p>
<pre><code class="language-java"><span class="hljs-meta">@Produces</span>({MediaType.APPLICATION_JSON, MediaType.TEXT_XML})
<span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
</code></pre>
<p>Or you can directly represent a MediaType with a string (also supports wildcards):</p>
<pre><code class="language-java"><span class="hljs-meta">@Produces</span>({<span class="hljs-string">"application/json"</span>, <span class="hljs-string">"text/xml"</span>})
<span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
</code></pre>
<p>If all methods support the same type of input and output data format, then we do not need to make configure on each method, just add annotation to the service class:</p>
<pre><code class="language-java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-meta">@Consumes</span>({MediaType.APPLICATION_JSON, MediaType.TEXT_XML})
<span class="hljs-meta">@Produces</span>({MediaType.APPLICATION_JSON, MediaType.TEXT_XML})
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>In the case where a REST service supports multiple data formats, according to the JAX-RS standard, the MIME header (content-type and accept) in HTTP is generally used to specify which format data is currently used.</p>
<p>But in dubbo, we also automatically support the current common use of the industry, that is, use a URL suffix (.json and .xml) to specify the data format you want to use. For example, after adding the above annotation, directly accessing <code>http://localhost:8888/users/1001.json</code> means using the json format, and directly accessing <code>http://localhost:8888/users/1002.xml</code> means using the xml format. It's simpler and more intuitive than using HTTP Header. This way is used by the REST APIs of Twitter, Weibo, etc.</p>
<p>If you don't add HTTP header or suffix, the REST of dubbo will give priority to enable the top ranked data format in the above definition of annotation.</p>
<blockquote>
<p>Note: To support XML format data, you can use either <code>MediaType.TEXT_XML</code> or <code>MediaType.APPLICATION_XML</code> in annotation, but TEXT_XML is more commonly used, and if you want to use the above URL suffix to specify the data format, you can only configure it as TEXT_XML to take effect.</p>
</blockquote>
<h3>Chinese character support</h3>
<p>In order to output Chinese characters normally in dubbo REST, as with the usual Java web applications, we need to set the contentType of the HTTP response to UTF-8 encoding.</p>
<p>Based on the standard usage of JAX-RS, we only need to do the following annotation configuration:</p>
<pre><code class="language-java"><span class="hljs-meta">@Produces</span>({<span class="hljs-string">"application/json; charset=UTF-8"</span>, <span class="hljs-string">"text/xml; charset=UTF-8"</span>})
<span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
</code></pre>
<p>For the convenience of users, we add a support class directly in dubbo REST to define the above constants, which can be used directly and reduce the possibility of error.</p>
<pre><code class="language-java"><span class="hljs-meta">@Produces</span>({ContentType.APPLICATION_JSON_UTF_8, ContentType.TEXT_XML_UTF_8})
<span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
</code></pre>
<h3>Additional requirements for XML data format</h3>
<p>Because the implementation of JAX-RS generally use standard JAXB (Java API for XML Binding) to serialize and deserialize XML format data, we need to add a class-level JAXB annotation for each object to be transferred in XML. Otherwise serialization will report an error. For example, add follows to the User returned in <code>getUser()</code> :</p>
<pre><code class="language-java"><span class="hljs-meta">@XmlRootElement</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>In addition, if the return value in the service method is Java primitive type (such as int, long, float, double, etc.), it is best to add a wrapper object to them, because JAXB can not directly serialize the primitive type.</p>
<p>For example, we want the above <code>registerUser()</code> method to return the ID number generated by the server for the user:</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">registerUser</span><span class="hljs-params">(User user)</span></span>;
</code></pre>
<p>Because the primitive type is not supported by JAXB serialization, add a wrapper object:</p>
<pre><code class="language-java"><span class="hljs-meta">@XmlRootElement</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegistrationResult</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{

    <span class="hljs-keyword">private</span> Long id;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RegistrationResult</span><span class="hljs-params">()</span> </span>{
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RegistrationResult</span><span class="hljs-params">(Long id)</span> </span>{
        <span class="hljs-keyword">this</span>.id = id;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> id;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Long id)</span> </span>{
        <span class="hljs-keyword">this</span>.id = id;
    }
}
</code></pre>
<p>And modify the service method:</p>
<pre><code class="language-java"><span class="hljs-function">RegistrationResult <span class="hljs-title">registerUser</span><span class="hljs-params">(User user)</span></span>;
</code></pre>
<p>This not only solves the problem of XML serialization, but also makes the returned data conform to the specifications of XML and JSON. For example, in JSON, the returned form would be as follows:</p>
<pre><code class="language-javascript">{<span class="hljs-string">"id"</span>: <span class="hljs-number">1001</span>}
</code></pre>
<p>If you do not add a wrapper, the JSON return value will be directly</p>
<pre><code>1001 	
</code></pre>
<p>In XML, the return value after adding wrapper will be:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">registrationResult</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>1002<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">registrationResult</span>&gt;</span>
</code></pre>
<p>This wrapper object actually uses the so-called Data Transfer Object (DTO) mode, and DTO can also make more useful customizations for transferring data.
While in XML, after adding wrapper, the return value will be</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">registrationResult</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>1002<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">registrationResult</span>&gt;</span>
</code></pre>
<p>In fact, this wrapper object uses the so-called Data Transfer Object (DTO) mode. DTO can also be used to make more useful customizations to transfer data.</p>
<h3>Custom Serialization</h3>
<p>As mentioned above, the underlying implementation of REST will automatically serialize/deserialize between the service object and the JSON/XML data format.</p>
<p>The REST implementation in Dubbo uses JAXB for XML serialization and Jackson for JSON serialization,so you can customize the mapping by adding JAXB or Jackson's annotation to the object.</p>
<p>For example, customizing the object properties to map to the names of the XML elements:</p>
<pre><code class="language-java"><span class="hljs-meta">@XmlRootElement</span>
<span class="hljs-meta">@XmlAccessorType</span>(XmlAccessType.FIELD)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{

    <span class="hljs-meta">@XmlElement</span>(name=<span class="hljs-string">"username"</span>)
    <span class="hljs-keyword">private</span> String name;  
}
</code></pre>
<p>Customizing the object properties to map to the names of the JSON field:</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{

    <span class="hljs-meta">@JsonProperty</span>(<span class="hljs-string">"username"</span>)
    <span class="hljs-keyword">private</span> String name;
}
</code></pre>
<p>For more information, please refer to the official documentation of JAXB and Jackson, or google yourself.</p>
<h3>Configuring REST Server implementation</h3>
<p>Currently in dubbo, we support the implementation of five embedded rest servers. The implementation of the rest server is selected by the following XML attribute of the server:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"jetty"</span>/&gt;</span>
</code></pre>
<p>The above configuration uses the embedded jetty to do the rest server. At the same time, if you do not configure the server attribute, the rest protocol also uses jetty by default. jetty is a very mature java servlet container and has a good integration with dubbob (Among the five embedded servers, Only jetty and later tomcat、tjws, complete seamless integration with Dubbo monitoring system.), so, if your dubbo system is a separate process, you can use jetty by default.</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"tomcat"</span>/&gt;</span>
</code></pre>
<p>The above configuration uses the embedded tomcat to do the rest server.On embedded tomcat, REST performance is much better than jetty (See the benchmark below). It is recommended that Tomcat is used in scenarios where high performance is required.</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"netty"</span>/&gt;</span>
</code></pre>
<p>The above configuration uses embedded netty to do the rest server. (TODO more contents to add)</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"tjws"</span>/&gt;</span> (tjws is now deprecated)
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"sunhttp"</span>/&gt;</span>
</code></pre>
<p>The above configuration uses embedded tjws or Sun HTTP server to do the rest server. These two server implementations are very lightweight, it is very convenient for quick start-up in integration testing, of course, it can also be used in a production environment with low load. Note: tjws is currently deprecated because it does not work well with the servlet 3.1 API.</p>
<p>If your dubbo system is not a separate process,
instead of deploying to a Java application server, we recommend the following configuration:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"servlet"</span>/&gt;</span>
</code></pre>
<p>By setting the server as the servlet, dubbo will use the servlet container of the external application server to do the rest server. At the same time, add the following configuration to the web.xml of the dubbo system:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>/WEB-INF/classes/META-INF/spring/dubbo-demo-provider.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>com.alibaba.dubbo.remoting.http.servlet.BootstrapListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.alibaba.dubbo.remoting.http.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span>
</code></pre>
<p>In other words, you must add dubbo's BootstrapListener and DispatherServlet to web.xml to complete the integration of dubbo's REST functionality with the external servlet container.</p>
<blockquote>
<p>Note:If you are using spring's ContextLoaderListener to load spring, you must ensure that the BootstrapListener is configured before the ContextLoaderListener, otherwise the dubbo initialization will fail.</p>
</blockquote>
<p>In fact, you can still stick to the embedded server in this scenario, but the servlet container of the external application server is often more powerful than the embedded server(Especially if you are deploying to a more robust and scalable WebLogic, WebSphere, etc.). In addition, it is sometimes convenient to do unified management, monitoring, and so on in the application server.</p>
<h3>Get Context Information</h3>
<p>Varieties of context information are valuable when calling procedures remotely. For instance, the IP address from the Client.</p>
<p>We provide two methods to get the Client's IP in dubbo.</p>
<p>The first one is using @Context annotation from JAX-RS:</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id, @Context HttpServletRequest request) </span>{
    System.out.println(<span class="hljs-string">"Client address is "</span> + request.getRemoteAddr());
} 
</code></pre>
<p>After decorating a parameter of <code>getUser()</code> with Context, we can inject the current HttpServletRequest and then call the servlet api to get the IP.</p>
<blockquote>
<p>Notice: This method can only be used when the server is one of the followings: twjs, tomecat, jetty or servlet. All of them provide servlet container. In addition, standard JAX-RS also allow us to get HttpServletRequest using an instance field in service Class decorated by <code>@Context</code>.</p>
</blockquote>
<p>The second method is to use RpcContext, which is commonly seen in dubbo:</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id) </span>{
    System.out.println(<span class="hljs-string">"Client address is "</span> + RpcContext.getContext().getRemoteAddressString());
} 
</code></pre>
<blockquote>
<p>Notice: Similarly, this method only works in the jetty, tomcat, servlet or tjws server. In dubbo, the usage of RpcContext is rather invasive. We are likely to refactor it in the future.</p>
</blockquote>
<p>The first method is suggested when your project may run without dubbo and need the compatibility with JAX-RS. But if you want a more elegant service interface definition, the second method would be the better choice.</p>
<p>What's more, in the newest version of dubbo REST service, RpcContext could be used to get HttpServletRequest and HttpServletResponse, providing great flexibility for users to implement some complex functions. The following is an example:</p>
<pre><code class="language-java"><span class="hljs-keyword">if</span> (RpcContext.getContext().getRequest() != <span class="hljs-keyword">null</span> &amp;&amp; RpcContext.getContext().getRequest() <span class="hljs-keyword">instanceof</span> HttpServletRequest) {
    System.out.println(<span class="hljs-string">"Client address is "</span> + ((HttpServletRequest) RpcContext.getContext().getRequest()).getRemoteAddr());
}

<span class="hljs-keyword">if</span> (RpcContext.getContext().getResponse() != <span class="hljs-keyword">null</span> &amp;&amp; RpcContext.getContext().getResponse() <span class="hljs-keyword">instanceof</span> HttpServletResponse) {
    System.out.println(<span class="hljs-string">"Response object from RpcContext: "</span> + RpcContext.getContext().getResponse());
}
</code></pre>
<blockquote>
<p>Notice:
In order to maintain the neutrality of the protocol, <code>RpcContext.getRequest()</code> and <code>RpcContext.getResponse()</code> only return an Object which could be null. Therefore, you have to check the type on your own.</p>
</blockquote>
<blockquote>
<p>Notice: only when you use jetty, tomcat, servlet as the server can you get the HttpServletRequest and HttpServletResponse as expected. Because only these server
implemented the servlet container.</p>
</blockquote>
<p>To simplify the programme, you can also use generic to get a specific type of request/response:</p>
<pre><code class="language-java"><span class="hljs-keyword">if</span> (RpcContext.getContext().getRequest(HttpServletRequest.class) != <span class="hljs-keyword">null</span>) {
    System.out.println(<span class="hljs-string">"Client address is "</span> + RpcContext.getContext().getRequest(HttpServletRequest.class).getRemoteAddr());
}

<span class="hljs-keyword">if</span> (RpcContext.getContext().getResponse(HttpServletResponse.class) != <span class="hljs-keyword">null</span>) {
    System.out.println(<span class="hljs-string">"Response object from RpcContext: "</span> + RpcContext.getContext().getResponse(HttpServletResponse.class));
}
</code></pre>
<p>If request/response does not correspond to the specific type, it would return null.</p>
<h3>Configure The Port Number and Context Path</h3>
<p>The REST protocol in dubbo use 80 as the default port. But you are also allowed to modify it:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span>/&gt;</span>
</code></pre>
<p>As what have been metioned before, we can use <code>@Path</code> to configure relative URL path in single REST service. In fact, we can also set a basic relative path which is known as context path for all REST service.</p>
<p>All we need to do is to add the contextpath property:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">contextpath</span>=<span class="hljs-string">"services"</span>/&gt;</span>
</code></pre>
<p>Let's have a look at the previous code:</p>
<pre><code class="language-java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>{
       
    <span class="hljs-meta">@POST</span>
    <span class="hljs-meta">@Path</span>(<span class="hljs-string">"register"</span>)
    <span class="hljs-meta">@Consumes</span>({MediaType.APPLICATION_JSON})
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerUser</span><span class="hljs-params">(User user)</span> </span>{
        <span class="hljs-comment">// save the user...</span>
    }	
}
</code></pre>
<p>Now the complete path would be:</p>
<pre><code>http://localhost:8888/services/users/register
</code></pre>
<p>Notice: If you use external server as REST server, you should configure as followings,</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">contextpath</span>=<span class="hljs-string">"services"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"servlet"</span>/&gt;</span>
</code></pre>
<p>meaning that you should keep the config of port and contextpath are the same with the port and DispatcherServlet's context path (webapp path + servlet url pattern) in external server. For example, when we are configuring the application on tomcat Root path, we need to make sure the contextpath here is totally the same with the <code>&lt;url-pattern/&gt;</code> of DispacherServlet in web.xml:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/services/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>
</code></pre>
<h3>Configure the number of threads and IO threads</h3>
<p>We can set the number of threads of rest service:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">threads</span>=<span class="hljs-string">"500"</span>/&gt;</span>
</code></pre>
<blockquote>
<p>Notice: Currently, the setting only works when the server is netty, jetty or tomcat. If you use servlet as the server, you are using the external server as the REST server which is out of dubboes' control, so the setting would not work expectedly.</p>
</blockquote>
<p>You can also set threads number of IO worker of netty server:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">iothreads</span>=<span class="hljs-string">"5"</span> <span class="hljs-attr">threads</span>=<span class="hljs-string">"100"</span>/&gt;</span>
</code></pre>
<h3>Configure long connections</h3>
<p>The REST service in Dubbo is accessed by default with http long connection, if you want to switch to short connection, you can configure it as below:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">keepalive</span>=<span class="hljs-string">"false"</span>/&gt;</span>
</code></pre>
<blockquote>
<p>Notice: This configuration only works in netty and tomcat.</p>
</blockquote>
<h3>Configure the maximum number of HTTP connections</h3>
<p>Configuring the maximum number of HTTP connections can prevent REST server from
overload as the basic self-protection mechanism.</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">accepts</span>=<span class="hljs-string">"500"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"tomcat/&gt;
</span></span></code></pre>
<blockquote>
<p>Notice: Currently, it only works in tomcat.</p>
</blockquote>
<h3>Configuring the timeout and HTTP connections for each consumer</h3>
<p>If the consumer of the rest service is also a dubbo system, you can configure the maximum timeout for the consumer to call the rest service, and the maximum number of HTTP connections that each consumer can initiate, just like other dubbo RPC mechanisms.</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"2000"</span> <span class="hljs-attr">connections</span>=<span class="hljs-string">"10"</span>/&gt;</span>
</code></pre>
<p>Of course, since this configuration is valid for the consumer, it can also be configured on the consumer side:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"2000"</span> <span class="hljs-attr">connections</span>=<span class="hljs-string">"10"</span>/&gt;</span>
</code></pre>
<p>However, we generally recommend configuring the service provider to provide such a configuration. According to the official dubbo documentation, “Provider should configure the properties of the Consumer side as much as possible.
Let the Provider implementer think about the service features and service quality of the Provider from the beginning.”</p>
<blockquote>
<p>Note: If dubbo REST service is released to non-dubbo clients, the configuration on <code>&lt;dubbo:service/&gt;</code> is completely invalid because the client is not under dubbo control.</p>
</blockquote>
<h3>GZIP data compresssion</h3>
<p>Dubbo RESTful Remoting supports the use of Gzip to compress request and response data to reduce network transmission time and bandwidth consumption, but this will also increase CPU overhead.</p>
<p>TODO more contents to add.</p>
<h3>Replacing part of the spring XML configuration with annotation</h3>
<p>Above discussions are based on the XML configuration of Dubbo in spring.
However, dubbo/spring itself supports the use of annotation for configuration, so we can also follow the steps in the Dubbo document and add the relevant annotation to the REST service implementation, replacing some XML configurations, such as:</p>
<pre><code class="language-java"><span class="hljs-meta">@Service</span>(protocol = <span class="hljs-string">"rest"</span>)
<span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserRepository userRepository;
       
    <span class="hljs-meta">@POST</span>
    <span class="hljs-meta">@Path</span>(<span class="hljs-string">"register"</span>)
    <span class="hljs-meta">@Consumes</span>({MediaType.APPLICATION_JSON})
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerUser</span><span class="hljs-params">(User user)</span> </span>{
        <span class="hljs-comment">// save the user</span>
        userRepository.save(user);
    }	
}
</code></pre>
<p>Annotation-based configuration is more concise and precise, and often easier to maintain (modern IDE can support such things as class name refactoring in XML, and therefore the maintenance of XML is good for specific use cases here). XML is less intrusive to code, especially for dynamically modifying configurations, especially when you want to modify the timeout for connection of a single service configuration, the maximum number of connections per client, cluster policy, weights, and so on. In addition, for complex applications or modules, XML provides a central point to cover all the components and configurations. It is at a glance, and generally more convenient for long term maintenance of the project.</p>
<p>Of course, there's no right or wrong of different choices of configuration method. Sometimes it's just personal preference.</p>
<h3>Adding a custom Filter, Interceptor, etc</h3>
<p>Dubbo RESTful Remoting also supports JAX-RS standard Filter and Interceptor to facilitate customized interception of REST request and response processes.</p>
<p>Here, Filter is mainly used to access and set parameters, URIs for HTTP request and response, and so on, for example, setting the cache header for HTTP response:</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheControlFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ContainerResponseFilter</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filter</span><span class="hljs-params">(ContainerRequestContext req, ContainerResponseContext res)</span> </span>{
        <span class="hljs-keyword">if</span> (req.getMethod().equals(<span class="hljs-string">"GET"</span>)) {
            res.getHeaders().add(<span class="hljs-string">"Cache-Control"</span>, <span class="hljs-string">"someValue"</span>);
        }
    }
}
</code></pre>
<p>Interceptor is mainly used to access and modify the input and output byte streams, for example, manually adding GZIP compression:</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GZIPWriterInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WriterInterceptor</span> </span>{
 
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">aroundWriteTo</span><span class="hljs-params">(WriterInterceptorContext context)</span>
                    <span class="hljs-keyword">throws</span> IOException, WebApplicationException </span>{
        OutputStream outputStream = context.getOutputStream();
        context.setOutputStream(<span class="hljs-keyword">new</span> GZIPOutputStream(outputStream));
        context.proceed();
    }
}
</code></pre>
<p>In standard JAX-RS applications, we generally add @Provider annotations to Filter and Interceptor, and JAX-RS runtime will automatically discover and enable them. In Dubbo, we register Filter and Interceptor by adding an XML configuration:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">extension</span>=<span class="hljs-string">"xxx.TraceInterceptor, xxx.TraceFilter"</span>/&gt;</span>
</code></pre>
<p>Here, we can add these three types of objects, Filter, Interceptor and DynamicFuture, to the <code>extension</code> attributes, separated by commas. (DynamicFuture is another interface that allows us to enable Filter and Interceptor more dynamically. Please feel free to google.)</p>
<p>Of course, Dubbo itself also supports Filter, but the Filter and Interceptor we discuss here are more like the bottom of the protocol implementation. Compared to Dubbo's filter, you can do a lower level of customization here.</p>
<blockquote>
<p>Note: The XML attribute here is called extension, not interceptor or filter. That is because we will add more extension types in addition to Interceptor and Filter in the future.</p>
</blockquote>
<p>If the REST consumer is also a Dubbo system (see discussion below), you can also configure the Interceptor and Filter for the consumer in a similar way.</p>
<p>However, it should be noted that the consumer-side Filter and the provider-side Filter in JAX-RS are two different interfaces. For example, in the previous example, the server is the ContainerResponseFilter interface, and the consumer side corresponds to the ClientResponseFilter:</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoggingFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ClientResponseFilter</span> </span>{
 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filter</span><span class="hljs-params">(ClientRequestContext reqCtx, ClientResponseContext resCtx)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        System.out.println(<span class="hljs-string">"status: "</span> + resCtx.getStatus());
	    System.out.println(<span class="hljs-string">"date: "</span> + resCtx.getDate());
	    System.out.println(<span class="hljs-string">"last-modified: "</span> + resCtx.getLastModified());
	    System.out.println(<span class="hljs-string">"location: "</span> + resCtx.getLocation());
	    System.out.println(<span class="hljs-string">"headers:"</span>);
	    <span class="hljs-keyword">for</span> (Entry&lt;String, List&lt;String&gt;&gt; header : resCtx.getHeaders().entrySet()) {
     	    System.out.print(<span class="hljs-string">"\t"</span> + header.getKey() + <span class="hljs-string">" :"</span>);
	        <span class="hljs-keyword">for</span> (String value : header.getValue()) {
	            System.out.print(value + <span class="hljs-string">", "</span>);
	        }
	        System.out.print(<span class="hljs-string">"\n"</span>);
	    }
	    System.out.println(<span class="hljs-string">"media-type: "</span> + resCtx.getMediaType().getType());
    } 
}
</code></pre>
<h3>Adding custom Exception handler</h3>
<p>Dubbo RESTful Remoting also supports JAX-RS standard ExceptionMapper, which can be used to customize the HTTP response after a particular exception occurs.</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomExceptionMapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExceptionMapper</span>&lt;<span class="hljs-title">NotFoundException</span>&gt; </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">toResponse</span><span class="hljs-params">(NotFoundException e)</span> </span>{     
        <span class="hljs-keyword">return</span> Response.status(Response.Status.NOT_FOUND).entity(<span class="hljs-string">"Oops! the requested resource is not found!"</span>).type(<span class="hljs-string">"text/plain"</span>).build();
    }
}
</code></pre>
<p>Similar to Interceptor and Filter, it can be enabled by adding it to an XML configuration file:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">extension</span>=<span class="hljs-string">"xxx.CustomExceptiionMapper"</span>/&gt;</span>
</code></pre>
<h3>Configuring HTTP log output</h3>
<p>Dubbo RESTful Remoting supports outputting the header and body in all HTTP requests/responses.</p>
<p>Add the following REST filter to the XML configuration:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">extension</span>=<span class="hljs-string">"com.alibaba.dubbo.rpc.protocol.rest.support.LoggingFilter"</span>/&gt;</span>
</code></pre>
<p><strong>Then turn on at least INFO level log output for com.alibaba.dubbo.rpc.protocol.rest.support in the logging configuration</strong>,for example,in log4j.xml:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.alibaba.dubbo.rpc.protocol.rest.support"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"INFO"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"CONSOLE"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span>
</code></pre>
<p>Of course, you can also turn on INFO level log output directly in the ROOT logger:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"INFO"</span> /&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"CONSOLE"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
</code></pre>
<p>Then there will be something like the following output in the log:</p>
<pre><code>The HTTP headers are: 
accept: application/json;charset=UTF-8
accept-encoding: gzip, deflate
connection: Keep-Alive
content-length: 22
content-type: application/json
host: 192.168.1.100:8888
user-agent: Apache-HttpClient/4.2.1 (java 1.5)
</code></pre>
<pre><code>The contents of request body is: 
{&quot;id&quot;:1,&quot;name&quot;:&quot;dang&quot;}
</code></pre>
<p>After the HTTP log output is turned on, in addition to the performance overhead of the normal log output, additional overhead is generated in, for example, HTTP request parsing, because an additional memory buffer needs to be allocated to prepare the data for the log output.</p>
<h3>Inputing parameter validation</h3>
<p>Dubbo RESTful Remoting supports the use of the Java standard bean validation annotation(JSR 303) for input validation <a href="http://beanvalidation.org/">http://beanvalidation.org/</a>.</p>
<p>In order to be consistent with other Dubbo remote invocation protocols, the annotations that are checked for rest must be placed on the interface of the service, for example:</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>{
   
    <span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@Min(value=<span class="hljs-number">1</span>L, message=<span class="hljs-string">"User ID must be greater than 1"</span>)</span> Long id)</span>;
}
</code></pre>
<p>Of course, in many other bean validation scenarios, annotations are placed on implementation classes rather than interfaces. At least one advantage of placing an annotation on an interface is that the Dubbo client can share information about the interface. The input validation can be done locally even without RPC.</p>
<p>Then turn on the validation in the XML configuration in the same way as Dubbo:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">xxx.UserService</span>" <span class="hljs-attr">ref</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">validation</span>=<span class="hljs-string">"true"</span>/&gt;</span>
</code></pre>
<p>In many other RPC protocols of Dubbo, if the input validation error occurs, the <code>RpcException</code> is directly thrown to the client, but in the rest, since the client is often non-Dubbo or even non-Java system, it is inconvenient to directly throw a Java exception.  Therefore, at present we will return the validation error in XML format:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">violationReport</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">constraintViolations</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>getUserArgument0<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span>User ID must be greater than 1<span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">constraintViolations</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">violationReport</span>&gt;</span>
</code></pre>
<p>The return values of other data formats will also be supported later. As for how to internationalize the verification error message, refer directly to the relevant documentation of the bean validation.</p>
<p>If you think that the default validation error return format does not meet your requirements, you can add custom ExceptionMapper to custom error return format freely as described in the previous section. It should be noted that this ExceptionMapper must use the generic declaration to capture the RpcException of Dubbo in order to successfully override the default exception handling strategy of Dubbo rest. In order to simplify the operation, the easiest way to do this is to directly inherit the RpcExceptionMapper of Dubbo rest and override the method that handles the validation exception:</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyValidationExceptionMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RpcExceptionMapper</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">protected</span> Response <span class="hljs-title">handleConstraintViolationException</span><span class="hljs-params">(ConstraintViolationException cve)</span> </span>{
        ViolationReport report = <span class="hljs-keyword">new</span> ViolationReport();
        <span class="hljs-keyword">for</span> (ConstraintViolation cv : cve.getConstraintViolations()) {
            report.addConstraintViolation(<span class="hljs-keyword">new</span> RestConstraintViolation(
                    cv.getPropertyPath().toString(),
                    cv.getMessage(),
                    cv.getInvalidValue() == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"null"</span> : cv.getInvalidValue().toString()));
        }
        <span class="hljs-comment">// Use json output instead of xml output</span>
        <span class="hljs-keyword">return</span> Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(report).type(ContentType.APPLICATION_JSON_UTF_8).build();
    }
}
</code></pre>
<p>Then add this ExceptionMapper to the XML configuration:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">extension</span>=<span class="hljs-string">"xxx.MyValidationExceptionMapper"</span>/&gt;</span>
</code></pre>
<h3>Whether to transparently publish REST service</h3>
<p>Dubbo RESTful Remoting differs from some other RPCs in Dubbo in that you need to add JAX-RS annotations (and JAXB, Jackson's annotation) to your service code. If you think these annotations &quot;pollute&quot; your service code to a certain extent,you can consider writing additional Facade and DTO classes, adding annotations to that, and Facade forwards the calls to the real service implementation class. Of course, adding annotations directly to the service code basically has no negative effects, and this is itself a standard usage in Java EE. In addition, JAX-RS and JAXB annotations belong to the Java standard. Compared with spring, Dubbo, etc., which we often use, annotations have no problem with vendor lock-in, so there is usually no need to introduce additional objects.</p>
<p>In addition,when you want to use the @Context annotation mentioned above, injecting HttpServletRequest through method parameters (such as <code>public User getUser(@PathParam(&quot;id&quot;) Long id, @Context HttpServletRequest request)</code>), the method signature of service is changed and HttpServletRequest is a REST-specific parameter, you should introduce additional Facade classes if your service supports multiple RPC mechanisms.</p>
<p>Of course, your service code may already act as a Facade and DTO before adding RESTful Remoting (as to why some scenarios require these roles, and if you are interested, you can refer to [Micro-SOA: Service Design Principles and Practices] <a href="Http://www.infoq.com/cn/articles/micro-soa-1">Http://www.infoq.com/cn/articles/micro-soa-1</a>). In this case, after adding REST, if you add additional REST-related Facade and DTO, it is equivalent to wrapping the original code again, which forms the following call chain:</p>
<p><code>RestFacade/RestDTO -&gt; Facade/DTO -&gt; Service</code></p>
<p>This kind of system is cumbersome, and the workload of data conversion is not small, so it should be avoided if possible.</p>
<h3>Consumer of RESTful Remoting</h3>
<p>Here we use three scenarios:</p>
<ol>
<li>The non-Dubbo consumer calls Dubbo REST service (non-Dubbo --&gt; Dubbo)</li>
<li>The Dubbo consumer calls Dubbo REST service (Dubbo --&gt; Dubbo)</li>
<li>The consumer of Dubbo calls the non-Dubbo REST service (Dubbo --&gt; non-Dubbo)</li>
</ol>
<h3>Scenario 1: Non-Dubbo consumer calls Dubbo REST Service</h3>
<p>The client of this scenario has nothing to do with Dubbo itself, and it can be directly selected in the appropriate language and framework.</p>
<p>If it is still a Java client (but not using Dubbo), consider using the standard JAX-RS Client API or a specific REST-implemented Client API to invoke the REST service. The following is the registerUser() that uses the JAX-RS Client API to access the above UserService:</p>
<pre><code class="language-java">User user = <span class="hljs-keyword">new</span> User();
user.setName(<span class="hljs-string">"Larry"</span>);

Client client = ClientBuilder.newClient();
WebTarget target = client.target(<span class="hljs-string">"http://localhost:8080/services/users/register.json"</span>);
Response response = target.request().post(Entity.entity(user, MediaType.APPLICATION_JSON_TYPE));

<span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">if</span> (response.getStatus() != <span class="hljs-number">200</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Failed with HTTP error code : "</span> + response.getStatus());
    }
    System.out.println(<span class="hljs-string">"The generated id is "</span> + response.readEntity(RegistrationResult.class).getId());
} <span class="hljs-keyword">finally</span> {
    response.close();
    client.close(); <span class="hljs-comment">//Do not close the client every time in real development, such as HTTP long connection is held by the client</span>
}
</code></pre>
<p>The User and RegistrationResult classes in the code snippet above are written by the consumer itself, and the JAX-RS Client API automatically serializes/deserializes them.</p>
<p>Of course, in Java, you can also use the familiar technologies such as HttpClient, FastJson, XStream, etc. to implement the REST client, which will not be detailed here.</p>
<h3>Scenario 2: Dubbo consumer calls Dubbo RESTful Remoting</h3>
<p>In this scenario,  same as  other Dubbo remote calling methods, the Java service interface is shared directly between the service provider and the service consumer, and the Spring XML configuration is added (of course, the Spring/Dubbo annotation configuration can also be used),the remote REST service can be called transparently:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"xxx.UserService"</span>/&gt;</span>
</code></pre>
<p>As mentioned earlier, in this scenario, JAX-RS annotations must be added to the service interface, so that the corresponding REST configuration information can be shared on the consumer side of Dubbo and remotely called accordingly:</p>
<pre><code class="language-java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>{
    
    <span class="hljs-meta">@GET</span>
    <span class="hljs-meta">@Path</span>(<span class="hljs-string">"{id : \\d+}"</span>)
    <span class="hljs-meta">@Produces</span>({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    <span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
}
</code></pre>
<p>If a variety of data formats are configured in the annotation of the service interface, since both ends are Dubbo systems, a lot of details of REST are blocked, so there is no possibility to select a data format using the aforementioned URL suffix. Currently in this case, the top ranked data format will be used directly.</p>
<p>Therefore, we recommend that you put the most appropriate data format in front of defining an annotation. For example, we put JSON in front of XML because JSON's transmission performance is better than XML.</p>
<h3>Scenario 3: The consumer of Dubbo calls a non-Dubbo RESTful Remoting</h3>
<p>In this scenario, the REST service can be called directly using the Java method described in Scenario 1. But in fact, you can also use the way described in Scenario 2, that is, calling the REST service more transparently, even if this service is not provided by Dubbo.</p>
<p>If the scenario 2 is used, since the REST service is not provided by Dubbo, there is generally no shared Java service interface mentioned above, so we need to write the Java interface and the corresponding parameter class according to the external REST service. Add JAX-RS, JAXB, Jackson and other annotations, Dubbo's REST underlying implementation will automatically generate request messages, automatically parse response messages, etc., so as  to transparently make remote calls. Or this way can also be understood as, we try to use JAX-RS to copy the implementation of the external REST service provider, and then put the written service interface to the client to use directly, Dubbo REST underlying implementation can call other REST services as it calls Dubbo's REST service .</p>
<p>For example, we want to call the following external service.</p>
<pre><code>http://api.foo.com/services/users/1001
http://api.foo.com/services/users/1002
</code></pre>
<p>Get user data of different IDs, the return format is JSON</p>
<pre><code class="language-java">{
    <span class="hljs-string">"id"</span>: <span class="hljs-number">1001</span>,
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"Larry"</span>
}
</code></pre>
<p>We can write service interfaces and parameter classes based on this information:</p>
<pre><code class="language-java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>{
    
    <span class="hljs-meta">@GET</span>
    <span class="hljs-meta">@Path</span>(<span class="hljs-string">"{id : \\d+}"</span>)
    <span class="hljs-meta">@Produces</span>({MediaType.APPLICATION_JSON})
    <span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
}
</code></pre>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{

    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-comment">// …</span>
}
</code></pre>
<p>For the configuration in Spring, because the REST service is not provided by Dubbo, you can not use the Dubbo registry to directly configure the url address of the external REST service (such as multiple addresses separated by commas):</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"xxx.UserService"</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"rest://api.foo.com/services/"</span>/&gt;</span>
</code></pre>
<blockquote>
<p>Note: The protocol here must use rest:// instead of http://. If the external REST service has a context path, it must also be added to the url (unless you have a context path in the @Path annotation for each service interface), such as /services/ above. At the same time, the services here must be followed by /, in order to make Dubbo work properly.</p>
<p>In addition, you can still configure the maximum number of connections and timeouts that the client can start:</p>
</blockquote>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"xxx.UserService"</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"rest://api.foo.com/services/"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"2000"</span> <span class="hljs-attr">connections</span>=<span class="hljs-string">"10"</span>/&gt;</span>
</code></pre>
<h3>JAX-RS restrictions in Dubbo</h3>
<p>The REST development in Dubbo is fully compatible with standard JAX-RS, but the features it supports are currently a subset of full JAX-RS, in part because it is limited to the specific architecture of Dubbo and Spring. The limitations of JAX-RS used in Dubbo include but are not limited to:</p>
<ol>
<li>Service implementation can only be singleton, and it can not support per-request scope and per-lookup scope</li>
<li>It is not supported to inject into ServletConfig, ServletContext, HttpServletRequest, HttpServletResponse, etc. with the @Context annotation for the instance field of the service, but it can support the injection of service method parameters. However, for certain REST server implementations (see the previous section), injection of service method parameters is not supported.</li>
</ol>
<h2>REST FAQ</h2>
<hr>
<h3>Can Dubbo REST services be integrated with Dubbo Registry and Monitor?</h3>
<p>Yes, and it will integrate automatically. That is, all the REST services you develop in Dubbo are automatically registered to the Registry and Monitor, by which you can managed your services.
However, many of the service governance operations in the Registry can only be fully functional when the REST consumer is based on Dubbo. If the consumer side is non-Dubbo, it is naturally not managed by the Registry, so that many of the operations will not work for the consumer.</p>
<h3>How to implement load balancing and failover in Dubbo REST?</h3>
<p>If the consumer side of Dubbo REST is based on Dubbo, then Dubbo REST is basically the same as other Dubbo remote call protocols: Dubbo framework transparently performs load balancing, failover, etc. on the consumer side.
If the consumer side of Dubbo REST is non-Dubbo or even non-Java, it is better to configure the soft load balancing mechanism on the service provider. Currently, you can consider LVS, HAProxy, Nginx, and so on to achieve load balancing for HTTP requests.</p>
<h3>Can overloaded method in JAX-RS maps to the same URL address?</h3>
<p><a href="http://stackoverflow.com/questions/17196766/can-resteasy-choose-method-based-on-query-params">http://stackoverflow.com/questions/17196766/can-resteasy-choose-method-based-on-query-params</a></p>
<h3>Can a POST method in JAX-RS receive multiple parameters?</h3>
<p><a href="http://stackoverflow.com/questions/5553218/jax-rs-post-multiple-objects">http://stackoverflow.com/questions/5553218/jax-rs-post-multiple-objects</a></p>
<h2>The shortcomings of Dubbo's current system (related to REST)</h2>
<hr>
<p>I think there are obviously a lot of deficiencies in Dubbo's current system. Here are a few REST-related issues that affect users (not including internal implementation issues) for reference and comments, which can help prepare for the refactoring later.</p>
<h3>Invasiveness of RpcContext</h3>
<p>We have already mentioned the intrusiveness of RpcContext(See above). Because it uses a singleton to access context information, which is completely inconsistent with the general style of spring applications as well as not conducive to application extension and unit testing. In the future, we may inject an interface with dependency injection, and then use it to access the context information in ThreadLocal.</p>
<h3>limitations of Protocol configuration</h3>
<p>Dubbo supports multiple remote call methods, but all call methods are configured with <a href="Dubbo:protocol/">Dubbo:protocol/</a>,  for example:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Dubbo"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"9090"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"netty"</span> <span class="hljs-attr">client</span>=<span class="hljs-string">"netty"</span> <span class="hljs-attr">codec</span>=<span class="hljs-string">"Dubbo"</span> <span class="hljs-attr">serialization</span>=<span class="hljs-string">"hessian2"</span>
    <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> <span class="hljs-attr">threadpool</span>=<span class="hljs-string">"fixed"</span> <span class="hljs-attr">threads</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">queues</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">iothreads</span>=<span class="hljs-string">"9"</span> <span class="hljs-attr">buffer</span>=<span class="hljs-string">"8192"</span> <span class="hljs-attr">accepts</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attr">payload</span>=<span class="hljs-string">"8388608"</span>/&gt;</span>
</code></pre>
<p>Dubbo supports multiple remote call methods, but all call methods are configured with <a href="Dubbo:protocol/">Dubbo:protocol/</a>,  for example:
In fact, many of the above properties are uniquely held by the Dubbo RPC remote call method and many other remote call methods in Dubbo do not support server, client, codec, iothreads, accepts, payload, etc. (of course, some are not supported because of limited conditions, some have no need to be supported at all). This adds a lot of confusions to users when they use Dubbo, and they actually do not know that some attributes (such as performance tuning) will not work after adding them.</p>
<p>On the other hand, various remote call methods often have a large number of unique configuration requirements, especially as we gradually add much richer and more advanced functions to each kind of remote call method, which cause the expands in <protocol/> attributes inevitably (for example, we have added keepalive and extension two attributes in REST at the moment) and then lead to bloated <protocol/> and user confusion.</p>
<p>Of course, there is a way to expand <protocol/> in Dubbo by using <a href="Dubbo:parameter/">Dubbo:parameter/</a>, but this method is obviously very limited, the usage is complicated and the schema verification is lacking.
So that the best method is to set your own protocol elements for each remote call, such as <protocol-Dubbo/>, <protocol-rest/>, etc. Each element specifies its own attributes using XML Schema. (Of course, it is best to use common attributes between a variety of remote call methods)
In this way, a freer way can be used when doing the extension configuration mentioned above, so that it can be much clearer and more extensible (the following is just an example, of course there may be a better way):</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Dubbo:protocol-rest</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Dubbo:extension</span>&gt;</span>someInterceptor<span class="hljs-tag">&lt;/<span class="hljs-name">Dubbo:extension</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Dubbo:extension</span>&gt;</span>someFilter<span class="hljs-tag">&lt;/<span class="hljs-name">Dubbo:extension</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Dubbo:extension</span>&gt;</span>someDynamicFeature<span class="hljs-tag">&lt;/<span class="hljs-name">Dubbo:extension</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Dubbo:extension</span>&gt;</span>someEntityProvider<span class="hljs-tag">&lt;/<span class="hljs-name">Dubbo:extension</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Dubbo:protocol-rest</span>&gt;</span>
</code></pre>
<h3>XML naming does not conform to the spring specification</h3>
<p>A lot of naming in XML configuration of Dubbo dose not conform to the spring specification, such as:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Dubbo"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"9090"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"netty"</span> <span class="hljs-attr">client</span>=<span class="hljs-string">"netty"</span>

<span class="hljs-attr">codec</span>=<span class="hljs-string">"Dubbo"</span> <span class="hljs-attr">serialization</span>=<span class="hljs-string">"hessian2"</span>
    <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> <span class="hljs-attr">threadpool</span>=<span class="hljs-string">"fixed"</span> <span class="hljs-attr">threads</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">queues</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">iothreads</span>=<span class="hljs-string">"9"</span> <span class="hljs-attr">buffer</span>=<span class="hljs-string">"8192"</span> <span class="hljs-attr">accepts</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attr">payload</span>=<span class="hljs-string">"8388608"</span>/&gt;</span>
</code></pre>
<p>The above threadpool should be changed to thread-pool, iothreads should be changed to io-threads, and words should be separated by &quot;-&quot;. While this may seem like a minor issue, it also involves readability, especially scalability, because sometimes we will inevitably use more words to describe XML elements and attributes.</p>
<p>In fact, Dubbo itself also recommended to follow the naming convention of spring to XML.</p>
<h2>Best practices of REST</h2>
<hr>
<p>TODO</p>
<h2>Performance benchmark</h2>
<hr>
<h3>Test Environment</h3>
<p>Roughly as follows:</p>
<ul>
<li>4-core Intel(R) Xeon(R) CPU E5-2603 0 @ 1.80GHz</li>
<li>8G memory</li>
<li>The network between servers passes through a 100 Mbps switch</li>
<li>CentOS 5</li>
<li>JDK 7</li>
<li>Tomcat 7</li>
<li>JVM parameter -server -Xms1g -Xmx1g -XX:PermSize=64M -XX:+UseConcMarkSweepGC</li>
</ul>
<h3>Test Script</h3>
<p>Similar to Dubbo's own benchmarks:
10 concurrent clients send requests continuously:
• Pass in nested complex objects (single data is small), do nothing and return
• Pass in a 50K string, do nothing and return (TODO: the result is not listed yet)
Excute a five-minute performance test. (Reference to Dubbo's own test considerations: &quot;Mainly consider the serialization and performance of network IO, so that the server side does not have any business logic. Take 10 to run simultaneously because of the consideration that the bottleneck can be hit first when the high CPU usage rate is reached by HTTP protocol under the high concurrency situation.&quot;)</p>
<h3>Test Result</h3>
<p>The following results are mainly from the comparison between to the two remote call methods, REST and Dubbo RPC which are configured differently, for example:</p>
<ul>
<li>“REST: Jetty + XML + GZIP” means: Test REST, use jetty server and XML data format, and enable GZIP compression.</li>
<li>“Dubbo: hessian2” means: test Dubbo RPC and use hessian2 serialization.</li>
</ul>
<p>The results for complex objects are as follows (the smaller Response Time and the larger TPS, the better results):</p>
<table>
<thead>
<tr>
<th>Remote Call Mode</th>
<th>Average Response Time</th>
<th>Average TPS（Num of transactions per second）</th>
</tr>
</thead>
<tbody>
<tr>
<td>REST: Jetty + JSON</td>
<td>7.806</td>
<td>1280</td>
</tr>
<tr>
<td>REST: Jetty + JSON + GZIP</td>
<td>TODO</td>
<td>TODO</td>
</tr>
<tr>
<td>REST: Jetty + XML</td>
<td>TODO</td>
<td>TODO</td>
</tr>
<tr>
<td>REST: Jetty + XML + GZIP</td>
<td>TODO</td>
<td>TODO</td>
</tr>
<tr>
<td>REST: Tomcat + JSON</td>
<td>2.082</td>
<td>4796</td>
</tr>
<tr>
<td>REST: Netty + JSON</td>
<td>2.182</td>
<td>4576</td>
</tr>
<tr>
<td>Dubbo: FST</td>
<td>1.211</td>
<td>8244</td>
</tr>
<tr>
<td>Dubbo: kyro</td>
<td>1.182</td>
<td>8444</td>
</tr>
<tr>
<td>Dubbo: Dubbo serialization</td>
<td>1.43</td>
<td>6982</td>
</tr>
<tr>
<td>Dubbo: hessian2</td>
<td>1.49</td>
<td>6701</td>
</tr>
<tr>
<td>Dubbo: fastjson</td>
<td>1.572</td>
<td>6352</td>
</tr>
</tbody>
</table>
<p>Just a brief summary of the current results:</p>
<ul>
<li>Dubbo RPC (especially when based on efficient java serialization methods such as kryo and fst) has a significant advantage response time and throughput over REST. Dubbo RPC is preferred in the intranet Dubbo systems.</li>
<li>When choosinf REST implementation, tomcat7 and netty are optimal (of course, the current versions of jetty and netty are lower) currently only considering performance. Tjws and sun http server performed extremely poorly in performance tests, with an average response time of more than 200ms and an average tps of only about 50 (to avoid affecting the picture effect, the results are not listed above).</li>
<li>Performance of JSON data format is better than XML in REST (data is not listed above).</li>
<li>Enabling GZIP in REST has little to do with complex objects with small data volume in the intranet, but performance has declined (data is not listed above).</li>
</ul>
<h2>Performance Optimization Recommendations</h2>
<p>If you deploy Dubbo REST to an external Tomcat and configure server=&quot;servlet&quot;, that is, enable external tomcat as the underlying implementation of rest server, it is best to add the following configuration to tomcat:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span>

<span class="hljs-attr">protocol</span>=<span class="hljs-string">"org.apache.coyote.http11.Http11NioProtocol"</span>
               <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span>
               <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span>
               <span class="hljs-attr">minSpareThreads</span>=<span class="hljs-string">"20"</span>
               <span class="hljs-attr">enableLookups</span>=<span class="hljs-string">"false"</span>
               <span class="hljs-attr">maxThreads</span>=<span class="hljs-string">"100"</span>
               <span class="hljs-attr">maxKeepAliveRequests</span>=<span class="hljs-string">"-1"</span>
               <span class="hljs-attr">keepAliveTimeout</span>=<span class="hljs-string">"60000"</span>/&gt;</span>
</code></pre>
<p>Especially the configuration maxKeepAliveRequests=&quot;-1&quot; ,which is mainly to ensure that tomcat always enables http long connection, in order to improve the performance of REST call. Note, however, that if the REST consumer side is not continuously call REST services, it is not always best to enable long connections all time. In addition, the way to always enable long connections is generally not suitable for ordinary webapps, but more suitable for such rpc-like scenarios. So that in order to get high performance, Dubbo REST applications and ordinary web applications are best not to be mixed deployment, but should use a separate instance in tomcat.</p>
<h2>##Extended discussion</h2>
<h3>Comparison among Rest, Thrift, Protobuf and so on</h3>
<p>TODO</p>
<h3>Comparison between REST and traditional Webservers</h3>
<p>TODO</p>
<h3>Comparison of JAX-RS Between Spring MVC</h3>
<p>A preliminary view from <a href="http://www.infoq.com/cn/news/2014/10/Dubbox-open-source?utm_source=infoq&amp;utm_medium=popular_links_homepage#theCommentsSection">http://www.infoq.com/cn/news/2014/10/Dubbox-open-source?utm_source=infoq&amp;utm_medium=popular_links_homepage#theCommentsSection</a></p>
<blockquote>
<p>Thank you, in fact, for jax-rs and Spring MVC, I do not have a deep look at the rest support of Spring MVC. I would like to give you some preliminary ideas. Please correct me:</p>
</blockquote>
<blockquote>
<p>Spring MVC also supports configuration using annotation, which actually looks very similar to jax-rs.</p>
</blockquote>
<blockquote>
<p>Personally, I think Spring MVC is better suited to restful services of web applications, such as being invoked by AJAX, or possibly outputting HTML or something like page jump processes in applications. Spring MVC can handle both normal web page requests and rest requests at the same time. But in general, the restful service is implemented in the presentation layer or the web layer.</p>
</blockquote>
<blockquote>
<p>But Jax-rs is more suitable for pure service-oriented applications, that is, the middle-tier services in traditional Java EE, for example, it can publish traditional EJB as restful services. In a Spring application, the bean that acts as a service in the Spring is directly published as a restful service. In general, the restful service is at the business layer, application layer, or facade layer. And MVC hierarchies and concepts are often of little value in such (back-end) applications.</p>
</blockquote>
<blockquote>
<p>Of course, some implementations of jax-rs, such as jersey, also try to include MVC to better accommodate the web applications described above, but not as well as Spring MVC.</p>
</blockquote>
<blockquote>
<p>In Dubbo applications, I think a lot of people prefer to publish a local Spring service bean (or manager) as a remote service directly and transparently, so that it is more straightforward to use JAX-RS here, and there is no need to introduce the MVC concept. Of course, we do not discuss whether transparent publishing of remote services is a best practice or whether to add facade things here first.</p>
</blockquote>
<blockquote>
<p>Of course, I know that many people use Spring MVC restful to call Dubbo (spring) service to publish restful services under the situation that Dubbo does not support rest now. It’s a good method also in my opinion, but if you do not modify Spring MVC and integrate it deeply with Dubbo, restful services cannot enjoy many advanced services such as registering to the Dubbo Registry, monitoring the number of calls, TPS, response time through the Dubbo Monitor, controlling the size of the thread pool and the maximum number of connections through the unified configuration of Dubbo, and controlling the service flow, authority and frequency through Dubbo unified mode like other remote call protocol such as webservices, Dubbo rpc, hessian and so on in Dubbo system. In addition, Spring MVC only works in server side and Spring restTemplate are usually used on consumer side. If restTemplate is not integrated with Dubbo, the service can be downgraded by Dubbo client automatically or manually. If the server and consumer are all Dubbo system, you cannot use unified routing and other functions in Dubbo if the Spring rest is not deeply integrated into Dubbo through interaction of Spring and rest.</p>
</blockquote>
<blockquote>
<p>Of course, I personally think that these things are not necessarily to be one or the other. I heard that Rod Johnson, the founder of spring usually says ‘the customer is always right,’ In fact, it is better to support both ways at the same time rather than discuss which way is better, so that originally I wrote in the document that we plan to support Spring rest annotation, but the feasibility is unknown.</p>
</blockquote>
<h2>##Future</h2>
<p>Functions may be supported later:</p>
<ul>
<li>Rest annotation for Spring MVC</li>
<li>Safety System</li>
<li>OAuth</li>
<li>Asynchronous calls</li>
<li>Gzip</li>
<li>Payload maxsize</li>
</ul>
</div></section><footer class="footer-container" data-reactid="367"><div class="footer-body" data-reactid="368"><img src="/img/dubbo_gray.png" data-reactid="369"/><img class="apache" src="/img/apache_logo.png" data-reactid="370"/><div class="cols-container" data-reactid="371"><div class="col col-12" data-reactid="372"><h3 data-reactid="373">Disclaimer</h3><p data-reactid="374">Apache Dubbo is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Incubator. Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.</p></div><div class="col col-4" data-reactid="375"><dl data-reactid="376"><dt data-reactid="377">ASF</dt><dd data-reactid="378"><a href="http://www.apache.org" target="_self" data-reactid="379">Foundation</a></dd><dd data-reactid="380"><a href="http://www.apache.org/licenses/" target="_self" data-reactid="381">License</a></dd><dd data-reactid="382"><a href="http://www.apache.org/events/current-event" target="_self" data-reactid="383">Events</a></dd><dd data-reactid="384"><a href="http://www.apache.org/foundation/sponsorship.html" target="_self" data-reactid="385">Sponsorship</a></dd><dd data-reactid="386"><a href="http://www.apache.org/foundation/thanks.html" target="_self" data-reactid="387">Thanks</a></dd></dl></div><div class="col col-4" data-reactid="388"><dl data-reactid="389"><dt data-reactid="390">Documentation</dt><dd data-reactid="391"><a href="/en-us/docs/user/quick-start.html" target="_self" data-reactid="392">Quick start</a></dd><dd data-reactid="393"><a href="/en-us/docs/dev/build.html" target="_self" data-reactid="394">Developer guide</a></dd><dd data-reactid="395"><a href="/en-us/docs/admin/ops/dubbo-ops.html" target="_self" data-reactid="396">Admin manual</a></dd></dl></div><div class="col col-4" data-reactid="397"><dl data-reactid="398"><dt data-reactid="399">Resources</dt><dd data-reactid="400"><a href="/en-us/blog/index.html" target="_self" data-reactid="401">Blog</a></dd><dd data-reactid="402"><a href="/en-us/community/index.html" target="_self" data-reactid="403">Community</a></dd><dd data-reactid="404"><a href="https://www.apache.org/security/" target="_self" data-reactid="405">Security</a></dd></dl></div></div><div class="copyright" data-reactid="406"><span data-reactid="407">Copyright © 2018 The Apache Software Foundation. Apache and the Apache feather logo are trademarks of The Apache Software Foundation.</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
  <script src="/build/documentation.js"></script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112489517-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-112489517-1');
	</script>
</body>
</html>