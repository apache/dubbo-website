<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dubbo Examples on Apache Dubbo</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/</link><description>Recent content in Dubbo Examples on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://dubbo.apache.org/en/docs/v2.7/user/examples/index.xml" rel="self" type="application/rss+xml"/><item><title>Preflight Check</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/preflight-check/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/preflight-check/</guid><description>By default dubbo will check if the dependent service is available at startup . It will throw an exception to prevent Spring complete initialization when it is not available, so that you can find the problems early before publishing you application, the default setting: check=true.
You can turn off checking by check=false. For example, some services do not care it when you run testing, or you must have one started firstly because of circular dependency.</description></item><item><title>Fault Tolerance Strategy</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/fault-tolerent-strategy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/fault-tolerent-strategy/</guid><description>Dubbo offers a variety of fault-tolerant scenarios when a cluster call fails, with a default failover retry.
The relationship between nodes:
This Invoker is the callable Service&amp;rsquo;s abstract of the Provider, and the Invoker packaging the Provider&amp;rsquo;s address and Service&amp;rsquo;s interface. The Directory represent multiple Invoker,You can think of it as List&amp;lt;Invoker&amp;gt;,But unlike List,its value can be dynamically changing.such as registry push changes The Cluster disguises multiple Invoker in Directory as a Invoker,The upper transparent, masquerade process contains fault-tolerant logic, call failed, try another The Router is responsible for selecting subsets according to routing rules from multiple Invokers, such as read-write separation, application isolation, etc.</description></item><item><title>Load Balance</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/loadbalance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/loadbalance/</guid><description>Dubbo offers a number of balancing strategies for cluster load balancing, which defaults to random.
You can extend the load balancing strategy by yourself, see: LoadBalance extension
LoadBalance strategy Random LoadBalance Ramdom, set random probabilities by weight. The probability of collisions on one section is high, but the larger the amount of calls, the more uniform the distribution. And when use weight based on probability the distribution turns out to be uniform, which also helps to dynamically adjust the provider weights.</description></item><item><title>Thread Model</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/thread-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/thread-model/</guid><description>Thread Model If events handing can be executed quickly without sending new request like marking in memory. Events should be handled by I/O thread since it reduces thread dispatching. If event handling will be executed slowly or needs to send new I/O request like querying from database, events should be handled in thread pool. Otherwise, I/O thread will be blocked and then will be not able to receive requests. If events are handled by I/O thread, and send new I/O requests during the handling like sending a l login request during connect event, it will alert with “Potentially leading to deadlock”, but deadlock will not happen actually.</description></item><item><title>Explicit Target</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/explicit-target/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/explicit-target/</guid><description>In the development and testing environment, it is often necessary to bypass the registry and test only designated service providers. In this case, point-to-point direct connection may be required, and the service provider will ignore the list of provider registration providers. The interface A configure Point-to-point, does not affect the B interface to obtain a list from the registry.
Configure with XML If it is online demand needs the point-to-point feature,You can configure the specified provider url at &amp;lt;dubbo:reference&amp;gt;.</description></item><item><title>Subscribe Only</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/subscribe-only/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/subscribe-only/</guid><description>To facilitate the development of tests, it is common to have a registry of all services available in develop environment.And the registration of a service provider under development may affect consumers&amp;rsquo; inability to run.
You can let service provider developers only subscribe to services only (services developed may rely on other services) ,don&amp;rsquo;t register services under development and testing services under development with directly connection.
User configuration:
&amp;lt;dubbo:registry address=&amp;#34;10.20.153.10:9090&amp;#34; register=&amp;#34;false&amp;#34; /&amp;gt; or</description></item><item><title>Multiple Protocols</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/multi-protocols/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/multi-protocols/</guid><description>Dubbo allows you to configure multiple protocols, support different protocols on different services, or support multiple protocols on the same service.
Every service export to one specific protocol separately Different protocol performance is not the same. Such as big data should use short connection protocol, small data and concurrent should use long connection protocol.
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;dubbo:application name=&amp;#34;world&amp;#34; /&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;registry&amp;#34; address=&amp;#34;10.</description></item><item><title>Multiple Registries</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/multi-registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/multi-registry/</guid><description>Dubbo supports the same service to register multiple registries, or different services were registered to different registries, or even reference the same name service from different registries. In addition, the registry supports custom extensions 1。
One service register to multiple registries For example: Alibaba some services are not deployed in Qingdao, only deployed in Hangzhou. While other applications in Qingdao need to reference this service, you can register your services to both registries at the same time.</description></item><item><title>Service Group</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/service-group/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/service-group/</guid><description>When you have multi-impls of a interface,you can distinguish them with the group.
Service &amp;lt;dubbo:service group=&amp;#34;feedback&amp;#34; interface=&amp;#34;com.xxx.IndexService&amp;#34; /&amp;gt; &amp;lt;dubbo:service group=&amp;#34;member&amp;#34; interface=&amp;#34;com.xxx.IndexService&amp;#34; /&amp;gt; Reference &amp;lt;dubbo:reference id=&amp;#34;feedbackIndexService&amp;#34; group=&amp;#34;feedback&amp;#34; interface=&amp;#34;com.xxx.IndexService&amp;#34; /&amp;gt; &amp;lt;dubbo:reference id=&amp;#34;memberIndexService&amp;#34; group=&amp;#34;member&amp;#34; interface=&amp;#34;com.xxx.IndewxService&amp;#34; /&amp;gt; Any group:
&amp;lt;dubbo:reference id=&amp;#34;barService&amp;#34; interface=&amp;#34;com.foo.BarService&amp;#34; group=&amp;#34;*&amp;#34; /&amp;gt; Warning group=&amp;quot;*&amp;quot; is supported after version 2.2.0, always select only one available group of implementations to invoke.</description></item><item><title>Static Service</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/static-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/static-service/</guid><description>Sometimes we want to manually manage the registration and deregistration for service provider, we need to set registry to non-dynamoic mode.
&amp;lt;dubbo:registry address=&amp;#34;10.20.141.150:9090&amp;#34; dynamic=&amp;#34;false&amp;#34; /&amp;gt; Or
&amp;lt;dubbo:registry address=&amp;#34;10.20.141.150:9090?dynamic=false&amp;#34; /&amp;gt; dynamic mode is disabled when service provider initially registers, then we need to enable it manually. When disconnects, the setting will not be deleted automatically, need to disable it manually.
For a third party service provider like “memcachd”, it can directly write the address information of service provider to registry, which can be used by consumer.</description></item><item><title>Multiple Versions</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/multi-versions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/multi-versions/</guid><description>When an interface to achieve an incompatible upgrade, you can use the version number transition. Different versions of the services do not reference each other.
You can follow the steps below for version migration:
In the low pressure period, upgrade to half of the provider to the new version Then upgrade all consumers to the new version Then upgrade the remaining half providers to the new version Old version of the service provider configuration:</description></item><item><title>Group Merger</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/group-merger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/group-merger/</guid><description>According to the group to invoke server and return the merge result 1, such as the menu service, the same interface, but there are a variety of implementations, using group distinction, consumers call each group and get the results, the merger can merge the resules, so that you can achieve aggregation Menu Item.
Related code can refer to dubbo project example
Configuration Merge all groups
&amp;lt;dubbo:reference interface=&amp;#34;com.xxx.MenuService&amp;#34; group=&amp;#34;*&amp;#34; merger=&amp;#34;true&amp;#34; /&amp;gt; Merge the specified group</description></item><item><title>Parameter Validation</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/parameter-validation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/parameter-validation/</guid><description>The parameter validation 1 is based on [JSR303] (https://jcp.org/en/jsr/detail?id=303). The user simply add the validation annotation of the JSR303 and declares the filter for validation 2.
Maven Dependency &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.validation&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;validation-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0.GA&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hibernate-validator&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.2.0.Final&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; Sample Example of Parameter Annotation import java.io.Serializable; import java.util.Date; import javax.validation.constraints.Future; import javax.validation.constraints.Max; import javax.validation.constraints.Min; import javax.validation.constraints.NotNull; import javax.validation.constraints.Past; import javax.validation.constraints.Pattern; import javax.validation.constraints.Size; public class ValidationParameter implements Serializable { private static final long serialVersionUID = 7158911668568000392L; @NotNull // Required @Size(min = 1, max = 20) // range private String name; @NotNull(groups = ValidationService.</description></item><item><title>Cache Result</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/result-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/result-cache/</guid><description>Cache result is used to speed up access to popular data. Dubbo provides declarative caching to reduce the user work of adding cache 1.
Cache Type lru Delete excess cache Based on the principle of least recently used. The hottest data is cached. threadlocal The current thread cache. For example, a page have a lot of portal and each portal need to check user information, you can reduce this redundant visit with this cache.</description></item><item><title>Collect Broadcast Responses</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/broadcast-resp-collect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/broadcast-resp-collect/</guid><description>Applicable scenario: for any Dubbo consumer, broadcast calls multiple service providers. The consumer is able to collect responses from all of the providers.
Notice support on 2.7.12 or above. Demo consumer demo @Reference imports providers. Within the brackets, letting cluster = &amp;ldquo;broadcast2&amp;rdquo; represents doing one broadcast call that collects providers&amp;rsquo; responses.
Broadcast calls all service providers one by one. Is able to return all service providers’ execution outcomes (success or exceptions) completely and stores providers&amp;rsquo; responses in RpcContext.</description></item><item><title>json generic invoke</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/generic-invoke-with-json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/generic-invoke-with-json/</guid><description>Notice support on 2.7.12 or above. A new method is provided for Dubbo generic invoke: directly passing on String to complete an invoke. In other words, users can directly pass on parameter object&amp;rsquo;s json String to complete a generic invoke.
Using generic invoke through API method For the following providers:
public User setUser(User user) { return user; } @Data public class User { String name; int age; } do one generic invoke:</description></item><item><title>msgpack serialization</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/msgpack-serialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/msgpack-serialization/</guid><description>MessagePack is an efficient binary serialization format. It lets you exchange data among multiple languages like JSON. But it&amp;rsquo;s faster and smaller. Small integers are encoded into a single byte, and typical short strings require only one extra byte in addition to the strings themselves.
Notice support on 2.7.12 or above. msgpack demo provider and consumer import msgpack dependencies &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.msgpack&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;msgpack-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.8.22&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.msgpack&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-dataformat-msgpack&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.8.22&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; provider demo Add the following protocol configurations into Dubbo configuration class:</description></item><item><title>provider timeout release</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/provider-timeout-release/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/provider-timeout-release/</guid><description>Dubbo allows providers to shutdown operations based on how long the timeout lasts.
Applicable scenario: when a certain operation times out, providers can release that thread instead of simply printing out the timeout log message.
Notice support on 2.7.12 or above. Main Logic public class AllChannelHandler2 extends AllChannelHandler { public static final Timer TIME_OUT_TIMER = new HashedWheelTimer( new NamedThreadFactory(&amp;#34;dubbo-server-future-timeout&amp;#34;, true), 30, TimeUnit.MILLISECONDS); public AllChannelHandler2(ChannelHandler handler, URL url) { super(handler, url); } @Override public void received(Channel channel, Object message) throws RemotingException { ExecutorService executor = getPreferredExecutorService(message); try { Future&amp;lt;?</description></item><item><title>Invoke provider with specified IP port</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/invoke-with-specified-ip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/invoke-with-specified-ip/</guid><description>When multiple providers are registered at the register center, dynamically specifying one of the instances’ IP through RpcContext is enabled. Port does Dubbo invoke.
Notice support on 2.7.12 or above. Demo provider demo Assume two registered providers at the register center are provided, which are 10.220.47.253:20880;10.220.47.253:20881; respectively.
// 10.220.47.253:20880 @Service(interfaceClass = TestService.class) public class TestServiceImpl implements TestService { @Override public String sayHello(String name) { return &amp;#34;Hello &amp;#34;+name+&amp;#34; i am provider1&amp;#34;; } } // 10.</description></item><item><title>Generic Reference</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/generic-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/generic-reference/</guid><description>Generic invocation is mainly used when the client does not have API interface or model class, all POJOs in parameters and return values are represented by Map.Commonly used for framework integration such as: implementing a common service testing framework, all service implementations can be invoked via GenericService.
Use generic invocation via Spring Declared in the Spring configuration file generic =&amp;quot; true &amp;quot;：
&amp;lt;dubbo:reference id=&amp;#34;barService&amp;#34; interface=&amp;#34;com.foo.BarService&amp;#34; generic=&amp;#34;true&amp;#34; /&amp;gt; In Java code, get barService and start generic invocation:</description></item><item><title>Generic Service</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/generic-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/generic-service/</guid><description>The implementation of the generic interface is mainly used when there is no API interface and model class on the server side. All POJOs in the parameters and return values are represented by the Map and are usually used for framework integration. For example, to implement a universal remote service Mock framework, handle all service requests by implementing the GenericService interface.
In Java code, implement GenericService interface：
package com.foo; public class MyGenericService implements GenericService { public Object $invoke(String methodName, String[] parameterTypes, Object[] args) throws GenericException { if (&amp;#34;sayHello&amp;#34;.</description></item><item><title>Echo Testing Service</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/echo-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/echo-service/</guid><description>Echo testing is used for check the service is available,Echo testing is performed according to the normal request flow and is able to test whether the entire call is unobstructed and can be used for monitoring.
All the services will be automatically implemented EchoService interface,just cast any service reference to EchoService to use it.
Spring configuration:
&amp;lt;dubbo:reference id=&amp;#34;memberService&amp;#34; interface=&amp;#34;com.xxx.MemberService&amp;#34; /&amp;gt; The java code：
// reference the remote service MemberService memberService = ctx.</description></item><item><title>Context</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/context/</guid><description>All environment information of during the current call will put into the context,and all configuration information will convert the parameters of URL instance,Ref to the column of URL parameters at the schema configuration reference book
RpcContext is a temporary status recorder of ThreadLocal,when accept RPC request or send RPC request,The RpcContext will be changed.Such as: A call B and B call C. On B machine,before B call C,the RpcContext will record the information of A call B.</description></item><item><title>Implicit parameters</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/attachment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/attachment/</guid><description>You can implicitly pass parameters between service consumers and providers via setAttachment and getAttachment on RpcContext. Set the implicit parameters at service consumer side Via setAttachment on RpcContext set key/value pair for implicitly pass parameters.When finished once remote invoke,will be clear,so multi-invoke must set multi-times.
RpcContext.getContext().setAttachment(&amp;#34;index&amp;#34;, &amp;#34;1&amp;#34;); // implicitly pass parameters,behind the remote call will implicitly send these parameters to the server side, similar to the cookie, for the framework of integration, not recommended for regular business use xxxService.</description></item><item><title>Asynchronous Call</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/async-call/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/async-call/</guid><description>As dubbo is based on a non-blocking NIO network layer, the client can start parallel call to multiple remote services without explicitly starting mulithreads, which costs relatively fewer resources.
You can config at consumer.xml for setup asynchronous call some remote service.
&amp;lt;dubbo:reference id=&amp;#34;fooService&amp;#34; interface=&amp;#34;com.alibaba.foo.FooService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;findFoo&amp;#34; async=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; &amp;lt;dubbo:reference id=&amp;#34;barService&amp;#34; interface=&amp;#34;com.alibaba.bar.BarService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;findBar&amp;#34; async=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; Configure the above configuration information,you can invoke the remote service in your code.</description></item><item><title>Asynchronous Execution</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/async-execute-on-provider/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/async-execute-on-provider/</guid><description>The asynchronous execute on provider switches the blocked service from the internal thread pool of Dubbo to the service custom thread to avoid over-occupation of the Dubbo thread pool, which helps to avoid mutual influence between different services.Asynchronous-Execution is not conducive to saving resources or improving RPC responsiveness, because if business execution needs to be blocked, there is always a thread to be responsible for execution.
Notice Note: Asynchronous execute on provider and asynchronous execute on consumer are independent of each other.</description></item><item><title>Local Call</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/local-call/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/local-call/</guid><description>The local call uses the injvm protocol, a pseudo-protocol that does not turn on the port, does not initiate remote calls, is directly associated within the JVM, but executes the Dubbo Filter chain.
Configuration Configure injvm protocol
&amp;lt;dubbo:protocol name=&amp;#34;injvm&amp;#34; /&amp;gt; Configure default provider
&amp;lt;dubbo:provider protocol=&amp;#34;injvm&amp;#34; /&amp;gt; Configure default service
&amp;lt;dubbo:service protocol=&amp;#34;injvm&amp;#34; /&amp;gt; Use injvm first
&amp;lt;dubbo:consumer injvm=&amp;#34;true&amp;#34; .../&amp;gt; &amp;lt;dubbo:provider injvm=&amp;#34;true&amp;#34; .../&amp;gt; or
&amp;lt;dubbo:reference injvm=&amp;#34;true&amp;#34; .../&amp;gt; &amp;lt;dubbo:service injvm=&amp;#34;true&amp;#34; .../&amp;gt; Note: Dubbo services are exposed locally from 2.</description></item><item><title>Callback parameter</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/callback-parameter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/callback-parameter/</guid><description>The parameter callback is the same as calling a local callback or listener, just declare which parameter is a callback type in Spring&amp;rsquo;s configuration file, and Dubbo will generate a reverse proxy based on the long connection so that client logic can be called from the server.Can ref to Sample code in the dubbo project.
Example of service interface CallbackService.java package com.callback; public interface CallbackService { void addListener(String key, CallbackListener listener); } CallbackListener.</description></item><item><title>Event Notification</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/events-notify/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/events-notify/</guid><description>Before calling, after calling, when an exception occurs,will trigger oninvoke, onreturn, onthrow events.You can configure which method to notify when an event occurs.
Service Interface interface IDemoService { public Person get(int id); } Service provider implement the service. class NormalDemoService implements IDemoService { public Person get(int id) { return new Person(id, &amp;#34;charles`son&amp;#34;, 4); } } Service provider configure the service which it provided. &amp;lt;dubbo:application name=&amp;#34;rpc-callback-demo&amp;#34; /&amp;gt; &amp;lt;dubbo:registry address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;demoService&amp;#34; class=&amp;#34;org.</description></item><item><title>Local Stub</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/local-stub/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/local-stub/</guid><description>When using rpc, the client usually only the interface, but sometimes the client also want to perform part of the logic in the client. For example: do ThreadLocal cache, verify parameters, return mock data when call fails., etc.
To solve this problem, you can configure the stub in the API, so that when the client generates the proxy instance, it passes the proxy to the Stub via the constructor 1, and then you can implement your logic in the stub implementation code.</description></item><item><title>Local Mock</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/local-mock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/local-mock/</guid><description>Local mock 1 is usually used for service downgrade, such as a verification service, the client does not throw an exception when the service provider hangs up all the time, but returns the authorization failed through the Mock data.
Configured in the spring configuration file as follows:
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; mock=&amp;#34;true&amp;#34; /&amp;gt; or
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; mock=&amp;#34;com.foo.BarServiceMock&amp;#34; /&amp;gt; Mock implementation in the project 2：
package com.foo; public class BarServiceMock implements BarService { public String sayHello(String name) { // You can return mock data, this method is only executed when an RpcException is thrown.</description></item><item><title>Delay Publish</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/delay-publish/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/delay-publish/</guid><description>If your services need time to warm up, such as: initialization cache or another reference resources has to be ready. You can use the delay feature to delay publishing services. We fine-tuned the service delay exposure logic in Dubbo 2.6.5, delaying the countdown of services that require delayed exposure until Spring initialization is complete. You won&amp;rsquo;t be aware of this change while using Dubbo, so please be assured that use.</description></item><item><title>Concurrency Control</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/concurrency-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/concurrency-control/</guid><description>Example of configuration Example 1: Control the concurrency of all method for a specified service interface at server-side Limit each method of com.foo.BarService to no more than 10 concurrent server-side executions (or take up thread pool threads):
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; executes=&amp;#34;10&amp;#34; /&amp;gt; Example 2: Control the concurrency of specified method for a specified service interface at server-side Limit the sayHello method of com.foo.BarService to no more than 10 concurrent server-side executions(or take up thread pool threads):</description></item><item><title>Config connections</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/config-connections/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/config-connections/</guid><description>Control connections at server-side Limit server-side accept to no more than 10 connections
&amp;lt;dubbo:provider protocol=&amp;#34;dubbo&amp;#34; accepts=&amp;#34;10&amp;#34; /&amp;gt; OR
&amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; accepts=&amp;#34;10&amp;#34; /&amp;gt; Control connections at client-side Limit client-side creating connection to no more than 10 connections for interface com.foo.BarService.
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; connections=&amp;#34;10&amp;#34; /&amp;gt; OR
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; connections=&amp;#34;10&amp;#34; /&amp;gt; Warning If used default protocol(dubbo protocol), and the value of connections attribute is great than 0,then each service reference will has itself connection,else all service which belong to same remote server will share only one connection.</description></item><item><title>Lazy Connect</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/lazy-connect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/lazy-connect/</guid><description>Lazy connect can reduce the number of keep-alive connections. When a call is initiated, create a keep-alive connection.1
&amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; lazy=&amp;#34;true&amp;#34; /&amp;gt; Note: This configuration takes effect only for dubbo protocols that use keep-alive connections.&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>Stickiness Connection</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/stickiness/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/stickiness/</guid><description>Sticky connections are used for stateful services, as much as possible so that clients always make calls to the same provider, unless the provider hangs up and connects to the other one.
Sticky connections will automatically open Lazy Connection to reduce the number of long connections.
&amp;lt;dubbo:reference id=&amp;#34;xxxService&amp;#34; interface=&amp;#34;com.xxx.XxxService&amp;#34; sticky=&amp;#34;true&amp;#34; /&amp;gt; Dubbo supports method-level sticky connection, and if you want more granular control, you can also configure as follows.
&amp;lt;dubbo:reference id=&amp;#34;xxxService&amp;#34; interface=&amp;#34;com.</description></item><item><title>Token Authorization</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/token-authorization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/token-authorization/</guid><description>Through the token authorization control center at the registry to decide whether to issue tokens to consumers, you can prevent consumers from bypassing the registry access provider, another through the registry can flexibly change the authorization without modification or upgrade provider
You can turn on token authentication globally:
&amp;lt;!--Random token , generated using a UUID--&amp;gt; &amp;lt;dubbo:provider token=&amp;#34;true&amp;#34; /&amp;gt; or
&amp;lt;!--Fixed token, equivalent to the password--&amp;gt; &amp;lt;dubbo:provider token=&amp;#34;123456&amp;#34; /&amp;gt; Of course can turn on token authentication at service level:</description></item><item><title>Routing Rule</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/routing-rule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/routing-rule/</guid><description>The routing rules 1 determine the target server of one service call. It has two kinds of routing rules: conditional routing rules and script routing rules. It also support extension2.
Write Routing Rules Writing routing rules to the registry is usually done by the monitoring center or the console page.
RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(&amp;#34;zookeeper://10.20.153.10:2181&amp;#34;)); registry.register(URL.valueOf(&amp;#34;route://0.0.0.0/com.foo.BarService?category=routers&amp;amp;dynamic=false&amp;amp;rule=&amp;#34; + URL.encode(&amp;#34;host = 10.20.153.10 =&amp;gt; host = 10.20.153.11&amp;#34;))); 其中：
route:// It indicates the type of routing rules, supports routing rules and script routing rules, and can be extended.</description></item><item><title>Configure rule</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/config-rule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/config-rule/</guid><description>Write then dynamic configuration to the registry center,This feature is usually done by the monitoring center or the center&amp;rsquo;s page.
RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(&amp;#34;zookeeper://10.20.153.10:2181&amp;#34;)); registry.register(URL.valueOf(&amp;#34;override://0.0.0.0/com.foo.BarService?category=configurators&amp;amp;dynamic=false&amp;amp;application=foo&amp;amp;timeout=1000&amp;#34;)); In the config override url：
override:// Indicates that the data is overwritten,support override and absent，can extends，Required. 0.0.0.0 Indicates that the configurations is valid for all IP addresses，If only want to overwritten specified ip data,you can replace that specified ip address.Required. com.foo.BarService Indicates that is valid for specified service,Required.</description></item><item><title>Service Downgrade</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/service-downgrade/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/service-downgrade/</guid><description>You can temporarily shield a non-critical service through the service downgrade and define the return policy for it.
Publish dynamic configuration rule to the registry:
RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(&amp;#34;zookeeper://10.20.153.10:2181&amp;#34;)); registry.register(URL.valueOf(&amp;#34;override://0.0.0.0/com.foo.BarService?category=configurators&amp;amp;dynamic=false&amp;amp;application=foo&amp;amp;mock=force:return+null&amp;#34;)); The configuration mock=force:return+null means that all calls of this service will return null value directly,without making remote calls.Usually used to reduce the effect of some slow non-critical services.
Also you can change that configuration to mock=fail:return+null.Then you will get null value after a failed call.</description></item><item><title>Graceful Shutdown</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/graceful-shutdown/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/graceful-shutdown/</guid><description>Dubbo is graceful shutdown through the ShutdownHook of the JDK, so graceful shutdowns are not performed if you force shutdown the command, such as kill -9 PID, and will only be executed if kill PID is passed.
Howto Service provider When stop, first marked as not receiving new requests, the new request directly return the error, so that the client retries other machines. Then check thread pool thread is running, if any, waiting for all threads to complete execution, unless overtime, then forced to close.</description></item><item><title>Hostname Binding</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/hostname-binding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/hostname-binding/</guid><description>Lookup order Default host IP lookup order：
Get local address via LocalHost.getLocalHost(). If it is 127. * loopback address, then scan the network for host IP Host configuration Registered address if it is not correct, such as the need to register public address, you can do this:
edit /etc/hosts : add machinename and public ip, such as:
test1 205.182.23.201 in dubbo.xml add host address configuration:
&amp;lt;dubbo:protocol host=&amp;#34;205.182.23.201&amp;#34;&amp;gt; or config that in dubbo.</description></item><item><title>Logger Strategy</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/logger-strategy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/logger-strategy/</guid><description>2.2.1 or later, dubbo support log4j、slf4j、jcl、jdk adapters 1, you can also explicitly configure the log output policy in the following ways:
Command
java -Ddubbo.application.logger=log4j Configure in dubbo.properties
dubbo.application.logger=log4j Configure in dubbo.xml
&amp;lt;dubbo:application logger=&amp;#34;log4j&amp;#34; /&amp;gt; Custom Extensions: logger-adapter&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>Access Log</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/accesslog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/accesslog/</guid><description>If you want to log the access information for each provide service,you can turn on the accesslog switch,which like the access log of Apache.
Warning The size of the access log maybe too much,please check the disk capacity. Now I will show you how to config the access log. Logging by logging framework &amp;lt;dubbo:protocol accesslog=&amp;#34;true&amp;#34; .../&amp;gt; The above configuration will turn on accesslog switch for all provide services,and logging the access log with logging framework(log4j/logback/slf4j&amp;hellip;).</description></item><item><title>Service Container</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/service-container/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/service-container/</guid><description>The service container is a standalone launcher because the backend service does not require the functionality of a Web container ,such as Tomcat or JBoss. If you insist on using web containers to load service providers, that increase complexity and is waste of resources.
The service container is just a simple Main method and loads a simple Spring container to expose the service.
The content of Service container can be extended, built-in spring, jetty, log4j etc.</description></item><item><title>ReferenceConfig Cache</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/reference-config-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/reference-config-cache/</guid><description>The instance of ReferenceConfig is heavy. It encapsulates the connection to the registry and the connection to the provider, so it need to be cached. Otherwise, repeatedly generating ReferenceConfig may cause performance problems , memory and connection leaks. This problem is easy to ignored when programming in API mode.
Therefore, since 2.4.0, dubbo provides a simple utility ReferenceConfigCache for caching instances of ReferenceConfig.
Use as follows：
ReferenceConfig&amp;lt;XxxService&amp;gt; reference = new ReferenceConfig&amp;lt;XxxService&amp;gt;(); reference.</description></item><item><title>Register Only</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/registry-only/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/registry-only/</guid><description>You have two mirroring environments, two registries. You have deployed one service at only one of the registries, another registries have not had time to deploy, and other applications at both registries need to rely on the service. At this time, the service provider registers service to another registrar, but the service consumers do not consume the service from another registrar.
Disable subscription configuration
&amp;lt;dubbo:registry id=&amp;#34;hzRegistry&amp;#34; address=&amp;#34;10.20.153.10:9090&amp;#34; /&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;qdRegistry&amp;#34; address=&amp;#34;10.</description></item><item><title>Distributed transaction</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/distributed-transaction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/distributed-transaction/</guid><description>Distributed transactions are based on the JTA / XA specification(this feature has not yet been implemented)
Two-phase commit:
In Dubbo, Seate can be used to support distributed transactions.</description></item><item><title>Thread Dump</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/dump/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/dump/</guid><description>When the business thread pool is full, we need to know what resources/conditions are waiting for the thread , to find the bottleneck point of the system or abnormal point. dubbo automatically export thread stack through Jstack to keep the scene for easy to troubleshoot the problem.
Default policy:
Export file path，user.home directory Export interval，The shortest interval allows you to export every 10 minutes Specified export file path:
# dubbo.properties dubbo.</description></item><item><title>Netty4</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/netty4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/netty4/</guid><description>Add support for netty4 communication module in 2.5.6 version of dubbo, enabled as follows:
provider：
&amp;lt;dubbo:protocol server=&amp;#34;netty4&amp;#34; /&amp;gt; or
&amp;lt;dubbo:provider server=&amp;#34;netty4&amp;#34; /&amp;gt; consumer：
&amp;lt;dubbo:consumer client=&amp;#34;netty4&amp;#34; /&amp;gt; Warning If provider need to use different communication layer framework for different protocols , please configure multiple protocols separately.
consumer configuration as follow：
&amp;lt;dubbo:consumer client=&amp;#34;netty&amp;#34;&amp;gt; &amp;lt;dubbo:reference /&amp;gt; &amp;lt;/dubbo:consumer&amp;gt; &amp;lt;dubbo:consumer client=&amp;#34;netty4&amp;#34;&amp;gt; &amp;lt;dubbo:reference /&amp;gt; &amp;lt;/dubbo:consumer&amp;gt; Next we will continue to do something：We will provide a reference data on the performance test indicators and performance test comparison with the version of netty 3.</description></item><item><title>Serialization</title><link>https://dubbo.apache.org/en/docs/v2.7/user/examples/serialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/examples/serialization/</guid><description>Using Kryo and FST is very simple, just add an attribute to the dubbo RPC XML configurition:
&amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; serialization=&amp;#34;kryo&amp;#34;/&amp;gt; &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; serialization=&amp;#34;fst&amp;#34;/&amp;gt; Register serialized class For releasing the high ability of Kryo and FST, it&amp;rsquo;s best to register the classes that need serializing into the dubbo system. For example, we can implement the following callback interface:
public class SerializationOptimizerImpl implements SerializationOptimizer { public Collection&amp;lt;Class&amp;gt; getSerializableClasses() { List&amp;lt;Class&amp;gt; classes = new LinkedList&amp;lt;Class&amp;gt;(); classes.</description></item></channel></rss>