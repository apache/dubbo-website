<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Preface on Apache Dubbo</title><link>https://dubbo.apache.org/en/docs/v2.7/user/preface/</link><description>Recent content in Preface on Apache Dubbo</description><generator>Hugo</generator><language>en</language><atom:link href="https://dubbo.apache.org/en/docs/v2.7/user/preface/index.xml" rel="self" type="application/rss+xml"/><item><title>Background</title><link>https://dubbo.apache.org/en/docs/v2.7/user/preface/background/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/preface/background/</guid><description>&lt;h1 id="background">Background&lt;/h1>
&lt;p>With the fast development of Internet, the scale of web applications expands unceasingly, and finally we find that the traditional vertical architecture(monolithic) can not handle this any more. Distributed service architecture and the flow computing architecture are imperative, and a governance system is urgently needed to ensure an orderly evolution of the architecture.&lt;/p>
&lt;p>&lt;img alt="image" src="https://dubbo.apache.org/imgs/user/dubbo-architecture-roadmap.jpg">&lt;/p>
&lt;h4 id="monolithic-architecture">Monolithic architecture&lt;/h4>
&lt;p>When the traffic is very low, there is only one application, all the features are deployed together to reduce the deployment node and cost. At this point, the data access framework (ORM) is the key to simplifying the workload of the CRUD.&lt;/p></description></item><item><title>Requirements</title><link>https://dubbo.apache.org/en/docs/v2.7/user/preface/requirements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/preface/requirements/</guid><description>&lt;h1 id="requirements">Requirements&lt;/h1>
&lt;p>&lt;img alt="image" src="https://dubbo.apache.org/imgs/user/dubbo-service-governance.jpg">&lt;/p>
&lt;p>Before the advent of large-scale services, an application might just exposes or references remote service by using RMI or Hessian, the call is done by configuring service URL, and load balance is done through hardwares, like F5.&lt;/p>
&lt;p>&lt;strong>When there are more and more services, it becomes very difficult to configure the service URL, the single point pressure of F5 hardware load balancer is also increasing.&lt;/strong> At this point, a service registry is needed to dynamically register and discover services to make the service&amp;rsquo;s location transparent. By obtaining the list of service provider addresses in the consumer side, the soft load balancing and Failover can be realized, this reduces the dependence on the F5 hardware load balancer and some of the costs.&lt;/p></description></item><item><title>Architecture</title><link>https://dubbo.apache.org/en/docs/v2.7/user/preface/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/preface/architecture/</guid><description>&lt;p>&lt;img alt="dubbo-architucture" src="https://dubbo.apache.org/imgs/user/dubbo-architecture.jpg">&lt;/p>
&lt;h5 id="specification-of-nodes-role">Specification of Node&amp;rsquo;s Role&lt;/h5>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: left">Node&lt;/th>
 &lt;th style="text-align: left">Role Spec&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: left">&lt;code>Provider&lt;/code>&lt;/td>
 &lt;td style="text-align: left">The provider exposes remote services&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;code>Consumer&lt;/code>&lt;/td>
 &lt;td style="text-align: left">The consumer calls the remote services&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;code>Registry&lt;/code>&lt;/td>
 &lt;td style="text-align: left">The registry is responsible for service discovery and configuration&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;code>Monitor&lt;/code>&lt;/td>
 &lt;td style="text-align: left">The monitor counts the number of service invocations and time-consuming&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;code>Container&lt;/code>&lt;/td>
 &lt;td style="text-align: left">The container manages the services&amp;rsquo;s lifetime&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h5 id="service-relationship">Service relationship&lt;/h5>
&lt;ol start="0">
&lt;li>&lt;code>Container&lt;/code> is responsible for launching, loading, and running the service &lt;code>Provider&lt;/code>.&lt;/li>
&lt;li>&lt;code>Provider&lt;/code> registers its services to &lt;code>Register&lt;/code> at the time it starts.&lt;/li>
&lt;li>&lt;code>Consumer&lt;/code> subscribes the services it needs from the &lt;code>Register&lt;/code> when it starts.&lt;/li>
&lt;li>&lt;code>Register&lt;/code> returns the &lt;code>Provider&lt;/code>s list to &lt;code>Consumer&lt;/code>, when it changes, the &lt;code>Register&lt;/code> will push the changed data to &lt;code>Consumer&lt;/code> through long connection.&lt;/li>
&lt;li>&lt;code>Consumer&lt;/code> selects one of the &lt;code>Provider&lt;/code>s based on soft load balancing algorithm and executes the invocation, if fails, it will choose another &lt;code>Provider&lt;/code>.&lt;/li>
&lt;li>Both &lt;code>Consumer&lt;/code> and &lt;code>Provider&lt;/code> will count the number service invocations and time-consuming in memory, and send the statistics to &lt;code>Monitor&lt;/code> every minute.&lt;/li>
&lt;/ol>
&lt;p>Dubbo has the following features: Connectivity, Robustness, Scalability and Upgradeability.&lt;/p></description></item><item><title>Usage</title><link>https://dubbo.apache.org/en/docs/v2.7/user/preface/usage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/preface/usage/</guid><description>&lt;h2 id="spring-configuration-of-local-service">Spring configuration of local service&lt;/h2>
&lt;p>local.xml:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;bean&lt;/span> id=&lt;span style="color:#2aa198">“xxxService”&lt;/span> class=&lt;span style="color:#2aa198">“com.xxx.XxxServiceImpl”&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;bean&lt;/span> id=&lt;span style="color:#2aa198">“xxxAction”&lt;/span> class=&lt;span style="color:#2aa198">“com.xxx.XxxAction”&lt;/span>&lt;span style="color:#268bd2">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;lt;property&lt;/span> name=&lt;span style="color:#2aa198">“xxxService”&lt;/span> ref=&lt;span style="color:#2aa198">“xxxService”&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;/bean&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="spring-configuration-of-remote-service">Spring configuration of remote service&lt;/h2>
&lt;p>The remote configuration can be done by very little change based on the local configuration:&lt;/p>
&lt;ul>
&lt;li>split the &lt;code>local.xml&lt;/code> into two part, put the service define part into &lt;code>remote-privider.xml&lt;/code>(exists in the provider node), meanwhile the refrence part into &lt;code>remote-consumer.xml&lt;/code>(exists in the consumer node).&lt;/li>
&lt;li>add &lt;code>&amp;lt;dubbo:service&amp;gt;&lt;/code> to the provider&amp;rsquo;s configuration, and &lt;code>&amp;lt;dubbo:reference&amp;gt;&lt;/code> to the consumer&amp;rsquo;s configuration.&lt;/li>
&lt;/ul>
&lt;p>remote-provider.xml:&lt;/p></description></item></channel></rss>