<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Apache Dubbo – Preface</title><link>https://dubbo.apache.org/en/docs/v2.7/user/preface/</link><description>Recent content in Preface on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://dubbo.apache.org/en/docs/v2.7/user/preface/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Background</title><link>https://dubbo.apache.org/en/docs/v2.7/user/preface/background/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/preface/background/</guid><description>
&lt;h1 id="background">Background&lt;/h1>
&lt;p>With the fast development of Internet, the scale of web applications expands unceasingly, and finally we find that the traditional vertical architecture(monolithic) can not handle this any more. Distributed service architecture and the flow computing architecture are imperative, and a governance system is urgently needed to ensure an orderly evolution of the architecture.&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/user/dubbo-architecture-roadmap.jpg" alt="image">&lt;/p>
&lt;h4 id="monolithic-architecture">Monolithic architecture&lt;/h4>
&lt;p>When the traffic is very low, there is only one application, all the features are deployed together to reduce the deployment node and cost. At this point, the data access framework (ORM) is the key to simplifying the workload of the CRUD.&lt;/p>
&lt;h4 id="vertical-architecture">Vertical architecture&lt;/h4>
&lt;p>When the traffic gets heavier, add monolithic application instances can not accelerate the access very well, one way to improve efficiency is to split the monolithic into discrete applications. At this point, the Web framework (MVC) used to accelerate front-end page development is the key.&lt;/p>
&lt;h4 id="distributed-service-architecture">Distributed service architecture&lt;/h4>
&lt;p>When there are more and more vertical applications, the interaction between applications is inevitable, some core businesses are extracted and served as independent services, which gradually forms a stable service center，this way the front-end application can respond to the changeable market demand more quickly. At this point, the distributed service framework (RPC) for business reuse and integration is the key.&lt;/p>
&lt;h4 id="flow-computing-architecture">Flow computing architecture&lt;/h4>
&lt;p>When there are more and more services, capacity evaluation becomes difficult, and also services with small scales often causes waste of resources. To solve these problems, a scheduling center should be added to manage the cluster capacity based on traffics and to improve the utilization of the cluster. At this time, the resource scheduling and governance centers (SOA), which are used to improve machine utilization, are the keys.&lt;/p></description></item><item><title>Docs: Requirements</title><link>https://dubbo.apache.org/en/docs/v2.7/user/preface/requirements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/preface/requirements/</guid><description>
&lt;h1 id="requirements">Requirements&lt;/h1>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/user/dubbo-service-governance.jpg" alt="image">&lt;/p>
&lt;p>Before the advent of large-scale services, an application might just exposes or references remote service by using RMI or Hessian, the call is done by configuring service URL, and load balance is done through hardwares, like F5.&lt;/p>
&lt;p>&lt;strong>When there are more and more services, it becomes very difficult to configure the service URL, the single point pressure of F5 hardware load balancer is also increasing.&lt;/strong> At this point, a service registry is needed to dynamically register and discover services to make the service&amp;rsquo;s location transparent. By obtaining the list of service provider addresses in the consumer side, the soft load balancing and Failover can be realized, this reduces the dependence on the F5 hardware load balancer and some of the costs.&lt;/p>
&lt;p>&lt;strong>When things go further, the service dependencies become so complex that it can&amp;rsquo;t even tell which applications to start before, even the architect can&amp;rsquo;t fully describe the application architecture relationships&lt;/strong>. At this time, automatically draw the dependency diagram of the applications is needed to help the architect to be clear of the relationship.&lt;/p>
&lt;p>&lt;strong>Then, the traffic becomes even heavier, the capacity problem of the service is exposed, how many machines are needed to support this service? When should the machine be added?&lt;/strong> To solve these problems, first, the daily service calls and the amount of response time should be counted as a reference for capacity planning. Second, dynamically adjust the weight, increase the weight of an online machine, and recorded the response time changes until it reaches the threshold, record the visits times at this time, then multiply this number of visits by the total number of machines to calculate the capacity in turn.&lt;/p>
&lt;p>Above are the most basic requirements of Dubbo.&lt;/p></description></item><item><title>Docs: Architecture</title><link>https://dubbo.apache.org/en/docs/v2.7/user/preface/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/preface/architecture/</guid><description>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/user/dubbo-architecture.jpg" alt="dubbo-architucture">&lt;/p>
&lt;h5 id="specification-of-nodes-role">Specification of Node&amp;rsquo;s Role&lt;/h5>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Node&lt;/th>
&lt;th>Role Spec&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>Provider&lt;/code>&lt;/td>
&lt;td>The provider exposes remote services&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Consumer&lt;/code>&lt;/td>
&lt;td>The consumer calls the remote services&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Registry&lt;/code>&lt;/td>
&lt;td>The registry is responsible for service discovery and configuration&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Monitor&lt;/code>&lt;/td>
&lt;td>The monitor counts the number of service invocations and time-consuming&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Container&lt;/code>&lt;/td>
&lt;td>The container manages the services&amp;rsquo;s lifetime&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5 id="service-relationship">Service relationship&lt;/h5>
&lt;ol start="0">
&lt;li>&lt;code>Container&lt;/code> is responsible for launching, loading, and running the service &lt;code>Provider&lt;/code>.&lt;/li>
&lt;li>&lt;code>Provider&lt;/code> registers its services to &lt;code>Register&lt;/code> at the time it starts.&lt;/li>
&lt;li>&lt;code>Consumer&lt;/code> subscribes the services it needs from the &lt;code>Register&lt;/code> when it starts.&lt;/li>
&lt;li>&lt;code>Register&lt;/code> returns the &lt;code>Provider&lt;/code>s list to &lt;code>Consumer&lt;/code>, when it changes, the &lt;code>Register&lt;/code> will push the changed data to &lt;code>Consumer&lt;/code> through long connection.&lt;/li>
&lt;li>&lt;code>Consumer&lt;/code> selects one of the &lt;code>Provider&lt;/code>s based on soft load balancing algorithm and executes the invocation, if fails, it will choose another &lt;code>Provider&lt;/code>.&lt;/li>
&lt;li>Both &lt;code>Consumer&lt;/code> and &lt;code>Provider&lt;/code> will count the number service invocations and time-consuming in memory, and send the statistics to &lt;code>Monitor&lt;/code> every minute.&lt;/li>
&lt;/ol>
&lt;p>Dubbo has the following features: Connectivity, Robustness, Scalability and Upgradeability.&lt;/p>
&lt;h2 id="connectivity">Connectivity&lt;/h2>
&lt;ul>
&lt;li>&lt;code>Register&lt;/code> is responsible for the registration and search of service addresses, like directory services, &lt;code>Provider&lt;/code> and &lt;code>Consumer&lt;/code> only interact with the registry during startup, and the registry does not forward requests, so it is less stressed&lt;/li>
&lt;li>&amp;lsquo;Monitor&amp;rsquo; is responsible for counting the number of service invocations and time-consuming, the statistics will assembles in &lt;code>Provider&lt;/code>&amp;rsquo;s and &lt;code>Consumer&lt;/code>&amp;rsquo;s memory first and then sent to &lt;code>Monitor&lt;/code>&lt;/li>
&lt;li>&amp;lsquo;Provider&amp;rsquo; registers services to &amp;lsquo;Register&amp;rsquo; and report time-consuming statistic(not include network overhead) to &amp;lsquo;Monitor&amp;rsquo;&lt;/li>
&lt;li>&amp;lsquo;Consumer&amp;rsquo; gets a list of service provider addresses from &lt;code>Registry&lt;/code>, call the provider directly according to the LB algorithm, report the time-consuming statistic to &lt;code>Monitor&lt;/code>, which includes network overhead&lt;/li>
&lt;li>The connections between &lt;code>Register&lt;/code>, &lt;code>Provider&lt;/code> and &lt;code>Consumer&lt;/code> are long connections, &lt;code>Moniter&lt;/code> is an exception&lt;/li>
&lt;li>&lt;code>Register&lt;/code> is aware of the existence of &lt;code>Provider&lt;/code> through the long connection, when &lt;code>Provider&lt;/code> gets down, &lt;code>Register&lt;/code> will push the event to &lt;code>Consumer&lt;/code>&lt;/li>
&lt;li>It doesn&amp;rsquo;t affect the already running instances of &lt;code>Provider&lt;/code> and &lt;code>Consumer&lt;/code> even all of the &lt;code>Register&lt;/code> and &lt;code>Monitor&lt;/code> get down, since &lt;code>Consumer&lt;/code> got a cache of &lt;code>Provider&lt;/code>s list&lt;/li>
&lt;li>&lt;code>Register&lt;/code> and &lt;code>Monitor&lt;/code> are optional, &lt;code>Consumer&lt;/code> can connect &lt;code>Provider&lt;/code> directly&lt;/li>
&lt;/ul>
&lt;h2 id="robustness">Robustness&lt;/h2>
&lt;ul>
&lt;li>&lt;code>Monitor&lt;/code>&amp;rsquo;s downtime doesn&amp;rsquo;t affect the usage, only lose some sampling data&lt;/li>
&lt;li>When the DB server goes down, &lt;code>Register&lt;/code> can return service &lt;code>Provider&lt;/code>s list to &lt;code>Consumer&lt;/code> by checking its cache, but new &lt;code>Provider&lt;/code> cannot register any services&lt;/li>
&lt;li>&lt;code>Register&lt;/code> is a peer cluster, it will automatically switch to another when any instance goes down&lt;/li>
&lt;li>Even all &lt;code>Register&lt;/code>&amp;rsquo;s instances go down, &lt;code>Provider&lt;/code> and &lt;code>Consumer&lt;/code> can still conmunicate by checking their local cache&lt;/li>
&lt;li>Service &lt;code>Provider&lt;/code>s are stateless, one instance&amp;rsquo;s downtime doesn&amp;rsquo;t affect the usage&lt;/li>
&lt;li>After all the &lt;code>Provider&lt;/code>s of one service go down, &lt;code>Consumer&lt;/code> can not use that service, and infinitely reconnect to wait for service &lt;code>Provider&lt;/code> to recover&lt;/li>
&lt;/ul>
&lt;h2 id="scalability">Scalability&lt;/h2>
&lt;ul>
&lt;li>&lt;code>Register&lt;/code> is a peer cluster that can dynamically increases its instances, all clients will automatically discover the new instances.&lt;/li>
&lt;li>&lt;code>Provider&lt;/code> is stateless, it can dynamically increases the deployment instances, and the registry will push the new service provider information to the &lt;code>Consumer&lt;/code>.&lt;/li>
&lt;/ul>
&lt;h2 id="upgradeablity">Upgradeablity&lt;/h2>
&lt;p>When the service cluster is further expanded and the IT governance structure is further upgraded, dynamic deployment is needed, and the current distributed service architecture will not bring resistance. Here is a possible future architecture:&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/user/dubbo-architecture-future.jpg" alt="dubbo-architucture-futures">&lt;/p>
&lt;h5 id="specification-of-nodes-role-1">Specification of Node&amp;rsquo;s Role&lt;/h5>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Node&lt;/th>
&lt;th>Role Spec&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>Deployer &lt;/code>&lt;/td>
&lt;td>Local proxy for automatic services deployment&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Repository&lt;/code>&lt;/td>
&lt;td>The repository is used to store application packages&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Scheduler&lt;/code>&lt;/td>
&lt;td>The scheduler automatically increases or decreases service providers based on the access pressure&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Admin&lt;/code>&lt;/td>
&lt;td>Unified management console&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Registry&lt;/code>&lt;/td>
&lt;td>the registry is responsible for service discovery and configuration&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Monitor&lt;/code>&lt;/td>
&lt;td>The monitor counts the service call times and time-consuming&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Usage</title><link>https://dubbo.apache.org/en/docs/v2.7/user/preface/usage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs/v2.7/user/preface/usage/</guid><description>
&lt;h2 id="spring-configuration-of-local-service">Spring configuration of local service&lt;/h2>
&lt;p>local.xml:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;bean&lt;/span> id=&lt;span style="color:#2aa198">“xxxService”&lt;/span> class=&lt;span style="color:#2aa198">“com.xxx.XxxServiceImpl”&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;bean&lt;/span> id=&lt;span style="color:#2aa198">“xxxAction”&lt;/span> class=&lt;span style="color:#2aa198">“com.xxx.XxxAction”&lt;/span>&lt;span style="color:#268bd2">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;lt;property&lt;/span> name=&lt;span style="color:#2aa198">“xxxService”&lt;/span> ref=&lt;span style="color:#2aa198">“xxxService”&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;/bean&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="spring-configuration-of-remote-service">Spring configuration of remote service&lt;/h2>
&lt;p>The remote configuration can be done by very little change based on the local configuration:&lt;/p>
&lt;ul>
&lt;li>split the &lt;code>local.xml&lt;/code> into two part, put the service define part into &lt;code>remote-privider.xml&lt;/code>(exists in the provider node), meanwhile the refrence part into &lt;code>remote-consumer.xml&lt;/code>(exists in the consumer node).&lt;/li>
&lt;li>add &lt;code>&amp;lt;dubbo:service&amp;gt;&lt;/code> to the provider&amp;rsquo;s configuration, and &lt;code>&amp;lt;dubbo:reference&amp;gt;&lt;/code> to the consumer&amp;rsquo;s configuration.&lt;/li>
&lt;/ul>
&lt;p>remote-provider.xml:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&amp;lt;!-- define remote service bean the same way as local service bean --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;bean&lt;/span> id=&lt;span style="color:#2aa198">“xxxService”&lt;/span> class=&lt;span style="color:#2aa198">“com.xxx.XxxServiceImpl”&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&amp;lt;!-- expose the remote service --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;dubbo:service&lt;/span> interface=&lt;span style="color:#2aa198">“com.xxx.XxxService”&lt;/span> ref=&lt;span style="color:#2aa198">“xxxService”&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>remote-consumer.xml:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&amp;lt;!-- reference the remote service --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;dubbo:reference&lt;/span> id=&lt;span style="color:#2aa198">“xxxService”&lt;/span> interface=&lt;span style="color:#2aa198">“com.xxx.XxxService”&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&amp;lt;!-- use remote service the same say as local service --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;bean&lt;/span> id=&lt;span style="color:#2aa198">“xxxAction”&lt;/span> class=&lt;span style="color:#2aa198">“com.xxx.XxxAction”&lt;/span>&lt;span style="color:#268bd2">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;lt;property&lt;/span> name=&lt;span style="color:#2aa198">“xxxService”&lt;/span> ref=&lt;span style="color:#2aa198">“xxxService”&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;/bean&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>