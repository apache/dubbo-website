<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Diagnostics and Tuning on Apache Dubbo</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/</link><description>Recent content in Diagnostics and Tuning on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/index.xml" rel="self" type="application/rss+xml"/><item><title>Request time-consuming sampling</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/profiler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/profiler/</guid><description>Function Description The performance sampling function can detect the time consumption of various parts of the Dubbo processing link. When a timeout occurs, ( usageTime / timeout &amp;gt; profilerWarnPercent * 100 ) records the time consumption of calls through logs.
This function is divided into simple profiler and detail profiler two modes, where simple profiler mode is enabled by default, and detail profiler mode is disabled by default. Compared with the simple profiler mode, the detail profiler collects more time-consuming processing of each filter, specific time-consuming protocols, etc.</description></item><item><title>Routing Status Collection</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/router-snapshot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/router-snapshot/</guid><description>Function Description scenes to be used Many of Dubbo&amp;rsquo;s traffic management capabilities are implemented based on Router. In a production environment, if traffic results do not meet expectations, you can use the routing status command to check the routing status to locate possible problems.
How to use View route cache status When Dubbo receives the address change, it will push the address information to all Routers, and these Routers can calculate the routing packets in advance at this stage and cache them to avoid the need to traverse all provider calculations when calling grouping parameters.</description></item><item><title>Service Reference Configuration Object Cache</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/reference-config-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/reference-config-cache/</guid><description>Feature description The ReferenceConfig instance is heavy, encapsulates the connection to the registry and the connection to the provider, and needs to be cached. Otherwise repeatedly generating ReferenceConfig may cause performance problems and have memory and connection leaks. It&amp;rsquo;s easy to overlook this problem when programming in the API way.
Therefore, since 2.4.0 version, dubbo provides a simple tool class ReferenceConfigCache for caching ReferenceConfig instances.
scenes to be used There are scenarios such as gateways that dynamically create subscriptions.</description></item><item><title>Load Balancing</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/loadbalance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/loadbalance/</guid><description>When cluster load balancing, Dubbo provides a variety of balancing strategies, the default is random random calls.
In terms of specific implementation, Dubbo provides client load balancing, that is, the Consumer uses the load balancing algorithm to determine which Provider instance to submit the request to.
You can expand the load balancing strategy by yourself, see: Load Balance Extension
load balancing strategy Currently Dubbo has the following built-in load balancing algorithms, which users can directly configure and use:</description></item><item><title>Registration Information Simplified</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/simplify-registry-data/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/simplify-registry-data/</guid><description>Feature description There are nearly 30 configuration items in the service configuration items in Dubbo provider. Excluding the need for registry service governance, a large part of configuration items are used by the provider itself and do not need to be transparently passed to consumers. This part of data does not need to enter the registry, but only needs to be stored persistently in the form of key-value.
The configuration items in Dubbo consumer also have 20+ configuration items.</description></item><item><title>Call Result Cache</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/result-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/result-cache/</guid><description>Feature description cache type lru deletes redundant caches based on the least recently used principle, keeping the hottest data cached. threadlocal The current thread cache, such as a page rendering, uses many portals, and each portal needs to check user information. Through thread caching, this redundant access can be reduced. jcache integrates with JSR107 to bridge various cache implementations. Cache Type Extensible Cache Extensions
About sample code
scenes to be used The result cache is used to speed up access to popular data.</description></item><item><title>Concurrency Control</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/concurrency-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/concurrency-control/</guid><description>Configuration example Example 1 To limit each method of com.foo.BarService, the concurrent execution on the server side (or the number of threads in the thread pool) cannot exceed 10:
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; executes=&amp;#34;10&amp;#34; /&amp;gt; Example 2 To limit the sayHello method of com.foo.BarService, the concurrent execution on the server side (or the number of threads in the thread pool) cannot exceed 10:
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;sayHello&amp;#34; executes=&amp;#34;10&amp;#34; /&amp;gt; &amp;lt;/dubbo:service&amp;gt; Example 3 Limit each method of com.</description></item><item><title>Connection Control</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/config-connections/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/config-connections/</guid><description>Feature description scenes to be used How to use Server connection control Limit the number of connections accepted by the server to no more than 10 1:
&amp;lt;dubbo:provider protocol=&amp;#34;dubbo&amp;#34; accepts=&amp;#34;10&amp;#34; /&amp;gt; or
&amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; accepts=&amp;#34;10&amp;#34; /&amp;gt; Client connection control Limit the client service to use no more than 10 connections 2:
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; connections=&amp;#34;10&amp;#34; /&amp;gt; or
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; connections=&amp;#34;10&amp;#34; /&amp;gt; If both &amp;lt;dubbo:service&amp;gt; and &amp;lt;dubbo:reference&amp;gt; are configured with connections, &amp;lt;dubbo:reference&amp;gt; takes precedence, see: [Configuration override strategy](.</description></item><item><title>Delayed Connection</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/lazy-connect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/lazy-connect/</guid><description>Feature description scenes to be used Delayed connections are used to reduce the number of long connections. When a call is initiated, create a persistent connection.
How to use &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; lazy=&amp;#34;true&amp;#34; /&amp;gt; This configuration is only valid for the dubbo protocol that uses long connections.</description></item><item><title>Stick Connection</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/stickiness/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/stickiness/</guid><description>Feature description scenes to be used Sticky connections are used for stateful services, so that the client always initiates calls to the same provider as much as possible, unless the provider hangs up and connects to another one.
Sticky connection will automatically enable Delayed Connection to reduce the number of long connections.
How to use &amp;lt;dubbo:reference id=&amp;#34;xxxService&amp;#34; interface=&amp;#34;com.xxx.XxxService&amp;#34; sticky=&amp;#34;true&amp;#34; /&amp;gt; Dubbo supports method-level sticky connections, if you want more fine-grained control, you can also configure it like this.</description></item><item><title>Support Graal VM</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/support-graalvm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/support-graalvm/</guid><description>dubbo3.0 supports native-image document
Feature description This document will introduce the process of connecting dubbo3.0 project to GraalVM and compiling native-image into binary.
More information about GraalVm can be read https://www.graalvm.org/docs/getting-started/container-images/ this document.
scenes to be used How to use Before compiling our dubbo project, we need to make sure that we are based on the graalVm environment.
Install GraalVM Go to https://www.graalvm.org/ official website and select the latest version to install according to your own system:</description></item><item><title>Export thread stack</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/dump/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/dump/</guid><description>Feature description Dubbo automatically exports the thread stack through Jstack to keep the scene, which is convenient for troubleshooting.
default policy
Export path: the user&amp;rsquo;s home directory identified by user.home Export Interval: The shortest interval allows an export every 10 minutes Export switch: open by default scenes to be used When the business thread pool is full, we need to know which resources and conditions the threads are waiting for in order to find the bottleneck or abnormal point of the system.</description></item><item><title>Kryo and FST Serialization</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/serialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/performance/serialization/</guid><description>Table of contents Serialization talk Enable Kryo and FST Register the class to be serialized No parameter constructor and Serializable interface Serialization performance analysis and testing test environment Test script Comparison of byte sizes generated by different serializations in Dubbo RPC Comparison of response time and throughput of different serializations in Dubbo RPC future Serialization talk dubbo RPC is the core high-performance, high-throughput remote call method in the dubbo system. I like to call it a multiplexed TCP long connection call.</description></item></channel></rss>