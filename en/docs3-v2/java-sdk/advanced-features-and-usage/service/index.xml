<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Configuration Framework and Service Behavior on Apache Dubbo</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/</link><description>Recent content in Configuration Framework and Service Behavior on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/index.xml" rel="self" type="application/rss+xml"/><item><title>Check at startup</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/preflight-check/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/preflight-check/</guid><description>Feature description By default, Dubbo will check whether the dependent service is available at startup, and will throw an exception when it is unavailable, preventing Spring initialization from completing, so that problems can be detected early when going online. The default check=&amp;quot;true&amp;quot;.
Checking can be turned off by check=&amp;quot;false&amp;quot;. For example, when testing, some services do not care, or there is a circular dependency, and one of them must be started first.</description></item><item><title>Distributed Transactions</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/transaction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/transaction/</guid><description>How to use First step First visit: https://seata.apache.org/unversioned/download/seata-server
Download the seata1.5.2 service we need to use
Second step Add the undo_log table to your database participating in global transactions (TCC, SAGA, XA can skip this step) -- for AT mode you must to init this sql for you business database. the seata server not need it. CREATE TABLE IF NOT EXISTS `undo_log` ( `branch_id` BIGINT(20) NOT NULL COMMENT &amp;#39;branch transaction id&amp;#39;, `xid` VARCHAR(100) NOT NULL COMMENT &amp;#39;global transaction id&amp;#39;, `context` VARCHAR(128) NOT NULL COMMENT &amp;#39;undo_log context, such as serialization&amp;#39;, `rollback_info` LONGBLOB NOT NULL COMMENT &amp;#39;rollback info&amp;#39;, `log_status` INT(11) NOT NULL COMMENT &amp;#39;0: normal status,1: defense status&amp;#39;, `log_created` DATETIME(6) NOT NULL COMMENT &amp;#39;create datetime&amp;#39;, `log_modified` DATETIME(6) NOT NULL COMMENT &amp;#39;modify datetime&amp;#39;, UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`) ) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8 COMMENT = &amp;#39;AT transaction mode undo table&amp;#39;; Create a library named seata in your mysql database, and use the following sql -- -------------------------------- The script used when storeMode is &amp;#39;db&amp;#39; ------- ------------------------- -- the table to store GlobalSession data CREATE TABLE IF NOT EXISTS `global_table` ( `xid` VARCHAR(128) NOT NULL, `transaction_id` BIGINT, `status` TINYINT NOT NULL, `application_id` VARCHAR(32), `transaction_service_group` VARCHAR(32), `transaction_name` VARCHAR(128), `timeout` INT, `begin_time` BIGINT, `application_data` VARCHAR(2000), `gmt_create` DATETIME, `gmt_modified` DATETIME, PRIMARY KEY (`xid`), KEY `idx_gmt_modified_status` (`gmt_modified`, `status`), KEY `idx_transaction_id` (`transaction_id`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8; -- the table to store BranchSession data CREATE TABLE IF NOT EXISTS `branch_table` ( `branch_id` BIGINT NOT NULL, `xid` VARCHAR(128) NOT NULL, `transaction_id` BIGINT, `resource_group_id` VARCHAR(32), `resource_id` VARCHAR(256), `branch_type` VARCHAR(8), `status` TINYINT, `client_id` VARCHAR(64), `application_data` VARCHAR(2000), `gmt_create` DATETIME(6), `gmt_modified` DATETIME(6), PRIMARY KEY (`branch_id`), KEY `idx_xid` (`xid`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8; -- the table to store lock data CREATE TABLE IF NOT EXISTS `lock_table` ( `row_key` VARCHAR(128) NOT NULL, `xid` VARCHAR(96), `transaction_id` BIGINT, `branch_id` BIGINT NOT NULL, `resource_id` VARCHAR(256), `table_name` VARCHAR(32), `pk` VARCHAR(36), `gmt_create` DATETIME, `gmt_modified` DATETIME, PRIMARY KEY (`row_key`), KEY `idx_branch_id` (`branch_id`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8; third step Introduce seata dependency into your project</description></item><item><title>Group Aggregation</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/group-merger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/group-merger/</guid><description>Feature description Aggregate the results by grouping and return the aggregated results, such as menu service, use group to distinguish multiple implementations of the same interface, now the consumer needs to call once from each group and return the result, and return the result after merging, so You can implement aggregated menu items.
For relevant codes, please refer to Samples in the dubbo project
scenes to be used Service Grouping and Multiple Versions</description></item><item><title>Port Protocol Multiplexing</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/port-unification/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/port-unification/</guid><description>Feature description By configuring the protocol, dubbo3 can support port protocol multiplexing. For example, after using the Triple protocol to enable port multiplexing, you can add Dubbo protocol support, and Qos protocol support. These protocols are identified by a unified port multiplexing It can be used for service protocol migration, which is processed by the server, and can save ports and related resources and reduce the complexity of operation and maintenance.</description></item><item><title>Reactive Programming</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/reactive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/reactive/</guid><description>Feature description This feature is implemented based on the Triple protocol and Project Reactor, and is supported in versions above 3.1.0. Users only need to write the IDL file and specify the corresponding Generator of the protobuf plug-in to generate and use the Stub code that supports the responsive API.
There are four call modes, namely OneToOne, OneToMany, ManyToOne, and ManyToMany, corresponding to Unary calls, server streams, client streams, and bidirectional streams.</description></item><item><title>Service Version</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/multi-versions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/multi-versions/</guid><description>Feature description Follow the steps below for version migration
During low-stress periods, first upgrade half of the providers to the new version Upgrade all consumers to the new version Then upgrade the remaining half of the providers to the new version Configuration Old and new versions of service providers New and old version service consumers scenes to be used When an interface is implemented and an incompatible upgrade occurs, the version number can be used for transition, and services with different version numbers do not refer to each other.</description></item><item><title>Cluster Fault Tolerance</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/fault-tolerent-strategy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/fault-tolerent-strategy/</guid><description>When the cluster call fails, Dubbo provides a variety of fault tolerance schemes, and the default is failover retry.
Each node relationship:
Here Invoker is an abstraction of Provider that can call Service, Invoker encapsulates Provider address and Service interface information Directory represents multiple Invoker, which can be regarded as List&amp;lt;Invoker&amp;gt;, but different from List, its value may change dynamically, such as the registration center pushing changes Cluster disguises multiple Invoker in Directory as an Invoker, which is transparent to the upper layer.</description></item><item><title>Parameter Validation</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/parameter-validation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/parameter-validation/</guid><description>Feature description The parameter verification function is implemented based on JSR303, users only need to identify the verification annotation of the JSR303 standard, and realize the verification by declaring the filter.
Maven dependencies &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.validation&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;validation-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0.GA&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hibernate-validator&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.2.0.Final&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; scenes to be used When the server provides interface services to the outside, it solves various interface parameter verification problems.
Reference use case https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-validation
How to use Parameter annotation example import java.</description></item><item><title>Service Group</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/service-group/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/service-group/</guid><description>Feature description The same interface can use service grouping to distinguish different implementation methods for different business scenarios, different usage requirements, or different functional modules. At the same time, the services provided by these different implementations can coexist and support mutual calls.
scenes to be used When an interface has multiple implementations, it can be distinguished by group.
Reference use case https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-group
How to use Annotation configuration Service provider (annotation configuration) Use @DubboService annotation, add group parameter</description></item><item><title>Asynchronous call</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/async-call/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/async-call/</guid><description>Feature description background Starting from 2.7.0, all asynchronous programming interfaces of Dubbo are based on CompletableFuture
Based on NIO&amp;rsquo;s non-blocking implementation of parallel calls, the client does not need to start multi-threads to complete parallel calls to multiple remote services, and the overhead of multi-threading is relatively small.
Reference use case https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-async
scenes to be used Send the user request content to the target request. When the target request encounters high traffic or needs to be processed for a long time, the asynchronous call function will allow the response to be returned to the user immediately, while the target request continues to process the request in the background.</description></item><item><title>Service Downgrade</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/service-downgrade/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/service-downgrade/</guid><description>Feature description It is recommended to use relevant current limiting and downgrading components (such as Sentinel) to achieve the best experience. Reference example practice: Microservice Governance/Limit and Downgrade
Service degradation refers to the emergency treatment of service degradation under abnormal circumstances.
scenes to be used When the load of a certain service or interface exceeds the maximum carrying capacity range, downgrade emergency treatment is required to avoid system crash When a non-critical service or interface called is temporarily unavailable, simulated data or null is returned, and the business can continue to be available Downgrade non-core business services or interfaces, free up system resources, and try to ensure the normal operation of core business When an upstream basic service times out or is unavailable, execute a downgrade plan that can respond quickly to avoid the overall avalanche of services How to use Take xml configuration as an example: (configuration through annotations is similar)</description></item><item><title>Generalization call (client generalization)</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/generic-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/generic-reference/</guid><description>Feature description Generalized call refers to calling the server without the API (SDK) provided by the server, and the call result can be obtained normally.
scenes to be used The generalization call is mainly used to implement a general remote service mock framework, which can handle all service requests by implementing the GenericService interface. For example, the following scenario:
Gateway service: If you want to build a gateway service, then the service gateway should be the calling end of all RPC services.</description></item><item><title>Stream Communication</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/streaming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/streaming/</guid><description>TBD</description></item><item><title>Thread Pool Isolation</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/isolation-executor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/isolation-executor/</guid><description>Feature description A new thread pool management method enables the thread pools of each service in the provider application to be isolated and independent from each other. The exhaustion of the thread pool resources of a certain service will not affect other normal services. Support thread pool configurable, manually specified by the user.
scenes to be used How to use Currently, it can be configured in the form of API, XML, and Annotation</description></item><item><title>Call link to pass implicit parameters</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/attachment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/attachment/</guid><description>Feature description Parameters can be implicitly passed between the service consumer and the provider through setAttachment and getAttachment on RpcContext.
background Context information is a very important function of the RPC framework. Using RpcContext can specify different configurations for a single call. For example, in the distributed link tracking scenario, the implementation principle is to maintain a traceId in the context of the entire link. The Consumer and Provider connect an RPC call by passing the traceId.</description></item><item><title>Direct Connection Provider</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/explicit-target/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/explicit-target/</guid><description>This document is no longer maintained. You are currently viewing a snapshot version. If you want to view the latest version of the documentation, see Latest Version.
In the development and testing environment, it is often necessary to bypass the registration center and only test the specified service provider. At this time, point-to-point direct connection may be required. The point-to-point direct connection method will use the service interface as the unit and ignore the provider list of the registration center.</description></item><item><title>Dynamic IP call</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/specify-ip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/specify-ip/</guid><description>Feature description Use the extension of Dubbo to realize the specified IP call.
scenes to be used When initiating a request, you need to specify the server for this call, such as message callback, traffic isolation, etc.
How to use Plugin dependencies Adapt to Dubbo 3 version
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-cluster-specify-address-dubbo3&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; Adapt to Dubbo 2 version
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-cluster-specify-address-dubbo2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; call example ReferenceConfig&amp;lt;DemoService&amp;gt; referenceConfig = new ReferenceConfig&amp;lt;&amp;gt;(); // .</description></item><item><title>Consistent Hash Site Selection</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/consistent-hash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/consistent-hash/</guid><description>Feature description [Analysis of Dubbo Consistent Hash Load Balancing Implementation](/zh-cn/blog/2019/05/01/dubbo-%E4%B8%80%E8%87%B4%E6%80%A7hash%E8%B4%9F%E8 %BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0%E5%89%96%E6%9E%90/)
scenes to be used When there are multiple servers, the server is selected according to the consistent hashing of the request parameters.
How to use There are many ways to configure consistent hashing, the most common are:
Annotation configuration @DubboReference(loadbalance = &amp;ldquo;consistenthash&amp;rdquo;)
API configuration referenceConfig.setLoadBalance(&amp;ldquo;consistenthash&amp;rdquo;);
Properties configuration dubbo.reference.loadbalance=consistenthash
XML configuration &amp;lt;dubbo:reference loadbalance=&amp;ldquo;consistenthash&amp;rdquo; /&amp;gt;
By default, the first parameter is used as the hash key.</description></item><item><title>RPC call context</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/context/</guid><description>Feature description The context stores the environment information needed in the current calling process. All configuration information will be converted to URL parameters, see the corresponding URL parameters column in schema configuration reference manual.
RpcContext is a temporary state recorder for ThreadLocal. When RPC requests are received or RPC requests are initiated, the state of RpcContext will change. For example: A tunes B, B then tunes C, then on machine B, before B tunes C, RpcContext records the information of A&amp;rsquo;s tune to B, after B tunes C, RpcContext records the information of B&amp;rsquo;s tune to C.</description></item><item><title>Subscription Only</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/subscribe-only/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/subscribe-only/</guid><description>Feature description In order to facilitate development and testing, a registration center that is available for all services is often shared offline. At this time, if a service provider under development registers, it may affect the normal operation of consumers.
The service provider developer can only subscribe to the service (the developed service may depend on other services), without registering the service under development, and test the service under development through direct connection.</description></item><item><title>Call trigger event notification</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/events-notify/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/events-notify/</guid><description>Feature description Before calling, after calling, and when an exception occurs, three events oninvoke, onreturn, and onthrow will be triggered. You can configure which method of which class to notify when an event occurs.
Reference use case https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-notify
scenes to be used Before calling the service method, we can record the start time, and after the call ends, we can count the entire call cost. When an exception occurs, we can warn or print error logs, or record request logs and response logs before and after calling the service.</description></item><item><title>Multi-protocol</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/multi-protocols/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/multi-protocols/</guid><description>Feature description Dubbo allows multi-protocol configuration, supports different protocols on different services or supports multiple protocols on the same service at the same time.
scenes to be used How to use Different protocols for different services Different services apply different protocols for transmission in terms of performance. For example, short connection protocols are used for large data, and long connection protocols are used for small data and large concurrency.
&amp;lt;?xml version=&amp;#34;1.</description></item><item><title>The server makes a callback to the client</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/callback-parameter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/callback-parameter/</guid><description>Feature description The parameter callback method is the same as calling a local callback or listener, you only need to declare which parameter is the callback type in the Spring configuration file. Dubbo will generate a reverse proxy based on the persistent connection, so that the client logic can be invoked from the server. You can refer to sample code in the dubbo project.
scenes to be used The callback function notifies the client of the execution result, or sends a notification.</description></item><item><title>Local Masquerade</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/local-mock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/local-mock/</guid><description>Feature description There is a mechanism in Dubbo3 to achieve lightweight service degradation, which is local masquerade1.
scenes to be used Local masquerading is often used for service degradation. For example, for a verification service, when all the service providers hang up, if the service consumer initiates a remote call at this time, the call will fail and an RpcException will be thrown.
In order to avoid such a situation where an exception is thrown directly, the client can use local masquerade to provide Mock data and return authorization failure.</description></item><item><title>Multiple Registries</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/multi-registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/multi-registry/</guid><description>Feature description Dubbo supports the simultaneous registration of the same service to multiple registries, or the registration of different services to different registries, or even references to services with the same name registered on different registries at the same time. In addition, the registry is 1 that supports custom extensions.
scenes to be used How to use Multi-registry registration For example: Some services of the Chinese website are too late to be deployed in Qingdao, and are only deployed in Hangzhou, while other applications in Qingdao need to reference this service, so the service can be registered to two registration centers at the same time.</description></item><item><title>Local Stub</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/local-stub/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/local-stub/</guid><description>Feature description: After the remote service, the client usually only has the interface, and the implementation is all on the server side, but the provider sometimes wants to execute some logic on the client side.
scenes to be used Do ThreadLocal cache, verify parameters in advance, forge fault-tolerant data after call failure, etc. At this time, you need to bring a Stub in the API, and the client generates a Proxy instance, which will pass the Proxy to the Stub through the constructor 1, and then pass the The Stub is exposed to the user, and the Stub can decide whether to call the Proxy.</description></item><item><title>Echo Test</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/echo-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/echo-service/</guid><description>Feature description The echo test is used to detect whether the service is available. The echo test is performed according to the normal request process. It can test whether the entire call is smooth and can be used for monitoring.
Reference use case https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-echo
scenes to be used How to use All services automatically implement the EchoService interface, just cast any service reference to EchoService to use it.
Spring configuration &amp;lt;dubbo:reference id=&amp;#34;memberService&amp;#34; interface=&amp;#34;com.</description></item><item><title>Call Information Record</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/accesslog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/accesslog/</guid><description>Feature description The log in dubbo3 is divided into log adaptation and access log. If you want to record each request information, you can enable the access log, which is similar to the apache access log.
scenes to be used Based on audit needs, etc. similar to nginx accesslog output, etc.
How to use log4j log Output access logs to the current application&amp;rsquo;s log4j log
&amp;lt;dubbo:protocol accesslog=&amp;#34;true&amp;#34; /&amp;gt; specify the file Output the access log to the specified file</description></item><item><title>Achieving generalization (server-side generalization)</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/generic-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/generic-service/</guid><description>Feature description The universal interface implementation method is mainly used when there is no API interface and model classifier on the server side. All POJOs in the parameters and return values are represented by Map, which is usually used for framework integration. For example, to implement a general remote service Mock framework, you can All service requests are handled by implementing the GenericService interface.
scenes to be used How to use Implement the GenericService interface in Java code</description></item><item><title>Asynchronous execution</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/async-execute-on-provider/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/async-execute-on-provider/</guid><description>This document is no longer maintained. You are currently viewing a snapshot version. If you want to see the latest version of the documentation, see Latest Version.
The asynchronous execution of the provider side switches the blocked business from Dubbo&amp;rsquo;s internal thread pool to the business-defined thread, avoiding excessive occupation of the Dubbo thread pool, and helping to avoid the mutual influence between different services. Asynchronous execution is tantamount to saving resources or improving RPC response performance, because if business execution needs to be blocked, there is always a thread to be responsible for execution.</description></item><item><title>Local call</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/local-call/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/local-call/</guid><description>Feature description The local call uses the injvm protocol, which is a pseudo-protocol. It does not open ports, does not initiate remote calls, and is only directly associated in the JVM, but executes Dubbo&amp;rsquo;s Filter chain.
scenes to be used When we need to call a remote service, the remote service has not been developed yet, and similar services are implemented locally using the injvm protocol. When calling this service, we can call our local implementation service.</description></item><item><title>Delayed Exposure</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/delay-publish/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/delay-publish/</guid><description>If your service needs warm-up time, such as initializing the cache, waiting for related resources to be in place, etc., you can use delay for delayed exposure. In Dubbo version 2.6.5, we made minor adjustments to the service delay exposure logic, and postponed the countdown action for services that require delay exposure (delay &amp;gt; 0) until Spring initialization is complete. You will not feel this change while using Dubbo, so please feel free to use it.</description></item><item><title>Sign Up Only</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/registry-only/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/registry-only/</guid><description>Feature description If there are two mirroring environments and two registries, one service is only deployed in one of the registries, and the other registry has not yet been deployed, and other applications in the two registries need to rely on this service. At this time, the service provider can only register the service to another registration center, but not subscribe to the service from another registration center.
scenes to be used How to use Disable subscription configuration &amp;lt;dubbo:registry id=&amp;#34;hzRegistry&amp;#34; address=&amp;#34;10.</description></item><item><title>Distributed transaction support</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/distributed-transaction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/advanced-features-and-usage/service/distributed-transaction/</guid><description>Distributed transactions are implemented based on the JTA/XA specification.
two-phase commit
In Dubbo, you can use [seata](/zh-cn/blog/2019/01/17/How to use seata to ensure the consistency between dubbo microservices/) to complete the support for distributed transactions.</description></item></channel></rss>