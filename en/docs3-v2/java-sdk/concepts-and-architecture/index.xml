<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Concepts and Architecture on Apache Dubbo</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/</link><description>Recent content in Concepts and Architecture on Apache Dubbo</description><generator>Hugo</generator><language>en</language><atom:link href="https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>Overall Architecture</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/overall-architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/overall-architecture/</guid><description>&lt;p>&lt;img alt="dubbo-architecture" src="https://dubbo.apache.org/imgs/user/dubbo-architecture.jpg">&lt;/p>
&lt;h5 id="node-role-description">Node role description&lt;/h5>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: left">Node&lt;/th>
 &lt;th style="text-align: left">Role Description&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: left">&lt;code>Provider&lt;/code>&lt;/td>
 &lt;td style="text-align: left">The service provider of the exposed service&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;code>Consumer&lt;/code>&lt;/td>
 &lt;td style="text-align: left">The service consumer who invokes the remote service&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;code>Registry&lt;/code>&lt;/td>
 &lt;td style="text-align: left">Registry for service registration and discovery&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;code>Monitor&lt;/code>&lt;/td>
 &lt;td style="text-align: left">A monitoring center that counts service calls and call times&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;code>Container&lt;/code>&lt;/td>
 &lt;td style="text-align: left">service running container&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h5 id="description-of-calling-relationship">Description of calling relationship&lt;/h5>
&lt;ol start="0">
&lt;li>The service container is responsible for starting, loading, and running the service provider.&lt;/li>
&lt;li>When the service provider starts, it registers the services it provides with the registration center.&lt;/li>
&lt;li>When a service consumer starts, it subscribes to the registration center for the services it needs.&lt;/li>
&lt;li>The registration center returns the service provider address list to the consumer. If there is a change, the registration center will push the change data to the consumer based on the long connection.&lt;/li>
&lt;li>The service consumer, from the provider address list, selects a provider to call based on the soft load balancing algorithm, and if the call fails, select another provider to call.&lt;/li>
&lt;li>Service consumers and providers accumulate the number of invocations and invocation time in memory, and regularly send statistical data to the monitoring center every minute.&lt;/li>
&lt;/ol>
&lt;p>The Dubbo architecture has the following characteristics, namely connectivity, robustness, scalability, and upgradeability to future architectures.&lt;/p></description></item><item><title>Code Architecture</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/code-architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/code-architecture/</guid><description>&lt;h2 id="overall-design">overall design&lt;/h2>
&lt;p>&lt;img alt="/dev-guide/images/dubbo-framework.jpg" src="https://dubbo.apache.org/imgs/dev/dubbo-framework.jpg">&lt;/p>
&lt;p>illustration:&lt;/p>
&lt;ul>
&lt;li>The light blue background on the left in the figure is the interface used by the service consumer, the light green background on the right is the interface used by the service provider, and the interface on the central axis is the interface used by both parties.&lt;/li>
&lt;li>The figure is divided into ten layers from bottom to top. Each layer is one-way dependent. The black arrow on the right represents the dependency relationship between layers. Each layer can be reused by stripping the upper layer. Among them, the Service and Config layers are API , the other layers are SPI.&lt;/li>
&lt;li>The small green block in the figure is the extension interface, and the small blue block is the implementation class. Only the implementation class used to associate each layer is shown in the figure.&lt;/li>
&lt;li>The blue dotted line in the figure is the initialization process, that is, the assembly chain at startup, the red solid line is the method call process, that is, the runtime call chain, and the purple triangle arrow is inheritance. You can regard the subclass as the same node of the parent class, and the line The text above is the method to call.&lt;/li>
&lt;/ul>
&lt;h2 id="description-of-each-layer">Description of each layer&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Config configuration layer&lt;/strong>: external configuration interface, centered on &lt;code>ServiceConfig&lt;/code>, &lt;code>ReferenceConfig&lt;/code>, can directly initialize configuration classes, or generate configuration classes through spring parsing configuration&lt;/li>
&lt;li>&lt;strong>Proxy service proxy layer&lt;/strong>: service interface transparent proxy, generating service client Stub and server Skeleton, with &lt;code>ServiceProxy&lt;/code> as the center, the extended interface is &lt;code>ProxyFactory&lt;/code>&lt;/li>
&lt;li>&lt;strong>Registry registration center layer&lt;/strong>: Encapsulates the registration and discovery of service addresses, centered on service URLs, and the extended interfaces are &lt;code>RegistryFactory&lt;/code>, &lt;code>Registry&lt;/code>, &lt;code>RegistryService&lt;/code>&lt;/li>
&lt;li>&lt;strong>Cluster routing layer&lt;/strong>: Encapsulate the routing and load balancing of multiple providers, and bridge the registration center, with &lt;code>Invoker&lt;/code> as the center, and the extended interfaces are &lt;code>Cluster&lt;/code>, &lt;code>Directory&lt;/code>, &lt;code>Router&lt;/code>, &lt;code>LoadBalance&lt;/code>&lt;/li>
&lt;li>&lt;strong>Monitor monitoring layer&lt;/strong>: RPC call times and call time monitoring, centered on &lt;code>Statistics&lt;/code>, extended interfaces are &lt;code>MonitorFactory&lt;/code>, &lt;code>Monitor&lt;/code>, &lt;code>MonitorService&lt;/code>&lt;/li>
&lt;li>&lt;strong>Protocol remote call layer&lt;/strong>: Encapsulates RPC calls, centered on &lt;code>Invocation&lt;/code>, &lt;code>Result&lt;/code>, extended interfaces are &lt;code>Protocol&lt;/code>, &lt;code>Invoker&lt;/code>, &lt;code>Exporter&lt;/code>&lt;/li>
&lt;li>&lt;strong>Exchange information exchange layer&lt;/strong>: encapsulation request response mode, synchronous to asynchronous, centered on &lt;code>Request&lt;/code>, &lt;code>Response&lt;/code>, extended interfaces are &lt;code>Exchanger&lt;/code>, &lt;code>ExchangeChannel&lt;/code>, &lt;code>ExchangeClient&lt;/code>, &lt;code>ExchangeServer&lt;/code>&lt;/li>
&lt;li>&lt;strong>Transport network transport layer&lt;/strong>: Abstract mina and netty as a unified interface, with &lt;code>Message&lt;/code> as the center, and extended interfaces as &lt;code>Channel&lt;/code>, &lt;code>Transporter&lt;/code>, &lt;code>Client&lt;/code>, &lt;code>Server&lt;/code>, &lt;code>Codec&lt;/code>&lt;/li>
&lt;li>&lt;strong>Serialize data serialization layer&lt;/strong>: some reusable tools, the extended interfaces are &lt;code>Serialization&lt;/code>, &lt;code>ObjectInput&lt;/code>, &lt;code>ObjectOutput&lt;/code>, &lt;code>ThreadPool&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="relationship-description">Relationship description&lt;/h2>
&lt;ul>
&lt;li>In RPC, Protocol is the core layer, that is, as long as there is Protocol + Invoker + Exporter, non-transparent RPC calls can be completed, and then Filter interception points on the main process of Invoker.&lt;/li>
&lt;li>The Consumer and Provider in the picture are abstract concepts, just to let the viewer understand more intuitively which classes belong to the client and server. The reason for not using Client and Server is that Dubbo uses Provider, Consumer, Registry in many scenarios , Monitor divides logical topology nodes and maintains a unified concept.&lt;/li>
&lt;li>Cluster is a peripheral concept, so the purpose of Cluster is to disguise multiple Invokers as one Invoker, so that other people only need to pay attention to the Protocol layer Invoker. Adding Cluster or removing Cluster will not affect other layers, because there is only one Provider, Cluster is not required.&lt;/li>
&lt;li>The Proxy layer encapsulates the transparent proxy of all interfaces, and the Invoker is the center in other layers. Only when it is exposed to the user, the Proxy is used to convert the Invoker into an interface, or convert the interface implementation into an Invoker, that is, remove Proxy layer RPC can be run, but it is not so transparent, and it does not look like calling remote services like calling local services.&lt;/li>
&lt;li>The Remoting implementation is the implementation of the Dubbo protocol. If you choose the RMI protocol, the entire Remoting will not be used. The Remoting is divided into the Transport transport layer and the Exchange information exchange layer. The Transport layer is only responsible for one-way message transmission. , Netty, Grizzly&amp;rsquo;s abstraction, it can also extend UDP transmission, and the Exchange layer encapsulates the Request-Response semantics above the transport layer.&lt;/li>
&lt;li>Registry and Monitor are actually not considered a layer, but an independent node, just for a global overview, drawn together in layers.&lt;/li>
&lt;/ul>
&lt;h2 id="module-subpackage">Module Subpackage&lt;/h2>
&lt;p>&lt;img alt="/dev-guide/images/dubbo-modules.jpg" src="https://dubbo.apache.org/imgs/dev/dubbo-modules.jpg">&lt;/p></description></item><item><title>Service Discovery</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/service-discovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/service-discovery/</guid><description>&lt;p>Service discovery, that is, the ability of the consumer to automatically discover the list of service addresses, is a key capability that the microservice framework needs to have. With the help of automated service discovery, microservices can be implemented without knowing the deployment location and IP address of the peer. communication.&lt;/p>
&lt;h3 id="method-to-realize">Method to realize&lt;/h3>
&lt;p>There are many ways to realize service discovery. Dubbo provides a Client-Based service discovery mechanism. Usually, additional third-party registry components need to be deployed to coordinate the service discovery process, such as commonly used Nacos, Consul, Zookeeper, etc. Dubbo itself also provides the connection to various registry components, and users can choose flexibly.&lt;/p></description></item><item><title>Service Call Extension Point</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/service-invocation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/service-invocation/</guid><description>&lt;p>&lt;img alt="dubbo-architecture" src="https://dubbo.apache.org/imgs/v3/concepts/invoke-arch.jpg">&lt;/p>
&lt;p>As shown in the figure above, from the perspective of service invocation, Dubbo provides a wealth of extension points in the link, covering load balancing methods, interceptors before and after site selection, and server-side processing interceptors.
To put it simply, when Dubbo initiates a remote call, the main workflow can be divided into two parts: the consumer side and the server side.&lt;/p>
&lt;p>The workflow on the consumer side is as follows:&lt;/p></description></item><item><title>Dubbo Mesh</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/mesh/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/mesh/</guid><description>&lt;p>From the design concept, Dubbo Mesh emphasizes the unified control, standardization and governance capabilities of the control plane, while giving more choices on the data plane, including deployment modes such as Sidecar Mesh and Proxyless Mesh. Multiple deployment models provide enterprises with more choices. Through the hybrid deployment model, while realizing the sharing of the service governance control plane, it can better respond to the deployment requirements of different scenarios (performance, deployment complexity, etc.), and adapt to complex infrastructure environment and improve the availability of the architecture as a whole.&lt;/p></description></item><item><title>Triple Protocol</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/triple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/triple/</guid><description>&lt;h3 id="protocol-description">Protocol Description&lt;/h3>
&lt;p>Triple is an HTTP2-based open protocol proposed by Dubbo3, which aims to solve the interoperability problems brought about by Dubbo2&amp;rsquo;s private protocol. Compared with the original Dubbo2 protocol, Triple has the following advantages:&lt;/p>
&lt;ol>
&lt;li>Interoperability between native and gRPC protocols. Open up the gRPC ecology and reduce the migration cost from gRPC to Dubbo.&lt;/li>
&lt;li>Enhance multilingual ecology. Avoid the problem of difficulty in business selection and adaptation due to insufficient capabilities of Dubbo SDK in CPP/C#/RUST and other languages.&lt;/li>
&lt;li>Gateway friendly. The gateway does not need to participate in serialization, which is convenient for users to upgrade from the traditional HTTP to generalized Dubbo call gateway to the open source or cloud vendor&amp;rsquo;s Ingress solution.&lt;/li>
&lt;li>Perfect asynchronous and streaming support. It brings performance improvement from the underlying protocol to the upper-layer business, and it is easy to build a full-link asynchronous streaming service that strictly guarantees the order of messages.&lt;/li>
&lt;/ol>
&lt;p>**Currently, the Dubbo SDK for Java and Go fully supports the Triple protocol. ** In Alibaba, the Triple protocol is widely used for cross-environment, cross-language, and cross-ecology interoperability, and hundreds of thousands of containers have been used in production.&lt;/p></description></item></channel></rss>