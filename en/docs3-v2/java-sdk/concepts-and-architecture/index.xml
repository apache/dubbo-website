<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Concepts and Architecture on Apache Dubbo</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/</link><description>Recent content in Concepts and Architecture on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>Overall Architecture</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/overall-architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/overall-architecture/</guid><description>Node role description Node Role Description Provider The service provider of the exposed service Consumer The service consumer who invokes the remote service Registry Registry for service registration and discovery Monitor A monitoring center that counts service calls and call times Container service running container Description of calling relationship The service container is responsible for starting, loading, and running the service provider. When the service provider starts, it registers the services it provides with the registration center.</description></item><item><title>Code Architecture</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/code-architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/code-architecture/</guid><description>overall design illustration:
The light blue background on the left in the figure is the interface used by the service consumer, the light green background on the right is the interface used by the service provider, and the interface on the central axis is the interface used by both parties. The figure is divided into ten layers from bottom to top. Each layer is one-way dependent. The black arrow on the right represents the dependency relationship between layers.</description></item><item><title>Service Discovery</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/service-discovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/service-discovery/</guid><description>Service discovery, that is, the ability of the consumer to automatically discover the list of service addresses, is a key capability that the microservice framework needs to have. With the help of automated service discovery, microservices can be implemented without knowing the deployment location and IP address of the peer. communication.
Method to realize There are many ways to realize service discovery. Dubbo provides a Client-Based service discovery mechanism. Usually, additional third-party registry components need to be deployed to coordinate the service discovery process, such as commonly used Nacos, Consul, Zookeeper, etc.</description></item><item><title>Service Call Extension Point</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/service-invocation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/service-invocation/</guid><description>As shown in the figure above, from the perspective of service invocation, Dubbo provides a wealth of extension points in the link, covering load balancing methods, interceptors before and after site selection, and server-side processing interceptors. To put it simply, when Dubbo initiates a remote call, the main workflow can be divided into two parts: the consumer side and the server side.
The workflow on the consumer side is as follows:</description></item><item><title>Dubbo Mesh</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/mesh/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/mesh/</guid><description>From the design concept, Dubbo Mesh emphasizes the unified control, standardization and governance capabilities of the control plane, while giving more choices on the data plane, including deployment modes such as Sidecar Mesh and Proxyless Mesh. Multiple deployment models provide enterprises with more choices. Through the hybrid deployment model, while realizing the sharing of the service governance control plane, it can better respond to the deployment requirements of different scenarios (performance, deployment complexity, etc.</description></item><item><title>Triple Protocol</title><link>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/triple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/docs3-v2/java-sdk/concepts-and-architecture/triple/</guid><description>Protocol Description Triple is an HTTP2-based open protocol proposed by Dubbo3, which aims to solve the interoperability problems brought about by Dubbo2&amp;rsquo;s private protocol. Compared with the original Dubbo2 protocol, Triple has the following advantages:
Interoperability between native and gRPC protocols. Open up the gRPC ecology and reduce the migration cost from gRPC to Dubbo. Enhance multilingual ecology. Avoid the problem of difficulty in business selection and adaptation due to insufficient capabilities of Dubbo SDK in CPP/C#/RUST and other languages.</description></item></channel></rss>