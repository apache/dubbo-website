<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Apache Dubbo – Core Features</title><link>https://dubbo.apache.org/en/overview/core-features/</link><description>Recent content in Core Features on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://dubbo.apache.org/en/overview/core-features/index.xml" rel="self" type="application/rss+xml"/><item><title>Overview: Develop microservice with Dubbo</title><link>https://dubbo.apache.org/en/overview/core-features/service-definition/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/core-features/service-definition/</guid><description>
&lt;p>Dubbo addresses a series of challenges from development and deployment to governance and operations in enterprise microservices. Dubbo provides a full suite of services for developers, from project creation, development testing, to deployment, visual monitoring, traffic governance, and ecosystem integration.&lt;/p>
&lt;h3 id="development">Development&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Language Support&lt;/strong>: Dubbo supports various programming languages including Java, Go, Rust, Node.js, and defines a set of paradigms for microservice development. A corresponding scaffold is available for quickly creating a microservice project skeleton.&lt;/li>
&lt;li>&lt;strong>Deployment&lt;/strong>: Dubbo applications can be deployed in different environments including virtual machines, Docker containers, Kubernetes, and service mesh architectures.&lt;/li>
&lt;li>&lt;strong>Service Governance&lt;/strong>: Dubbo provides capabilities like address discovery, load balancing, and traffic control. It also offers an Admin dashboard for visual control and a rich microservice ecosystem.&lt;/li>
&lt;/ul>
&lt;h4 id="creating-a-project">Creating a Project&lt;/h4>
&lt;p>The &lt;a href="https://start.dubbo.apache.org/bootstrap.html">Dubbo Microservices Project Scaffold&lt;/a> can be used to quickly create a microservices project. The scaffold can generate a microservice project with necessary dependencies based on the features or components you want.&lt;/p>
&lt;h4 id="developing-services">Developing Services&lt;/h4>
&lt;p>&lt;strong>1. Define the Service&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">DemoService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String &lt;span style="color:#268bd2">hello&lt;/span>(String arg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>2. Implement Business Logic&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@DubboService&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">DemoServiceImpl&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> DemoService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> String &lt;span style="color:#268bd2">hello&lt;/span>(String arg) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// your microservice logic here&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="publishing-services">Publishing Services&lt;/h4>
&lt;p>&lt;strong>1. Publish the Service Definition&lt;/strong>&lt;/p>
&lt;p>The service provider needs to publish the service definition as a Jar package to the Maven central repository.&lt;/p>
&lt;p>&lt;strong>2. Expose the Service&lt;/strong>&lt;/p>
&lt;p>Add Dubbo configuration and start the Dubbo server.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">dubbo&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">application&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">name&lt;/span>: dubbo-demo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protocol&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">name&lt;/span>: dubbo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">port&lt;/span>: -&lt;span style="color:#2aa198">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">registry&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">address&lt;/span>: zookeeper://127.0.0.1:2181
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="consuming-services">Consuming Services&lt;/h4>
&lt;p>First, consumers include the &lt;code>DemoService&lt;/code> service definition dependency via Maven/Gradle.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;lt;groupId&amp;gt;&lt;/span>org.apache.dubbo&lt;span style="color:#268bd2">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;lt;artifactId&amp;gt;&lt;/span>dubbo-demo-interface&lt;span style="color:#268bd2">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;lt;version&amp;gt;&lt;/span>3.2.0&lt;span style="color:#268bd2">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then, programmatically inject the remote Dubbo service instance.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">Consumer&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@DubboReference&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> DemoService demoService;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="deployment">Deployment&lt;/h3>
&lt;p>Dubbo native services can be packaged and deployed to cloud-native infrastructures like Docker containers, Kubernetes, and service meshes.&lt;/p>
&lt;h3 id="governance">Governance&lt;/h3>
&lt;p>For service governance, most applications just need to add the following configuration. Dubbo will then have address discovery and load balancing capabilities.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">dubbo&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">registry&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">address&lt;/span>: zookeeper://127.0.0.1:2181
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Deploy and open the &lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/deploy/">Dubbo Admin Dashboard&lt;/a>, and you will see the service deployment and invocation data.&lt;/p>
&lt;p>Dubbo Admin can also improve development and testing efficiency through additional capabilities like:&lt;/p>
&lt;ul>
&lt;li>Document management for regular services and IDL documents&lt;/li>
&lt;li>Service testing &amp;amp; service Mock&lt;/li>
&lt;li>Service status inquiry&lt;/li>
&lt;/ul>
&lt;p>For more complex microservices scenarios, Dubbo also provides more advanced governance features, including:&lt;/p>
&lt;ul>
&lt;li>Traffic governance&lt;/li>
&lt;li>Dynamic configuration&lt;/li>
&lt;li>Rate limiting and degradation&lt;/li>
&lt;li>Data consistency&lt;/li>
&lt;li>Observability&lt;/li>
&lt;li>Multi-protocol&lt;/li>
&lt;li>Multiple registries&lt;/li>
&lt;li>Service mesh&lt;/li>
&lt;/ul>
&lt;p>This guide provides an overview of the workflow for developing microservices with Dubbo. For detailed step-by-step instructions, please refer to:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dubbo.apache.org/en/overview/quickstart/">Getting Started with Java Microservices&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/en/overview/quickstart/go/">Getting Started with Go Microservices&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/en/overview/quickstart/rust/">Getting Started with Rust Microservices&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/apache/dubbo-js">Getting Started with Node.js Microservices&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="deployment-1">Deployment&lt;/h3>
&lt;p>Dubbo&amp;rsquo;s native services can be packaged and deployed in various cloud-native infrastructures and microservices architectures, including Docker containers, Kubernetes, and Service Mesh.&lt;/p>
&lt;p>For examples of deployment in different environments, refer to:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/deploy/deploy-on-docker">Deploying Dubbo services to Docker containers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/en/overview/tasks/kubernetes/">Deploying Dubbo services to Kubernetes&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="governance-1">Governance&lt;/h3>
&lt;p>For service governance, most applications only need to add the following configuration, and the Dubbo application will have address discovery and load balancing capabilities.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">dubbo&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">registry&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">address&lt;/span>: zookeeper://127.0.0.1:2181
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once deployed and the &lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/deploy">Dubbo Admin Console&lt;/a> is opened, you can see the deployment and invocation data of services in the cluster.&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/what/admin.png" alt="Admin">&lt;/p>
&lt;p>In addition, Dubbo Admin can also enhance R&amp;amp;D and testing efficiency through the following capabilities:&lt;/p>
&lt;ul>
&lt;li>Document management, providing general services and IDL document management.&lt;/li>
&lt;li>Service testing &amp;amp; Service Mock.&lt;/li>
&lt;li>Service status inquiry.&lt;/li>
&lt;/ul>
&lt;p>For more complex microservices practice scenarios, Dubbo also offers many more advanced service governance features. For more details, please refer to the documentation, including:&lt;/p>
&lt;ul>
&lt;li>Traffic governance&lt;/li>
&lt;li>Dynamic configuration&lt;/li>
&lt;li>Rate limiting and degradation&lt;/li>
&lt;li>Data consistency&lt;/li>
&lt;li>Observability&lt;/li>
&lt;li>Multi-protocol&lt;/li>
&lt;li>Multi-registry centers&lt;/li>
&lt;li>Service Mesh&lt;/li>
&lt;/ul></description></item><item><title>Overview: Service Mesh</title><link>https://dubbo.apache.org/en/overview/core-features/service-mesh/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/core-features/service-mesh/</guid><description>
&lt;p>Dubbo Mesh is Dubbo&amp;rsquo;s comprehensive microservices solution in a cloud-native context. It helps developers integrate Dubbo services with standard Kubernetes Native Service systems, enabling seamless connectivity with leading service mesh products like Istio.&lt;/p>
&lt;p>Below is the deployment architecture diagram for Dubbo Mesh.&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/mesh/mix-mesh.png" alt="Dubbo-Mesh">&lt;/p>
&lt;ul>
&lt;li>Control Plane: Istio serves as the unified control plane, providing cluster-wide capabilities like Kubernetes adaptation, service discovery, certificate management, observability, and traffic management.&lt;/li>
&lt;li>Data Plane: Dubbo application instances act as data plane components and support two deployment modes:
&lt;ul>
&lt;li>Proxy Mode: Dubbo and Envoy are deployed in the same pod, and all traffic to and from Dubbo is intercepted and managed by Envoy.&lt;/li>
&lt;li>Proxyless Mode: Dubbo instances are deployed independently, communicating directly with each other and interacting directly with the control plane via the xDS protocol.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>For general content on service mesh architecture and why you might want to integrate with the Istio control plane, please refer to the &lt;a href="https://istio.io/">Istio official website&lt;/a>. This document will focus on the Dubbo Mesh solution itself.&lt;/p>
&lt;h2 id="dubbo-mesh">Dubbo Mesh&lt;/h2>
&lt;h3 id="proxy-mesh">Proxy Mesh&lt;/h3>
&lt;p>In Proxy mode, Dubbo is deployed alongside a sidecar like Envoy.&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/mesh/dubbo-proxy.png" alt="dubbo-sidecar">&lt;/p>
&lt;p>The architecture diagram above depicts Dubbo Proxy Mesh deployment:&lt;/p>
&lt;ul>
&lt;li>Dubbo and Envoy are deployed in the same pod, with Istio managing traffic and governance.&lt;/li>
&lt;li>Dubbo provides programming APIs and RPC communication capabilities for business applications, while other capabilities like address discovery, load balancing, and routing are delegated to Envoy, which intercepts all incoming and outgoing traffic.&lt;/li>
&lt;li>The control plane distributes configurations to Envoy via the xDS protocol, as indicated by the dashed lines in the diagram.&lt;/li>
&lt;/ul>
&lt;p>In Proxy mode, using Dubbo3 communication layers like Triple, gRPC, and REST that are based on HTTP can result in better gateway penetration and performance.&lt;/p>
&lt;h3 id="proxyless-mesh">Proxyless Mesh&lt;/h3>
&lt;p>In Proxyless mode, there are no proxy components like Envoy. Dubbo&amp;rsquo;s processes are deployed independently and communicate directly. Istio&amp;rsquo;s control plane interacts with Dubbo processes for governance via the xDS protocol.&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/mesh/dubbo-proxyless.png" alt="dubbo-proxyless">&lt;/p>
&lt;p>In Proxyless mode, Dubbo deployment is basically the same as before, but the Dubbo3 SDKs directly implement xDS protocol parsing.&lt;/p>
&lt;h4 id="why-proxyless-mesh">Why Proxyless Mesh?&lt;/h4>
&lt;p>While Proxy mode offers many advantages, such as smooth upgrades, multi-language support, and minimal business intrusion, it also introduces some challenges:&lt;/p>
&lt;ul>
&lt;li>Sidecar communication adds extra performance overhead, especially noticeable in complex network topologies.&lt;/li>
&lt;li>The presence of a sidecar complicates application lifecycle management.&lt;/li>
&lt;li>Not all environments can accommodate Sidecar deployment and request interception.&lt;/li>
&lt;/ul>
&lt;p>In Proxyless mode, Dubbo processes continue to communicate directly:&lt;/p>
&lt;ul>
&lt;li>There is no additional Proxy-related overhead, making it more suitable for performance-sensitive applications.&lt;/li>
&lt;li>It simplifies legacy system migration.&lt;/li>
&lt;li>The architecture is simple and easy to manage.&lt;/li>
&lt;li>It is suitable for almost all deployment environments.&lt;/li>
&lt;/ul>
&lt;h2 id="sample-tasks">Sample Tasks&lt;/h2>
&lt;p>After acquiring sufficient theoretical knowledge, we recommend that you visit the following &lt;a href="https://dubbo.apache.org/en/overview/tasks/mesh">examples&lt;/a> for hands-on practice.&lt;/p>
&lt;h2 id="visualization">Visualization&lt;/h2>
&lt;p>We recommend using &lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/deploy">Dubbo Admin&lt;/a> as the visualization console for your Dubbo cluster. It is compatible with all Kubernetes, Mesh, and non-Mesh architecture deployments.&lt;/p>
&lt;p>Additionally, you can use &lt;a href="https://istio.io/latest/docs/tasks/observability/kiali/">Istio&amp;rsquo;s official recommended visualization tools&lt;/a> to manage your Dubbo Mesh cluster.&lt;/p>
&lt;h2 id="integration-with-non-istio-control-planes">Integration with Non-Istio Control Planes&lt;/h2>
&lt;p>Dubbo Mesh itself is not tied to any control plane product implementation. You can use Istio, Linkerd, Kuma, or any control plane product that supports the xDS protocol. The same applies to Sidecars.&lt;/p>
&lt;p>If you have already experienced the &lt;a href="https://dubbo.apache.org/">Dubbo Mesh based on Istio&lt;/a> sample tasks and find that Istio meets your governance needs for Dubbo Mesh, then adopting Istio as your control plane is the preferred solution.&lt;/p>
&lt;p>If you find that Dubbo&amp;rsquo;s capabilities are limited in Istio mode and need those capabilities, you may consider integrating Dubbo&amp;rsquo;s control plane to replace Istio for better native Dubbo support and performance. For details, please refer to &lt;a href="https://dubbo.apache.org/">Dubbo Mesh Sample Tasks based on Custom Dubbo Control Plane&lt;/a>.&lt;/p>
&lt;blockquote>
&lt;p>In short, this is a customized version of the control plane released by the Dubbo community based on Istio. For installation and capability differences of Dubbo&amp;rsquo;s control plane, please refer to the sample task link above.&lt;/p>
&lt;/blockquote></description></item><item><title>Overview: Service Discovery</title><link>https://dubbo.apache.org/en/overview/core-features/service-discovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/core-features/service-discovery/</guid><description>
&lt;p>Dubbo provides a Client-Based service discovery mechanism, relying on third-party registry components to coordinate the service discovery process. It supports popular registries like Nacos, Consul, and Zookeeper.&lt;/p>
&lt;p>Below is a basic workflow diagram for Dubbo&amp;rsquo;s service discovery mechanism:&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/feature/service-discovery/arc.png" alt="service-discovery">&lt;/p>
&lt;p>Service discovery involves three roles: providers, consumers, and the registry. In this setup, Dubbo provider instances register their URL addresses with the registry, which aggregates this data. Dubbo consumers read the address list from the registry and subscribe to changes. Whenever the address list changes, the registry notifies all subscribed consumer instances.&lt;/p>
&lt;h2 id="service-discovery-for-million-scale-clusters">Service Discovery for Million-Scale Clusters&lt;/h2>
&lt;p>Unlike many other microservices frameworks, &lt;strong>Dubbo 3&amp;rsquo;s service discovery is born out of Alibaba&amp;rsquo;s large-scale e-commerce microservices cluster. Therefore, it significantly outperforms most mainstream open-source products in terms of performance, scalability, and ease of use.&lt;/strong> It is the best choice for enterprises to build scalable microservices clusters for the future.&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/feature/service-discovery/arc2.png" alt="service-discovery">&lt;/p>
&lt;ul>
&lt;li>First, Dubbo&amp;rsquo;s registry aggregates instance data at the application granularity level, allowing consumers to subscribe precisely according to their needs, thereby avoiding the performance bottleneck caused by full subscriptions in most open-source frameworks like Istio and Spring Cloud.&lt;/li>
&lt;li>Second, Dubbo SDK has heavily optimized the consumer-side address list processing, adding asynchronous notifications, caching, bitmap, and various parsing optimizations to avoid resource fluctuations commonly seen during address updates.&lt;/li>
&lt;li>Finally, in terms of feature richness and ease of use, besides synchronizing basic endpoint information like IP and port to consumers, Dubbo also synchronizes the metadata information of the server&amp;rsquo;s RPC/HTTP services and their configurations to the consumer side, allowing for finer-grained collaboration between consumers and providers.&lt;/li>
&lt;/ul>
&lt;h3 id="efficient-address-push-implementation">Efficient Address Push Implementation&lt;/h3>
&lt;p>From the registry&amp;rsquo;s perspective, it aggregates the instance addresses of the entire cluster based on the application name (&lt;code>dubbo.application.name&lt;/code>). Each service-providing instance registers its own application name, instance IP:port address information (usually also containing a small amount of instance metadata, such as the machine&amp;rsquo;s region, environment, etc.) with the registry.&lt;/p>
&lt;blockquote>
&lt;p>Dubbo2&amp;rsquo;s registry aggregates instance addresses at the service granularity, which is finer than application granularity and thus means more data transfer. This has led to some performance issues in large-scale clusters.
For the inconsistency between the data models of Dubbo2 and Dubbo3, Dubbo3 provides a &lt;a href="https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/upgrades-and-compatibility/service-discovery/migration-service-discovery/">smooth migration solution&lt;/a> that makes the model change transparent to users.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/feature/service-discovery/registry-data.png" alt="service-discovery">&lt;/p>
&lt;br/>
Each consumer service instance subscribes to the instance address list from the registry. Unlike some products that load all registry data (application + instance address) into local processes, Dubbo implements precise, on-demand address subscription. For example, if a consumer application depends on app1 and app2, it will only subscribe to the address list updates of app1 and app2, significantly reducing the burden of redundant data pushing and parsing.
&lt;p> &lt;/p>
&lt;br/>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/feature/service-discovery/subscription2.png" alt="service-discovery">&lt;/p>
&lt;h3 id="rich-metadata-configuration">Rich Metadata Configuration&lt;/h3>
&lt;p>In addition to interacting with the registry, Dubbo 3&amp;rsquo;s complete address discovery process also has an additional metadata path, known as the Metadata Service. Instance addresses and metadata together form the effective address list on the consumer side.&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/feature/service-discovery/metadata.png" alt="service-discovery">&lt;/p>
&lt;p>The complete workflow is shown above. First, the consumer receives the address (IP:port) information from the registry, then establishes a connection with the provider and reads the metadata configuration information from the Metadata Service. These two pieces of information together form the effective, service-oriented address list for Dubbo&amp;rsquo;s consumer side. Both of these steps occur before the actual RPC service invocation takes place.&lt;/p>
&lt;blockquote>
&lt;p>For the definition of MetadataService and a complete analysis of the service discovery process, please refer to &lt;a href="https://dubbo.apache.org/en/blog/1/01/01/application-level-service-discovery/">Detailed Application-Level Service Discovery&lt;/a>.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>For data synchronization in microservices&amp;rsquo; service discovery models, REST has defined a very interesting maturity model. Interested readers can refer to the link here &lt;a href="https://www.martinfowler.com/articles/richardsonMaturityModel.html">https://www.martinfowler.com/articles/richardsonMaturityModel.html&lt;/a>. According to the article&amp;rsquo;s 4-level maturity definition, Dubbo&amp;rsquo;s current model based on interface granularity corresponds to the highest L4 level.&lt;/p>
&lt;/blockquote>
&lt;h2 id="configuration-methods">Configuration Methods&lt;/h2>
&lt;p>Dubbo service discovery extends support for multiple registry components, such as Nacos, Zookeeper, Consul, Redis, Kubernetes, etc. It can be switched through configuration and also supports authentication and namespace isolation configurations. For specific configuration methods, please refer to the SDK documentation:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dubbo.apache.org/en/docs3-v2/java-sdk/reference-manual/registry">Java&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/en/docs3-v2/golang-sdk/tutorial/develop/registry">Golang&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/en/docs3-v2/rust-sdk/">Rust&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Dubbo also supports scenarios of multiple registries within a single application, such as dual registration, dual subscription, etc. This is very useful for implementing data exchange between different clusters and cluster migration. We will add &lt;code>Best Practices&lt;/code> examples to future documentation to illustrate this part.&lt;/p>
&lt;h2 id="custom-extensions">Custom Extensions&lt;/h2>
&lt;p>Registry adaptation supports custom extension implementation. For details, please refer to &lt;a href="https://dubbo.apache.org/en/overview/core-features/extensibility/">Dubbo Extensibility&lt;/a>.&lt;/p></description></item><item><title>Overview: More Advanced Features</title><link>https://dubbo.apache.org/en/overview/core-features/more/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/core-features/more/</guid><description>
&lt;p>As a microservice framework closely related to application development and aimed at providing enterprise-level service governance capabilities, Dubbo offers a variety of advanced features covering service call behavior control, service diagnostics and tuning, and service governance.&lt;/p>
&lt;p>Different language SDKs may have slight variations in feature implementation and configuration methods. For a specific list of features and usage, refer to the following documents:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/advanced-features-and-usage/">Java&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/">Golang&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="controlling-service-invocation-behavior">Controlling Service Invocation Behavior&lt;/h2>
&lt;ul>
&lt;li>Service Versions&lt;/li>
&lt;li>Service Groups&lt;/li>
&lt;li>Group Aggregation&lt;/li>
&lt;li>Asynchronous Invocation&lt;/li>
&lt;li>Asynchronous Execution&lt;/li>
&lt;li>Streaming Communication&lt;/li>
&lt;li>Reactive Programming&lt;/li>
&lt;li>Generic Invocation&lt;/li>
&lt;li>Generic Implementation&lt;/li>
&lt;li>Passing Implicit Parameters in Call Chain&lt;/li>
&lt;li>RPC Call Context&lt;/li>
&lt;li>Invocation Event Notifications&lt;/li>
&lt;li>Server Callbacks to Client&lt;/li>
&lt;li>Subscribe Only&lt;/li>
&lt;li>Register Only&lt;/li>
&lt;li>Runtime Dynamic IP Specification&lt;/li>
&lt;li>Direct Provider Connection&lt;/li>
&lt;li>Startup Checks&lt;/li>
&lt;li>Local Invocation&lt;/li>
&lt;li>Parameter Validation&lt;/li>
&lt;li>Local Mocking&lt;/li>
&lt;li>Local Stubs&lt;/li>
&lt;li>Echo Tests&lt;/li>
&lt;li>Invocation Information Logging&lt;/li>
&lt;li>Delayed Exposure&lt;/li>
&lt;li>Cluster Fault Tolerance&lt;/li>
&lt;li>Service Degradation&lt;/li>
&lt;/ul>
&lt;h2 id="diagnostics-and-tuning">Diagnostics and Tuning&lt;/h2>
&lt;ul>
&lt;li>Port Protocol Multiplexing&lt;/li>
&lt;li>Thread Pool Isolation&lt;/li>
&lt;li>Multiple Protocols&lt;/li>
&lt;li>Multiple Registry Centers&lt;/li>
&lt;li>Request Latency Sampling&lt;/li>
&lt;li>Thread Models&lt;/li>
&lt;li>Service Reference Configuration Object Caching&lt;/li>
&lt;li>Route State Collection&lt;/li>
&lt;li>Load Balancing&lt;/li>
&lt;li>Simplified Registration Information&lt;/li>
&lt;li>Invocation Result Caching&lt;/li>
&lt;li>Concurrency Control&lt;/li>
&lt;li>Connection Control&lt;/li>
&lt;li>Delayed Connections&lt;/li>
&lt;li>Sticky Connections&lt;/li>
&lt;li>Graal VM Support&lt;/li>
&lt;li>Exporting Thread Stack Trace&lt;/li>
&lt;li>Kryo and FST Serialization&lt;/li>
&lt;li>Custom Service Container&lt;/li>
&lt;li>Graceful Shutdown&lt;/li>
&lt;li>Custom Host Address Exposure&lt;/li>
&lt;li>Consistent Hashing&lt;/li>
&lt;li>Logging Framework Adaptation and Runtime Management&lt;/li>
&lt;li>Kubernetes Lifecycle Probes&lt;/li>
&lt;/ul>
&lt;p>These features are designed to provide more control and flexibility in a microservices environment. They can help improve system reliability, enhance performance, and ease the process of deploying, managing, and scaling applications.&lt;/p></description></item><item><title>Overview: Load Balancing</title><link>https://dubbo.apache.org/en/overview/core-features/load-balance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/core-features/load-balance/</guid><description>
&lt;p>During cluster load balancing, Dubbo provides multiple balancing strategies, with the default being the &lt;code>weighted random&lt;/code> strategy, which is a weight-based random load balancing strategy.&lt;/p>
&lt;p>In terms of implementation, Dubbo provides client-side load balancing, meaning the Consumer determines which Provider instance to send the request to using a load balancing algorithm.&lt;/p>
&lt;h2 id="load-balancing-strategies">Load Balancing Strategies&lt;/h2>
&lt;p>Currently, Dubbo has built-in the following load balancing algorithms, which can be enabled through configuration adjustments.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">Algorithm&lt;/th>
&lt;th style="text-align:left">Characteristics&lt;/th>
&lt;th style="text-align:left">Remarks&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">Weighted Random LoadBalance&lt;/td>
&lt;td style="text-align:left">Weighted Random&lt;/td>
&lt;td style="text-align:left">Default algorithm, default weights are the same.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">RoundRobin LoadBalance&lt;/td>
&lt;td style="text-align:left">Weighted Round Robin&lt;/td>
&lt;td style="text-align:left">Inspired by Nginx&amp;rsquo;s smooth weighted round-robin algorithm.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">LeastActive LoadBalance&lt;/td>
&lt;td style="text-align:left">Least Active + Weighted Random&lt;/td>
&lt;td style="text-align:left">The principle of &amp;ldquo;the more capable, the more work&amp;rdquo;.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Shortest-Response LoadBalance&lt;/td>
&lt;td style="text-align:left">Shortest Response + Weighted Random&lt;/td>
&lt;td style="text-align:left">Focuses more on response speed.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">ConsistentHash LoadBalance&lt;/td>
&lt;td style="text-align:left">Consistent Hashing&lt;/td>
&lt;td style="text-align:left">Deterministic parameters lead to a deterministic provider, suitable for stateful requests.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">P2C LoadBalance&lt;/td>
&lt;td style="text-align:left">Power of Two Choice&lt;/td>
&lt;td style="text-align:left">After randomly selecting two nodes, choose the one with fewer &amp;ldquo;connections&amp;rdquo;.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Adaptive LoadBalance&lt;/td>
&lt;td style="text-align:left">Adaptive Load Balancing&lt;/td>
&lt;td style="text-align:left">Based on P2C algorithm, chooses the node with the least load.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="weighted-random">Weighted Random&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Weighted Random&lt;/strong>: The probability of random selection is set according to the weight.&lt;/li>
&lt;li>There&amp;rsquo;s a high collision probability on a cross-section, but as the call volume grows, the distribution becomes more even. After probability-based weighting, it&amp;rsquo;s also fairly even, which facilitates dynamic adjustment of provider weights.&lt;/li>
&lt;li>Downside: There&amp;rsquo;s the problem of slow providers accumulating requests.&lt;/li>
&lt;/ul>
&lt;h3 id="roundrobin">RoundRobin&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Weighted Round Robin&lt;/strong>: Calls nodes in a circular manner based on proportionate weights.&lt;/li>
&lt;li>Downside: There&amp;rsquo;s the problem of slow providers accumulating requests.&lt;/li>
&lt;/ul>
&lt;p>For the weighted round robin, if a node&amp;rsquo;s weight is too large, there&amp;rsquo;s the problem of concentrated calls in a short time span.&lt;/p>
&lt;h3 id="leastactive">LeastActive&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Weighted Least Active&lt;/strong>: The provider with the fewest active calls is preferred. The fewer the active calls, the stronger the provider&amp;rsquo;s processing ability.&lt;/li>
&lt;li>This ensures slower providers receive fewer requests, as slower providers will have a larger difference between requests sent and responses received.&lt;/li>
&lt;/ul>
&lt;h3 id="shortestresponse">ShortestResponse&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Weighted Shortest Response&lt;/strong>: Providers with faster response times handle more requests.&lt;/li>
&lt;li>Downside: This might lead to traffic concentrating too much on high-performance nodes.&lt;/li>
&lt;/ul>
&lt;h3 id="consistenthash">ConsistentHash&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Consistent Hashing&lt;/strong>: Requests with the same parameters are always sent to the same provider.&lt;/li>
&lt;li>When a provider fails, the requests originally directed to that provider are spread across other providers based on virtual nodes, without causing major disruption.&lt;/li>
&lt;li>For details, refer to: &lt;a href="http://en.wikipedia.org/wiki/Consistent_hashing">Consistent Hashing | WIKIPEDIA&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="p2c-load-balance">P2C Load Balance&lt;/h3>
&lt;p>The Power of Two Choice algorithm is simple but classic.&lt;/p>
&lt;h3 id="adaptive-load-balance">Adaptive Load Balance&lt;/h3>
&lt;p>Adaptive, as the name suggests, is a self-adapting load balancing mechanism that always tries to forward requests to the least loaded node.&lt;/p>
&lt;h2 id="configuration">Configuration&lt;/h2>
&lt;p>Dubbo allows providers to configure a default load balancing strategy so that all consumers will use the strategy specified by the provider by default. Consumers can also specify their own load balancing strategies. If neither side has any configuration, the random load balancing strategy is used by default.&lt;/p>
&lt;p>Each application can configure different services to use different load balancing strategies and can even specify different strategies for different methods of the same service.&lt;/p>
&lt;p>For configuration details, refer to the implementations in different languages:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/advanced-features-and-usage/performance/loadbalance/">Java&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/">Golang&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="custom-extensions">Custom Extensions&lt;/h2>
&lt;p>Load balancing strategies support custom extension implementations. For details, please see &lt;a href="https://dubbo.apache.org/en/overview/core-features/extensibility/">Dubbo&amp;rsquo;s Extensibility&lt;/a>.&lt;/p></description></item><item><title>Overview: 流量管控</title><link>https://dubbo.apache.org/en/overview/core-features/traffic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/core-features/traffic/</guid><description/></item><item><title>Overview: Protocols</title><link>https://dubbo.apache.org/en/overview/core-features/protocols/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/core-features/protocols/</guid><description>
&lt;p>The Dubbo framework offers custom, high-performance RPC communication protocols: the HTTP/2-based Triple protocol and the TCP-based Dubbo2 protocol. Additionally, Dubbo supports any third-party communication protocols, such as officially supported ones like gRPC, Thrift, REST, JsonRPC, Hessian2, and more. Further protocols can be implemented through custom extensions. This is particularly useful for handling multi-protocol communication scenarios, which are common in microservices practices.&lt;/p>
&lt;p>&lt;strong>The Dubbo framework is not tied to any specific communication protocol. In its implementation, Dubbo&amp;rsquo;s support for multiple protocols is highly flexible. It allows you to publish services that use different protocols within a single application. Furthermore, it supports exposing all protocols externally through the same port.&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/feature/protocols/protocol1.png" alt="protocols">&lt;/p>
&lt;p>Through Dubbo framework&amp;rsquo;s support for multiple protocols, you can achieve:&lt;/p>
&lt;ul>
&lt;li>Seamlessly integrate any communication protocol into the Dubbo service governance system. All communication protocols under the Dubbo ecosystem can leverage Dubbo&amp;rsquo;s programming model, service discovery, and traffic control advantages. For instance, in the case of gRPC over Dubbo, both service governance and programming APIs can be seamlessly integrated into the Dubbo ecosystem at zero cost.&lt;/li>
&lt;li>Compatibility with different technology stacks, allowing for a mix of different service frameworks and RPC frameworks in a business system. For example, some services may be developed using gRPC or Spring Cloud, while others use the Dubbo framework. Through Dubbo&amp;rsquo;s support for multiple protocols, interoperability can be achieved seamlessly.&lt;/li>
&lt;li>Simplifying protocol migration. By coordinating multiple protocols with the registry center, you can quickly meet the company&amp;rsquo;s needs for protocol migration. For example, migrating from a proprietary protocol to the Dubbo protocol, upgrading the Dubbo protocol itself, migrating from the Dubbo protocol to gRPC, or transitioning from HTTP to the Dubbo protocol, and so on.&lt;/li>
&lt;/ul>
&lt;h2 id="http2-triple">HTTP/2 (Triple)&lt;/h2>
&lt;p>Triple protocol, introduced in Dubbo 3, is a communication protocol designed for the cloud-native era. It is based on HTTP/2 and fully compatible with the gRPC protocol. Triple natively supports streaming communication semantics. It can run on both HTTP/1 and HTTP/2 transport protocols, allowing you to directly access backend Dubbo services using tools like curl or a web browser.&lt;/p>
&lt;p>Since the introduction of the Triple protocol, Dubbo also supports service definition and data transmission based on Protocol Buffers. However, Triple&amp;rsquo;s implementation is not bound to Interface Definition Language (IDL). For example, you can directly use Java Interface to define and publish Triple services. Triple possesses better gateway and proxy penetration capabilities, making it well-suited for deployment architectures involving cross-gateway and proxy communication, such as service meshes.&lt;/p>
&lt;p>Key features of the Triple protocol include:&lt;/p>
&lt;ul>
&lt;li>Support for TLS encryption and plaintext data transmission&lt;/li>
&lt;li>Support for backpressure and flow control&lt;/li>
&lt;li>Support for streaming communication&lt;/li>
&lt;li>Simultaneous support for HTTP/1 and HTTP/2 transport protocols&lt;/li>
&lt;/ul>
&lt;p>In terms of programming and communication models, the Triple protocol supports the following modes:&lt;/p>
&lt;ul>
&lt;li>Client-side asynchronous request-response&lt;/li>
&lt;li>Server-side asynchronous request-response&lt;/li>
&lt;li>Client-side request streaming&lt;/li>
&lt;li>Server-side response streaming&lt;/li>
&lt;li>Bidirectional streaming communication&lt;/li>
&lt;/ul>
&lt;p>Development Practice&lt;/p>
&lt;ul>
&lt;li>For the usage of the Triple protocol, please refer to the &lt;a href="../../tasks/triple/">Triple Protocol Development Tasks&lt;/a> or the &lt;a href="../../../docs3-v2/java-sdk/reference-manual/protocol/triple/">Java SDK Example Documentation&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/reference/protocols/triple/">Triple Design Ideas and Protocol Specifications&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="dubbo2">Dubbo2&lt;/h2>
&lt;p>The Dubbo2 protocol is an RPC communication protocol built on top of the TCP transport layer protocol. Due to its compact, flexible, and high-performance characteristics, it gained widespread use during the Dubbo2 era. It served as a key communication solution for enterprises to build high-performance, large-scale microservice clusters. In the cloud-native era, we recommend using the Triple protocol for its greater generality and better penetration.&lt;/p>
&lt;p>The Dubbo2 protocol also has built-in support for HTTP, so you can use curl for quick service validation or debugging during development.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="../../../docs/v2.7/dev/impls/protocol/">Dubbo2 Protocol Development Tasks&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/reference/protocols/tcp/">Dubbo2 Design Ideas and Protocol Specifications&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="grpc">gRPC&lt;/h2>
&lt;p>You can develop and manage microservices using Dubbo and then set up underlying communication using the gRPC protocol. But why do this instead of directly using the gRPC framework, and what advantages does it offer in comparison? The simple answer is that this is a common pattern for developing microservices using gRPC. Please read on for more details.&lt;/p>
&lt;p>gRPC is Google&amp;rsquo;s open-source communication protocol based on HTTP/2. As we mentioned in our &lt;a href="https://dubbo.apache.org/zh-cn/overview/what/xyz-difference/">Product Comparison&lt;/a> document, gRPC is positioned as a communication protocol and its implementation, making it a pure RPC framework. On the other hand, Dubbo is positioned as a microservices framework, providing solutions for microservices practices. Therefore, compared to Dubbo, gRPC lacks abstractions for microservices programming models, service governance, and other capabilities.&lt;/p>
&lt;p>Using the gRPC protocol (gRPC over Dubbo Framework) within the Dubbo ecosystem is a highly efficient and lightweight choice. It allows you to use the native gRPC protocol for communication while avoiding the complexity of customizing and developing based on gRPC (customizing and developing with gRPC is an inevitable step in many enterprise-scale practices, and the Dubbo framework handles this for developers, enabling them to use gRPC in the simplest way possible).&lt;/p>
&lt;p>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/protocols/grpc/">gRPC over Dubbo Example&lt;/a>&lt;/p>
&lt;h2 id="rest">REST&lt;/h2>
&lt;p>A common communication pattern in the microservices domain is HTTP + JSON. This includes mainstream microservices frameworks like Spring Cloud and Microprofile, which default to using this communication pattern. Dubbo also provides support for programming and communication patterns based on HTTP.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/protocols/web/">HTTP over Dubbo Example&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/protocols/springcloud/">Interoperability between Dubbo and Spring Cloud Ecosystems&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="other-communication-protocols">Other Communication Protocols&lt;/h2>
&lt;p>In addition to the protocols mentioned above, you can also run the following protocols on top of Dubbo. For Dubbo, it only takes a simple configuration change to switch the underlying service communication protocol, without affecting other peripheral APIs and governance capabilities.&lt;/p>
&lt;ul>
&lt;li>Hessian2&lt;/li>
&lt;li>Thrift&lt;/li>
&lt;li>JsonRPC&lt;/li>
&lt;/ul>
&lt;h2 id="interoperability-in-heterogeneous-microservice-ecosystems">Interoperability in Heterogeneous Microservice Ecosystems&lt;/h2>
&lt;p>For practices related to protocol migration and coexistence of multi-protocol technology stacks, please refer to this &lt;a href="https://dubbo.apache.org/zh-cn/blog/2023/01/05/dubbo-%E8%BF%9E%E6%8E%A5%E5%BC%82%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BD%93%E7%B3%BB-%E5%A4%9A%E5%8D%8F%E8%AE%AE%E5%A4%9A%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/">blog post&lt;/a>.&lt;/p>
&lt;h2 id="configuration-method">Configuration Method&lt;/h2>
&lt;p>For the configuration and usage methods of the protocols mentioned above, including how to configure &lt;code>single-port multi-protocol&lt;/code> support, please refer to the following SDK documentation:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="../../../docs3-v2/java-sdk/reference-manual/protocol/">Java&lt;/a>&lt;/li>
&lt;li>&lt;a href="../../../docs3-v2/golang-sdk/preface/concept/protocol/">Golang&lt;/a>&lt;/li>
&lt;li>&lt;a href="../../../docs3-v2/rust-sdk/protocol/">Rust&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="custom-extensions">Custom Extensions&lt;/h2>
&lt;p>In addition to the communication protocols officially supported, Dubbo supports extending support for new protocols. For specific details, please refer to &lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/extensibility/protocol/">【Task】-【Extensibility】-【Protocol】&lt;/a>.&lt;/p></description></item><item><title>Overview: Extensibility Adaptation</title><link>https://dubbo.apache.org/en/overview/core-features/extensibility/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/core-features/extensibility/</guid><description>
&lt;p>From its design, Dubbo is highly extendable. Through these extension points, you can:&lt;/p>
&lt;ul>
&lt;li>Intercept traffic and control its behavior.&lt;/li>
&lt;li>Fine-tune some of Dubbo&amp;rsquo;s default strategies and implementations.&lt;/li>
&lt;li>Adapt Dubbo services to internal microservices clusters or other mainstream open-source components.&lt;/li>
&lt;/ul>
&lt;h2 id="everything-is-extendable">Everything is Extendable&lt;/h2>
&lt;p>Dubbo&amp;rsquo;s extensibility allows the project to be conveniently divided into various sub-modules, enabling hot plugging. Users can replace Dubbo&amp;rsquo;s native implementation based on their needs to meet specific business requirements.&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/advantages/extensibility.png" alt="Admin Screenshot">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Protocol and Coding Extension&lt;/strong>: Communication protocols, serialization protocols, etc.&lt;/li>
&lt;li>&lt;strong>Traffic Control Extension&lt;/strong>: Cluster fault tolerance strategies, routing rules, load balancing, rate limiting, fallback, circuit breaking, etc.&lt;/li>
&lt;li>&lt;strong>Service Governance Extension&lt;/strong>: Service registry, configuration center, metadata center, distributed transactions, full-link tracing, monitoring systems, etc.&lt;/li>
&lt;li>&lt;strong>Diagnostic and Tuning Extension&lt;/strong>: Traffic statistics, thread pool strategies, logging, QoS maintenance commands, health checks, configuration loading, etc.&lt;/li>
&lt;/ul>
&lt;h2 id="microservices-ecosystem-based-on-extension-points">Microservices Ecosystem Based on Extension Points&lt;/h2>
&lt;p>Numerous extension points and abstractions form the foundation for Dubbo&amp;rsquo;s integration with various microservices ecosystem components and the realization of microservices governance capabilities.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/observability/tracing/">Full-link Tracing&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/ecosystem/transaction/">Data Consistency&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/core-features/traffic/circuit-breaking/">Rate Limiting &amp;amp; Fallback&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Dubbo&amp;rsquo;s SDKs for various languages adopt the &amp;ldquo;microkernel + plugin&amp;rdquo; design pattern. Almost all core nodes in every process are defined as extension points. Officially released components are also released in the form of extension point implementations, so Dubbo can treat all official and third-party component extensions equally.&lt;/p>
&lt;ul>
&lt;li>Extensibility adaptation is key to realizing Dubbo&amp;rsquo;s microservices ecosystem. Ecosystem components, such as full-link tracing and service registry implementations, are adapted based on extension points like Filter, Registry, and DynamicConfiguration.&lt;/li>
&lt;li>Extensibility adaptation offers users the highest flexibility, allowing developers to integrate with internal components and customize core capabilities as needed.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/feature/extensibility/arc.png" alt="extensibility-echosystem.png">&lt;/p>
&lt;p>The above are some core extension points within Dubbo, categorized by architectural levels:&lt;/p>
&lt;ul>
&lt;li>Protocol Communication Layer&lt;/li>
&lt;li>Traffic Control Layer&lt;/li>
&lt;li>Service Governance Layer&lt;/li>
&lt;/ul>
&lt;h2 id="protocol-communication-layer">Protocol Communication Layer&lt;/h2>
&lt;p>As emphasized in the communication protocol section, Dubbo is not bound to any specific protocol. Users can select any combination of RPC and serialization protocols, such as Triple, gRPC, Dubbo2, REST, custom protocols, etc.&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/feature/extensibility/protocol.png" alt="Protocol and Coding Principles">&lt;/p>
&lt;h3 id="protocol">Protocol&lt;/h3>
&lt;p>The Protocol extension point defines the corresponding RPC protocol. By utilizing this extension point, Dubbo can act as a unified microservices development and governance framework, allowing for flexibility in the underlying communication protocol. Officially supported are the most popular RPC communication protocols, and if you wish to use a company-specific RPC communication protocol, provide a custom extension implementation via Protocol.&lt;/p>
&lt;h3 id="serialization">Serialization&lt;/h3>
&lt;p>The Serialization extension point defines serialization protocol extensions. Officially, Dubbo offers serialization protocols like Fastjson, Protobuf, Hessian2, Kryo, and FST.&lt;/p>
&lt;h2 id="traffic-control-layer">Traffic Control Layer&lt;/h2>
&lt;p>Dubbo pre-embeds a significant number of extension points in the service call link, allowing users to control the flow of runtime traffic and change the behavior of runtime calls.&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/feature/extensibility/traffic.png" alt="Protocol and Coding Principles">&lt;/p>
&lt;h3 id="filter">Filter&lt;/h3>
&lt;p>Filters, traffic interceptors in Dubbo, are based on the AOP design pattern. They preprocess and postprocess each service call, handling tasks like access logs, encryption/decryption, traffic statistics, parameter verification, etc.&lt;/p>
&lt;h3 id="router">Router&lt;/h3>
&lt;p>The Router is a key component for traffic control in Dubbo. It directs traffic that meets certain conditions to a specific group of address subsets, enabling various traffic control modes.&lt;/p>
&lt;h3 id="load-balance">Load Balance&lt;/h3>
&lt;p>In Dubbo, Load Balance works after the router. It ensures that calls are evenly distributed across all machines in the address subset over a period of time.&lt;/p>
&lt;h2 id="service-governance-layer">Service Governance Layer&lt;/h2>
&lt;p>The classic Dubbo deployment architecture consists of a registry (service discovery), configuration center, and metadata center.&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/threecenters.png" alt="Service Governance Architecture">&lt;/p>
&lt;p>This section primarily discusses Dubbo&amp;rsquo;s service governance from an architectural and implementation perspective.&lt;/p>
&lt;h3 id="registry">Registry&lt;/h3>
&lt;p>The registry is the foundation for Dubbo&amp;rsquo;s service discovery capability, with official support for registries like Zookeeper, Nacos, Etcd, Consul, and Eureka.&lt;/p>
&lt;h3 id="config-center">Config Center&lt;/h3>
&lt;p>The configuration center is a key component for dynamically controlling Dubbo&amp;rsquo;s behavior. All rules dispatched in &lt;a href="../../../../zh-cn/overview/tasks/traffic-management">Traffic Management&lt;/a> are first saved in the configuration center.&lt;/p>
&lt;h3 id="metadata-center">Metadata Center&lt;/h3>
&lt;p>In contrast to the configuration center, from a user&amp;rsquo;s perspective, the metadata center is read-only.&lt;/p>
&lt;h2 id="custom-extension-examples">Custom Extension Examples&lt;/h2>
&lt;p>The following examples demonstrate how to extend Dubbo to address practical problems.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/extensibility/protocol/">Custom RPC Protocol&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/extensibility/router/">Custom Traffic Routing Rule&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/extensibility/registry/">Custom Registry&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/extensibility/filter/">Custom Interceptor&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="more-extension-points">More Extension Points&lt;/h2>
&lt;p>This article lists some of the commonly used extension points in Dubbo. However, there are many more extension points available for flexible customization. Each SDK for different languages may have variations in extension definitions and configuration methods.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/">Java Extension Manual&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/preface/design/aop_and_extension/">Go Extension Manual&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/">Java Extension Manual&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/preface/design/aop_and_extension/">Go Extension Manual&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Overview: Observability</title><link>https://dubbo.apache.org/en/overview/core-features/observability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/core-features/observability/</guid><description>
&lt;p>Dubbo maintains observability metrics across multiple dimensions and supports various methods of visual monitoring. Observability metrics can be broadly categorized into three measurement dimensions:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Admin.&lt;/strong> The Admin console provides a visual representation of applications, services, instances, and dependency relationships within the cluster. It supports the issuance of traffic governance rules. Additionally, it offers tools such as service testing, mocking, and document management to enhance the efficiency of development and testing processes.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Metrics.&lt;/strong> Dubbo collects a range of traffic metrics such as QPS (Queries Per Second), RT (Response Time), successful requests, failed requests, and also includes various internal component statuses like thread pool count, service health status, and more.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Tracing.&lt;/strong> Dubbo has been adapted to work with mainstream industry-level distributed tracing tools, including Skywalking, Zipkin, and Jaeger. These tools all support the tracing of Dubbo services.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Logging.&lt;/strong> Dubbo supports adaptation to multiple logging frameworks. In the Java ecosystem, it provides support for various frameworks including Slf4j, Log4j2, Log4j, Logback, Jcl, etc. Users can choose the appropriate framework based on their business requirements. Additionally, Dubbo also supports Access Log to record request traces.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="admin">Admin&lt;/h2>
&lt;p>The Admin console provides a visual representation of applications, services, instances, and dependency relationships within the cluster. It supports the issuance of traffic governance rules. Additionally, it offers tools such as service testing, mocking, and document management to enhance the efficiency of development and testing processes.&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/feature/observability/admin.jpg" alt="Admin rendering">&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#">Admin deployment and effect demonstration&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="metrics">Metrics&lt;/h2>
&lt;p>At runtime, Dubbo collects core service metrics, including QPS (Queries Per Second), RT (Response Time), total invocations, successful invocations, and failure statistics, along with reasons for failures. Additionally, for more effective monitoring of service operation, Dubbo offers monitoring of essential component states such as thread pool count and service health status.&lt;/p>
&lt;p>You can visualize the metrics using Grafana.&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/feature/observability/grafana.png" alt="Grafana rendering">&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#">Use Grafana for visualizing metrics&lt;/a>&lt;/li>
&lt;li>&lt;a href="#">How to Query Specific Metrics from Prometheus&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="tracing">Tracing&lt;/h2>
&lt;p>Full link tracing holds significant value in monitoring the operational status of distributed systems. Dubbo achieves runtime pointcut tracing through Filter interceptors. By exporting trace data to prominent platforms like Zipkin, Skywalking, Jaeger, etc., comprehensive end-to-end tracking data analysis and visual representation can be accomplished.&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/feature/observability/tracing.png" alt="Tracing rendering">&lt;/p>
&lt;p>With just a simple line of configuration, you can switch the backend implementation for tracing. Moreover, you have the flexibility to dynamically adjust Dubbo&amp;rsquo;s tracing sampling rate through governance platforms like Dubbo Admin, which proves highly valuable for troubleshooting.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#">Realize full-link tracking based on Skywalking&lt;/a>&lt;/li>
&lt;li>&lt;a href="#">Full link tracking based on Zipkin&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="logging">Logging&lt;/h2>
&lt;p>Access logs can assist in analyzing system traffic. In certain scenarios, enabling access logs can also be very helpful for troubleshooting issues.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#">Enable Access Log&lt;/a>&lt;/li>
&lt;li>&lt;a href="#">Enable Access Log in running state&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Overview: Authentication</title><link>https://dubbo.apache.org/en/overview/core-features/security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/core-features/security/</guid><description>
&lt;p>Dubbo provides comprehensive mechanisms to build a secure microservices communication system, also known as a Zero Trust system. This includes:&lt;/p>
&lt;ul>
&lt;li>Preventing man-in-the-middle attacks by offering identity authentication (Authentication) and TLS-based encrypted communication.&lt;/li>
&lt;li>Controlling inter-service access authorization (Authorization) with mechanisms like mTLS and permission checks.&lt;/li>
&lt;/ul>
&lt;p>This document will guide you through leveraging Dubbo&amp;rsquo;s security features to build a Zero Trust system for your microservices, focusing on authentication, transparent encryption, authorization, and auditing. Since Zero Trust is a comprehensive approach, you may need another infrastructure, such as certificate management and security policy control.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note&lt;/strong>: The scope of this document does not include certificate generation and distribution. We assume you already have an infrastructure in place for certificate management. Hence, we will focus on Dubbo&amp;rsquo;s authentication and authorization mechanisms and processes. If you lack such infrastructure, we recommend using a service mesh architecture like Istio for certificate management and security policies.&lt;/p>
&lt;/blockquote>
&lt;h2 id="architecture">Architecture&lt;/h2>
&lt;p>A complete Zero Trust system comprises multiple components:&lt;/p>
&lt;ul>
&lt;li>A Root Certificate Authority (CA) to manage keys and certificates.&lt;/li>
&lt;li>A security policy management and distribution center to send real-time policies to data plane components:
&lt;ul>
&lt;li>Authentication policies&lt;/li>
&lt;li>Authorization policies&lt;/li>
&lt;li>Secure Naming Information&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Data plane components (Dubbo) responsible for identification, encryption, and policy enforcement.&lt;/li>
&lt;li>A suite of tools and ecosystems to complete security audits and data link monitoring.&lt;/li>
&lt;/ul>
&lt;p>In a service mesh deployment like Istio, the control plane typically handles security policies and certificates, interacting with infrastructure like the Kubernetes API Server to distribute configuration data to Dubbo or other data plane components.&lt;/p>
&lt;p>Here is a comprehensive architecture diagram for Dubbo Zero Trust:&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/feature/security/arch.png" alt="Authentication">&lt;/p>
&lt;h2 id="authentication">Authentication&lt;/h2>
&lt;p>Dubbo provides two modes of authentication:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Channel Authentication&lt;/strong>: Dubbo supports TLS-based HTTP/2 and TCP communication. You can enable TLS through Channel Authentication API or control plane policies for server identity authentication and data link encryption. Additionally, you can enable mTLS for client-server mutual authentication. This is a service-to-service mode of authentication.&lt;/li>
&lt;li>&lt;strong>Request Authentication&lt;/strong>: Dubbo offers APIs to attach user identity credentials (like JWT tokens) in the request context. Dubbo automatically recognizes these identity tokens for permission checks. You can also customize these tokens, like OAuth2 access tokens. This is an end-user mode of authentication, representing the identity of the user logged into the system.&lt;/li>
&lt;/ul>
&lt;h3 id="architecture-1">Architecture&lt;/h3>
&lt;p>In Istio mode, Dubbo&amp;rsquo;s authentication mechanism automatically interfaces with the Istio control plane through xDS. Certificates and authentication policies generated by the Istio control plane are automatically sent to the Dubbo data plane, which applies them to all subsequent data communications.&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/feature/security/auth-1.png" alt="Authentication">&lt;/p>
&lt;h4 id="dubbo-mtls-flow">Dubbo mTLS Flow&lt;/h4>
&lt;p>In Istio deployments, you can enable or disable Channel Authentication&amp;rsquo;s mutual authentication through control plane policies. The workflow for mutual authentication is as follows:&lt;/p>
&lt;ol>
&lt;li>Istio sends authentication policies to enable mutual authentication.&lt;/li>
&lt;li>The Dubbo client initiates a mutual TLS handshake with the server, performing a secure naming check to validate the server&amp;rsquo;s identity.&lt;/li>
&lt;li>A mutual mTLS link is established between the client and server for encrypted communication.&lt;/li>
&lt;li>The Dubbo server recognizes the client&amp;rsquo;s identity and checks whether it has the permission to access the corresponding resource.&lt;/li>
&lt;/ol>
&lt;h3 id="authentication-policies">Authentication Policies&lt;/h3>
&lt;p>For specific rules supported by Istio, Dubbo fully supports Istio-defined authentication policies.&lt;/p>
&lt;p>&lt;a href="https://istio.io/latest/docs/concepts/security/#authentication-policies">Read More&lt;/a>&lt;/p>
&lt;h2 id="authorization">Authorization&lt;/h2>
&lt;p>Dubbo has abstracted an authorization extension mechanism but currently only supports the Istio system. Thus, its authorization capabilities are equivalent to those described in the official Istio documentation.&lt;/p>
&lt;p>&lt;a href="https://istio.io/latest/docs/concepts/security/#authorization">Read More&lt;/a>&lt;/p>
&lt;h3 id="architecture-2">Architecture&lt;/h3>
&lt;p>Dubbo receives user-configured authorization policies from the Istio control plane through xDS. When a request reaches a Dubbo instance, the built-in authorization engine matches the request parameters and user identity against the policy. If the match is successful, access is granted; otherwise, it&amp;rsquo;s denied.&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/feature/security/authz-1.png" alt="Authorization">&lt;/p>
&lt;h3 id="authorization-policies">Authorization Policies&lt;/h3>
&lt;p>For specific rules supported by Istio, Dubbo fully supports Istio-defined authorization policies.&lt;/p>
&lt;p>&lt;a href="https://istio.io/latest/docs/concepts/security/#authorization-policies">Read More&lt;/a>&lt;/p>
&lt;h2 id="dubbo-authentication-api">Dubbo Authentication API&lt;/h2>
&lt;p>Dubbo defines an authentication API. For general use cases, developers can enable TLS/mTLS through this API. However, in an Istio control plane deployment, Dubbo automatically recognizes the certificates and authentication policies sent by Istio, so no special configuration is needed on the Dubbo side.&lt;/p>
&lt;p>Whether or not you use the Istio control plane, JWT tokens for Request Authentication still need to be specified programmatically in Dubbo.&lt;/p>
&lt;p>For language-specific API definitions, please refer to the respective SDK documentation:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dubbo.apache.org/">Java&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/">Go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/">Rust&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/">Node.js&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="sample-tasks">Sample Tasks&lt;/h2>
&lt;p>Please visit the following &lt;a href="https://dubbo.apache.org/">Dubbo Task Examples&lt;/a> for hands-on practice with security policies.&lt;/p></description></item><item><title>Overview: Microservices Ecosystem</title><link>https://dubbo.apache.org/en/overview/core-features/ecosystem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/core-features/ecosystem/</guid><description>
&lt;p>The Dubbo community, along with numerous outstanding open-source projects, has established a rich microservices ecosystem support around Dubbo. This allows developers to opt for Dubbo as their development framework without worrying about subsequent service governance needs. From day one, Dubbo offers production-level solutions for every common issue.&lt;/p>
&lt;p>The table below shows the support for ecosystem components based on the latest Dubbo Java 3.2.x version, which will be continuously updated based on development progress. The completeness of components supported in each language may vary. For specifics, please refer to the detailed explanations in each &lt;a href="../../mannual/">language reference manual&lt;/a>.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Feature&lt;/th>
&lt;th>Component List&lt;/th>
&lt;th>Component List&lt;/th>
&lt;th>Component List&lt;/th>
&lt;th>Component List&lt;/th>
&lt;th>Component List&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Service Discovery&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/en/docs3-v2/java-sdk/reference-manual/registry/zookeeper/">Zookeeper&lt;/a>&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/en/docs3-v2/java-sdk/reference-manual/registry/nacos/">Nacos&lt;/a>&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/">Kubernetes Service&lt;/a>&lt;/td>
&lt;td>DNS​&lt;code>oaicite:{&amp;quot;number&amp;quot;:1,&amp;quot;invalid_reason&amp;quot;:&amp;quot;Malformed citation 【Under Development】&amp;quot;}&lt;/code>​&lt;/td>
&lt;td>&lt;a href="https://github.com/apache/dubbo-spi-extensions/tree/master/dubbo-registry-extensions">More&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Dynamic Configuration&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/en/docs3-v2/java-sdk/reference-manual/config-center/zookeeper/">Zookeeper&lt;/a>&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/en/docs3-v2/java-sdk/reference-manual/config-center/nacos/">Nacos&lt;/a>&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/en/docs3-v2/java-sdk/reference-manual/config-center/apollo/">Apollo&lt;/a>&lt;/td>
&lt;td>Kubernetes​&lt;code>oaicite:{&amp;quot;number&amp;quot;:2,&amp;quot;invalid_reason&amp;quot;:&amp;quot;Malformed citation 【Under Development】&amp;quot;}&lt;/code>​&lt;/td>
&lt;td>&lt;a href="https://github.com/apache/dubbo-spi-extensions/tree/master/dubbo-configcenter-extensions">More&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Metadata Management&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/en/docs3-v2/java-sdk/reference-manual/metadata-center/zookeeper/">Zookeeper&lt;/a>&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/en/docs3-v2/java-sdk/reference-manual/metadata-center/nacos/">Nacos&lt;/a>&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/metadata-center/redis/">Redis&lt;/a>&lt;/td>
&lt;td>Kubernetes​&lt;code>oaicite:{&amp;quot;number&amp;quot;:3,&amp;quot;invalid_reason&amp;quot;:&amp;quot;Malformed citation 【Under Development】&amp;quot;}&lt;/code>​&lt;/td>
&lt;td>&lt;a href="https://github.com/apache/dubbo-spi-extensions/tree/master/dubbo-metadata-report-extensions">More&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RPC Protocols&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/en/docs3-v2/java-sdk/reference-manual/protocol/triple/">HTTP/2 (Triple)&lt;/a>&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/zh-cn/overview/reference/protocols/tcp/">TCP&lt;/a>&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/en/docs3-v2/java-sdk/reference-manual/protocol/http">HTTP/REST​&lt;code>oaicite:{&amp;quot;number&amp;quot;:4,&amp;quot;invalid_reason&amp;quot;:&amp;quot;Malformed citation 【Alpha】&amp;quot;}&lt;/code>​&lt;/a>&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/en/docs3-v2/java-sdk/reference-manual/protocol/triple">gRPC&lt;/a>&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/en/docs3-v2/java-sdk/reference-manual/protocol/">More&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Visualization &amp;amp; Monitoring Platform&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/observability/admin/">Admin&lt;/a>&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/observability/grafana/">Grafana&lt;/a>&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/observability/prometheus/">Prometheus&lt;/a>&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Full-link Tracing&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/observability/tracing/zipkin/">Zipkin&lt;/a>&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/observability/tracing/skywalking/">Skywalking&lt;/a>&lt;/td>
&lt;td>&lt;a href="https://github.com/apache/dubbo-samples/tree/master/4-governance/dubbo-samples-spring-boot3-tracing#2-adding-micrometer-tracing-bridge-to-your-project">OpenTelemetry&lt;/a>&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Rate Limiting &amp;amp; Fallback&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/rate-limit/sentinel">Sentinel&lt;/a>&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/rate-limit/resilience4j">Resilience4j&lt;/a>&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/rate-limit/hystrix">Hystrix&lt;/a>&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Distributed Transactions&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/en/overview/tasks/ecosystem/transaction/">Seata&lt;/a>&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Gateway&lt;/td>
&lt;td>[Higress]&lt;/td>
&lt;td>&lt;a href="https://dubbo.apache.org/zh-cn/overview/tasks/ecosystem/gateway/">APISIX&lt;/a>&lt;/td>
&lt;td>[Shenyu]&lt;/td>
&lt;td>&lt;a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/network_filters/dubbo_proxy_filter">Envoy&lt;/a>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Service Mesh&lt;/td>
&lt;td>Istio​&lt;code>oaicite:{&amp;quot;number&amp;quot;:5,&amp;quot;invalid_reason&amp;quot;:&amp;quot;Malformed citation 【Under Development】&amp;quot;}&lt;/code>​&lt;/td>
&lt;td>&lt;a href="https://www.aeraki.net/">Aeraka&lt;/a>&lt;/td>
&lt;td>OpenSergo​&lt;code>oaicite:{&amp;quot;number&amp;quot;:6,&amp;quot;invalid_reason&amp;quot;:&amp;quot;Malformed citation 【Under Development】&amp;quot;}&lt;/code>​&lt;/td>
&lt;td>Proxyless​&lt;code>oaicite:{&amp;quot;number&amp;quot;:7,&amp;quot;invalid_reason&amp;quot;:&amp;quot;Malformed citation 【Alpha】&amp;quot;}&lt;/code>​&lt;/td>
&lt;td>More&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="microservices-ecosystem-example-architecture">Microservices Ecosystem Example Architecture&lt;/h2>
&lt;script src="https://g.alicdn.com/mamba/assets/0.0.19/mse-arc-ui.min.js">&lt;/script>
&lt;link rel="stylesheet" href="https://g.alicdn.com/mamba/assets/0.0.19/mse-arc-ui.min.css" />
&lt;section id="section-1" style="">
&lt;div class="msemap-section">
&lt;div class="msemap-container">
&lt;div id="mse-arc-container">&lt;/div>
&lt;/div>
&lt;/div>
&lt;/section></description></item></channel></rss>