<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Source Code Architecture on Apache Dubbo</title><link>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/</link><description>Recent content in Source Code Architecture on Apache Dubbo</description><generator>Hugo</generator><language>en</language><atom:link href="https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>Analysis of Single-Port Multi-Protocol Implementation Principles</title><link>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/multi-protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/multi-protocol/</guid><description>&lt;p&gt;By configuring protocols, Dubbo 3 can support port protocol multiplexing. For instance, after enabling port reuse with the Triple protocol, you can add support for the Dubbo protocol and the Qos protocol on the same port. These protocols are identified by a unified port reuse server, which can facilitate service protocol migration, save ports and related resources, and reduce operational complexity.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cn.dubbo.apache.org/imgs/blog/pu-server/pu-server-flow.png" alt="pu-server-image1"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;During the service creation phase, different Protocol objects are created for export by retrieving service export protocol configurations from the Config layer. If it&amp;rsquo;s not the first time creating a port-reusing Server, the Exchanger saves data passed from the Protocol layer to the Server for subsequent processing of that protocol type&amp;rsquo;s messages.&lt;/p&gt;</description></item><item><title>Code Architecture</title><link>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/code-architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/code-architecture/</guid><description>&lt;h2 id="overall-design"&gt;Overall Design&lt;/h2&gt;
&lt;p&gt;&lt;img src="https://cn.dubbo.apache.org/imgs/dev/dubbo-framework.jpg" alt="/dev-guide/images/dubbo-framework.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Legend explanation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The light blue background on the left side of the diagram represents the interfaces used by service consumers, the light green background on the right side represents the interfaces used by service providers, and the interfaces on the central axis are used by both parties.&lt;/li&gt;
&lt;li&gt;The diagram is divided into ten layers from bottom to top, with each layer being a one-way dependency. The black arrows on the right represent the dependency relationships between layers. Each layer can detach from the upper layer for reuse, where the Service and Config layers are APIs and the others are SPIs.&lt;/li&gt;
&lt;li&gt;The green small blocks represent extension interfaces, and the blue small blocks represent implementation classes. Only the implementation classes related to the inter-layer connections are shown in the diagram.&lt;/li&gt;
&lt;li&gt;The blue dashed lines represent the initialization process, i.e., the assembly chain during startup, the red solid lines represent the method invocation process, i.e., the runtime invocation chain, and the purple triangular arrows represent inheritance, where subclasses can be seen as the same node as their parent class. The text on the lines indicates the invoked methods.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="layer-descriptions"&gt;Layer Descriptions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Config Layer&lt;/strong&gt;: External configuration interface centered around &lt;code&gt;ServiceConfig&lt;/code&gt; and &lt;code&gt;ReferenceConfig&lt;/code&gt;, allowing direct initialization of configuration classes or generating configuration classes through Spring.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Proxy Layer&lt;/strong&gt;: Transparent proxy for service interfaces, generating client Stubs and server Skeletons centered around &lt;code&gt;ServiceProxy&lt;/code&gt;, with the extension interface being &lt;code&gt;ProxyFactory&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Registry Layer&lt;/strong&gt;: Encapsulates the registration and discovery of service addresses, centered around service URLs, with extension interfaces &lt;code&gt;RegistryFactory&lt;/code&gt;, &lt;code&gt;Registry&lt;/code&gt;, &lt;code&gt;RegistryService&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cluster Layer&lt;/strong&gt;: Encapsulates routing and load balancing for multiple providers and bridges to the registry, centered around &lt;code&gt;Invoker&lt;/code&gt;, with extension interfaces &lt;code&gt;Cluster&lt;/code&gt;, &lt;code&gt;Directory&lt;/code&gt;, &lt;code&gt;Router&lt;/code&gt;, &lt;code&gt;LoadBalance&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Monitor Layer&lt;/strong&gt;: Monitors RPC call counts and call durations, centered around &lt;code&gt;Statistics&lt;/code&gt;, with extension interfaces &lt;code&gt;MonitorFactory&lt;/code&gt;, &lt;code&gt;Monitor&lt;/code&gt;, &lt;code&gt;MonitorService&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Protocol Layer&lt;/strong&gt;: Encapsulates RPC calls, centered around &lt;code&gt;Invocation&lt;/code&gt; and &lt;code&gt;Result&lt;/code&gt;, with extension interfaces &lt;code&gt;Protocol&lt;/code&gt;, &lt;code&gt;Invoker&lt;/code&gt;, &lt;code&gt;Exporter&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exchange Layer&lt;/strong&gt;: Encapsulates request-response patterns, synchronizing to asynchronous, centered around &lt;code&gt;Request&lt;/code&gt; and &lt;code&gt;Response&lt;/code&gt;, with extension interfaces &lt;code&gt;Exchanger&lt;/code&gt;, &lt;code&gt;ExchangeChannel&lt;/code&gt;, &lt;code&gt;ExchangeClient&lt;/code&gt;, &lt;code&gt;ExchangeServer&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transport Layer&lt;/strong&gt;: Abstracts Mina and Netty into a unified interface, centered around &lt;code&gt;Message&lt;/code&gt;, with extension interfaces &lt;code&gt;Channel&lt;/code&gt;, &lt;code&gt;Transporter&lt;/code&gt;, &lt;code&gt;Client&lt;/code&gt;, &lt;code&gt;Server&lt;/code&gt;, &lt;code&gt;Codec&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Serialize Layer&lt;/strong&gt;: Reusable tools, with extension interfaces &lt;code&gt;Serialization&lt;/code&gt;, &lt;code&gt;ObjectInput&lt;/code&gt;, &lt;code&gt;ObjectOutput&lt;/code&gt;, &lt;code&gt;ThreadPool&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="relationship-explanation"&gt;Relationship Explanation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;In RPC, the Protocol is the core layer, meaning that as long as there is Protocol + Invoker + Exporter, non-transparent RPC calls can be completed, then applying Filters on the Invoker&amp;rsquo;s main process.&lt;/li&gt;
&lt;li&gt;The Consumer and Provider in the diagram are abstract concepts meant to help viewers understand which classes belong to the client and server side. The reason for not using Client and Server is that Dubbo employs Provider, Consumer, Registry, and Monitor to define logical topological nodes in many scenarios, maintaining a unified concept.&lt;/li&gt;
&lt;li&gt;Cluster is an external concept, meaning its purpose is to disguise multiple Invokers as a single Invoker, allowing others to focus only on the Protocol layer Invoker. Adding or removing Cluster will not affect other layers, as there is no need for Cluster with only one provider.&lt;/li&gt;
&lt;li&gt;The Proxy Layer encapsulates transparent proxying for all interfaces, and in other layers, it revolves around the Invoker. Only at the point of exposing for user use is Proxy used to convert Invoker into an interface or convert interface implementations into Invoker. This means removing the Proxy layer allows RPC to run, though it won&amp;rsquo;t be as transparent or seem as local as remote service calls.&lt;/li&gt;
&lt;li&gt;The Remoting implementation is the Dubbo protocol implementation. If you choose the RMI protocol, the entire Remoting will not be used. Remoting is internally divided into the Transport layer and the Exchange layer, where the Transport layer is responsible for one-way message transmission, abstracting Mina, Netty, and Grizzly, and it can also extend UDP transmission. The Exchange layer encapsulates Request-Response semantics on top of the Transport layer.&lt;/li&gt;
&lt;li&gt;The Registry and Monitor should not be counted as a layer but rather as independent nodes, drawn together for a global view in a layered manner.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="module-packaging"&gt;Module Packaging&lt;/h2&gt;
&lt;p&gt;&lt;img src="https://cn.dubbo.apache.org/imgs/dev/dubbo-modules.jpg" alt="/dev-guide/images/dubbo-modules.jpg"&gt;&lt;/p&gt;</description></item><item><title>Service Invocation Extension Points</title><link>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/service-invocation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/service-invocation/</guid><description>&lt;p&gt;&lt;img src="https://cn.dubbo.apache.org/imgs/v3/concepts/invoke-arch.jpg" alt="dubbo-architecture"&gt;&lt;/p&gt;
&lt;p&gt;As shown in the figure above, from the perspective of service invocation, Dubbo provides a wealth of extension points in the call chain, covering load balancing methods, interceptors before and after service location, server processing interceptors, and more.
In simple terms, when Dubbo initiates a remote call, the main workflow can be divided into two parts: the consumer side and the server side.&lt;/p&gt;
&lt;p&gt;The workflow of the consumer side is as follows:&lt;/p&gt;</description></item><item><title>Extension Point Development Guide</title><link>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/dubbo-spi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/dubbo-spi/</guid><description>&lt;h2 id="1-introduction-to-dubbo-spi-extensions"&gt;1. Introduction to Dubbo SPI Extensions&lt;/h2&gt;
&lt;p&gt;The extension mechanism in Dubbo is similar to the &lt;a href="https://www.baeldung.com/java-spi" target="_blank"&gt;JDK standard SPI extension points&lt;/a&gt; principle. Dubbo has made certain modifications and enhancements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The JDK standard SPI instantiates all extension point implementations at once, which can waste resources if the extension implementations are resource-intensive but not used.&lt;/li&gt;
&lt;li&gt;If an extension point fails to load, JDK SPI does not provide detailed information to locate the problem, while Dubbo SPI logs the actual failure reason on failure and prints it out.&lt;/li&gt;
&lt;li&gt;Adds &lt;a href="https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/dubbo-spi/#23-ioc-mechanism"&gt;IOC&lt;/a&gt;, &lt;a href="https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/dubbo-spi/#24-aop-mechanism"&gt;AOP&lt;/a&gt; capabilities.&lt;/li&gt;
&lt;li&gt;Adds sorting capabilities.&lt;/li&gt;
&lt;li&gt;Adds conditional activation capabilities.&lt;/li&gt;
&lt;li&gt;Provides a series of more flexible APIs, such as &lt;code&gt;getting all SPI extension implementations&lt;/code&gt;, &lt;code&gt;querying a specific extension implementation by name&lt;/code&gt;, querying extensions by type, and querying extension implementations that match conditions.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="11-definition-of-spi"&gt;1.1 Definition of SPI&lt;/h3&gt;
&lt;p&gt;The SPI plugin in Dubbo is standard Java Interface definition and must contain the &lt;code&gt;@org.apache.dubbo.common.extension.SPI&lt;/code&gt; annotation:&lt;/p&gt;</description></item></channel></rss>