<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Multi-instance Deployment on Apache Dubbo</title><link>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/</link><description>Recent content in Multi-instance Deployment on Apache Dubbo</description><generator>Hugo</generator><language>en</language><atom:link href="https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/index.xml" rel="self" type="application/rss+xml"/><item><title>Design Concept for Multi-instance Deployment</title><link>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/multi-instance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/multi-instance/</guid><description>&lt;h2 id="background"&gt;Background&lt;/h2&gt;
&lt;p&gt;Java&amp;rsquo;s static variable capability allows binding behaviors holding object references to classes, providing significant convenience to developers. Implementation solutions for design patterns like Singleton and Factory rely on static variables. By using static variables, developers can easily access needed object information anytime, anywhere.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#268bd2"&gt;public&lt;/span&gt; &lt;span style="color:#268bd2"&gt;class&lt;/span&gt; &lt;span style="color:#268bd2"&gt;Test&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#268bd2"&gt;public&lt;/span&gt; &lt;span style="color:#268bd2"&gt;static&lt;/span&gt; Object obj;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Test.obj &lt;span style="color:#719e07"&gt;=&lt;/span&gt; xxx;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the long-standing development of the Dubbo framework, static variables have been widely used, such as using a globally shared ConfigManager to store global configuration information, and ServiceRepository to store service information. This design is optimal from the perspective of centralized management of configuration or parameter acquisition. In all versions before Dubbo 2.7, runtime configuration information needed by Dubbo was accessed through global static variables, uniquely identified via the RPC service triplet (interface + version + group).&lt;/p&gt;</description></item><item><title>Definitions of Models and Concepts Related to Multi-Instances</title><link>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/model/</guid><description>&lt;h2 id="dubbo-architecture"&gt;Dubbo Architecture&lt;/h2&gt;
&lt;p&gt;JVM — Virtual Machine Layer&lt;br&gt;
Purpose: Complete isolation between Dubbo frameworks (ports cannot be reused)&lt;/p&gt;
&lt;p&gt;Dubbo Framework — Framework Layer&lt;br&gt;
Purpose: Reuse resources that need global caching (ports, serialization, etc.)&lt;/p&gt;
&lt;p&gt;Application — Application Layer&lt;br&gt;
Purpose: Isolate information between applications, including registration center, configuration center, and metadata center&lt;/p&gt;
&lt;p&gt;Services — Module Layer&lt;br&gt;
Purpose: Provide hot loading capability, allowing isolation contexts per ClassLoader or Spring Context&lt;/p&gt;
&lt;h2 id="dubbo-concept-alignment"&gt;Dubbo Concept Alignment&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;DubboBootstrap
&lt;ol&gt;
&lt;li&gt;Needs to separate export/refer services, ServiceInstance, Metadata/Config, etc. Client&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;ConfigManager
&lt;ol&gt;
&lt;li&gt;Needs to separate application-level configuration information from module-level configuration information&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;ApplicationModel
&lt;ol&gt;
&lt;li&gt;Actually stores application layer information, holding a reference to ConfigManager’s application-level configuration information&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;ConsumerModel
&lt;ol&gt;
&lt;li&gt;Actually stores interface information, held by ModuleModel&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;ProviderModel
&lt;ol&gt;
&lt;li&gt;Actually stores interface information, held by ModuleModel&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;ExtensionLoader
&lt;ol&gt;
&lt;li&gt;Needs to load different instance objects based on different levels&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Registry
&lt;ol&gt;
&lt;li&gt;Application level sharing, needs to ensure that multi-instance subscriptions work properly (considering unit scenarios)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Router / Filter
&lt;ol&gt;
&lt;li&gt;Module level sharing&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Protocol / Remoting
&lt;ol&gt;
&lt;li&gt;Framework level sharing, reusing IO, contributing across multiple applications&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Metadata&lt;/li&gt;
&lt;li&gt;Application level sharing, considering application-level service discovery&lt;/li&gt;
&lt;li&gt;QoS&lt;/li&gt;
&lt;li&gt;Framework level sharing, related to IO&lt;/li&gt;
&lt;li&gt;Serialization&lt;/li&gt;
&lt;li&gt;Framework level sharing, related to IO&lt;/li&gt;
&lt;li&gt;ConfigCenter&lt;/li&gt;
&lt;li&gt;Application level contribution&lt;/li&gt;
&lt;li&gt;ModuleModel (new)&lt;/li&gt;
&lt;li&gt;Actually stores module layer information, holding interface-level information&lt;/li&gt;
&lt;li&gt;FrameworkModel (new)&lt;/li&gt;
&lt;li&gt;Actually stores framework layer information&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="configuration-storage-organization"&gt;Configuration Storage Organization&lt;/h2&gt;
&lt;h3 id="frameworkmodel"&gt;FrameworkModel&lt;/h3&gt;
&lt;p&gt;Qos, Protocol, Remoting, Serialization, ExtensionLoader&lt;/p&gt;</description></item><item><title>Multiple Instances Make Source Code Development More Complex, Learn How to Correctly Extend SPI Implementations</title><link>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/develop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/develop/</guid><description>&lt;p&gt;This article provides a simple summary of the coding-related changes after the multiple-instance transformation of Dubbo 3.&lt;/p&gt;
&lt;h3 id="hierarchical-model"&gt;Hierarchical Model&lt;/h3&gt;
&lt;p&gt;From only ApplicationModel, new ScopeModel/FrameworkModel/ModuleModel are added to express the hierarchical model of multiple instances.
&lt;img src="https://cdn.nlark.com/yuque/0/2021/png/2391732/1630663265196-0c9e3746-3f62-406b-93d6-7d971ee3e96a.png#clientId=u53624b84-1e3c-4&amp;amp;from=paste&amp;amp;height=302&amp;amp;id=udc7e6f69&amp;amp;originHeight=604&amp;amp;originWidth=1378&amp;amp;originalType=binary&amp;amp;ratio=1&amp;amp;size=132247&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u06713196-e7be-483c-8762-6bbc756f336&amp;amp;width=689" alt="image.png"&gt;
Each ScopeModel instance will create and bind its own important members:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ExtensionDirector&lt;/li&gt;
&lt;li&gt;BeanFactory&lt;/li&gt;
&lt;li&gt;ServiceRepository&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ScopeModel, as the most basic model, can hold and pass in SPI/Bean/URL, etc.&lt;/p&gt;
&lt;h3 id="spi-extension"&gt;SPI Extension&lt;/h3&gt;
&lt;h4 id="extensionscope"&gt;ExtensionScope&lt;/h4&gt;
&lt;p&gt;The SPI annotation adds the scope attribute to indicate its belonging scope.
&lt;img src="https://cdn.nlark.com/yuque/0/2021/png/2391732/1630664482020-9d35e6de-17f7-4334-8506-3af362c03de0.png#clientId=u53624b84-1e3c-4&amp;amp;from=paste&amp;amp;height=249&amp;amp;id=u6c288d3d&amp;amp;originHeight=498&amp;amp;originWidth=930&amp;amp;originalType=binary&amp;amp;ratio=1&amp;amp;size=197493&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u56167d63-ab53-4cdb-bb10-723d0c97663&amp;amp;width=465" alt="image.png"&gt;
The correspondence between ExtensionScope and the hierarchical model:&lt;/p&gt;</description></item><item><title>Startup Process and Module Dependency</title><link>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/workflow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/workflow/</guid><description>&lt;ol&gt;
&lt;li&gt;Application Startup Process&lt;br&gt;
Initialize application configuration, start internal modules, and start other modules.&lt;br&gt;
The application startup methods include: DubboBootstrap.start(), ApplicationModel.getDeployer().start()&lt;br&gt;
&lt;img src="https://cdn.nlark.com/yuque/0/2021/svg/2391732/1634895625292-99fdac6f-3371-4147-9ad5-9428296cb083.svg#clientId=u82d0d5c2-bff3-4&amp;amp;from=drop&amp;amp;id=u8db161d3&amp;amp;originHeight=2594&amp;amp;originWidth=1050&amp;amp;originalType=binary&amp;amp;ratio=1&amp;amp;size=64242&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u8976fa81-5bc5-469a-ab4a-b4cda12cd6d" alt="Dubbo start process.svg"&gt;&lt;/li&gt;
&lt;li&gt;Module Startup Process&lt;br&gt;
Starting from ModuleDeployer.start() in the diagram above, automatically initialize application configuration, start internal modules, and then start the current module.&lt;br&gt;
Module startup methods include:&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;Spring context loads dubbo xml configuration or annotations&lt;/li&gt;
&lt;li&gt;Manually start the module: ModuleModel.getDeployer().start()&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start="3"&gt;
&lt;li&gt;Service Interface API Startup&lt;br&gt;
ServiceConfig.export() or ReferenceConfig.get() first automatically starts the module, and then executes export/refer service interfaces&lt;/li&gt;
&lt;/ol&gt;</description></item></channel></rss>