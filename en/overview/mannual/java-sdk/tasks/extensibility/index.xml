<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Custom Extensions on Apache Dubbo</title><link>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/tasks/extensibility/</link><description>Recent content in Custom Extensions on Apache Dubbo</description><generator>Hugo</generator><language>en</language><atom:link href="https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/tasks/extensibility/index.xml" rel="self" type="application/rss+xml"/><item><title>Basic Steps to Customize SPI Extensions</title><link>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/tasks/extensibility/spi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/tasks/extensibility/spi/</guid><description>&lt;p>Taking the &lt;code>RPC Protocol Plugin&lt;/code> as an example, this section demonstrates how to use the SPI plugin provided by Dubbo to provide a custom RPC protocol implementation. If you want to understand how the SPI mechanism works and the list of built-in SPI extension points in the framework, please refer to the &lt;a href="https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/reference-manual/spi/overview">Reference Manual - SPI Extension&lt;/a>.&lt;/p>
&lt;h2 id="1-provide-spi-plugin-implementation-class">1. Provide SPI Plugin Implementation Class&lt;/h2>
&lt;p>Provide a Java class that implements the &lt;code>org.apache.dubbo.rpc.Protocol&lt;/code> interface.&lt;/p></description></item><item><title>Filter</title><link>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/tasks/extensibility/filter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/tasks/extensibility/filter/</guid><description>&lt;p>In the section &lt;a href="../../framework/filter/">RPC Framework - Filter Request Interception&lt;/a>, we learned about the working mechanism of Filters and some built-in Filter implementations provided by the Dubbo framework. In this article, we will learn how to extend custom filter implementations: a unified Filter processor that can handle and validate returned results, reducing disruptions to developers.&lt;/p>
&lt;p>The complete source code for this example can be found at &lt;a href="https://github.com/apache/dubbo-samples/blob/master/10-task/dubbo-samples-extensibility/">dubbo-samples-extensibility&lt;/a>. In addition to this example, many Filter implementations in the Dubbo core repository apache/dubbo and the extension library &lt;a href="https://github.com/apache/dubbo-spi-extensions/tree/master/dubbo-filter-extensions/">apache/dubbo-spi-extensions&lt;/a> can serve as reference implementations.&lt;/p></description></item><item><title>Protocol</title><link>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/tasks/extensibility/protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/tasks/extensibility/protocol/</guid><description>&lt;p>In the &lt;a href="https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/tasks/protocols/">Communication Protocol&lt;/a> chapter, we learned about several core RPC protocols built into Dubbo: &lt;code>dubbo&lt;/code>, &lt;code>rest&lt;/code>, and &lt;code>tri&lt;/code>, and how to use them. This article explains how to provide a custom RPC protocol implementation by extending the &lt;code>org.apache.dubbo.rpc.Protocol&lt;/code> SPI.&lt;/p>
&lt;p>There are two ways to create a private protocol: the first is to wrap the existing protocol and add specific business logic. The second is to completely customize a protocol. The former is simpler to implement and is widely used in &lt;code>dubbo&lt;/code>, such as &lt;code>ProtocolFilterWrapper&lt;/code>, &lt;code>QosProtocolWrapper&lt;/code>, and &lt;code>ProtocolListenerWrapper&lt;/code>. The latter is relatively complex but offers maximum flexibility; for instance, the built-in protocols &lt;code>dubbo&lt;/code> and &lt;code>triple&lt;/code> in the Dubbo framework fall under this implementation style.&lt;/p></description></item><item><title>Registry</title><link>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/tasks/extensibility/registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/tasks/extensibility/registry/</guid><description>&lt;p>In the &lt;a href="https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/tasks/protocols/">Service Discovery&lt;/a> chapter, we learned about the usage and working principles of several core built-in registry implementations in Dubbo, such as &lt;code>Nacos&lt;/code> and &lt;code>Zookeeper&lt;/code>. This article explains how to provide a custom registry implementation by extending the &lt;code>org.apache.dubbo.registry.client.ServiceDiscovery&lt;/code> and &lt;code>org.apache.dubbo.registry.nacos.NacosServiceDiscoveryFactory&lt;/code> SPI.&lt;/p>
&lt;p>For the complete source code of this example, please refer to &lt;a href="https://github.com/apache/dubbo-spi-extensions/tree/3.2.0/dubbo-registry-extensions/dubbo-registry-etcd3">dubbo-registry-etcd&lt;/a>. In addition to this example, many registry extension implementations in the core repository apache/dubbo and the extension library apache/dubbo-spi-extensions can serve as references for extensions:&lt;/p></description></item><item><title>Router</title><link>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/tasks/extensibility/router/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/en/overview/mannual/java-sdk/tasks/extensibility/router/</guid><description>&lt;p>By customizing the router, specific routing methods can be implemented based on the characteristics of business scenarios. Please refer to the source code for the router extension implementation in the example at &lt;a href="https://github.com/apache/dubbo-samples/blob/master/10-task/dubbo-samples-extensibility/">dubbo-samples-extensibility&lt;/a> .&lt;/p>
&lt;h2 id="before-you-begin">Before You Begin&lt;/h2>
&lt;h2 id="task-details">Task Details&lt;/h2>
&lt;p>Use the first provided service Provider for all requests. If this Provider goes offline, choose a new Provider.&lt;/p>
&lt;h2 id="implementation-method">Implementation Method&lt;/h2>
&lt;p>In the Consumer, customize a Router that saves the Provider used in the first call. If there are subsequent requests and the Provider list includes the Provider used in the first call, continue to use that Provider; otherwise, select a new Provider.&lt;/p></description></item></channel></rss>