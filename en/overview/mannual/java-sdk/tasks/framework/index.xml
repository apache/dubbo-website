<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dubbo as a Lightweight RPC Framework for Solving Component Communication Issues on Apache Dubbo</title><link>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/</link><description>Recent content in Dubbo as a Lightweight RPC Framework for Solving Component Communication Issues on Apache Dubbo</description><generator>Hugo</generator><language>en</language><atom:link href="https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/index.xml" rel="self" type="application/rss+xml"/><item><title>Develop RPC Server and Client with Lightweight Java SDK</title><link>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/lightweight-rpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/lightweight-rpc/</guid><description>&lt;p>This example demonstrates how to use the lightweight Dubbo SDK to develop RPC Server and Client. The example uses Java Interface to define, publish, and access RPC services, with Triple protocol communication at the core. For the complete code of this example, please refer to &lt;a href="https://github.com/apache/dubbo-samples/tree/master/1-basic/dubbo-samples-api" target="_blank">dubbo-samples&lt;/a>.&lt;/p>
&lt;p>Based on the Triple protocol defined by Dubbo, you can easily write browser and gRPC-compatible RPC services that can run on both HTTP/1 and HTTP/2. The Dubbo Java SDK supports defining services using IDL or language-specific methods and provides a lightweight API for publishing or invoking these services.&lt;/p></description></item><item><title>Consumer Thread Model, Provider Thread Model</title><link>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/threading-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/threading-model/</guid><description>&lt;h2 id="consumer-thread-model">Consumer Thread Model&lt;/h2>
&lt;p>For Dubbo applications prior to version 2.7.5, especially some consumer applications, when faced with consuming a large number of services with a high concurrency scenario (typical in gateway scenarios), there often arises the issue of excessive thread allocation on the consumer side. For specific discussions, refer to &lt;a href="https://github.com/apache/dubbo/issues/2013">Need a limited Threadpool in consumer side #2013&lt;/a>.&lt;/p>
&lt;p>The improved consumer thread pool model effectively addresses this issue by reusing the blocked business threads on the service side.&lt;/p></description></item><item><title>Asynchronous Call</title><link>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/async/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/async/</guid><description>&lt;p>Dubbo asynchronous calls can be divided into Provider-side asynchronous calls and Consumer-side asynchronous calls.&lt;/p>
&lt;ul>
&lt;li>Consumer-side asynchronous means that after initiating an RPC call, it returns immediately, allowing the calling thread to continue processing other business logic. When the response returns, a callback function is used to notify the consumer of the result.&lt;/li>
&lt;li>Provider-side asynchronous execution moves blocking business from Dubbo&amp;rsquo;s internal thread pool to a user-defined thread, avoiding excessive occupation of the Dubbo thread pool, which helps prevent interference between different services.&lt;/li>
&lt;/ul>
&lt;p>Below is a working example diagram of consumer asynchronous calls:&lt;/p></description></item><item><title>Use Filter to Dynamically Intercept Requests or Responses</title><link>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/filter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/filter/</guid><description>&lt;p>The Filter dynamically intercepts requests or responses to transform or utilize the information contained within them. Filters themselves do not typically create responses but provide generic functions that can be &amp;ldquo;attached&amp;rdquo; to any RPC request. Dubbo Filters are pluggable, allowing us to insert any type and number of Filters into an RPC request.&lt;/p>
&lt;p>The operation of a Filter is illustrated as follows:&lt;/p>
&lt;img style="max-width:800px;height:auto;" src="https://dubbo.apache.org/imgs/v3/tasks/framework/filter.png"/>
&lt;p>Some typical capabilities achievable through Filters include:&lt;/p>
&lt;ul>
&lt;li>Logging request parameters and response results to log files&lt;/li>
&lt;li>Adding authentication or verification logic for RPC requests&lt;/li>
&lt;li>Formatting request bodies or header parameters before sending or executing requests&lt;/li>
&lt;li>Compressing response results&lt;/li>
&lt;li>Collecting metrics on request data, such as call time, success, and failure counts&lt;/li>
&lt;li>Monitoring the number of concurrently executed requests to implement rate limiting and degradation capabilities&lt;/li>
&lt;/ul>
&lt;h2 id="usage">Usage&lt;/h2>
&lt;p>As shown in the figure above, the Dubbo proxy automatically loads Filter implementations and assembles them into the call chain. Filter is a standard SPI definition, and the framework automatically loads Filter implementations based on certain activation rules.&lt;/p></description></item><item><title>Specify timeout duration for service calls</title><link>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/timeout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/timeout/</guid><description>&lt;p>Setting a timeout for RPC calls can improve the overall stability of the cluster, avoiding resource occupation caused by waiting indefinitely for response results (e.g., a large number of long-running unresponsive requests occupying the thread pool). In cases of no response, for example, after 5 seconds, the Dubbo framework will automatically terminate the call wait process (throwing a TimeoutException) and release the resources occupied by this call.&lt;/p>
&lt;h2 id="usage">Usage&lt;/h2>
&lt;p>There are multiple ways to configure the RPC call timeout, from coarse-grained global defaults to independent configurations at the specific service or method level:&lt;/p></description></item><item><title>Version and Group</title><link>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/version_group/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/version_group/</guid><description>&lt;p>In Dubbo services, an interface cannot uniquely identify a service. Only the tuple &lt;code>interface + group + version&lt;/code> can uniquely identify a service.&lt;/p>
&lt;ul>
&lt;li>When the same interface is used for different business scenarios, usage needs, or functional modules, service groups can be used to distinguish different implementations. At the same time, these different implementations can coexist and call each other.&lt;/li>
&lt;li>When the interface implementation needs upgrading while retaining the original implementation, we can distinguish them using different version numbers.&lt;/li>
&lt;/ul>
&lt;p>The complete source code of this article&amp;rsquo;s examples can be found at the following links:&lt;/p></description></item><item><title>Implicit Parameter Passing in Call Chain</title><link>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/attachment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/attachment/</guid><description>&lt;p>Parameters can be implicitly passed between service consumers and providers using &lt;code>setAttachment&lt;/code> and &lt;code>getAttachment&lt;/code> on &lt;code>RpcContext&lt;/code> without modifying method signatures and parameter definitions. Implicit parameter passing supports the following two directions:&lt;/p>
&lt;ul>
&lt;li>From consumer to provider, i.e., additional parameters are passed via attachment when the request is initiated, outside of method parameters.&lt;/li>
&lt;li>From provider to consumer, i.e., additional parameters are passed via attachment when the response is returned, outside of the response result.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>The most direct way to understand implicit parameter passing is the HTTP header, which works exactly like an HTTP header. Any number of header parameters can be passed outside of the GET or POST request body.&lt;/strong> Regarding implementation principles, the implementation of attachments varies slightly for different protocols:&lt;/p></description></item><item><title>Cluster Fault Tolerance</title><link>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/fault-tolerent-strategy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/fault-tolerent-strategy/</guid><description>&lt;h2 id="background">Background&lt;/h2>
&lt;p>When cluster calls fail, Dubbo provides various fault tolerance solutions, with failover retry as the default.&lt;/p>
&lt;p>&lt;img alt="cluster" src="https://dubbo.apache.org/imgs/user/cluster.jpg">&lt;/p>
&lt;p>Node relationships:&lt;/p>
&lt;ul>
&lt;li>Here, &lt;code>Invoker&lt;/code> is an abstraction of a callable &lt;code>Service&lt;/code> of &lt;code>Provider&lt;/code>, encapsulating the &lt;code>Provider&lt;/code> address and &lt;code>Service&lt;/code> interface information.&lt;/li>
&lt;li>&lt;code>Directory&lt;/code> represents multiple &lt;code>Invokers&lt;/code>, which can be viewed as &lt;code>List&amp;lt;Invoker&amp;gt;&lt;/code>, but unlike &lt;code>List&lt;/code>, its values may change dynamically, such as changes pushed by the registry.&lt;/li>
&lt;li>&lt;code>Cluster&lt;/code> disguises multiple &lt;code>Invokers&lt;/code> in &lt;code>Directory&lt;/code> as a single &lt;code>Invoker&lt;/code>, transparent to the upper layer, involving fault tolerance logic; if a call fails, it retries another.&lt;/li>
&lt;li>&lt;code>Router&lt;/code> selects a subset from multiple &lt;code>Invokers&lt;/code> based on routing rules, such as read-write separation and application isolation.&lt;/li>
&lt;li>&lt;code>LoadBalance&lt;/code> selects a specific &lt;code>Invoker&lt;/code> for the current call from multiple &lt;code>Invokers&lt;/code>, involving load balancing algorithms; if a call fails, it needs to reselect.&lt;/li>
&lt;/ul>
&lt;h2 id="cluster-fault-tolerance-modes">Cluster Fault Tolerance Modes&lt;/h2>
&lt;p>You can extend the cluster fault tolerance strategy. See: &lt;a href="../../../dev/impls/cluster">Cluster Extension&lt;/a>&lt;/p></description></item><item><title>Generic Call</title><link>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/generic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/framework/generic/</guid><description>&lt;div class="alert alert-warning" role="alert">
&lt;h4 class="alert-heading">Note&lt;/h4>

 Generic calls are suitable for older versions of the Dubbo communication protocol. If you are using the triple protocol from version 3.3 and onwards, please use the HTTP application/json capabilities provided by the triple protocol to directly initiate service calls. Relevant examples can be found in &lt;a href="https://dubbo.apache.org/en/overview/mannual/java-sdk/tasks/gateway/triple/">Gateway Access Instructions&lt;/a>.

&lt;/div>

&lt;p>A generic call (client generic call) refers to invoking the service when the caller does not have the service provider&amp;rsquo;s API (SDK) and can still obtain the call result. The caller can invoke the corresponding interface through a generic call by knowing the fully qualified class name and method name of the service interface.&lt;/p></description></item></channel></rss>