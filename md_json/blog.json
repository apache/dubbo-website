{
  "zh-cn": [
    {
      "filename": "dubbo-101.md",
      "__html": "<h1>第一个 Dubbo 应用</h1>\n<h2>Java RMI 简介</h2>\n<p>Java RMI （Remote Method Invocation）- 远程方法调用，能够让客户端像使用本地调用一样调用服务端 Java 虚拟机中的对象方法。RMI 是面向对象语言领域对 RPC （Remote Procedure Call）的完善，用户无需依靠 IDL 的帮助来完成分布式调用，而是通过依赖接口这种更简单自然的方式。</p>\n<h3>Java RMI 工作原理</h3>\n<p>一个典型的 RMI 调用如下图所示：</p>\n<ol>\n<li>服务端向 RMI 注册服务绑定自己的地址，</li>\n<li>客户端通过 RMI 注册服务获取目标地址，</li>\n<li>客户端调用本地的 Stub 对象上的方法，和调用本地对象上的方法一致，</li>\n<li>本地存根对象将调用信息打包，通过网络发送到服务端，</li>\n<li>服务端的 Skeleton 对象收到网络请求之后，将调用信息解包，</li>\n<li>然后找到真正的服务对象发起调用，并将返回结果打包通过网络发送回客户端。</li>\n</ol>\n<p><img src=\"../../img/blog/rmi-flow.png\" alt=\"RMI Flow\"></p>\n<p>(来源：<a href=\"https://www.cs.rutgers.edu/~pxk/417/notes/images/rpc-rmi_flow.png\">https://www.cs.rutgers.edu/~pxk/417/notes/images/rpc-rmi_flow.png</a>)</p>\n<h3>Java RMI 基本概念</h3>\n<p>Java RMI 是 Java 领域创建分布式应用的技术基石。后续的 EJB 技术，以及现代的分布式服务框架，其中的基本理念依旧是 Java RMI 的延续。在 RMI 调用中，有以下几个核心的概念：</p>\n<ol>\n<li>\n<p>通过<strong>接口</strong>进行远程调用</p>\n</li>\n<li>\n<p>通过客户端的 <strong>Stub 对象</strong>和服务端的 <strong>Skeleton 对象</strong>的帮助将远程调用伪装成本地调用</p>\n</li>\n<li>\n<p>通过 <strong>RMI 注册服务</strong>完成服务的注册和发现</p>\n</li>\n</ol>\n<p>对于第一点，客户端需要依赖接口，而服务端需要提供该接口的实现。</p>\n<p>对于第二点，在 J2SE 1.5 版本之前需要通过 rmic 预先编译好客户端的 Stub 对象和服务端的 Skeleton 对象。在之后的版本中，不再需要事先生成 Stub 和 Skeleton 对象。</p>\n<p>下面通过示例代码简单的展示 RMI 中的服务注册和发现</p>\n<h4>服务端的服务注册</h4>\n<pre><code class=\"language-java\">Hello obj = <span class=\"hljs-keyword\">new</span> HelloImpl(); <span class=\"hljs-comment\">// #1</span>\nHello stub = (Hello) UnicastRemoteObject.exportObject(obj, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// #2</span>\nRegistry registry = LocateRegistry.createRegistry(<span class=\"hljs-number\">1099</span>); <span class=\"hljs-comment\">// #3</span>\nregistry.rebind(<span class=\"hljs-string\">\"Hello\"</span>, stub); <span class=\"hljs-comment\">// #4</span>\n</code></pre>\n<p>说明：</p>\n<ol>\n<li>初始化服务对象实例，</li>\n<li>通过 <em>UnicastRemoteObject.exportObject</em> 生成可以与服务端通讯的 Stub 对象，</li>\n<li>创建一个本地的 RMI 注册服务，监听端口为 1099。该注册服务运行在服务端，也可以单独启动一个注册服务的进程，</li>\n<li>将 Stub 对象绑定到注册服务上，这样，客户端可以通过 <em>Hello</em> 这个名字查找到该远程对象。</li>\n</ol>\n<h4>客户端的服务发现</h4>\n<pre><code class=\"language-java\">Registry registry = LocateRegistry.getRegistry(); <span class=\"hljs-comment\">// #1</span>\nHello stub = (Hello) registry.lookup(<span class=\"hljs-string\">\"Hello\"</span>); <span class=\"hljs-comment\">// #2</span>\nString response = stub.sayHello(); <span class=\"hljs-comment\">// #3</span>\n</code></pre>\n<p>说明：</p>\n<ol>\n<li>获取注册服务实例，在本例中，由于没有传入任何参数，假定要获取的注册服务实例部署在本机，并监听在 1099 端口上，</li>\n<li>从注册服务中查找服务名为 <em>Hello</em> 的远程对象，</li>\n<li>通过获取的 Stub 对象发起一次 RMI 调用并获得结果。</li>\n</ol>\n<p>理解 RMI 的工作原理和基本概念，对掌握现代分布式服务框架很有帮助，建议进一步的阅读 RMI 官方教材 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>。</p>\n<h2>Dubbo 基本概念</h2>\n<p>现代的分布式服务框架的基本概念与 RMI 是类似的，同样是使用 Java 的 Interface 作为服务契约，通过注册中心来完成服务的注册和发现，远程通讯的细节也是通过代理类来屏蔽。具体来说，Dubbo 在工作时有以下四个角色参与：</p>\n<ol>\n<li>服务提供者 - 启动时在指定端口上暴露服务，并将服务地址和端口注册到注册中心上</li>\n<li>服务消费者 - 启动时向注册中心订阅自己感兴趣的服务，以便获得服务提供方的地址列表</li>\n<li>注册中心 - 负责服务的注册和发现，负责保存服务提供方上报的地址信息，并向服务消费方推送</li>\n<li>监控中心 - 负责收集服务提供方和消费方的运行状态，比如服务调用次数、延迟等，用于监控</li>\n<li>运行容器 - 负责服务提供方的初始化、加载以及运行的生命周期管理</li>\n</ol>\n<p><img src=\"../../img/blog/dubbo-architecture.png\" alt=\"dubbo-architecture\"></p>\n<p><strong>部署阶段</strong></p>\n<ul>\n<li>服务提供者在指定端口暴露服务，并向注册中心注册服务信息。</li>\n<li>服务消费者向注册中心发起服务地址列表的订阅。</li>\n</ul>\n<p><strong>运行阶段</strong></p>\n<ul>\n<li>注册中心向服务消费者推送地址列表信息。</li>\n<li>服务消费者收到地址列表后，从其中选取一个向目标服务发起调用。</li>\n<li>调用过程服务消费者和服务提供者的运行状态上报给监控中心。</li>\n</ul>\n<h2>基于 API 的 Dubbo 应用</h2>\n<p>Dubbo 的应用一般都是通过 Spring 来组装的。为了快速获得一个可以工作的 Dubbo 应用，这里的示例摒弃了复杂的配置，而改用面向 Dubbo API 的方式来构建服务提供者和消费者，另外，注册中心和监控中心在本示例中也不需要安装和配置。</p>\n<p>在生产环境，Dubbo 的服务需要一个分布式的服务注册中心与之配合，比如，ZooKeeper。为了方便开发，Dubbo 提供了直连<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>以及组播<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>两种方式，从而避免额外搭建注册中心的工作。在本例中，将使用组播的方式来完成服务的注册和发现。</p>\n<h3>定义服务契约</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">GreetingsService</span> </span>{\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">sayHi</span><span class=\"hljs-params\">(String name)</span></span>; <span class=\"hljs-comment\">// #1</span>\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ol>\n<li>定义了一个简单的服务契约 <em>GreetingsService</em>，其中只有一个方法 <em>sayHi</em> 可供调用，入参是 <em>String</em> 类型，返回值也是 <em>String</em> 类型。</li>\n</ol>\n<h3>提供契约的实现</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GreetingsServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">GreetingsService</span> </span>{ <span class=\"hljs-comment\">// #1</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHi</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hi, \"</span> + name; <span class=\"hljs-comment\">// #2</span>\n    }\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ol>\n<li>服务提供者需要实现服务契约 <em>GreetingsService</em> 接口。</li>\n<li>该实现简单的返回一个欢迎信息，如果入参是 <em>dubbo</em>，则返回 <em>hi, dubbo</em>。</li>\n</ol>\n<h3>实现 Dubbo 服务提供方</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Application</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        ServiceConfig&lt;GreetingsService&gt; service = <span class=\"hljs-keyword\">new</span> ServiceConfig&lt;&gt;(); <span class=\"hljs-comment\">// #1</span>\n        service.setApplication(<span class=\"hljs-keyword\">new</span> ApplicationConfig(<span class=\"hljs-string\">\"first-dubbo-provider\"</span>)); <span class=\"hljs-comment\">// #2</span>\n        service.setRegistry(<span class=\"hljs-keyword\">new</span> RegistryConfig(<span class=\"hljs-string\">\"multicast://224.5.6.7:1234\"</span>)); <span class=\"hljs-comment\">// #3</span>\n        service.setInterface(GreetingsService.class); <span class=\"hljs-comment\">// #4</span>\n        service.setRef(<span class=\"hljs-keyword\">new</span> GreetingsServiceImpl()); <span class=\"hljs-comment\">// #5</span>\n        service.export(); <span class=\"hljs-comment\">// #6</span>\n        System.in.read(); <span class=\"hljs-comment\">// #7</span>\n    }\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ol>\n<li>创建一个 <em>ServiceConfig</em> 的实例，泛型参数信息是服务接口类型，即 <em>GreetingsService</em>。</li>\n<li>生成一个 <em>AplicatonConfig</em> 的实例，并将其装配进 <em>ServiceConfig</em>。</li>\n<li>生成一个 <em>RegistryConfig</em> 实例，并将其装配进 <em>ServiceConfig</em>，这里使用的是组播方式，参数是 <code>multicast://224.5.6.7:1234</code>。合法的组播地址范围为：<em>224.0.0.0 - 239.255.255.255</em></li>\n<li>将服务契约 <em>GreetingsService</em> 装配进 <em>ServiceConfig</em>。</li>\n<li>将服务提供者提供的实现 <em>GreetingsServiceImpl</em> 的实例装配进 <em>ServiceConfig</em>。</li>\n<li><em>ServiceConfig</em> 已经具备足够的信息，开始对外暴露服务，默认监听端口是 <em>20880</em>。</li>\n<li>为了防止服务端退出，按任意键或者 <em>ctrl-c</em> 退出。</li>\n</ol>\n<h3>实现 Dubbo 服务调用方</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Application</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        ReferenceConfig&lt;GreetingsService&gt; reference = <span class=\"hljs-keyword\">new</span> ReferenceConfig&lt;&gt;(); <span class=\"hljs-comment\">// #1</span>\n        reference.setApplication(<span class=\"hljs-keyword\">new</span> ApplicationConfig(<span class=\"hljs-string\">\"first-dubbo-client\"</span>)); <span class=\"hljs-comment\">// #2</span>\n        reference.setRegistry(<span class=\"hljs-keyword\">new</span> RegistryConfig(<span class=\"hljs-string\">\"multicast://224.5.6.7:1234\"</span>)); <span class=\"hljs-comment\">// #3</span>\n        reference.setInterface(GreetingsService.class); <span class=\"hljs-comment\">// #4</span>\n        GreetingsService greetingsService = reference.get(); <span class=\"hljs-comment\">// #5</span>\n        String message = greetingsService.sayHi(<span class=\"hljs-string\">\"dubbo\"</span>); <span class=\"hljs-comment\">// #6</span>\n        System.out.println(message); <span class=\"hljs-comment\">// #7</span>\n    }\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ol>\n<li>创建一个 <em>ReferenceConfig</em> 的实例，同样，泛型参数信息是服务接口类型，即 <em>GreetingService</em>。</li>\n<li>生成一个 <em>AplicatonConfig</em> 的实例，并将其装配进 <em>ReferenceConfig</em>。</li>\n<li>生成一个 <em>RegistryConfig</em> 实例，并将其装配进 <em>ReferenceConfig</em>，注意这里的组播地址信息需要与服务提供方的相同。</li>\n<li>将服务契约 <em>GreetingsService</em> 装配进 <em>ReferenceConfig</em>。</li>\n<li>从 <em>ReferenceConfig</em> 中获取到 <em>GreetingService</em> 的代理。</li>\n<li>通过 <em>GreetingService</em> 的代理发起远程调用，传入的参数为 <em>dubbo</em>。</li>\n<li>打印返回结果 <em>hi, dubbo</em>。</li>\n</ol>\n<h3>运行</h3>\n<p>完整的示例在 <a href=\"https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-api\">https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-api</a> 上提供。在完整的示例中，由于配置了 <em>exec-maven-plugin</em>，可以很方便的在命令行下通过 maven 的方式执行。当然，您也可以在 IDE 里直接执行，但是需要注意的是，由于使用了组播的方式来发现服务，运行时需要指定 <em>-Djava.net.preferIPv4Stack=true</em>。</p>\n<h4>构建示例</h4>\n<p>通过以下的命令来同步示例代码并完成构建：</p>\n<ol>\n<li>同步代码：git clone <a href=\"https://github.com/dubbo/dubbo-samples.git\">https://github.com/dubbo/dubbo-samples.git</a></li>\n<li>构建：mvn clean package</li>\n</ol>\n<pre><code class=\"language-bash\">$ git <span class=\"hljs-built_in\">clone</span> https://github.com/dubbo/dubbo-samples.git\n$ <span class=\"hljs-built_in\">cd</span> dubbo-samples/dubbo-samples-api/\n$ mvn clean package\nINFO] Scanning <span class=\"hljs-keyword\">for</span> projects...\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building dubbo-samples-api 1.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ dubbo-samples-api ---\n...\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 2.182 s\n[INFO] Finished at: 2018-05-28T14:56:08+08:00\n[INFO] Final Memory: 20M/353M\n[INFO] ------------------------------------------------------------------------\n</code></pre>\n<p>当看到 <em>BUILD SUCCESS</em> 的时候表明构建完成，下面就可以开始进入运行阶段了。</p>\n<h4>运行服务端</h4>\n<p>通过运行以下的 maven 命令来启动服务提供者：</p>\n<pre><code class=\"language-bash\">$ mvn -Djava.net.preferIPv4Stack=<span class=\"hljs-literal\">true</span> -Dexec.mainClass=com.alibaba.dubbo.samples.server.Application <span class=\"hljs-built_in\">exec</span>:java\n[INFO] Scanning <span class=\"hljs-keyword\">for</span> projects...\n[INFO]                                                                         \n[INFO] ------------------------------------------------------------------------\n[INFO] Building dubbo-samples-api 1.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO] \n[INFO] --- <span class=\"hljs-built_in\">exec</span>-maven-plugin:1.6.0:java (default-cli) @ dubbo-samples-api ---\nlog4j:WARN No appenders could be found <span class=\"hljs-keyword\">for</span> logger (com.alibaba.dubbo.common.logger.LoggerFactory).\nlog4j:WARN Please initialize the log4j system properly.\nlog4j:WARN See http://logging.apache.org/log4j/1.2/faq.html<span class=\"hljs-comment\">#noconfig for more info.</span>\nfirst-dubbo-provider is running.\n</code></pre>\n<p>当 <em>first-dubbo-provider is running.</em> 出现时，代表服务提供者已经启动就绪，等待客户端的调用。</p>\n<h4>运行客户端</h4>\n<p>通过运行以下的 maven 命令来调用服务：</p>\n<pre><code class=\"language-bash\">$ mvn -Djava.net.preferIPv4Stack=<span class=\"hljs-literal\">true</span> -Dexec.mainClass=com.alibaba.dubbo.samples.client.Application <span class=\"hljs-built_in\">exec</span>:java\n[INFO] Scanning <span class=\"hljs-keyword\">for</span> projects...\n[INFO]                                                                         \n[INFO] ------------------------------------------------------------------------\n[INFO] Building dubbo-samples-api 1.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO] \n[INFO] --- <span class=\"hljs-built_in\">exec</span>-maven-plugin:1.6.0:java (default-cli) @ dubbo-samples-api ---\nlog4j:WARN No appenders could be found <span class=\"hljs-keyword\">for</span> logger (com.alibaba.dubbo.common.logger.LoggerFactory).\nlog4j:WARN Please initialize the log4j system properly.\nlog4j:WARN See http://logging.apache.org/log4j/1.2/faq.html<span class=\"hljs-comment\">#noconfig for more info.</span>\nhi, dubbo\n</code></pre>\n<p>可以看到， <em>hi, dubbo</em> 是从服务提供者返回的执行结果。</p>\n<h2>快速生成 Dubbo 应用</h2>\n<p>Dubbo 还提供了一个公共服务快速搭建基于 Spring Boot 的 Dubbo 应用。访问 <a href=\"http://start.dubbo.io\">http://start.dubbo.io</a> 并按照下图所示来生成示例工程：</p>\n<p><img src=\"../../img/blog/dubbo-initializr.png\" alt=\"dubbo initializr\"></p>\n<p><strong>说明</strong>：</p>\n<ol>\n<li>在 <em>Group</em> 中提供 maven groupId，默认值是 <em>com.example</em>。</li>\n<li>在 <em>Artifact</em> 中提供 maven artifactId，默认值是 <em>demo</em>。</li>\n<li>在 <em>DubboServiceName</em> 中提供服务名，默认值是 <em>com.example.HelloService</em>。</li>\n<li>在 <em>DubboServiceVersion</em> 中提供服务的版本，默认值是 <em>1.0.0</em>。</li>\n<li>在 <em>Client/Server</em> 中选取本次构建的工程是服务提供者 (Server) 还是服务消费者 (Client)，默认值是 <em>server</em>。</li>\n<li>使用 <em>embeddedZookeeper</em> 作为服务注册发现，默认为勾选。</li>\n<li>是否激活 qos 端口，默认为不勾选，如果勾选可以通过 <em>22222</em> 端口访问。</li>\n<li>点击 <em>Generate Project</em> 即可下载生成好的工程。</li>\n</ol>\n<p>在本例中展示的是服务提供者，同样的，通过在生成界面选取 <em>client</em> 来生成对应的服务消费者。</p>\n<h3>运行</h3>\n<p>用 IDE 打开生成好的工程，可以发现应用是一个典型的 Spring Boot 应用。程序的入口如下所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoApplication</span> </span>{\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n\t\t<span class=\"hljs-keyword\">new</span> EmbeddedZooKeeper(<span class=\"hljs-number\">2181</span>, <span class=\"hljs-keyword\">false</span>).start();  <span class=\"hljs-comment\">// #1</span>\n\t\tSpringApplication.run(DemoApplication.class, args); <span class=\"hljs-comment\">// #2</span>\n\t}\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ol>\n<li>在 <em>2181</em> 端口上启动嵌入式 <em>ZooKeeper</em>。</li>\n<li>启动 <em>Spring Boot</em> 上下文。</li>\n</ol>\n<p>可以直接在 IDE 中运行，输出结果如下：</p>\n<pre><code class=\"language-bash\">2018-05-28 16:59:38.072  INFO 59943 --- [           main] a.b.d.c.e.WelcomeLogoApplicationListener : \n\n  ████████▄  ███    █▄  ▀█████████▄  ▀█████████▄   ▄██████▄  \n  ███   ▀███ ███    ███   ███    ███   ███    ███ ███    ███ \n  ███    ███ ███    ███   ███    ███   ███    ███ ███    ███ \n  ███    ███ ███    ███  ▄███▄▄▄██▀   ▄███▄▄▄██▀  ███    ███ \n  ███    ███ ███    ███ ▀▀███▀▀▀██▄  ▀▀███▀▀▀██▄  ███    ███ \n  ███    ███ ███    ███   ███    ██▄   ███    ██▄ ███    ███ \n  ███   ▄███ ███    ███   ███    ███   ███    ███ ███    ███ \n  ████████▀  ████████▀  ▄█████████▀  ▄█████████▀   ▀██████▀  \n                                                             \n\n :: Dubbo Spring Boot (v0.1.0) : https://github.com/dubbo/dubbo-spring-boot-project\n :: Dubbo (v2.0.1) : https://github.com/alibaba/dubbo\n :: Google group : http://groups.google.com/group/dubbo\n\n2018-05-28 16:59:38.079  INFO 59943 --- [           main] e.OverrideDubboConfigApplicationListener : Dubbo Config was overridden by externalized configuration {dubbo.application.name=dubbo-demo-server, dubbo.application.qosAcceptForeignIp=<span class=\"hljs-literal\">false</span>, dubbo.application.qosEnable=<span class=\"hljs-literal\">true</span>, dubbo.application.qosPort=22222, dubbo.registry.address=zookeeper://localhost:2181?client=curator, dubbo.registry.id=my-registry, dubbo.scan.basePackages=com.example} <span class=\"hljs-comment\">#1</span>\n\n...\n\n2018-05-28 16:59:39.624  INFO 59943 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication <span class=\"hljs-keyword\">in</span> 1.746 seconds (JVM running <span class=\"hljs-keyword\">for</span> 2.963)\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ol>\n<li>输出中打印的以 <em>dubbo.</em> 开头的配置信息，定义在 <em>main/resources/application.properties</em> 中。</li>\n</ol>\n<h3>通过 Telnet 管理服务</h3>\n<p>生成工程的时候如果选择了激活 <em>qos</em> 的话，就可以通过 <em>telnet</em> 或者 <em>nc</em> 来管理服务、查看服务状态。</p>\n<pre><code class=\"language-bash\">$ telnet localhost 22222\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is <span class=\"hljs-string\">'^]'</span>.\n  ████████▄  ███    █▄  ▀█████████▄  ▀█████████▄   ▄██████▄  \n  ███   ▀███ ███    ███   ███    ███   ███    ███ ███    ███ \n  ███    ███ ███    ███   ███    ███   ███    ███ ███    ███ \n  ███    ███ ███    ███  ▄███▄▄▄██▀   ▄███▄▄▄██▀  ███    ███ \n  ███    ███ ███    ███ ▀▀███▀▀▀██▄  ▀▀███▀▀▀██▄  ███    ███ \n  ███    ███ ███    ███   ███    ██▄   ███    ██▄ ███    ███ \n  ███   ▄███ ███    ███   ███    ███   ███    ███ ███    ███ \n  ████████▀  ████████▀  ▄█████████▀  ▄█████████▀   ▀██████▀  \n                                                             \n\ndubbo&gt;\ndubbo&gt;ls\nAs Provider side:\n+------------------------------+---+\n|     Provider Service Name    |PUB|\n+------------------------------+---+\n|com.example.HelloService:1.0.0| Y |\n+------------------------------+---+\nAs Consumer side:\n+---------------------+---+\n|Consumer Service Name|NUM|\n+---------------------+---+\n</code></pre>\n<p>目前 <em>qos</em> 支持以下几个命令，更详细的信息请查阅官方文档<sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup>：</p>\n<ul>\n<li><em>ls</em>：列出消费者、提供者信息</li>\n<li><em>online</em>：上线服务</li>\n<li><em>offline</em>：下线服务</li>\n<li><em>help</em>：联机帮助</li>\n</ul>\n<h2>总结</h2>\n<p>在本文中，从 RMI 开始，介绍了 Java 领域分布式调用的基本概念，也就是基于接口编程、通过代理将远程调用伪装成本地、通过注册中心完成服务的注册和发现。</p>\n<p>然后为了简单起见，使用简单的组播注册方式和直接面向 Dubbo API 编程的方式介绍了如何开发一个 Dubbo 的完整应用。深入的了解 <em>ServiceConfig</em> 和 <em>ReferenceConfig</em> 的用法，对于进一步的使用 Spring XML 配置、乃至 Spring Boot 的编程方式有这很大的帮助。</p>\n<p>最后，简单的介绍了如何通过 Dubbo 团队提供的公共服务 <a href=\"http://start.dubbo.io\">start.dubbo.io</a> 快速搭建基于 Spring Boot 的 Dubbo 应用，并通过 <em>qos</em> 来做 Dubbo 服务的简单运维。</p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://docs.oracle.com/javase/6/docs/technotes/guides/rmi/hello/hello-world.html\">Getting Started Using JavaTM RMI</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p><a href=\"http://dubbo.apache.org/books/dubbo-user-book/demos/explicit-target.html\">直连提供者</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p><a href=\"http://dubbo.apache.org/books/dubbo-user-book/references/registry/multicast.html\">Multicast 注册中心</a> <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p><a href=\"http://dubbo.apache.org/books/dubbo-user-book/references/qos.html\">在线运维命令</a> <a href=\"#fnref4\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n"
    },
    {
      "filename": "dubbo-basic-usage-dubbo-provider-configuration.md",
      "__html": "<h2>Dubbo基本用法-Dubbo Provider配置</h2>\n<h1>Dubbo基本用法</h1>\n<p>本章节主要讲述如何配置dubbo，按照配置方式上分，可以分为：XML配置，properties方式配置，注解方式配置，API调用方式配置。\n按照功能角度进行划分，可以分为Dubbo Provider和Dubbo Consumer。接下来章节中，分别对dubbo provider和Dubbo consumer进行讲解。</p>\n<h2>Dubbo Provider配置</h2>\n<h3>Provider 配置详解</h3>\n<p>配置Dubbo Provider有4种方式：XML配置，properties方式配置，API调用方式配置，注解方式配置。</p>\n<h4>XML配置</h4>\n<h6>最简单的配置的样例：</h6>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt;  \n    &lt;dubbo:application name=&quot;hello-world-app&quot; /&gt;  \n    &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot; /&gt;  \n    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;  \n    &lt;dubbo:service interface=&quot;com.alibaba.dubbo.demo.DemoService&quot; ref=&quot;demoServiceLocal&quot; /&gt;  \n    &lt;dubbo:reference id=&quot;demoServiceRemote&quot; interface=&quot;com.alibaba.dubbo.demo.DemoService&quot; /&gt;  \n&lt;/beans&gt;\n</code></pre>\n<p>上面样例中，注意下dubbo schema的写法：</p>\n<pre><code>&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;\n       xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\n       http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;\n</code></pre>\n<h6>支持的配置标签</h6>\n<table>\n<thead>\n<tr>\n<th>标签</th>\n<th>用途</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&lt;dubbo:service/&gt;</td>\n<td>服务配置</td>\n<td style=\"text-align:left\">用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心</td>\n</tr>\n<tr>\n<td>&lt;dubbo:reference/&gt;</td>\n<td>引用配置</td>\n<td style=\"text-align:left\">用于创建一个远程服务代理，一个引用可以指向多个注册中心</td>\n</tr>\n<tr>\n<td>&lt;dubbo:protocol/&gt;</td>\n<td>协议配置</td>\n<td style=\"text-align:left\">用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受</td>\n</tr>\n<tr>\n<td>&lt;dubbo:application/&gt;</td>\n<td>应用配置</td>\n<td style=\"text-align:left\">用于配置当前应用信息，不管该应用是提供者还是消费者</td>\n</tr>\n<tr>\n<td>&lt;dubbo:module/&gt;</td>\n<td>模块配置</td>\n<td style=\"text-align:left\">用于配置当前模块信息，可选</td>\n</tr>\n<tr>\n<td>&lt;dubbo:registry/&gt;</td>\n<td>注册中心配置</td>\n<td style=\"text-align:left\">用于配置连接注册中心相关信息</td>\n</tr>\n<tr>\n<td>&lt;dubbo:monitor/&gt;</td>\n<td>监控中心配置</td>\n<td style=\"text-align:left\">用于配置连接监控中心相关信息，可选</td>\n</tr>\n<tr>\n<td>&lt;dubbo:provider/&gt;</td>\n<td>提供方配置</td>\n<td style=\"text-align:left\">当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选</td>\n</tr>\n<tr>\n<td>&lt;dubbo:consumer/&gt;</td>\n<td>消费方配置</td>\n<td style=\"text-align:left\">当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选</td>\n</tr>\n<tr>\n<td>&lt;dubbo:method/&gt;</td>\n<td>方法配置</td>\n<td style=\"text-align:left\">用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息</td>\n</tr>\n<tr>\n<td>&lt;dubbo:argument/&gt;</td>\n<td>参数配置</td>\n<td style=\"text-align:left\">用于指定方法参数配置</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://cdn.yuque.com/lark/0/2018/png/15841/1527849348155-8423d401-9ea4-4dc6-8720-d9e3d90963b6.png\" alt=\"undefined\"></p>\n <center>配置之间关系图</center>\n<h6>配置项详解</h6>\n<ul>\n<li>\n<p>&lt;dubbo:application name=&quot;hello-world-app&quot; /&gt;<br>\n用于指定应用名，这里需要保证应用名唯一，这个应用名在后续的console admin中可以在列表中显示，方便管理。</p>\n</li>\n<li>\n<p>&lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot; /&gt;<br>\n注册中心配置，和服务发现的具体机制有关系。可以是zookeeper地质，也可以eureka地质。上面这个是广播地址，在本地服务调用的测试过程中非常方便。</p>\n</li>\n<li>\n<p>&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;<br>\n这里是传输的协议和默认端口，一般不需要更改。</p>\n</li>\n</ul>\n<blockquote>\n<p>接下来重点讲解下&lt;dubbo:service/&gt;的配置。</p>\n</blockquote>\n<ul>\n<li>&lt;dubbo:service/&gt;支持的主要属性列表：\n| 属性名 | 说明 |\n| -------- | ----- |\n| version | 版本号 |\n| scope | 服务可见性, 值为：local 或者 remote，默认为remote |\n| actives | 最大的激活的请求数 |\n| async | 方法调用是否异步，默认为false |\n| cache | 服务缓存，可选值：lru/threadlocal/jcache |\n| callbacks | callback实例的限制 |\n| generic | 泛化调用，可以绕过 |\n| class | Service的实现的类名 |\n| connections | 这个服务里的连接数 |\n| delay | 发布服务延迟的毫秒数 |\n| executes | 服务执行的请求上限 |\n| retries | 超时重试次数 |\n| timeout | 调用超时时间 |</li>\n</ul>\n<p>其他配置属性请参考xsd：<a href=\"http://dubbo.apache.org/schema/dubbo/dubbo.xsd\">http://dubbo.apache.org/schema/dubbo/dubbo.xsd</a></p>\n<ul>\n<li>&lt;dubbo:method/&gt;作为&lt;dubbo:service/&gt;的子元素，它可以针对方法进行配置。比较常用的属性有：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>executes</td>\n<td>服务执行的请求上限</td>\n</tr>\n<tr>\n<td>retries</td>\n<td>超时重试次数</td>\n</tr>\n<tr>\n<td>timeout</td>\n<td>调用超时时间</td>\n</tr>\n</tbody>\n</table>\n<p>其他属性，可以参考上面的xsd。</p>\n<h6>配置的覆盖关系</h6>\n<p><img src=\"https://cdn.yuque.com/lark/0/2018/png/15841/1527849374313-94a5ea24-0e72-4d83-871b-e0e95eab646a.png\" alt=\"undefined\"></p>\n<center>配置的覆盖关系图</center>\n<p>这里的覆盖关系包含了Provider和Consumer两端的配置，如果对consumer有疑问，可以参考后一章节的consumer章节之后再来理解。</p>\n<h4>dubbo.properties方式配置</h4>\n<blockquote>\n<p>如果公共配置很简单，没有多注册中心，多协议等情况，或者想多个 Spring 容器想共享配置，可以使用 dubbo.properties 作为缺省配置。</p>\n</blockquote>\n<p>Dubbo 将自动加载 classpath 根目录下的 dubbo.properties，可以通过JVM启动参数 -Ddubbo.properties.file=xxx.properties 改变缺省配置位置。</p>\n<h6>dubbo.properties配置样例</h6>\n<pre><code># 应用名\ndubbo.application.name=dubbodemo-provider\n# 注册中心地址\ndubbo.registry.address=zookeeper://localhost:2181\n# 广播的注册中心样例\n#dubbo.registry.address=multicast://224.5.6.7:1234\n# 调用协议地址\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=28080\n</code></pre>\n<h6>映射规则</h6>\n<p>将 XML 配置的标签名，加属性名，用点分隔，多个属性拆成多行</p>\n<ul>\n<li>比如：dubbo.application.name=foo等价于&lt;dubbo:application name=&quot;foo&quot; /&gt;</li>\n<li>比如：dubbo.registry.address=10.20.153.10:9090等价于&lt;dubbo:registry address=&quot;10.20.153.10:9090&quot; /&gt;</li>\n</ul>\n<p>如果 XML 有多行同名标签配置，可用 id 号区分，如果没有 id 号将对所有同名标签生效</p>\n<ul>\n<li>比如：dubbo.protocol.rmi.port=1234等价于&lt;dubbo:protocol id=&quot;rmi&quot; name=&quot;rmi&quot; port=&quot;1099&quot; /&gt; 2</li>\n<li>比如：dubbo.registry.china.address=10.20.153.10:9090等价于&lt;dubbo:registry id=&quot;china&quot; address=&quot;10.20.153.10:9090&quot; /&gt;</li>\n</ul>\n<h6>覆盖策略</h6>\n<p><img src=\"https://cdn.yuque.com/lark/0/2018/png/15841/1527849393591-2c3de248-1b3d-47d3-bd10-8b415e9fcd39.png\" alt=\"undefined\"></p>\n<ul>\n<li>JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。</li>\n<li>XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。</li>\n<li>Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</li>\n</ul>\n<blockquote>\n<p>注意：</p>\n</blockquote>\n<ol>\n<li>如果 classpath 根目录下存在多个 dubbo.properties，比如多个 jar 包中有 dubbo.properties，Dubbo 会任意加载，并打印 Error 日志，后续可能改为抛异常。 ↩</li>\n<li>协议的 id 没配时，缺省使用协议名作为 id</li>\n</ol>\n<h4>annotation</h4>\n<h6>Service注解暴露服务</h6>\n<pre><code>import com.alibaba.dubbo.config.annotation.Service;\n\n@Service(timeout = 5000)\npublic class AnnotateServiceImpl implements AnnotateService { \n    // ...\n}\n</code></pre>\n<h6>javaconfig形式配置公共模块</h6>\n<pre><code>@Configuration\npublic class DubboConfiguration {\n\n    @Bean\n    public ApplicationConfig applicationConfig() {\n        ApplicationConfig applicationConfig = new ApplicationConfig();\n        applicationConfig.setName(&quot;provider-test&quot;);\n        return applicationConfig;\n    }\n\n    @Bean\n    public RegistryConfig registryConfig() {\n        RegistryConfig registryConfig = new RegistryConfig();\n        registryConfig.setAddress(&quot;zookeeper://127.0.0.1:2181&quot;);\n        registryConfig.setClient(&quot;curator&quot;);\n        return registryConfig;\n    }\n}\n</code></pre>\n<p>这种方式的配置和前面用xml配置的方式是一样的效果。</p>\n<h6>指定dubbo扫描路径</h6>\n<pre><code>@SpringBootApplication\n@DubboComponentScan(basePackages = &quot;com.alibaba.dubbo.test.service.impl&quot;)\npublic class ProviderTestApp {\n    // ...\n}\n</code></pre>\n<p>或者使用spring bean xml配置方式：</p>\n<pre><code>&lt;dubbo:annotation package=&quot;com.chanshuyi.service.impl&quot; /&gt;\n</code></pre>\n<h4>api直接触发</h4>\n<pre><code>import com.alibaba.dubbo.rpc.config.ApplicationConfig;\nimport com.alibaba.dubbo.rpc.config.RegistryConfig;\nimport com.alibaba.dubbo.rpc.config.ProviderConfig;\nimport com.alibaba.dubbo.rpc.config.ServiceConfig;\nimport com.xxx.XxxService;\nimport com.xxx.XxxServiceImpl;\n\n// 服务实现\nXxxService xxxService = new XxxServiceImpl();\n\n// 当前应用配置\nApplicationConfig application = new ApplicationConfig();\napplication.setName(&quot;xxx&quot;);\n\n// 连接注册中心配置\nRegistryConfig registry = new RegistryConfig();\nregistry.setAddress(&quot;10.20.130.230:9090&quot;);\nregistry.setUsername(&quot;aaa&quot;);\nregistry.setPassword(&quot;bbb&quot;);\n\n// 服务提供者协议配置\nProtocolConfig protocol = new ProtocolConfig();\nprotocol.setName(&quot;dubbo&quot;);\nprotocol.setPort(12345);\nprotocol.setThreads(200);\n\n// 注意：ServiceConfig为重对象，内部封装了与注册中心的连接，以及开启服务端口\n\n// 服务提供者暴露服务配置\nServiceConfig&lt;XxxService&gt; service = new ServiceConfig&lt;XxxService&gt;(); // 此实例很重，封装了与注册中心的连接，请自行缓存，否则可能造成内存和连接泄漏\nservice.setApplication(application);\nservice.setRegistry(registry); // 多个注册中心可以用setRegistries()\nservice.setProtocol(protocol); // 多个协议可以用setProtocols()\nservice.setInterface(XxxService.class);\nservice.setRef(xxxService);\nservice.setVersion(&quot;1.0.0&quot;);\n\n// 暴露及注册服务\nservice.export();\n</code></pre>\n<p>一般在spring应用中，不推荐使用这种方式。 具体的含义这里不做解释，可以通过github查看源码。</p>\n<h3>Provider 接口和实现</h3>\n<p>上面章节更多从配置角度出发，接下来通过一个完整的例子，来讲解下dubbo provider的完整使用。</p>\n<p>这个例子中只有一个服务UserReadService，有一个方法 getUserById。 需要将这个服务通过Dubbo暴露给远程的服务。具体的步骤如下：</p>\n<p>1.创建工程\n如果本来已经有工程，可以忽略。创建一个spring boot工程，可以通过 <a href=\"https://start.spring.io/\">https://start.spring.io/</a> 创建。\n2.定义接口\n定义接口：UserReadService</p>\n<pre><code>public interface UserReadService{\npublic User getUserById(Long userId);\n}\n</code></pre>\n<p>这个接口一般来说会放到独立的jar包里，作为client包。 其他应用要消费这个服务的时候，一般来说需要应用引用这个client包。(除了泛化调用)\n3.实现接口\n实现UserReadService, 当前实现部署在Provider的应用中。</p>\n<pre><code>public UserReadServiceImpl implements UserReadService{\n    public User getUserById(Long userId){\n        return xxx;\n    }\n}\n</code></pre>\n<p>4.Dubbo配置</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt;  \n    &lt;dubbo:application name=&quot;hello-world-app&quot; /&gt;  \n    &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot; /&gt;  \n    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;  \n    &lt;bean id=&quot;userReadService&quot; class=&quot;com.package.UserReadServiceImpl&quot;/&gt;\n    &lt;dubbo:service interface=&quot;com.package.UserReadService&quot; ref=&quot;userReadService&quot; /&gt;  \n&lt;/beans&gt;\n</code></pre>\n<p>Dubbo配置的其他方式可以参考上一章节的相关配置，或者使用集成dubbo spring boot starter方式。</p>\n"
    },
    {
      "filename": "introduction-to-dubbo-spi-2.md",
      "__html": "<h1>Dubbo可扩展机制源码解析</h1>\n<hr>\n<p>在<a href=\"#/blog/introduction-to-dubbo-spi.md\">Dubbo可扩展机制实战</a>中，我们了解了Dubbo扩展机制的一些概念，初探了Dubbo中LoadBalance的实现，并自己实现了一个LoadBalance。是不是觉得Dubbo的扩展机制很不错呀，接下来，我们就深入Dubbo的源码，一睹庐山真面目。</p>\n<h1>ExtensionLoader</h1>\n<p>ExtentionLoader是最核心的类，负责扩展点的加载和生命周期管理。我们就以这个类开始吧。\nExtension的方法比较多，比较常用的方法有:</p>\n<ul>\n<li><code>public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type)</code></li>\n<li><code>public T getExtension(String name)</code></li>\n<li><code>public T getAdaptiveExtension()</code></li>\n</ul>\n<p>比较常见的用法有:</p>\n<ul>\n<li><code>LoadBalance lb = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(loadbalanceName)</code></li>\n<li><code>RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getAdaptiveExtension()</code></li>\n</ul>\n<p>说明：在接下来展示的源码中，我会将无关的代码(比如日志，异常捕获等)去掉，方便大家阅读和理解。</p>\n<ol>\n<li>getExtensionLoader方法\n这是一个静态工厂方法，入参是一个可扩展的接口，返回一个该接口的ExtensionLoader实体类。通过这个实体类，可以根据name获得具体的扩展，也可以获得一个自适应扩展。</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\">ExtensionLoader&lt;T&gt; <span class=\"hljs-title\">getExtensionLoader</span><span class=\"hljs-params\">(Class&lt;T&gt; type)</span> </span>{\n        <span class=\"hljs-comment\">// 扩展点必须是接口</span>\n        <span class=\"hljs-keyword\">if</span> (!type.isInterface()) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"Extension type(\"</span> + type + <span class=\"hljs-string\">\") is not interface!\"</span>);\n        }\n        <span class=\"hljs-comment\">// 必须要有@SPI注解</span>\n        <span class=\"hljs-keyword\">if</span> (!withExtensionAnnotation(type)) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"Extension type without @SPI Annotation!\"</span>);\n        }\n        <span class=\"hljs-comment\">// 从缓存中根据接口获取对应的ExtensionLoader</span>\n        <span class=\"hljs-comment\">// 每个扩展只会被加载一次</span>\n        ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);\n        <span class=\"hljs-keyword\">if</span> (loader == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-comment\">// 初始化扩展</span>\n            EXTENSION_LOADERS.putIfAbsent(type, <span class=\"hljs-keyword\">new</span> ExtensionLoader&lt;T&gt;(type));\n            loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);\n        }\n        <span class=\"hljs-keyword\">return</span> loader;\n    }\n    \n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">ExtensionLoader</span><span class=\"hljs-params\">(Class&lt;?&gt; type)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.type = type;\n        objectFactory = (type == ExtensionFactory.class ? <span class=\"hljs-keyword\">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());\n    }\n</code></pre>\n<ol start=\"2\">\n<li>getExtension方法</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> T <span class=\"hljs-title\">getExtension</span><span class=\"hljs-params\">(String name)</span> </span>{\n        Holder&lt;Object&gt; holder = cachedInstances.get(name);\n        <span class=\"hljs-keyword\">if</span> (holder == <span class=\"hljs-keyword\">null</span>) {\n            cachedInstances.putIfAbsent(name, <span class=\"hljs-keyword\">new</span> Holder&lt;Object&gt;());\n            holder = cachedInstances.get(name);\n        }\n        Object instance = holder.get();\n        <span class=\"hljs-comment\">// 从缓存中获取，如果不存在就创建</span>\n        <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">synchronized</span> (holder) {\n                instance = holder.get();\n                <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n                    instance = createExtension(name);\n                    holder.set(instance);\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> (T) instance;\n    }\n</code></pre>\n<p>getExtention方法中做了一些判断和缓存，主要的逻辑在createExtension方法中。我们继续看createExtention方法。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> T <span class=\"hljs-title\">createExtension</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-comment\">// 根据扩展点名称得到扩展类，比如对于LoadBalance，根据random得到RandomLoadBalance类</span>\n        Class&lt;?&gt; clazz = getExtensionClasses().get(name);\n        \n        T instance = (T) EXTENSION_INSTANCES.get(clazz);\n        <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n              <span class=\"hljs-comment\">// 使用反射调用nesInstance来创建扩展类的一个示例</span>\n            EXTENSION_INSTANCES.putIfAbsent(clazz, (T) clazz.newInstance());\n            instance = (T) EXTENSION_INSTANCES.get(clazz);\n        }\n        <span class=\"hljs-comment\">// 对扩展类示例进行依赖注入</span>\n        injectExtension(instance);\n        <span class=\"hljs-comment\">// 如果有wrapper，添加wrapper</span>\n        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;\n        <span class=\"hljs-keyword\">if</span> (wrapperClasses != <span class=\"hljs-keyword\">null</span> &amp;&amp; !wrapperClasses.isEmpty()) {\n            <span class=\"hljs-keyword\">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) {\n                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> instance;\n}\n</code></pre>\n<p>createExtension方法做了以下事情:</p>\n<ol>\n<li>先根据name来得到对应的扩展类。从ClassPath下<code>META-INF</code>文件夹下读取扩展点配置文件。</li>\n<li>使用反射创建一个扩展类的实例</li>\n<li>对扩展类实例的属性进行依赖注入，即IoC。</li>\n<li>如果有wrapper，添加wrapper。即AoP。</li>\n</ol>\n<p>下面我们来重点看下这4个过程</p>\n<ol>\n<li>根据name获取对应的扩展类\n先看代码:</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() {\n        Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();\n        <span class=\"hljs-keyword\">if</span> (classes == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">synchronized</span> (cachedClasses) {\n                classes = cachedClasses.get();\n                <span class=\"hljs-keyword\">if</span> (classes == <span class=\"hljs-keyword\">null</span>) {\n                    classes = loadExtensionClasses();\n                    cachedClasses.set(classes);\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> classes;\n    }\n\n    <span class=\"hljs-comment\">// synchronized in getExtensionClasses</span>\n    <span class=\"hljs-keyword\">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() {\n        <span class=\"hljs-keyword\">final</span> SPI defaultAnnotation = type.getAnnotation(SPI.class);\n        <span class=\"hljs-keyword\">if</span> (defaultAnnotation != <span class=\"hljs-keyword\">null</span>) {\n            String value = defaultAnnotation.value();\n            <span class=\"hljs-keyword\">if</span> (value != <span class=\"hljs-keyword\">null</span> &amp;&amp; (value = value.trim()).length() &gt; <span class=\"hljs-number\">0</span>) {\n                String[] names = NAME_SEPARATOR.split(value);\n                <span class=\"hljs-keyword\">if</span> (names.length &gt; <span class=\"hljs-number\">1</span>) {\n                    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"more than 1 default extension name on extension \"</span> + type.getName());\n                }\n                <span class=\"hljs-keyword\">if</span> (names.length == <span class=\"hljs-number\">1</span>) cachedDefaultName = names[<span class=\"hljs-number\">0</span>];\n            }\n        }\n\n        Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();\n        loadFile(extensionClasses, DUBBO_INTERNAL_DIRECTORY);\n        loadFile(extensionClasses, DUBBO_DIRECTORY);\n        loadFile(extensionClasses, SERVICES_DIRECTORY);\n        <span class=\"hljs-keyword\">return</span> extensionClasses;\n    }\n</code></pre>\n<p>过程很简单，先从缓存中获取，如果没有，就从配置文件中加载。配置文件的路径就是之前提到的:</p>\n<ul>\n<li><code>META-INF/dubbo/internal</code></li>\n<li><code>META-INF/dubbo</code></li>\n<li><code>META-INF/services</code></li>\n</ul>\n<ol start=\"2\">\n<li>使用反射创建扩展实例\n这个过程很简单，使用<code>clazz.newInstance())</code>来完成。创建的扩展实例的属性都是空值。</li>\n<li>扩展实例自动装配\n在实际的场景中，类之间都是有依赖的。扩展实例中也会引用一些依赖，比如简单的Java类，另一个Dubbo的扩展或一个Spring Bean等。依赖的情况很复杂，Dubbo的处理也相对复杂些。我们稍后会有专门的章节对其进行说明，现在，我们只需要知道，Dubbo可以正确的注入扩展点中的普通依赖，Dubbo扩展依赖或Spring依赖等。</li>\n<li>扩展实例自动包装\n自动包装就是要实现类似于Spring的AOP功能。Dubbo利用它在内部实现一些通用的功能，比如日志，监控等。关于扩展实例自动包装的内容，也会在后面单独讲解。</li>\n</ol>\n<p>经过上面的4步，Dubbo就创建并初始化了一个扩展实例。这个实例的依赖被注入了，也根据需要被包装了。到此为止，这个扩展实例就可以被使用了。</p>\n<h1>Dubbo SPI高级用法之自动装配</h1>\n<p>自动装配的相关代码在injectExtension方法中:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> T <span class=\"hljs-title\">injectExtension</span><span class=\"hljs-params\">(T instance)</span> </span>{\n    <span class=\"hljs-keyword\">for</span> (Method method : instance.getClass().getMethods()) {\n        <span class=\"hljs-keyword\">if</span> (method.getName().startsWith(<span class=\"hljs-string\">\"set\"</span>)\n                &amp;&amp; method.getParameterTypes().length == <span class=\"hljs-number\">1</span>\n                &amp;&amp; Modifier.isPublic(method.getModifiers())) {\n            Class&lt;?&gt; pt = method.getParameterTypes()[<span class=\"hljs-number\">0</span>];\n          \n            String property = method.getName().length() &gt; <span class=\"hljs-number\">3</span> ? method.getName().substring(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>).toLowerCase() + method.getName().substring(<span class=\"hljs-number\">4</span>) : <span class=\"hljs-string\">\"\"</span>;\n            Object object = objectFactory.getExtension(pt, property);\n            <span class=\"hljs-keyword\">if</span> (object != <span class=\"hljs-keyword\">null</span>) {\n                method.invoke(instance, object);\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> instance;\n}\n</code></pre>\n<p>要实现对扩展实例的依赖的自动装配，首先需要知道有哪些依赖，这些依赖的类型是什么。Dubbo的方案是查找Java标准的setter方法。即方法名以set开始，只有一个参数。如果扩展类中有这样的set方法，Dubbo会对其进行依赖注入，类似于Spring的set方法注入。\n但是Dubbo中的依赖注入比Spring要复杂，因为Spring注入的都是Spring bean，都是由Spring容器来管理的。而Dubbo的依赖注入中，需要注入的可能是另一个Dubbo的扩展，也可能是一个Spring Bean，或是Google guice的组件，或其他任何一个框架中的组件。Dubbo需要能够从任何一个场景中加载扩展。在injectExtension方法中，是用<code>Object object = objectFactory.getExtension(pt, property)</code>来实现的。objectFactory是ExtensionFactory类型的，在创建ExtensionLoader时被初始化:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">ExtensionLoader</span><span class=\"hljs-params\">(Class&lt;?&gt; type)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.type = type;\n        objectFactory = (type == ExtensionFactory.class ? <span class=\"hljs-keyword\">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());\n    }\n</code></pre>\n<p>objectFacory本身也是一个扩展，通过<code>ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension())</code>来获取。</p>\n<p><img src=\"https://raw.githubusercontent.com/vangoleo/wiki/master/dubbo/dubbo-extensionfactory.png\" alt=\"Dubbo-ExtensionFactory | left\"></p>\n<p>ExtensionLoader有三个实现：</p>\n<ol>\n<li>SpiExtensionLoader：Dubbo自己的Spi去加载Extension</li>\n<li>SpringExtensionLoader：从Spring容器中去加载Extension</li>\n<li>AdaptiveExtensionLoader: 自适应的AdaptiveExtensionLoader</li>\n</ol>\n<p>这里要注意AdaptiveExtensionLoader，源码如下:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Adaptive</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AdaptiveExtensionFactory</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ExtensionFactory</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> List&lt;ExtensionFactory&gt; factories;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">AdaptiveExtensionFactory</span><span class=\"hljs-params\">()</span> </span>{\n        ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);\n        List&lt;ExtensionFactory&gt; list = <span class=\"hljs-keyword\">new</span> ArrayList&lt;ExtensionFactory&gt;();\n        <span class=\"hljs-keyword\">for</span> (String name : loader.getSupportedExtensions()) {\n            list.add(loader.getExtension(name));\n        }\n        factories = Collections.unmodifiableList(list);\n    }\n\n    <span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">T <span class=\"hljs-title\">getExtension</span><span class=\"hljs-params\">(Class&lt;T&gt; type, String name)</span> </span>{\n        <span class=\"hljs-keyword\">for</span> (ExtensionFactory factory : factories) {\n            T extension = factory.getExtension(type, name);\n            <span class=\"hljs-keyword\">if</span> (extension != <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-keyword\">return</span> extension;\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n    }\n}\n</code></pre>\n<p>AdaptiveExtensionLoader类有@Adaptive注解。前面提到了，Dubbo会为每一个扩展创建一个自适应实例。如果扩展类上有@Adaptive，会使用该类作为自适应类。如果没有，Dubbo会为我们创建一个。所以<code>ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension())</code>会返回一个AdaptiveExtensionLoader实例，作为自适应扩展实例。\nAdaptiveExtentionLoader会遍历所有的ExtensionFactory实现，尝试着去加载扩展。如果找到了，返回。如果没有，在下一个ExtensionFactory中继续找。Dubbo内置了两个ExtensionFactory，分别从Dubbo自身的扩展机制和Spring容器中去寻找。由于ExtensionFactory本身也是一个扩展点，我们可以实现自己的ExtensionFactory，让Dubbo的自动装配支持我们自定义的组件。比如，我们在项目中使用了Google的guice这个IoC容器。我们可以实现自己的GuiceExtensionFactory，让Dubbo支持从guice容器中加载扩展。</p>\n<h1>Dubbo SPI高级用法之AoP</h1>\n<p>在用Spring的时候，我们经常会用到AOP功能。在目标类的方法前后插入其他逻辑。比如通常使用Spring AOP来实现日志，监控和鉴权等功能。\nDubbo的扩展机制，是否也支持类似的功能呢？答案是yes。在Dubbo中，有一种特殊的类，被称为Wrapper类。通过装饰者模式，使用包装类包装原始的扩展点实例。在原始扩展点实现前后插入其他逻辑，实现AOP功能。</p>\n<h3>什么是Wrapper类</h3>\n<p>那什么样类的才是Dubbo扩展机制中的Wrapper类呢？Wrapper类是一个有复制构造函数的类，也是典型的装饰者模式。下面就是一个Wrapper类:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span>{\n    <span class=\"hljs-keyword\">private</span> A a;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">A</span><span class=\"hljs-params\">(A a)</span></span>{\n        <span class=\"hljs-keyword\">this</span>.a = a;\n    }\n}\n</code></pre>\n<p>类A有一个构造函数<code>public A(A a)</code>，构造函数的参数是A本身。这样的类就可以成为Dubbo扩展机制中的一个Wrapper类。Dubbo中这样的Wrapper类有ProtocolFilterWrapper, ProtocolListenerWrapper等, 大家可以查看源码加深理解。</p>\n<h3>怎么配置Wrapper类</h3>\n<p>在Dubbo中Wrapper类也是一个扩展点，和其他的扩展点一样，也是在<code>META-INF</code>文件夹中配置的。比如前面举例的ProtocolFilterWrapper和ProtocolListenerWrapper就是在路径<code>dubbo-rpc/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol</code>中配置的:</p>\n<pre><code class=\"language-text\">filter=com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper\nlistener=com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper\nmock=com.alibaba.dubbo.rpc.support.MockProtocol\n</code></pre>\n<p>在Dubbo加载扩展配置文件时，有一段如下的代码:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">try</span> {  \n  clazz.getConstructor(type);    \n  Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;\n  <span class=\"hljs-keyword\">if</span> (wrappers == <span class=\"hljs-keyword\">null</span>) {\n    cachedWrapperClasses = <span class=\"hljs-keyword\">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();\n    wrappers = cachedWrapperClasses;\n  }\n  wrappers.add(clazz);\n} <span class=\"hljs-keyword\">catch</span> (NoSuchMethodException e) {}\n</code></pre>\n<p>这段代码的意思是，如果扩展类有复制构造函数，就把该类存起来，供以后使用。有复制构造函数的类就是Wrapper类。通过<code>clazz.getConstructor(type)</code>来获取参数是扩展点接口的构造函数。注意构造函数的参数类型是扩展点接口，而不是扩展类。\n以Protocol为例。配置文件<code>dubbo-rpc/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol</code>中定义了<code>filter=com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper</code>。\nProtocolFilterWrapper代码如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProtocolFilterWrapper</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Protocol</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Protocol protocol;\n\n    <span class=\"hljs-comment\">// 有一个参数是Protocol的复制构造函数</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ProtocolFilterWrapper</span><span class=\"hljs-params\">(Protocol protocol)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (protocol == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"protocol == null\"</span>);\n        }\n        <span class=\"hljs-keyword\">this</span>.protocol = protocol;\n    }\n</code></pre>\n<p>ProtocolFilterWrapper有一个构造函数<code>public ProtocolFilterWrapper(Protocol protocol)</code>，参数是扩展点Protocol，所以它是一个Dubbo扩展机制中的Wrapper类。ExtensionLoader会把它缓存起来，供以后创建Extension实例的时候，使用这些包装类依次包装原始扩展点。</p>\n<h1>扩展点自适应</h1>\n<p>前面讲到过，Dubbo需要在运行时根据方法参数来决定该使用哪个扩展，所以有了扩展点自适应实例。其实是一个扩展点的代理，将扩展的选择从Dubbo启动时，延迟到RPC调用时。Dubbo中每一个扩展点都有一个自适应类，如果没有显式提供，Dubbo会自动为我们创建一个，默认使用Javaassist。\n先来看下创建自适应扩展类的代码:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> T <span class=\"hljs-title\">getAdaptiveExtension</span><span class=\"hljs-params\">()</span> </span>{\n    Object instance = cachedAdaptiveInstance.get();\n    <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">synchronized</span> (cachedAdaptiveInstance) {\n                instance = cachedAdaptiveInstance.get();\n                <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n                      instance = createAdaptiveExtension();\n                      cachedAdaptiveInstance.set(instance); \n                }\n            }        \n    }\n\n    <span class=\"hljs-keyword\">return</span> (T) instance;\n}\n</code></pre>\n<p>继续看createAdaptiveExtension方法</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> T <span class=\"hljs-title\">createAdaptiveExtension</span><span class=\"hljs-params\">()</span> </span>{        \n    <span class=\"hljs-keyword\">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());\n}\n</code></pre>\n<p>继续看getAdaptiveExtensionClass方法</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() {\n        getExtensionClasses();\n        <span class=\"hljs-keyword\">if</span> (cachedAdaptiveClass != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">return</span> cachedAdaptiveClass;\n        }\n        <span class=\"hljs-keyword\">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();\n    }\n</code></pre>\n<p>继续看createAdaptiveExtensionClass方法，绕了一大圈，终于来到了具体的实现了。看这个createAdaptiveExtensionClass方法，它首先会生成自适应类的Java源码，然后再将源码编译成Java的字节码，加载到JVM中。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() {\n        String code = createAdaptiveExtensionClassCode();\n        ClassLoader classLoader = findClassLoader();\n        com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();\n        <span class=\"hljs-keyword\">return</span> compiler.compile(code, classLoader);\n    }\n</code></pre>\n<p>Compiler的代码，默认实现是javassist。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@SPI</span>(<span class=\"hljs-string\">\"javassist\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Compiler</span> </span>{\n    Class&lt;?&gt; compile(String code, ClassLoader classLoader);\n}\n</code></pre>\n<p>createAdaptiveExtensionClassCode()方法中使用一个StringBuilder来构建自适应类的Java源码。方法实现比较长，这里就不贴代码了。这种生成字节码的方式也挺有意思的，先生成Java源代码，然后编译，加载到jvm中。通过这种方式，可以更好的控制生成的Java类。而且这样也不用care各个字节码生成框架的api等。因为xxx.java文件是Java通用的，也是我们最熟悉的。只是代码的可读性不强，需要一点一点构建xx.java的内容。\n下面是使用createAdaptiveExtensionClassCode方法为Protocol创建的自适应类的Java代码范例:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.alibaba.dubbo.rpc;\n\n<span class=\"hljs-keyword\">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Protocol</span>$<span class=\"hljs-title\">Adpative</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">com</span>.<span class=\"hljs-title\">alibaba</span>.<span class=\"hljs-title\">dubbo</span>.<span class=\"hljs-title\">rpc</span>.<span class=\"hljs-title\">Protocol</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnsupportedOperationException(<span class=\"hljs-string\">\"method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!\"</span>);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getDefaultPort</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnsupportedOperationException(<span class=\"hljs-string\">\"method public abstract int com.alibaba.dubbo.rpc.Protocol.getDefaultPort() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!\"</span>);\n    }\n\n    <span class=\"hljs-keyword\">public</span> com.alibaba.dubbo.rpc.<span class=\"hljs-function\">Exporter <span class=\"hljs-title\">export</span><span class=\"hljs-params\">(com.alibaba.dubbo.rpc.Invoker arg0)</span> <span class=\"hljs-keyword\">throws</span> com.alibaba.dubbo.rpc.RpcException </span>{\n        <span class=\"hljs-keyword\">if</span> (arg0 == <span class=\"hljs-keyword\">null</span>) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"com.alibaba.dubbo.rpc.Invoker argument == null\"</span>);\n        <span class=\"hljs-keyword\">if</span> (arg0.getUrl() == <span class=\"hljs-keyword\">null</span>)\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"com.alibaba.dubbo.rpc.Invoker argument getUrl() == null\"</span>);\n        com.alibaba.dubbo.common.URL url = arg0.getUrl();\n        String extName = (url.getProtocol() == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-string\">\"dubbo\"</span> : url.getProtocol());\n        <span class=\"hljs-keyword\">if</span> (extName == <span class=\"hljs-keyword\">null</span>)\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(\"</span> + url.toString() + <span class=\"hljs-string\">\") use keys([protocol])\"</span>);\n        com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);\n        <span class=\"hljs-keyword\">return</span> extension.export(arg0);\n    }\n\n    <span class=\"hljs-keyword\">public</span> com.alibaba.dubbo.rpc.<span class=\"hljs-function\">Invoker <span class=\"hljs-title\">refer</span><span class=\"hljs-params\">(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1)</span> <span class=\"hljs-keyword\">throws</span> com.alibaba.dubbo.rpc.RpcException </span>{\n        <span class=\"hljs-keyword\">if</span> (arg1 == <span class=\"hljs-keyword\">null</span>) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"url == null\"</span>);\n        com.alibaba.dubbo.common.URL url = arg1;\n        String extName = (url.getProtocol() == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-string\">\"dubbo\"</span> : url.getProtocol());\n        <span class=\"hljs-keyword\">if</span> (extName == <span class=\"hljs-keyword\">null</span>)\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(\"</span> + url.toString() + <span class=\"hljs-string\">\") use keys([protocol])\"</span>);\n        com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);\n        <span class=\"hljs-keyword\">return</span> extension.refer(arg0, arg1);\n    }\n}\n</code></pre>\n<p>大致的逻辑和开始说的一样，通过url解析出参数，解析的逻辑由@Adaptive的value参数控制，然后再根据得到的扩展点名获取扩展点实现，然后进行调用。如果大家想知道具体的构建.java代码的逻辑，可以看<code>createAdaptiveExtensionClassCode</code>的完整实现。\n在生成的Protocol$Adpative中，发现getDefaultPort和destroy方法都是直接抛出异常的，这是为什么呢？来看看Protocol的源码</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@SPI</span>(<span class=\"hljs-string\">\"dubbo\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Protocol</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getDefaultPort</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-meta\">@Adaptive</span>\n    &lt;T&gt; <span class=\"hljs-function\">Exporter&lt;T&gt; <span class=\"hljs-title\">export</span><span class=\"hljs-params\">(Invoker&lt;T&gt; invoker)</span> <span class=\"hljs-keyword\">throws</span> RpcException</span>;\n\n    <span class=\"hljs-meta\">@Adaptive</span>\n    &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">refer</span><span class=\"hljs-params\">(Class&lt;T&gt; type, URL url)</span> <span class=\"hljs-keyword\">throws</span> RpcException</span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">()</span></span>;\n</code></pre>\n<p>可以看到Protocol接口中有4个方法，但只有export和refer两个方法使用了@Adaptive注解。Dubbo自动生成的自适应实例，只有@Adaptive修饰的方法才有具体的实现。所以，Protocol$Adpative类中，也只有export和refer这两个方法有具体的实现，其余方法都是抛出异常。</p>\n"
    },
    {
      "filename": "introduction-to-dubbo-spi.md",
      "__html": "<h2>Dubbo可扩展机制实战</h2>\n<h1>1. Dubbo的扩展机制</h1>\n<p>在Dubbo的官网上，Dubbo描述自己是一个高性能的RPC框架。今天我想聊聊Dubbo的另一个很棒的特性, 就是它的可扩展性。\n如同罗马不是一天建成的，任何系统都一定是从小系统不断发展成为大系统的，想要从一开始就把系统设计的足够完善是不可能的，相反的，我们应该关注当下的需求，然后再不断地对系统进行迭代。在代码层面，要求我们适当的对关注点进行抽象和隔离，在软件不断添加功能和特性时，依然能保持良好的结构和可维护性，同时允许第三方开发者对其功能进行扩展。在某些时候，软件设计者对扩展性的追求甚至超过了性能。</p>\n<p>在谈到软件设计时，可扩展性一直被谈起，那到底什么才是可扩展性，什么样的框架才算有良好的可扩展性呢？它必须要做到以下两点:</p>\n<ol>\n<li>作为框架的维护者，在添加一个新功能时，只需要添加一些新代码，而不用大量的修改现有的代码，即符合开闭原则。</li>\n<li>作为框架的使用者，在添加一个新功能时，不需要去修改框架的源码，在自己的工程中添加代码即可。</li>\n</ol>\n<p>Dubbo很好的做到了上面两点。这要得益于Dubbo的微内核+插件的机制。接下来的章节中我们会慢慢揭开Dubbo扩展机制的神秘面纱。</p>\n<h1>2. 可扩展的几种解决方案</h1>\n<p>通常可扩展的实现有下面几种:</p>\n<ul>\n<li>Factory模式</li>\n<li>IoC容器</li>\n<li>OSGI容器</li>\n</ul>\n<p>Dubbo作为一个框架，不希望强依赖其他的IoC容器，比如Spring，Guice。OSGI也是一个很重的实现，不适合Dubbo。最终Dubbo的实现参考了Java原生的SPI机制，但对其进行了一些扩展，以满足Dubbo的需求。</p>\n<h1>3. Java SPI机制</h1>\n<p>既然Dubbo的扩展机制是基于Java原生的SPI机制，那么我们就先来了解下Java SPI吧。了解了Java的SPI，也就是对Dubbo的扩展机制有一个基本的了解。如果对Java SPI比较了解的同学，可以跳过。</p>\n<p>Java SPI(Service Provider Interface)是JDK内置的一种动态加载扩展点的实现。在ClassPath的<code>META-INF/services</code>目录下放置一个与接口同名的文本文件，文件的内容为接口的实现类，多个实现类用换行符分隔。JDK中使用<code>java.util.ServiceLoader</code>来加载具体的实现。\n让我们通过一个简单的例子，来看看Java SPI是如何工作的。</p>\n<ol>\n<li>定义一个接口IRepository用于实现数据储存</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">IRepository</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">save</span><span class=\"hljs-params\">(String data)</span></span>;\n}\n</code></pre>\n<ol start=\"2\">\n<li>提供IRepository的实现\nIRepository有两个实现。MysqlRepository和MongoRepository。</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MysqlRepository</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IRepository</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">save</span><span class=\"hljs-params\">(String data)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"Save \"</span> + data + <span class=\"hljs-string\">\" to Mysql\"</span>);\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MongoRepository</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IRepository</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">save</span><span class=\"hljs-params\">(String data)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"Save \"</span> + data + <span class=\"hljs-string\">\" to Mongo\"</span>);\n    }\n}\n</code></pre>\n<ol start=\"3\">\n<li>添加配置文件\n在<code>META-INF/services</code>目录添加一个文件，文件名和接口全名称相同，所以文件是<code>META-INF/services/com.demo.IRepository</code>。文件内容为:</li>\n</ol>\n<pre><code class=\"language-text\">com.demo.MongoRepository\ncom.demo.MysqlRepository\n</code></pre>\n<ol start=\"4\">\n<li>通过ServiceLoader加载IRepository实现</li>\n</ol>\n<pre><code class=\"language-java\">ServiceLoader&lt;IRepository&gt; serviceLoader = ServiceLoader.load(IRepository.class);\nIterator&lt;IRepository&gt; it = serviceLoader.iterator();\n<span class=\"hljs-keyword\">while</span> (it != <span class=\"hljs-keyword\">null</span> &amp;&amp; it.hasNext()){\n    IRepository demoService = it.next();\n    System.out.println(<span class=\"hljs-string\">\"class:\"</span> + demoService.getClass().getName());\n    demoService.save(<span class=\"hljs-string\">\"tom\"</span>);\n}\n</code></pre>\n<p>在上面的例子中，我们定义了一个扩展点和它的两个实现。在ClassPath中添加了扩展的配置文件，最后使用ServiceLoader来加载所有的扩展点。\n最终的输出结果为：\nclass:testDubbo.MongoRepository\nSave tom to Mongo\nclass:testDubbo.MysqlRepository\nSave tom to Mysql</p>\n<h1>4. Dubbo的SPI机制</h1>\n<p>Java SPI的使用很简单。也做到了基本的加载扩展点的功能。但Java SPI有以下的不足:</p>\n<ul>\n<li>需要遍历所有的实现，并实例化，然后我们在循环中才能找到我们需要的实现。</li>\n<li>配置文件中只是简单的列出了所有的扩展实现，而没有给他们命名。导致在程序中很难去准确的引用它们。</li>\n<li>扩展如果依赖其他的扩展，做不到自动注入和装配</li>\n<li>不提供类似于Spring的IOC和AOP功能</li>\n<li>扩展很难和其他的框架集成，比如扩展里面依赖了一个Spring bean，原生的Java SPI不支持</li>\n</ul>\n<p>所以Java SPI应付一些简单的场景是可以的，但对于Dubbo，它的功能还是比较弱的。Dubbo对原生SPI机制进行了一些扩展。接下来，我们就更深入地了解下Dubbo的SPI机制。</p>\n<h1>5. Dubbo扩展点机制基本概念</h1>\n<p>在深入学习Dubbo的扩展机制之前，我们先明确Dubbo SPI中的一些基本概念。在接下来的内容中，我们会多次用到这些术语。</p>\n<h3>5.1 扩展点(Extension Point)</h3>\n<p>是一个Java的接口。</p>\n<h3>5.2 扩展(Extension)</h3>\n<p>扩展点的实现类。</p>\n<h3>5.3 扩展实例(Extension Instance)</h3>\n<p>扩展点实现类的实例。</p>\n<h3>5.4 扩展自适应实例(Extension Adaptive Instance)</h3>\n<p>第一次接触这个概念时，可能不太好理解(我第一次也是这样的...)。如果称它为扩展代理类，可能更好理解些。扩展的自适应实例其实就是一个Extension的代理，它实现了扩展点接口。在调用扩展点的接口方法时，会根据实际的参数来决定要使用哪个扩展。比如一个IRepository的扩展点，有一个save方法。有两个实现MysqlRepository和MongoRepository。IRepository的自适应实例在调用接口方法的时候，会根据save方法中的参数，来决定要调用哪个IRepository的实现。如果方法参数中有repository=mysql，那么就调用MysqlRepository的save方法。如果repository=mongo，就调用MongoRepository的save方法。和面向对象的延迟绑定很类似。为什么Dubbo会引入扩展自适应实例的概念呢？</p>\n<ul>\n<li>Dubbo中的配置有两种，一种是固定的系统级别的配置，在Dubbo启动之后就不会再改了。还有一种是运行时的配置，可能对于每一次的RPC，这些配置都不同。比如在xml文件中配置了超时时间是10秒钟，这个配置在Dubbo启动之后，就不会改变了。但针对某一次的RPC调用，可以设置它的超时时间是30秒钟，以覆盖系统级别的配置。对于Dubbo而言，每一次的RPC调用的参数都是未知的。只有在运行时，根据这些参数才能做出正确的决定。</li>\n<li>很多时候，我们的类都是一个单例的，比如Spring的bean，在Spring bean都实例化时，如果它依赖某个扩展点，但是在bean实例化时，是不知道究竟该使用哪个具体的扩展实现的。这时候就需要一个代理模式了，它实现了扩展点接口，方法内部可以根据运行时参数，动态的选择合适的扩展实现。而这个代理就是自适应实例。\n自适应扩展实例在Dubbo中的使用非常广泛，Dubbo中，每一个扩展都会有一个自适应类，如果我们没有提供，Dubbo会使用字节码工具为我们自动生成一个。所以我们基本感觉不到自适应类的存在。后面会有例子说明自适应类是怎么工作的。</li>\n</ul>\n<h3>5.5 @SPI</h3>\n<p>@SPI注解作用于扩展点的接口上，表明该接口是一个扩展点。可以被Dubbo的ExtentionLoader加载。如果没有此ExtensionLoader调用会异常。</p>\n<h3>5.6 @Adaptive</h3>\n<p>@Adaptive注解用在扩展接口的方法上。表示该方法是一个自适应方法。Dubbo在为扩展点生成自适应实例时，如果方法有@Adaptive注解，会为该方法生成对应的代码。方法内部会根据方法的参数，来决定使用哪个扩展。\n@Adaptive注解用在类上代表实现一个装饰类，类似于设计模式中的装饰模式，它主要作用是返回指定类，目前在整个系统中AdaptiveCompiler、AdaptiveExtensionFactory这两个类拥有该注解。</p>\n<h3>5.7 ExtentionLoader</h3>\n<p>类似于Java SPI的ServiceLoader，负责扩展的加载和生命周期维护。</p>\n<h3>5.8 扩展别名</h3>\n<p>和Java SPI不同，Dubbo中的扩展都有一个别名，用于在应用中引用它们。比如</p>\n<pre><code class=\"language-bash\">random=com.alibaba.dubbo.rpc.cluster.loadbalance.RandomLoadBalance\nroundrobin=com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance\n</code></pre>\n<p>其中的random，roundrobin就是对应扩展的别名。这样我们在配置文件中使用random或roundrobin就可以了。</p>\n<h3>5.9 一些路径</h3>\n<p>和Java SPI从<code>/META-INF/services</code>目录加载扩展配置类似，Dubbo也会从以下路径去加载扩展配置文件:</p>\n<ul>\n<li><code>META-INF/dubbo/internal</code></li>\n<li><code>META-INF/dubbo</code></li>\n<li><code>META-INF/services</code></li>\n</ul>\n<h1>6. Dubbo的LoadBalance扩展点解读</h1>\n<p>在了解了Dubbo的一些基本概念后，让我们一起来看一个Dubbo中实际的扩展点，对这些概念有一个更直观的认识。</p>\n<p>我们选择的是Dubbo中的LoadBalance扩展点。Dubbo中的一个服务，通常有多个Provider，consumer调用服务时，需要在多个Provider中选择一个。这就是一个LoadBalance。我们一起来看看在Dubbo中，LoadBalance是如何成为一个扩展点的。</p>\n<h3>6.1 LoadBalance接口</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@SPI</span>(RandomLoadBalance.NAME)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">LoadBalance</span> </span>{\n\n    <span class=\"hljs-meta\">@Adaptive</span>(<span class=\"hljs-string\">\"loadbalance\"</span>)\n    &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">select</span><span class=\"hljs-params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> RpcException</span>;\n}\n</code></pre>\n<p>LoadBalance接口只有一个select方法。select方法从多个invoker中选择其中一个。上面代码中和Dubbo SPI相关的元素有:</p>\n<ul>\n<li>@SPI(<a href=\"http://RandomLoadBalance.NAME\">RandomLoadBalance.NAME</a>)\n@SPI作用于LoadBalance接口，表示接口LoadBalance是一个扩展点。如果没有@SPI注解，试图去加载扩展时，会抛出异常。@SPI注解有一个参数，该参数表示该扩展点的默认实现的别名。如果没有显示的指定扩展，就使用默认实现。<code>RandomLoadBalance.NAME</code>是一个常量，值是&quot;random&quot;，是一个随机负载均衡的实现。\nrandom的定义在配置文件<code>META-INF/dubbo/internal/com.alibaba.dubbo.rpc.cluster.LoadBalance</code>中:</li>\n</ul>\n<pre><code class=\"language-bash\">random=com.alibaba.dubbo.rpc.cluster.loadbalance.RandomLoadBalance\nroundrobin=com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance\nleastactive=com.alibaba.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance\nconsistenthash=com.alibaba.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance\n</code></pre>\n<p>可以看到文件中定义了4个LoadBalance的扩展实现。由于负载均衡的实现不是本次的内容，这里就不过多说明。只用知道Dubbo提供了4种负载均衡的实现，我们可以通过xml文件，properties文件，JVM参数显式的指定一个实现。如果没有，默认使用随机。</p>\n<p><img src=\"https://raw.githubusercontent.com/vangoleo/wiki/master/dubbo/dubbo_loadbalance.png\" alt=\"dubbo-loadbalance | left\"></p>\n<ul>\n<li>@Adaptive(&quot;loadbalance&quot;)\n@Adaptive注解修饰select方法，表明方法select方法是一个可自适应的方法。Dubbo会自动生成该方法对应的代码。当调用select方法时，会根据具体的方法参数来决定调用哪个扩展实现的select方法。@Adaptive注解的参数<code>loadbalance</code>表示方法参数中的loadbalance的值作为实际要调用的扩展实例。\n但奇怪的是，我们发现select的方法中并没有loadbalance参数，那怎么获取loadbalance的值呢？select方法中还有一个URL类型的参数，Dubbo就是从URL中获取loadbalance的值的。这里涉及到Dubbo的URL总线模式，简单说，URL中包含了RPC调用中的所有参数。URL类中有一个<code>Map&lt;String, String&gt; parameters</code>字段，parameters中就包含了loadbalance。</li>\n</ul>\n<h3>6.2 获取LoadBalance扩展</h3>\n<p>Dubbo中获取LoadBalance的代码如下:</p>\n<pre><code class=\"language-java\">LoadBalance lb = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(loadbalanceName);\n</code></pre>\n<p>使用ExtensionLoader.getExtensionLoader(LoadBalance.class)方法获取一个ExtensionLoader的实例，然后调用getExtension，传入一个扩展的别名来获取对应的扩展实例。</p>\n<h1>7. 自定义一个LoadBalance扩展</h1>\n<p>本节中，我们通过一个简单的例子，来自己实现一个LoadBalance，并把它集成到Dubbo中。我会列出一些关键的步骤和代码，也可以从这个地址(<a href=\"https://github.com/vangoleo/dubbo-spi-demo\">https://github.com/vangoleo/dubbo-spi-demo</a>)下载完整的demo。</p>\n<h3>7.1 实现LoadBalance接口</h3>\n<p>首先，编写一个自己实现的LoadBalance，因为是为了演示Dubbo的扩展机制，而不是LoadBalance的实现，所以这里LoadBalance的实现非常简单，选择第一个invoker，并在控制台输出一条日志。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.dubbo.spi.demo.consumer;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoLoadBalance</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">LoadBalance</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">select</span><span class=\"hljs-params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n        System.out.println(<span class=\"hljs-string\">\"DemoLoadBalance: Select the first invoker...\"</span>);\n        <span class=\"hljs-keyword\">return</span> invokers.get(<span class=\"hljs-number\">0</span>);\n    }\n}\n</code></pre>\n<h3>7.2 添加扩展配置文件</h3>\n<p>添加文件:<code>META-INF/dubbo/com.alibaba.dubbo.rpc.cluster.LoadBalance</code>。文件内容如下:</p>\n<pre><code class=\"language-bash\">demo=com.dubbo.spi.demo.consumer.DemoLoadBalance\n</code></pre>\n<h3>7.3 配置使用自定义LoadBalance</h3>\n<p>通过上面的两步，已经添加了一个名字为demo的LoadBalance实现，并在配置文件中进行了相应的配置。接下来，需要显式的告诉Dubbo使用demo的负载均衡实现。如果是通过spring的方式使用Dubbo，可以在xml文件中进行设置。</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"helloService\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.dubbo.spi.demo.api.IHelloService\"</span> <span class=\"hljs-attr\">loadbalance</span>=<span class=\"hljs-string\">\"demo\"</span> /&gt;</span>\n</code></pre>\n<p>在consumer端的<a href=\"dubbo:reference\">dubbo:reference</a>中配置&lt;loadbalance=&quot;demo&quot;&gt;</p>\n<h3>7.4 启动Dubbo</h3>\n<p>启动Dubbo，调用一次IHelloService，可以看到控制台会输出一条<code>DemoLoadBalance: Select the first invoker...</code>日志。说明Dubbo的确是使用了我们自定义的LoadBalance。</p>\n<h1>总结</h1>\n<p>到此，我们从Java SPI开始，了解了Dubbo SPI 的基本概念，并结合了Dubbo中的LoadBalance加深了理解。最后，我们还实践了一下，创建了一个自定义LoadBalance，并集成到Dubbo中。相信通过这里理论和实践的结合，大家对Dubbo的可扩展有更深入的理解。\n总结一下，Dubbo SPI有以下的特点:</p>\n<ul>\n<li>对Dubbo进行扩展，不需要改动Dubbo的源码</li>\n<li>自定义的Dubbo的扩展点实现，是一个普通的Java类，Dubbo没有引入任何Dubbo特有的元素，对代码侵入性几乎为零。</li>\n<li>将扩展注册到Dubbo中，只需要在ClassPath中添加配置文件。使用简单。而且不会对现有代码造成影响。符合开闭原则。</li>\n<li>dubbo的扩展机制设计默认值：@SPI(&quot;dubbo&quot;) 代表默认的spi对象</li>\n<li>Dubbo的扩展机制支持IoC,AoP等高级功能</li>\n<li>Dubbo的扩展机制能很好的支持第三方IoC容器，默认支持Spring Bean，可自己扩展来支持其他容器，比如Google的Guice。</li>\n<li>切换扩展点的实现，只需要在配置文件中修改具体的实现，不需要改代码。使用方便。</li>\n</ul>\n<p>下一篇，我们将会一起深入Dubbo的源码，更深入的了解Dubbo的可扩展机制。</p>\n"
    },
    {
      "filename": "optimization-branch-prediction.md",
      "__html": "<h1>优化技巧：提前if判断帮助CPU分支预测</h1>\n<hr>\n<h2>分支预测</h2>\n<p>在stackoverflow上有一个非常有名的问题：<a href=\"https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array\">为什么处理有序数组要比非有序数组快？</a>，可见分支预测对代码运行效率有非常大的影响。</p>\n<p>现代CPU都支持分支预测(branch prediction)和指令流水线(instruction pipeline)，这两个结合可以极大提高CPU效率。对于像简单的if跳转，CPU是可以比较好地做分支预测的。但是对于switch跳转，CPU则没有太多的办法。switch本质上是据索引，从地址数组里取地址再跳转。</p>\n<p>要提高代码执行效率，一个重要的原则就是尽量避免CPU把流水线清空，那么提高分支预测的成功率就非常重要。</p>\n<p>那么对于代码里，如果某个switch分支概率很高，是否可以考虑代码层面帮CPU把判断提前，来提高代码执行效率呢？</p>\n<h2>Dubbo里ChannelEventRunnable的switch判断</h2>\n<p>在<code>ChannelEventRunnable</code>里有一个switch来判断channel state，然后做对应的逻辑：<a href=\"https://github.com/hengyunabc/incubator-dubbo/blob/dubbo-2.6.1/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/ChannelEventRunnable.java#L54\">查看</a></p>\n<p>一个channel建立起来之后，超过99.9%情况它的state都是<code>ChannelState.RECEIVED</code>，那么可以考虑把这个判断提前。</p>\n<h2>benchmark验证</h2>\n<p>下面通过jmh来验证下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestBenchMarks</span> </span>{\n\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> ChannelState {\n\t\tCONNECTED, DISCONNECTED, SENT, RECEIVED, CAUGHT\n\t}\n\n\t<span class=\"hljs-meta\">@State</span>(Scope.Benchmark)\n\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ExecutionPlan</span> </span>{\n\t\t<span class=\"hljs-meta\">@Param</span>({ <span class=\"hljs-string\">\"1000000\"</span> })\n\t\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> size;\n\t\t<span class=\"hljs-keyword\">public</span> ChannelState[] states = <span class=\"hljs-keyword\">null</span>;\n\n\t\t<span class=\"hljs-meta\">@Setup</span>\n\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setUp</span><span class=\"hljs-params\">()</span> </span>{\n\t\t\tChannelState[] values = ChannelState.values();\n\t\t\tstates = <span class=\"hljs-keyword\">new</span> ChannelState[size];\n\t\t\tRandom random = <span class=\"hljs-keyword\">new</span> Random(<span class=\"hljs-keyword\">new</span> Date().getTime());\n\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; i++) {\n\t\t\t\t<span class=\"hljs-keyword\">int</span> nextInt = random.nextInt(<span class=\"hljs-number\">1000000</span>);\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (nextInt &gt; <span class=\"hljs-number\">100</span>) {\n\t\t\t\t\tstates[i] = ChannelState.RECEIVED;\n\t\t\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\t\t\tstates[i] = values[nextInt % values.length];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t<span class=\"hljs-meta\">@Fork</span>(value = <span class=\"hljs-number\">5</span>)\n\t<span class=\"hljs-meta\">@Benchmark</span>\n\t<span class=\"hljs-meta\">@BenchmarkMode</span>(Mode.Throughput)\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">benchSiwtch</span><span class=\"hljs-params\">(ExecutionPlan plan, Blackhole bh)</span> </span>{\n\t\t<span class=\"hljs-keyword\">int</span> result = <span class=\"hljs-number\">0</span>;\n\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; plan.size; ++i) {\n\t\t\t<span class=\"hljs-keyword\">switch</span> (plan.states[i]) {\n\t\t\t<span class=\"hljs-keyword\">case</span> CONNECTED:\n\t\t\t\tresult += ChannelState.CONNECTED.ordinal();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t<span class=\"hljs-keyword\">case</span> DISCONNECTED:\n\t\t\t\tresult += ChannelState.DISCONNECTED.ordinal();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t<span class=\"hljs-keyword\">case</span> SENT:\n\t\t\t\tresult += ChannelState.SENT.ordinal();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t<span class=\"hljs-keyword\">case</span> RECEIVED:\n\t\t\t\tresult += ChannelState.RECEIVED.ordinal();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t<span class=\"hljs-keyword\">case</span> CAUGHT:\n\t\t\t\tresult += ChannelState.CAUGHT.ordinal();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t}\n\t\t}\n\t\tbh.consume(result);\n\t}\n\n\t<span class=\"hljs-meta\">@Fork</span>(value = <span class=\"hljs-number\">5</span>)\n\t<span class=\"hljs-meta\">@Benchmark</span>\n\t<span class=\"hljs-meta\">@BenchmarkMode</span>(Mode.Throughput)\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">benchIfAndSwitch</span><span class=\"hljs-params\">(ExecutionPlan plan, Blackhole bh)</span> </span>{\n\t\t<span class=\"hljs-keyword\">int</span> result = <span class=\"hljs-number\">0</span>;\n\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; plan.size; ++i) {\n\t\t\tChannelState state = plan.states[i];\n\t\t\t<span class=\"hljs-keyword\">if</span> (state == ChannelState.RECEIVED) {\n\t\t\t\tresult += ChannelState.RECEIVED.ordinal();\n\t\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\t\t<span class=\"hljs-keyword\">switch</span> (state) {\n\t\t\t\t<span class=\"hljs-keyword\">case</span> CONNECTED:\n\t\t\t\t\tresult += ChannelState.CONNECTED.ordinal();\n\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t\t<span class=\"hljs-keyword\">case</span> SENT:\n\t\t\t\t\tresult += ChannelState.SENT.ordinal();\n\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t\t<span class=\"hljs-keyword\">case</span> DISCONNECTED:\n\t\t\t\t\tresult += ChannelState.DISCONNECTED.ordinal();\n\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t\t<span class=\"hljs-keyword\">case</span> CAUGHT:\n\t\t\t\t\tresult += ChannelState.CAUGHT.ordinal();\n\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbh.consume(result);\n\t}\n}\n</code></pre>\n<ul>\n<li>benchSiwtch里是纯switch判断</li>\n<li>benchIfAndSwitch 里用一个if提前判断state是否<code>ChannelState.RECEIVED</code></li>\n</ul>\n<p>benchmark结果是：</p>\n<pre><code>Result &quot;io.github.hengyunabc.jmh.TestBenchMarks.benchSiwtch&quot;:\n  576.745 ±(99.9%) 6.806 ops/s [Average]\n  (min, avg, max) = (490.348, 576.745, 618.360), stdev = 20.066\n  CI (99.9%): [569.939, 583.550] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:06:48\n\nBenchmark                         (size)   Mode  Cnt     Score    Error  Units\nTestBenchMarks.benchIfAndSwitch  1000000  thrpt  100  1535.867 ± 61.212  ops/s\nTestBenchMarks.benchSiwtch       1000000  thrpt  100   576.745 ±  6.806  ops/s\n</code></pre>\n<p>可以看到提前if判断的确提高了代码效率，这种技巧可以放在性能要求严格的地方。</p>\n<p>Benchmark代码：<a href=\"https://github.com/hengyunabc/jmh-demo\">https://github.com/hengyunabc/jmh-demo</a></p>\n<h2>总结</h2>\n<ul>\n<li>switch对于CPU来说难以做分支预测</li>\n<li>某些switch条件如果概率比较高，可以考虑单独提前if判断，充分利用CPU的分支预测机制</li>\n</ul>\n"
    },
    {
      "filename": "spring-boot-dubbo-start-stop-analysis.md",
      "__html": "<h1>Spring-boot+Dubbo应用启停源码分析</h1>\n<h3>背景介绍</h3>\n<p><a href=\"https://github.com/apache/incubator-dubbo-spring-boot-project\">Dubbo Spring Boot</a> 工程致力于简化 Dubbo RPC 框架在Spring Boot应用场景的开发。同时也整合了 Spring Boot 特性：</p>\n<ul>\n<li><a href=\"https://github.com/apache/incubator-dubbo-spring-boot-project/blob/master/dubbo-spring-boot-autoconfigure\">自动装配</a> (比如： 注解驱动, 自动装配等).</li>\n<li><a href=\"https://github.com/apache/incubator-dubbo-spring-boot-project/blob/master/dubbo-spring-boot-actuator\">Production-Ready</a> (比如： 安全, 健康检查, 外部化配置等).</li>\n</ul>\n<h3>DubboConsumer启动分析</h3>\n<p>你有没有想过一个问题？<code>incubator-dubbo-spring-boot-project</code>中的<code>DubboConsumerDemo</code>应用就一行代码，<code>main</code>方法执行完之后，为什么不会直接退出呢？</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@SpringBootApplication</span>(scanBasePackages = <span class=\"hljs-string\">\"com.alibaba.boot.dubbo.demo.consumer.controller\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DubboConsumerDemo</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(DubboConsumerDemo.class,args);\n    }\n\n}\n</code></pre>\n<p>其实要回答这样一个问题，我们首先需要把这个问题进行一个抽象，即一个JVM进程，在什么情况下会退出？</p>\n<p>以Java 8为例，通过查阅JVM语言规范[1]，在12.8章节中有清晰的描述：</p>\n<p>A program terminates all its activity and <em>exits</em> when one of two things happens:</p>\n<ul>\n<li>All the threads that are not daemon threads terminate.</li>\n<li>Some thread invokes the <code>exit</code> method of class <code>Runtime</code> or class <code>System</code>, and the <code>exit</code> operation is not forbidden by the security manager.</li>\n</ul>\n<p>也就是说，导致JVM的退出只有2种情况：</p>\n<ol>\n<li>所有的非daemon进程完全终止</li>\n<li>某个线程调用了<code>System.exit()</code>或<code>Runtime.exit()</code></li>\n</ol>\n<p>因此针对上面的情况，我们判断，一定是有某个非daemon线程没有退出导致。我们知道，通过jstack可以看到所有的线程信息，包括他们是否是daemon线程，可以通过jstack找出那些是非deamon的线程。</p>\n<pre><code class=\"language-sh\">➜  jstack 57785 | grep tid | grep -v <span class=\"hljs-string\">\"daemon\"</span>\n<span class=\"hljs-string\">\"container-0\"</span> <span class=\"hljs-comment\">#37 prio=5 os_prio=31 tid=0x00007fbe312f5800 nid=0x7103 waiting on condition  [0x0000700010144000]</span>\n<span class=\"hljs-string\">\"container-1\"</span> <span class=\"hljs-comment\">#49 prio=5 os_prio=31 tid=0x00007fbe3117f800 nid=0x7b03 waiting on condition  [0x0000700010859000]</span>\n<span class=\"hljs-string\">\"DestroyJavaVM\"</span> <span class=\"hljs-comment\">#83 prio=5 os_prio=31 tid=0x00007fbe30011000 nid=0x2703 waiting on condition  [0x0000000000000000]</span>\n<span class=\"hljs-string\">\"VM Thread\"</span> os_prio=31 tid=0x00007fbe3005e800 nid=0x3703 runnable\n<span class=\"hljs-string\">\"GC Thread#0\"</span> os_prio=31 tid=0x00007fbe30013800 nid=0x5403 runnable\n<span class=\"hljs-string\">\"GC Thread#1\"</span> os_prio=31 tid=0x00007fbe30021000 nid=0x5303 runnable\n<span class=\"hljs-string\">\"GC Thread#2\"</span> os_prio=31 tid=0x00007fbe30021800 nid=0x2d03 runnable\n<span class=\"hljs-string\">\"GC Thread#3\"</span> os_prio=31 tid=0x00007fbe30022000 nid=0x2f03 runnable\n<span class=\"hljs-string\">\"G1 Main Marker\"</span> os_prio=31 tid=0x00007fbe30040800 nid=0x5203 runnable\n<span class=\"hljs-string\">\"G1 Conc#0\"</span> os_prio=31 tid=0x00007fbe30041000 nid=0x4f03 runnable\n<span class=\"hljs-string\">\"G1 Refine#0\"</span> os_prio=31 tid=0x00007fbe31044800 nid=0x4e03 runnable\n<span class=\"hljs-string\">\"G1 Refine#1\"</span> os_prio=31 tid=0x00007fbe31045800 nid=0x4d03 runnable\n<span class=\"hljs-string\">\"G1 Refine#2\"</span> os_prio=31 tid=0x00007fbe31046000 nid=0x4c03 runnable\n<span class=\"hljs-string\">\"G1 Refine#3\"</span> os_prio=31 tid=0x00007fbe31047000 nid=0x4b03 runnable\n<span class=\"hljs-string\">\"G1 Young RemSet Sampling\"</span> os_prio=31 tid=0x00007fbe31047800 nid=0x3603 runnable\n<span class=\"hljs-string\">\"VM Periodic Task Thread\"</span> os_prio=31 tid=0x00007fbe31129000 nid=0x6703 waiting on condition\n\n</code></pre>\n<blockquote>\n<p>此处通过grep tid 找出所有的线程摘要，通过grep -v找出不包含daemon关键字的行</p>\n</blockquote>\n<p>通过上面的结果，我们发现了一些信息：</p>\n<ul>\n<li>有两个线程<code>container-0</code>, <code>container-1</code>非常可疑，他们是非daemon线程，处于wait状态</li>\n<li>有一些GC相关的线程，和VM打头的线程，也是非daemon线程，但他们很有可能是JVM自己的线程，在此暂时忽略。</li>\n</ul>\n<p>综上，我们可以推断，很可能是因为<code>container-0</code>和<code>container-1</code>导致JVM没有退出。现在我们通过源码，搜索一下到底是谁创建的这两个线程。</p>\n<p>通过对spring-boot的源码分析，我们在<code>org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainer</code>的<code>startDaemonAwaitThread</code>找到了如下代码</p>\n<pre><code class=\"language-java\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">startDaemonAwaitThread</span><span class=\"hljs-params\">()</span> </span>{\n\t\tThread awaitThread = <span class=\"hljs-keyword\">new</span> Thread(<span class=\"hljs-string\">\"container-\"</span> + (containerCounter.get())) {\n\n\t\t\t<span class=\"hljs-meta\">@Override</span>\n\t\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n\t\t\t\tTomcatEmbeddedServletContainer.<span class=\"hljs-keyword\">this</span>.tomcat.getServer().await();\n\t\t\t}\n\n\t\t};\n\t\tawaitThread.setContextClassLoader(getClass().getClassLoader());\n\t\tawaitThread.setDaemon(<span class=\"hljs-keyword\">false</span>);\n\t\tawaitThread.start();\n\t}\n</code></pre>\n<p>在这个方法加个断点，看下调用堆栈：</p>\n<pre><code>initialize:115, TomcatEmbeddedServletContainer (org.springframework.boot.context.embedded.tomcat)\n&lt;init&gt;:84, TomcatEmbeddedServletContainer (org.springframework.boot.context.embedded.tomcat)\ngetTomcatEmbeddedServletContainer:554, TomcatEmbeddedServletContainerFactory (org.springframework.boot.context.embedded.tomcat)\ngetEmbeddedServletContainer:179, TomcatEmbeddedServletContainerFactory (org.springframework.boot.context.embedded.tomcat)\ncreateEmbeddedServletContainer:164, EmbeddedWebApplicationContext (org.springframework.boot.context.embedded)\nonRefresh:134, EmbeddedWebApplicationContext (org.springframework.boot.context.embedded)\nrefresh:537, AbstractApplicationContext (org.springframework.context.support)\nrefresh:122, EmbeddedWebApplicationContext (org.springframework.boot.context.embedded)\nrefresh:693, SpringApplication (org.springframework.boot)\nrefreshContext:360, SpringApplication (org.springframework.boot)\nrun:303, SpringApplication (org.springframework.boot)\nrun:1118, SpringApplication (org.springframework.boot)\nrun:1107, SpringApplication (org.springframework.boot)\nmain:35, DubboConsumerDemo (com.alibaba.boot.dubbo.demo.consumer.bootstrap)\n</code></pre>\n<p>可以看到，spring-boot应用在启动的过程中，由于默认启动了Tomcat暴露HTTP服务，所以执行到了上述方法，而Tomcat启动的所有的线程，默认都是daemon线程，例如监听请求的Acceptor，工作线程池等等，如果这里不加控制的话，启动完成之后JVM也会退出。因此需要显示的启动一个线程，在某个条件下进行持续等待，从而避免线程退出。</p>\n<p>下面我们在深挖一下，在Tomcat的<code>this.tomcat.getServer().await()</code>这个方法中，线程是如何实现不退出的。这里为了阅读方便，去掉了不相关的代码。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">await</span><span class=\"hljs-params\">()</span> </span>{\n    \t<span class=\"hljs-comment\">// ...</span>\n        <span class=\"hljs-keyword\">if</span>( port==-<span class=\"hljs-number\">1</span> ) {\n            <span class=\"hljs-keyword\">try</span> {\n                awaitThread = Thread.currentThread();\n                <span class=\"hljs-keyword\">while</span>(!stopAwait) {\n                    <span class=\"hljs-keyword\">try</span> {\n                        Thread.sleep( <span class=\"hljs-number\">10000</span> );\n                    } <span class=\"hljs-keyword\">catch</span>( InterruptedException ex ) {\n                        <span class=\"hljs-comment\">// continue and check the flag</span>\n                    }\n                }\n            } <span class=\"hljs-keyword\">finally</span> {\n                awaitThread = <span class=\"hljs-keyword\">null</span>;\n            }\n            <span class=\"hljs-keyword\">return</span>;\n        }\n\t\t<span class=\"hljs-comment\">// ...</span>\n    }\n</code></pre>\n<p>在await方法中，实际上当前线程在一个while循环中每10秒检查一次 <code>stopAwait</code>这个变量，它是一个<code>volatile</code>类型变量，用于确保被另一个线程修改后，当前线程能够立即看到这个变化。如果没有变化，就会一直处于while循环中。这就是该线程不退出的原因，也就是整个spring-boot应用不退出的原因。</p>\n<p>因为Springboot应用同时启动了8080和8081(management port)两个端口，实际是启动了两个Tomcat，因此会有两个线程<code>container-0</code>和<code>container-1</code>。</p>\n<p>接下来，我们再看看，这个Spring-boot应用又是如何退出的呢？</p>\n<h3>DubboConsumer退出分析</h3>\n<p>在前面的描述中提到，有一个线程持续的在检查<code>stopAwait</code>这个变量，那么我们自然想到，在Stop的时候，应该会有一个线程去修改<code>stopAwait</code>，打破这个while循环，那又是谁在修改这个变量呢？</p>\n<p>通过对源码分析，可以看到只有一个方法修改了<code>stopAwait</code>,即<code>org.apache.catalina.core.StandardServer#stopAwait</code>，我们在此处加个断点，看看是谁在调用。</p>\n<blockquote>\n<p>注意，当我们在Intellij IDEA的Debug模式，加上一个断点后，需要在命令行下使用<code>kill -s INT $PID</code>或者<code>kill -s TERM $PID</code>才能触发断点，点击IDE上的Stop按钮，不会触发断点。这是IDEA的bug</p>\n</blockquote>\n<p>可以看到有一个名为<code>Thread-3</code>的线程调用了该方法：</p>\n<pre><code class=\"language-java\">stopAwait:<span class=\"hljs-number\">390</span>, StandardServer (org.apache.catalina.core)\nstopInternal:<span class=\"hljs-number\">819</span>, StandardServer (org.apache.catalina.core)\nstop:<span class=\"hljs-number\">226</span>, LifecycleBase (org.apache.catalina.util)\nstop:<span class=\"hljs-number\">377</span>, Tomcat (org.apache.catalina.startup)\nstopTomcat:<span class=\"hljs-number\">241</span>, TomcatEmbeddedServletContainer (org.springframework.boot.context.embedded.tomcat)\nstop:<span class=\"hljs-number\">295</span>, TomcatEmbeddedServletContainer (org.springframework.boot.context.embedded.tomcat)\nstopAndReleaseEmbeddedServletContainer:<span class=\"hljs-number\">306</span>, EmbeddedWebApplicationContext (org.springframework.boot.context.embedded)\nonClose:<span class=\"hljs-number\">155</span>, EmbeddedWebApplicationContext (org.springframework.boot.context.embedded)\ndoClose:<span class=\"hljs-number\">1014</span>, AbstractApplicationContext (org.springframework.context.support)\nrun:<span class=\"hljs-number\">929</span>, AbstractApplicationContext$<span class=\"hljs-number\">2</span> (org.springframework.context.support)\n</code></pre>\n<p>通过源码分析，原来是通过Spring注册的<code>ShutdownHook</code>来执行的</p>\n<pre><code class=\"language-java\">\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerShutdownHook</span><span class=\"hljs-params\">()</span> </span>{\n\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.shutdownHook == <span class=\"hljs-keyword\">null</span>) {\n\t\t\t<span class=\"hljs-comment\">// No shutdown hook registered yet.</span>\n\t\t\t<span class=\"hljs-keyword\">this</span>.shutdownHook = <span class=\"hljs-keyword\">new</span> Thread() {\n\t\t\t\t<span class=\"hljs-meta\">@Override</span>\n\t\t\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n\t\t\t\t\t<span class=\"hljs-keyword\">synchronized</span> (startupShutdownMonitor) {\n\t\t\t\t\t\tdoClose();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tRuntime.getRuntime().addShutdownHook(<span class=\"hljs-keyword\">this</span>.shutdownHook);\n\t\t}\n\t}\n</code></pre>\n<p>通过查阅Java的API文档[2], 我们可以知道ShutdownHook将在下面两种情况下执行</p>\n<blockquote>\n<p>The Java virtual machine <em>shuts down</em> in response to two kinds of events:</p>\n<ul>\n<li>The program <em>exits</em> normally, when the last non-daemon thread exits or when the <code>exit</code> (equivalently, <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#exit-int-\"><code>System.exit</code></a>) method is invoked, or</li>\n<li>The virtual machine is <em>terminated</em> in response to a user interrupt, such as typing <code>^C</code>, or a system-wide event, such as user logoff or system shutdown.</li>\n</ul>\n</blockquote>\n<ol>\n<li>调用了System.exit()方法</li>\n<li>响应外部的信号，例如Ctrl+C（其实发送的是SIGINT信号），或者是<code>SIGTERM</code>信号（默认<code>kill $PID</code>发送的是<code>SIGTERM</code>信号）</li>\n</ol>\n<p>因此，正常的应用在停止过程中(<code>kill -9 $PID</code>除外)，都会执行上述ShutdownHook，它的作用不仅仅是关闭tomcat，还有进行其他的清理工作，在此不再赘述。</p>\n<h3>总结</h3>\n<ol>\n<li>在<code>DubboConsumer</code>启动的过程中，通过启动一个独立的非daemon线程循环检查变量的状态，确保进程不退出</li>\n<li>在<code>DubboConsumer</code>停止的过程中，通过执行spring容器的shutdownhook，修改了变量的状态，使得程序正常退出</li>\n</ol>\n<h3>问题</h3>\n<p>在DubboProvider的例子中，我们看到Provider并没有启动Tomcat提供HTTP服务，那又是如何实现不退出的呢？我们将在下一篇文章中回答这个问题。</p>\n<h4>彩蛋</h4>\n<p>在<code>Intellij IDEA</code>中运行了如下的单元测试，创建一个线程执行睡眠1000秒的操作，我们惊奇的发现，代码并没有线程执行完就退出了，这又是为什么呢？（被创建的线程是非daemon线程）</p>\n<pre><code class=\"language-java\">    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">new</span> Thread(<span class=\"hljs-keyword\">new</span> Runnable() {\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n                <span class=\"hljs-keyword\">try</span> {\n                    Thread.sleep(<span class=\"hljs-number\">1000000</span>);\n                } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n</code></pre>\n<p>[1] <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.8\">https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.8</a></p>\n<p>[2] <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#addShutdownHook\">https://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#addShutdownHook</a></p>\n"
    }
  ],
  "en-us": [
    {
      "filename": "apachecon-na-2018.md",
      "__html": "<h2>The ApacheCon NA schedule has been announced</h2>\n<p>Ian Luo(PPMC) and Jun Liu(PPMC) will talk about &quot;Introducing Apache Dubbo(Incubating): What is Dubbo and How it Works&quot; at ApacheCon NA this year in Montréal! Please check out the schedule <a href=\"https://apachecon.dukecon.org/acna/2018/#/scheduledEvent/b8db9dc580d85853f\">here</a> and register <a href=\"https://www.eventbrite.com/e/apachecon-north-america-2018-registration-43200327342\">here</a>.</p>\n"
    },
    {
      "filename": "dubbo-meetup-beijing-may-12th-2018.md",
      "__html": "<h2>The first Dubbo meetup has been held in Beijing</h2>\n<p>The first Dubbo meetup has successfully been held in Beijing, over 400+ people were present. What a great event!</p>\n<p>Please enjoy the slides of the topics:</p>\n<ul>\n<li>Ian Luo: Dubbo's present and future (Chinese) <a href=\"https://github.com/dubbo/awesome-dubbo/raw/master/slides/meetup/201805%40Beijing/dubbo-present-and-future.pdf\">slides</a></li>\n<li>Jun Liu: Introduction to the 4th Aliware Performance Challenge (Chinese) <a href=\"https://github.com/dubbo/awesome-dubbo/raw/master/slides/meetup/201805%40Beijing/introduction-to-4th-aliware-performance-challenge.pdf\">slides</a></li>\n<li>Zhixuan Chen: Quickly building Microservice with Dubbo and Spring-boot (Chinese) <a href=\"https://github.com/dubbo/awesome-dubbo/raw/master/slides/meetup/201805%40Beijing/quickly-building-microservice-with-dubbo-and-springboot.pdf\">slides</a></li>\n<li>Xin Wang: Dubbo and Weidian's Practice on Microservice Architecture (Chinese) <a href=\"https://github.com/dubbo/awesome-dubbo/raw/master/slides/meetup/201805%40Beijing/dubbo-and-weidian's-practice-on-microservice-architecture.pdf\">slides</a></li>\n</ul>\n"
    },
    {
      "filename": "gsoc-2018.md",
      "__html": "<h2>The GSoC(Google Summer of Code) 2018 projects has been announced</h2>\n<p>The GSoC(Google Summer of Code) 2018 projects has been announced, Raghu Reddy's project &quot;Extending Serialization protocols support for Apache Dubbo&quot; has been <a href=\"https://summerofcode.withgoogle.com/projects/#4747840161579008\">accepted</a>! Congratulations!</p>\n"
    },
    {
      "filename": "qcon-beijing-2018.md",
      "__html": "<h2>Dubbo roadmap is announced in QCon Beijing 2018</h2>\n<p>Ian Luo has delivered a great talk at QCon Beijing 2018, where the roadmap of Dubbo has also be announced. Please enjoy the <a href=\"https://github.com/dubbo/awesome-dubbo/raw/master/slides/qcon2018/dubbo-present-and-future.pdf\">slides</a>!</p>\n"
    }
  ]
}