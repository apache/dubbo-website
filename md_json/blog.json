{
  "zh-cn": [
    {
      "filename": "Prepare-an-Apache-release.md",
      "__html": "<h2>理解Apache发布的内容和流程</h2>\n<p>总的来说，Source Release是Apache关注的重点，也是发布的必须内容；而Binary Release是可选项，Dubbo可以选择是否发布二进制包到Apache仓库或者发布到Maven中央仓库。</p>\n<p>请参考以下链接，找到更多关于ASF的发布指南:</p>\n<ul>\n<li><a href=\"http://www.apache.org/dev/release-publishing\">Apache Release Guide</a></li>\n<li><a href=\"http://www.apache.org/dev/release.html\">Apache Release Policy</a></li>\n<li><a href=\"http://www.apache.org/dev/publishing-maven-artifacts.html\">Maven Release Info</a></li>\n</ul>\n<h2>本地构建环境准备</h2>\n<p>主要包括签名工具、Maven仓库认证相关准备</p>\n<ol>\n<li>\n<p>安装GPG，参见 <a href=\"https://www.gnupg.org/download/index.html\">https://www.gnupg.org/download/index.html</a></p>\n<ul>\n<li>如Mac OS</li>\n</ul>\n<pre><code class=\"language-sh\">$ brew install gpg\n$ gpg --version <span class=\"hljs-comment\">#检查版本，应该为2.x</span>\n</code></pre>\n</li>\n<li>\n<p>用gpg生成key</p>\n<ul>\n<li>根据提示，生成key</li>\n</ul>\n<pre><code class=\"language-shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> gpg2 --full-gen-key</span>\ngpg (GnuPG) 2.0.12; Copyright (C) 2009 Free Software Foundation, Inc.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\nPlease select what kind of key you want:\n  (1) RSA and RSA (default)\n  (2) DSA and Elgamal\n  (3) DSA (sign only)\n  (4) RSA (sign only)\nYour selection? 1\nRSA keys may be between 1024 and 4096 bits long.\nWhat keysize do you want? (2048) 4096\nRequested keysize is 4096 bits\nPlease specify how long the key should be valid.\n        0 = key does not expire\n     &lt;n&gt;  = key expires in n days\n     &lt;n&gt;w = key expires in n weeks\n     &lt;n&gt;m = key expires in n months\n     &lt;n&gt;y = key expires in n years\nKey is valid for? (0) \nKey does not expire at all\nIs this correct? (y/N) y\n\nGnuPG needs to construct a user ID to identify your key.\n\nReal name: Robert Burrell Donkin\nEmail address: rdonkin@apache.org\nComment: CODE SIGNING KEY\nYou selected this USER-ID:\n   \"Robert Burrell Donkin (CODE SIGNING KEY) &lt;rdonkin@apache.org&gt;\"\n\nChange (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O\nYou need a Passphrase to protect your secret key. # 填入密码，以后打包过程中会经常用到\n</code></pre>\n<ul>\n<li>查看key id</li>\n</ul>\n<pre><code class=\"language-sh\">$ gpg --list-keys\npub   rsa4096/28681CB1 2018-04-26 <span class=\"hljs-comment\"># 28681CB1就是key id</span>\nuid       [ultimate] liujun (apache-dubbo) &lt;liujun@apache.org&gt;\nsub   rsa4096/D3D6984B 2018-04-26\n\n<span class=\"hljs-comment\"># 通过key id发送public key到keyserver</span>\n$ gpg --keyserver pgpkeys.mit.edu --send-key 28681CB1\n<span class=\"hljs-comment\"># 其中，pgpkeys.mit.edu为随意挑选的keyserver，keyserver列表为：https://sks-keyservers.net/status/，因为相互之间是自动同步的，选任意一个都可以。</span>\n</code></pre>\n<ul>\n<li>如果有多个public key，设置默认key</li>\n</ul>\n<p>~/.gnupg/gpg.conf</p>\n<pre><code class=\"language-proper\"># If you have more than 1 secret key in your keyring, you may want to\n# uncomment the following option and set your preferred keyid.\n\ndefault-key 28681CB1\n</code></pre>\n</li>\n<li>\n<p>设置Apache中央仓库</p>\n<ul>\n<li>Dubbo项目的父pom为apache pom</li>\n</ul>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.apache<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>apache<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>19<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n</code></pre>\n<ul>\n<li>\n<p>添加以下内容到.m2/settings.xml</p>\n<p>所有密码请使用<a href=\"http://maven.apache.org/guides/mini/guide-encryption.html\">maven-encryption-plugin</a>加密后再填入</p>\n</li>\n</ul>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">settings</span>&gt;</span>\n...\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">servers</span>&gt;</span>\n   <span class=\"hljs-comment\">&lt;!-- To publish a snapshot of some part of Maven --&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">server</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>apache.snapshots.https<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">username</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- YOUR APACHE LDAP USERNAME --&gt;</span> <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">username</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">password</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- YOUR APACHE LDAP PASSWORD (encrypted) --&gt;</span> <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">password</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">server</span>&gt;</span>\n   <span class=\"hljs-comment\">&lt;!-- To stage a release of some part of Maven --&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">server</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>apache.releases.https<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">username</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- YOUR APACHE LDAP USERNAME --&gt;</span> <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">username</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">password</span>&gt;</span> <span class=\"hljs-comment\">&lt;!-- YOUR APACHE LDAP PASSWORD (encrypted) --&gt;</span> <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">password</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">server</span>&gt;</span>\n  ...\n     <span class=\"hljs-comment\">&lt;!-- gpg passphrase used when generate key --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">server</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>gpg.passphrase<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">passphrase</span>&gt;</span><span class=\"hljs-comment\">&lt;!-- yourKeyPassword --&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">passphrase</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">server</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">servers</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">settings</span>&gt;</span>\n</code></pre>\n<p>​</p>\n</li>\n</ol>\n<h2>打包&amp;上传</h2>\n<ol>\n<li>\n<p>从主干分支拉取新分支作为发布分支，如现在要发布2.6.4版本，则从2.6.x拉出新分支2.6.4-release，此后2.6.4 Release Candidates涉及的修改及打标签等都在2.6.4-release分支进行，最终发布完成后合入主干分支。</p>\n</li>\n<li>\n<p>首先，在2.6.4-release分支验证maven组件打包、source源码打包、签名等是否都正常工作</p>\n<pre><code class=\"language-shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> mvn clean install -Papache-release</span>\n<span class=\"hljs-meta\">$</span><span class=\"bash\"> mvn deploy</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 将snapshot包推送到maven中央仓库，处于staging状态</span>\n</code></pre>\n</li>\n<li>\n<p>用maven-release-plugin发布</p>\n<ul>\n<li>先用dryRun验证是否ok</li>\n</ul>\n<pre><code class=\"language-shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> mvn release:prepare -Papache-release -Darguments=<span class=\"hljs-string\">\"-DskipTests\"</span> -DautoVersionSubmodules=<span class=\"hljs-literal\">true</span> -Dusername=YOUR GITHUB ID -DdryRun=<span class=\"hljs-literal\">true</span></span>\n</code></pre>\n<ul>\n<li>验证通过后，执行release:prepare</li>\n</ul>\n<pre><code class=\"language-shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> mvn release:clean</span>\n<span class=\"hljs-meta\">$</span><span class=\"bash\"> mvn release:prepare -Papache-release -Darguments=<span class=\"hljs-string\">\"-DskipTests\"</span> -DautoVersionSubmodules=<span class=\"hljs-literal\">true</span> -Dusername=YOUR GITHUB ID</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 执行完成后：1.生成source.zip包； 2.打出tag，并推送到github仓库； 3.分支版本自动升级为2.6.4-SNAPSHOT，并将修改推送到github仓库</span>\n</code></pre>\n<ul>\n<li>执行release:perform，做正式发布</li>\n</ul>\n<pre><code class=\"language-shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> mvn -Prelease release:perform -Darguments=<span class=\"hljs-string\">\"-DskipTests\"</span> -DautoVersionSubmodules=<span class=\"hljs-literal\">true</span> -Dusername=YOUR GITHUB ID</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 所有artifacts发布到配置的远程maven中央仓库，处于staging状态</span>\n</code></pre>\n</li>\n</ol>\n<h2>准备Apache发布</h2>\n<ol>\n<li>\n<p>准备svn本机环境（Apache使用svn托管项目的发布内容）</p>\n</li>\n<li>\n<p>将dubbo checkout到本地目录</p>\n<pre><code class=\"language-shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> svn checkout https://dist.apache.org/repos/dist/dev/incubator/dubbo</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 假定本地目录为 ~/apache/incubator/dubbo</span>\n</code></pre>\n</li>\n<li>\n<p>当前发布版本为2.6.4，新建目录</p>\n<pre><code class=\"language-shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> <span class=\"hljs-built_in\">cd</span> ~/apache/incubator/dubbo <span class=\"hljs-comment\"># dubbo svn根目录</span></span>\n<span class=\"hljs-meta\">$</span><span class=\"bash\"> mkdir 2.6.4</span>\n</code></pre>\n</li>\n<li>\n<p>添加public key到<a href=\"https://dist.apache.org/repos/dist/dev/incubator/dubbo/KEYS\">KEYS</a>文件。KEYS主要是让参与投票的人在本地导入，用来校验sign的正确性</p>\n</li>\n<li>\n<p>拷贝Dubbo根目录下的source.zip包到svn本地仓库dubbo/2.6.4</p>\n</li>\n<li>\n<p>生成sha512签名</p>\n<pre><code class=\"language-shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> shasum -a 512 dubbo-incubating-2.6.4-source-release.zip &gt;&gt; dubbo-incubating-2.6.4-source-release.zip.sha512</span>\n</code></pre>\n</li>\n<li>\n<p>如果有binary release要同时发布</p>\n<pre><code class=\"language-shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 到dubbo项目distribution的module下，执行：</span>\n<span class=\"hljs-meta\">$</span><span class=\"bash\"> mvn install</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> target目录下，拷贝bin-release.zip以及bin-release.zip.asc到svn本地仓库dubbo/2.6.4</span>\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 参考第6步，生成sha512签名</span>\n</code></pre>\n</li>\n<li>\n<p>提交到Apache svn</p>\n<pre><code class=\"language-shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> svn status</span>\n<span class=\"hljs-meta\">$</span><span class=\"bash\"> svn commit -m <span class=\"hljs-string\">'prepare for 2.6.4 RC1'</span></span>\n</code></pre>\n</li>\n</ol>\n<h2>验证Release Candidates</h2>\n<p>验证环节包含但不限于以下内容和形式：</p>\n<ol>\n<li>Check signatures and hashes are good</li>\n</ol>\n<pre><code class=\"language-sh\">sha512 dubbo-incubating-<span class=\"hljs-variable\">${release_version}</span>-bin-release.zip.sha512\nsha512 dubbo-incubating-<span class=\"hljs-variable\">${release_version}</span>-<span class=\"hljs-built_in\">source</span>-release.zip.sha512\n</code></pre>\n<ol start=\"2\">\n<li>Unzip dubbo-incubating-${release_version}-source-release.zip to the default directory and check the following:</li>\n</ol>\n<ul>\n<li>\n<p>Directory with 'incubating' in name\n<code>dubbo-incubating-${release_version}-bin-release</code></p>\n</li>\n<li>\n<p>DISCLAIMER exists</p>\n</li>\n<li>\n<p>LICENSE and NOTICE exists and contents are good</p>\n</li>\n<li>\n<p>All files and no binary files exist</p>\n</li>\n<li>\n<p>All files has standard ASF License header</p>\n</li>\n<li>\n<p>Can compile from source</p>\n</li>\n<li>\n<p>All unit tests can pass</p>\n<pre><code class=\"language-sh\">mvn clean <span class=\"hljs-built_in\">test</span> <span class=\"hljs-comment\"># This will run all unit tests</span>\n<span class=\"hljs-comment\"># you can also open rat and style plugin to check if every file meets requirements.</span>\nmvn clean install -Drat.skip=<span class=\"hljs-literal\">false</span> -Dcheckstyle.skip=<span class=\"hljs-literal\">false</span>\n</code></pre>\n</li>\n<li>\n<p>Release candidates match with corresponding tags, you can find tag link and hash in vote email.</p>\n</li>\n</ul>\n<h2>进入投票</h2>\n<p>投票分两个阶段：</p>\n<ol>\n<li>Dubbo社区投票，发起投票邮件到dev@dubbo.apache.org。在社区开发者Review，并统计到3个同意发版的binding票后，即可进入下一阶段的投票。</li>\n<li>Apache社区投票，发起投票邮件到general@apache.org。在Apache PMC Review，并统计到3个统一发版的binding票后，即可进行正式发布。</li>\n</ol>\n<p>邮件模板：</p>\n<pre><code class=\"language-tex\">Hello Dubbo Community,\n\nThis is a call for vote to release Apache Dubbo (Incubating) version 2.6.2.\n\nThe release candidates:\nhttps://dist.apache.org/repos/dist/dev/incubator/dubbo/2.6.2/\n\nGit tag for the release:\nhttps://github.com/apache/incubator-dubbo/tree/dubbo-2.6.2\n\nHash for the release tag:\nafab04c53edab38d52275d2a198ea1aff7a4f41e\n\nRelease Notes:\nhttps://github.com/apache/incubator-dubbo/releases/tag/untagged-4775c0a22c60fca55118\n\nThe artifacts have been signed with Key : 28681CB1, which can be found in the keys file:\nhttps://dist.apache.org/repos/dist/dev/incubator/dubbo/KEYS\n\nThe vote will be open for at least 72 hours or until necessary number of votes are reached.\n\nPlease vote accordingly:\n\n[ ] +1 approve \n[ ] +0 no opinion \n[ ] -1 disapprove with the reason\n\nThanks,\nThe Apache Dubbo (Incubating) Team\n</code></pre>\n<p>##正式发布</p>\n<ol>\n<li>提交https://dist.apache.org/repos/dist/dev/incubator/dubbo目录下的发布包到https://dist.apache.org/repos/dist/release/incubator/dubbo/，完成正式发布。</li>\n<li>发邮件到dev@dubbo.apache.org和general@apache.org，通知社区发布完成。</li>\n</ol>\n<h2>完成Maven Convenient Binary发布（可选）</h2>\n<p><strong><a href=\"http://apache.repository.org\">apache.repository.org</a> nexus仓库的权限已经申请，参见<a href=\"https://issues.apache.org/jira/browse/INFRA-16451\">jira</a>。</strong></p>\n<p>之前发布到maven仓库的atifacts都处于staging状态，用Apache <a href=\"http://xn--idapache-zm2p156p.repository.org\">id登录apache.repository.org</a>，发布即可。</p>\n"
    },
    {
      "filename": "dubbo-101.md",
      "__html": "<h1>第一个 Dubbo 应用</h1>\n<h2>Java RMI 简介</h2>\n<p>Java RMI （Remote Method Invocation）- 远程方法调用，能够让客户端像使用本地调用一样调用服务端 Java 虚拟机中的对象方法。RMI 是面向对象语言领域对 RPC （Remote Procedure Call）的完善，用户无需依靠 IDL 的帮助来完成分布式调用，而是通过依赖接口这种更简单自然的方式。</p>\n<h3>Java RMI 工作原理</h3>\n<p>一个典型的 RMI 调用如下图所示：</p>\n<ol>\n<li>服务端向 RMI 注册服务绑定自己的地址，</li>\n<li>客户端通过 RMI 注册服务获取目标地址，</li>\n<li>客户端调用本地的 Stub 对象上的方法，和调用本地对象上的方法一致，</li>\n<li>本地存根对象将调用信息打包，通过网络发送到服务端，</li>\n<li>服务端的 Skeleton 对象收到网络请求之后，将调用信息解包，</li>\n<li>然后找到真正的服务对象发起调用，并将返回结果打包通过网络发送回客户端。</li>\n</ol>\n<p><img src=\"../../img/blog/rmi-flow.png\" alt=\"RMI Flow\"></p>\n<p>(来源：<a href=\"https://www.cs.rutgers.edu/~pxk/417/notes/images/rpc-rmi_flow.png\">https://www.cs.rutgers.edu/~pxk/417/notes/images/rpc-rmi_flow.png</a>)</p>\n<h3>Java RMI 基本概念</h3>\n<p>Java RMI 是 Java 领域创建分布式应用的技术基石。后续的 EJB 技术，以及现代的分布式服务框架，其中的基本理念依旧是 Java RMI 的延续。在 RMI 调用中，有以下几个核心的概念：</p>\n<ol>\n<li>\n<p>通过<strong>接口</strong>进行远程调用</p>\n</li>\n<li>\n<p>通过客户端的 <strong>Stub 对象</strong>和服务端的 <strong>Skeleton 对象</strong>的帮助将远程调用伪装成本地调用</p>\n</li>\n<li>\n<p>通过 <strong>RMI 注册服务</strong>完成服务的注册和发现</p>\n</li>\n</ol>\n<p>对于第一点，客户端需要依赖接口，而服务端需要提供该接口的实现。</p>\n<p>对于第二点，在 J2SE 1.5 版本之前需要通过 rmic 预先编译好客户端的 Stub 对象和服务端的 Skeleton 对象。在之后的版本中，不再需要事先生成 Stub 和 Skeleton 对象。</p>\n<p>下面通过示例代码简单的展示 RMI 中的服务注册和发现</p>\n<h4>服务端的服务注册</h4>\n<pre><code class=\"language-java\">Hello obj = <span class=\"hljs-keyword\">new</span> HelloImpl(); <span class=\"hljs-comment\">// #1</span>\nHello stub = (Hello) UnicastRemoteObject.exportObject(obj, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// #2</span>\nRegistry registry = LocateRegistry.createRegistry(<span class=\"hljs-number\">1099</span>); <span class=\"hljs-comment\">// #3</span>\nregistry.rebind(<span class=\"hljs-string\">\"Hello\"</span>, stub); <span class=\"hljs-comment\">// #4</span>\n</code></pre>\n<p>说明：</p>\n<ol>\n<li>初始化服务对象实例，</li>\n<li>通过 <em>UnicastRemoteObject.exportObject</em> 生成可以与服务端通讯的 Stub 对象，</li>\n<li>创建一个本地的 RMI 注册服务，监听端口为 1099。该注册服务运行在服务端，也可以单独启动一个注册服务的进程，</li>\n<li>将 Stub 对象绑定到注册服务上，这样，客户端可以通过 <em>Hello</em> 这个名字查找到该远程对象。</li>\n</ol>\n<h4>客户端的服务发现</h4>\n<pre><code class=\"language-java\">Registry registry = LocateRegistry.getRegistry(); <span class=\"hljs-comment\">// #1</span>\nHello stub = (Hello) registry.lookup(<span class=\"hljs-string\">\"Hello\"</span>); <span class=\"hljs-comment\">// #2</span>\nString response = stub.sayHello(); <span class=\"hljs-comment\">// #3</span>\n</code></pre>\n<p>说明：</p>\n<ol>\n<li>获取注册服务实例，在本例中，由于没有传入任何参数，假定要获取的注册服务实例部署在本机，并监听在 1099 端口上，</li>\n<li>从注册服务中查找服务名为 <em>Hello</em> 的远程对象，</li>\n<li>通过获取的 Stub 对象发起一次 RMI 调用并获得结果。</li>\n</ol>\n<p>理解 RMI 的工作原理和基本概念，对掌握现代分布式服务框架很有帮助，建议进一步的阅读 RMI 官方教材 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>。</p>\n<h2>Dubbo 基本概念</h2>\n<p>现代的分布式服务框架的基本概念与 RMI 是类似的，同样是使用 Java 的 Interface 作为服务契约，通过注册中心来完成服务的注册和发现，远程通讯的细节也是通过代理类来屏蔽。具体来说，Dubbo 在工作时有以下四个角色参与：</p>\n<ol>\n<li>服务提供者 - 启动时在指定端口上暴露服务，并将服务地址和端口注册到注册中心上</li>\n<li>服务消费者 - 启动时向注册中心订阅自己感兴趣的服务，以便获得服务提供方的地址列表</li>\n<li>注册中心 - 负责服务的注册和发现，负责保存服务提供方上报的地址信息，并向服务消费方推送</li>\n<li>监控中心 - 负责收集服务提供方和消费方的运行状态，比如服务调用次数、延迟等，用于监控</li>\n<li>运行容器 - 负责服务提供方的初始化、加载以及运行的生命周期管理</li>\n</ol>\n<p><img src=\"../../img/blog/dubbo-architecture.png\" alt=\"dubbo-architecture\"></p>\n<p><strong>部署阶段</strong></p>\n<ul>\n<li>服务提供者在指定端口暴露服务，并向注册中心注册服务信息。</li>\n<li>服务消费者向注册中心发起服务地址列表的订阅。</li>\n</ul>\n<p><strong>运行阶段</strong></p>\n<ul>\n<li>注册中心向服务消费者推送地址列表信息。</li>\n<li>服务消费者收到地址列表后，从其中选取一个向目标服务发起调用。</li>\n<li>调用过程服务消费者和服务提供者的运行状态上报给监控中心。</li>\n</ul>\n<h2>基于 API 的 Dubbo 应用</h2>\n<p>Dubbo 的应用一般都是通过 Spring 来组装的。为了快速获得一个可以工作的 Dubbo 应用，这里的示例摒弃了复杂的配置，而改用面向 Dubbo API 的方式来构建服务提供者和消费者，另外，注册中心和监控中心在本示例中也不需要安装和配置。</p>\n<p>在生产环境，Dubbo 的服务需要一个分布式的服务注册中心与之配合，比如，ZooKeeper。为了方便开发，Dubbo 提供了直连<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>以及组播<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>两种方式，从而避免额外搭建注册中心的工作。在本例中，将使用组播的方式来完成服务的注册和发现。</p>\n<h3>定义服务契约</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">GreetingsService</span> </span>{\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">sayHi</span><span class=\"hljs-params\">(String name)</span></span>; <span class=\"hljs-comment\">// #1</span>\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ol>\n<li>定义了一个简单的服务契约 <em>GreetingsService</em>，其中只有一个方法 <em>sayHi</em> 可供调用，入参是 <em>String</em> 类型，返回值也是 <em>String</em> 类型。</li>\n</ol>\n<h3>提供契约的实现</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GreetingsServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">GreetingsService</span> </span>{ <span class=\"hljs-comment\">// #1</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHi</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hi, \"</span> + name; <span class=\"hljs-comment\">// #2</span>\n    }\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ol>\n<li>服务提供者需要实现服务契约 <em>GreetingsService</em> 接口。</li>\n<li>该实现简单的返回一个欢迎信息，如果入参是 <em>dubbo</em>，则返回 <em>hi, dubbo</em>。</li>\n</ol>\n<h3>实现 Dubbo 服务提供方</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Application</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        ServiceConfig&lt;GreetingsService&gt; service = <span class=\"hljs-keyword\">new</span> ServiceConfig&lt;&gt;(); <span class=\"hljs-comment\">// #1</span>\n        service.setApplication(<span class=\"hljs-keyword\">new</span> ApplicationConfig(<span class=\"hljs-string\">\"first-dubbo-provider\"</span>)); <span class=\"hljs-comment\">// #2</span>\n        service.setRegistry(<span class=\"hljs-keyword\">new</span> RegistryConfig(<span class=\"hljs-string\">\"multicast://224.5.6.7:1234\"</span>)); <span class=\"hljs-comment\">// #3</span>\n        service.setInterface(GreetingsService.class); <span class=\"hljs-comment\">// #4</span>\n        service.setRef(<span class=\"hljs-keyword\">new</span> GreetingsServiceImpl()); <span class=\"hljs-comment\">// #5</span>\n        service.export(); <span class=\"hljs-comment\">// #6</span>\n        System.in.read(); <span class=\"hljs-comment\">// #7</span>\n    }\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ol>\n<li>创建一个 <em>ServiceConfig</em> 的实例，泛型参数信息是服务接口类型，即 <em>GreetingsService</em>。</li>\n<li>生成一个 <em>AplicatonConfig</em> 的实例，并将其装配进 <em>ServiceConfig</em>。</li>\n<li>生成一个 <em>RegistryConfig</em> 实例，并将其装配进 <em>ServiceConfig</em>，这里使用的是组播方式，参数是 <code>multicast://224.5.6.7:1234</code>。合法的组播地址范围为：<em>224.0.0.0 - 239.255.255.255</em></li>\n<li>将服务契约 <em>GreetingsService</em> 装配进 <em>ServiceConfig</em>。</li>\n<li>将服务提供者提供的实现 <em>GreetingsServiceImpl</em> 的实例装配进 <em>ServiceConfig</em>。</li>\n<li><em>ServiceConfig</em> 已经具备足够的信息，开始对外暴露服务，默认监听端口是 <em>20880</em>。</li>\n<li>为了防止服务端退出，按任意键或者 <em>ctrl-c</em> 退出。</li>\n</ol>\n<h3>实现 Dubbo 服务调用方</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Application</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        ReferenceConfig&lt;GreetingsService&gt; reference = <span class=\"hljs-keyword\">new</span> ReferenceConfig&lt;&gt;(); <span class=\"hljs-comment\">// #1</span>\n        reference.setApplication(<span class=\"hljs-keyword\">new</span> ApplicationConfig(<span class=\"hljs-string\">\"first-dubbo-client\"</span>)); <span class=\"hljs-comment\">// #2</span>\n        reference.setRegistry(<span class=\"hljs-keyword\">new</span> RegistryConfig(<span class=\"hljs-string\">\"multicast://224.5.6.7:1234\"</span>)); <span class=\"hljs-comment\">// #3</span>\n        reference.setInterface(GreetingsService.class); <span class=\"hljs-comment\">// #4</span>\n        GreetingsService greetingsService = reference.get(); <span class=\"hljs-comment\">// #5</span>\n        String message = greetingsService.sayHi(<span class=\"hljs-string\">\"dubbo\"</span>); <span class=\"hljs-comment\">// #6</span>\n        System.out.println(message); <span class=\"hljs-comment\">// #7</span>\n    }\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ol>\n<li>创建一个 <em>ReferenceConfig</em> 的实例，同样，泛型参数信息是服务接口类型，即 <em>GreetingService</em>。</li>\n<li>生成一个 <em>AplicatonConfig</em> 的实例，并将其装配进 <em>ReferenceConfig</em>。</li>\n<li>生成一个 <em>RegistryConfig</em> 实例，并将其装配进 <em>ReferenceConfig</em>，注意这里的组播地址信息需要与服务提供方的相同。</li>\n<li>将服务契约 <em>GreetingsService</em> 装配进 <em>ReferenceConfig</em>。</li>\n<li>从 <em>ReferenceConfig</em> 中获取到 <em>GreetingService</em> 的代理。</li>\n<li>通过 <em>GreetingService</em> 的代理发起远程调用，传入的参数为 <em>dubbo</em>。</li>\n<li>打印返回结果 <em>hi, dubbo</em>。</li>\n</ol>\n<h3>运行</h3>\n<p>完整的示例在 <a href=\"https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-api\">https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-api</a> 上提供。在完整的示例中，由于配置了 <em>exec-maven-plugin</em>，可以很方便的在命令行下通过 maven 的方式执行。当然，您也可以在 IDE 里直接执行，但是需要注意的是，由于使用了组播的方式来发现服务，运行时需要指定 <em>-Djava.net.preferIPv4Stack=true</em>。</p>\n<h4>构建示例</h4>\n<p>通过以下的命令来同步示例代码并完成构建：</p>\n<ol>\n<li>同步代码：git clone <a href=\"https://github.com/dubbo/dubbo-samples.git\">https://github.com/dubbo/dubbo-samples.git</a></li>\n<li>构建：mvn clean package</li>\n</ol>\n<pre><code class=\"language-bash\">$ git <span class=\"hljs-built_in\">clone</span> https://github.com/dubbo/dubbo-samples.git\n$ <span class=\"hljs-built_in\">cd</span> dubbo-samples/dubbo-samples-api/\n$ mvn clean package\nINFO] Scanning <span class=\"hljs-keyword\">for</span> projects...\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building dubbo-samples-api 1.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ dubbo-samples-api ---\n...\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 2.182 s\n[INFO] Finished at: 2018-05-28T14:56:08+08:00\n[INFO] Final Memory: 20M/353M\n[INFO] ------------------------------------------------------------------------\n</code></pre>\n<p>当看到 <em>BUILD SUCCESS</em> 的时候表明构建完成，下面就可以开始进入运行阶段了。</p>\n<h4>运行服务端</h4>\n<p>通过运行以下的 maven 命令来启动服务提供者：</p>\n<pre><code class=\"language-bash\">$ mvn -Djava.net.preferIPv4Stack=<span class=\"hljs-literal\">true</span> -Dexec.mainClass=com.alibaba.dubbo.samples.server.Application <span class=\"hljs-built_in\">exec</span>:java\n[INFO] Scanning <span class=\"hljs-keyword\">for</span> projects...\n[INFO]                                                                         \n[INFO] ------------------------------------------------------------------------\n[INFO] Building dubbo-samples-api 1.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO] \n[INFO] --- <span class=\"hljs-built_in\">exec</span>-maven-plugin:1.6.0:java (default-cli) @ dubbo-samples-api ---\nlog4j:WARN No appenders could be found <span class=\"hljs-keyword\">for</span> logger (com.alibaba.dubbo.common.logger.LoggerFactory).\nlog4j:WARN Please initialize the log4j system properly.\nlog4j:WARN See http://logging.apache.org/log4j/1.2/faq.html<span class=\"hljs-comment\">#noconfig for more info.</span>\nfirst-dubbo-provider is running.\n</code></pre>\n<p>当 <em>first-dubbo-provider is running.</em> 出现时，代表服务提供者已经启动就绪，等待客户端的调用。</p>\n<h4>运行客户端</h4>\n<p>通过运行以下的 maven 命令来调用服务：</p>\n<pre><code class=\"language-bash\">$ mvn -Djava.net.preferIPv4Stack=<span class=\"hljs-literal\">true</span> -Dexec.mainClass=com.alibaba.dubbo.samples.client.Application <span class=\"hljs-built_in\">exec</span>:java\n[INFO] Scanning <span class=\"hljs-keyword\">for</span> projects...\n[INFO]                                                                         \n[INFO] ------------------------------------------------------------------------\n[INFO] Building dubbo-samples-api 1.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO] \n[INFO] --- <span class=\"hljs-built_in\">exec</span>-maven-plugin:1.6.0:java (default-cli) @ dubbo-samples-api ---\nlog4j:WARN No appenders could be found <span class=\"hljs-keyword\">for</span> logger (com.alibaba.dubbo.common.logger.LoggerFactory).\nlog4j:WARN Please initialize the log4j system properly.\nlog4j:WARN See http://logging.apache.org/log4j/1.2/faq.html<span class=\"hljs-comment\">#noconfig for more info.</span>\nhi, dubbo\n</code></pre>\n<p>可以看到， <em>hi, dubbo</em> 是从服务提供者返回的执行结果。</p>\n<h2>快速生成 Dubbo 应用</h2>\n<p>Dubbo 还提供了一个公共服务快速搭建基于 Spring Boot 的 Dubbo 应用。访问 <a href=\"http://start.dubbo.io\">http://start.dubbo.io</a> 并按照下图所示来生成示例工程：</p>\n<p><img src=\"../../img/blog/dubbo-initializr.png\" alt=\"dubbo initializr\"></p>\n<p><strong>说明</strong>：</p>\n<ol>\n<li>在 <em>Group</em> 中提供 maven groupId，默认值是 <em>com.example</em>。</li>\n<li>在 <em>Artifact</em> 中提供 maven artifactId，默认值是 <em>demo</em>。</li>\n<li>在 <em>DubboServiceName</em> 中提供服务名，默认值是 <em>com.example.HelloService</em>。</li>\n<li>在 <em>DubboServiceVersion</em> 中提供服务的版本，默认值是 <em>1.0.0</em>。</li>\n<li>在 <em>Client/Server</em> 中选取本次构建的工程是服务提供者 (Server) 还是服务消费者 (Client)，默认值是 <em>server</em>。</li>\n<li>使用 <em>embeddedZookeeper</em> 作为服务注册发现，默认为勾选。</li>\n<li>是否激活 qos 端口，默认为不勾选，如果勾选可以通过 <em>22222</em> 端口访问。</li>\n<li>点击 <em>Generate Project</em> 即可下载生成好的工程。</li>\n</ol>\n<p>在本例中展示的是服务提供者，同样的，通过在生成界面选取 <em>client</em> 来生成对应的服务消费者。</p>\n<h3>运行</h3>\n<p>用 IDE 打开生成好的工程，可以发现应用是一个典型的 Spring Boot 应用。程序的入口如下所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoApplication</span> </span>{\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n\t\t<span class=\"hljs-keyword\">new</span> EmbeddedZooKeeper(<span class=\"hljs-number\">2181</span>, <span class=\"hljs-keyword\">false</span>).start();  <span class=\"hljs-comment\">// #1</span>\n\t\tSpringApplication.run(DemoApplication.class, args); <span class=\"hljs-comment\">// #2</span>\n\t}\n}\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ol>\n<li>在 <em>2181</em> 端口上启动嵌入式 <em>ZooKeeper</em>。</li>\n<li>启动 <em>Spring Boot</em> 上下文。</li>\n</ol>\n<p>可以直接在 IDE 中运行，输出结果如下：</p>\n<pre><code class=\"language-bash\">2018-05-28 16:59:38.072  INFO 59943 --- [           main] a.b.d.c.e.WelcomeLogoApplicationListener : \n\n  ████████▄  ███    █▄  ▀█████████▄  ▀█████████▄   ▄██████▄  \n  ███   ▀███ ███    ███   ███    ███   ███    ███ ███    ███ \n  ███    ███ ███    ███   ███    ███   ███    ███ ███    ███ \n  ███    ███ ███    ███  ▄███▄▄▄██▀   ▄███▄▄▄██▀  ███    ███ \n  ███    ███ ███    ███ ▀▀███▀▀▀██▄  ▀▀███▀▀▀██▄  ███    ███ \n  ███    ███ ███    ███   ███    ██▄   ███    ██▄ ███    ███ \n  ███   ▄███ ███    ███   ███    ███   ███    ███ ███    ███ \n  ████████▀  ████████▀  ▄█████████▀  ▄█████████▀   ▀██████▀  \n                                                             \n\n :: Dubbo Spring Boot (v0.1.0) : https://github.com/dubbo/dubbo-spring-boot-project\n :: Dubbo (v2.0.1) : https://github.com/alibaba/dubbo\n :: Google group : http://groups.google.com/group/dubbo\n\n2018-05-28 16:59:38.079  INFO 59943 --- [           main] e.OverrideDubboConfigApplicationListener : Dubbo Config was overridden by externalized configuration {dubbo.application.name=dubbo-demo-server, dubbo.application.qosAcceptForeignIp=<span class=\"hljs-literal\">false</span>, dubbo.application.qosEnable=<span class=\"hljs-literal\">true</span>, dubbo.application.qosPort=22222, dubbo.registry.address=zookeeper://localhost:2181?client=curator, dubbo.registry.id=my-registry, dubbo.scan.basePackages=com.example} <span class=\"hljs-comment\">#1</span>\n\n...\n\n2018-05-28 16:59:39.624  INFO 59943 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication <span class=\"hljs-keyword\">in</span> 1.746 seconds (JVM running <span class=\"hljs-keyword\">for</span> 2.963)\n</code></pre>\n<p><strong>说明</strong>：</p>\n<ol>\n<li>输出中打印的以 <em>dubbo.</em> 开头的配置信息，定义在 <em>main/resources/application.properties</em> 中。</li>\n</ol>\n<h3>通过 Telnet 管理服务</h3>\n<p>生成工程的时候如果选择了激活 <em>qos</em> 的话，就可以通过 <em>telnet</em> 或者 <em>nc</em> 来管理服务、查看服务状态。</p>\n<pre><code class=\"language-bash\">$ telnet localhost 22222\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is <span class=\"hljs-string\">'^]'</span>.\n  ████████▄  ███    █▄  ▀█████████▄  ▀█████████▄   ▄██████▄  \n  ███   ▀███ ███    ███   ███    ███   ███    ███ ███    ███ \n  ███    ███ ███    ███   ███    ███   ███    ███ ███    ███ \n  ███    ███ ███    ███  ▄███▄▄▄██▀   ▄███▄▄▄██▀  ███    ███ \n  ███    ███ ███    ███ ▀▀███▀▀▀██▄  ▀▀███▀▀▀██▄  ███    ███ \n  ███    ███ ███    ███   ███    ██▄   ███    ██▄ ███    ███ \n  ███   ▄███ ███    ███   ███    ███   ███    ███ ███    ███ \n  ████████▀  ████████▀  ▄█████████▀  ▄█████████▀   ▀██████▀  \n                                                             \n\ndubbo&gt;\ndubbo&gt;ls\nAs Provider side:\n+------------------------------+---+\n|     Provider Service Name    |PUB|\n+------------------------------+---+\n|com.example.HelloService:1.0.0| Y |\n+------------------------------+---+\nAs Consumer side:\n+---------------------+---+\n|Consumer Service Name|NUM|\n+---------------------+---+\n</code></pre>\n<p>目前 <em>qos</em> 支持以下几个命令，更详细的信息请查阅官方文档<sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup>：</p>\n<ul>\n<li><em>ls</em>：列出消费者、提供者信息</li>\n<li><em>online</em>：上线服务</li>\n<li><em>offline</em>：下线服务</li>\n<li><em>help</em>：联机帮助</li>\n</ul>\n<h2>总结</h2>\n<p>在本文中，从 RMI 开始，介绍了 Java 领域分布式调用的基本概念，也就是基于接口编程、通过代理将远程调用伪装成本地、通过注册中心完成服务的注册和发现。</p>\n<p>然后为了简单起见，使用简单的组播注册方式和直接面向 Dubbo API 编程的方式介绍了如何开发一个 Dubbo 的完整应用。深入的了解 <em>ServiceConfig</em> 和 <em>ReferenceConfig</em> 的用法，对于进一步的使用 Spring XML 配置、乃至 Spring Boot 的编程方式有这很大的帮助。</p>\n<p>最后，简单的介绍了如何通过 Dubbo 团队提供的公共服务 <a href=\"http://start.dubbo.io\">start.dubbo.io</a> 快速搭建基于 Spring Boot 的 Dubbo 应用，并通过 <em>qos</em> 来做 Dubbo 服务的简单运维。</p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://docs.oracle.com/javase/6/docs/technotes/guides/rmi/hello/hello-world.html\">Getting Started Using JavaTM RMI</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p><a href=\"http://dubbo.apache.org/books/dubbo-user-book/demos/explicit-target.html\">直连提供者</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p><a href=\"http://dubbo.apache.org/books/dubbo-user-book/references/registry/multicast.html\">Multicast 注册中心</a> <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p><a href=\"http://dubbo.apache.org/books/dubbo-user-book/references/qos.html\">在线运维命令</a> <a href=\"#fnref4\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n"
    },
    {
      "filename": "dubbo-annotation.md",
      "__html": "<h1>在 Dubbo 中使用注解</h1>\n<p>随着微服务架构的广泛地推广和实施。在 Java 生态系统中，以 Spring Boot 和 Spring Cloud 为代表的微服务框架，引入了全新的编程模型，包括：</p>\n<ul>\n<li>注解驱动（Annotation-Driven）</li>\n<li>外部化配置（External Configuration）</li>\n<li>以及自动装配（Auto-Configure）</li>\n</ul>\n<p>新的编程模型无需 XML 配置、简化部署、提升开发效率。为了更好地实践微服务架构，Dubbo 从 <code>2.5.8</code> 版本开始， 分别针对了上述的三个场景，提供了更完善的支持。本文不讨论传统的 XML 配置方式，而是侧重介绍注解这种方式。外部配置、自动装配两种自动装配会在另外的文章中专门介绍。</p>\n<h2>注解介绍</h2>\n<h3>@EnableDubbo</h3>\n<p><code>@EnableDubbo</code> 注解是 <code>@EnableDubboConfig</code> 和 <code>@DubboComponentScan</code>两者组合的便捷表达方式。与注解驱动相关的是 <code>@DubboComponentScan</code>。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> org.apache.dubbo.config.spring.context.annotation;\n\n<span class=\"hljs-meta\">@EnableDubboConfig</span>\n<span class=\"hljs-meta\">@DubboComponentScan</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@interface</span> EnableDubbo {\n    <span class=\"hljs-comment\">/**\n     * Base packages to scan for annotated <span class=\"hljs-doctag\">@Service</span> classes.\n     * &lt;p&gt;\n     * Use {<span class=\"hljs-doctag\">@link</span> #scanBasePackageClasses()} for a type-safe alternative to String-based\n     * package names.\n     *\n     * <span class=\"hljs-doctag\">@return</span> the base packages to scan\n     * <span class=\"hljs-doctag\">@see</span> DubboComponentScan#basePackages()\n     */</span>\n    <span class=\"hljs-meta\">@AliasFor</span>(annotation = DubboComponentScan.class, attribute = <span class=\"hljs-string\">\"basePackages\"</span>)\n    String[] scanBasePackages() <span class=\"hljs-keyword\">default</span> {};\n\n    <span class=\"hljs-comment\">/**\n     * Type-safe alternative to {<span class=\"hljs-doctag\">@link</span> #scanBasePackages()} for specifying the packages to\n     * scan for annotated <span class=\"hljs-doctag\">@Service</span> classes. The package of each class specified will be\n     * scanned.\n     *\n     * <span class=\"hljs-doctag\">@return</span> classes from the base packages to scan\n     * <span class=\"hljs-doctag\">@see</span> DubboComponentScan#basePackageClasses\n     */</span>\n    <span class=\"hljs-meta\">@AliasFor</span>(annotation = DubboComponentScan.class, attribute = <span class=\"hljs-string\">\"basePackageClasses\"</span>)\n    Class&lt;?&gt;[] scanBasePackageClasses() <span class=\"hljs-keyword\">default</span> {};    \n}\n</code></pre>\n<p>通过 <code>@EnableDubbo</code> 可以在指定的包名下（通过 <code>scanBasePackages</code>），或者指定的类中（通过 <code>scanBasePackageClasses</code>）扫描 Dubbo 的服务提供者（以 <code>@Service</code> 标注）以及 Dubbo 的服务消费者（以 <code>Reference</code> 标注）。</p>\n<p>扫描到 Dubbo 的服务提供方和消费者之后，对其做相应的组装并初始化，并最终完成服务暴露或者引用的工作。</p>\n<p>当然，如果不使用外部化配置（External Configuration）的话，也可以直接使用 <code>@DubboComponentScan</code>。</p>\n<h3>@Service</h3>\n<p><code>@Service</code> 用来配置 Dubbo 的服务提供方，比如：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Service</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AnnotatedGreetingService</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">GreetingService</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello, \"</span> + name;\n    }\n}\n</code></pre>\n<p>通过 <code>@Service</code> 上提供的属性，可以进一步的定制化 Dubbo 的服务提供方：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> org.apache.dubbo.config.annotation;\n\n<span class=\"hljs-meta\">@Documented</span>\n<span class=\"hljs-meta\">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class=\"hljs-meta\">@Target</span>({ElementType.TYPE}) <span class=\"hljs-comment\">// #1</span>\n<span class=\"hljs-meta\">@Inherited</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@interface</span> Service {\n    Class&lt;?&gt; interfaceClass() <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span>.class; <span class=\"hljs-comment\">// #2</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">interfaceName</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #3</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">version</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #4</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">group</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #5</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">export</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">true</span></span>; <span class=\"hljs-comment\">// #6</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">register</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">true</span></span>; <span class=\"hljs-comment\">// #7</span>\n    \n    <span class=\"hljs-function\">String <span class=\"hljs-title\">application</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #8</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">module</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #9</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">provider</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #10</span>\n    String[] protocol() <span class=\"hljs-keyword\">default</span> {}; <span class=\"hljs-comment\">// #11</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">monitor</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #12</span>\n    String[] registry() <span class=\"hljs-keyword\">default</span> {}; <span class=\"hljs-comment\">// #13</span>\n}\n</code></pre>\n<p>其中比较重要的有：</p>\n<ol>\n<li>@Service 只能定义在一个类上，表示一个服务的具体实现</li>\n<li>interfaceClass：指定服务提供方实现的 interface 的类</li>\n<li>interfaceName：指定服务提供方实现的 interface 的类名</li>\n<li>version：指定服务的版本号</li>\n<li>group：指定服务的分组</li>\n<li>export：是否暴露服务</li>\n<li>registry：是否向注册中心注册服务</li>\n<li>application：应用配置</li>\n<li>module：模块配置</li>\n<li>provider：服务提供方配置</li>\n<li>protocol：协议配置</li>\n<li>monitor：监控中心配置</li>\n<li>registry：注册中心配置</li>\n</ol>\n<p>另外，需要注意的是，application、module、provider、protocol、monitor、registry（从 8 到 13）需要提供的是对应的 spring bean 的名字，而这些 bean 的组装要么通过传统的 XML 配置方式完成，要么通过现代的 Java Config 来完成。在本文中，将会展示 Java Config 的使用方式。</p>\n<h3>@Reference</h3>\n<p><code>@Reference</code> 用来配置 Dubbo 的服务消费方，比如：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GreetingServiceConsumer</span> </span>{\n    <span class=\"hljs-meta\">@Reference</span>\n    <span class=\"hljs-keyword\">private</span> GreetingService greetingService;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">doSayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> greetingService.sayHello(name);\n    }\n}\n</code></pre>\n<p>通过 <code>@Reference</code> 上提供的属性，可以进一步的定制化 Dubbo 的服务消费方：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> org.apache.dubbo.config.annotation;\n\n<span class=\"hljs-meta\">@Documented</span>\n<span class=\"hljs-meta\">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class=\"hljs-meta\">@Target</span>({ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE}) <span class=\"hljs-comment\">// #1</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@interface</span> Reference {\n    Class&lt;?&gt; interfaceClass() <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span>.class; <span class=\"hljs-comment\">// #2</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">interfaceName</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #3</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">version</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #4</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">group</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #5</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">url</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #6</span>\n    \n    <span class=\"hljs-function\">String <span class=\"hljs-title\">application</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #7</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">module</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #8</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">consumer</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #9</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">protocol</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #10</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">monitor</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #11</span>\n    String[] registry() <span class=\"hljs-keyword\">default</span> {}; <span class=\"hljs-comment\">// #12</span>\n}\n</code></pre>\n<p>其中比较重要的有：</p>\n<ol>\n<li>@Reference 可以定义在类中的一个字段上，也可以定义在一个方法上，甚至可以用来修饰另一个 annotation，表示一个服务的引用。通常 @Reference 定义在一个字段上</li>\n<li>interfaceClass：指定服务的 interface 的类</li>\n<li>interfaceName：指定服务的 interface 的类名</li>\n<li>version：指定服务的版本号</li>\n<li>group：指定服务的分组</li>\n<li>url：通过指定服务提供方的 URL 地址直接绕过注册中心发起调用</li>\n<li>application：应用配置</li>\n<li>module：模块配置</li>\n<li>consumer：服务消费方配置</li>\n<li>protocol：协议配置</li>\n<li>monitor：监控中心配置</li>\n<li>registry：注册中心配置</li>\n</ol>\n<p>另外，需要注意的是，application、module、consumer、protocol、monitor、registry（从 7 到 12）需要提供的是对应的 spring bean 的名字，而这些 bean 的组装要么通过传统的 XML 配置方式完成，要么通过现代的 Java Config 来完成。在本文中，将会展示 Java Config 的使用方式。</p>\n<h2>示例实战</h2>\n<p>了解了 <code>@EnableDubbo</code>， <code>@Service</code>，<code>@Reference</code> 的作用，下面以一个实际的例子来展示如何使用 annotation 来开发 Dubbo 应用。以下的代码可以在 <a href=\"https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-annotation\">https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-annotation</a> 中找到。</p>\n<h3>1. 接口定义</h3>\n<p>定义一个简单的 <code>GreetingService</code> 接口，里面只有一个简单的方法 <code>sayHello</code> 向调用者问好。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">GreetingService</span> </span>{\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span></span>;\n}\n</code></pre>\n<h3>2. 服务端：服务实现</h3>\n<p>实现 <code>GreetingService</code> 接口，并通过 <code>@Service</code> 来标注其为 Dubbo 的一个服务。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Service</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AnnotatedGreetingService</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">GreetingService</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello, \"</span> + name;\n    }\n}\n</code></pre>\n<h3>3. 服务端：组装服务提供方</h3>\n<p>通过 Spring 中 Java Config 的技术（<code>@Configuration</code>）和 annotation 扫描（<code>@EnableDubbo</code>）来发现、组装、并向外提供 Dubbo 的服务。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@EnableDubbo</span>(scanBasePackages = <span class=\"hljs-string\">\"com.alibaba.dubbo.samples.impl\"</span>)\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProviderConfiguration</span> </span>{\n    <span class=\"hljs-meta\">@Bean</span> <span class=\"hljs-comment\">// #1</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ProviderConfig <span class=\"hljs-title\">providerConfig</span><span class=\"hljs-params\">()</span> </span>{\n        ProviderConfig providerConfig = <span class=\"hljs-keyword\">new</span> ProviderConfig();\n        providerConfig.setTimeout(<span class=\"hljs-number\">1000</span>);\n        <span class=\"hljs-keyword\">return</span> providerConfig;\n    }\n\n    <span class=\"hljs-meta\">@Bean</span> <span class=\"hljs-comment\">// #2</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ApplicationConfig <span class=\"hljs-title\">applicationConfig</span><span class=\"hljs-params\">()</span> </span>{\n        ApplicationConfig applicationConfig = <span class=\"hljs-keyword\">new</span> ApplicationConfig();\n        applicationConfig.setName(<span class=\"hljs-string\">\"dubbo-annotation-provider\"</span>);\n        <span class=\"hljs-keyword\">return</span> applicationConfig;\n    }\n\n    <span class=\"hljs-meta\">@Bean</span> <span class=\"hljs-comment\">// #3</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> RegistryConfig <span class=\"hljs-title\">registryConfig</span><span class=\"hljs-params\">()</span> </span>{\n        RegistryConfig registryConfig = <span class=\"hljs-keyword\">new</span> RegistryConfig();\n        registryConfig.setProtocol(<span class=\"hljs-string\">\"zookeeper\"</span>);\n        registryConfig.setAddress(<span class=\"hljs-string\">\"localhost\"</span>);\n        registryConfig.setPort(<span class=\"hljs-number\">2181</span>);\n        <span class=\"hljs-keyword\">return</span> registryConfig;\n    }\n\n    <span class=\"hljs-meta\">@Bean</span> <span class=\"hljs-comment\">// #4</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ProtocolConfig <span class=\"hljs-title\">protocolConfig</span><span class=\"hljs-params\">()</span> </span>{\n        ProtocolConfig protocolConfig = <span class=\"hljs-keyword\">new</span> ProtocolConfig();\n        protocolConfig.setName(<span class=\"hljs-string\">\"dubbo\"</span>);\n        protocolConfig.setPort(<span class=\"hljs-number\">20880</span>);\n        <span class=\"hljs-keyword\">return</span> protocolConfig;\n    }\n}\n</code></pre>\n<p>说明：</p>\n<ul>\n<li>\n<p>通过 <code>@EnableDubbo</code> 指定在 <code>com.alibaba.dubbo.samples.impl</code> 下扫描所有标注有 <code>@Service</code> 的类</p>\n</li>\n<li>\n<p>通过 <code>@Configuration</code> 将 ProviderConfiguration 中所有的 <code>@Bean</code> 通过 Java Config 的方式组装出来并注入给 Dubbo 服务，也就是标注有 <code>@Service</code> 的类。这其中就包括了：</p>\n<ol>\n<li>ProviderConfig：服务提供方配置</li>\n<li>ApplicationConfig：应用配置</li>\n<li>RegistryConfig：注册中心配置</li>\n<li>ProtocolConfig：协议配置</li>\n</ol>\n</li>\n</ul>\n<h3>4. 服务端：启动服务</h3>\n<p>在 <code>main</code> 方法中通过启动一个 Spring Context 来对外提供 Dubbo 服务。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProviderBootstrap</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        <span class=\"hljs-keyword\">new</span> EmbeddedZooKeeper(<span class=\"hljs-number\">2181</span>, <span class=\"hljs-keyword\">false</span>).start(); <span class=\"hljs-comment\">// #1</span>\n        AnnotationConfigApplicationContext context = <span class=\"hljs-keyword\">new</span> AnnotationConfigApplicationContext(ProviderConfiguration.class); <span class=\"hljs-comment\">// #2</span>\n        context.start(); <span class=\"hljs-comment\">// #3</span>\n        System.in.read(); <span class=\"hljs-comment\">// #4</span>\n    }\n}\n</code></pre>\n<p>说明：</p>\n<ol>\n<li>启动一个嵌入式的 zookeeper 在 2181 端口上提供注册中心的服务</li>\n<li>初始化一个 <code>AnnotationConfigApplicationContext</code> 的示例，并将 <code>ProviderConfiguration</code> 传入以完成 Dubbo 服务的自动发现和装配</li>\n<li>启动 Spring Context，开始提供对外的 Dubbo 服务</li>\n<li>因为是服务端，需要通过阻塞主线程来防止进程退出</li>\n</ol>\n<p>启动服务端的 <code>main</code> 方法，将会看到下面的输出，代表服务端启动成功，并在注册中心（ZookeeperRegistry）上注册了 <code>GreetingService</code> 这个服务：</p>\n<pre><code class=\"language-sh\">[01/08/18 02:12:51:051 CST] main  INFO transport.AbstractServer:  [DUBBO] Start NettyServer <span class=\"hljs-built_in\">bind</span> /0.0.0.0:20880, <span class=\"hljs-built_in\">export</span> /192.168.99.1:20880, dubbo version: 2.6.2, current host: 192.168.99.1\n\n[01/08/18 02:12:51:051 CST] main  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Register: dubbo://192.168.99.1:20880/com.alibaba.dubbo.samples.api.GreetingService?anyhost=<span class=\"hljs-literal\">true</span>&amp;application=dubbo-annotation-provider&amp;default.timeout=1000&amp;dubbo=2.6.2&amp;generic=<span class=\"hljs-literal\">false</span>&amp;interface=com.alibaba.dubbo.samples.api\n</code></pre>\n<h3>5. 客户端：引用服务</h3>\n<p>通过 <code>@Reference</code> 来标记 <code>GreetingService</code> 接口的成员变量 greetingService 是一个 Dubbo 服务的引用，也就是说，可以简单的通过该接口向远端的服务提供方发起调用，而客户端并没有实现 <code>GreetingService</code> 接口。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Component</span>(<span class=\"hljs-string\">\"annotatedConsumer\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GreetingServiceConsumer</span> </span>{\n    <span class=\"hljs-meta\">@Reference</span>\n    <span class=\"hljs-keyword\">private</span> GreetingService greetingService;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">doSayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> greetingService.sayHello(name);\n    }\n}\n</code></pre>\n<h3>6. 客户端：组装服务消费者</h3>\n<p>与 <strong>3. 服务端：组装服务提供方</strong> 类似，通过 Spring 中 Java Config 的技术（<code>@Configuration</code>）和 annotation 扫描（<code>@EnableDubbo</code>）来发现、组装 Dubbo 服务的消费者。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@EnableDubbo</span>(scanBasePackages = <span class=\"hljs-string\">\"com.alibaba.dubbo.samples.action\"</span>)\n<span class=\"hljs-meta\">@ComponentScan</span>(value = {<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.action\"</span>})\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConsumerConfiguration</span> </span>{\n    <span class=\"hljs-meta\">@Bean</span> <span class=\"hljs-comment\">// #1</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ApplicationConfig <span class=\"hljs-title\">applicationConfig</span><span class=\"hljs-params\">()</span> </span>{\n        ApplicationConfig applicationConfig = <span class=\"hljs-keyword\">new</span> ApplicationConfig();\n        applicationConfig.setName(<span class=\"hljs-string\">\"dubbo-annotation-consumer\"</span>);\n        <span class=\"hljs-keyword\">return</span> applicationConfig;\n    }\n\n    <span class=\"hljs-meta\">@Bean</span> <span class=\"hljs-comment\">// #2</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ConsumerConfig <span class=\"hljs-title\">consumerConfig</span><span class=\"hljs-params\">()</span> </span>{\n        ConsumerConfig consumerConfig = <span class=\"hljs-keyword\">new</span> ConsumerConfig();\n        consumerConfig.setTimeout(<span class=\"hljs-number\">3000</span>);\n        <span class=\"hljs-keyword\">return</span> consumerConfig;\n    }\n\n    <span class=\"hljs-meta\">@Bean</span> <span class=\"hljs-comment\">// #3</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> RegistryConfig <span class=\"hljs-title\">registryConfig</span><span class=\"hljs-params\">()</span> </span>{\n        RegistryConfig registryConfig = <span class=\"hljs-keyword\">new</span> RegistryConfig();\n        registryConfig.setProtocol(<span class=\"hljs-string\">\"zookeeper\"</span>);\n        registryConfig.setAddress(<span class=\"hljs-string\">\"localhost\"</span>);\n        registryConfig.setPort(<span class=\"hljs-number\">2181</span>);\n        <span class=\"hljs-keyword\">return</span> registryConfig;\n    }\n}\n</code></pre>\n<p>说明：</p>\n<ul>\n<li>通过 <code>@EnableDubbo</code> 指定在 <code>com.alibaba.dubbo.samples.impl</code> 下扫描所有标注有 `@Reference 的类</li>\n<li>通过 <code>@Configuration</code> 将 ConsumerConfiguration 中所有的 <code>@Bean</code> 通过 Java Config 的方式组装出来并注入给 Dubbo 服务消费者，也就是标注有 `@Reference 的类。这其中就包括了：\n<ol>\n<li>ApplicationConfig：应用配置</li>\n<li>ConsumerConfig：服务消费者配置</li>\n<li>RegistryConfig：注册中心配置，注意：这里的配置需要与服务提供方启动的 EmbeddedZooKeeper 的配置信息保持一致</li>\n</ol>\n</li>\n</ul>\n<h3>7. 客户端：发起远程调用</h3>\n<p>在 <code>main</code> 方法中通过启动一个 Spring Context，从其中查找到组装好的 Dubbo 的服务消费者，并发起一次远程调用。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConsumerBootstrap</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        AnnotationConfigApplicationContext context = <span class=\"hljs-keyword\">new</span> AnnotationConfigApplicationContext(ConsumerConfiguration.class); <span class=\"hljs-comment\">// #1</span>\n        context.start(); <span class=\"hljs-comment\">// #2</span>\n        GreetingServiceConsumer greetingServiceConsumer = context.getBean(GreetingServiceConsumer.class); <span class=\"hljs-comment\">// #3</span>\n        String hello = greetingServiceConsumer.doSayHello(<span class=\"hljs-string\">\"annotation\"</span>); <span class=\"hljs-comment\">// #4</span>\n        System.out.println(<span class=\"hljs-string\">\"result: \"</span> + hello); <span class=\"hljs-comment\">// #5</span>\n    }\n}\n</code></pre>\n<p>说明：</p>\n<ol>\n<li>\n<p>初始化一个 <code>AnnotationConfigApplicationContext</code> 的示例，并将 <code>ConsumerConfiguration</code> 传入以完成 Dubbo 服务消费者的自动发现和装配</p>\n</li>\n<li>\n<p>启动 Spring Context</p>\n</li>\n<li>\n<p>从 Context 中查找出类型为 <code>GreetingServiceConsumer</code> 的 Bean</p>\n</li>\n<li>\n<p>调用 <code>doSayHello</code> 方法，最终通过 Dubbo 的服务引用（由 <code>@Reference</code> 标注）发起一次远程调用</p>\n</li>\n<li>\n<p>打印调用结果</p>\n</li>\n</ol>\n<p>启动客户端的 <code>main</code> 方法，将会看到下面的输出，其中返回结果为 result: hello, annotation：</p>\n<pre><code class=\"language-sh\">[01/08/18 02:38:40:040 CST] main  INFO config.AbstractConfig:  [DUBBO] Refer dubbo service com.alibaba.dubbo.samples.api.GreetingService from url zookeeper://localhost:2181/com.alibaba.dubbo.registry.RegistryService?anyhost=<span class=\"hljs-literal\">true</span>&amp;application=dubbo-annotation-consumer&amp;check=<span class=\"hljs-literal\">false</span>&amp;default.timeout=3000&amp;dubbo=2.6.2&amp;generic=<span class=\"hljs-literal\">false</span>&amp;interface=com.alibaba.dubbo.samples.api.GreetingService&amp;methods=sayHello&amp;pid=33001&amp;register.ip=192.168.99.1&amp;remote.timestamp=1533105502086&amp;side=consumer&amp;timestamp=1533105519216, dubbo version: 2.6.2, current host: 192.168.99.1\n[01/08/18 02:38:40:040 CST] main  INFO annotation.ReferenceBeanBuilder: &lt;dubbo:reference object=<span class=\"hljs-string\">\"com.alibaba.dubbo.common.bytecode.proxy0@673be18f\"</span> singleton=<span class=\"hljs-string\">\"true\"</span> interface=<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.api.GreetingService\"</span> uniqueServiceName=<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.api.GreetingService\"</span> generic=<span class=\"hljs-string\">\"false\"</span> id=<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.api.GreetingService\"</span> /&gt; has been built.\nresult: hello, annotation\n</code></pre>\n<h2>总结</h2>\n<p>通过本文的学习，读者可以掌握 Dubbo 专属的 annotation <code>@EnableDubbo</code>、<code>@Service</code>、<code>@Reference</code> 的基本概念，并通过一个简单 Dubbo 应用的实战开发掌握其基本的用法。</p>\n<p>Spring 除了传统的 XML 配置之外，还提供了注解驱动、外部化配置、以及自动装配等更现代的配置方式。本文专注在介绍通过注解方式来开发 Dubbo 应用，可以看到，与 XML 配置相比，注解方式编程更加简洁明快。在今后的博文中，会进一步的介绍在 Dubbo 中使用外部化配置、以及自动装配的方法。</p>\n"
    },
    {
      "filename": "dubbo-basic-usage-dubbo-provider-configuration.md",
      "__html": "<h2>Dubbo基本用法-Dubbo Provider配置</h2>\n<h1>Dubbo基本用法</h1>\n<p>本章节主要讲述如何配置dubbo，按照配置方式上分，可以分为：XML配置，properties方式配置，注解方式配置，API调用方式配置。\n按照功能角度进行划分，可以分为Dubbo Provider和Dubbo Consumer。接下来章节中，分别对dubbo provider和Dubbo consumer进行讲解。</p>\n<h2>Dubbo Provider配置</h2>\n<h3>Provider 配置详解</h3>\n<p>配置Dubbo Provider有4种方式：XML配置，properties方式配置，API调用方式配置，注解方式配置。</p>\n<h4>XML配置</h4>\n<h6>最简单的配置的样例：</h6>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt;  \n    &lt;dubbo:application name=&quot;hello-world-app&quot; /&gt;  \n    &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot; /&gt;  \n    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;  \n    &lt;dubbo:service interface=&quot;com.alibaba.dubbo.demo.DemoService&quot; ref=&quot;demoServiceLocal&quot; /&gt;  \n    &lt;dubbo:reference id=&quot;demoServiceRemote&quot; interface=&quot;com.alibaba.dubbo.demo.DemoService&quot; /&gt;  \n&lt;/beans&gt;\n</code></pre>\n<p>上面样例中，注意下dubbo schema的写法：</p>\n<pre><code>&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;\n       xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\n       http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;\n</code></pre>\n<h6>支持的配置标签</h6>\n<table>\n<thead>\n<tr>\n<th>标签</th>\n<th>用途</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&lt;dubbo:service/&gt;</td>\n<td>服务配置</td>\n<td style=\"text-align:left\">用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心</td>\n</tr>\n<tr>\n<td>&lt;dubbo:reference/&gt;</td>\n<td>引用配置</td>\n<td style=\"text-align:left\">用于创建一个远程服务代理，一个引用可以指向多个注册中心</td>\n</tr>\n<tr>\n<td>&lt;dubbo:protocol/&gt;</td>\n<td>协议配置</td>\n<td style=\"text-align:left\">用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受</td>\n</tr>\n<tr>\n<td>&lt;dubbo:application/&gt;</td>\n<td>应用配置</td>\n<td style=\"text-align:left\">用于配置当前应用信息，不管该应用是提供者还是消费者</td>\n</tr>\n<tr>\n<td>&lt;dubbo:module/&gt;</td>\n<td>模块配置</td>\n<td style=\"text-align:left\">用于配置当前模块信息，可选</td>\n</tr>\n<tr>\n<td>&lt;dubbo:registry/&gt;</td>\n<td>注册中心配置</td>\n<td style=\"text-align:left\">用于配置连接注册中心相关信息</td>\n</tr>\n<tr>\n<td>&lt;dubbo:monitor/&gt;</td>\n<td>监控中心配置</td>\n<td style=\"text-align:left\">用于配置连接监控中心相关信息，可选</td>\n</tr>\n<tr>\n<td>&lt;dubbo:provider/&gt;</td>\n<td>提供方配置</td>\n<td style=\"text-align:left\">当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选</td>\n</tr>\n<tr>\n<td>&lt;dubbo:consumer/&gt;</td>\n<td>消费方配置</td>\n<td style=\"text-align:left\">当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选</td>\n</tr>\n<tr>\n<td>&lt;dubbo:method/&gt;</td>\n<td>方法配置</td>\n<td style=\"text-align:left\">用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息</td>\n</tr>\n<tr>\n<td>&lt;dubbo:argument/&gt;</td>\n<td>参数配置</td>\n<td style=\"text-align:left\">用于指定方法参数配置</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://cdn.yuque.com/lark/0/2018/png/15841/1527849348155-8423d401-9ea4-4dc6-8720-d9e3d90963b6.png\" alt=\"undefined\"></p>\n <center>配置之间关系图</center>\n<h6>配置项详解</h6>\n<ul>\n<li>\n<p>&lt;dubbo:application name=&quot;hello-world-app&quot; /&gt;<br>\n用于指定应用名，这里需要保证应用名唯一，这个应用名在后续的console admin中可以在列表中显示，方便管理。</p>\n</li>\n<li>\n<p>&lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot; /&gt;<br>\n注册中心配置，和服务发现的具体机制有关系。可以是zookeeper地质，也可以eureka地质。上面这个是广播地址，在本地服务调用的测试过程中非常方便。</p>\n</li>\n<li>\n<p>&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;<br>\n这里是传输的协议和默认端口，一般不需要更改。</p>\n</li>\n</ul>\n<blockquote>\n<p>接下来重点讲解下&lt;dubbo:service/&gt;的配置。</p>\n</blockquote>\n<ul>\n<li>&lt;dubbo:service/&gt;支持的主要属性列表：\n| 属性名 | 说明 |\n| -------- | ----- |\n| version | 版本号 |\n| scope | 服务可见性, 值为：local 或者 remote，默认为remote |\n| actives | 最大的激活的请求数 |\n| async | 方法调用是否异步，默认为false |\n| cache | 服务缓存，可选值：lru/threadlocal/jcache |\n| callbacks | callback实例的限制 |\n| generic | 泛化调用，可以绕过 |\n| class | Service的实现的类名 |\n| connections | 这个服务里的连接数 |\n| delay | 发布服务延迟的毫秒数 |\n| executes | 服务执行的请求上限 |\n| retries | 超时重试次数 |\n| timeout | 调用超时时间 |</li>\n</ul>\n<p>其他配置属性请参考xsd：<a href=\"http://dubbo.apache.org/schema/dubbo/dubbo.xsd\">http://dubbo.apache.org/schema/dubbo/dubbo.xsd</a></p>\n<ul>\n<li>&lt;dubbo:method/&gt;作为&lt;dubbo:service/&gt;的子元素，它可以针对方法进行配置。比较常用的属性有：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>executes</td>\n<td>服务执行的请求上限</td>\n</tr>\n<tr>\n<td>retries</td>\n<td>超时重试次数</td>\n</tr>\n<tr>\n<td>timeout</td>\n<td>调用超时时间</td>\n</tr>\n</tbody>\n</table>\n<p>其他属性，可以参考上面的xsd。</p>\n<h6>配置的覆盖关系</h6>\n<p><img src=\"https://cdn.yuque.com/lark/0/2018/png/15841/1527849374313-94a5ea24-0e72-4d83-871b-e0e95eab646a.png\" alt=\"undefined\"></p>\n<center>配置的覆盖关系图</center>\n<p>这里的覆盖关系包含了Provider和Consumer两端的配置，如果对consumer有疑问，可以参考后一章节的consumer章节之后再来理解。</p>\n<h4>dubbo.properties方式配置</h4>\n<blockquote>\n<p>如果公共配置很简单，没有多注册中心，多协议等情况，或者想多个 Spring 容器想共享配置，可以使用 dubbo.properties 作为缺省配置。</p>\n</blockquote>\n<p>Dubbo 将自动加载 classpath 根目录下的 dubbo.properties，可以通过JVM启动参数 -Ddubbo.properties.file=xxx.properties 改变缺省配置位置。</p>\n<h6>dubbo.properties配置样例</h6>\n<pre><code># 应用名\ndubbo.application.name=dubbodemo-provider\n# 注册中心地址\ndubbo.registry.address=zookeeper://localhost:2181\n# 广播的注册中心样例\n#dubbo.registry.address=multicast://224.5.6.7:1234\n# 调用协议地址\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=28080\n</code></pre>\n<h6>映射规则</h6>\n<p>将 XML 配置的标签名，加属性名，用点分隔，多个属性拆成多行</p>\n<ul>\n<li>比如：dubbo.application.name=foo等价于&lt;dubbo:application name=&quot;foo&quot; /&gt;</li>\n<li>比如：dubbo.registry.address=10.20.153.10:9090等价于&lt;dubbo:registry address=&quot;10.20.153.10:9090&quot; /&gt;</li>\n</ul>\n<p>如果 XML 有多行同名标签配置，可用 id 号区分，如果没有 id 号将对所有同名标签生效</p>\n<ul>\n<li>比如：dubbo.protocol.rmi.port=1234等价于&lt;dubbo:protocol id=&quot;rmi&quot; name=&quot;rmi&quot; port=&quot;1099&quot; /&gt; 2</li>\n<li>比如：dubbo.registry.china.address=10.20.153.10:9090等价于&lt;dubbo:registry id=&quot;china&quot; address=&quot;10.20.153.10:9090&quot; /&gt;</li>\n</ul>\n<h6>覆盖策略</h6>\n<p><img src=\"https://cdn.yuque.com/lark/0/2018/png/15841/1527849393591-2c3de248-1b3d-47d3-bd10-8b415e9fcd39.png\" alt=\"undefined\"></p>\n<ul>\n<li>JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。</li>\n<li>XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。</li>\n<li>Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</li>\n</ul>\n<blockquote>\n<p>注意：</p>\n</blockquote>\n<ol>\n<li>如果 classpath 根目录下存在多个 dubbo.properties，比如多个 jar 包中有 dubbo.properties，Dubbo 会任意加载，并打印 Error 日志，后续可能改为抛异常。 ↩</li>\n<li>协议的 id 没配时，缺省使用协议名作为 id</li>\n</ol>\n<h4>annotation</h4>\n<h6>Service注解暴露服务</h6>\n<pre><code>import com.alibaba.dubbo.config.annotation.Service;\n\n@Service(timeout = 5000)\npublic class AnnotateServiceImpl implements AnnotateService { \n    // ...\n}\n</code></pre>\n<h6>javaconfig形式配置公共模块</h6>\n<pre><code>@Configuration\npublic class DubboConfiguration {\n\n    @Bean\n    public ApplicationConfig applicationConfig() {\n        ApplicationConfig applicationConfig = new ApplicationConfig();\n        applicationConfig.setName(&quot;provider-test&quot;);\n        return applicationConfig;\n    }\n\n    @Bean\n    public RegistryConfig registryConfig() {\n        RegistryConfig registryConfig = new RegistryConfig();\n        registryConfig.setAddress(&quot;zookeeper://127.0.0.1:2181&quot;);\n        registryConfig.setClient(&quot;curator&quot;);\n        return registryConfig;\n    }\n}\n</code></pre>\n<p>这种方式的配置和前面用xml配置的方式是一样的效果。</p>\n<h6>指定dubbo扫描路径</h6>\n<pre><code>@SpringBootApplication\n@DubboComponentScan(basePackages = &quot;com.alibaba.dubbo.test.service.impl&quot;)\npublic class ProviderTestApp {\n    // ...\n}\n</code></pre>\n<p>或者使用spring bean xml配置方式：</p>\n<pre><code>&lt;dubbo:annotation package=&quot;com.chanshuyi.service.impl&quot; /&gt;\n</code></pre>\n<h4>api直接触发</h4>\n<pre><code>import com.alibaba.dubbo.rpc.config.ApplicationConfig;\nimport com.alibaba.dubbo.rpc.config.RegistryConfig;\nimport com.alibaba.dubbo.rpc.config.ProviderConfig;\nimport com.alibaba.dubbo.rpc.config.ServiceConfig;\nimport com.xxx.XxxService;\nimport com.xxx.XxxServiceImpl;\n\n// 服务实现\nXxxService xxxService = new XxxServiceImpl();\n\n// 当前应用配置\nApplicationConfig application = new ApplicationConfig();\napplication.setName(&quot;xxx&quot;);\n\n// 连接注册中心配置\nRegistryConfig registry = new RegistryConfig();\nregistry.setAddress(&quot;10.20.130.230:9090&quot;);\nregistry.setUsername(&quot;aaa&quot;);\nregistry.setPassword(&quot;bbb&quot;);\n\n// 服务提供者协议配置\nProtocolConfig protocol = new ProtocolConfig();\nprotocol.setName(&quot;dubbo&quot;);\nprotocol.setPort(12345);\nprotocol.setThreads(200);\n\n// 注意：ServiceConfig为重对象，内部封装了与注册中心的连接，以及开启服务端口\n\n// 服务提供者暴露服务配置\nServiceConfig&lt;XxxService&gt; service = new ServiceConfig&lt;XxxService&gt;(); // 此实例很重，封装了与注册中心的连接，请自行缓存，否则可能造成内存和连接泄漏\nservice.setApplication(application);\nservice.setRegistry(registry); // 多个注册中心可以用setRegistries()\nservice.setProtocol(protocol); // 多个协议可以用setProtocols()\nservice.setInterface(XxxService.class);\nservice.setRef(xxxService);\nservice.setVersion(&quot;1.0.0&quot;);\n\n// 暴露及注册服务\nservice.export();\n</code></pre>\n<p>一般在spring应用中，不推荐使用这种方式。 具体的含义这里不做解释，可以通过github查看源码。</p>\n<h3>Provider 接口和实现</h3>\n<p>上面章节更多从配置角度出发，接下来通过一个完整的例子，来讲解下dubbo provider的完整使用。</p>\n<p>这个例子中只有一个服务UserReadService，有一个方法 getUserById。 需要将这个服务通过Dubbo暴露给远程的服务。具体的步骤如下：</p>\n<p>1.创建工程\n如果本来已经有工程，可以忽略。创建一个spring boot工程，可以通过 <a href=\"https://start.spring.io/\">https://start.spring.io/</a> 创建。\n2.定义接口\n定义接口：UserReadService</p>\n<pre><code>public interface UserReadService{\npublic User getUserById(Long userId);\n}\n</code></pre>\n<p>这个接口一般来说会放到独立的jar包里，作为client包。 其他应用要消费这个服务的时候，一般来说需要应用引用这个client包。(除了泛化调用)\n3.实现接口\n实现UserReadService, 当前实现部署在Provider的应用中。</p>\n<pre><code>public UserReadServiceImpl implements UserReadService{\n    public User getUserById(Long userId){\n        return xxx;\n    }\n}\n</code></pre>\n<p>4.Dubbo配置</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt;  \n    &lt;dubbo:application name=&quot;hello-world-app&quot; /&gt;  \n    &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot; /&gt;  \n    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;  \n    &lt;bean id=&quot;userReadService&quot; class=&quot;com.package.UserReadServiceImpl&quot;/&gt;\n    &lt;dubbo:service interface=&quot;com.package.UserReadService&quot; ref=&quot;userReadService&quot; /&gt;  \n&lt;/beans&gt;\n</code></pre>\n<p>Dubbo配置的其他方式可以参考上一章节的相关配置，或者使用集成dubbo spring boot starter方式。</p>\n"
    },
    {
      "filename": "dubbo-invoke.md",
      "__html": "<h1>Dubbo 关于同步/异步调用的几种方式</h1>\n<p>我们知道，Dubbo 缺省协议采用单一长连接，底层实现是 Netty 的 NIO 异步通讯机制；基于这种机制，Dubbo 实现了以下几种调用方式：</p>\n<ul>\n<li>同步调用</li>\n<li>异步调用</li>\n<li>参数回调</li>\n<li>事件通知</li>\n</ul>\n<h3>同步调用</h3>\n<p>同步调用是一种阻塞式的调用方式，即 Consumer 端代码一直阻塞等待，直到 Provider 端返回为止；</p>\n<p>通常，一个典型的同步调用过程如下：</p>\n<ol>\n<li>Consumer 业务线程调用远程接口，向 Provider 发送请求，同时当前线程处于<code>阻塞</code>状态；</li>\n<li>Provider 接到 Consumer 的请求后，开始处理请求，将结果返回给 Consumer；</li>\n<li>Consumer 收到结果后，当前线程继续往后执行。</li>\n</ol>\n<p>这里有 2 个问题：</p>\n<ol>\n<li>Consumer 业务线程是怎么进入<code>阻塞</code>状态的？</li>\n<li>Consumer 收到结果后，如果唤醒业务线程往后执行的？</li>\n</ol>\n<p>其实，Dubbo 的底层 IO 操作都是异步的。Consumer 端发起调用后，得到一个 Future 对象。对于同步调用，业务线程通过<code>Future#get(timeout)</code>，阻塞等待 Provider 端将结果返回；<code>timeout</code>则是 Consumer 端定义的超时时间。当结果返回后，会设置到此 Future，并唤醒阻塞的业务线程；当超时时间到结果还未返回时，业务线程将会异常返回。</p>\n<h3>异步调用</h3>\n<p>基于 Dubbo 底层的异步 NIO 实现异步调用，对于 Provider 响应时间较长的场景是必须的，它能有效利用 Consumer 端的资源，相对于 Consumer 端使用多线程来说开销较小。</p>\n<p>异步调用，对于 Provider 端不需要做特别的配置。下面的例子中，Provider 端接口定义如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">AsyncService</span> </span>{\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">goodbye</span><span class=\"hljs-params\">(String name)</span></span>;\n}\n</code></pre>\n<h5>Consumer 配置</h5>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"asyncService\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.async.api.AsyncService\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"goodbye\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"true\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dubbo:reference</span>&gt;</span>\n</code></pre>\n<p>需要异步调用的方法，均需要使用 <code>&lt;dubbo:method/&gt;</code>标签进行描述。</p>\n<h5>Consumer 端发起调用</h5>\n<pre><code class=\"language-java\">AsyncService service = ...;\nString result = service.goodbye(<span class=\"hljs-string\">\"samples\"</span>);<span class=\"hljs-comment\">// 这里的返回值为空，请不要使用</span>\nFuture&lt;String&gt; future = RpcContext.getContext().getFuture();\n... <span class=\"hljs-comment\">// 业务线程可以开始做其他事情</span>\nresult = future.get(); <span class=\"hljs-comment\">// 阻塞需要获取异步结果时，也可以使用 get(timeout, unit) 设置超时时间</span>\n</code></pre>\n<p>Dubbo Consumer 端发起调用后，同时通过<code>RpcContext.getContext().getFuture()</code>获取跟返回结果关联的<code>Future</code>对象，然后就可以开始处理其他任务；当需要这次异步调用的结果时，可以在任意时刻通过<code>future.get(timeout)</code>来获取。</p>\n<p>一些特殊场景下，为了尽快调用返回，可以设置是否等待消息发出：</p>\n<ul>\n<li><code>sent=&quot;true&quot;</code> 等待消息发出，消息发送失败将抛出异常；</li>\n<li><code>sent=&quot;false&quot;</code> 不等待消息发出，将消息放入 IO 队列，即刻返回。</li>\n</ul>\n<p>默认为<code>fase</code>。配置方式如下：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"goodbye\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"true\"</span> <span class=\"hljs-attr\">sent</span>=<span class=\"hljs-string\">\"true\"</span> /&gt;</span>\n</code></pre>\n<p>如果你只是想异步，完全忽略返回值，可以配置 <code>return=&quot;false&quot;</code>，以减少 Future 对象的创建和管理成本：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"goodbye\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"true\"</span> <span class=\"hljs-attr\">return</span>=<span class=\"hljs-string\">\"false\"</span>/&gt;</span>\n</code></pre>\n<p>此时，<code>RpcContext.getContext().getFuture()</code>将返回<code>null</code>。</p>\n<p>整个异步调用的时序图如下：</p>\n<p><img src=\"../../img/blog/dubbo-async.svg\" alt=\"异步调用\"></p>\n<p>此示例代码位于：<a href=\"https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-async\">https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-async</a></p>\n<h3>参数回调</h3>\n<p>参数回调有点类似于本地 Callback 机制，但 Callback 并不是 Dubbo 内部的类或接口，而是由 Provider 端自定义的；Dubbo 将基于长连接生成反向代理，从而实现从 Provider 端调用 Consumer 端的逻辑。</p>\n<h5>Provider 端定义 Service 和 Callback</h5>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">CallbackService</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addListener</span><span class=\"hljs-params\">(String key, CallbackListener listener)</span></span>;\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">CallbackListener</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">changed</span><span class=\"hljs-params\">(String msg)</span></span>;\n}\n</code></pre>\n<h5>Provider 端 Service 实现</h5>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CallbackServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">CallbackService</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Map&lt;String, CallbackListener&gt; listeners = <span class=\"hljs-keyword\">new</span> ConcurrentHashMap&lt;String, CallbackListener&gt;();\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">CallbackServiceImpl</span><span class=\"hljs-params\">()</span> </span>{\n        Thread t = <span class=\"hljs-keyword\">new</span> Thread(<span class=\"hljs-keyword\">new</span> Runnable() {\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n                <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">true</span>) {\n                    <span class=\"hljs-keyword\">try</span> {\n                        <span class=\"hljs-keyword\">for</span> (Map.Entry&lt;String, CallbackListener&gt; entry : listeners.entrySet()) {\n                            <span class=\"hljs-keyword\">try</span> {\n                                entry.getValue().changed(getChanged(entry.getKey()));\n                            } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n                                listeners.remove(entry.getKey());\n                            }\n                        }\n                        Thread.sleep(<span class=\"hljs-number\">5000</span>); <span class=\"hljs-comment\">// timely trigger change event</span>\n                    } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n                        t.printStackTrace();\n                    }\n                }\n            }\n        });\n        t.setDaemon(<span class=\"hljs-keyword\">true</span>);\n        t.start();\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addListener</span><span class=\"hljs-params\">(String key, CallbackListener listener)</span> </span>{\n        listeners.put(key, listener);\n        listener.changed(getChanged(key)); <span class=\"hljs-comment\">// send notification for change</span>\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> String <span class=\"hljs-title\">getChanged</span><span class=\"hljs-params\">(String key)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Changed: \"</span> + <span class=\"hljs-keyword\">new</span> SimpleDateFormat(<span class=\"hljs-string\">\"yyyy-MM-dd HH:mm:ss\"</span>).format(<span class=\"hljs-keyword\">new</span> Date());\n    }\n}\n</code></pre>\n<h5>Provider 端暴露服务</h5>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"callbackService\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.callback.impl.CallbackServiceImpl\"</span>/&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.callback.api.CallbackService\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"callbackService\"</span> <span class=\"hljs-attr\">connections</span>=<span class=\"hljs-string\">\"1\"</span> <span class=\"hljs-attr\">callbacks</span>=<span class=\"hljs-string\">\"1000\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"addListener\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:argument</span> <span class=\"hljs-attr\">index</span>=<span class=\"hljs-string\">\"1\"</span> <span class=\"hljs-attr\">callback</span>=<span class=\"hljs-string\">\"true\"</span>/&gt;</span>\n        <span class=\"hljs-comment\">&lt;!--&lt;dubbo:argument type=\"com.demo.CallbackListener\" callback=\"true\" /&gt;--&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dubbo:method</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dubbo:service</span>&gt;</span>\n</code></pre>\n<p>这里，Provider 需要在方法中声明哪个参数是 Callback 参数。</p>\n<h5>Consumer 端实现 Callback 接口</h5>\n<pre><code class=\"language-java\">CallbackService callbackService = ...;\ncallbackService.addListener(<span class=\"hljs-string\">\"foo.bar\"</span>, <span class=\"hljs-keyword\">new</span> CallbackListener() {\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">changed</span><span class=\"hljs-params\">(String msg)</span> </span>{\n            System.out.println(<span class=\"hljs-string\">\"callback1:\"</span> + msg);\n        }\n});\n</code></pre>\n<p>Callback 接口的实现类在 Consumer 端，当方法发生调用时，Consumer 端会自动 export 一个 Callback 服务。而 Provider 端在处理调用时，判断如果参数是 Callback，则生成了一个 proxy，因此服务实现类里在调用 Callback 方法的时候，会被传递到 Consumer 端执行 Callback 实现类的代码。</p>\n<p>上述示例代码位于：此示例代码位于：<a href=\"https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-callback\">https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-callback</a></p>\n<p>这种调用方式有点像消息的发布和订阅，但又有区别。比如当 Consumer 端 完成了Callback 服务的 export 后，如果后续重启了，这时 Provider 端就会调不通；同时 Provider 端如何清理掉这个 proxy 也是一个问题。</p>\n<h3>事件通知</h3>\n<p>事件通知允许 Consumer 端在调用之前、调用正常返回之后或调用出现异常时，触发 <code>oninvoke</code>、<code>onreturn</code>、<code>onthrow</code> 三个事件。</p>\n<p>可以通过在配置 Consumer 时，指定事件需要通知的方法，如：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demoCallback\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.notify.impl.NotifyImpl\"</span> /&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">check</span>=<span class=\"hljs-string\">\"false\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.notify.api.DemoService\"</span> <span class=\"hljs-attr\">version</span>=<span class=\"hljs-string\">\"1.0.0\"</span> <span class=\"hljs-attr\">group</span>=<span class=\"hljs-string\">\"cn\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"sayHello\"</span> <span class=\"hljs-attr\">onreturn</span>=<span class=\"hljs-string\">\"demoCallback.onreturn\"</span> <span class=\"hljs-attr\">onthrow</span>=<span class=\"hljs-string\">\"demoCallback.onthrow\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dubbo:reference</span>&gt;</span>\n</code></pre>\n<p>其中，NotifyImpl 的代码如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NotifyImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Notify</span></span>{\n\n    <span class=\"hljs-keyword\">public</span> Map&lt;Integer, String&gt; ret = <span class=\"hljs-keyword\">new</span> HashMap&lt;Integer, String&gt;();\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onreturn</span><span class=\"hljs-params\">(String name, <span class=\"hljs-keyword\">int</span> id)</span> </span>{\n        ret.put(id, name);\n        System.out.println(<span class=\"hljs-string\">\"onreturn: \"</span> + name);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onthrow</span><span class=\"hljs-params\">(Throwable ex, String name, <span class=\"hljs-keyword\">int</span> id)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"onthrow: \"</span> + name);\n    }\n}\n</code></pre>\n<p>这里要强调一点，自定义 Notify 接口中的三个方法的参数规则如下：</p>\n<ul>\n<li><code>oninvoke</code> 方法参数与调用方法的参数相同；</li>\n<li><code>onreturn</code>方法第一个参数为调用方法的返回值，其余为调用方法的参数；</li>\n<li><code>onthrow</code>方法第一个参数为调用异常，其余为调用方法的参数。</li>\n</ul>\n<p>上述配置中，<code>sayHello</code>方法为同步调用，因此事件通知方法的执行也是同步执行。可以配置 <code>async=true</code>让方法调用为异步，这时事件通知的方法也是异步执行的。特别强调一下，<code>oninvoke</code>方法不管是否异步调用，都是同步执行的。</p>\n<p>事件通知的示例代码请参考：<a href=\"https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-notify\">https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-notify</a></p>\n"
    },
    {
      "filename": "dubbo-meetup-shanghai-jun-23rd-2018.md",
      "__html": "<h2>第二届Dubbo开发者沙龙在上海成功举办</h2>\n<p>第二届Dubbo开发者沙龙在上海成功举办，超过700位开发者报名，现场参与人数300+，通过阿里云天池、云栖社区、大咖说引导线上直播观看次数10000+</p>\n<p>分享嘉宾及PPT:</p>\n<ul>\n<li>朱勇: Dubbo开源现状与未来规划 (中文) <a href=\"https://github.com/dubbo/awesome-dubbo/blob/master/slides/meetup/201806%40Shanghai/dubbo-status-and-roadmap.pdf\">slides</a></li>\n<li>小马哥: Dubbo Cloud Native 之路的实践与思考 (中文) <a href=\"https://github.com/dubbo/awesome-dubbo/blob/master/slides/meetup/201806%40Shanghai/dubbo-cloud-native-practices-and-thoughts.pdf\">slides</a></li>\n<li>郭平: Nacos - 贡献Dubbo生态，阿里巴巴注册中心和配置中心开源计划 (中文) <a href=\"https://github.com/dubbo/awesome-dubbo/blob/master/slides/meetup/201806%40Shanghai/nacos-open-source-initiative.pdf\">slides</a></li>\n<li>潘志伟: Dubbo在互金行业的应用场景 (中文) <a href=\"https://github.com/dubbo/awesome-dubbo/blob/master/slides/meetup/201806%40Shanghai/dubbo-practices-on-internet-finance-industries.pdf\">slides</a></li>\n</ul>\n"
    },
    {
      "filename": "dubbo-zk.md",
      "__html": "<h1>在 Dubbo 应用中使用 Zookeeper</h1>\n<h2>Zookeeper 介绍</h2>\n<h3>基本概念</h3>\n<p>在现代的分布式应用中，往往会出现节点和节点之间的协调问题，其中就包括了：选主、集群管理、分布式锁、分布式配置管理、统一命名服务、状态同步等诉求。<a href=\"https://zookeeper.apache.org\">Apache Zookeeper</a>，正如它的名字所暗示的那样，<em>动物园管理员</em>，就是为了解决这些诉求的一个分布式协调服务框架。</p>\n<p>为了保证高可用，ZooKeeper 本身也可以部署成集群模式，称之为 <em>ZooKeeper ensemble</em>。ZooKeeper 集群中始终确保其中的一台为 leader 的角色，并通过 <em>ZAB (Zookeeper Atomic Broadcast Protocol) <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></em> 协议确保所有节点上的信息的一致。客户端可以访问集群中的任何一台进行读写操作，而不用担心数据出现不一致的现象。</p>\n<p><img src=\"../../img/blog/zk-emsemble.png\" alt=\"Diagram shows client-server architecture of ZooKeeper\">\n<em>Image Credit : ebook -Zookeeper-Distributed Process Coordination from O'Reilly</em></p>\n<p>Zookeeper 中的数据存储方式与传统的 UNIX 文件系统相似，节点按照树状结构来组织，其中，节点被称之为 <em>znodes (ZooKeeper data nodes)</em></p>\n<p><img src=\"../../img/blog/zk-tree.png\" alt=\"zk-tree\">\n<em>Image Credit : ebook -Zookeeper-Distributed Process Coordination from O'Reilly</em></p>\n<h3>基本用法</h3>\n<p>可以通过直接下载的方式 <sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>安装并运行 Zookeeper ，在 Mac 上也可以通过 Homebrew <sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>  <code>brew install zookeeper</code>  来安装，考虑到通用性，本文采用 docker 的方式来运行 Zookeeper。如果没有安装 docker，请先准备好 docker 环境 <sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup>。</p>\n<h4>1. 启动 Zookeeper</h4>\n<p>执行命令将 Zookeeper 运行在 docker 容器中</p>\n<pre><code class=\"language-shell\">docker run --rm --name zookeeper -p 2181:2181 zookeeper\n</code></pre>\n<h4>2. 进入 Zookeeper 容器</h4>\n<pre><code class=\"language-shell\">docker exec -it zookeeper bash\n</code></pre>\n<p>在 <code>bin</code> 目录下有启动 Zookeeper 的命令 <code>zkServer</code> 以及管理控制台 <code>zkCli</code></p>\n<pre><code class=\"language-shell\">bash-4.4# ls -l bin\ntotal 36\n-rwxr-xr-x    1 zookeepe zookeepe       232 Mar 27 04:32 README.txt\n-rwxr-xr-x    1 zookeepe zookeepe      1937 Mar 27 04:32 zkCleanup.sh\n-rwxr-xr-x    1 zookeepe zookeepe      1056 Mar 27 04:32 zkCli.cmd\n-rwxr-xr-x    1 zookeepe zookeepe      1534 Mar 27 04:32 zkCli.sh\n-rwxr-xr-x    1 zookeepe zookeepe      1759 Mar 27 04:32 zkEnv.cmd\n-rwxr-xr-x    1 zookeepe zookeepe      2696 Mar 27 04:32 zkEnv.sh\n-rwxr-xr-x    1 zookeepe zookeepe      1089 Mar 27 04:32 zkServer.cmd\n-rwxr-xr-x    1 zookeepe zookeepe      6773 Mar 27 04:32 zkServer.sh\n</code></pre>\n<h4>3. 通过 zkCli 进入 Zookeeper 管理界面</h4>\n<p>由于是通过 Docker 启动，Zookeeper 进程已经启动，并通过 2181 端口对外提供服务。</p>\n<pre><code class=\"language-shell\">bash-4.4# ps\nPID   USER     TIME  COMMAND\n    1 zookeepe  0:02 /usr/lib/jvm/java-1.8-openjdk/jre/bin/java -Dzookeeper.log.dir=. -Dzookeeper.root\n   32 root      0:00 bash\n   42 root      0:00 ps\n</code></pre>\n<p>因此可以直接通过 <code>zkCli</code> 来访问 Zookeeper 的控制台来进行管理。</p>\n<pre><code class=\"language-shell\">bash-4.4# bin/zkCli.sh -server 127.0.0.1:2181\nConnecting to 127.0.0.1:2181\n...\nWATCHER::\n\nWatchedEvent state:SyncConnected type:None path:null\n\n[zk: 127.0.0.1:2181(CONNECTED) 0] help\nZooKeeper -server host:port cmd args\n\tstat path [watch]\n\tset path data [version]\n\tls path [watch]\n\tdelquota [-n|-b] path\n\tls2 path [watch]\n\tsetAcl path acl\n\tsetquota -n|-b val path\n\thistory\n\tredo cmdno\n\tprintwatches on|off\n\tdelete path [version]\n\tsync path\n\tlistquota path\n\trmr path\n\tget path [watch]\n\tcreate [-s] [-e] path data acl\n\taddauth scheme auth\n\tquit\n\tgetAcl path\n\tclose\n\tconnect host:port\n</code></pre>\n<h4>4. zkCli 上的一些基本操作</h4>\n<p>创建 <code>/hello-zone</code> 节点：</p>\n<pre><code class=\"language-shell\">[zk: 127.0.0.1:2181(CONNECTED) 19] create /hello-zone 'world'\nCreated /hello-zone\n</code></pre>\n<p>列出 <code>/</code> 下的子节点，确认 <code>hello-zone</code> 被创建：</p>\n<pre><code class=\"language-shell\">[zk: 127.0.0.1:2181(CONNECTED) 20] ls /\n[zookeeper, hello-zone]\n</code></pre>\n<p>列出 <code>/hello-zone</code> 的子节点，确认为空：</p>\n<pre><code class=\"language-shell\">[zk: 127.0.0.1:2181(CONNECTED) 21] ls /hello-zone\n[]\n</code></pre>\n<p>获取存储在 <code>/hello-zone</code> 节点上的数据：</p>\n<pre><code class=\"language-shell\">[zk: 127.0.0.1:2181(CONNECTED) 22] get /hello-zone\nworld\n</code></pre>\n<h2>在 Dubbo 中使用 Zookeeper</h2>\n<p>Dubbo 使用 Zookeeper 用于服务的注册发现和配置管理，在 Zookeeper 中数据的组织由下图所示：</p>\n<p><img src=\"../../img/blog/dubbo-in-zk.jpg\" alt=\"dubbo-in-zk\"></p>\n<p>首先，所有 Dubbo 相关的数据都组织在 <code>/duboo</code> 的根节点下。</p>\n<p>二级目录是服务名，如 <code>com.foo.BarService</code>。</p>\n<p>三级目录有两个子节点，分别是 <code>providers</code> 和 <code>consumers</code>，表示该服务的提供者和消费者。</p>\n<p>四级目录记录了与该服务相关的每一个应用实例的 URL 信息，在 <code>providers</code> 下的表示该服务的所有提供者，而在 <code>consumers</code> 下的表示该服务的所有消费者。举例说明，<code>com.foo.BarService</code> 的服务提供者在启动时将自己的 URL 信息注册到 <code>/dubbo/com.foo.BarService/providers</code> 下；同样的，服务消费者将自己的信息注册到相应的 <code>consumers</code> 下，同时，服务消费者会订阅其所对应的 <code>providers</code> 节点，以便能够感知到服务提供方地址列表的变化。</p>\n<h3>准备示例代码</h3>\n<p>本文的代码可以在 <a href=\"https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-zookeeper\">https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-zookeeper</a> 中找到。</p>\n<h4>1. 接口定义</h4>\n<p>定义一个简单的 <code>GreetingService</code> 接口，里面只有一个简单的方法 <code>sayHello</code> 向调用者问好。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">GreetingService</span> </span>{\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span></span>;\n}\n</code></pre>\n<h4>2. 服务端：服务实现</h4>\n<p>实现 <code>GreetingService</code> 接口，并通过 <code>@Service</code> 来标注其为 Dubbo 的一个服务。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Service</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AnnotatedGreetingService</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">GreetingService</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello, \"</span> + name;\n    }\n}\n</code></pre>\n<h4>3. 服务端：组装</h4>\n<p>定义 ProviderConfiguration 来组装 Dubbo 服务。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@EnableDubbo</span>(scanBasePackages = <span class=\"hljs-string\">\"com.alibaba.dubbo.samples.impl\"</span>)\n<span class=\"hljs-meta\">@PropertySource</span>(<span class=\"hljs-string\">\"classpath:/spring/dubbo-provider.properties\"</span>)\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProviderConfiguration</span> </span>{}\n</code></pre>\n<p>dubbo-provider.properties 是在 Spring 应用中外置配置的方式，内容如下：</p>\n<pre><code class=\"language-properties\">dubbo.application.name=demo-provider\ndubbo.registry.address=zookeeper://$DOCKER_HOST:2181\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20880\n</code></pre>\n<p>由于 Zookeeper 运行在 Docker 容器中，需要注意的是：</p>\n<ul>\n<li>本文假定 Dubbo 应用运行在宿主机上，也就是 Docker 容器外，需要将 Zookeeper 的地址替换成环境变量 <em>${DOCKER_HOST}</em> 所指定的 IP 地址，相关信息请查阅 Docker 官方文档</li>\n<li>如果 Dubbo 应用也是 Docker 化的应用，只需要用 Zookeeper 的容器名，在本文中容器名是 <strong>zookeeper</strong></li>\n<li>当然，如果不用容器方式启动 Zookeeper，只需要简单的将这里的 <em>$DOCKER_HOST</em> 换成 <strong>localhost</strong> 即可</li>\n</ul>\n<h4>4. 服务端：启动服务</h4>\n<p>在 <code>main</code> 方法中通过启动一个 Spring Context 来对外提供 Dubbo 服务。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProviderBootstrap</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        AnnotationConfigApplicationContext context = <span class=\"hljs-keyword\">new</span> AnnotationConfigApplicationContext(ProviderConfiguration.class);\n        context.start();\n        System.in.read();\n    }\n}\n</code></pre>\n<p>启动服务端的 <code>main</code> 方法，将会看到下面的输出，代表服务端启动成功，并在注册中心（ZookeeperRegistry）上注册了 <code>GreetingService</code> 这个服务：</p>\n<pre><code class=\"language-sh\">[03/08/18 10:50:33:033 CST] main  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Register: dubbo://192.168.99.1:20880/com.alibaba.dubbo.samples.api.GreetingService?anyhost=<span class=\"hljs-literal\">true</span>&amp;application=demo-provider&amp;dubbo=2.6.2&amp;generic=<span class=\"hljs-literal\">false</span>&amp;interface=com.alibaba.dubbo.samples.api.GreetingService&amp;methods=sayHello&amp;pid=12938&amp;side=provider&amp;timestamp=1533264631849, dubbo version: 2.6.2, current host: 192.168.99.1\n</code></pre>\n<p>通过 Zookeeper 管理终端观察服务提供方的注册信息：</p>\n<pre><code class=\"language-sh\">$ docker <span class=\"hljs-built_in\">exec</span> -it zookeeper bash\nbash-4.4<span class=\"hljs-comment\"># bin/zkCli.sh -server localhost:218</span>\nConnecting to localhost:2181\n...\nWelcome to ZooKeeper!\nJLine support is enabled\n...\n[zk: localhost:2181(CONNECTED) 0] ls /dubbo/com.alibaba.dubbo.samples.api.GreetingService/providers\n[dubbo%3A%2F%2F192.168.99.1%3A20880%2Fcom.alibaba.dubbo.samples.api.GreetingService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26dubbo%3D2.6.2%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.samples.api.GreetingService%26methods%3DsayHello%26pid%3D12938%26side%3Dprovider%26timestamp%3D1533264631849]\n</code></pre>\n<p>可以看到刚刚启动的 Dubbo 的服务在 <code>providers</code> 节点下注册了自己的 URL 地址：<em>dubbo://192.168.99.1:20880/com.alibaba.dubbo.samples.api.GreetingService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.6.2&amp;generic=false&amp;interface=com.alibaba.dubbo.samples.api.GreetingService&amp;methods=sayHello&amp;pid=12938&amp;side=provider&amp;timestamp=1533264631849</em></p>\n<h4>5. 客户端：引用服务</h4>\n<p>通过 <code>@Reference</code> 来在客户端声明服务的引用，运行时将会通过该引用发起全程调用，而服务的目标地址将会从 Zookeeper 的 <code>provider</code> 节点下查询。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Component</span>(<span class=\"hljs-string\">\"annotatedConsumer\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GreetingServiceConsumer</span> </span>{\n    <span class=\"hljs-meta\">@Reference</span>\n    <span class=\"hljs-keyword\">private</span> GreetingService greetingService;\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">doSayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> greetingService.sayHello(name);\n    }\n}\n</code></pre>\n<h4>6. 客户端：组装</h4>\n<p>定义 ConsumerConfiguration 来组装 Dubbo 服务。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@EnableDubbo</span>(scanBasePackages = <span class=\"hljs-string\">\"com.alibaba.dubbo.samples.action\"</span>)\n<span class=\"hljs-meta\">@PropertySource</span>(<span class=\"hljs-string\">\"classpath:/spring/dubbo-consumer.properties\"</span>)\n<span class=\"hljs-meta\">@ComponentScan</span>(value = {<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.action\"</span>})\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConsumerConfiguration</span> </span>{}\n</code></pre>\n<p>dubbo-consumer.properties 是在 Spring 应用中外置配置的方式，内容如下：</p>\n<pre><code class=\"language-properties\">dubbo.application.name=demo-consumer\ndubbo.registry.address=zookeeper://$DOCKER_HOST:2181\ndubbo.consumer.timeout=3000\n</code></pre>\n<p>与 <strong>3. 服务端：组装</strong> 相同，需要根据自己的运行环境来修改 <em>dubbo.registry.address</em> 中定义的 <em>$DOCKER_HOST</em>。请参阅步骤 3 的说明部分。</p>\n<h4>7. 客户端：发起远程调用</h4>\n<p>运行 <code>main</code> 向已经启动的服务提供方发起一次远程调用。Dubbo 会先向 Zookeeper 订阅服务地址，然后从返回的地址列表中选取一个，向对端发起调用：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConsumerBootstrap</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConsumerBootstrap</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        AnnotationConfigApplicationContext context = <span class=\"hljs-keyword\">new</span> AnnotationConfigApplicationContext(ConsumerConfiguration.class);\n        context.start();\n        GreetingServiceConsumer greetingServiceConsumer = context.getBean(GreetingServiceConsumer.class);\n        String hello = greetingServiceConsumer.doSayHello(<span class=\"hljs-string\">\"zookeeper\"</span>);\n        System.out.println(<span class=\"hljs-string\">\"result: \"</span> + hello);\n        System.in.read();\n    }\n}\n</code></pre>\n<p>运行结果如下：</p>\n<pre><code class=\"language-shell\">[03/08/18 01:42:31:031 CST] main  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Register: consumer://192.168.99.1/com.alibaba.dubbo.samples.api.GreetingService?application=demo-consumer&amp;category=consumers&amp;check=false&amp;default.timeout=3000&amp;dubbo=2.6.2&amp;interface=com.alibaba.dubbo.samples.api.GreetingService&amp;methods=sayHello&amp;pid=82406&amp;side=consumer&amp;timestamp=1533274951195, dubbo version: 2.6.2, current host: 192.168.99.1 #1\n[03/08/18 01:42:31:031 CST] main  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Subscribe: consumer://192.168.99.1/com.alibaba.dubbo.samples.api.GreetingService?application=demo-consumer&amp;category=providers,configurators,routers&amp;default.timeout=3000&amp;dubbo=2.6.2&amp;interface=com.alibaba.dubbo.samples.api.GreetingService&amp;methods=sayHello&amp;pid=82406&amp;side=consumer&amp;timestamp=1533274951195, dubbo version: 2.6.2, current host: 192.168.99.1 #2\n...\nresult: hello, zookeeper\n</code></pre>\n<p>说明：</p>\n<ol>\n<li><strong>Register</strong>: consumer://192.168.99.1/...&amp;<strong>category=consumers</strong>&amp;：消费者向 Zookeeper 注册自己的信息，并放在 <code>consumers</code> 节点下</li>\n<li><strong>Subscribe</strong>: consumer://192.168.99.1/...&amp;<strong>category=providers,configurators,routers</strong>&amp;：消费者同时向 Zookeeper 订阅了 <code>providers</code>、<code>configurators</code>、<code>routers</code> 节点，其中 <code>configurations</code> 与 Dubbo 配置相关，<code>routers</code> 与路由规则相关，值得注意的是 <code>providers</code> 节点的订阅，当有新的服务提供方加入后，由于订阅的关系，新的地址列表会推送给订阅方，服务的消费者也因此动态感知到了地址列表的变化。</li>\n</ol>\n<p>通过 Zookeeper 管理终端观察服务提供方的注册信息：</p>\n<pre><code class=\"language-sh\">$ docker <span class=\"hljs-built_in\">exec</span> -it zookeeper bash\nbash-4.4<span class=\"hljs-comment\"># bin/zkCli.sh -server localhost:218</span>\nConnecting to localhost:2181\n...\nWelcome to ZooKeeper!\nJLine support is enabled\n...\n[zk: localhost:2181(CONNECTED) 4] ls /dubbo/com.alibaba.dubbo.samples.api.GreetingService/consumers\n[consumer%3A%2F%2F192.168.99.1%2Fcom.alibaba.dubbo.samples.api.GreetingService%3Fapplication%3Ddemo-consumer%26category%3Dconsumers%26check%3Dfalse%26default.timeout%3D3000%26dubbo%3D2.6.2%26interface%3Dcom.alibaba.dubbo.samples.api.GreetingService%26methods%3DsayHello%26pid%3D82406%26side%3Dconsumer%26timestamp%3D1533274951195]\n</code></pre>\n<p>可以看到 Dubbo 的服务消费者在 <code>consumers</code> 节点下注册了自己的 URL 地址：<em>consumer://192.168.99.1/com.alibaba.dubbo.samples.api.GreetingService?application=demo-consumer&amp;category=providers,configurators,routers&amp;default.timeout=3000&amp;dubbo=2.6.2&amp;interface=com.alibaba.dubbo.samples.api.GreetingService&amp;methods=sayHello&amp;pid=82406&amp;side=consumer&amp;timestamp=1533274951195</em></p>\n<h2>总结</h2>\n<p>本文侧重介绍了如何在 Dubbo 应用中使用 Zookeeper 做为注册中心，当然，本文也提到了 Zookeeper 在 Dubbo 的应用场景下还承担了配置中心和服务治理的职责。本文中的 Zookeeper 是单节点、Standalone 的模式，在生产环境中为了高可用的诉求，往往会组件 Zookeeper 集群，也就是 <em>Zookeeper ensemble</em> 模式。</p>\n<p>通过本文的学习，读者可以掌握到：</p>\n<ul>\n<li>Zookeeper 的基本概念和基本用法</li>\n<li>Zookeeper 在 Dubbo 应用中的作用</li>\n<li>通过实战了解 Zookeeper 与 Dubbo 的交互</li>\n<li>Dubbo 在 Zookeeper 中服务注册、消费信息的存储方式</li>\n</ul>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://www.ixiacom.com/company/blog/apache-zab%E2%80%94zookeeper-atomic-broadcast-protocol\">https://www.ixiacom.com/company/blog/apache-zab—zookeeper-atomic-broadcast-protocol</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p><a href=\"https://www.apache.org/dyn/closer.cgi/zookeeper/\">https://www.apache.org/dyn/closer.cgi/zookeeper/</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p><a href=\"https://brew.sh\">https://brew.sh</a> <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p><a href=\"https://www.docker.com/community-edition\">https://www.docker.com/community-edition</a> <a href=\"#fnref4\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n"
    },
    {
      "filename": "dubbo2-js.md",
      "__html": "<h1>从跨语言调用到dubbo2.js</h1>\n<blockquote>\n<p><a href=\"https://github.com/dubbo/dubbo2.js\">dubbo2.js</a> 是 <a href=\"https://www.qianmi.com/\">千米网</a> 贡献给 dubbo 社区的一款 nodejs dubbo 客户端，它提供了 nodejs 对原生 dubbo 协议的支持，使得 nodejs 和 java 这两种异构语言的 rpc 调用变得便捷，高效。</p>\n</blockquote>\n<h2>微服务跨语言调用</h2>\n<p>微服务架构已成为目前互联网架构的趋势，关于微服务的讨论，几乎占据了各种技术大会的绝大多数版面。国内使用最多的服务治理框架非阿里开源的 dubbo 莫属，千米网也选择了 dubbo 作为微服务治理框架。另一方面，和大多数互联网公司一样，千米的开发语言是多样的，大多数后端业务由 java 支撑，而每个业务线有各自开发语言的选择权，便出现了 nodejs，python，go 多语言调用的问题。\n跨语言调用是一个很大的话题，也是一个很有挑战的技术活，目前业界经常被提及的解决方案有如下几种，不妨拿出来老生常谈一番：</p>\n<ul>\n<li>spring cloud。spring cloud 提供了一整套微服务开发组件，它主要面向 java 开发，但由于其使用的协议是基于 restful 风格的 http 协议，这使得其天然具备跨语言能力，异构语言只需要提供 http 客户端，便可以实现跨语言调用。</li>\n<li>service mesh。号称下一代微服务框架的 service mesh，其解决跨语言问题的核心在于 SideCar ，SideCar 在 service mesh 的发展过程中概念不断的迁移，但本质都是完成了一件事：处理服务间通信，负责实现请求的可靠传递。</li>\n<li>motan。<a href=\"https://github.com/weibocom/motan\">motan</a> 是新浪微博开源的一款跨语言服务治理框架，在其早期版本中仅支持 motan-java，随着版本演进，在目前最新版本(1.1.0)中，提供了 motan-go，motan-php，motan-openresty 等跨语言特性。类似于 service mesh 中的 SideCar，motan 借助于 motan-go 作为 agent 完成协议的转发，并且依赖于定制协议：motan2，实现跨语言调用。</li>\n</ul>\n<p>当我们再聊跨语言调用时我们在聊什么？纵观上述几个较为通用，成熟的解决方案，可以得出结论：解决跨语言调用的思路无非是两种：</p>\n<ul>\n<li>寻找一个通用的协议</li>\n<li>使用 agent 完成协议的适配</li>\n</ul>\n<p>如果一个新型的团队面临技术选型，我认为上述的方案都可以纳入参考，可考虑到遗留系统的兼容性问题</p>\n<ul>\n<li>旧系统的迁移成本</li>\n</ul>\n<p>这也关键的选型因素。我们做出的第一个尝试，便是在 RPC 协议上下功夫。</p>\n<h2>通用协议的跨语言支持</h2>\n<h3>springmvc的美好时代</h3>\n<p><img src=\"../../img/blog/springmvc.png\" alt=\"springmvc\"></p>\n<p>在没有实现真正的跨语言调用之前，想要实现“跨语言”大多数方案是使用 http 协议做一层转换，最常见的手段莫过于借助 springmvc 提供的 controller/restController，间接调用 dubbo provider。这种方案的优势和劣势显而易见</p>\n<ul>\n<li>优势是简单，是最通俗的解决方案。</li>\n<li>劣势是使得调用链路变长，tcp 通信之上又多了一层 http 通信；开发体验差，为了将 rpc 接口暴露出去，需要额外编写一份 controller 层的代码。</li>\n</ul>\n<h3>通用协议的支持</h3>\n<p>事实上，大多数服务治理框架都支持多种协议，dubbo 框架除默认的 dubbo 协议之外，还有当当网扩展的 <a href=\"https://dangdangdotcom.github.io/dubbox/rest.html\">rest</a> 协议和千米网扩展的 <a href=\"https://github.com/apache/incubator-dubbo-rpc-jsonrpc\">json-rpc</a> 协议可供选择。这两者都是通用的跨语言协议。</p>\n<p>rest 协议为满足 JAX-RS 2.0 标准规范，在开发过程中引入了 @Path，@POST，@GET 等注解，习惯于编写传统 rpc 接口的人可能不太习惯 rest 风格的 rpc 接口。一方面这样会影响开发体验，另一方面，独树一帜的接口风格使得它与其他协议不太兼容，旧接口的共生和迁移都无法实现。如果没有遗留系统，rest 协议无疑是跨语言方案最简易的实现，绝大多数语言支持 rest 协议。</p>\n<p>和 rest 协议类似，json-rpc 的实现也是文本序列化&amp;http 协议。dubbox 在 restful 接口上已经做出了尝试，但是 rest 架构和 dubbo 原有的 rpc 架构是有区别的，rest 架构需要对资源(Resources)进行定义， 需要用到 http 协议的基本操作 GET、POST、PUT、DELETE。在我们看来，restful 更合适互联网系统之间的调用，而 rpc 更适合一个系统内的调用。使用 json-rpc 协议使得旧接口得以兼顾，开发习惯仍旧保留，同时获得了跨语言的能力。</p>\n<p>千米网在早期实践中采用了 json-rpc 作为 dubbo 的跨语言协议实现，并开源了基于 json-rpc 协议下的 python 客户端 <a href=\"https://github.com/dubbo/dubbo-client-py\">dubbo-client-py</a> 和 node 客户端 <a href=\"https://github.com/QianmiOpen/dubbo-node-client\">dubbo-node-client</a>，使用 python 和 nodejs 的小伙伴可以借助于它们直接调用 dubbo-provider-java 提供的 rpc 服务。系统中大多数 java 服务之间的互相调用还是以 dubbo 协议为主，考虑到新旧协议的适配，在不影响原有服务的基础上，我们配置了双协议。</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"dubbo\"</span> <span class=\"hljs-attr\">port</span>=<span class=\"hljs-string\">\"20880\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"jsonrpc\"</span> <span class=\"hljs-attr\">port</span>=<span class=\"hljs-string\">\"8080\"</span> /&gt;</span>\n</code></pre>\n<p>dubbo 协议主要支持 java 间的相互调用，适配老接口；json-rpc 协议主要支持异构语言的调用。</p>\n<h3>定制协议的跨语言支持</h3>\n<p>微服务框架所谓的协议(protocol)可以简单理解为：报文格式和序列化方案。服务治理框架一般都提供了众多的协议配置项供使用者选择，除去上述两种通用协议，还存在一些定制化的协议，如 dubbo 框架的默认协议：dubbo 协议以及 motan 框架提供的跨语言协议：motan2。</p>\n<h4>motan2协议的跨语言支持</h4>\n<p><img src=\"../../img/blog/motan-protocol.png\" alt=\"motan2\"></p>\n<p>motan2 协议被设计用来满足跨语言的需求主要体现在两个细节中—MetaData 和 motan-go。在最初的 motan 协议中，协议报文仅由 Header+Body 组成，这样导致 path，param，group 等存储在 Body 中的数据需要反序列得到，这对异构语言来说是很不友好的，所以在 motan2 中修改了协议的组成；weibo 开源了 <a href=\"https://github.com/weibocom/motan-go/\">motan-go</a> ，<a href=\"https://github.com/weibocom/motan-php\">motan-php</a>，<a href=\"https://github.com/weibocom/motan-openresty\">motan-openresty</a> ,并借助于 motan-go 充当了 agent 这一翻译官的角色，使用 simple 序列化方案来序列化协议报文的 Body 部分（simple 序列化是一种较弱的序列化方案）。</p>\n<p><img src=\"../../img/blog/motan-agent.png\" alt=\"agent\"></p>\n<p>仔细揣摩下可以发现这么做和双协议的配置区别并不是大，只不过这里的 agent 是隐式存在的，与主服务共生。明显的区别在于 agent 方案中异构语言并不直接交互。</p>\n<h4>dubbo协议的跨语言支持</h4>\n<p>dubbo 协议设计之初只考虑到了常规的 rpc 调用场景，它并不是为跨语言而设计，但跨语言支持从来不是只有支持、不支持两种选择，而是要按难易</p>\n<p>程度来划分。是的，dubbo 协议的跨语言调用可能并不好做，但并非无法实现。千米网便实现了这一点，nodejs 构建的前端业务是异构语言的主战场，最终实现了 dubbo2.js，打通了 nodejs 和原生 dubbo 协议。作为本文第二部分的核心内容，重点介绍下我们使用 dubbo2.js 干了什么事。</p>\n<h5>Dubbo协议报文格式</h5>\n<p><img src=\"../../img/blog/dubbo-protocol.png\" alt=\"dubbo协议\"></p>\n<p>dubbo协议报文消息头详解：</p>\n<ul>\n<li>magic：类似java字节码文件里的魔数，用来判断是不是 dubbo 协议的数据包。魔数是常量 0xdabb</li>\n<li>flag：标志位, 一共8个地址位。低四位用来表示消息体数据用的序列化工具的类型（默认 hessian），高四位中，第一位为 1 表示是 request 请求，第二位为 1 表示双向传输（即有返回 response），第三位为 1 表示是心跳 ping 事件。</li>\n<li>status：状态位, 设置请求响应状态，dubbo 定义了一些响应的类型。具体类型见<code>com.alibaba.dubbo.remoting.exchange.Response</code></li>\n<li>invoke id：消息 id, long 类型。每一个请求的唯一识别 id（由于采用异步通讯的方式，用来把请求 request 和返回的 response 对应上）</li>\n<li>body length：消息体 body 长度, int 类型，即记录 Body Content 有多少个字节</li>\n<li>body content：请求参数，响应参数的抽象序列化之后存储于此。</li>\n</ul>\n<p>协议报文最终都会变成字节，使用 tcp 传输，任何语言只要支持网络模块，有类似 Socket 之类的封装，那么通信就不成问题。那，跨语言难在哪儿？以其他语言调用 java 来说，主要有两个难点：</p>\n<ol>\n<li>异构语言如何表示 java 中的数据类型，特别是动态语言，可能不存在严格的数据类型</li>\n<li>序列化方案如何做到跨语言</li>\n</ol>\n<h2>dubbo2.js解决方案</h2>\n<p>上面我们分析出了两个难点，dubbo2.js 解决这两个问题的关键依赖于两个类库：<a href=\"https://github.com/node-modules/js-to-java\">js-to-java</a>，<a href=\"https://github.com/node-modules/hessian.js\">hessian.js</a> 。js-to-java 使得 nodejs 具备 java 对象的表达能力，而 hessian.js 提供了序列化能力。借助于 nodejs 的 socket ，妇科一套 dubbo 协议的报文格式，最终便实现了 nodejs 对 java-dubbo-provider 的调用。</p>\n<h2>dubbo2.js快速入门</h2>\n<p>为了让对 dubbo2.js 感兴趣的读者有一个直观的体验，本节呈现一个快速入门示例，让你体会到使用 dubbo2.js 调用 dubbo 服务是一件多么轻松的事。</p>\n<h3>1. 创建 dubbo-java-provider</h3>\n<p>后端 dubbo 服务使用 java 来提供，这服务大多数的业务场景。首先定义服务接口：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">DemoProvider</span> </span>{\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span></span>;\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">echo</span><span class=\"hljs-params\">()</span> </span>;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span>;\n    <span class=\"hljs-function\">UserResponse <span class=\"hljs-title\">getUserInfo</span><span class=\"hljs-params\">(UserRequest request)</span></span>;\n}\n</code></pre>\n<p>其次，实现服务：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoProviderImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">DemoProvider</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"[\"</span> + <span class=\"hljs-keyword\">new</span> SimpleDateFormat(<span class=\"hljs-string\">\"HH:mm:ss\"</span>).format(<span class=\"hljs-keyword\">new</span> Date()) + <span class=\"hljs-string\">\"] Hello \"</span> + name + <span class=\"hljs-string\">\", request from consumer: \"</span> + RpcContext.getContext().getRemoteAddress());\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Hello \"</span> + name + <span class=\"hljs-string\">\", response form provider: \"</span> + RpcContext.getContext().getLocalAddress();\n    }\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">echo</span><span class=\"hljs-params\">()</span>  </span>{\n        System.out.println(<span class=\"hljs-string\">\"receive....\"</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"pang\"</span>;\n    }\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"test\"</span>);\n    }\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> UserResponse <span class=\"hljs-title\">getUserInfo</span><span class=\"hljs-params\">(UserRequest request)</span> </span>{\n        System.out.println(request);\n        UserResponse response = <span class=\"hljs-keyword\">new</span> UserResponse();\n        response.setStatus(<span class=\"hljs-string\">\"ok\"</span>);\n        Map&lt;String, String&gt; map = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, String&gt;();\n        map.put(<span class=\"hljs-string\">\"id\"</span>, <span class=\"hljs-string\">\"1\"</span>);\n        map.put(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"test\"</span>);\n        response.setInfo(map);\n        <span class=\"hljs-keyword\">return</span> response;\n    }\n}\n</code></pre>\n<p>暴露服务：</p>\n<pre><code class=\"language-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span> <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n       <span class=\"hljs-attr\">xmlns:dubbo</span>=<span class=\"hljs-string\">\"http://code.alibabatech.com/schema/dubbo\"</span>\n       <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans\"</span>\n       <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n   http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"</span>&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:application</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"demo-provider\"</span>/&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:registry</span> <span class=\"hljs-attr\">protocol</span>=<span class=\"hljs-string\">\"zookeeper\"</span> <span class=\"hljs-attr\">address</span>=<span class=\"hljs-string\">\"localhost:2181\"</span>/&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"dubbo\"</span> <span class=\"hljs-attr\">port</span>=<span class=\"hljs-string\">\"20880\"</span>/&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- 和本地bean一样实现服务 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demoProvider\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"com.alibaba.dubbo.demo.provider.DemoProviderImpl\"</span>/&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- 声明需要暴露的服务接口 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.alibaba.dubbo.demo.DemoProvider\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"demoProvider\"</span> <span class=\"hljs-attr\">version</span>=<span class=\"hljs-string\">\"1.0.0\"</span>/&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n</code></pre>\n<p>我们完成了服务端的所有配置，启动启动类即可在本地注册一个 dubbo 服务。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Provider</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        ClassPathXmlApplicationContext context = <span class=\"hljs-keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"hljs-keyword\">new</span> String[]{<span class=\"hljs-string\">\"META-INF/spring/dubbo-demo-provider.xml\"</span>});\n        context.start();\n        System.in.read();\n    }\n}\n</code></pre>\n<h3>2. 实现 nodejs 的 dubbo 客户端</h3>\n<p>安装 dubbo2.js：</p>\n<pre><code class=\"language-sh\">npm install dubbo2.js --save\n</code></pre>\n<p>配置 dubboConfig.ts：</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { Dubbo, java, TDubboCallResult } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'dubbo2.js'</span>\n\n<span class=\"hljs-keyword\">const</span> dubbo = <span class=\"hljs-keyword\">new</span> Dubbo({\n  application: {name: <span class=\"hljs-string\">'demo-provider'</span>},\n  register: <span class=\"hljs-string\">'localhost:2181'</span>,\n  dubboVersion: <span class=\"hljs-string\">'2.0.0'</span>,\n  interfaces: [\n    <span class=\"hljs-string\">'com.alibaba.dubbo.demo.DemoProvider'</span>,\n  ],\n});\n\n<span class=\"hljs-keyword\">interface</span> IDemoService {\n  sayHello(name: <span class=\"hljs-built_in\">string</span>): TDubboCallResult&lt;<span class=\"hljs-built_in\">string</span>&gt;;\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> demoService = dubbo.proxyService&lt;IDemoService&gt;({\n  dubboInterface: <span class=\"hljs-string\">'com.alibaba.dubbo.demo.DemoProvider'</span>,\n  version: <span class=\"hljs-string\">'1.0.0'</span>,\n  methods: {\n    sayHello(name: <span class=\"hljs-built_in\">string</span>) {\n      <span class=\"hljs-keyword\">return</span> [java.String(name)];\n    },\n\n    echo() {},\n\n    test() {},\n\n    getUserInfo() {\n      <span class=\"hljs-keyword\">return</span> [\n        java.combine(<span class=\"hljs-string\">'com.alibaba.dubbo.demo.UserRequest'</span>, {\n          id: <span class=\"hljs-number\">1</span>,\n          name: <span class=\"hljs-string\">'nodejs'</span>,\n          email: <span class=\"hljs-string\">'node@qianmi.com'</span>,\n        }),\n      ];\n    },\n  },\n});\n</code></pre>\n<blockquote>\n<p>使用 typescript 可以带来更好的开发体验。</p>\n</blockquote>\n<p>编写调用类 main.ts：</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> {demoService} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./dubboConfig'</span>\n\ndemoService.sayHello(<span class=\"hljs-string\">'kirito'</span>).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">{res,err}</span>)=&gt;</span>{\n    <span class=\"hljs-built_in\">console</span>.log(res)\n});\n</code></pre>\n<h3>3. 执行调用</h3>\n<p>Debug 模式启动 nodejs 客户端：</p>\n<pre><code class=\"language-sh\">DEBUG=dubbo* ts-node main.ts\n</code></pre>\n<p>查看运行结果：</p>\n<pre><code class=\"language-sh\">Hello kirito, response form provider: 172.19.6.151:20880\n</code></pre>\n<p>Congratulation！</p>\n<h2>dubbo2.js特性</h2>\n<ul>\n<li>支持 zookeeper 注册中心</li>\n<li>支持原生 dubbo 协议</li>\n<li>支持服务直连</li>\n<li>全链路跟踪</li>\n<li>dubbo 接口自动生成</li>\n</ul>\n<h2>更多细节</h2>\n<p>本文中的示例代码，提供在此处，<a href=\"https://github.com/lexburner/Dubbojs-Learning\">https://github.com/lexburner/Dubbojs-Learning</a> 。如果你对 dubbo 协议不慎了解，想要理解它的工作原理，项目中提供了一个子 moudle — java-socket-consumer，使用面向过程的思路实现了 java-socket-consumer，完成了原生 socket 发送 dubbo 协议报文，完成方法调用，并获取响应的全流程。</p>\n"
    },
    {
      "filename": "introduction-to-dubbo-qos.md",
      "__html": "<h1>通过QoS对服务进行动态控制</h1>\n<p>QoS，全称为<code>Quality of Service</code>, 是常见于网络设备中的一个术语 ，例如在路由器中，可以通过Qos动态的调整和控制某些端口的权重，从优先的保障运行在这些端口上的服务质量。</p>\n<p>在Dubbo中，QoS这个概念被用于动态的对服务进行查询和控制。例如对获取当前提供和消费的所有服务，以及对服务进行动态的上下线，即从注册中心上进行注册和反注册操作。</p>\n<h3>QoS工作机制</h3>\n<p>从Dubbo 2.5.8开始，默认引入了Qos功能，默认处于启动状态。所有的QoS功能被抽象成一个个的命令，通过执行这些命令，Qos会返回响应的结果。</p>\n<blockquote>\n<p>Qos功能基于Netty4实现，在Dubbo 2.6.x之前的版本中，默认依赖的是Netty3，因此需要显示的添加Netty4的依赖，才能确保Netty4正常工作。如果使用http://start.dubbo.io自动生成的Dubbo应用，则无需添加额外的配置，因为已经默认加上了Netty4的依赖。</p>\n</blockquote>\n<p>Qos的工作机制如下图所示：</p>\n<p><img src=\"../../img/blog/qos-architecture.png\" alt=\"undefined\"></p>\n<ol>\n<li>启动并监听一个端口，默认端口是22222</li>\n<li>识别目标请求的协议是Http或者是Telnet，根据协议不同动态添加对应的处理器</li>\n<li>针对不同的协议进行解码，解析出需要执行的命令</li>\n<li>执行命令并返回结果</li>\n</ol>\n<h3>QoS命令</h3>\n<p>QoS目前支持的命令包括：</p>\n<ul>\n<li>help: 帮助命令，列出</li>\n<li>ls: 列出当前所有的正在提供的服务，以及消费的服务</li>\n<li>online: 动态将某个或全部服务向注册中心进行注册</li>\n<li>offline: 动态将某个或全部服务从注册中心摘除（反注册）</li>\n<li>quit: 退出当前telnet会话</li>\n</ul>\n<p>下面，我们具体来操作一下如何通过用QoS对服务进行动态控制。</p>\n<h4>通过Telnet方式访问QoS</h4>\n<p>假设我们的Dubbo服务端已经启动，我们通过Telnet方式进行连接：</p>\n<pre><code>$ telnet localhost 22222\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\n  ?????????  ???    ??  ???????????  ???????????   ????????\n  ???   ???? ???    ???   ???    ???   ???    ??? ???    ???\n  ???    ??? ???    ???   ???    ???   ???    ??? ???    ???\n  ???    ??? ???    ???  ??????????   ??????????  ???    ???\n  ???    ??? ???    ??? ???????????  ???????????  ???    ???\n  ???    ??? ???    ???   ???    ???   ???    ??? ???    ???\n  ???   ???? ???    ???   ???    ???   ???    ??? ???    ???\n  ?????????  ?????????  ???????????  ???????????   ????????\n\n\ndubbo&gt;\n</code></pre>\n<p>连接成功后，会出现<code>dubbo&gt;</code>提示符，此时输入<code>help</code>命令</p>\n<pre><code>dubbo&gt;help\n+---------+----------------------------------------------------------------------------------+\n|    help | help command                                                                     |\n+---------+----------------------------------------------------------------------------------+\n|      ls | ls service                                                                       |\n+---------+----------------------------------------------------------------------------------+\n| offline | offline dubbo                                                                    |\n+---------+----------------------------------------------------------------------------------+\n|  online | online dubbo                                                                     |\n+---------+----------------------------------------------------------------------------------+\n|    quit | quit telnet console                                                              |\n+---------+----------------------------------------------------------------------------------+\n\ndubbo&gt;\n</code></pre>\n<p>会列出当前所有可用的命令，及相应的说明。</p>\n<p>也可以对单个命令进行help操作，可以看到该命令对应的示例</p>\n<pre><code>dubbo&gt;help online\n+--------------+----------------------------------------------------------------------------------+\n| COMMAND NAME | online                                                                           |\n+--------------+----------------------------------------------------------------------------------+\n|      EXAMPLE | online dubbo                                                                     |\n|              | online xx.xx.xxx.service                                                         |\n+--------------+----------------------------------------------------------------------------------+\n</code></pre>\n<p>通过<code>ls</code> 查看当前的服务状态</p>\n<pre><code>dubbo&gt;ls\nAs Provider side:\n+------------------------------------------+---+\n|           Provider Service Name          |PUB|\n+------------------------------------------+---+\n|org.apache.dubbo.demo.provider.DemoService| Y |\n+------------------------------------------+---+\nAs Consumer side:\n+---------------------+---+\n|Consumer Service Name|NUM|\n+---------------------+---+\n</code></pre>\n<p>可以看到，在服务端可以看到一个服务<code>org.apache.dubbo.demo.provider.DemoService</code>，第二列里面的<code>PUB=Y</code>代表改服务已经发布到注册中心，可供消费端进行调用。</p>\n<p>假设我们需要动态的对该服务进行下线操作，可以通过<code>offline</code>命令来完成</p>\n<pre><code>dubbo&gt;offline org.apache.dubbo.demo.provider.DemoService\nOK\n</code></pre>\n<p>可以看到命令返回了OK，我们再通过ls看下当前的状态：</p>\n<pre><code>dubbo&gt;ls\nAs Provider side:\n+------------------------------------------+---+\n|           Provider Service Name          |PUB|\n+------------------------------------------+---+\n|org.apache.dubbo.demo.provider.DemoService| N |\n+------------------------------------------+---+\nAs Consumer side:\n+---------------------+---+\n|Consumer Service Name|NUM|\n+---------------------+---+\n</code></pre>\n<p>可以看到<code>org.apache.dubbo.demo.provider.DemoService</code>的<code>PUB</code>已经被设置成了<code>N</code>。</p>\n<p>通过<code>quit</code>命令退出当前的telnet会话：</p>\n<pre><code>dubbo&gt;quit\nBYE!\nConnection closed by foreign host.\n</code></pre>\n<h4>通过HTTP方式访问QOS</h4>\n<p>在上面的例子中，我们已经对<code>org.apache.dubbo.demo.provider.DemoService</code>进行了下线操作，下面，我们通过对Http方式对上面的服务进行注册操作：</p>\n<pre><code>$ curl -i http://localhost:22222/online?service=org.apache.dubbo.demo.provider.DemoService\nHTTP/1.1 200 OK\nContent-Type: text/plain\nContent-Length: 2\n\nOK% \n</code></pre>\n<blockquote>\n<p>注意online操作对应的参数，需要以<code>key=value</code>的形式提供，但实际上key会被忽略</p>\n</blockquote>\n<p>看到操作返回了OK，下面通过ls命令查看下当前的状态</p>\n<pre><code>$ curl -i http://localhost:22222/ls\nHTTP/1.1 200 OK\nContent-Type: text/plain\nContent-Length: 365\n\nAs Provider side:\n+------------------------------------------+---+\n|           Provider Service Name          |PUB|\n+------------------------------------------+---+\n|org.apache.dubbo.demo.provider.DemoService| Y |\n+------------------------------------------+---+\nAs Consumer side:\n+---------------------+---+\n|Consumer Service Name|NUM|\n+---------------------+---+\n</code></pre>\n<p>可以看到服务的<code>PUB</code>状态已经变成了<code>Y</code>。</p>\n<h3>QoS相关参数说明</h3>\n<p>QoS提供了一些启动参数，来对启动进行配置，他们主要包括：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>qosEnable</td>\n<td>是否启动QoS</td>\n<td>true</td>\n</tr>\n<tr>\n<td>qosPort</td>\n<td>启动QoS绑定的端口</td>\n<td>22222</td>\n</tr>\n<tr>\n<td>qosAcceptForeignIp</td>\n<td>是否允许远程访问</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>注意，从2.6.4/2.7.0开始，qosAcceptForeignIp默认配置改为false，如果qosAcceptForeignIp设置为true，有可能带来安全风险，请仔细评估后再打开。</p>\n</blockquote>\n<p>QoS参数可以通过如下方式进行配置</p>\n<ul>\n<li>系统属性</li>\n<li>dubbo.properties</li>\n<li>XML方式</li>\n<li>Spring-boot自动装配方式</li>\n</ul>\n<p>其中，上述方式的优先顺序为系统属性 &gt; dubbo.properties &gt; XML/Spring-boot自动装配方式。</p>\n<h4>使用系统属性方式进行配置</h4>\n<pre><code>-Ddubbo.application.qos.enable=true\n-Ddubbo.application.qos.port=33333\n-Ddubbo.application.qos.accept.foreign.ip=false\n</code></pre>\n<h4>使用dubbo.properties文件进行配置</h4>\n<p>在项目的<code>src/main/resources</code>目录下添加dubbo.properties文件，内容如下:</p>\n<pre><code>dubbo.application.qos.enable=true\ndubbo.application.qos.port=33333\ndubbo.application.qos.accept.foreign.ip=false\n</code></pre>\n<h4>使用XML方法进行配置</h4>\n<p>如果要通过XML配置响应的QoS相关的参数，可以进行如下配置：</p>\n<pre><code class=\"language-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">beans</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans\"</span>\n       <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n       <span class=\"hljs-attr\">xmlns:dubbo</span>=<span class=\"hljs-string\">\"http://dubbo.apache.org/schema/dubbo\"</span>\n       <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:application</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"demo-provider\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:parameter</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">\"qos.enable\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"true\"</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:parameter</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">\"qos.accept.foreign.ip\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"false\"</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:parameter</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">\"qos.port\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"33333\"</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dubbo:application</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:registry</span> <span class=\"hljs-attr\">address</span>=<span class=\"hljs-string\">\"multicast://224.5.6.7:1234\"</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"dubbo\"</span> <span class=\"hljs-attr\">port</span>=<span class=\"hljs-string\">\"20880\"</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.provider.DemoService\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"demoService\"</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.provider.DemoServiceImpl\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">beans</span>&gt;</span>\n</code></pre>\n<h4>使用spring-boot自动装配方式配置</h4>\n<p>如果是spring-boot的应用，可以在<code>application.properties</code>或者<code>application.yml</code>上配置:</p>\n<pre><code>dubbo.application.qosEnable=true\ndubbo.application.qosPort=33333\ndubbo.application.qosAcceptForeignIp=false\n</code></pre>\n"
    },
    {
      "filename": "introduction-to-dubbo-spi-2.md",
      "__html": "<h1>Dubbo可扩展机制源码解析</h1>\n<hr>\n<p>在<a href=\"#/blog/introduction-to-dubbo-spi.md\">Dubbo可扩展机制实战</a>中，我们了解了Dubbo扩展机制的一些概念，初探了Dubbo中LoadBalance的实现，并自己实现了一个LoadBalance。是不是觉得Dubbo的扩展机制很不错呀，接下来，我们就深入Dubbo的源码，一睹庐山真面目。</p>\n<h1>ExtensionLoader</h1>\n<p>ExtentionLoader是最核心的类，负责扩展点的加载和生命周期管理。我们就以这个类开始吧。\nExtension的方法比较多，比较常用的方法有:</p>\n<ul>\n<li><code>public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type)</code></li>\n<li><code>public T getExtension(String name)</code></li>\n<li><code>public T getAdaptiveExtension()</code></li>\n</ul>\n<p>比较常见的用法有:</p>\n<ul>\n<li><code>LoadBalance lb = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(loadbalanceName)</code></li>\n<li><code>RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getAdaptiveExtension()</code></li>\n</ul>\n<p>说明：在接下来展示的源码中，我会将无关的代码(比如日志，异常捕获等)去掉，方便大家阅读和理解。</p>\n<ol>\n<li>getExtensionLoader方法\n这是一个静态工厂方法，入参是一个可扩展的接口，返回一个该接口的ExtensionLoader实体类。通过这个实体类，可以根据name获得具体的扩展，也可以获得一个自适应扩展。</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\">ExtensionLoader&lt;T&gt; <span class=\"hljs-title\">getExtensionLoader</span><span class=\"hljs-params\">(Class&lt;T&gt; type)</span> </span>{\n        <span class=\"hljs-comment\">// 扩展点必须是接口</span>\n        <span class=\"hljs-keyword\">if</span> (!type.isInterface()) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"Extension type(\"</span> + type + <span class=\"hljs-string\">\") is not interface!\"</span>);\n        }\n        <span class=\"hljs-comment\">// 必须要有@SPI注解</span>\n        <span class=\"hljs-keyword\">if</span> (!withExtensionAnnotation(type)) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"Extension type without @SPI Annotation!\"</span>);\n        }\n        <span class=\"hljs-comment\">// 从缓存中根据接口获取对应的ExtensionLoader</span>\n        <span class=\"hljs-comment\">// 每个扩展只会被加载一次</span>\n        ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);\n        <span class=\"hljs-keyword\">if</span> (loader == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-comment\">// 初始化扩展</span>\n            EXTENSION_LOADERS.putIfAbsent(type, <span class=\"hljs-keyword\">new</span> ExtensionLoader&lt;T&gt;(type));\n            loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);\n        }\n        <span class=\"hljs-keyword\">return</span> loader;\n    }\n    \n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">ExtensionLoader</span><span class=\"hljs-params\">(Class&lt;?&gt; type)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.type = type;\n        objectFactory = (type == ExtensionFactory.class ? <span class=\"hljs-keyword\">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());\n    }\n</code></pre>\n<ol start=\"2\">\n<li>getExtension方法</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> T <span class=\"hljs-title\">getExtension</span><span class=\"hljs-params\">(String name)</span> </span>{\n        Holder&lt;Object&gt; holder = cachedInstances.get(name);\n        <span class=\"hljs-keyword\">if</span> (holder == <span class=\"hljs-keyword\">null</span>) {\n            cachedInstances.putIfAbsent(name, <span class=\"hljs-keyword\">new</span> Holder&lt;Object&gt;());\n            holder = cachedInstances.get(name);\n        }\n        Object instance = holder.get();\n        <span class=\"hljs-comment\">// 从缓存中获取，如果不存在就创建</span>\n        <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">synchronized</span> (holder) {\n                instance = holder.get();\n                <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n                    instance = createExtension(name);\n                    holder.set(instance);\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> (T) instance;\n    }\n</code></pre>\n<p>getExtention方法中做了一些判断和缓存，主要的逻辑在createExtension方法中。我们继续看createExtention方法。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> T <span class=\"hljs-title\">createExtension</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-comment\">// 根据扩展点名称得到扩展类，比如对于LoadBalance，根据random得到RandomLoadBalance类</span>\n        Class&lt;?&gt; clazz = getExtensionClasses().get(name);\n        \n        T instance = (T) EXTENSION_INSTANCES.get(clazz);\n        <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n              <span class=\"hljs-comment\">// 使用反射调用nesInstance来创建扩展类的一个示例</span>\n            EXTENSION_INSTANCES.putIfAbsent(clazz, (T) clazz.newInstance());\n            instance = (T) EXTENSION_INSTANCES.get(clazz);\n        }\n        <span class=\"hljs-comment\">// 对扩展类示例进行依赖注入</span>\n        injectExtension(instance);\n        <span class=\"hljs-comment\">// 如果有wrapper，添加wrapper</span>\n        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;\n        <span class=\"hljs-keyword\">if</span> (wrapperClasses != <span class=\"hljs-keyword\">null</span> &amp;&amp; !wrapperClasses.isEmpty()) {\n            <span class=\"hljs-keyword\">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) {\n                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> instance;\n}\n</code></pre>\n<p>createExtension方法做了以下事情:</p>\n<ol>\n<li>先根据name来得到对应的扩展类。从ClassPath下<code>META-INF</code>文件夹下读取扩展点配置文件。</li>\n<li>使用反射创建一个扩展类的实例</li>\n<li>对扩展类实例的属性进行依赖注入，即IoC。</li>\n<li>如果有wrapper，添加wrapper。即AoP。</li>\n</ol>\n<p>下面我们来重点看下这4个过程</p>\n<ol>\n<li>根据name获取对应的扩展类\n先看代码:</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() {\n        Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();\n        <span class=\"hljs-keyword\">if</span> (classes == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">synchronized</span> (cachedClasses) {\n                classes = cachedClasses.get();\n                <span class=\"hljs-keyword\">if</span> (classes == <span class=\"hljs-keyword\">null</span>) {\n                    classes = loadExtensionClasses();\n                    cachedClasses.set(classes);\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> classes;\n    }\n\n    <span class=\"hljs-comment\">// synchronized in getExtensionClasses</span>\n    <span class=\"hljs-keyword\">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() {\n        <span class=\"hljs-keyword\">final</span> SPI defaultAnnotation = type.getAnnotation(SPI.class);\n        <span class=\"hljs-keyword\">if</span> (defaultAnnotation != <span class=\"hljs-keyword\">null</span>) {\n            String value = defaultAnnotation.value();\n            <span class=\"hljs-keyword\">if</span> (value != <span class=\"hljs-keyword\">null</span> &amp;&amp; (value = value.trim()).length() &gt; <span class=\"hljs-number\">0</span>) {\n                String[] names = NAME_SEPARATOR.split(value);\n                <span class=\"hljs-keyword\">if</span> (names.length &gt; <span class=\"hljs-number\">1</span>) {\n                    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"more than 1 default extension name on extension \"</span> + type.getName());\n                }\n                <span class=\"hljs-keyword\">if</span> (names.length == <span class=\"hljs-number\">1</span>) cachedDefaultName = names[<span class=\"hljs-number\">0</span>];\n            }\n        }\n\n        Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();\n        loadFile(extensionClasses, DUBBO_INTERNAL_DIRECTORY);\n        loadFile(extensionClasses, DUBBO_DIRECTORY);\n        loadFile(extensionClasses, SERVICES_DIRECTORY);\n        <span class=\"hljs-keyword\">return</span> extensionClasses;\n    }\n</code></pre>\n<p>过程很简单，先从缓存中获取，如果没有，就从配置文件中加载。配置文件的路径就是之前提到的:</p>\n<ul>\n<li><code>META-INF/dubbo/internal</code></li>\n<li><code>META-INF/dubbo</code></li>\n<li><code>META-INF/services</code></li>\n</ul>\n<ol start=\"2\">\n<li>使用反射创建扩展实例\n这个过程很简单，使用<code>clazz.newInstance())</code>来完成。创建的扩展实例的属性都是空值。</li>\n<li>扩展实例自动装配\n在实际的场景中，类之间都是有依赖的。扩展实例中也会引用一些依赖，比如简单的Java类，另一个Dubbo的扩展或一个Spring Bean等。依赖的情况很复杂，Dubbo的处理也相对复杂些。我们稍后会有专门的章节对其进行说明，现在，我们只需要知道，Dubbo可以正确的注入扩展点中的普通依赖，Dubbo扩展依赖或Spring依赖等。</li>\n<li>扩展实例自动包装\n自动包装就是要实现类似于Spring的AOP功能。Dubbo利用它在内部实现一些通用的功能，比如日志，监控等。关于扩展实例自动包装的内容，也会在后面单独讲解。</li>\n</ol>\n<p>经过上面的4步，Dubbo就创建并初始化了一个扩展实例。这个实例的依赖被注入了，也根据需要被包装了。到此为止，这个扩展实例就可以被使用了。</p>\n<h1>Dubbo SPI高级用法之自动装配</h1>\n<p>自动装配的相关代码在injectExtension方法中:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> T <span class=\"hljs-title\">injectExtension</span><span class=\"hljs-params\">(T instance)</span> </span>{\n    <span class=\"hljs-keyword\">for</span> (Method method : instance.getClass().getMethods()) {\n        <span class=\"hljs-keyword\">if</span> (method.getName().startsWith(<span class=\"hljs-string\">\"set\"</span>)\n                &amp;&amp; method.getParameterTypes().length == <span class=\"hljs-number\">1</span>\n                &amp;&amp; Modifier.isPublic(method.getModifiers())) {\n            Class&lt;?&gt; pt = method.getParameterTypes()[<span class=\"hljs-number\">0</span>];\n          \n            String property = method.getName().length() &gt; <span class=\"hljs-number\">3</span> ? method.getName().substring(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>).toLowerCase() + method.getName().substring(<span class=\"hljs-number\">4</span>) : <span class=\"hljs-string\">\"\"</span>;\n            Object object = objectFactory.getExtension(pt, property);\n            <span class=\"hljs-keyword\">if</span> (object != <span class=\"hljs-keyword\">null</span>) {\n                method.invoke(instance, object);\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> instance;\n}\n</code></pre>\n<p>要实现对扩展实例的依赖的自动装配，首先需要知道有哪些依赖，这些依赖的类型是什么。Dubbo的方案是查找Java标准的setter方法。即方法名以set开始，只有一个参数。如果扩展类中有这样的set方法，Dubbo会对其进行依赖注入，类似于Spring的set方法注入。\n但是Dubbo中的依赖注入比Spring要复杂，因为Spring注入的都是Spring bean，都是由Spring容器来管理的。而Dubbo的依赖注入中，需要注入的可能是另一个Dubbo的扩展，也可能是一个Spring Bean，或是Google guice的组件，或其他任何一个框架中的组件。Dubbo需要能够从任何一个场景中加载扩展。在injectExtension方法中，是用<code>Object object = objectFactory.getExtension(pt, property)</code>来实现的。objectFactory是ExtensionFactory类型的，在创建ExtensionLoader时被初始化:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">ExtensionLoader</span><span class=\"hljs-params\">(Class&lt;?&gt; type)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.type = type;\n        objectFactory = (type == ExtensionFactory.class ? <span class=\"hljs-keyword\">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());\n    }\n</code></pre>\n<p>objectFacory本身也是一个扩展，通过<code>ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension())</code>来获取。</p>\n<p><img src=\"https://raw.githubusercontent.com/vangoleo/wiki/master/dubbo/dubbo-extensionfactory.png\" alt=\"Dubbo-ExtensionFactory | left\"></p>\n<p>ExtensionLoader有三个实现：</p>\n<ol>\n<li>SpiExtensionLoader：Dubbo自己的Spi去加载Extension</li>\n<li>SpringExtensionLoader：从Spring容器中去加载Extension</li>\n<li>AdaptiveExtensionLoader: 自适应的AdaptiveExtensionLoader</li>\n</ol>\n<p>这里要注意AdaptiveExtensionLoader，源码如下:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Adaptive</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AdaptiveExtensionFactory</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ExtensionFactory</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> List&lt;ExtensionFactory&gt; factories;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">AdaptiveExtensionFactory</span><span class=\"hljs-params\">()</span> </span>{\n        ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);\n        List&lt;ExtensionFactory&gt; list = <span class=\"hljs-keyword\">new</span> ArrayList&lt;ExtensionFactory&gt;();\n        <span class=\"hljs-keyword\">for</span> (String name : loader.getSupportedExtensions()) {\n            list.add(loader.getExtension(name));\n        }\n        factories = Collections.unmodifiableList(list);\n    }\n\n    <span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">T <span class=\"hljs-title\">getExtension</span><span class=\"hljs-params\">(Class&lt;T&gt; type, String name)</span> </span>{\n        <span class=\"hljs-keyword\">for</span> (ExtensionFactory factory : factories) {\n            T extension = factory.getExtension(type, name);\n            <span class=\"hljs-keyword\">if</span> (extension != <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-keyword\">return</span> extension;\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n    }\n}\n</code></pre>\n<p>AdaptiveExtensionLoader类有@Adaptive注解。前面提到了，Dubbo会为每一个扩展创建一个自适应实例。如果扩展类上有@Adaptive，会使用该类作为自适应类。如果没有，Dubbo会为我们创建一个。所以<code>ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension())</code>会返回一个AdaptiveExtensionLoader实例，作为自适应扩展实例。\nAdaptiveExtentionLoader会遍历所有的ExtensionFactory实现，尝试着去加载扩展。如果找到了，返回。如果没有，在下一个ExtensionFactory中继续找。Dubbo内置了两个ExtensionFactory，分别从Dubbo自身的扩展机制和Spring容器中去寻找。由于ExtensionFactory本身也是一个扩展点，我们可以实现自己的ExtensionFactory，让Dubbo的自动装配支持我们自定义的组件。比如，我们在项目中使用了Google的guice这个IoC容器。我们可以实现自己的GuiceExtensionFactory，让Dubbo支持从guice容器中加载扩展。</p>\n<h1>Dubbo SPI高级用法之AoP</h1>\n<p>在用Spring的时候，我们经常会用到AOP功能。在目标类的方法前后插入其他逻辑。比如通常使用Spring AOP来实现日志，监控和鉴权等功能。\nDubbo的扩展机制，是否也支持类似的功能呢？答案是yes。在Dubbo中，有一种特殊的类，被称为Wrapper类。通过装饰者模式，使用包装类包装原始的扩展点实例。在原始扩展点实现前后插入其他逻辑，实现AOP功能。</p>\n<h3>什么是Wrapper类</h3>\n<p>那什么样类的才是Dubbo扩展机制中的Wrapper类呢？Wrapper类是一个有复制构造函数的类，也是典型的装饰者模式。下面就是一个Wrapper类:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span></span>{\n    <span class=\"hljs-keyword\">private</span> A a;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">A</span><span class=\"hljs-params\">(A a)</span></span>{\n        <span class=\"hljs-keyword\">this</span>.a = a;\n    }\n}\n</code></pre>\n<p>类A有一个构造函数<code>public A(A a)</code>，构造函数的参数是A本身。这样的类就可以成为Dubbo扩展机制中的一个Wrapper类。Dubbo中这样的Wrapper类有ProtocolFilterWrapper, ProtocolListenerWrapper等, 大家可以查看源码加深理解。</p>\n<h3>怎么配置Wrapper类</h3>\n<p>在Dubbo中Wrapper类也是一个扩展点，和其他的扩展点一样，也是在<code>META-INF</code>文件夹中配置的。比如前面举例的ProtocolFilterWrapper和ProtocolListenerWrapper就是在路径<code>dubbo-rpc/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol</code>中配置的:</p>\n<pre><code class=\"language-text\">filter=com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper\nlistener=com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper\nmock=com.alibaba.dubbo.rpc.support.MockProtocol\n</code></pre>\n<p>在Dubbo加载扩展配置文件时，有一段如下的代码:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">try</span> {  \n  clazz.getConstructor(type);    \n  Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;\n  <span class=\"hljs-keyword\">if</span> (wrappers == <span class=\"hljs-keyword\">null</span>) {\n    cachedWrapperClasses = <span class=\"hljs-keyword\">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();\n    wrappers = cachedWrapperClasses;\n  }\n  wrappers.add(clazz);\n} <span class=\"hljs-keyword\">catch</span> (NoSuchMethodException e) {}\n</code></pre>\n<p>这段代码的意思是，如果扩展类有复制构造函数，就把该类存起来，供以后使用。有复制构造函数的类就是Wrapper类。通过<code>clazz.getConstructor(type)</code>来获取参数是扩展点接口的构造函数。注意构造函数的参数类型是扩展点接口，而不是扩展类。\n以Protocol为例。配置文件<code>dubbo-rpc/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol</code>中定义了<code>filter=com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper</code>。\nProtocolFilterWrapper代码如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProtocolFilterWrapper</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Protocol</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Protocol protocol;\n\n    <span class=\"hljs-comment\">// 有一个参数是Protocol的复制构造函数</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ProtocolFilterWrapper</span><span class=\"hljs-params\">(Protocol protocol)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (protocol == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"protocol == null\"</span>);\n        }\n        <span class=\"hljs-keyword\">this</span>.protocol = protocol;\n    }\n</code></pre>\n<p>ProtocolFilterWrapper有一个构造函数<code>public ProtocolFilterWrapper(Protocol protocol)</code>，参数是扩展点Protocol，所以它是一个Dubbo扩展机制中的Wrapper类。ExtensionLoader会把它缓存起来，供以后创建Extension实例的时候，使用这些包装类依次包装原始扩展点。</p>\n<h1>扩展点自适应</h1>\n<p>前面讲到过，Dubbo需要在运行时根据方法参数来决定该使用哪个扩展，所以有了扩展点自适应实例。其实是一个扩展点的代理，将扩展的选择从Dubbo启动时，延迟到RPC调用时。Dubbo中每一个扩展点都有一个自适应类，如果没有显式提供，Dubbo会自动为我们创建一个，默认使用Javaassist。\n先来看下创建自适应扩展类的代码:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> T <span class=\"hljs-title\">getAdaptiveExtension</span><span class=\"hljs-params\">()</span> </span>{\n    Object instance = cachedAdaptiveInstance.get();\n    <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">synchronized</span> (cachedAdaptiveInstance) {\n                instance = cachedAdaptiveInstance.get();\n                <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n                      instance = createAdaptiveExtension();\n                      cachedAdaptiveInstance.set(instance); \n                }\n            }        \n    }\n\n    <span class=\"hljs-keyword\">return</span> (T) instance;\n}\n</code></pre>\n<p>继续看createAdaptiveExtension方法</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> T <span class=\"hljs-title\">createAdaptiveExtension</span><span class=\"hljs-params\">()</span> </span>{        \n    <span class=\"hljs-keyword\">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());\n}\n</code></pre>\n<p>继续看getAdaptiveExtensionClass方法</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() {\n        getExtensionClasses();\n        <span class=\"hljs-keyword\">if</span> (cachedAdaptiveClass != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">return</span> cachedAdaptiveClass;\n        }\n        <span class=\"hljs-keyword\">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();\n    }\n</code></pre>\n<p>继续看createAdaptiveExtensionClass方法，绕了一大圈，终于来到了具体的实现了。看这个createAdaptiveExtensionClass方法，它首先会生成自适应类的Java源码，然后再将源码编译成Java的字节码，加载到JVM中。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() {\n        String code = createAdaptiveExtensionClassCode();\n        ClassLoader classLoader = findClassLoader();\n        com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();\n        <span class=\"hljs-keyword\">return</span> compiler.compile(code, classLoader);\n    }\n</code></pre>\n<p>Compiler的代码，默认实现是javassist。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@SPI</span>(<span class=\"hljs-string\">\"javassist\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Compiler</span> </span>{\n    Class&lt;?&gt; compile(String code, ClassLoader classLoader);\n}\n</code></pre>\n<p>createAdaptiveExtensionClassCode()方法中使用一个StringBuilder来构建自适应类的Java源码。方法实现比较长，这里就不贴代码了。这种生成字节码的方式也挺有意思的，先生成Java源代码，然后编译，加载到jvm中。通过这种方式，可以更好的控制生成的Java类。而且这样也不用care各个字节码生成框架的api等。因为xxx.java文件是Java通用的，也是我们最熟悉的。只是代码的可读性不强，需要一点一点构建xx.java的内容。\n下面是使用createAdaptiveExtensionClassCode方法为Protocol创建的自适应类的Java代码范例:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.alibaba.dubbo.rpc;\n\n<span class=\"hljs-keyword\">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Protocol</span>$<span class=\"hljs-title\">Adpative</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">com</span>.<span class=\"hljs-title\">alibaba</span>.<span class=\"hljs-title\">dubbo</span>.<span class=\"hljs-title\">rpc</span>.<span class=\"hljs-title\">Protocol</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnsupportedOperationException(<span class=\"hljs-string\">\"method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!\"</span>);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getDefaultPort</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnsupportedOperationException(<span class=\"hljs-string\">\"method public abstract int com.alibaba.dubbo.rpc.Protocol.getDefaultPort() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!\"</span>);\n    }\n\n    <span class=\"hljs-keyword\">public</span> com.alibaba.dubbo.rpc.<span class=\"hljs-function\">Exporter <span class=\"hljs-title\">export</span><span class=\"hljs-params\">(com.alibaba.dubbo.rpc.Invoker arg0)</span> <span class=\"hljs-keyword\">throws</span> com.alibaba.dubbo.rpc.RpcException </span>{\n        <span class=\"hljs-keyword\">if</span> (arg0 == <span class=\"hljs-keyword\">null</span>) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"com.alibaba.dubbo.rpc.Invoker argument == null\"</span>);\n        <span class=\"hljs-keyword\">if</span> (arg0.getUrl() == <span class=\"hljs-keyword\">null</span>)\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"com.alibaba.dubbo.rpc.Invoker argument getUrl() == null\"</span>);\n        com.alibaba.dubbo.common.URL url = arg0.getUrl();\n        String extName = (url.getProtocol() == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-string\">\"dubbo\"</span> : url.getProtocol());\n        <span class=\"hljs-keyword\">if</span> (extName == <span class=\"hljs-keyword\">null</span>)\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(\"</span> + url.toString() + <span class=\"hljs-string\">\") use keys([protocol])\"</span>);\n        com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);\n        <span class=\"hljs-keyword\">return</span> extension.export(arg0);\n    }\n\n    <span class=\"hljs-keyword\">public</span> com.alibaba.dubbo.rpc.<span class=\"hljs-function\">Invoker <span class=\"hljs-title\">refer</span><span class=\"hljs-params\">(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1)</span> <span class=\"hljs-keyword\">throws</span> com.alibaba.dubbo.rpc.RpcException </span>{\n        <span class=\"hljs-keyword\">if</span> (arg1 == <span class=\"hljs-keyword\">null</span>) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"url == null\"</span>);\n        com.alibaba.dubbo.common.URL url = arg1;\n        String extName = (url.getProtocol() == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-string\">\"dubbo\"</span> : url.getProtocol());\n        <span class=\"hljs-keyword\">if</span> (extName == <span class=\"hljs-keyword\">null</span>)\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(\"</span> + url.toString() + <span class=\"hljs-string\">\") use keys([protocol])\"</span>);\n        com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);\n        <span class=\"hljs-keyword\">return</span> extension.refer(arg0, arg1);\n    }\n}\n</code></pre>\n<p>大致的逻辑和开始说的一样，通过url解析出参数，解析的逻辑由@Adaptive的value参数控制，然后再根据得到的扩展点名获取扩展点实现，然后进行调用。如果大家想知道具体的构建.java代码的逻辑，可以看<code>createAdaptiveExtensionClassCode</code>的完整实现。\n在生成的Protocol$Adpative中，发现getDefaultPort和destroy方法都是直接抛出异常的，这是为什么呢？来看看Protocol的源码</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@SPI</span>(<span class=\"hljs-string\">\"dubbo\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Protocol</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getDefaultPort</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-meta\">@Adaptive</span>\n    &lt;T&gt; <span class=\"hljs-function\">Exporter&lt;T&gt; <span class=\"hljs-title\">export</span><span class=\"hljs-params\">(Invoker&lt;T&gt; invoker)</span> <span class=\"hljs-keyword\">throws</span> RpcException</span>;\n\n    <span class=\"hljs-meta\">@Adaptive</span>\n    &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">refer</span><span class=\"hljs-params\">(Class&lt;T&gt; type, URL url)</span> <span class=\"hljs-keyword\">throws</span> RpcException</span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">()</span></span>;\n</code></pre>\n<p>可以看到Protocol接口中有4个方法，但只有export和refer两个方法使用了@Adaptive注解。Dubbo自动生成的自适应实例，只有@Adaptive修饰的方法才有具体的实现。所以，Protocol$Adpative类中，也只有export和refer这两个方法有具体的实现，其余方法都是抛出异常。</p>\n"
    },
    {
      "filename": "introduction-to-dubbo-spi.md",
      "__html": "<h2>Dubbo可扩展机制实战</h2>\n<h1>1. Dubbo的扩展机制</h1>\n<p>在Dubbo的官网上，Dubbo描述自己是一个高性能的RPC框架。今天我想聊聊Dubbo的另一个很棒的特性, 就是它的可扩展性。\n如同罗马不是一天建成的，任何系统都一定是从小系统不断发展成为大系统的，想要从一开始就把系统设计的足够完善是不可能的，相反的，我们应该关注当下的需求，然后再不断地对系统进行迭代。在代码层面，要求我们适当的对关注点进行抽象和隔离，在软件不断添加功能和特性时，依然能保持良好的结构和可维护性，同时允许第三方开发者对其功能进行扩展。在某些时候，软件设计者对扩展性的追求甚至超过了性能。</p>\n<p>在谈到软件设计时，可扩展性一直被谈起，那到底什么才是可扩展性，什么样的框架才算有良好的可扩展性呢？它必须要做到以下两点:</p>\n<ol>\n<li>作为框架的维护者，在添加一个新功能时，只需要添加一些新代码，而不用大量的修改现有的代码，即符合开闭原则。</li>\n<li>作为框架的使用者，在添加一个新功能时，不需要去修改框架的源码，在自己的工程中添加代码即可。</li>\n</ol>\n<p>Dubbo很好的做到了上面两点。这要得益于Dubbo的微内核+插件的机制。接下来的章节中我们会慢慢揭开Dubbo扩展机制的神秘面纱。</p>\n<h1>2. 可扩展的几种解决方案</h1>\n<p>通常可扩展的实现有下面几种:</p>\n<ul>\n<li>Factory模式</li>\n<li>IoC容器</li>\n<li>OSGI容器</li>\n</ul>\n<p>Dubbo作为一个框架，不希望强依赖其他的IoC容器，比如Spring，Guice。OSGI也是一个很重的实现，不适合Dubbo。最终Dubbo的实现参考了Java原生的SPI机制，但对其进行了一些扩展，以满足Dubbo的需求。</p>\n<h1>3. Java SPI机制</h1>\n<p>既然Dubbo的扩展机制是基于Java原生的SPI机制，那么我们就先来了解下Java SPI吧。了解了Java的SPI，也就是对Dubbo的扩展机制有一个基本的了解。如果对Java SPI比较了解的同学，可以跳过。</p>\n<p>Java SPI(Service Provider Interface)是JDK内置的一种动态加载扩展点的实现。在ClassPath的<code>META-INF/services</code>目录下放置一个与接口同名的文本文件，文件的内容为接口的实现类，多个实现类用换行符分隔。JDK中使用<code>java.util.ServiceLoader</code>来加载具体的实现。\n让我们通过一个简单的例子，来看看Java SPI是如何工作的。</p>\n<ol>\n<li>定义一个接口IRepository用于实现数据储存</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">IRepository</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">save</span><span class=\"hljs-params\">(String data)</span></span>;\n}\n</code></pre>\n<ol start=\"2\">\n<li>提供IRepository的实现\nIRepository有两个实现。MysqlRepository和MongoRepository。</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MysqlRepository</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IRepository</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">save</span><span class=\"hljs-params\">(String data)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"Save \"</span> + data + <span class=\"hljs-string\">\" to Mysql\"</span>);\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MongoRepository</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IRepository</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">save</span><span class=\"hljs-params\">(String data)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"Save \"</span> + data + <span class=\"hljs-string\">\" to Mongo\"</span>);\n    }\n}\n</code></pre>\n<ol start=\"3\">\n<li>添加配置文件\n在<code>META-INF/services</code>目录添加一个文件，文件名和接口全名称相同，所以文件是<code>META-INF/services/com.demo.IRepository</code>。文件内容为:</li>\n</ol>\n<pre><code class=\"language-text\">com.demo.MongoRepository\ncom.demo.MysqlRepository\n</code></pre>\n<ol start=\"4\">\n<li>通过ServiceLoader加载IRepository实现</li>\n</ol>\n<pre><code class=\"language-java\">ServiceLoader&lt;IRepository&gt; serviceLoader = ServiceLoader.load(IRepository.class);\nIterator&lt;IRepository&gt; it = serviceLoader.iterator();\n<span class=\"hljs-keyword\">while</span> (it != <span class=\"hljs-keyword\">null</span> &amp;&amp; it.hasNext()){\n    IRepository demoService = it.next();\n    System.out.println(<span class=\"hljs-string\">\"class:\"</span> + demoService.getClass().getName());\n    demoService.save(<span class=\"hljs-string\">\"tom\"</span>);\n}\n</code></pre>\n<p>在上面的例子中，我们定义了一个扩展点和它的两个实现。在ClassPath中添加了扩展的配置文件，最后使用ServiceLoader来加载所有的扩展点。\n最终的输出结果为：\nclass:testDubbo.MongoRepository\nSave tom to Mongo\nclass:testDubbo.MysqlRepository\nSave tom to Mysql</p>\n<h1>4. Dubbo的SPI机制</h1>\n<p>Java SPI的使用很简单。也做到了基本的加载扩展点的功能。但Java SPI有以下的不足:</p>\n<ul>\n<li>需要遍历所有的实现，并实例化，然后我们在循环中才能找到我们需要的实现。</li>\n<li>配置文件中只是简单的列出了所有的扩展实现，而没有给他们命名。导致在程序中很难去准确的引用它们。</li>\n<li>扩展如果依赖其他的扩展，做不到自动注入和装配</li>\n<li>不提供类似于Spring的IOC和AOP功能</li>\n<li>扩展很难和其他的框架集成，比如扩展里面依赖了一个Spring bean，原生的Java SPI不支持</li>\n</ul>\n<p>所以Java SPI应付一些简单的场景是可以的，但对于Dubbo，它的功能还是比较弱的。Dubbo对原生SPI机制进行了一些扩展。接下来，我们就更深入地了解下Dubbo的SPI机制。</p>\n<h1>5. Dubbo扩展点机制基本概念</h1>\n<p>在深入学习Dubbo的扩展机制之前，我们先明确Dubbo SPI中的一些基本概念。在接下来的内容中，我们会多次用到这些术语。</p>\n<h3>5.1 扩展点(Extension Point)</h3>\n<p>是一个Java的接口。</p>\n<h3>5.2 扩展(Extension)</h3>\n<p>扩展点的实现类。</p>\n<h3>5.3 扩展实例(Extension Instance)</h3>\n<p>扩展点实现类的实例。</p>\n<h3>5.4 扩展自适应实例(Extension Adaptive Instance)</h3>\n<p>第一次接触这个概念时，可能不太好理解(我第一次也是这样的...)。如果称它为扩展代理类，可能更好理解些。扩展的自适应实例其实就是一个Extension的代理，它实现了扩展点接口。在调用扩展点的接口方法时，会根据实际的参数来决定要使用哪个扩展。比如一个IRepository的扩展点，有一个save方法。有两个实现MysqlRepository和MongoRepository。IRepository的自适应实例在调用接口方法的时候，会根据save方法中的参数，来决定要调用哪个IRepository的实现。如果方法参数中有repository=mysql，那么就调用MysqlRepository的save方法。如果repository=mongo，就调用MongoRepository的save方法。和面向对象的延迟绑定很类似。为什么Dubbo会引入扩展自适应实例的概念呢？</p>\n<ul>\n<li>Dubbo中的配置有两种，一种是固定的系统级别的配置，在Dubbo启动之后就不会再改了。还有一种是运行时的配置，可能对于每一次的RPC，这些配置都不同。比如在xml文件中配置了超时时间是10秒钟，这个配置在Dubbo启动之后，就不会改变了。但针对某一次的RPC调用，可以设置它的超时时间是30秒钟，以覆盖系统级别的配置。对于Dubbo而言，每一次的RPC调用的参数都是未知的。只有在运行时，根据这些参数才能做出正确的决定。</li>\n<li>很多时候，我们的类都是一个单例的，比如Spring的bean，在Spring bean都实例化时，如果它依赖某个扩展点，但是在bean实例化时，是不知道究竟该使用哪个具体的扩展实现的。这时候就需要一个代理模式了，它实现了扩展点接口，方法内部可以根据运行时参数，动态的选择合适的扩展实现。而这个代理就是自适应实例。\n自适应扩展实例在Dubbo中的使用非常广泛，Dubbo中，每一个扩展都会有一个自适应类，如果我们没有提供，Dubbo会使用字节码工具为我们自动生成一个。所以我们基本感觉不到自适应类的存在。后面会有例子说明自适应类是怎么工作的。</li>\n</ul>\n<h3>5.5 @SPI</h3>\n<p>@SPI注解作用于扩展点的接口上，表明该接口是一个扩展点。可以被Dubbo的ExtentionLoader加载。如果没有此ExtensionLoader调用会异常。</p>\n<h3>5.6 @Adaptive</h3>\n<p>@Adaptive注解用在扩展接口的方法上。表示该方法是一个自适应方法。Dubbo在为扩展点生成自适应实例时，如果方法有@Adaptive注解，会为该方法生成对应的代码。方法内部会根据方法的参数，来决定使用哪个扩展。\n@Adaptive注解用在类上代表实现一个装饰类，类似于设计模式中的装饰模式，它主要作用是返回指定类，目前在整个系统中AdaptiveCompiler、AdaptiveExtensionFactory这两个类拥有该注解。</p>\n<h3>5.7 ExtentionLoader</h3>\n<p>类似于Java SPI的ServiceLoader，负责扩展的加载和生命周期维护。</p>\n<h3>5.8 扩展别名</h3>\n<p>和Java SPI不同，Dubbo中的扩展都有一个别名，用于在应用中引用它们。比如</p>\n<pre><code class=\"language-bash\">random=com.alibaba.dubbo.rpc.cluster.loadbalance.RandomLoadBalance\nroundrobin=com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance\n</code></pre>\n<p>其中的random，roundrobin就是对应扩展的别名。这样我们在配置文件中使用random或roundrobin就可以了。</p>\n<h3>5.9 一些路径</h3>\n<p>和Java SPI从<code>/META-INF/services</code>目录加载扩展配置类似，Dubbo也会从以下路径去加载扩展配置文件:</p>\n<ul>\n<li><code>META-INF/dubbo/internal</code></li>\n<li><code>META-INF/dubbo</code></li>\n<li><code>META-INF/services</code></li>\n</ul>\n<h1>6. Dubbo的LoadBalance扩展点解读</h1>\n<p>在了解了Dubbo的一些基本概念后，让我们一起来看一个Dubbo中实际的扩展点，对这些概念有一个更直观的认识。</p>\n<p>我们选择的是Dubbo中的LoadBalance扩展点。Dubbo中的一个服务，通常有多个Provider，consumer调用服务时，需要在多个Provider中选择一个。这就是一个LoadBalance。我们一起来看看在Dubbo中，LoadBalance是如何成为一个扩展点的。</p>\n<h3>6.1 LoadBalance接口</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@SPI</span>(RandomLoadBalance.NAME)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">LoadBalance</span> </span>{\n\n    <span class=\"hljs-meta\">@Adaptive</span>(<span class=\"hljs-string\">\"loadbalance\"</span>)\n    &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">select</span><span class=\"hljs-params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> RpcException</span>;\n}\n</code></pre>\n<p>LoadBalance接口只有一个select方法。select方法从多个invoker中选择其中一个。上面代码中和Dubbo SPI相关的元素有:</p>\n<ul>\n<li>@SPI(<a href=\"http://RandomLoadBalance.NAME\">RandomLoadBalance.NAME</a>)\n@SPI作用于LoadBalance接口，表示接口LoadBalance是一个扩展点。如果没有@SPI注解，试图去加载扩展时，会抛出异常。@SPI注解有一个参数，该参数表示该扩展点的默认实现的别名。如果没有显示的指定扩展，就使用默认实现。<code>RandomLoadBalance.NAME</code>是一个常量，值是&quot;random&quot;，是一个随机负载均衡的实现。\nrandom的定义在配置文件<code>META-INF/dubbo/internal/com.alibaba.dubbo.rpc.cluster.LoadBalance</code>中:</li>\n</ul>\n<pre><code class=\"language-bash\">random=com.alibaba.dubbo.rpc.cluster.loadbalance.RandomLoadBalance\nroundrobin=com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance\nleastactive=com.alibaba.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance\nconsistenthash=com.alibaba.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance\n</code></pre>\n<p>可以看到文件中定义了4个LoadBalance的扩展实现。由于负载均衡的实现不是本次的内容，这里就不过多说明。只用知道Dubbo提供了4种负载均衡的实现，我们可以通过xml文件，properties文件，JVM参数显式的指定一个实现。如果没有，默认使用随机。</p>\n<p><img src=\"https://raw.githubusercontent.com/vangoleo/wiki/master/dubbo/dubbo_loadbalance.png\" alt=\"dubbo-loadbalance | left\"></p>\n<ul>\n<li>@Adaptive(&quot;loadbalance&quot;)\n@Adaptive注解修饰select方法，表明方法select方法是一个可自适应的方法。Dubbo会自动生成该方法对应的代码。当调用select方法时，会根据具体的方法参数来决定调用哪个扩展实现的select方法。@Adaptive注解的参数<code>loadbalance</code>表示方法参数中的loadbalance的值作为实际要调用的扩展实例。\n但奇怪的是，我们发现select的方法中并没有loadbalance参数，那怎么获取loadbalance的值呢？select方法中还有一个URL类型的参数，Dubbo就是从URL中获取loadbalance的值的。这里涉及到Dubbo的URL总线模式，简单说，URL中包含了RPC调用中的所有参数。URL类中有一个<code>Map&lt;String, String&gt; parameters</code>字段，parameters中就包含了loadbalance。</li>\n</ul>\n<h3>6.2 获取LoadBalance扩展</h3>\n<p>Dubbo中获取LoadBalance的代码如下:</p>\n<pre><code class=\"language-java\">LoadBalance lb = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(loadbalanceName);\n</code></pre>\n<p>使用ExtensionLoader.getExtensionLoader(LoadBalance.class)方法获取一个ExtensionLoader的实例，然后调用getExtension，传入一个扩展的别名来获取对应的扩展实例。</p>\n<h1>7. 自定义一个LoadBalance扩展</h1>\n<p>本节中，我们通过一个简单的例子，来自己实现一个LoadBalance，并把它集成到Dubbo中。我会列出一些关键的步骤和代码，也可以从这个地址(<a href=\"https://github.com/vangoleo/dubbo-spi-demo\">https://github.com/vangoleo/dubbo-spi-demo</a>)下载完整的demo。</p>\n<h3>7.1 实现LoadBalance接口</h3>\n<p>首先，编写一个自己实现的LoadBalance，因为是为了演示Dubbo的扩展机制，而不是LoadBalance的实现，所以这里LoadBalance的实现非常简单，选择第一个invoker，并在控制台输出一条日志。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.dubbo.spi.demo.consumer;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoLoadBalance</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">LoadBalance</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">select</span><span class=\"hljs-params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n        System.out.println(<span class=\"hljs-string\">\"DemoLoadBalance: Select the first invoker...\"</span>);\n        <span class=\"hljs-keyword\">return</span> invokers.get(<span class=\"hljs-number\">0</span>);\n    }\n}\n</code></pre>\n<h3>7.2 添加扩展配置文件</h3>\n<p>添加文件:<code>META-INF/dubbo/com.alibaba.dubbo.rpc.cluster.LoadBalance</code>。文件内容如下:</p>\n<pre><code class=\"language-bash\">demo=com.dubbo.spi.demo.consumer.DemoLoadBalance\n</code></pre>\n<h3>7.3 配置使用自定义LoadBalance</h3>\n<p>通过上面的两步，已经添加了一个名字为demo的LoadBalance实现，并在配置文件中进行了相应的配置。接下来，需要显式的告诉Dubbo使用demo的负载均衡实现。如果是通过spring的方式使用Dubbo，可以在xml文件中进行设置。</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"helloService\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.dubbo.spi.demo.api.IHelloService\"</span> <span class=\"hljs-attr\">loadbalance</span>=<span class=\"hljs-string\">\"demo\"</span> /&gt;</span>\n</code></pre>\n<p>在consumer端的<a href=\"dubbo:reference\">dubbo:reference</a>中配置&lt;loadbalance=&quot;demo&quot;&gt;</p>\n<h3>7.4 启动Dubbo</h3>\n<p>启动Dubbo，调用一次IHelloService，可以看到控制台会输出一条<code>DemoLoadBalance: Select the first invoker...</code>日志。说明Dubbo的确是使用了我们自定义的LoadBalance。</p>\n<h1>总结</h1>\n<p>到此，我们从Java SPI开始，了解了Dubbo SPI 的基本概念，并结合了Dubbo中的LoadBalance加深了理解。最后，我们还实践了一下，创建了一个自定义LoadBalance，并集成到Dubbo中。相信通过这里理论和实践的结合，大家对Dubbo的可扩展有更深入的理解。\n总结一下，Dubbo SPI有以下的特点:</p>\n<ul>\n<li>对Dubbo进行扩展，不需要改动Dubbo的源码</li>\n<li>自定义的Dubbo的扩展点实现，是一个普通的Java类，Dubbo没有引入任何Dubbo特有的元素，对代码侵入性几乎为零。</li>\n<li>将扩展注册到Dubbo中，只需要在ClassPath中添加配置文件。使用简单。而且不会对现有代码造成影响。符合开闭原则。</li>\n<li>dubbo的扩展机制设计默认值：@SPI(&quot;dubbo&quot;) 代表默认的spi对象</li>\n<li>Dubbo的扩展机制支持IoC,AoP等高级功能</li>\n<li>Dubbo的扩展机制能很好的支持第三方IoC容器，默认支持Spring Bean，可自己扩展来支持其他容器，比如Google的Guice。</li>\n<li>切换扩展点的实现，只需要在配置文件中修改具体的实现，不需要改代码。使用方便。</li>\n</ul>\n<p>下一篇，我们将会一起深入Dubbo的源码，更深入的了解Dubbo的可扩展机制。</p>\n"
    },
    {
      "filename": "optimization-branch-prediction.md",
      "__html": "<h1>优化技巧：提前if判断帮助CPU分支预测</h1>\n<hr>\n<h2>分支预测</h2>\n<p>在stackoverflow上有一个非常有名的问题：<a href=\"https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array\">为什么处理有序数组要比非有序数组快？</a>，可见分支预测对代码运行效率有非常大的影响。</p>\n<p>现代CPU都支持分支预测(branch prediction)和指令流水线(instruction pipeline)，这两个结合可以极大提高CPU效率。对于像简单的if跳转，CPU是可以比较好地做分支预测的。但是对于switch跳转，CPU则没有太多的办法。switch本质上是据索引，从地址数组里取地址再跳转。</p>\n<p>要提高代码执行效率，一个重要的原则就是尽量避免CPU把流水线清空，那么提高分支预测的成功率就非常重要。</p>\n<p>那么对于代码里，如果某个switch分支概率很高，是否可以考虑代码层面帮CPU把判断提前，来提高代码执行效率呢？</p>\n<h2>Dubbo里ChannelEventRunnable的switch判断</h2>\n<p>在<code>ChannelEventRunnable</code>里有一个switch来判断channel state，然后做对应的逻辑：<a href=\"https://github.com/hengyunabc/incubator-dubbo/blob/dubbo-2.6.1/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/ChannelEventRunnable.java#L54\">查看</a></p>\n<p>一个channel建立起来之后，超过99.9%情况它的state都是<code>ChannelState.RECEIVED</code>，那么可以考虑把这个判断提前。</p>\n<h2>benchmark验证</h2>\n<p>下面通过jmh来验证下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestBenchMarks</span> </span>{\n\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> ChannelState {\n\t\tCONNECTED, DISCONNECTED, SENT, RECEIVED, CAUGHT\n\t}\n\n\t<span class=\"hljs-meta\">@State</span>(Scope.Benchmark)\n\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ExecutionPlan</span> </span>{\n\t\t<span class=\"hljs-meta\">@Param</span>({ <span class=\"hljs-string\">\"1000000\"</span> })\n\t\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> size;\n\t\t<span class=\"hljs-keyword\">public</span> ChannelState[] states = <span class=\"hljs-keyword\">null</span>;\n\n\t\t<span class=\"hljs-meta\">@Setup</span>\n\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setUp</span><span class=\"hljs-params\">()</span> </span>{\n\t\t\tChannelState[] values = ChannelState.values();\n\t\t\tstates = <span class=\"hljs-keyword\">new</span> ChannelState[size];\n\t\t\tRandom random = <span class=\"hljs-keyword\">new</span> Random(<span class=\"hljs-keyword\">new</span> Date().getTime());\n\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; i++) {\n\t\t\t\t<span class=\"hljs-keyword\">int</span> nextInt = random.nextInt(<span class=\"hljs-number\">1000000</span>);\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (nextInt &gt; <span class=\"hljs-number\">100</span>) {\n\t\t\t\t\tstates[i] = ChannelState.RECEIVED;\n\t\t\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\t\t\tstates[i] = values[nextInt % values.length];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t<span class=\"hljs-meta\">@Fork</span>(value = <span class=\"hljs-number\">5</span>)\n\t<span class=\"hljs-meta\">@Benchmark</span>\n\t<span class=\"hljs-meta\">@BenchmarkMode</span>(Mode.Throughput)\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">benchSiwtch</span><span class=\"hljs-params\">(ExecutionPlan plan, Blackhole bh)</span> </span>{\n\t\t<span class=\"hljs-keyword\">int</span> result = <span class=\"hljs-number\">0</span>;\n\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; plan.size; ++i) {\n\t\t\t<span class=\"hljs-keyword\">switch</span> (plan.states[i]) {\n\t\t\t<span class=\"hljs-keyword\">case</span> CONNECTED:\n\t\t\t\tresult += ChannelState.CONNECTED.ordinal();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t<span class=\"hljs-keyword\">case</span> DISCONNECTED:\n\t\t\t\tresult += ChannelState.DISCONNECTED.ordinal();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t<span class=\"hljs-keyword\">case</span> SENT:\n\t\t\t\tresult += ChannelState.SENT.ordinal();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t<span class=\"hljs-keyword\">case</span> RECEIVED:\n\t\t\t\tresult += ChannelState.RECEIVED.ordinal();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t<span class=\"hljs-keyword\">case</span> CAUGHT:\n\t\t\t\tresult += ChannelState.CAUGHT.ordinal();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t}\n\t\t}\n\t\tbh.consume(result);\n\t}\n\n\t<span class=\"hljs-meta\">@Fork</span>(value = <span class=\"hljs-number\">5</span>)\n\t<span class=\"hljs-meta\">@Benchmark</span>\n\t<span class=\"hljs-meta\">@BenchmarkMode</span>(Mode.Throughput)\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">benchIfAndSwitch</span><span class=\"hljs-params\">(ExecutionPlan plan, Blackhole bh)</span> </span>{\n\t\t<span class=\"hljs-keyword\">int</span> result = <span class=\"hljs-number\">0</span>;\n\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; plan.size; ++i) {\n\t\t\tChannelState state = plan.states[i];\n\t\t\t<span class=\"hljs-keyword\">if</span> (state == ChannelState.RECEIVED) {\n\t\t\t\tresult += ChannelState.RECEIVED.ordinal();\n\t\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\t\t<span class=\"hljs-keyword\">switch</span> (state) {\n\t\t\t\t<span class=\"hljs-keyword\">case</span> CONNECTED:\n\t\t\t\t\tresult += ChannelState.CONNECTED.ordinal();\n\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t\t<span class=\"hljs-keyword\">case</span> SENT:\n\t\t\t\t\tresult += ChannelState.SENT.ordinal();\n\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t\t<span class=\"hljs-keyword\">case</span> DISCONNECTED:\n\t\t\t\t\tresult += ChannelState.DISCONNECTED.ordinal();\n\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t\t<span class=\"hljs-keyword\">case</span> CAUGHT:\n\t\t\t\t\tresult += ChannelState.CAUGHT.ordinal();\n\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbh.consume(result);\n\t}\n}\n</code></pre>\n<ul>\n<li>benchSiwtch里是纯switch判断</li>\n<li>benchIfAndSwitch 里用一个if提前判断state是否<code>ChannelState.RECEIVED</code></li>\n</ul>\n<p>benchmark结果是：</p>\n<pre><code>Result &quot;io.github.hengyunabc.jmh.TestBenchMarks.benchSiwtch&quot;:\n  576.745 ±(99.9%) 6.806 ops/s [Average]\n  (min, avg, max) = (490.348, 576.745, 618.360), stdev = 20.066\n  CI (99.9%): [569.939, 583.550] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:06:48\n\nBenchmark                         (size)   Mode  Cnt     Score    Error  Units\nTestBenchMarks.benchIfAndSwitch  1000000  thrpt  100  1535.867 ± 61.212  ops/s\nTestBenchMarks.benchSiwtch       1000000  thrpt  100   576.745 ±  6.806  ops/s\n</code></pre>\n<p>可以看到提前if判断的确提高了代码效率，这种技巧可以放在性能要求严格的地方。</p>\n<p>Benchmark代码：<a href=\"https://github.com/hengyunabc/jmh-demo\">https://github.com/hengyunabc/jmh-demo</a></p>\n<h2>总结</h2>\n<ul>\n<li>switch对于CPU来说难以做分支预测</li>\n<li>某些switch条件如果概率比较高，可以考虑单独提前if判断，充分利用CPU的分支预测机制</li>\n</ul>\n"
    },
    {
      "filename": "pinpoint.md",
      "__html": "<h1>使用Pinpoint做分布式跟踪</h1>\n<p>在使用Dubbo进行服务化或者整合应用后，假设某个服务后台日志显示有异常，这个服务又被多个应用调用的情况下，我们通常很难判断是哪个应用调用的，问题的起因是什么，因此我们需要一套分布式跟踪系统来快速定位问题，Pinpoint可以帮助我们快速定位问题（当然，解决方案也不止这一种）。</p>\n<h2>什么是Pinpoint(摘自<a href=\"https://skyao.gitbooks.io/learning-pinpoint/\">Pinpoint学习笔记</a>)</h2>\n<p><a href=\"https://github.com/naver/pinpoint\">Pinpoint</a>是一个开源的 APM (Application Performance Management/应用性能管理)工具，用于基于java的大规模分布式系统。\n仿照Google Dapper，Pinpoint通过跟踪分布式应用之间的调用来提供解决方案，以帮助分析系统的总体结构和内部模块之间如何相互联系。</p>\n<blockquote>\n<p>注：对于各个模块之间的通讯英文原文中用的是transaction一词，但是我觉得如果翻译为&quot;事务&quot;容易引起误解，所以替换为&quot;交互&quot;或者&quot;调用&quot;这种比较直白的字眼。</p>\n</blockquote>\n<p>在使用上力图简单高效：</p>\n<ul>\n<li>安装agent，不需要修改哪怕一行代码</li>\n<li>最小化性能损失</li>\n</ul>\n<h3>服务器地图(ServerMap)</h3>\n<p>通过可视化分布式系统的模块和他们之间的相互联系来理解系统拓扑。点击某个节点会展示这个模块的详情，比如它当前的状态和请求数量。</p>\n<h3>实时活动线程图表(Realtime Active Thread Chart)</h3>\n<p>实时监控应用内部的活动线程。</p>\n<h3>请求/应答分布图表(Request/Response Scatter Chart)</h3>\n<p>长期可视化请求数量和应答模式来定位潜在问题。通过在图表上拉拽可以选择请求查看更多的详细信息。</p>\n<h3>调用栈(CallStack)</h3>\n<p>在分布式环境中为每个调用生成代码级别的可视图，在单个视图中定位瓶颈和失败点。</p>\n<h3>巡查(Inspector)</h3>\n<p>查看应用上的其他详细信息，比如CPU使用率，内存/垃圾回收，TPS，和JVM参数。</p>\n<h3>支持模块</h3>\n<ul>\n<li>JDK 6+</li>\n<li>Tomcat 6/7/8, Jetty 8/9, JBoss EAP 6, Resin 4, Websphere 6/7/8, Vertx 3.3/3.4/3.5</li>\n<li>Spring, Spring Boot (Embedded Tomcat, Jetty)</li>\n<li>Apache HTTP Client 3.x/4.x, JDK HttpConnector, GoogleHttpClient, OkHttpClient, NingAsyncHttpClient</li>\n<li>Thrift Client, Thrift Service, DUBBO PROVIDER, DUBBO CONSUMER</li>\n<li>ActiveMQ, RabbitMQ</li>\n<li>MySQL, Oracle, MSSQL, CUBRID,POSTGRESQL, MARIA</li>\n<li>Arcus, Memcached, Redis, CASSANDRA</li>\n<li>iBATIS, MyBatis</li>\n<li>DBCP, DBCP2, HIKARICP</li>\n<li>gson, Jackson, Json Lib</li>\n<li>log4j, Logback</li>\n<li>自定义模块</li>\n</ul>\n<h2>Pinpoint与Dubbo的结合</h2>\n<h3>启动Pinpoint</h3>\n<p>参考Pinpoint的<a href=\"http://naver.github.io/pinpoint/quickstart.html\">Quick start</a>搭建环境（不需要启动TestApp）</p>\n<h3>准备Dubbo示例程序</h3>\n<h4>创建API包</h4>\n<p>pom.xml</p>\n<pre><code class=\"language-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.example<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>demo-api<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></pre>\n<p>新建API接口：</p>\n<pre><code>package com.example.demoapi;\n\npublic interface HelloService {\n    String sayHello(String name);\n}\n</code></pre>\n<h4>实现 Dubbo 服务提供方</h4>\n<p>pom.xml</p>\n<pre><code class=\"language-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n\t<span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.example<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>demo-provider<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">packaging</span>&gt;</span>jar<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">packaging</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">name</span>&gt;</span>demo-provider<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">name</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.0.3.RELEASE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">relativePath</span>/&gt;</span> <span class=\"hljs-comment\">&lt;!-- lookup parent from repository --&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.reporting.outputEncoding</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">java.version</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">java.version</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">repositories</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">repository</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>sonatype-nexus-snapshots<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">url</span>&gt;</span>https://oss.sonatype.org/content/repositories/snapshots<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">url</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">releases</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">enabled</span>&gt;</span>false<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">enabled</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">releases</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">snapshots</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">enabled</span>&gt;</span>true<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">enabled</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">snapshots</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">repository</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">repositories</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.2.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.example<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>demo-api<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></pre>\n<ol>\n<li>实现 <code>HelloService</code> 接口：</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.example.demoprovider.provider;\n\n<span class=\"hljs-keyword\">import</span> com.alibaba.dubbo.config.annotation.Service;\n<span class=\"hljs-keyword\">import</span> com.example.demoapi.HelloService;\n\n<span class=\"hljs-meta\">@Service</span>(version = <span class=\"hljs-string\">\"${demo.service.version}\"</span>,\n        application = <span class=\"hljs-string\">\"${dubbo.application.id}\"</span>,\n        protocol = <span class=\"hljs-string\">\"${dubbo.protocol.id}\"</span>,\n        registry = <span class=\"hljs-string\">\"${dubbo.registry.id}\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">HelloService</span> </span>{\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        i++;\n        <span class=\"hljs-keyword\">if</span> (i % <span class=\"hljs-number\">3</span> == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(<span class=\"hljs-string\">\"ex\"</span>);\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Hello \"</span> + name + <span class=\"hljs-string\">\"!\"</span>;\n    }\n}\n</code></pre>\n<ol start=\"2\">\n<li>编写 Spring Boot 引导程序：</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.example.demoprovider;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoProviderApplication</span> </span>{\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n\t\tSpringApplication.run(DemoProviderApplication.class, args);\n\t}\n}\n</code></pre>\n<ol start=\"3\">\n<li>配置 <code>application.properties</code>：</li>\n</ol>\n<pre><code class=\"language-properties\"># Spring boot application\nspring.application.name = dubbo-provider-demo\nserver.port = 9090\nmanagement.port = 9091\n\n# Service version\ndemo.service.version = 1.0.0\n\n# Base packages to scan Dubbo Components (e.g @Service , @Reference)\ndubbo.scan.basePackages  = com.example.demoprovider\n\n# Dubbo Config properties\n## ApplicationConfig Bean\ndubbo.application.id = dubbo-provider-demo\ndubbo.application.name = dubbo-provider-demo\n\n## ProtocolConfig Bean\ndubbo.protocol.id = dubbo\ndubbo.protocol.name = dubbo\ndubbo.protocol.port = 12345\n\n## RegistryConfig Bean\ndubbo.registry.id = my-registry\ndubbo.registry.address = N/A\n</code></pre>\n<h4>实现 Dubbo 服务消费方</h4>\n<p>pom.xml</p>\n<pre><code class=\"language-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n\t<span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.example<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>demo-consumer<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">packaging</span>&gt;</span>jar<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">packaging</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">name</span>&gt;</span>demo-consumer<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">name</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.0.3.RELEASE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">relativePath</span>/&gt;</span> <span class=\"hljs-comment\">&lt;!-- lookup parent from repository --&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.reporting.outputEncoding</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">java.version</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">java.version</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">repositories</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">repository</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>sonatype-nexus-snapshots<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">url</span>&gt;</span>https://oss.sonatype.org/content/repositories/snapshots<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">url</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">releases</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">enabled</span>&gt;</span>false<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">enabled</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">releases</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">snapshots</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">enabled</span>&gt;</span>true<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">enabled</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">snapshots</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">repository</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">repositories</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.2.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.example<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>demo-api<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;</span>\n\t\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">classifier</span>&gt;</span>exec<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">classifier</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">configuration</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></pre>\n<ol>\n<li>通过 <code>@Reference</code> 注入 <code>HelloService</code></li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.example.democonsumer.controller;\n\n<span class=\"hljs-keyword\">import</span> com.alibaba.dubbo.config.annotation.Reference;\n<span class=\"hljs-keyword\">import</span> com.example.demoapi.HelloService;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestParam;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoConsumerController</span> </span>{\n    <span class=\"hljs-meta\">@Reference</span>(version = <span class=\"hljs-string\">\"${demo.service.version}\"</span>,\n            application = <span class=\"hljs-string\">\"${dubbo.application.id}\"</span>,\n            url = <span class=\"hljs-string\">\"dubbo://&lt;注意，这里填写具体IP&gt;:12345\"</span>)\n    <span class=\"hljs-keyword\">private</span> HelloService helloService;\n\n    <span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"/sayHello\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(@RequestParam String name)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> helloService.sayHello(name);\n    }\n}\n</code></pre>\n<blockquote>\n<p>直连提供者调用需要填写具体IP地址，如果写localhost也可以，但是会被Pinpoint额外识别为一个未知服务</p>\n</blockquote>\n<ol start=\"2\">\n<li>编写 Spring Boot 引导程序（Web 应用）：</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.example.democonsumer;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoConsumerApplication</span> </span>{\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n\t\tSpringApplication.run(DemoConsumerApplication.class, args);\n\t}\n}\n</code></pre>\n<ol start=\"3\">\n<li>配置 <code>application.properties</code>：</li>\n</ol>\n<pre><code class=\"language-properties\"># Spring boot application\nspring.application.name=dubbo-consumer-demo\nserver.port=8080\nmanagement.port=8081\n\n# Service Version\ndemo.service.version=1.0.0\n\n# Dubbo Config properties\n## ApplicationConfig Bean\ndubbo.application.id=dubbo-consumer-demo\ndubbo.application.name=dubbo-consumer-demo\n\n## ProtocolConfig Bean\ndubbo.protocol.id=dubbo\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=12345\n</code></pre>\n<h3>使用Pinpoint-agent启动服务提供方和服务消费方</h3>\n<h4>启动服务提供方</h4>\n<ol>\n<li>编译打包</li>\n</ol>\n<pre><code>mvn clean package\n</code></pre>\n<ol start=\"2\">\n<li>附加参数启动服务提供方</li>\n</ol>\n<pre><code>java -jar -javaagent:$AGENT_PATH/pinpoint-bootstrap-$VERSION.jar -Dpinpoint.agentId=demo-provider -Dpinpoint.applicationName=DP target/demo-provider-0.0.1-SNAPSHOT.jar\n</code></pre>\n<ol start=\"3\">\n<li>附加参数启动服务消费方</li>\n</ol>\n<pre><code>java -jar -javaagent:$AGENT_PATH/pinpoint-bootstrap-$VERSION.jar -Dpinpoint.agentId=demo-consumer -Dpinpoint.applicationName=DC target/demo-comsumer-0.0.1-SNAPSHOT-exec.jar\n</code></pre>\n<ol start=\"4\">\n<li>访问消费方地址模拟用户请求</li>\n</ol>\n<p><code>http://localhost:8080/sayHello?name=ABC</code></p>\n<h2>使用Pinpoint快速定位问题</h2>\n<h3>首页</h3>\n<p><img src=\"../../img/blog/pinpoint-home.png\" alt=\"/admin-guide/images/pinpoint-home.png\"></p>\n<blockquote>\n<p>这里的用户请求是请求DubboProvider数量的双倍，原因是记录了favicon.ico图标请求导致的</p>\n</blockquote>\n<h3>调用树</h3>\n<p><img src=\"../../img/blog/pinpoint-calltree.png\" alt=\"/admin-guide/images/pinpoint-calltree.png\"></p>\n<h3>深入跟踪</h3>\n<p><img src=\"../../img/blog/pinpoint-mixedview.png\" alt=\"/admin-guide/images/pinpoint-mixedview.png\"></p>\n<h3>其他</h3>\n<p>示例简单的模拟了Dubbo的提供和调用，并没有进行数据库等其他中间件的应用，详细使用请参照Pinpoint文档。</p>\n"
    },
    {
      "filename": "sentinel-introduction-for-dubbo.md",
      "__html": "<h1>Sentinel 为 Dubbo 服务保驾护航</h1>\n<p>在复杂的生产环境下可能部署着成千上万的 Dubbo 服务实例，流量持续不断地进入，服务之间进行相互调用。但是分布式系统中可能会因流量激增、系统负载过高、网络延迟等一系列问题，导致某些服务不可用，如果不进行相应的控制可能导致级联故障，影响服务的可用性，因此如何对流量进行合理的控制，成为保障服务稳定性的关键。</p>\n<p><a href=\"https://github.com/alibaba/Sentinel\">Sentinel</a> 是阿里中间件团队开源的，面向分布式服务架构的轻量级流量控制产品，主要以流量为切入点，从<strong>流量控制</strong>、<strong>熔断降级</strong>、<strong>系统负载保护</strong>等多个维度来帮助用户保护服务的稳定性。本文将基于 Dubbo，看看 Sentinel 是如何进行流量控制的，并且提供 Dubbo 整合 Sentinel 的最佳实践。</p>\n<h2>快速接入 Sentinel</h2>\n<p>Sentinel 意为<strong>哨兵</strong>，这个命名形象的诠释了 Sentinel 在分布式系统中的工作角色和重要性。以 Sentinel 在 Dubbo 生态系统中的作用为例，Dubbo 的核心模块包括注册中心、服务提供方、服务消费方（服务调用方）和监控四个模块。Sentinel 通过对服务提供方和服务消费方的限流来进一步提升服务的可用性。接下来我们看看 Sentinel 对服务提供方和服务消费方限流的技术实现方式。</p>\n<p><img src=\"http://dubbo.incubator.apache.org/img/architecture.png\" alt=\"Dubbo Arch\"></p>\n<p>Sentinel 提供了与 Dubbo 适配的模块 – <a href=\"https://github.com/dubbo/dubbo-sentinel-support\">Sentinel Dubbo Adapter</a>，包括针对服务提供方的过滤器和服务消费方的过滤器（Filter）。使用时我们只需引入以下模块（以 Maven 为例）：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>sentinel-dubbo-adapter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>x.y.z<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<p>引入此依赖后，Dubbo 的服务接口和方法（包括调用端和服务端）就会成为 Sentinel 中的资源，在配置了规则后就可以自动享受到 Sentinel 的防护能力。同时提供了灵活的配置选项，例如若不希望开启 Sentinel Dubbo Adapter 中的某个 Filter，可以手动关闭对应的 Filter。</p>\n<p>接入 Sentinel Dubbo Adapter 后，即使未配置规则，Sentinel 也会对相应的 Dubbo 服务的调用信息进行统计。那么我们怎么知道 Sentinel 接入成功了呢？这时候就要请出一大利器 —— Sentinel 控制台了。</p>\n<h2>限流必备 - 监控管理</h2>\n<p>流量具有很强的实时性，之所以需要限流，是因为我们无法对流量的到来作出精确的预判，不然的话我们完全可以通过弹性的计算资源来处理，所以这时候为了保证限流的准确性，限流框架的监控功能就非常重要了。</p>\n<p>Sentinel 的控制台（Dashboard）是流量控制、熔断降级规则统一配置和管理的入口，同时它为用户提供了多个维度的监控功能。在 Sentinel 控制台上，我们可以配置规则并实时查看流量控制效果。</p>\n<p>接入 Sentinel 控制台的步骤如下（<strong>缺一不可</strong>）：</p>\n<ol>\n<li>按照 <a href=\"https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0\">Sentinel 控制台文档</a> 启动控制台</li>\n<li>应用引入 <code>sentinel-transport-simple-http</code> 依赖，以便控制台可以拉取对应应用的相关信息</li>\n<li>给应用添加相关的启动参数，启动应用。需要配置的参数有：\n<ul>\n<li><code>-Dcsp.sentinel.api.port</code>：客户端的 port，用于上报相关信息（默认为 8719）</li>\n<li><code>-Dcsp.sentinel.dashboard.server</code>：控制台的地址</li>\n<li><code>-Dproject.name</code>：应用名称，会在控制台中显示</li>\n</ul>\n</li>\n</ol>\n<p>注意某些环境下本地运行 Dubbo 服务还需要加上 <code>-Djava.net.preferIPv4Stack=true</code> 参数。比如中 Service Provider 的启动参数可以配成：</p>\n<pre><code class=\"language-bash\">-Djava.net.preferIPv4Stack=<span class=\"hljs-literal\">true</span> -Dcsp.sentinel.api.port=8720 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=dubbo-provider-demo\n</code></pre>\n<p>这样在启动应用后就能在控制台找到对应的应用了。以下是常用功能：</p>\n<ul>\n<li><strong>单台设备监控</strong>：当在机器列表中看到您的机器，就代表着已经成功接入控制台，可以查看单台设备的设备名称、IP地址、端口号、健康状态和心跳时间等信息。</li>\n</ul>\n<p><img src=\"https://github.com/alibaba/Sentinel/wiki/image/machinediscover.png\" alt=\"Discovery\"></p>\n<ul>\n<li><strong>链路监控</strong>：簇点链路实时的去拉取指定客户端资源的运行情况，它提供了两种展示模式，一种用书状结构展示资源的调用链路；另外一种则不区分调用链路展示资源的运行情况。通过链路监控，可以查看到每个资源的流控和降级的历史状态。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">树状链路</th>\n<th style=\"text-align:left\">平铺链路</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><img src=\"https://github.com/alibaba/Sentinel/wiki/image/resourceTree.png\" alt=\"resourceTree\"></td>\n<td style=\"text-align:left\"><img src=\"https://github.com/alibaba/Sentinel/wiki/image/sentine_dashboard.gif\" alt=\"cluster\"></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>聚合监控</strong>：同一个服务下的所有机器的簇点信息会被汇总，实现实时监控，精确度达秒级。</li>\n</ul>\n<p><img src=\"../../img/blog/sentinel-dashboard-metrics.png\" alt=\"秒级实时监控\"></p>\n<ul>\n<li><strong>规则配置</strong>：可以查看已有的限流、降级和系统保护规则，并实时地进行配置。</li>\n</ul>\n<p><img src=\"../../img/blog/sentinel-dashboard-view-rules.png\" alt=\"规则配置\"></p>\n<h2>Sentinel 基于 Dubbo 的最佳实践</h2>\n<blockquote>\n<p>具体 Demo 代码请见 <a href=\"https://github.com/alibaba/Sentinel/tree/master/sentinel-demo/sentinel-demo-dubbo\">sentinel-demo-dubbo</a>。</p>\n</blockquote>\n<h3>Service Provider</h3>\n<blockquote>\n<p>对服务提供方的流量控制可分为<strong>服务提供方的自我保护能力</strong>和<strong>服务提供方对服务消费方的请求分配能力</strong>两个维度。</p>\n</blockquote>\n<p>Service Provider 用于向外界提供服务，处理各个消费者的调用请求。为了保护 Provider 不被激增的流量拖垮影响稳定性，可以给 Provider 配置 <strong>QPS 模式</strong>的限流，这样当每秒的请求量超过设定的阈值时会自动拒绝多的请求。限流粒度可以是 <em>服务接口</em> 和 <em>服务方法</em> 两种粒度。若希望整个服务接口的 QPS 不超过一定数值，则可以为对应服务接口资源（resourceName 为<strong>接口全限定名</strong>）配置 QPS 阈值；若希望服务的某个方法的 QPS 不超过一定数值，则可以为对应服务方法资源（resourceName 为<strong>接口全限定名:方法签名</strong>）配置 QPS 阈值。有关配置详情请参考 <a href=\"https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6\">流量控制 | Sentinel</a>。</p>\n<p>我们看一下这种模式的限流产生的效果。假设我们已经定义了某个服务接口 <code>com.alibaba.csp.sentinel.demo.dubbo.FooService</code>，其中有一个方法 <code>sayHello(java.lang.String)</code>，Provider 端该方法设定 QPS 阈值为 10。在 Consumer 端在 1s 之内连续发起 15 次调用，可以通过日志文件看到 Provider 端被限流。拦截日志统一记录在 <code>~/logs/csp/sentinel-block.log</code> 中：</p>\n<pre><code>2018-07-24 17:13:43|1|com.alibaba.csp.sentinel.demo.dubbo.FooService:sayHello(java.lang.String),FlowException,default,|5,0\n</code></pre>\n<p>在 Provider 对应的 metrics 日志中也有记录：</p>\n<pre><code>1532423623000|2018-07-24 17:13:43|com.alibaba.csp.sentinel.demo.dubbo.FooService|15|0|15|0|3\n1532423623000|2018-07-24 17:13:43|com.alibaba.csp.sentinel.demo.dubbo.FooService:sayHello(java.lang.String)|10|5|10|0|0\n</code></pre>\n<p>根据<strong>调用方</strong>的需求来分配服务提供方的处理能力也是常见的限流方式。比如有两个服务 A 和 B 都向 Service Provider 发起调用请求，我们希望只对来自服务 B 的请求进行限流，则可以设置限流规则的 <code>limitApp</code> 为服务 B 的名称。Sentinel Dubbo Adapter 会自动解析 Dubbo 消费者（调用方）的 application name 作为调用方名称（<code>origin</code>），在进行资源保护的时候都会带上调用方名称。若限流规则未配置调用方（<code>default</code>），则该限流规则对所有调用方生效。若限流规则配置了调用方则限流规则将仅对指定调用方生效。</p>\n<blockquote>\n<p>注：Dubbo 默认通信不携带对端 application name 信息，因此需要开发者在调用端手动将 application name 置入 attachment 中，provider 端进行相应的解析。Sentinel Dubbo Adapter 实现了一个 Filter 用于自动从 consumer 端向 provider 端透传 application name。若调用端未引入 Sentinel Dubbo Adapter，又希望根据调用端限流，可以在调用端手动将 application name 置入 attachment 中，key 为 <code>dubboApplication</code>。</p>\n</blockquote>\n<p>在限流日志中会也会记录调用方的名称，如下面的日志中的 <code>demo-consumer</code> 即为调用方名称：</p>\n<pre><code>2018-07-25 16:26:48|1|com.alibaba.csp.sentinel.demo.dubbo.FooService:sayHello(java.lang.String),FlowException,default,demo-consumer|5,0\n</code></pre>\n<h3>Service Consumer</h3>\n<blockquote>\n<p>对服务提供方的流量控制可分为<strong>控制并发线程数</strong>和<strong>服务降级</strong>两个维度。</p>\n</blockquote>\n<h4>并发线程数限流</h4>\n<p>Service Consumer 作为客户端去调用远程服务。每一个服务都可能会依赖几个下游服务，若某个服务 A 依赖的下游服务 B 出现了不稳定的情况，服务 A 请求 服务 B 的响应时间变长，从而服务 A 调用服务 B 的线程就会产生堆积，最终可能耗尽服务 A 的线程数。我们通过用并发线程数来控制对下游服务 B 的访问，来保证下游服务不可靠的时候，不会拖垮服务自身。基于这种场景，推荐给 Consumer 配置<strong>线程数模式</strong>的限流，来保证自身不被不稳定服务所影响。采用基于线程数的限流模式后，我们不需要再显式地去进行线程池隔离，Sentinel 会控制资源的线程数，超出的请求直接拒绝，直到堆积的线程处理完成，可以达到<strong>信号量隔离</strong>的效果。</p>\n<p>我们看一下这种模式的效果。假设当前服务 A 依赖两个远程服务方法 <code>sayHello(java.lang.String)</code> 和 <code>doAnother()</code>。前者远程调用的响应时间 为 1s-1.5s 之间，后者 RT 非常小（30 ms 左右）。服务 A 端设两个远程方法 thread count 为 5。然后每隔 50 ms 左右向线程池投入两个任务，作为消费者分别远程调用对应方法，持续 10 次。可以看到 <code>sayHello</code> 方法被限流 5 次，因为后面调用的时候前面的远程调用还未返回（RT 高）；而 <code>doAnother()</code> 调用则不受影响。线程数目超出时快速失败能够有效地防止自己被慢调用所影响。</p>\n<h4>服务降级</h4>\n<p>当服务依赖于多个下游服务，而某个下游服务调用非常慢时，会严重影响当前服务的调用。这里我们可以利用 Sentinel 熔断降级的功能，为调用端配置基于平均 RT 的<a href=\"https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7\">降级规则</a>。这样当调用链路中某个服务调用的平均 RT 升高，在一定的次数内超过配置的 RT 阈值，Sentinel 就会对此调用资源进行降级操作，接下来的调用都会立刻拒绝，直到过了一段设定的时间后才恢复，从而保护服务不被调用端短板所影响。同时可以配合 fallback 功能使用，在被降级的时候提供相应的处理逻辑。</p>\n<h3>Fallback</h3>\n<p>从 0.1.1 版本开始，Sentinel Dubbo Adapter 还支持配置全局的 fallback 函数，可以在 Dubbo 服务被限流/降级/负载保护的时候进行相应的 fallback 处理。用户只需要实现自定义的 <a href=\"https://github.com/alibaba/Sentinel/blob/master/sentinel-adapter/sentinel-dubbo-adapter/src/main/java/com/alibaba/csp/sentinel/adapter/dubbo/fallback/DubboFallback.java\"><code>DubboFallback</code></a> 接口，并通过 <code>DubboFallbackRegistry</code> 注册即可。默认情况会直接将 <code>BlockException</code> 包装后抛出。同时，我们还可以配合 <a href=\"http://dubbo.apache.org/#!/docs/user/demos/local-mock.md?lang=zh-cn\">Dubbo 的 fallback 机制</a> 来为降级的服务提供替代的实现。</p>\n<h2>Sentinel 与 Hystrix 的比较</h2>\n<p>目前业界常用的熔断降级/隔离的库是 Netflix 的 <a href=\"https://github.com/Netflix/Hystrix\">Hystrix</a>，那么 Sentinel 与 Hystrix 有什么异同呢？Hystrix 的关注点在于以 <em>隔离</em> 和 <em>熔断</em> 为主的容错机制，而 Sentinel 的侧重点在于多样化的流量控制、熔断降级、系统负载保护、实时监控和控制台，可以看到解决的问题还是有比较大的不同的。</p>\n<p>Hystrix 采用命令模式封装资源调用逻辑，并且资源的定义与隔离规则是强依赖的，即在创建 HystrixCommand 的时候就要指定隔离规则（因其执行模型依赖于隔离模式）。Sentinel 的设计更为简单，不关注资源是如何执行的，资源的定义与规则的配置相分离。用户可以先定义好资源，然后在需要的时候配置规则即可。Sentinel 的原则非常简单：根据对应资源配置的规则来为资源执行相应的限流/降级/负载保护策略，若规则未配置则仅进行统计。从 0.1.1 版本开始，Sentinel 还引入了<a href=\"https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81\">注解支持</a>，可以更方便地定义资源。</p>\n<p>隔离是 Hystrix 的核心功能。Hystrix 通过线程池或信号量的方式来对依赖（即 Sentinel 中对应的资源）进行隔离，其中最常用的是资源隔离。Hystrix 线程池隔离的好处是比较彻底，但是不足之处在于要开很多线程池，在应用本身线程数目比较多的时候上下文切换的 overhead 会非常大；Hystrix 的信号量隔离模式可以限制调用的并发数而不显式创建线程，这样的方式比较轻量级，但缺点是无法对慢调用自动进行降级，只能等待客户端自己超时，因此仍然可能会出现级联阻塞的情况。Sentinel 可以通过并发线程数模式的流量控制来提供信号量隔离的功能。并且结合基于响应时间的熔断降级模式，可以在不稳定资源的平均响应时间比较高的时候自动降级，防止过多的慢调用占满并发数，影响整个系统。</p>\n<p>Hystrix 熔断降级功能采用熔断器模式，在某个服务失败比率高时自动进行熔断。Sentinel 的熔断降级功能更为通用，支持平均响应时间与失败比率两个指标。Sentinel 还提供各种调用链路关系和流量控制效果支持，同时还可以根据系统负载去实时地调整流量来保护系统，应用场景更为丰富。同时，Sentinel 还提供了实时的监控 API 和控制台，可以方便用户快速了解目前系统的状态，对服务的稳定性了如指掌。</p>\n<p>更详细的对比请参见 <a href=\"https://github.com/alibaba/Sentinel/wiki/Sentinel-%E4%B8%8E-Hystrix-%E7%9A%84%E5%AF%B9%E6%AF%94\">Sentinel 与 Hystrix 的对比</a>。</p>\n<h2>总结</h2>\n<p>以上介绍的只是 Sentinel 的一个最简单的场景 —— 限流。Sentinel 还可以处理更复杂的各种情况，比如超时熔断、冷启动、请求匀速等。可以参考 <a href=\"https://github.com/alibaba/Sentinel/wiki/%E4%B8%BB%E9%A1%B5\">Sentinel 文档</a>，更多的场景等待你去挖掘！</p>\n"
    },
    {
      "filename": "spring-boot-dubbo-start-stop-analysis.md",
      "__html": "<h1>Spring-boot+Dubbo应用启停源码分析</h1>\n<h3>背景介绍</h3>\n<p><a href=\"https://github.com/apache/incubator-dubbo-spring-boot-project\">Dubbo Spring Boot</a> 工程致力于简化 Dubbo RPC 框架在Spring Boot应用场景的开发。同时也整合了 Spring Boot 特性：</p>\n<ul>\n<li><a href=\"https://github.com/apache/incubator-dubbo-spring-boot-project/blob/master/dubbo-spring-boot-autoconfigure\">自动装配</a> (比如： 注解驱动, 自动装配等).</li>\n<li><a href=\"https://github.com/apache/incubator-dubbo-spring-boot-project/blob/master/dubbo-spring-boot-actuator\">Production-Ready</a> (比如： 安全, 健康检查, 外部化配置等).</li>\n</ul>\n<h3>DubboConsumer启动分析</h3>\n<p>你有没有想过一个问题？<code>incubator-dubbo-spring-boot-project</code>中的<code>DubboConsumerDemo</code>应用就一行代码，<code>main</code>方法执行完之后，为什么不会直接退出呢？</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@SpringBootApplication</span>(scanBasePackages = <span class=\"hljs-string\">\"com.alibaba.boot.dubbo.demo.consumer.controller\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DubboConsumerDemo</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(DubboConsumerDemo.class,args);\n    }\n\n}\n</code></pre>\n<p>其实要回答这样一个问题，我们首先需要把这个问题进行一个抽象，即一个JVM进程，在什么情况下会退出？</p>\n<p>以Java 8为例，通过查阅JVM语言规范[1]，在12.8章节中有清晰的描述：</p>\n<p>A program terminates all its activity and <em>exits</em> when one of two things happens:</p>\n<ul>\n<li>All the threads that are not daemon threads terminate.</li>\n<li>Some thread invokes the <code>exit</code> method of class <code>Runtime</code> or class <code>System</code>, and the <code>exit</code> operation is not forbidden by the security manager.</li>\n</ul>\n<p>也就是说，导致JVM的退出只有2种情况：</p>\n<ol>\n<li>所有的非daemon进程完全终止</li>\n<li>某个线程调用了<code>System.exit()</code>或<code>Runtime.exit()</code></li>\n</ol>\n<p>因此针对上面的情况，我们判断，一定是有某个非daemon线程没有退出导致。我们知道，通过jstack可以看到所有的线程信息，包括他们是否是daemon线程，可以通过jstack找出那些是非deamon的线程。</p>\n<pre><code class=\"language-sh\">➜  jstack 57785 | grep tid | grep -v <span class=\"hljs-string\">\"daemon\"</span>\n<span class=\"hljs-string\">\"container-0\"</span> <span class=\"hljs-comment\">#37 prio=5 os_prio=31 tid=0x00007fbe312f5800 nid=0x7103 waiting on condition  [0x0000700010144000]</span>\n<span class=\"hljs-string\">\"container-1\"</span> <span class=\"hljs-comment\">#49 prio=5 os_prio=31 tid=0x00007fbe3117f800 nid=0x7b03 waiting on condition  [0x0000700010859000]</span>\n<span class=\"hljs-string\">\"DestroyJavaVM\"</span> <span class=\"hljs-comment\">#83 prio=5 os_prio=31 tid=0x00007fbe30011000 nid=0x2703 waiting on condition  [0x0000000000000000]</span>\n<span class=\"hljs-string\">\"VM Thread\"</span> os_prio=31 tid=0x00007fbe3005e800 nid=0x3703 runnable\n<span class=\"hljs-string\">\"GC Thread#0\"</span> os_prio=31 tid=0x00007fbe30013800 nid=0x5403 runnable\n<span class=\"hljs-string\">\"GC Thread#1\"</span> os_prio=31 tid=0x00007fbe30021000 nid=0x5303 runnable\n<span class=\"hljs-string\">\"GC Thread#2\"</span> os_prio=31 tid=0x00007fbe30021800 nid=0x2d03 runnable\n<span class=\"hljs-string\">\"GC Thread#3\"</span> os_prio=31 tid=0x00007fbe30022000 nid=0x2f03 runnable\n<span class=\"hljs-string\">\"G1 Main Marker\"</span> os_prio=31 tid=0x00007fbe30040800 nid=0x5203 runnable\n<span class=\"hljs-string\">\"G1 Conc#0\"</span> os_prio=31 tid=0x00007fbe30041000 nid=0x4f03 runnable\n<span class=\"hljs-string\">\"G1 Refine#0\"</span> os_prio=31 tid=0x00007fbe31044800 nid=0x4e03 runnable\n<span class=\"hljs-string\">\"G1 Refine#1\"</span> os_prio=31 tid=0x00007fbe31045800 nid=0x4d03 runnable\n<span class=\"hljs-string\">\"G1 Refine#2\"</span> os_prio=31 tid=0x00007fbe31046000 nid=0x4c03 runnable\n<span class=\"hljs-string\">\"G1 Refine#3\"</span> os_prio=31 tid=0x00007fbe31047000 nid=0x4b03 runnable\n<span class=\"hljs-string\">\"G1 Young RemSet Sampling\"</span> os_prio=31 tid=0x00007fbe31047800 nid=0x3603 runnable\n<span class=\"hljs-string\">\"VM Periodic Task Thread\"</span> os_prio=31 tid=0x00007fbe31129000 nid=0x6703 waiting on condition\n\n</code></pre>\n<blockquote>\n<p>此处通过grep tid 找出所有的线程摘要，通过grep -v找出不包含daemon关键字的行</p>\n</blockquote>\n<p>通过上面的结果，我们发现了一些信息：</p>\n<ul>\n<li>有两个线程<code>container-0</code>, <code>container-1</code>非常可疑，他们是非daemon线程，处于wait状态</li>\n<li>有一些GC相关的线程，和VM打头的线程，也是非daemon线程，但他们很有可能是JVM自己的线程，在此暂时忽略。</li>\n</ul>\n<p>综上，我们可以推断，很可能是因为<code>container-0</code>和<code>container-1</code>导致JVM没有退出。现在我们通过源码，搜索一下到底是谁创建的这两个线程。</p>\n<p>通过对spring-boot的源码分析，我们在<code>org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainer</code>的<code>startDaemonAwaitThread</code>找到了如下代码</p>\n<pre><code class=\"language-java\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">startDaemonAwaitThread</span><span class=\"hljs-params\">()</span> </span>{\n\t\tThread awaitThread = <span class=\"hljs-keyword\">new</span> Thread(<span class=\"hljs-string\">\"container-\"</span> + (containerCounter.get())) {\n\n\t\t\t<span class=\"hljs-meta\">@Override</span>\n\t\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n\t\t\t\tTomcatEmbeddedServletContainer.<span class=\"hljs-keyword\">this</span>.tomcat.getServer().await();\n\t\t\t}\n\n\t\t};\n\t\tawaitThread.setContextClassLoader(getClass().getClassLoader());\n\t\tawaitThread.setDaemon(<span class=\"hljs-keyword\">false</span>);\n\t\tawaitThread.start();\n\t}\n</code></pre>\n<p>在这个方法加个断点，看下调用堆栈：</p>\n<pre><code>initialize:115, TomcatEmbeddedServletContainer (org.springframework.boot.context.embedded.tomcat)\n&lt;init&gt;:84, TomcatEmbeddedServletContainer (org.springframework.boot.context.embedded.tomcat)\ngetTomcatEmbeddedServletContainer:554, TomcatEmbeddedServletContainerFactory (org.springframework.boot.context.embedded.tomcat)\ngetEmbeddedServletContainer:179, TomcatEmbeddedServletContainerFactory (org.springframework.boot.context.embedded.tomcat)\ncreateEmbeddedServletContainer:164, EmbeddedWebApplicationContext (org.springframework.boot.context.embedded)\nonRefresh:134, EmbeddedWebApplicationContext (org.springframework.boot.context.embedded)\nrefresh:537, AbstractApplicationContext (org.springframework.context.support)\nrefresh:122, EmbeddedWebApplicationContext (org.springframework.boot.context.embedded)\nrefresh:693, SpringApplication (org.springframework.boot)\nrefreshContext:360, SpringApplication (org.springframework.boot)\nrun:303, SpringApplication (org.springframework.boot)\nrun:1118, SpringApplication (org.springframework.boot)\nrun:1107, SpringApplication (org.springframework.boot)\nmain:35, DubboConsumerDemo (com.alibaba.boot.dubbo.demo.consumer.bootstrap)\n</code></pre>\n<p>可以看到，spring-boot应用在启动的过程中，由于默认启动了Tomcat暴露HTTP服务，所以执行到了上述方法，而Tomcat启动的所有的线程，默认都是daemon线程，例如监听请求的Acceptor，工作线程池等等，如果这里不加控制的话，启动完成之后JVM也会退出。因此需要显示的启动一个线程，在某个条件下进行持续等待，从而避免线程退出。</p>\n<p>下面我们在深挖一下，在Tomcat的<code>this.tomcat.getServer().await()</code>这个方法中，线程是如何实现不退出的。这里为了阅读方便，去掉了不相关的代码。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">await</span><span class=\"hljs-params\">()</span> </span>{\n    \t<span class=\"hljs-comment\">// ...</span>\n        <span class=\"hljs-keyword\">if</span>( port==-<span class=\"hljs-number\">1</span> ) {\n            <span class=\"hljs-keyword\">try</span> {\n                awaitThread = Thread.currentThread();\n                <span class=\"hljs-keyword\">while</span>(!stopAwait) {\n                    <span class=\"hljs-keyword\">try</span> {\n                        Thread.sleep( <span class=\"hljs-number\">10000</span> );\n                    } <span class=\"hljs-keyword\">catch</span>( InterruptedException ex ) {\n                        <span class=\"hljs-comment\">// continue and check the flag</span>\n                    }\n                }\n            } <span class=\"hljs-keyword\">finally</span> {\n                awaitThread = <span class=\"hljs-keyword\">null</span>;\n            }\n            <span class=\"hljs-keyword\">return</span>;\n        }\n\t\t<span class=\"hljs-comment\">// ...</span>\n    }\n</code></pre>\n<p>在await方法中，实际上当前线程在一个while循环中每10秒检查一次 <code>stopAwait</code>这个变量，它是一个<code>volatile</code>类型变量，用于确保被另一个线程修改后，当前线程能够立即看到这个变化。如果没有变化，就会一直处于while循环中。这就是该线程不退出的原因，也就是整个spring-boot应用不退出的原因。</p>\n<p>因为Springboot应用同时启动了8080和8081(management port)两个端口，实际是启动了两个Tomcat，因此会有两个线程<code>container-0</code>和<code>container-1</code>。</p>\n<p>接下来，我们再看看，这个Spring-boot应用又是如何退出的呢？</p>\n<h3>DubboConsumer退出分析</h3>\n<p>在前面的描述中提到，有一个线程持续的在检查<code>stopAwait</code>这个变量，那么我们自然想到，在Stop的时候，应该会有一个线程去修改<code>stopAwait</code>，打破这个while循环，那又是谁在修改这个变量呢？</p>\n<p>通过对源码分析，可以看到只有一个方法修改了<code>stopAwait</code>,即<code>org.apache.catalina.core.StandardServer#stopAwait</code>，我们在此处加个断点，看看是谁在调用。</p>\n<blockquote>\n<p>注意，当我们在Intellij IDEA的Debug模式，加上一个断点后，需要在命令行下使用<code>kill -s INT $PID</code>或者<code>kill -s TERM $PID</code>才能触发断点，点击IDE上的Stop按钮，不会触发断点。这是IDEA的bug</p>\n</blockquote>\n<p>可以看到有一个名为<code>Thread-3</code>的线程调用了该方法：</p>\n<pre><code class=\"language-java\">stopAwait:<span class=\"hljs-number\">390</span>, StandardServer (org.apache.catalina.core)\nstopInternal:<span class=\"hljs-number\">819</span>, StandardServer (org.apache.catalina.core)\nstop:<span class=\"hljs-number\">226</span>, LifecycleBase (org.apache.catalina.util)\nstop:<span class=\"hljs-number\">377</span>, Tomcat (org.apache.catalina.startup)\nstopTomcat:<span class=\"hljs-number\">241</span>, TomcatEmbeddedServletContainer (org.springframework.boot.context.embedded.tomcat)\nstop:<span class=\"hljs-number\">295</span>, TomcatEmbeddedServletContainer (org.springframework.boot.context.embedded.tomcat)\nstopAndReleaseEmbeddedServletContainer:<span class=\"hljs-number\">306</span>, EmbeddedWebApplicationContext (org.springframework.boot.context.embedded)\nonClose:<span class=\"hljs-number\">155</span>, EmbeddedWebApplicationContext (org.springframework.boot.context.embedded)\ndoClose:<span class=\"hljs-number\">1014</span>, AbstractApplicationContext (org.springframework.context.support)\nrun:<span class=\"hljs-number\">929</span>, AbstractApplicationContext$<span class=\"hljs-number\">2</span> (org.springframework.context.support)\n</code></pre>\n<p>通过源码分析，原来是通过Spring注册的<code>ShutdownHook</code>来执行的</p>\n<pre><code class=\"language-java\">\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerShutdownHook</span><span class=\"hljs-params\">()</span> </span>{\n\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.shutdownHook == <span class=\"hljs-keyword\">null</span>) {\n\t\t\t<span class=\"hljs-comment\">// No shutdown hook registered yet.</span>\n\t\t\t<span class=\"hljs-keyword\">this</span>.shutdownHook = <span class=\"hljs-keyword\">new</span> Thread() {\n\t\t\t\t<span class=\"hljs-meta\">@Override</span>\n\t\t\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n\t\t\t\t\t<span class=\"hljs-keyword\">synchronized</span> (startupShutdownMonitor) {\n\t\t\t\t\t\tdoClose();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tRuntime.getRuntime().addShutdownHook(<span class=\"hljs-keyword\">this</span>.shutdownHook);\n\t\t}\n\t}\n</code></pre>\n<p>通过查阅Java的API文档[2], 我们可以知道ShutdownHook将在下面两种情况下执行</p>\n<blockquote>\n<p>The Java virtual machine <em>shuts down</em> in response to two kinds of events:</p>\n<ul>\n<li>The program <em>exits</em> normally, when the last non-daemon thread exits or when the <code>exit</code> (equivalently, <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#exit-int-\"><code>System.exit</code></a>) method is invoked, or</li>\n<li>The virtual machine is <em>terminated</em> in response to a user interrupt, such as typing <code>^C</code>, or a system-wide event, such as user logoff or system shutdown.</li>\n</ul>\n</blockquote>\n<ol>\n<li>调用了System.exit()方法</li>\n<li>响应外部的信号，例如Ctrl+C（其实发送的是SIGINT信号），或者是<code>SIGTERM</code>信号（默认<code>kill $PID</code>发送的是<code>SIGTERM</code>信号）</li>\n</ol>\n<p>因此，正常的应用在停止过程中(<code>kill -9 $PID</code>除外)，都会执行上述ShutdownHook，它的作用不仅仅是关闭tomcat，还有进行其他的清理工作，在此不再赘述。</p>\n<h3>总结</h3>\n<ol>\n<li>在<code>DubboConsumer</code>启动的过程中，通过启动一个独立的非daemon线程循环检查变量的状态，确保进程不退出</li>\n<li>在<code>DubboConsumer</code>停止的过程中，通过执行spring容器的shutdownhook，修改了变量的状态，使得程序正常退出</li>\n</ol>\n<h3>问题</h3>\n<p>在DubboProvider的例子中，我们看到Provider并没有启动Tomcat提供HTTP服务，那又是如何实现不退出的呢？我们将在下一篇文章中回答这个问题。</p>\n<h4>彩蛋</h4>\n<p>在<code>Intellij IDEA</code>中运行了如下的单元测试，创建一个线程执行睡眠1000秒的操作，我们惊奇的发现，代码并没有线程执行完就退出了，这又是为什么呢？（被创建的线程是非daemon线程）</p>\n<pre><code class=\"language-java\">    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">new</span> Thread(<span class=\"hljs-keyword\">new</span> Runnable() {\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n                <span class=\"hljs-keyword\">try</span> {\n                    Thread.sleep(<span class=\"hljs-number\">1000000</span>);\n                } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n</code></pre>\n<p>[1] <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.8\">https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.8</a></p>\n<p>[2] <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#addShutdownHook\">https://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#addShutdownHook</a></p>\n"
    }
  ],
  "en-us": [
    {
      "filename": "apachecon-na-2018.md",
      "__html": "<h2>The ApacheCon NA schedule has been announced</h2>\n<p>Ian Luo(PPMC) and Jun Liu(PPMC) will talk about &quot;Introducing Apache Dubbo(Incubating): What is Dubbo and How it Works&quot; at ApacheCon NA this year in Montréal! Please check out the schedule <a href=\"https://apachecon.dukecon.org/acna/2018/#/scheduledEvent/b8db9dc580d85853f\">here</a> and register <a href=\"https://www.eventbrite.com/e/apachecon-north-america-2018-registration-43200327342\">here</a>.</p>\n"
    },
    {
      "filename": "dubbo-101.md",
      "__html": "<h1>Your First Dubbo Demo</h1>\n<h2>Java RMI Introduction</h2>\n<p>Java RMI (Remote Method Invocation) is a mechanism that allows users to access or invocate an object and a method running on another JVM (Java Virtual Machine). RMI is an implementation of RPC (Remote Procedure Call) in java with support of OOP (Object Oriented Paradigms). Instead of bothering IDL (Interface Define Language), users can build distributed applications by depending on interfaces in an easy and natural way.</p>\n<h3>Java RMI Work Flow</h3>\n<p>Here is how a typical RMI invocation usually works：</p>\n<ol>\n<li>The server registers service from RMI and binds its address.</li>\n<li>The client registers service from RMI and obtains target address.</li>\n<li>The client invokes methods of local stub object in the same way of invoking other local objects.</li>\n<li>Local stub object zips invoking information and send it to the server via network.</li>\n<li>The Skeleton object of server receives the network request and unzips the information.</li>\n<li>Server runs invocation on the target object based on the information and return the zipped results back to client via network.</li>\n</ol>\n<p><img src=\"../../img/blog/rmi-flow.png\" alt=\"RMI Flow\"></p>\n<p>(source：<a href=\"https://www.cs.rutgers.edu/~pxk/417/notes/images/rpc-rmi_flow.png\">https://www.cs.rutgers.edu/~pxk/417/notes/images/rpc-rmi_flow.png</a>)</p>\n<h3>Java RMI Concepts</h3>\n<p>Java RMI is a technique foundation stone of creating distributed applications in Java. The following EJB techniques and current framework of distributed services still inherit the fundamental concepts of Java RMI. In RMI invocation, there are some core concepts：</p>\n<ol>\n<li>The invocation is run remotely on <strong>interface</strong>.</li>\n<li>\n<ol start=\"2\">\n<li>Disguise remote invocation as local invocation by <strong>Stub object</strong> on client and <strong>Skeleton object</strong> on server.</li>\n</ol>\n</li>\n<li>The service is registered and looked up by <strong>RMI</strong> registry service.</li>\n</ol>\n<p>For 1. users are dependent on interfaces which should be implemented by server.</p>\n<p>For 2. In J2SE 1.5 version and before, it needs to pre-compile Stub on client and Skeleton on server by rmic. In the later versions there is no need to do so.</p>\n<p>The following is a code example of registry and look-up in RMI.</p>\n<h4>Server service registry</h4>\n<pre><code class=\"language-java\">Hello obj = <span class=\"hljs-keyword\">new</span> HelloImpl(); <span class=\"hljs-comment\">// #1</span>\nHello stub = (Hello) UnicastRemoteObject.exportObject(obj, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// #2</span>\nRegistry registry = LocateRegistry.createRegistry(<span class=\"hljs-number\">1099</span>); <span class=\"hljs-comment\">// #3</span>\nregistry.rebind(<span class=\"hljs-string\">\"Hello\"</span>, stub); <span class=\"hljs-comment\">// #4</span>\n</code></pre>\n<p>Notes:</p>\n<ol>\n<li>\n<p>Initiate service object instance.</p>\n</li>\n<li>\n<p>Create stub object to communicate with the server by UnicastRemoteObject.exportObject.</p>\n</li>\n<li>\n<p>Create a local RMI registry service on port 1099 which is run on server. It can also be registered as an independent process.</p>\n</li>\n<li>\n<p>Bind stub object into registry so the client can find the remote object by looking up Hello.</p>\n</li>\n</ol>\n<h4>Client service look-up</h4>\n<pre><code class=\"language-java\">Registry registry = LocateRegistry.getRegistry(); <span class=\"hljs-comment\">// #1</span>\nHello stub = (Hello) registry.lookup(<span class=\"hljs-string\">\"Hello\"</span>); <span class=\"hljs-comment\">// #2</span>\nString response = stub.sayHello(); <span class=\"hljs-comment\">// #3</span>\n</code></pre>\n<p>Notes:</p>\n<ol>\n<li>Acquire registry service instances. In this case, there is no input parameters so it is assumed that the acquired instance is located on port 1099.</li>\n<li>Look up the remote object named Hello in registry service.</li>\n<li>Run a RMI invocation via acquired Stub object and get results.\nUnderstand the work flow and basic concepts of RMI is helpful to handle current framework of distributed service. It is recommended to refer to RMI official documents for further information[^1].</li>\n</ol>\n<h2>Basic Concepts of Dubbo</h2>\n<p>The basic concepts of current framework of distributed service is similar to the one of RMI. They both use Java interface as service contract, register and look up by registry center and use agency to block the details of remote communications. Specifically, Dubbo has following four types of roles to play when running：</p>\n<ol>\n<li>Serve the provider – Expose service at assigned ports at initialization and register the service address and ports at registry center</li>\n<li>Serve the consumer – Subscribe the service of interests at registry center at initialization to acquire the list of addresses provided by the service provider.</li>\n<li>Registry center – Register and look up service. Store the address provided by the service provider and send it to the consumer.</li>\n<li>Monitor center – Collect and monitor running status of providers and consumers, e.g., times of invocations, delay of invocations, etc.</li>\n<li>Running container – Initialize and load the provider and manage the lifecycle of running.</li>\n</ol>\n<p><img src=\"../../img/blog/dubbo-architecture.png\" alt=\"dubbo-architecture\"></p>\n<p><strong>Deploy stage</strong></p>\n<ul>\n<li>Service providers expose service at assigned ports and register information of service at registry center.</li>\n<li>Service consumers subscribe the list of service addresses from registry center.</li>\n</ul>\n<p><strong>Run stage</strong></p>\n<ul>\n<li>Registry center sends the address to service consumers.</li>\n<li>After receiving the list of addresses, service consumers select one of them and invoke an object service.</li>\n<li>During invocation, the running status of service providers and consumers is reported to the monitor center.</li>\n</ul>\n<h2>Dubbo Applications Based on API</h2>\n<p>The applications of Dubbo are usually assembled by Spring. To obtain an available Dubbo application quickly, the example shown here abandons complex configurations but to create service provider and consumer in Dubbo API oriented way. Additionally, the registry center and monitor center do not need installation or configuration in this example.</p>\n<p>In production environment, the service of Dubbo usually requires cooperation with a distributed service registry center, such as ZooKeeper. For convenience, Dubbo offers two ways to avoid extra work of building registry center, namely direct connection [2] and assembled podcast [3] respectively. In this example, the latter way is applied to register and look up service.</p>\n<h3>Define Service Contract</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">GreetingsService</span> </span>{\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">sayHi</span><span class=\"hljs-params\">(String name)</span></span>; <span class=\"hljs-comment\">// #1</span>\n}\n</code></pre>\n<p><strong>Notes</strong>：</p>\n<ol>\n<li>The codes define a simple service contract where there is only one function, sayHi, can be invoked. The type of input parameter and return value are both String.</li>\n</ol>\n<h3>Provide Contract Implementation</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GreetingsServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">GreetingsService</span> </span>{ <span class=\"hljs-comment\">// #1</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHi</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hi, \"</span> + name; <span class=\"hljs-comment\">// #2</span>\n    }\n}\n</code></pre>\n<p><strong>Notes</strong>：</p>\n<ol>\n<li>Service providers need to implement the interface of service contract, GreetingsService.</li>\n<li>This function simply returns a welcome message. For example, if the input value is <em>dubbo</em>，it will return <em>hi, dubbo</em>.</li>\n</ol>\n<h3>Implement Dubbo Service Provider</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Application</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        ServiceConfig&lt;GreetingsService&gt; service = <span class=\"hljs-keyword\">new</span> ServiceConfig&lt;&gt;(); <span class=\"hljs-comment\">// #1</span>\n        service.setApplication(<span class=\"hljs-keyword\">new</span> ApplicationConfig(<span class=\"hljs-string\">\"first-dubbo-provider\"</span>)); <span class=\"hljs-comment\">// #2</span>\n        service.setRegistry(<span class=\"hljs-keyword\">new</span> RegistryConfig(<span class=\"hljs-string\">\"multicast://224.5.6.7:1234\"</span>)); <span class=\"hljs-comment\">// #3</span>\n        service.setInterface(GreetingsService.class); <span class=\"hljs-comment\">// #4</span>\n        service.setRef(<span class=\"hljs-keyword\">new</span> GreetingsServiceImpl()); <span class=\"hljs-comment\">// #5</span>\n        service.export(); <span class=\"hljs-comment\">// #6</span>\n        System.in.read(); <span class=\"hljs-comment\">// #7</span>\n    }\n}\n</code></pre>\n<p><strong>Notes</strong>：</p>\n<ol>\n<li>Create an instance <em>ServiceConfig</em> with service interface type as generics parameters, which is <em>GreetingsService</em> in this example.</li>\n<li>Generate an instance of <em>ApplicationConfig</em> and assemble it into <em>ServiceConfig</em>.</li>\n<li>Generate an instance <em>RegistryConfig</em> and assemble it into <em>ServiceConfig</em>. Since the assembled way is applied here, the parameter should be <code>multicast://224.5.6.7:1234</code>. The valid range of assembled address is <em>224.0.0.0 - 239.255.255.255</em></li>\n<li>Assemble the service contract <em>GreetingsService</em> into <em>ServiceConfig</em>.</li>\n<li>Assemble the instance with implementation of <em>GreetingsServicelmpl</em> provided by service providers into <em>ServiceConfig</em>.</li>\n<li><em>ServiceConfig</em> starts to expose itself at default ports <em>20880</em>. after being equipped with enough information.</li>\n<li>Press any key or <em>ctrl-C</em> to exit to avoid server halt.</li>\n</ol>\n<h3>Implement Dubbo Service Consumer</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Application</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        ReferenceConfig&lt;GreetingsService&gt; reference = <span class=\"hljs-keyword\">new</span> ReferenceConfig&lt;&gt;(); <span class=\"hljs-comment\">// #1</span>\n        reference.setApplication(<span class=\"hljs-keyword\">new</span> ApplicationConfig(<span class=\"hljs-string\">\"first-dubbo-client\"</span>)); <span class=\"hljs-comment\">// #2</span>\n        reference.setRegistry(<span class=\"hljs-keyword\">new</span> RegistryConfig(<span class=\"hljs-string\">\"multicast://224.5.6.7:1234\"</span>)); <span class=\"hljs-comment\">// #3</span>\n        reference.setInterface(GreetingsService.class); <span class=\"hljs-comment\">// #4</span>\n        GreetingsService greetingsService = reference.get(); <span class=\"hljs-comment\">// #5</span>\n        String message = greetingsService.sayHi(<span class=\"hljs-string\">\"dubbo\"</span>); <span class=\"hljs-comment\">// #6</span>\n        System.out.println(message); <span class=\"hljs-comment\">// #7</span>\n    }\n}\n</code></pre>\n<p><strong>Notes</strong>：</p>\n<ol>\n<li>Create an instance of <em>ReferenceConfig</em> with service interface type as generics parameters, which is <em>GreetingsService</em> in this example.</li>\n<li>Create an instance of <em>AplicatonConfig</em>, and assemble it into <em>ReferenceConfig</em>.</li>\n<li>Generate an instance <em>RegistryConfig</em>, and assemble it into <em>ReferenceConfig</em>. Note that the address information here should be the same as the one of the service provider.</li>\n<li>Assemble the service contract <em>GreetingsService</em> into <em>ReferenceConfig</em>.</li>\n<li>Obtain the agency of <em>GreetingsService</em> from <em>ReferenceConfig</em>.</li>\n<li>Invoke a remote call through <em>GreetingsSerive</em>’s agency and pass in <code>dubbo</code> as input parameter.</li>\n<li>Return and print results <code>hi, dubbo</code>.</li>\n</ol>\n<h3>Run</h3>\n<p>The complete example can be found at <a href=\"https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-api\">https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-api</a>. In the complete version, it is convenient to execute by maven in command line with the configuration of <em>exec-maven-plugin</em>. Of course, it can also be executed directly in IDE. However, there is one noteworthy thing that because of using assembled way to look up service, it needs to assign <em>-Djava.net.preferIPv4Stack=true</em> when running.</p>\n<h4>Build Example</h4>\n<p>Synchronize the example codes and build by the following command lines:</p>\n<ol>\n<li>Synchronize the example codes: git clone <a href=\"https://github.com/dubbo/dubbo-samples.git\">https://github.com/dubbo/dubbo-samples.git</a></li>\n<li>Build：mvn clean package</li>\n</ol>\n<pre><code class=\"language-bash\">$ git <span class=\"hljs-built_in\">clone</span> https://github.com/dubbo/dubbo-samples.git\n$ <span class=\"hljs-built_in\">cd</span> dubbo-samples/dubbo-samples-api/\n$ mvn clean package\nINFO] Scanning <span class=\"hljs-keyword\">for</span> projects...\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building dubbo-samples-api 1.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ dubbo-samples-api ---\n...\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 2.182 s\n[INFO] Finished at: 2018-05-28T14:56:08+08:00\n[INFO] Final Memory: 20M/353M\n[INFO] ------------------------------------------------------------------------\n</code></pre>\n<p>The build is finished when it shows <code>BUILD SUCCESS</code>. Then comes the running stage.</p>\n<h4>Run the server</h4>\n<p>Run the service provider by the following maven command lines:</p>\n<pre><code class=\"language-bash\">$ mvn -Djava.net.preferIPv4Stack=<span class=\"hljs-literal\">true</span> -Dexec.mainClass=com.alibaba.dubbo.samples.server.Application <span class=\"hljs-built_in\">exec</span>:java\n[INFO] Scanning <span class=\"hljs-keyword\">for</span> projects...\n[INFO]                                                                         \n[INFO] ------------------------------------------------------------------------\n[INFO] Building dubbo-samples-api 1.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- <span class=\"hljs-built_in\">exec</span>-maven-plugin:1.6.0:java (default-cli) @ dubbo-samples-api ---\nlog4j:WARN No appenders could be found <span class=\"hljs-keyword\">for</span> logger (com.alibaba.dubbo.common.logger.LoggerFactory).\nlog4j:WARN Please initialize the log4j system properly.\nlog4j:WARN See http://logging.apache.org/log4j/1.2/faq.html<span class=\"hljs-comment\">#noconfig for more info.</span>\nfirst-dubbo-provider is running.\n</code></pre>\n<p>When <em>first-dubbo-provider is running</em> appears, the service provider is ready to be called by the client.</p>\n<h4>Run the client</h4>\n<p>Run the service consumer by the following maven command lines:</p>\n<pre><code class=\"language-bash\">$ mvn -Djava.net.preferIPv4Stack=<span class=\"hljs-literal\">true</span> -Dexec.mainClass=com.alibaba.dubbo.samples.client.Application <span class=\"hljs-built_in\">exec</span>:java\n[INFO] Scanning <span class=\"hljs-keyword\">for</span> projects...\n[INFO]                                                                         \n[INFO] ------------------------------------------------------------------------\n[INFO] Building dubbo-samples-api 1.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- <span class=\"hljs-built_in\">exec</span>-maven-plugin:1.6.0:java (default-cli) @ dubbo-samples-api ---\nlog4j:WARN No appenders could be found <span class=\"hljs-keyword\">for</span> logger (com.alibaba.dubbo.common.logger.LoggerFactory).\nlog4j:WARN Please initialize the log4j system properly.\nlog4j:WARN See http://logging.apache.org/log4j/1.2/faq.html<span class=\"hljs-comment\">#noconfig for more info.</span>\nhi, dubbo\n</code></pre>\n<p><code>hi, dubbo</code> is the execution results from service provider.</p>\n<h2>Quick Creation of A Dubbo Application</h2>\n<p>Dubbo also provides a public platform that can create a Dubbo application quickly based on Spring Boot. Visit  <a href=\"http://start.dubbo.io\">http://start.dubbo.io</a> and follow the figure below to create an example project:</p>\n<p><img src=\"../../img/blog/dubbo-initializr.png\" alt=\"dubbo initializr\"></p>\n<p><strong>Notes</strong>：</p>\n<ol>\n<li>Provide maven groupId in <em>Group</em> with default value <code>com.example</code>.</li>\n<li>Provide maven artifactId in <em>Artifact</em> with default value <code>demo</code>.</li>\n<li>Provide the name of service in <em>DubboServiceName</em> with default value <code>com.example.HelloService</code>.</li>\n<li>Provide the version of service in <em>DubboServiceVersion</em> with default value <code>1.0.0</code>.</li>\n<li>Choose server or client in <em>Client/Server</em> with default value <code>server</code>.</li>\n<li><em>embeddedZookeeper</em> is selected by default as service registry look up.</li>\n<li>qos ports activation is not selected by default but if it is, it can be accessed by port <em>22222</em>.</li>\n<li>Click <em>Generate Project</em> to download the generated project.</li>\n</ol>\n<p>This example shows how to generate a server. Similarly, it can generate a <em>client</em> by selecting client on the generation interface.</p>\n<h3>Run</h3>\n<p>Open the generated project with an IDE and to see the application is a typical Spring Boot application with the following program entry:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoApplication</span> </span>{\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n\t\t<span class=\"hljs-keyword\">new</span> EmbeddedZooKeeper(<span class=\"hljs-number\">2181</span>, <span class=\"hljs-keyword\">false</span>).start();  <span class=\"hljs-comment\">// #1</span>\n\t\tSpringApplication.run(DemoApplication.class, args); <span class=\"hljs-comment\">// #2</span>\n\t}\n}\n</code></pre>\n<p><strong>Notes</strong>：</p>\n<ol>\n<li>Launch embedded <em>ZooKeeper</em> on port <em>2181</em>.</li>\n<li>Launch the context of <em>Spring Boot</em>.</li>\n</ol>\n<p>Run it directly in IDE and here are the results:</p>\n<pre><code class=\"language-bash\">2018-05-28 16:59:38.072  INFO 59943 --- [           main] a.b.d.c.e.WelcomeLogoApplicationListener :\n\n  ████████▄  ███    █▄  ▀█████████▄  ▀█████████▄   ▄██████▄  \n  ███   ▀███ ███    ███   ███    ███   ███    ███ ███    ███\n  ███    ███ ███    ███   ███    ███   ███    ███ ███    ███\n  ███    ███ ███    ███  ▄███▄▄▄██▀   ▄███▄▄▄██▀  ███    ███\n  ███    ███ ███    ███ ▀▀███▀▀▀██▄  ▀▀███▀▀▀██▄  ███    ███\n  ███    ███ ███    ███   ███    ██▄   ███    ██▄ ███    ███\n  ███   ▄███ ███    ███   ███    ███   ███    ███ ███    ███\n  ████████▀  ████████▀  ▄█████████▀  ▄█████████▀   ▀██████▀  \n\n\n :: Dubbo Spring Boot (v0.1.0) : https://github.com/dubbo/dubbo-spring-boot-project\n :: Dubbo (v2.0.1) : https://github.com/alibaba/dubbo\n :: Google group : http://groups.google.com/group/dubbo\n\n2018-05-28 16:59:38.079  INFO 59943 --- [           main] e.OverrideDubboConfigApplicationListener : Dubbo Config was overridden by externalized configuration {dubbo.application.name=dubbo-demo-server, dubbo.application.qosAcceptForeignIp=<span class=\"hljs-literal\">false</span>, dubbo.application.qosEnable=<span class=\"hljs-literal\">true</span>, dubbo.application.qosPort=22222, dubbo.registry.address=zookeeper://localhost:2181?client=curator, dubbo.registry.id=my-registry, dubbo.scan.basePackages=com.example} <span class=\"hljs-comment\">#1</span>\n\n...\n\n2018-05-28 16:59:39.624  INFO 59943 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication <span class=\"hljs-keyword\">in</span> 1.746 seconds (JVM running <span class=\"hljs-keyword\">for</span> 2.963)\n</code></pre>\n<p><strong>Notes</strong>：</p>\n<ol>\n<li>In the printouts, the configuration starting with <code>dubbo.</code> Is defined in <em>main/resources/application.properties</em>.</li>\n</ol>\n<h3>Manage service by Telnet</h3>\n<p>If <em>qos</em> is actived during generation, the service can be watched and managed by <em>telnet</em> or <em>nc</em>.</p>\n<pre><code class=\"language-bash\">$ telnet localhost 22222\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is <span class=\"hljs-string\">'^]'</span>.\n  ████████▄  ███    █▄  ▀█████████▄  ▀█████████▄   ▄██████▄  \n  ███   ▀███ ███    ███   ███    ███   ███    ███ ███    ███\n  ███    ███ ███    ███   ███    ███   ███    ███ ███    ███\n  ███    ███ ███    ███  ▄███▄▄▄██▀   ▄███▄▄▄██▀  ███    ███\n  ███    ███ ███    ███ ▀▀███▀▀▀██▄  ▀▀███▀▀▀██▄  ███    ███\n  ███    ███ ███    ███   ███    ██▄   ███    ██▄ ███    ███\n  ███   ▄███ ███    ███   ███    ███   ███    ███ ███    ███\n  ████████▀  ████████▀  ▄█████████▀  ▄█████████▀   ▀██████▀  \n\n\ndubbo&gt;\ndubbo&gt;ls\nAs Provider side:\n+------------------------------+---+\n|     Provider Service Name    |PUB|\n+------------------------------+---+\n|com.example.HelloService:1.0.0| Y |\n+------------------------------+---+\nAs Consumer side:\n+---------------------+---+\n|Consumer Service Name|NUM|\n+---------------------+---+\n</code></pre>\n<p>Currently, <em>qos</em> supports following command lines. For more information please refer to the official document. [^4]:</p>\n<ul>\n<li><em>ls</em>：List the information of client and server.</li>\n<li><em>online</em>：Bring the service online.</li>\n<li><em>offline</em>：Bring the service offline.</li>\n<li><em>help</em>：View online help.</li>\n</ul>\n<h2>Summary</h2>\n<p>In this tutorial, we start with RMI and introduce the basic concepts in Java distributed invocations. Based on interface programming, it disguises remote calls as local by agency and run the service registry and looking up by registry center.</p>\n<p>Then for simplicity, we introduce how to develop a complete Dubbo demo in an easy way of assembled registry and direct Dubbo API oriented programming. Additionally, we look into the usage of <em>ServiceConfig</em> and <em>RefenceConfig</em>, which is of great help for further using Spring XML configuration and the programming pattern of Spring Boot.</p>\n<p>Eventually, we give an outline of how to create a Dubbo application quickly based on Spring Boot using the public resources, <a href=\"http://start.dubbo.io\">start.dubbo.io</a>, provided by the Dubbo development team and operate and maintain the Dubbo service by <em>qos</em>.</p>\n<hr>\n<ol>\n<li><a href=\"https://docs.oracle.com/javase/6/docs/technotes/guides/rmi/hello/hello-world.html\">Getting Started Using JavaTM RMI</a></li>\n<li><a href=\"http://dubbo.apache.org/books/dubbo-user-book/demos/explicit-target.html\">直连提供者</a></li>\n<li><a href=\"http://dubbo.apache.org/books/dubbo-user-book/references/registry/multicast.html\">Multicast 注册中心</a></li>\n<li><a href=\"http://dubbo.apache.org/books/dubbo-user-book/references/qos.html\">在线运维命令</a></li>\n</ol>\n"
    },
    {
      "filename": "dubbo-annotation.md",
      "__html": "<h1>Use Annotations In Dubbo</h1>\n<p>With the widely promotion and implementation of Microservices Architecture, the Microservices Architecture represented by Spring Boot and Spring Cloud, in Java ecosystem, introduced some brand new programming model, like:</p>\n<ul>\n<li>Annotation-Driven</li>\n<li>External Configuration</li>\n<li>Auto-Configure</li>\n</ul>\n<p>New programming model have some advantages, for example, it does not require <code>XML</code> configuration, it can simplify deployment process, beyond that，it can promote development efficiency. In order to implement the microservice architecture better，Dubbo has provided more perfect support for the above three scenarios since version 2.5.8. This article focuses on introduce annotations rather than discuss the traditional XML configuration approach. There are two kinds of automatic assembly, external configuration and automatic assembly, will be introduced in another aricle.</p>\n<h2>Introduce Annotations</h2>\n<h3>@EnableDubbo</h3>\n<p>The annotations of <code>@EnableDubbo</code> is a combination of both <code>@EnableDubboConfig</code> and <code>@DubboComponentScan</code>.Related to the annotation driver is  <code>@DubboComponentScan</code>.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> org.apache.dubbo.config.spring.context.annotation;\n\n<span class=\"hljs-meta\">@EnableDubboConfig</span>\n<span class=\"hljs-meta\">@DubboComponentScan</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@interface</span> EnableDubbo {\n    <span class=\"hljs-comment\">/**\n     * Base packages to scan for annotated <span class=\"hljs-doctag\">@Service</span> classes.\n     * &lt;p&gt;\n     * Use {<span class=\"hljs-doctag\">@link</span> #scanBasePackageClasses()} for a type-safe alternative to String-based\n     * package names.\n     *\n     * <span class=\"hljs-doctag\">@return</span> the base packages to scan\n     * <span class=\"hljs-doctag\">@see</span> DubboComponentScan#basePackages()\n     */</span>\n    <span class=\"hljs-meta\">@AliasFor</span>(annotation = DubboComponentScan.class, attribute = <span class=\"hljs-string\">\"basePackages\"</span>)\n    String[] scanBasePackages() <span class=\"hljs-keyword\">default</span> {};\n\n    <span class=\"hljs-comment\">/**\n     * Type-safe alternative to {<span class=\"hljs-doctag\">@link</span> #scanBasePackages()} for specifying the packages to\n     * scan for annotated <span class=\"hljs-doctag\">@Service</span> classes. The package of each class specified will be\n     * scanned.\n     *\n     * <span class=\"hljs-doctag\">@return</span> classes from the base packages to scan\n     * <span class=\"hljs-doctag\">@see</span> DubboComponentScan#basePackageClasses\n     */</span>\n    <span class=\"hljs-meta\">@AliasFor</span>(annotation = DubboComponentScan.class, attribute = <span class=\"hljs-string\">\"basePackageClasses\"</span>)\n    Class&lt;?&gt;[] scanBasePackageClasses() <span class=\"hljs-keyword\">default</span> {};    \n}\n</code></pre>\n<p>The <code>@bableDubbo</code> can be used to scan Dubbo's service provider (marked by <code>@Service</code>) and Dubbo's service consumer (marked by <code>Reference</code>) under the specified package name (via <code>scanBasePackages</code>) or in the specified class (via <code>scanBasePackageClasses</code>). After Dubbo's service providers and consumers have been scanned,  they have been assembled corresponding and been initialized, and finally the service is exposed or referenced, if you do not use <code>External Configuration</code>, you can use <code>@DubboComponentScan</code> directly.</p>\n<h3>@Service</h3>\n<p><code>@service</code> is used to configure Dubbo's Service provider,for example:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Service</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AnnotatedGreetingService</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">GreetingService</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello, \"</span> + name;\n    }\n}\n</code></pre>\n<p>Via <code>@Service</code>'s properties, you can customize Dubbo's Service provider:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> org.apache.dubbo.config.annotation;\n\n<span class=\"hljs-meta\">@Documented</span>\n<span class=\"hljs-meta\">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class=\"hljs-meta\">@Target</span>({ElementType.TYPE}) <span class=\"hljs-comment\">// #1</span>\n<span class=\"hljs-meta\">@Inherited</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@interface</span> Service {\n    Class&lt;?&gt; interfaceClass() <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span>.class; <span class=\"hljs-comment\">// #2</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">interfaceName</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #3</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">version</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #4</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">group</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #5</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">export</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">true</span></span>; <span class=\"hljs-comment\">// #6</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">register</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">true</span></span>; <span class=\"hljs-comment\">// #7</span>\n    \n    <span class=\"hljs-function\">String <span class=\"hljs-title\">application</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #8</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">module</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #9</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">provider</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #10</span>\n    String[] protocol() <span class=\"hljs-keyword\">default</span> {}; <span class=\"hljs-comment\">// #11</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">monitor</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #12</span>\n    String[] registry() <span class=\"hljs-keyword\">default</span> {}; <span class=\"hljs-comment\">// #13</span>\n}\n</code></pre>\n<p>Which is more important:</p>\n<ol>\n<li><strong>@Service</strong>:        Can only be defined on a class, represent a service</li>\n<li><strong>interfaceClass</strong>: specified <code>interface</code>'s class implemented by the service provider</li>\n<li><strong>interfaceName</strong>: specified <code>interface</code>'s class name implemented by the service provider</li>\n<li><strong>version</strong>: specified the version number of the service</li>\n<li><strong>group</strong>:specified the group of services</li>\n<li><strong>export</strong>:whether to expose service</li>\n<li><strong>registry</strong>:Whether to register service to the registry</li>\n<li><strong>application</strong>:application configuration</li>\n<li><strong>module</strong>:module configuration</li>\n<li><strong>provider</strong>:service provider configuration</li>\n<li><strong>protocol</strong>:protocol configuration</li>\n<li><strong>monitor</strong>:monitoring center configuration</li>\n<li><strong>registr</strong>:registry configuration</li>\n</ol>\n<p>In addition, it should be noted that, <code>application</code>, <code>module</code>, <code>provider</code>, <code>protocol</code>, <code>monitor</code>, <code>registry</code> (from 8 to 13) need to provide the name of the corresponding <code>spring bean</code>,These bean assembly completed either through traditional XML configuration,or by the modern Java Config. This article will show you how to use <code>Java Config</code>.</p>\n<h3>@Reference</h3>\n<p><code>@Reference</code> is used to configure Dubbo's Service consumer,for example:</p>\n<pre><code class=\"language-Java\"><span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GreetingServiceConsumer</span> </span>{\n    <span class=\"hljs-meta\">@Reference</span>\n    <span class=\"hljs-keyword\">private</span> GreetingService greetingService;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">doSayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> greetingService.sayHello(name);\n    }\n}\n</code></pre>\n<p>Via <code>@Reference</code>'s properties, you can customize Dubbo's Service consumer:</p>\n<pre><code class=\"language-Java\"><span class=\"hljs-keyword\">package</span> org.apache.dubbo.config.annotation;\n\n<span class=\"hljs-meta\">@Documented</span>\n<span class=\"hljs-meta\">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class=\"hljs-meta\">@Target</span>({ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE}) <span class=\"hljs-comment\">// #1</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@interface</span> Reference {\n    Class&lt;?&gt; interfaceClass() <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span>.class; <span class=\"hljs-comment\">// #2</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">interfaceName</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #3</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">version</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #4</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">group</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #5</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">url</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #6</span>\n    \n    <span class=\"hljs-function\">String <span class=\"hljs-title\">application</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #7</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">module</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #8</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">consumer</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #9</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">protocol</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #10</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">monitor</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> \"\"</span>; <span class=\"hljs-comment\">// #11</span>\n    String[] registry() <span class=\"hljs-keyword\">default</span> {}; <span class=\"hljs-comment\">// #12</span>\n}\n</code></pre>\n<p>Which is more important:</p>\n<ol>\n<li><strong>@Reference</strong>:you can define it on a field in a class, you can define it on a method, you can even modify another annotation, it represent a reference to a service.Normally <code>@Reference</code> is defined in one field</li>\n<li><strong>interfaceClass</strong> : specified <code>interface</code>'s class implemented by the service provider</li>\n<li><strong>interfaceName</strong>: specified <code>interface</code>'s class name implemented by the service provider</li>\n<li><strong>version</strong>: specified the version number of the service</li>\n<li><strong>group</strong>:pecified the group of services</li>\n<li><strong>url</strong>: invoking the registry directly by specifying the URL of the service provider</li>\n<li><strong>application</strong>:application configuration</li>\n<li><strong>module</strong>:module configuration</li>\n<li><strong>consumer</strong>:service consumer configuration</li>\n<li><strong>protocol</strong>:protocol configuration</li>\n<li><strong>monitor</strong>:monitoring center configuration</li>\n<li><strong>registr</strong>:registry configuration</li>\n</ol>\n<p>In addition, it should be noted that, <code>application</code>, <code>module</code>, <code>consumer</code>, <code>protocol</code>, <code>monitor</code>, <code>registry</code> (from 7 to 12) need to provide the name of the corresponding <code>spring bean</code>,These bean assembly completed either through traditional XML configuration,or by the modern Java Config. This article will show you how to use <code>Java Config</code>.</p>\n<h2>Example practice</h2>\n<p>After learn what <code>@EnableDubbo</code>, <code>@Service</code>, <code>@Reference</code> is, there is a practical example showing how to use the annotation to develop a Dubbo application.The following code can be found at <a href=\"https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-annotation\">https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-annotation</a></p>\n<h3>1.Interface Definition</h3>\n<p>Define a simple <code>GreetingService</code> interface with only a simple method <code>sayHello</code> to the caller.</p>\n<pre><code class=\"language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">GreetingService</span> </span>{\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span></span>;\n}\n</code></pre>\n<h3>2.Server:Service Implementation</h3>\n<p>Implement the <code>GreetingService</code> interface, and mark it as a service for Dubbo via @Service.</p>\n<pre><code class=\"language-Java\"><span class=\"hljs-meta\">@Service</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AnnotatedGreetingService</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">GreetingService</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello, \"</span> + name;\n    }\n}\n</code></pre>\n<h3>3.Server:Assembly Service Provider</h3>\n<p>You can discover, assemble, and provide Dubbo's services through the Java config technology (@Configuration) and annotation scan (@EnableDubbo) in Spring.</p>\n<pre><code class=\"language-Java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@EnableDubbo</span>(scanBasePackages = <span class=\"hljs-string\">\"com.alibaba.dubbo.samples.impl\"</span>)\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProviderConfiguration</span> </span>{\n    <span class=\"hljs-meta\">@Bean</span> <span class=\"hljs-comment\">// #1</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ProviderConfig <span class=\"hljs-title\">providerConfig</span><span class=\"hljs-params\">()</span> </span>{\n        ProviderConfig providerConfig = <span class=\"hljs-keyword\">new</span> ProviderConfig();\n        providerConfig.setTimeout(<span class=\"hljs-number\">1000</span>);\n        <span class=\"hljs-keyword\">return</span> providerConfig;\n    }\n\n    <span class=\"hljs-meta\">@Bean</span> <span class=\"hljs-comment\">// #2</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ApplicationConfig <span class=\"hljs-title\">applicationConfig</span><span class=\"hljs-params\">()</span> </span>{\n        ApplicationConfig applicationConfig = <span class=\"hljs-keyword\">new</span> ApplicationConfig();\n        applicationConfig.setName(<span class=\"hljs-string\">\"dubbo-annotation-provider\"</span>);\n        <span class=\"hljs-keyword\">return</span> applicationConfig;\n    }\n\n    <span class=\"hljs-meta\">@Bean</span> <span class=\"hljs-comment\">// #3</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> RegistryConfig <span class=\"hljs-title\">registryConfig</span><span class=\"hljs-params\">()</span> </span>{\n        RegistryConfig registryConfig = <span class=\"hljs-keyword\">new</span> RegistryConfig();\n        registryConfig.setProtocol(<span class=\"hljs-string\">\"zookeeper\"</span>);\n        registryConfig.setAddress(<span class=\"hljs-string\">\"localhost\"</span>);\n        registryConfig.setPort(<span class=\"hljs-number\">2181</span>);\n        <span class=\"hljs-keyword\">return</span> registryConfig;\n    }\n\n    <span class=\"hljs-meta\">@Bean</span> <span class=\"hljs-comment\">// #4</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ProtocolConfig <span class=\"hljs-title\">protocolConfig</span><span class=\"hljs-params\">()</span> </span>{\n        ProtocolConfig protocolConfig = <span class=\"hljs-keyword\">new</span> ProtocolConfig();\n        protocolConfig.setName(<span class=\"hljs-string\">\"dubbo\"</span>);\n        protocolConfig.setPort(<span class=\"hljs-number\">20880</span>);\n        <span class=\"hljs-keyword\">return</span> protocolConfig;\n    }\n}\n</code></pre>\n<p>Description：</p>\n<ul>\n<li>Scan all classes marked with <code>@Service</code> under <code>com.alibaba.dubbo.samples.impl</code> with <code>@EnableDubbo</code></li>\n<li>Via @Configuration, all @Beans in the ProviderConfiguration are assembled using the way of <code>Java Config</code> and then injected into the Dubbo service, which means the class marked with <code>@Service</code>.Which included:\ni. <strong>ProviderConfig</strong>:Service provider configuration\nii. <strong>ApplicationConfig</strong>:Application configuration\niii.<strong>RegistryConfig</strong>:registry configuration\niv. <strong>ProtocolConfig</strong>:Protocol configuration</li>\n</ul>\n<h3>4.Server:Start Service</h3>\n<p>In the <code>main</code> method to provide external <code>Dubbo</code> service by starting a <code>Spring Context</code>.</p>\n<pre><code class=\"language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProviderBootstrap</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        <span class=\"hljs-keyword\">new</span> EmbeddedZooKeeper(<span class=\"hljs-number\">2181</span>, <span class=\"hljs-keyword\">false</span>).start(); <span class=\"hljs-comment\">// #1</span>\n        AnnotationConfigApplicationContext context = <span class=\"hljs-keyword\">new</span> AnnotationConfigApplicationContext(ProviderConfiguration.class); <span class=\"hljs-comment\">// #2</span>\n        context.start(); <span class=\"hljs-comment\">// #3</span>\n        System.in.read(); <span class=\"hljs-comment\">// #4</span>\n    }\n}\n</code></pre>\n<p>Description：</p>\n<ol>\n<li>Start an embedded <code>zookeeper</code> and provide service registry on port <code>2181</code></li>\n<li>Initialize an example of an AnnotationConfigApplicationContext and pass the <code>ProviderConfiguration</code> into the example to complete the automatic discovery and assembly of the <code>Dubbo</code> service.</li>\n<li>Start the <code>Spring Context</code> and start providing external <code>Dubbo</code> services.</li>\n<li>Because it is a server, you need to prevent the process exit by blocking the main thread.</li>\n</ol>\n<p>Start the <code>main</code> method of the server, you will see the following output, on behalf of the server startup success, and registered the <code>GreetingService</code> service in the <code>ZookeeperRegistry</code>:</p>\n<pre><code class=\"language-sh\">[01/08/18 02:12:51:051 CST] main  INFO transport.AbstractServer:  [DUBBO] Start NettyServer <span class=\"hljs-built_in\">bind</span> /0.0.0.0:20880, <span class=\"hljs-built_in\">export</span> /192.168.99.1:20880, dubbo version: 2.6.2, current host: 192.168.99.1\n\n[01/08/18 02:12:51:051 CST] main  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Register: dubbo://192.168.99.1:20880/com.alibaba.dubbo.samples.api.GreetingService?anyhost=<span class=\"hljs-literal\">true</span>&amp;application=dubbo-annotation-provider&amp;default.timeout=1000&amp;dubbo=2.6.2&amp;generic=<span class=\"hljs-literal\">false</span>&amp;interface=com.alibaba.dubbo.samples.api\n</code></pre>\n<h3>5.Server:Reference Service</h3>\n<p>Marking the member variable of the <code>GreetingService</code> via <code>@Reference</code> .The <code>greetingService</code> is a reference to the <code>Dubbo</code> service, which means that it can simply provide through the interface to the remote party to initiate service calls, and the client does not implement <code>GreetingService</code> interface.</p>\n<pre><code class=\"language-Java\"><span class=\"hljs-meta\">@Component</span>(<span class=\"hljs-string\">\"annotatedConsumer\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GreetingServiceConsumer</span> </span>{\n    <span class=\"hljs-meta\">@Reference</span>\n    <span class=\"hljs-keyword\">private</span> GreetingService greetingService;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">doSayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> greetingService.sayHello(name);\n    }\n}\n</code></pre>\n<h3>6.Server:Assembly Service consumer</h3>\n<p>Just like  <strong>3. Server:Assembly Service Provider</strong> You can discover, assemble, and provide Dubbo's service consumer through the Java config technology (@Configuration) and annotation scan (@EnableDubbo) in Spring.</p>\n<pre><code class=\"language-Java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@EnableDubbo</span>(scanBasePackages = <span class=\"hljs-string\">\"com.alibaba.dubbo.samples.action\"</span>)\n<span class=\"hljs-meta\">@ComponentScan</span>(value = {<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.action\"</span>})\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConsumerConfiguration</span> </span>{\n    <span class=\"hljs-meta\">@Bean</span> <span class=\"hljs-comment\">// #1</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ApplicationConfig <span class=\"hljs-title\">applicationConfig</span><span class=\"hljs-params\">()</span> </span>{\n        ApplicationConfig applicationConfig = <span class=\"hljs-keyword\">new</span> ApplicationConfig();\n        applicationConfig.setName(<span class=\"hljs-string\">\"dubbo-annotation-consumer\"</span>);\n        <span class=\"hljs-keyword\">return</span> applicationConfig;\n    }\n\n    <span class=\"hljs-meta\">@Bean</span> <span class=\"hljs-comment\">// #2</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ConsumerConfig <span class=\"hljs-title\">consumerConfig</span><span class=\"hljs-params\">()</span> </span>{\n        ConsumerConfig consumerConfig = <span class=\"hljs-keyword\">new</span> ConsumerConfig();\n        consumerConfig.setTimeout(<span class=\"hljs-number\">3000</span>);\n        <span class=\"hljs-keyword\">return</span> consumerConfig;\n    }\n\n    <span class=\"hljs-meta\">@Bean</span> <span class=\"hljs-comment\">// #3</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> RegistryConfig <span class=\"hljs-title\">registryConfig</span><span class=\"hljs-params\">()</span> </span>{\n        RegistryConfig registryConfig = <span class=\"hljs-keyword\">new</span> RegistryConfig();\n        registryConfig.setProtocol(<span class=\"hljs-string\">\"zookeeper\"</span>);\n        registryConfig.setAddress(<span class=\"hljs-string\">\"localhost\"</span>);\n        registryConfig.setPort(<span class=\"hljs-number\">2181</span>);\n        <span class=\"hljs-keyword\">return</span> registryConfig;\n    }\n}\n</code></pre>\n<p>Description：</p>\n<ul>\n<li>Scan all classes marked with <code>@Service</code> under <code>com.alibaba.dubbo.samples.impl</code> with <code>@Reference</code></li>\n<li>Via @Configuration, all @Beans in the ProviderConfiguration are assembled using the way of <code>Java Config</code> and then injected into the Dubbo service, which means the class marked with <code>@Reference</code>.Which included:\ni. <code>ApplicationConfig</code>: Application configuration\nii. <code>ConsumerConfig</code>:Service consumer configuration\niii.<code>RegistryConfig</code>:Registry configuration.Note:The configuration here needs to be consistent with the configuration information of the EmbeddedZooKeeper when started by the service provider.</li>\n</ul>\n<h3>7.Server: Initiate Remote Calls</h3>\n<p>In the <code>main</code> method, you can start a <code>Spring Context</code> to find the service consumer of the assembled <code>Dubbo</code> from it, and initiate a remote call.</p>\n<pre><code class=\"language-Java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConsumerBootstrap</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        AnnotationConfigApplicationContext context = <span class=\"hljs-keyword\">new</span> AnnotationConfigApplicationContext(ConsumerConfiguration.class); <span class=\"hljs-comment\">// #1</span>\n        context.start(); <span class=\"hljs-comment\">// #2</span>\n        GreetingServiceConsumer greetingServiceConsumer = context.getBean(GreetingServiceConsumer.class); <span class=\"hljs-comment\">// #3</span>\n        String hello = greetingServiceConsumer.doSayHello(<span class=\"hljs-string\">\"annotation\"</span>); <span class=\"hljs-comment\">// #4</span>\n        System.out.println(<span class=\"hljs-string\">\"result: \"</span> + hello); <span class=\"hljs-comment\">// #5</span>\n    }\n}\n</code></pre>\n<p>Description：</p>\n<ul>\n<li>Initialize an example of an AnnotationConfigApplicationContext and pass the <code>ProviderConfiguration</code> into the example to complete the automatic discovery and assembly of the <code>Dubbo</code> service consumer.</li>\n<li>start <code>Spring Context</code>.</li>\n<li>Find <code>bean</code> which type is <code>GreetingServiceConsumer</code> from <code>Context</code>.</li>\n<li>Call the <code>doSayHello</code> method and finally initiate a remote call via Dubbo's service reference (marked by @Reference)</li>\n<li>Print call result\nStart the Server's <code>main</code> method, you will see the following output, which returns the <code>result</code>:  hello, annotation:</li>\n</ul>\n<pre><code class=\"language-sh\">[01/08/18 02:38:40:040 CST] main  INFO config.AbstractConfig:  [DUBBO] Refer dubbo service com.alibaba.dubbo.samples.api.GreetingService from url zookeeper://localhost:2181/com.alibaba.dubbo.registry.RegistryService?anyhost=<span class=\"hljs-literal\">true</span>&amp;application=dubbo-annotation-consumer&amp;check=<span class=\"hljs-literal\">false</span>&amp;default.timeout=3000&amp;dubbo=2.6.2&amp;generic=<span class=\"hljs-literal\">false</span>&amp;interface=com.alibaba.dubbo.samples.api.GreetingService&amp;methods=sayHello&amp;pid=33001&amp;register.ip=192.168.99.1&amp;remote.timestamp=1533105502086&amp;side=consumer&amp;timestamp=1533105519216, dubbo version: 2.6.2, current host: 192.168.99.1\n[01/08/18 02:38:40:040 CST] main  INFO annotation.ReferenceBeanBuilder: &lt;dubbo:reference object=<span class=\"hljs-string\">\"com.alibaba.dubbo.common.bytecode.proxy0@673be18f\"</span> singleton=<span class=\"hljs-string\">\"true\"</span> interface=<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.api.GreetingService\"</span> uniqueServiceName=<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.api.GreetingService\"</span> generic=<span class=\"hljs-string\">\"false\"</span> id=<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.api.GreetingService\"</span> /&gt; has been built.\nresult: hello, annotation\n</code></pre>\n<h2>Conclusion</h2>\n<p>By studying this article, the reader can master the basic concepts of <code>Dubbo</code>'s exclusive <code>annotations</code> , <code>@EnableDubbo</code>, <code>@Service</code>, <code>@Reference</code>, and master it's basic usage through a simple <code>Dubbo</code> application.</p>\n<p>In addition to traditional <code>XML</code> configuration, <code>Spring</code> offers more modern configurations such as annotation drivers, externalization, and auto-assembly.This article focuses on the development of <code>Dubbo</code> applications through annotations. You can be seen that annotation mode programming is more concise and simple than XML configuration. In future, we will introduce the use of externalization configuration and automatic assembly in <code>Dubbo</code>  further.</p>\n"
    },
    {
      "filename": "dubbo-meetup-beijing-may-12th-2018.md",
      "__html": "<h2>The first Dubbo meetup has been held in Beijing</h2>\n<p>The first Dubbo meetup has successfully been held in Beijing, over 400+ people were present. What a great event!</p>\n<p>Please enjoy the slides of the topics:</p>\n<ul>\n<li>Ian Luo: Dubbo's present and future (Chinese) <a href=\"https://github.com/dubbo/awesome-dubbo/raw/master/slides/meetup/201805%40Beijing/dubbo-present-and-future.pdf\">slides</a></li>\n<li>Jun Liu: Introduction to the 4th Aliware Performance Challenge (Chinese) <a href=\"https://github.com/dubbo/awesome-dubbo/raw/master/slides/meetup/201805%40Beijing/introduction-to-4th-aliware-performance-challenge.pdf\">slides</a></li>\n<li>Zhixuan Chen: Quickly building Microservice with Dubbo and Spring-boot (Chinese) <a href=\"https://github.com/dubbo/awesome-dubbo/raw/master/slides/meetup/201805%40Beijing/quickly-building-microservice-with-dubbo-and-springboot.pdf\">slides</a></li>\n<li>Xin Wang: Dubbo and Weidian's Practice on Microservice Architecture (Chinese) <a href=\"https://github.com/dubbo/awesome-dubbo/raw/master/slides/meetup/201805%40Beijing/dubbo-and-weidian's-practice-on-microservice-architecture.pdf\">slides</a></li>\n</ul>\n"
    },
    {
      "filename": "dubbo-meetup-shanghai-jun-23rd-2018.md",
      "__html": "<h2>Dubbo Shanghai meetup has been held successfully</h2>\n<p>The sencond Dubbo meetup has successfully been held in Shanghai, over 700 people submitted registration, and over 300 were present, more than 10,000 watched the live online. A great event again!</p>\n<p>Please enjoy the slides of the topics:</p>\n<ul>\n<li>Jerrick Zhu: Dubbo Status and Roadmap (Chinese) <a href=\"https://github.com/dubbo/awesome-dubbo/blob/master/slides/meetup/201806%40Shanghai/dubbo-status-and-roadmap.pdf\">slides</a></li>\n<li>Mercy Ma: Dubbo Cloud Native Practices and Thoughts (Chinese) <a href=\"https://github.com/dubbo/awesome-dubbo/blob/master/slides/meetup/201806%40Shanghai/dubbo-cloud-native-practices-and-thoughts.pdf\">slides</a></li>\n<li>Ping Guo: Nacos Open Source Initiative (Chinese) <a href=\"https://github.com/dubbo/awesome-dubbo/blob/master/slides/meetup/201806%40Shanghai/nacos-open-source-initiative.pdf\">slides</a></li>\n<li>Zhiwei Pan: Dubbo Practices on Internet Finance Industries (Chinese) <a href=\"https://github.com/dubbo/awesome-dubbo/blob/master/slides/meetup/201806%40Shanghai/dubbo-practices-on-internet-finance-industries.pdf\">slides</a></li>\n</ul>\n"
    },
    {
      "filename": "dubbo-zk.md",
      "__html": "<h1>Using Zookeeper in Dubbo</h1>\n<h2>Introduction of Zookeeper</h2>\n<h3>The basic concept</h3>\n<p>In the mordern distrbuted applications, there are multiple coordination problems between nodes and nodes, including: leader election, group service, locking, configuration management, naming and synchronization. Apache Zookeeper, as its name implied, is a distributed, open-source coordination service framwork to address these demand.</p>\n<p>In order to ensure the high performance, highly available and strictly ordered access, the performance aspects of ZooKeeper means it can be used in large, distributed systems and can also be deployed in cluster mode, which called 'ZooKeeper ensemble'. In ZooKeeper ensemble, all write requests from clients are forwarded to a single server, called the leader, through the ZAB(Zookeeper Atomic Broadcast Protocol) to make sure the message in each nodes are same. Clients can access any one of the clusters to read and write data without worrying about inconsistencies in the data.</p>\n<p><img src=\"../../img/blog/zk-emsemble.png\" alt=\"Diagram shows client-server architecture of ZooKeeper\">\n<em>Image Credit : ebook -Zookeeper-Distributed Process Coordination from O'Reilly</em></p>\n<p>The method to store the data in Zookeeper is similar as the standard UNIX file system, as a data model styled after the familiar directory tree structure of file systems. When we talking about ZooKeeper data nodes, we call it Znodes to clarify it.</p>\n<p><img src=\"../../img/blog/zk-tree.png\" alt=\"zk-tree\">\n<em>Image Credit : ebook -Zookeeper-Distributed Process Coordination from O'Reilly</em></p>\n<h3>Basic Implementation</h3>\n<p>You could donwload and install Zookeeper directly<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>.\nOr you could use Homebrew <sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup> <code>brew install zookeeper</code> to install Zookeeper in Mac OS.\nConsidering the versatility, we run the Zookeeper by using docker in this blog. If you have not installed the docker yet, please prepare the docker environment first. <sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup></p>\n<h4>1. Running the Zookeeper</h4>\n<p>Execute the command to run zookeeper in a docker container</p>\n<pre><code class=\"language-shell\">docker run --rm --name zookeeper -p 2181:2181 zookeeper\n</code></pre>\n<h4>2. Entering the zookeeper container</h4>\n<pre><code class=\"language-shell\">docker exec -it zookeeper bash\n</code></pre>\n<p>In the <code>bin</code> directory, there is a command to start zookeeper <code>zkServer</code> and the Management Console <code>zkCli</code></p>\n<pre><code class=\"language-shell\">bash-4.4# ls -l bin\ntotal 36\n-rwxr-xr-x    1 zookeepe zookeepe       232 Mar 27 04:32 README.txt\n-rwxr-xr-x    1 zookeepe zookeepe      1937 Mar 27 04:32 zkCleanup.sh\n-rwxr-xr-x    1 zookeepe zookeepe      1056 Mar 27 04:32 zkCli.cmd\n-rwxr-xr-x    1 zookeepe zookeepe      1534 Mar 27 04:32 zkCli.sh\n-rwxr-xr-x    1 zookeepe zookeepe      1759 Mar 27 04:32 zkEnv.cmd\n-rwxr-xr-x    1 zookeepe zookeepe      2696 Mar 27 04:32 zkEnv.sh\n-rwxr-xr-x    1 zookeepe zookeepe      1089 Mar 27 04:32 zkServer.cmd\n-rwxr-xr-x    1 zookeepe zookeepe      6773 Mar 27 04:32 zkServer.sh\n</code></pre>\n<h4>3. Entering the zookeeper management interface via zkCli</h4>\n<p>Since it was started through docker, the process of Zookeeper has been started and will provide the services to the public via port 2181.</p>\n<pre><code class=\"language-shell\">bash-4.4# ps\nPID   USER     TIME  COMMAND\n    1 zookeepe  0:02 /usr/lib/jvm/java-1.8-openjdk/jre/bin/java -Dzookeeper.log.dir=. -Dzookeeper.root\n   32 root      0:00 bash\n   42 root      0:00 ps\n</code></pre>\n<p>So, it allows you to access Zookeeper's console directly through <code>zkCli</code> for management.</p>\n<pre><code class=\"language-shell\">bash-4.4# bin/zkCli.sh -server 127.0.0.1:2181\nConnecting to 127.0.0.1:2181\n...\nWATCHER::\n\nWatchedEvent state:SyncConnected type:None path:null\n\n[zk: 127.0.0.1:2181(CONNECTED) 0] help\nZooKeeper -server host:port cmd args\n\tstat path [watch]\n\tset path data [version]\n\tls path [watch]\n\tdelquota [-n|-b] path\n\tls2 path [watch]\n\tsetAcl path acl\n\tsetquota -n|-b val path\n\thistory\n\tredo cmdno\n\tprintwatches on|off\n\tdelete path [version]\n\tsync path\n\tlistquota path\n\trmr path\n\tget path [watch]\n\tcreate [-s] [-e] path data acl\n\taddauth scheme auth\n\tquit\n\tgetAcl path\n\tclose\n\tconnect host:port\n</code></pre>\n<h4>4. Basic Examples on zkCli</h4>\n<p>Create <code>/hello-zone</code> node:</p>\n<pre><code class=\"language-shell\">[zk: 127.0.0.1:2181(CONNECTED) 19] create /hello-zone 'world'\nCreated /hello-zone\n</code></pre>\n<p>List the child nodes under <code>/</code> and confirm that <code>hello-zone</code> is created:</p>\n<pre><code class=\"language-shell\">[zk: 127.0.0.1:2181(CONNECTED) 20] ls /\n[zookeeper, hello-zone]\n</code></pre>\n<p>List the child nodes for <code>/hello-zone</code> and verify that it is empty:</p>\n<pre><code class=\"language-shell\">[zk: 127.0.0.1:2181(CONNECTED) 21] ls /hello-zone\n[]\n</code></pre>\n<p>Get the data stored on the <code>/hello-zone</code> node:</p>\n<pre><code class=\"language-shell\">[zk: 127.0.0.1:2181(CONNECTED) 22] get /hello-zone\nworld\n</code></pre>\n<h2>Using Zookeeper in Dubbo</h2>\n<p>Zookeeper is used for service registration discovery and configuration management in Dubbo, and the structure of data in Zookeeper is shown in the following figure:</p>\n<p><img src=\"../../img/blog/dubbo-in-zk.jpg\" alt=\"dubbo-in-zk\"></p>\n<p>First, all data related to Dubbo is organized under the root node of <code>/duboo</code>.</p>\n<p>The secondary directory is the service name like <code>com.foo.BarService</code>.</p>\n<p>The three-level directory has two child nodes, <code>providers</code> and <code>consumers</code>, representing the supplier and customers of the service.</p>\n<p>The URL information for each application instance associated with the service will be recorded by the Level 4 directory. The <code>providers</code> and <code>consumer</code> will stored the providers information and the consumers information of the services seperately.<br>\nFor example, the service provider of <code>com.foo.BarService</code>  will register its URL Information to <code>/dubbo/com.foo.BarService/providers</code>; Similarly, service consumers will register their information under the corresponding <code>consumer</code> node. At the same time, consumers will subscribe to the corresponding <code>providers</code> node to be able to detect the changes of the service provider address list.</p>\n<h3>Prepare the sample code</h3>\n<p>The code in this document can be found in <a href=\"https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-zookeeper\">https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-zookeeper</a>.</p>\n<h4>1. Interface definition</h4>\n<p>Define a simple <code>greetingservice</code> interface with only one simple method named <code>sayHello</code> to greet to the caller.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">GreetingService</span> </span>{\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span></span>;\n}\n</code></pre>\n<h4>2. Server: Implementation</h4>\n<p>Implement the <code>GreetingService</code>  interface and mark it as a service for Dubbo via <code>@Service</code>.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Service</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AnnotatedGreetingService</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">GreetingService</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello, \"</span> + name;\n    }\n}\n</code></pre>\n<h4>3. Server: Assembly</h4>\n<p>Define ProviderConfiguration to assemble Dubbo services.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@EnableDubbo</span>(scanBasePackages = <span class=\"hljs-string\">\"com.alibaba.dubbo.samples.impl\"</span>)\n<span class=\"hljs-meta\">@PropertySource</span>(<span class=\"hljs-string\">\"classpath:/spring/dubbo-provider.properties\"</span>)\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProviderConfiguration</span> </span>{}\n</code></pre>\n<p>Dubbo-provider.properties is an external configuration in a spring application, as follows:</p>\n<pre><code class=\"language-properties\">dubbo.application.name=demo-provider\ndubbo.registry.address=zookeeper://$DOCKER_HOST:2181\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20880\n</code></pre>\n<p>Since zookeeper runs in a docker container, please be noted that:</p>\n<ul>\n<li>We assumes that Dubbo applications is running on the host machine (outside the docker container) in this document, and  needs to replace the PATH of Zookeeper with the IP address of the Environment Variable <em>${DOCKER_HOST}</em>. Please find more detail in the official Docker documentation.</li>\n<li>When the Dubbo application is a docker application, the container's name is equivalent to Zookeeper's. The container's name is ** zookeeper ** in this document.</li>\n<li>Of course, if you don't want to run the Zookeeper in a container mode, just simply replace <em>$DOCKER_HOST</em> with <strong>localhost</strong>.</li>\n</ul>\n<h4>4. Server: Starting Service</h4>\n<p>In the <code>main</code> method, you could provide the Dubbo service by running a Spring Context.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProviderBootstrap</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        AnnotationConfigApplicationContext context = <span class=\"hljs-keyword\">new</span> AnnotationConfigApplicationContext(ProviderConfiguration.class);\n        context.start();\n        System.in.read();\n    }\n}\n</code></pre>\n<p>Start the <code>main</code> method of server,  you will get the following output, which represents the success of the server's startup, and  the <code>GreetingService</code> service is registered on the ZookeeperRegistry:</p>\n<pre><code class=\"language-sh\">[03/08/18 10:50:33:033 CST] main  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Register: dubbo://192.168.99.1:20880/com.alibaba.dubbo.samples.api.GreetingService?anyhost=<span class=\"hljs-literal\">true</span>&amp;application=demo-provider&amp;dubbo=2.6.2&amp;generic=<span class=\"hljs-literal\">false</span>&amp;interface=com.alibaba.dubbo.samples.api.GreetingService&amp;methods=sayHello&amp;pid=12938&amp;side=provider&amp;timestamp=1533264631849, dubbo version: 2.6.2, current host: 192.168.99.1\n</code></pre>\n<p>You could find the registration information of the service provider through the Zookeeper management terminal:</p>\n<pre><code class=\"language-sh\">$ docker <span class=\"hljs-built_in\">exec</span> -it zookeeper bash\nbash-4.4<span class=\"hljs-comment\"># bin/zkCli.sh -server localhost:218</span>\nConnecting to localhost:2181\n...\nWelcome to ZooKeeper!\nJLine support is enabled\n...\n[zk: localhost:2181(CONNECTED) 0] ls /dubbo/com.alibaba.dubbo.samples.api.GreetingService/providers\n[dubbo%3A%2F%2F192.168.99.1%3A20880%2Fcom.alibaba.dubbo.samples.api.GreetingService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26dubbo%3D2.6.2%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.samples.api.GreetingService%26methods%3DsayHello%26pid%3D12938%26side%3Dprovider%26timestamp%3D1533264631849]\n</code></pre>\n<p>You could find that the Dubbo services just registered its URL address at the <code>providers</code> node as follows:\n<em>dubbo://192.168.99.1:20880/com.alibaba.dubbo.samples.api.GreetingService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.6.2&amp;generic=false&amp;interface=com.alibaba.dubbo.samples.api.GreetingService&amp;methods=sayHello&amp;pid=12938&amp;side=provider&amp;timestamp=1533264631849</em></p>\n<h4>5. Client: Reference Service</h4>\n<p>You could declare the reference service by @Reference, while it will generate a full call. The target address of the service could be queried by the Zookeeper's <code>provider</code> node.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Component</span>(<span class=\"hljs-string\">\"annotatedConsumer\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GreetingServiceConsumer</span> </span>{\n    <span class=\"hljs-meta\">@Reference</span>\n    <span class=\"hljs-keyword\">private</span> GreetingService greetingService;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">doSayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> greetingService.sayHello(name);\n    }\n}\n</code></pre>\n<h4>6. Client: Assembling</h4>\n<p>Define the ConsumerConfiguration to assemble Dubbo service.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-meta\">@EnableDubbo</span>(scanBasePackages = <span class=\"hljs-string\">\"com.alibaba.dubbo.samples.action\"</span>)\n<span class=\"hljs-meta\">@PropertySource</span>(<span class=\"hljs-string\">\"classpath:/spring/dubbo-consumer.properties\"</span>)\n<span class=\"hljs-meta\">@ComponentScan</span>(value = {<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.action\"</span>})\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConsumerConfiguration</span> </span>{}\n</code></pre>\n<p>&quot;dubbo-consumer.properties&quot; is a method of external configuration in a Spring application, as follows:</p>\n<pre><code class=\"language-properties\">dubbo.application.name=demo-consumer\ndubbo.registry.address=zookeeper://$DOCKER_HOST:2181\ndubbo.consumer.timeout=3000\n</code></pre>\n<p>Same as <strong>3. Server: Assembling</strong>, You need to modify <em>$DOCKER_HOST</em> defined in <em>dubbo.registry.address</em> according to your own  environment. You could find more instructions in step 3.</p>\n<h4>7. Client: Initiating A Remote Call</h4>\n<p>Run <code>main</code> to initiate a remote call from a existed service provider. Dubbo first subscribes to the zookeeper service address and then selects one from the list of returned addresses to invoke the client:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConsumerBootstrap</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConsumerBootstrap</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        AnnotationConfigApplicationContext context = <span class=\"hljs-keyword\">new</span> AnnotationConfigApplicationContext(ConsumerConfiguration.class);\n        context.start();\n        GreetingServiceConsumer greetingServiceConsumer = context.getBean(GreetingServiceConsumer.class);\n        String hello = greetingServiceConsumer.doSayHello(<span class=\"hljs-string\">\"zookeeper\"</span>);\n        System.out.println(<span class=\"hljs-string\">\"result: \"</span> + hello);\n        System.in.read();\n    }\n}\n</code></pre>\n<p>The output are as follows:</p>\n<pre><code class=\"language-shell\">[03/08/18 01:42:31:031 CST] main  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Register: consumer://192.168.99.1/com.alibaba.dubbo.samples.api.GreetingService?application=demo-consumer&amp;category=consumers&amp;check=false&amp;default.timeout=3000&amp;dubbo=2.6.2&amp;interface=com.alibaba.dubbo.samples.api.GreetingService&amp;methods=sayHello&amp;pid=82406&amp;side=consumer&amp;timestamp=1533274951195, dubbo version: 2.6.2, current host: 192.168.99.1 #1\n[03/08/18 01:42:31:031 CST] main  INFO zookeeper.ZookeeperRegistry:  [DUBBO] Subscribe: consumer://192.168.99.1/com.alibaba.dubbo.samples.api.GreetingService?application=demo-consumer&amp;category=providers,configurators,routers&amp;default.timeout=3000&amp;dubbo=2.6.2&amp;interface=com.alibaba.dubbo.samples.api.GreetingService&amp;methods=sayHello&amp;pid=82406&amp;side=consumer&amp;timestamp=1533274951195, dubbo version: 2.6.2, current host: 192.168.99.1 #2\n...\nresult: hello, zookeeper\n</code></pre>\n<p>Description:</p>\n<ol>\n<li><strong>Register</strong>: consumer://192.168.99.1/...&amp;<strong>category=consumers</strong>&amp;： In Zookeeper, consumers could register their information and store it at the <code>consumers</code> node</li>\n<li><strong>Subscribe</strong>: consumer://192.168.99.1/...&amp;<strong>category=providers,configurators,routers</strong>&amp;：Consumers subscribe <code>providers</code>, <code>configurators</code>, <code>routers</code> from Zookeepers. The <code>configurations</code> is related to the Dubbo configuration, and <code>routers</code> is related to routing rules. The providers node subscription should be noted. When a new service provider to join, due to the relationship between the subscription, the new address list will be pushed to the subscriber. So service consumers also dynamically perceive changes in address lists.</li>\n</ol>\n<p>You could find the registration information of the service provider through the Zookeeper management terminal:</p>\n<pre><code class=\"language-sh\">$ docker <span class=\"hljs-built_in\">exec</span> -it zookeeper bash\nbash-4.4<span class=\"hljs-comment\"># bin/zkCli.sh -server localhost:218</span>\nConnecting to localhost:2181\n...\nWelcome to ZooKeeper!\nJLine support is enabled\n...\n[zk: localhost:2181(CONNECTED) 4] ls /dubbo/com.alibaba.dubbo.samples.api.GreetingService/consumers\n[consumer%3A%2F%2F192.168.99.1%2Fcom.alibaba.dubbo.samples.api.GreetingService%3Fapplication%3Ddemo-consumer%26category%3Dconsumers%26check%3Dfalse%26default.timeout%3D3000%26dubbo%3D2.6.2%26interface%3Dcom.alibaba.dubbo.samples.api.GreetingService%26methods%3DsayHello%26pid%3D82406%26side%3Dconsumer%26timestamp%3D1533274951195]\n</code></pre>\n<p>You could see that  consumers of Dubbo's servicehas registered its URL address at the <code>consumers</code> node:</p>\n<p><em>consumer://192.168.99.1/com.alibaba.dubbo.samples.api.GreetingService?application=demo-consumer&amp;category=providers,configurators,routers&amp;default.timeout=3000&amp;dubbo=2.6.2&amp;interface=com.alibaba.dubbo.samples.api.GreetingService&amp;methods=sayHello&amp;pid=82406&amp;side=consumer&amp;timestamp=1533274951195</em></p>\n<h2>Summary</h2>\n<p>This document focuses on how to use ZooKeeper as a registry in Dubbo. This document also mentioned that the Zookeeper could be a configuration center and a service management in Dubbo. Zookeeper is a single-node, standalone mode. However, developers always bulid a Zookeeper server cluster called * Zookeeper ensemble * in the real world.</p>\n<p>Through this document, readers can learn:</p>\n<ul>\n<li>Basic concepts and applications of ZooKeeper</li>\n<li>The function of Zookeeper in Dubbo application</li>\n<li>Learn about Zookeeper's interaction through practical sample codes</li>\n<li>The storage of service registration and consumption information of Dubbo with ZooKeeper</li>\n</ul>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://www.apache.org/dyn/closer.cgi/zookeeper/\">https://www.apache.org/dyn/closer.cgi/zookeeper/</a> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p><a href=\"https://brew.sh\">https://brew.sh</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p><a href=\"https://www.docker.com/community-edition\">https://www.docker.com/community-edition</a> <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n"
    },
    {
      "filename": "gsoc-2018.md",
      "__html": "<h2>The GSoC(Google Summer of Code) 2018 projects has been announced</h2>\n<p>The GSoC(Google Summer of Code) 2018 projects has been announced, Raghu Reddy's project &quot;Extending Serialization protocols support for Apache Dubbo&quot; has been <a href=\"https://summerofcode.withgoogle.com/projects/#4747840161579008\">accepted</a>! Congratulations!</p>\n"
    },
    {
      "filename": "introduction-to-dubbo-spi.md",
      "__html": "<h1>Instance for Dubbo Extension Mechanism</h1>\n<h2>1. Extension Mechanism of Dubbo</h2>\n<p>Dubbo is claimed as a high-performance RPC framework on its official website. Today, I want to talk about another great specialty of Dubbo --- its scalability.  As quote: Rome wasn’t built in a day. Any successful system always starts as a prototype. It is impossible to design a perfect system at the beginning. Instead, we should focus on true demand and keep improving the system. On the coding side, it requires us to pay attention on abstraction layers and high-level isolation. In that case, the system could keep a healthy structure and easy to maintain while new features or third-party extensions are added. Under some circumstances, a designer should pursue more of scalability than the system’s current performance.\nWhen talking about software design, people always mention scalability. A framework with good scalability requires the following:\n1.The framework should follow opening/closed principle: software entities should be open for extension, but closed for modification; This means a framework should allow the maintainer to add new functions with as few modifications as possible.\n2.The framework should allow the user to add new functions by adding code on his project without modifying the framework's original source code base.\nWith microkernel architecture and extension mechanism, Dubbo satisfies such requirements and achieves good scalability. In the following chapters, we will discuss Dubbo's extension mechanism in detail.</p>\n<h2>2.Extension Solutions</h2>\n<p>Creating Extensible applications usually considers:</p>\n<ul>\n<li>Factory method pattern</li>\n<li>IoC container</li>\n<li>OSGi (Open Services Gateway initiative)</li>\n</ul>\n<p>As a framework, Dubbo does not wish to rely on other IoC containers such as Spring, Guice. OSGi is too complicated to fit Dubbo. In the end, Dubbo SPI is inherited from standard JDK SPI and makes it more powerful.</p>\n<h2>3.Java SPI Mechanism</h2>\n<p>We will first discuss Java SPI mechanism, which is a basis for understanding Dubbo’s extension mechanism. If you are familiar with Java SPI, you can skip this part.</p>\n<p>Java SPI (Service Provider Interface) is a feature for discovering and loading implementations matching a given interface provided in JDK. We can create a text file with the same name as the interface under resource directory <code>META-INF/services</code>. The content of the file is the fully qualified class name of the SPI implementation, in which each component is separated by a line breaker. JDK uses <code>java.util.ServiceLoader</code> to load implementations of a service. Let us use a simple example to show how Java SPI works.</p>\n<ol>\n<li>Define an interface IRepository to store data.</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">IRepository</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">save</span><span class=\"hljs-params\">(String data)</span></span>;\n}\n</code></pre>\n<ol start=\"2\">\n<li>Create 2 implementations for IRepository: MysqlRepository and MongoRepository</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MysqlRepository</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IRepository</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">save</span><span class=\"hljs-params\">(String data)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"Save \"</span> + data + <span class=\"hljs-string\">\" to Mysql\"</span>);\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MongoRepository</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IRepository</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">save</span><span class=\"hljs-params\">(String data)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"Save \"</span> + data + <span class=\"hljs-string\">\" to Mongo\"</span>);\n    }\n}\n</code></pre>\n<ol start=\"3\">\n<li>Create a configuration file under <code>META-INF/services</code>.</li>\n</ol>\n<p>The file name is <code>META-INF/services/com.demo.IRepository</code>, the content of file is:</p>\n<pre><code class=\"language-text\">com.demo.MongoRepository\ncom.demo.MysqlRepository\n</code></pre>\n<ol start=\"4\">\n<li>Load IRepository using ServiceLoader</li>\n</ol>\n<pre><code class=\"language-java\">ServiceLoader&lt;IRepository&gt; serviceLoader = ServiceLoader.load(IRepository.class);\nIterator&lt;IRepository&gt; it = serviceLoader.iterator();\n<span class=\"hljs-keyword\">while</span> (it != <span class=\"hljs-keyword\">null</span> &amp;&amp; it.hasNext()){\n    IRepository demoService = it.next();\n    System.out.println(<span class=\"hljs-string\">\"class:\"</span> + demoService.getClass().getName());\n    demoService.save(<span class=\"hljs-string\">\"tom\"</span>);\n}\n</code></pre>\n<p>In the above example, we created an extension and two of its applications. We created the configuration file in ClassPath and loaded the extensions using ServiceLoader. The final output is:\nclass:testDubbo.MongoRepository\nSave tom to Mongo\nclass:testDubbo.MysqlRepository\nSave tom to Mysql</p>\n<h2>4. Dubbo SPI Mechanism</h2>\n<p>Java SPI is simple to use. It also supports basic extension point functions, however, it has some disadvantages:</p>\n<ul>\n<li>It will load and instantiate all implementations at once to find the requested implementation.</li>\n<li>The configuration file only includes the extension implementation but does not name them, which makes it hard to reference them in applications.</li>\n<li>If extensions depend on other extensions, Java SPI cannot automatically load the dependency SPI.</li>\n<li>It does not provide functions such as IOC or AOP in Spring.</li>\n<li>It is hard to assemble extensions with other frameworks. For example, if the extension depends on Spring bean, the original Java SPI will not support it.</li>\n</ul>\n<p>Therefore, Java SPI is good for some simple scenarios, but does not fit for Dubbo. Dubbo makes some extensions on the original SPI mechanism. We will discuss more about the Dubbo SPI mechanism in the following sections.</p>\n<h2>5. Basic Concepts for Dubbo Extension Point Mechanism</h2>\n<p>Before diving into Dubbo's extension mechanism，Let us first declare some basic concepts in Dubbo SPI. Those terms will appear multiple times in the following section.</p>\n<h3>5.1 Extension Point</h3>\n<p>an interface of java.</p>\n<h3>5.2 Extension</h3>\n<p>an implementation class of the Extension Point</p>\n<h3>5.3 Extension Instance</h3>\n<p>instance of an extension point implementation class</p>\n<h3>5.4 Extension Adaptive Instance</h3>\n<p>Maybe it is a little difficult to understand this concept when hearing about it the first time. It may help you understand it better by calling it an extension proxy class. The extension adaptive instance is actually an extension proxy, which implements the method of extension point interface. When calling the interface method of the extension point, it will decide which extension to use according to the actual parameters. For example, the extension point of an IRepository has one save method, and two implementations MysqlRepository and MongoRepository. When calling the method of the interface, the adaptive instance of IRepository will determine which IRepository implementation to call according to the parameters in the save method. If the parameter repository=mysql in the method, then we can call the save method of MysqlRepository. If repository=mongo, then we can call the save method of MongoRepository, which is similar to late binding in Object-oriented languages. However, why does Dubbo introduce the concept of extended adaptive instances?</p>\n<ul>\n<li>There are two configurations in Dubbo, one is a fixed system-level configuration and it will not be changed after Dubbo launches. Another is the run-time configuration that may be different for each RPC. For instance, the timeout is configured as 10 seconds in the xml file, which will not change after Dubbo launches. However, for a certain PRC call, we can set its timeout to 30 seconds so as to override the system-level configuration. For Dubbo, the parameters called in each RPC is unknown and only at run-time can you make the right decision according to revealed parameters.</li>\n<li>Our class is usually singleton-scaled, such as beans of Spring IoC Container. When instantiating beans, if it depends on some specific extension point, it will know which extension to use, otherwise, the bean will not know how to choose extensions. At this time, a proxy mode is needed, which implements the interface  of an extension point. The method can dynamically select the appropriate extension according to the run-time parameters, and this proxy is an adaptive instance. Adaptive extension instance is widely used in Dubbo, in Dubbo, each extension will have an adaptive class, and if we do not provide it, Dubbo will automatically generate one for us by using the bytecode encoder. Therefore, we basically don't recognize the existence of adaptive classes. We will explain how the adaptive class works in later chapters.</li>\n</ul>\n<h3>5.5 @SPI</h3>\n<p>@SPI annotation works on the interface of the extension point, which indicates that the interface is an extension point, and can be loaded by Dubbo ExtentionLoader. If there is no such ExtentionLoader, the call will throw an exception.</p>\n<h3>5.6 @Adaptive</h3>\n<p>@Adaptive annotation is used on the method that extends the interface, which indicates an adaptive method. When Dubbo generates an adaptive instance for an extension point, if the function has @Adaptive annotation, then Dubbo will generate the corresponding code for the method. The method determines which extension to use according to the parameters. When @Adaptive annotation is used on the class to implement a Decorator class, it is similar to the Decorator pattern, whose major function is to return a specified class. Currently in Dubbo, both AdaptiveCompiler and AdaptiveExtensionFactory have @Adaptive annotation.</p>\n<h3>5.7 ExtentionLoader</h3>\n<p>Similar to the Java SPI ServiceLoader, it is responsible for loading extensions and life-cycle maintenance.</p>\n<h3>5.8 Extension Alias</h3>\n<p>Different from Java, each extension in Dubbo has an alias, which is used to reference them in the application, such as</p>\n<pre><code class=\"language-bash\">random=com.alibaba.dubbo.rpc.cluster.loadbalance.RandomLoadBalance\nroundrobin=com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance\n</code></pre>\n<p>where random, roundrobin are alias of the corresponding extensions, and we can directly use them in the configuration file.</p>\n<h3>5.9 Paths</h3>\n<p>Similar to the way Java SPI loading the extension configuration from the <code>META-INF/services</code> directory, Dubbo will also load the extension configuration file from the following path:</p>\n<ul>\n<li><code>META-INF/dubbo/internal</code></li>\n<li><code>META-INF/dubbo</code></li>\n<li><code>META-INF/services</code></li>\n</ul>\n<h2>6. Interpretation for Dubbo's LoadBalance Extension Point</h2>\n<p>Now that we know some basic idea about Dubbo, let us check a practical extension point in Dubbo to get some intuition.</p>\n<p>We take the Dubbo’s LoadBalance extension point as an example. A service in Dubbo usually has multiple providers. When a consumer calls the service, he needs to choose one of the providers. This is an example of LoadBalance. Now, let us figure out how LoadBalance becomes an extension point in Dubbo.</p>\n<h3>6.1 LoadBalance Interfance</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@SPI</span>(RandomLoadBalance.NAME)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">LoadBalance</span> </span>{\n\n    <span class=\"hljs-meta\">@Adaptive</span>(<span class=\"hljs-string\">\"loadbalance\"</span>)\n    &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">select</span><span class=\"hljs-params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> RpcException</span>;\n}\n</code></pre>\n<p>LoadBalance interface has only one select method. Select method chose one invoker among multiple invokers. In the code above, the elements related to Dubbo SPI are:</p>\n<ul>\n<li>@SPI(<a href=\"http://RandomLoadBalance.NAME\">RandomLoadBalance.NAME</a>) @SPI is used for LoadBalance interface, which indicates that the LoadBalance interface is an extension point. Without the @SPI annotation, if we try to load the extension, it will throw an exception. @SPI annotation has one parameter, and this parameter represents the Alias of the default implementation of the extension point. If there has no explicitly specified extension, the default implementation will be used.\n<code>RandomLoadBalance.NAME</code> is a constant with value “random” and is a random load balancing implementation. The definition of random is in the configuration file <code>META-INF/dubbo/internal/com.alibaba.dubbo.rpc.cluster.LoadBalance</code>:</li>\n</ul>\n<pre><code class=\"language-bash\">random=com.alibaba.dubbo.rpc.cluster.loadbalance.RandomLoadBalance\nroundrobin=com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance\nleastactive=com.alibaba.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance\nconsistenthash=com.alibaba.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance\n</code></pre>\n<p>There are four extension implementations of LoadBalance defined in the configuration file. The implementation of load balancing will not be covered in this article. The only thing we need to know is that Dubbo provides four kinds of load balancing implementations. We can explicitly specify an implementation by using xml file, properties file or JVM parameter. If there has no explicitly specified implementation, Dubbo will use random as default.</p>\n<p><img src=\"https://raw.githubusercontent.com/vangoleo/wiki/master/dubbo/dubbo_loadbalance.png\" alt=\"dubbo-loadbalance | left\"></p>\n<ul>\n<li>@Adaptive(&quot;loadbalance&quot;)  Applying @Adaptive annotation on select method indicates that select method is an adaptive method. Dubbo will automatically generate the corresponding code for the method. When select method is called, it will decide which extension to apply based on the method parameters. @Adaptive parameter <code>loadbalance</code> indicates that the value of loadbalance in method is the extension implementation that will be actually called. However, we cannot find loadbalance parameter in select method, then how can we obtain the value of loadbalance? There is another URL-type parameter in select method, and Dubbo obtains the value of loadbalance from that URL. Here we need to use Dubbo’s URL bus pattern, in one word, URL contains all the parameters in RPC. There is a member variable <code>Map&lt;String, String&gt;parameters</code> in the URL class, which contains loadbalance as a parameter</li>\n</ul>\n<h3>6.2 Obtain LoadBalance extension</h3>\n<p>The code of LoadBalance in Dubbo is as follows:</p>\n<pre><code class=\"language-java\">LoadBalance lb = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(loadbalanceName);\n</code></pre>\n<p>Using ExtensionLoader.getExtensionLoader(LoadBalance.class) method to obtain an implementation of ExtensionLoader, then we call getExtension and pass an extension alias to obtain the corresponding extension implementation.</p>\n<h2>7. Customize a LoadBalance Extension</h2>\n<p>In this session, we will use a simple example to implement a LoadBalance and integrate it into Dubbo. I will show some important steps and codes, and the complete demo can be downloaded from the following address(<a href=\"https://github.com/vangoleo/dubbo-spi-demo\">https://github.com/vangoleo/dubbo-spi-demo</a>).</p>\n<h3>7.1 implement LoadBalance Interface</h3>\n<p>First, we build a LoadBalance instance. Since we just need the instance to demonstrate Dubbo extension mechanism, it will be very simple. We choose the first invoker and print a log sentence in the console.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.dubbo.spi.demo.consumer;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoLoadBalance</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">LoadBalance</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">select</span><span class=\"hljs-params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n        System.out.println(<span class=\"hljs-string\">\"DemoLoadBalance: Select the first invoker...\"</span>);\n        <span class=\"hljs-keyword\">return</span> invokers.get(<span class=\"hljs-number\">0</span>);\n    }\n}\n</code></pre>\n<h3>7.2 Add extension configuration file</h3>\n<p>Add file:<code>META-INF/dubbo/com.alibaba.dubbo.rpc.cluster.LoadBalance</code>. The content of file is:</p>\n<pre><code class=\"language-bash\">demo=com.dubbo.spi.demo.consumer.DemoLoadBalance\n</code></pre>\n<h3>7.3 Configure customized LoadBalance</h3>\n<p>Through the above 2 steps, we have already added a LoadBalance implementation named demo, and set up the configuration file. In the next step, we need to explicitly tell Dubbo to implement the demo while doing load balancing. If we use Dubbo through spring, we could set it up in the xml file.</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"helloService\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.dubbo.spi.demo.api.IHelloService\"</span> <span class=\"hljs-attr\">loadbalance</span>=<span class=\"hljs-string\">\"demo\"</span> /&gt;</span>\n</code></pre>\n<p>Configure &lt;loadbalance=&quot;demo&quot;&gt; in <a href=\"dubbo:reference\">dubbo:reference</a> at consumer part.</p>\n<h3>7.4 launch Dubbo</h3>\n<p>Launch Dubbo and call IHelloService, the console will output log: <code>DemoLoadBalance: Select the first invoker...</code>, which means Dubbo does use our customized LoadBalance.</p>\n<h2>Summary</h2>\n<p>So far, we learnt the basic concepts of Dubbo SPI beginning with Java SPI, and we used LoadBalance in Dubbo as an example to help us understand better. Finally, we practiced and created a customized LoadBalance and integrated it to Dubbo. We believe that combining concepts and practice, everyone can get a better idea of Dubbo’s scalability. To summarize, Dubbo SPI has the following features:</p>\n<ul>\n<li>Build extensions on Dubbo does not require modifications on the original source code base.</li>\n<li>The customized Dubbo extension point implementation is a normal Java class. Dubbo does not introduce any specialized elements, and have almost zero code intrusion.\n*Extension registration on Dubbo requires only configuration file under the ClassPath directory. It is simple to use and has no effect on the existing code. This meets opening/closed principle.</li>\n<li>Dubbo's extension mechanism default: @SPI(&quot;dubbo&quot;) represents the default SPI object.</li>\n<li>Dubbo's extension mechanism supports the advanced features such as IoC and AoP, etc.</li>\n<li>Dubbo's extension mechanism supports third-party IoC containers. It supports Spring beans by default and can be extended to other containers, such as Google/Guice.</li>\n<li>It is easy to switch the implementation of the extension point because it requires only modifications on the specific implementation in the configuration file without changing the code.</li>\n</ul>\n<p>In the next article, we will go deep and check Dubbo's source code to learn more about Dubbo's extensibility mechanism.</p>\n"
    },
    {
      "filename": "pinpoint.md",
      "__html": "<h1>Tracking with Pinpoint</h1>\n<p>After using Dubbo to serve or integrate applications, assuming that a service backstage log shows an exception and that the service is invoked by multiple applications, it is often difficult to determine which application is called, and what is the cause of the problem, so we need a set of distributed tracking systems to quickly locate the problem. Pinpoint can help us quickly locate problems (of course, there are more than one solution).</p>\n<h2>What is Pinpoint</h2>\n<p><a href=\"https://github.com/naver/pinpoint\">Pinpoint</a> is an APM (Application Performance Management) tool for large-scale distributed systems written in Java. Inspired by Dapper, Pinpoint provides a solution to help analyze the overall structure of the system and how components within them are interconnected by tracing transactions across distributed applications.</p>\n<p>You should definitely check Pinpoint out If you want to</p>\n<p>understand your application topology at a glance\nmonitor your application in Real-Time\ngain code-level visibility to every transaction\ninstall APM Agents without changing a single line of code\nhave minimal impact on the performance (approximately 3% increase in resource usage)</p>\n<h3>ServerMap</h3>\n<p>Understand the topology of any distributed systems by visualizing how their components are interconnected. Clicking on a node reveals details about the component, such as its current status, and transaction count.</p>\n<h3>Realtime Active Thread Chart</h3>\n<p>Monitor active threads inside applications in real-time.</p>\n<h3>Request/Response Scatter Chart</h3>\n<p>Visualize request count and response patterns over time to identify potential problems. Transactions can be selected for additional detail by dragging over the chart.</p>\n<h3>CallStack</h3>\n<p>Gain code-level visibility to every transaction in a distributed environment, identifying bottlenecks and points of failure in a single view.</p>\n<h3>Inspector</h3>\n<p>View additional details on the application such as CPU usage, Memory/Garbage Collection, TPS, and JVM arguments.</p>\n<h3>Supported Modules (last updated 2018/04/01)</h3>\n<ul>\n<li>JDK 6+</li>\n<li>Tomcat 6/7/8, Jetty 8/9, JBoss EAP 6, Resin 4, Websphere 6/7/8, Vertx 3.3/3.4/3.5</li>\n<li>Spring, Spring Boot (Embedded Tomcat, Jetty)</li>\n<li>Apache HTTP Client 3.x/4.x, JDK HttpConnector, GoogleHttpClient, OkHttpClient, NingAsyncHttpClient</li>\n<li>Thrift Client, Thrift Service, DUBBO PROVIDER, DUBBO CONSUMER</li>\n<li>ActiveMQ, RabbitMQ</li>\n<li>MySQL, Oracle, MSSQL, CUBRID,POSTGRESQL, MARIA</li>\n<li>Arcus, Memcached, Redis, CASSANDRA</li>\n<li>iBATIS, MyBatis</li>\n<li>DBCP, DBCP2, HIKARICP</li>\n<li>gson, Jackson, Json Lib</li>\n<li>log4j, Logback</li>\n</ul>\n<h2>Pinpoint and Dubbo</h2>\n<h3>Quickstart Pinpoint</h3>\n<p><a href=\"http://naver.github.io/pinpoint/quickstart.html\">Quick start</a>（No neet to start TestApp）</p>\n<h3>Dubbo demo</h3>\n<h4>Create API module</h4>\n<p>pom.xml</p>\n<pre><code class=\"language-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.example<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>demo-api<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></pre>\n<p>Create API interface：</p>\n<pre><code>package com.example.demoapi;\n\npublic interface HelloService {\n    String sayHello(String name);\n}\n</code></pre>\n<h4>Dubbo provider</h4>\n<p>pom.xml</p>\n<pre><code class=\"language-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n\t<span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.example<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>demo-provider<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">packaging</span>&gt;</span>jar<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">packaging</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">name</span>&gt;</span>demo-provider<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">name</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.0.3.RELEASE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">relativePath</span>/&gt;</span> <span class=\"hljs-comment\">&lt;!-- lookup parent from repository --&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.reporting.outputEncoding</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">java.version</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">java.version</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">repositories</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">repository</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>sonatype-nexus-snapshots<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">url</span>&gt;</span>https://oss.sonatype.org/content/repositories/snapshots<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">url</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">releases</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">enabled</span>&gt;</span>false<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">enabled</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">releases</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">snapshots</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">enabled</span>&gt;</span>true<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">enabled</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">snapshots</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">repository</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">repositories</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.2.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.example<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>demo-api<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></pre>\n<ol>\n<li><code>HelloService</code> interface：</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.example.demoprovider.provider;\n\n<span class=\"hljs-keyword\">import</span> com.alibaba.dubbo.config.annotation.Service;\n<span class=\"hljs-keyword\">import</span> com.example.demoapi.HelloService;\n\n<span class=\"hljs-meta\">@Service</span>(version = <span class=\"hljs-string\">\"${demo.service.version}\"</span>,\n        application = <span class=\"hljs-string\">\"${dubbo.application.id}\"</span>,\n        protocol = <span class=\"hljs-string\">\"${dubbo.protocol.id}\"</span>,\n        registry = <span class=\"hljs-string\">\"${dubbo.registry.id}\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">HelloService</span> </span>{\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        i++;\n        <span class=\"hljs-keyword\">if</span> (i % <span class=\"hljs-number\">3</span> == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(<span class=\"hljs-string\">\"ex\"</span>);\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Hello \"</span> + name + <span class=\"hljs-string\">\"!\"</span>;\n    }\n}\n</code></pre>\n<ol start=\"2\">\n<li>Spring Boot bootstrap：</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.example.demoprovider;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoProviderApplication</span> </span>{\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n\t\tSpringApplication.run(DemoProviderApplication.class, args);\n\t}\n}\n</code></pre>\n<ol start=\"3\">\n<li><code>application.properties</code>：</li>\n</ol>\n<pre><code class=\"language-properties\"># Spring boot application\nspring.application.name = dubbo-provider-demo\nserver.port = 9090\nmanagement.port = 9091\n\n# Service version\ndemo.service.version = 1.0.0\n\n# Base packages to scan Dubbo Components (e.g @Service , @Reference)\ndubbo.scan.basePackages  = com.example.demoprovider\n\n# Dubbo Config properties\n## ApplicationConfig Bean\ndubbo.application.id = dubbo-provider-demo\ndubbo.application.name = dubbo-provider-demo\n\n## ProtocolConfig Bean\ndubbo.protocol.id = dubbo\ndubbo.protocol.name = dubbo\ndubbo.protocol.port = 12345\n\n## RegistryConfig Bean\ndubbo.registry.id = my-registry\ndubbo.registry.address = N/A\n</code></pre>\n<h4>Dubbo consumer</h4>\n<p>pom.xml</p>\n<pre><code class=\"language-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n\t<span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.example<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>demo-consumer<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">packaging</span>&gt;</span>jar<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">packaging</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">name</span>&gt;</span>demo-consumer<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">name</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.0.3.RELEASE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">relativePath</span>/&gt;</span> <span class=\"hljs-comment\">&lt;!-- lookup parent from repository --&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.build.sourceEncoding</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project.reporting.outputEncoding</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">java.version</span>&gt;</span>1.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">java.version</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">repositories</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">repository</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>sonatype-nexus-snapshots<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">url</span>&gt;</span>https://oss.sonatype.org/content/repositories/snapshots<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">url</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">releases</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">enabled</span>&gt;</span>false<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">enabled</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">releases</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">snapshots</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">enabled</span>&gt;</span>true<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">enabled</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">snapshots</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">repository</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">repositories</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.2.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.example<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>demo-api<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;</span>\n\t\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">classifier</span>&gt;</span>exec<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">classifier</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">configuration</span>&gt;</span>\n\t\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></pre>\n<ol>\n<li><code>@Reference</code> injection <code>HelloService</code></li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.example.democonsumer.controller;\n\n<span class=\"hljs-keyword\">import</span> com.alibaba.dubbo.config.annotation.Reference;\n<span class=\"hljs-keyword\">import</span> com.example.demoapi.HelloService;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestParam;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoConsumerController</span> </span>{\n    <span class=\"hljs-meta\">@Reference</span>(version = <span class=\"hljs-string\">\"${demo.service.version}\"</span>,\n            application = <span class=\"hljs-string\">\"${dubbo.application.id}\"</span>,\n            url = <span class=\"hljs-string\">\"dubbo://&lt;Real IP Address&gt;:12345\"</span>)\n    <span class=\"hljs-keyword\">private</span> HelloService helloService;\n\n    <span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"/sayHello\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(@RequestParam String name)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> helloService.sayHello(name);\n    }\n}\n</code></pre>\n<ol start=\"2\">\n<li>Spring Boot bootstrap:</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.example.democonsumer;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoConsumerApplication</span> </span>{\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n\t\tSpringApplication.run(DemoConsumerApplication.class, args);\n\t}\n}\n</code></pre>\n<ol start=\"3\">\n<li><code>application.properties</code>:</li>\n</ol>\n<pre><code class=\"language-properties\"># Spring boot application\nspring.application.name=dubbo-consumer-demo\nserver.port=8080\nmanagement.port=8081\n\n# Service Version\ndemo.service.version=1.0.0\n\n# Dubbo Config properties\n## ApplicationConfig Bean\ndubbo.application.id=dubbo-consumer-demo\ndubbo.application.name=dubbo-consumer-demo\n\n## ProtocolConfig Bean\ndubbo.protocol.id=dubbo\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=12345\n</code></pre>\n<h3>Using Pinpoint-agent to start <code>Dubbo provider</code> and <code>Dubbo consumer</code></h3>\n<ol>\n<li>Maven clean package</li>\n</ol>\n<pre><code>mvn clean package\n</code></pre>\n<ol start=\"2\">\n<li>Start provider</li>\n</ol>\n<pre><code>java -jar -javaagent:$AGENT_PATH/pinpoint-bootstrap-$VERSION.jar -Dpinpoint.agentId=demo-provider -Dpinpoint.applicationName=DP target/demo-provider-0.0.1-SNAPSHOT.jar\n</code></pre>\n<ol start=\"3\">\n<li>Start consumer</li>\n</ol>\n<pre><code>java -jar -javaagent:$AGENT_PATH/pinpoint-bootstrap-$VERSION.jar -Dpinpoint.agentId=demo-consumer -Dpinpoint.applicationName=DC target/demo-comsumer-0.0.1-SNAPSHOT-exec.jar\n</code></pre>\n<ol start=\"4\">\n<li>Access the consumer address to simulate user requests</li>\n</ol>\n<p><code>http://localhost:8080/sayHello?name=ABC</code></p>\n<h2>Using Pinpoint locate problems</h2>\n<h3>Homepage</h3>\n<p><img src=\"../../img/blog/en_pinpoint-home.png\" alt=\"/admin-guide/images/pinpoint-home.png\"></p>\n<blockquote>\n<p>The user request here is double the number of requests for DubboProvider, because the favicon.ico icon request is recorded.</p>\n</blockquote>\n<h3>Call tree</h3>\n<p><img src=\"../../img/blog/en_pinpoint-calltree.png\" alt=\"/admin-guide/images/pinpoint-calltree.png\"></p>\n<h3>Mixed view</h3>\n<p><img src=\"../../img/blog/en_pinpoint-mixedview.png\" alt=\"/admin-guide/images/pinpoint-mixedview.png\"></p>\n<h3>Other</h3>\n<p>The example simply simulates the provision and call of Dubbo, and does not carry out the application of other middleware such as database. For detailed use, please refer to the Pinpoint document.</p>\n"
    },
    {
      "filename": "qcon-beijing-2018.md",
      "__html": "<h2>Dubbo roadmap is announced in QCon Beijing 2018</h2>\n<p>Ian Luo has delivered a great talk at QCon Beijing 2018, where the roadmap of Dubbo has also be announced. Please enjoy the <a href=\"https://github.com/dubbo/awesome-dubbo/raw/master/slides/qcon2018/dubbo-present-and-future.pdf\">slides</a>!</p>\n"
    },
    {
      "filename": "sentinel-introduction-for-dubbo.md",
      "__html": "<h1>Sentinel: The flow sentinel of Dubbo services</h1>\n<p>In large clusters there may be thousands of Dubbo service instances in production, with continuous traffic coming in. However, in distributed systems, some services may be unavailable due to various of failure such as traffic surge, high system load, and network latency. If no control actions are performed, this may cause cascading failure, affecting the availability of the service. So we need a powerful library - Sentinel, which can guarantee the stability of the service, to protect the Dubbo service.</p>\n<h2>Introduction to Sentinel</h2>\n<p><a href=\"https://github.com/alibaba/Sentinel\">Sentinel</a> is a powerful library opensourced by Alibaba Middleware Team. Sentinel takes &quot;<strong>flow</strong>&quot; as the breakthrough point, and covers multiple fields including flow control, concurrency, circuit breaking and load protection to protect service stability.</p>\n<p>There are mainly three features in Sentinel:</p>\n<ul>\n<li><strong>Flow Control</strong>: Sentinel can control the traffic flow of resource calls based on different runtime metrics (such as QPS, number of threads, system load, etc.), for different invocation paths, and adjust random traffic to appropriate shapes (e.g. uniform speed).</li>\n<li><strong>Circuit Breaking</strong>: When a resource in the invocation chain is unstable (average RT increase or exception ratio increase), Sentinel will fast-fail the call request for this resource to avoid affecting other resources, causing cascade failure.</li>\n<li><strong>System Load Protection</strong>: Sentinel can be used to protect your server in case the system load goes too high. It helps you to achieve a good balance between system load and incoming requests.</li>\n</ul>\n<p>The commonly used circuit breaker/isolation library in production is <a href=\"https://github.com/Netflix/Hystrix\">Netflix Hystrix</a>. Hystrix focuses on the concept of isolation, which isolates dependencies (that is resource in Sentinel) through thread pools or semaphores. The benefit of Hystrix thread pool isolation is that the isolation is thorough, but the downside is that you have to create a lot of thread pools, pre-divide dependencies, and allocate thread pools to each dependency. Sentinel provides another idea for resource isolation: it is controlled by <strong>the number of concurrent threads</strong>. In this way, developer does not need to specify the size of the thread pool in advance, and there is less loss of thread context switching. When the resource is in an unstable state, the response time becomes longer and the number of threads gradually increases. When the number of threads of a resource is raised to a threshold, traffic flow limit is triggered until the stacked thread completes the task and then continues to accept the requests.</p>\n<p>Hystrix uses Circuit Breaker Pattern to automatically fast-fail the service when exception ratio exceeds the threshold. Sentinel's circuit breaking feature is more versatile, which supports two metrics: average response time and failure ratio. Sentinel also provides various invocation chain path and flow control effects support, as well as the ability to adjust the traffic in real time according to the system load to protect the system. At the same time, Sentinel also provides a real-time monitoring API and dashboard, which allows developers to quickly understand the current state of the system and understand the stability of the service. The scenarios are more abundant.</p>\n<h2>Best Practice for using Dubbo with Sentinel</h2>\n<p><a href=\"https://github.com/dubbo/dubbo-sentinel-support\">Sentinel Dubbo Adapter</a> provides service consumer filter and provider filter for Dubbo services. We can add the following dependency in <code>pom.xml</code> (if you are using Maven):</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>sentinel-dubbo-adapter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>x.y.z<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<p>The two filters are enabled by default. Once you add the dependency, the Dubbo services and methods will become protected resources in Sentinel, which can leverage Sentinel's flow control and guard ability when rules are configured. If you don't want to enable the filter, you can manually disable it. For example:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Bean</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ConsumerConfig <span class=\"hljs-title\">consumerConfig</span><span class=\"hljs-params\">()</span> </span>{\n    ConsumerConfig consumerConfig = <span class=\"hljs-keyword\">new</span> ConsumerConfig();\n    consumerConfig.setFilter(<span class=\"hljs-string\">\"-sentinel.dubbo.consumer.filter\"</span>);\n    <span class=\"hljs-keyword\">return</span> consumerConfig;\n}\n</code></pre>\n<p>We've provided sereval demos, you can check here: <a href=\"https://github.com/alibaba/Sentinel/tree/master/sentinel-demo/sentinel-demo-dubbo\">sentinel-demo-dubbo</a>。</p>\n<h3>Service Provider</h3>\n<p>Dubbo service providers provide services for outside world and handle requests from consumers. To protect the service provider from suffering the proliferation of traffic flow, you can set flow rules in <strong>QPS mode</strong> to the service provider. Thus, when the number of requests per second exceeds the threshold, new requests are automatically rejected.</p>\n<p>The flow control for Dubbo services has two granularities: service interface and service method.</p>\n<ul>\n<li>Service interface：resourceName format is <code>interfaceName</code>，e.g. <code>com.alibaba.csp.sentinel.demo.dubbo.FooService</code></li>\n<li>Service method：resourceName format is <code>interfaceName:methodSignature</code>，e.g. <code>com.alibaba.csp.sentinel.demo.dubbo.FooService:sayHello(java.lang.String)</code></li>\n</ul>\n<p>For the detail of flow rule configuration and flow control, please refer to <a href=\"https://github.com/alibaba/Sentinel/wiki/Flow-Control\">Flow Control | Sentinel</a>.</p>\n<p>Let's take a look at the effect of the QPS flow control. Assume that we have a service interface <code>com.alibaba.csp.sentinel.demo.dubbo.FooService</code>, which contains a method <code>sayHello(java.lang.String)</code>. We set flow rule for service provider (QPS count = 10). Then we do RPC 15 times at service consumer continuously in 1s. We can see the blocked metrics in the log. The log of blocked calls is located in <code>~/logs/csp/sentinel-block.log</code>：</p>\n<pre><code>2018-07-24 17:13:43|1|com.alibaba.csp.sentinel.demo.dubbo.FooService:sayHello(java.lang.String),FlowException,default,|5,0\n</code></pre>\n<p>Log messages will also appear in provider's metric log：</p>\n<pre><code>1532423623000|2018-07-24 17:13:43|com.alibaba.csp.sentinel.demo.dubbo.FooService|15|0|15|0|3\n1532423623000|2018-07-24 17:13:43|com.alibaba.csp.sentinel.demo.dubbo.FooService:sayHello(java.lang.String)|10|5|10|0|0\n</code></pre>\n<p>In many circumstances, it's also significant to control traffic flow based on the <strong>caller</strong>. For example, assuming that there are two services A and B, both of them initiate remote call requests to the service provider. If we want to limit the calls from service B only, we can set the <code>limitApp</code> of flow rule as the identifier of service B (e.g. service name). The Sentinel Dubbo Adapter will automatically resolve the Dubbo consumer's <em>application name</em> as the caller's name (<code>origin</code>), and will bring the caller's name when doing resource protection. If <code>limitApp</code> of flow rules is not configured (<code>default</code>), flow control will take effects on all callers. If <code>limitApp</code> of a flow rule is configured with a caller, then the corresponding flow rule will only take effect on the specific caller.</p>\n<blockquote>\n<p>Note: Dubbo consumer does not provide its Dubbo application name when doing RPC, so developers should manually put the application name into <em>attachment</em> at consumer side, then extract it at provider side. Sentinel Dubbo Adapter has implemented a filter where consumer can carry application name information to provider automatically. If the counsmer does not use Sentinel Dubbo Adapter but requires flow control based on caller, developers can manually put the application name into attachment with the key <code>dubboApplication</code>.</p>\n</blockquote>\n<p>The <code>sentinel-block.log</code> will also record caller name. For example:</p>\n<pre><code>2018-07-25 16:26:48|1|com.alibaba.csp.sentinel.demo.dubbo.FooService:sayHello(java.lang.String),FlowException,default,demo-consumer|5,0\n</code></pre>\n<p>The <code>demo-consumer</code> in the log is the caller name (origin).</p>\n<h3>Service Consumer</h3>\n<p>Dubbo service consumers act as a client to invoke the remote service. Each service may depend on several downstream services. If a service A depends on the downstream service B, and service B is unstable (i.e. the response time becomes longer), the number of threads where service A invokes service B will accumulate, thus may eventually run out of service A's thread pool. We use the thread count to control access to downstream service B. This can ensure service itself not affected by others when downstream services are not stable and reliable. Based on this scenario, it is recommended to set flow rules with <strong>thread count mode</strong> to consumers so that it's not affected by unstable services.</p>\n<p>The thread-count-based flow control mode does not require us to explicitly perform thread pool isolation. Sentinel will control the number of threads of the resource, and the excess requests will be rejected directly until the stacked tasks are completed.</p>\n<h3>Sentinel Dashboard</h3>\n<p>For ease of use, Sentinel provides a Dashboard for configuring rules, viewing monitoring metrics, machine discovery, and more. We only need to start the dashborad according to the <a href=\"https://github.com/alibaba/Sentinel/wiki/Dashboard\">Sentinel dashboard documentation</a>, then add the appropriate parameters to the corresponding application and launch it. For example, the startup parameters of the service provider demo in this article is:</p>\n<pre><code class=\"language-bash\">-Djava.net.preferIPv4Stack=<span class=\"hljs-literal\">true</span> -Dcsp.sentinel.api.port=8720 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=dubbo-provider-demo\n</code></pre>\n<p>After launching the service provider demo, we can find our application in the Sentinel dashboard. It's convenient to configure the rules in the dashboard：</p>\n<p><img src=\"../../img/blog/sentinel-dashboard-view-rules.png\" alt=\"Rule List\"></p>\n<p>Or view real-time metrics：</p>\n<p><img src=\"../../img/blog/sentinel-dashboard-metrics.png\" alt=\"Real-time metrics monitoring\"></p>\n<h2>Summary</h2>\n<p>This blog post only introduces the simplest scenario in Sentinel - Traffic Flow Control. Sentinel can handle more complex scenarios like circuit breaking, cold starting and uniform traffic flow. For more scenarios, you can dig into <a href=\"https://github.com/alibaba/Sentinel/wiki\">Sentinel Wiki</a>.</p>\n"
    }
  ]
}