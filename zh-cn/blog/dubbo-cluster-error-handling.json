{
  "filename": "dubbo-cluster-error-handling.md",
  "__html": "<h3>Design For failure</h3>\n<p>在分布式系统中，集群某个某些节点出现问题是大概率事件，因此在设计分布式RPC框架的过程中，必须要把失败作为设计的一等公民来对待。一次调用失败之后，应该如何选择对失败的选择策略，这是一个见仁见智的问题，每种策略可能都有自己独特的应用场景。因此，作为框架来说，应当针对不同场景提供多种策略，供用户进行选择。</p>\n<p>在Dubbo设计中，通过Cluster这个接口的抽象，把一组可供调用的Provider信息组合成为一个统一的<code>Invoker</code>供调用方进行调用。经过路由规则过滤，负载均衡选址后，选中一个具体地址进行调用，如果调用失败，则会按照集群配置的容错策略进行容错处理。</p>\n<p>Dubbo默认内置了若干容错策略，如果不能满足用户需求，则可以通过自定义容错策略进行配置。</p>\n<h3>内置容错策略</h3>\n<p>Dubbo主要内置了如下几种策略：</p>\n<ul>\n<li>Failover(失败自动切换)</li>\n<li>Failsafe(失败安全)</li>\n<li>Failfast(快速失败)</li>\n<li>Failback(失败自动恢复)</li>\n<li>Forking(并行调用)</li>\n<li>Broadcast(广播调用)</li>\n</ul>\n<p>这些名称比较相似，概念也比较容易混淆，下面逐一进行解释。</p>\n<h4>Failover(失败自动切换)</h4>\n<p><code>Failover</code>是高可用系统中的一个常用概念，服务器通常拥有主备两套机器配置，如果主服务器出现故障，则自动切换到备服务器中，从而保证了整体的高可用性。</p>\n<p>Dubbo也借鉴了这个思想，并且把它作为Dubbo<code>默认的容错策略</code>。当调用出现失败的时候，根据配置的重试次数，会自动从其他可用地址中重新选择一个可用的地址进行调用，直到调用成功，或者是达到重试的上限位置。</p>\n<p>Dubbo里默认配置的重试次数是2，也就是说，算上第一次调用，最多会调用3次。</p>\n<p>其配置方法，容错策略既可以在服务提供方配置，也可以服务调用方进行配置。而重试次数的配置则更为灵活，既可以在服务级别进行配置，也可以在方法级别进行配置。具体优先顺序为：</p>\n<pre><code>服务调用方方法级配置 &gt; 服务调用方服务级配置 &gt; 服务提供方方法级配置 &gt; 服务提供方服务级配置\n</code></pre>\n<p>以XML方式为例，具体配置方法如下：</p>\n<p>服务提供方，服务级配置</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.DemoService\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">cluster</span>=<span class=\"hljs-string\">\"failover\"</span> <span class=\"hljs-attr\">retries</span>=<span class=\"hljs-string\">\"2\"</span> /&gt;</span>\n</code></pre>\n<p>服务提供方，方法级配置</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.DemoService\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"demoService\"</span><span class=\"hljs-attr\">cluster</span>=<span class=\"hljs-string\">\"failover\"</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"sayHello\"</span> <span class=\"hljs-attr\">retries</span>=<span class=\"hljs-string\">\"2\"</span> /&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dubbo:reference</span>&gt;</span>\n</code></pre>\n<p>服务调用方，服务级配置</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.DemoService\"</span> <span class=\"hljs-attr\">cluster</span>=<span class=\"hljs-string\">\"failover\"</span> <span class=\"hljs-attr\">retries</span>=<span class=\"hljs-string\">\"1\"</span>/&gt;</span>\n</code></pre>\n<p>服务调用方，方法级配置：</p>\n<pre><code class=\"language-xml\"> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.DemoService\"</span> <span class=\"hljs-attr\">cluster</span>=<span class=\"hljs-string\">\"failover\"</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"sayHello\"</span> <span class=\"hljs-attr\">retries</span>=<span class=\"hljs-string\">\"3\"</span> /&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dubbo:reference</span>&gt;</span>\n</code></pre>\n<p>Failover可以自动对失败进行重试，对调用者屏蔽了失败的细节，但是Failover策略也会带来一些副作用：</p>\n<ul>\n<li>重试会额外增加一下开销，例如增加资源的使用，在高负载系统下，额外的重试可能让系统雪上加霜。</li>\n<li>重试会增加调用的响应时间。</li>\n<li>某些情况下，重试甚至会造成资源的浪费。考虑一个调用场景，A-&gt;B-&gt;C，如果A处设置了超时100ms，再B-&gt;C的第一次调用完成时已经超过了100ms，但很不幸B-&gt;C失败，这时候会进行重试，但其实这时候重试已经没有意义，因此在A看来这次调用已经超时，A可能已经开始执行其他逻辑。</li>\n</ul>\n<h4>Failsafe(失败安全)</h4>\n<p>失败安全策略的核心是即使失败了也不会影响整个调用流程。通常情况下用于旁路系统或流程中，它的失败不影响核心业务的正确性。在实现上，当出现调用失败时，会忽略此错误，并记录一条日志，同时返回一个空结果，在上游看来调用是成功的。</p>\n<p>应用场景，可以用于写入审计日志等操作。</p>\n<p>具体配置方法：</p>\n<p>服务提供方，服务级配置</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.DemoService\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">cluster</span>=<span class=\"hljs-string\">\"failsafe\"</span> /&gt;</span>\n</code></pre>\n<p>服务调用方，服务级配置</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.DemoService\"</span> <span class=\"hljs-attr\">cluster</span>=<span class=\"hljs-string\">\"failsafe\"</span>/&gt;</span>\n</code></pre>\n<p>其中服务调用方配置优先于服务提供方配置。</p>\n<h4>Failfast(快速失败)</h4>\n<p>某些业务场景中，某些操作可能是非幂等的，如果重复发起调用，可能会导致出现脏数据等。例如调用某个服务，其中包含一个数据库的写操作，如果写操作完成，但是在发送结果给调用方的过程中出错了，那么在调用发看来这次调用失败了，但其实数据写入已经完成。这种情况下，重试可能并不是一个好策略，这时候就需要使用到<code>Failfast</code>策略，调用失败立即报错。让调用方来决定下一步的操作并保证业务的幂等性。</p>\n<p>具体配置方法：</p>\n<p>服务提供方，服务级配置</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.DemoService\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">cluster</span>=<span class=\"hljs-string\">\"failfast\"</span> /&gt;</span>\n</code></pre>\n<p>服务调用方，服务级配置</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.DemoService\"</span> <span class=\"hljs-attr\">cluster</span>=<span class=\"hljs-string\">\"failfast\"</span>/&gt;</span>\n</code></pre>\n<p>其中服务调用方配置优先于服务提供方配置。</p>\n<h4>Failback(失败自动恢复)</h4>\n<p><code>Failback</code>通常和<code>Failover</code>两个概念联系在一起。在高可用系统中，当主机发生故障，通过<code>Failover</code>进行主备切换后，待故障恢复后，系统应该具备自动恢复原始配置的能力。</p>\n<p>Dubbo中的<code>Failback</code>策略中，如果调用失败，则此次失败相当于<code>Failsafe</code>，将返回一个空结果。而与<code>Failsafe</code>不同的是，Failback策略会将这次调用加入内存中的失败列表中，对于这个列表中的失败调用，会在另一个线程中进行异步重试，重试如果再发生失败，则会忽略，即使重试调用成功，原来的调用方也感知不到了。因此它通常适合于，对于实时性要求不高，且不需要返回值的一些异步操作。</p>\n<p>具体配置方法：</p>\n<p>服务提供方，服务级配置</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.DemoService\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">cluster</span>=<span class=\"hljs-string\">\"failsafe\"</span> /&gt;</span>\n</code></pre>\n<p>服务调用方，服务级配置</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.DemoService\"</span> <span class=\"hljs-attr\">cluster</span>=<span class=\"hljs-string\">\"failsafe\"</span>/&gt;</span>\n</code></pre>\n<p>其中服务调用方配置优先于服务提供方配置。</p>\n<p>按照目前的实现，Failback策略还有一些局限，例如内存中的失败调用列表没有上限，可能导致堆积，异步重试的执行间隔无法调整，默认是5秒。</p>\n<h4>Forking(并行调用)</h4>\n<p>上述几种策略中，主要都是针对调用失败发生后如何进行弥补的角度去考虑的，而<code>Forking</code>策略则跟上述几种策略不同，是一种典型的用成本换时间的思路。即第一次调用的时候就同时发起多个调用，只要其中一个调用成功，就认为成功。在资源充足，且对于失败的容忍度较低的场景下，可以采用此策略。</p>\n<p>具体配置方法：</p>\n<p>服务提供方，服务级配置</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.DemoService\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">cluster</span>=<span class=\"hljs-string\">\"forking\"</span> /&gt;</span>\n</code></pre>\n<p>服务调用方，服务级配置</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.DemoService\"</span> <span class=\"hljs-attr\">cluster</span>=<span class=\"hljs-string\">\"forking\"</span>/&gt;</span>\n</code></pre>\n<p>其中服务调用方配置优先于服务提供方配置。</p>\n<h4>Broadcast(广播调用)</h4>\n<p>在某些场景下，可能需要对服务的所有提供者进行操作，此时可以使用广播调用策略。此策略会逐个调用所有提供者，只要任意有一个提供者出错，则认为此次调用出错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>\n<p>具体配置方法：</p>\n<p>服务提供方，服务级配置</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.DemoService\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">cluster</span>=<span class=\"hljs-string\">\"broadcast\"</span> /&gt;</span>\n</code></pre>\n<p>服务调用方，服务级配置</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.DemoService\"</span> <span class=\"hljs-attr\">cluster</span>=<span class=\"hljs-string\">\"broadcast\"</span>/&gt;</span>\n</code></pre>\n<p>其中服务调用方配置优先于服务提供方配置。</p>\n<h4>各种策略对比</h4>\n<p>下表对各种策略做一个简单对比，</p>\n<table>\n<thead>\n<tr>\n<th>策略名称</th>\n<th>优点</th>\n<th>缺点</th>\n<th>主要应用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Failover</td>\n<td>对调用者屏蔽调用失败的信息</td>\n<td>增加RT，额外资源开销，资源浪费</td>\n<td>对调用rt不敏感的场景</td>\n</tr>\n<tr>\n<td>Failfast</td>\n<td>业务快速感知失败状态进行自主决策</td>\n<td>产生较多报错的信息</td>\n<td>非幂等性操作，需要快速感知失败的场景</td>\n</tr>\n<tr>\n<td>Failsafe</td>\n<td>即使失败了也不会影响核心流程</td>\n<td>对于失败的信息不敏感，需要额外的监控</td>\n<td>旁路系统，失败不影响核心流程正确性的场景</td>\n</tr>\n<tr>\n<td>Failback</td>\n<td>失败自动异步重试</td>\n<td>重试任务可能堆积</td>\n<td>对于实时性要求不高，且不需要返回值的一些异步操作</td>\n</tr>\n<tr>\n<td>Forking</td>\n<td>并行发起多个调用，降低失败概率</td>\n<td>消耗额外的机器资源，需要确保操作幂等性</td>\n<td>资源充足，且对于失败的容忍度较低，实时性要求高的场景</td>\n</tr>\n<tr>\n<td>Broadcast</td>\n<td>支持对所有的服务提供者进行操作</td>\n<td>资源消耗很大</td>\n<td>通知所有提供者更新缓存或日志等本地资源信息</td>\n</tr>\n</tbody>\n</table>\n<h3>自定义容错策略</h3>\n<p>如果上述内置的容错策略无法满足你的需求，还可以通过扩展的方式来实现自定义容错策略。</p>\n<h4>扩展接口</h4>\n<p><code>com.alibaba.dubbo.rpc.cluster.Cluster</code></p>\n<h4>扩展配置</h4>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">cluster</span>=<span class=\"hljs-string\">\"xxx\"</span> /&gt;</span>\n</code></pre>\n<h4>扩展示例</h4>\n<p>下面通过一个例子来展示如何使用自定义的容错策略。\nMaven 项目结构：</p>\n<pre><code>src\n |-main\n    |-java\n        |-com\n            |-xxx\n                |-XxxCluster.java (实现Cluster接口)\n    |-resources\n        |-META-INF\n            |-dubbo\n                |-org.apache.dubbo.rpc.cluster.Cluster (纯文本文件，内容为：xxx=com.xxx.XxxCluster)\n</code></pre>\n<p>XxxCluster.java：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.xxx;\n \n<span class=\"hljs-keyword\">import</span> org.apache.dubbo.rpc.cluster.Cluster;\n<span class=\"hljs-keyword\">import</span> org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker;\n<span class=\"hljs-keyword\">import</span> org.apache.dubbo.rpc.cluster.Directory;\n<span class=\"hljs-keyword\">import</span> org.apache.dubbo.rpc.cluster.LoadBalance;\n<span class=\"hljs-keyword\">import</span> org.apache.dubbo.rpc.Invoker;\n<span class=\"hljs-keyword\">import</span> org.apache.dubbo.rpc.Invocation;\n<span class=\"hljs-keyword\">import</span> org.apache.dubbo.rpc.Result;\n<span class=\"hljs-keyword\">import</span> org.apache.dubbo.rpc.RpcException;\n\n<span class=\"hljs-keyword\">import</span> java.util.List;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">XxxCluster</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Cluster</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">join</span><span class=\"hljs-params\">(Directory&lt;T&gt; directory)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> AbstractClusterInvoker&lt;T&gt;() {\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Result <span class=\"hljs-title\">doInvoke</span><span class=\"hljs-params\">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n                <span class=\"hljs-comment\">// your custimzed fault tolarence strategy goes here</span>\n            }\n        };\n    }\n\n}\n</code></pre>\n<p><code>META-INF/dubbo/com.alibaba.dubbo.rpc.cluster.Cluster</code>文件的内容为</p>\n<pre><code>xxx=com.xxx.XxxCluster\n</code></pre>\n",
  "link": "/zh-cn/blog/dubbo-cluster-error-handling.html",
  "meta": {
    "title": "Dubbo集群容错",
    "keywords": "Dubbo, RPC, cluster, Error-handling",
    "description": "在分布式系统中，集群某个某些节点出现问题是大概率事件，因此在设计分布式RPC框架的过程中，必须要把失败作为设计的一等公民来对待。一次调用失败之后，应该如何选择对失败的选择策略，这是一个见仁见智的问题，每种策略可能都有自己独特的应用场景。因此，作为框架来说，应当针对不同场景提供多种策略，供用户进行选择。本文介绍了Dubbo框架提供的多种错误处理策略，并通过实例说明如何进行配置。"
  }
}