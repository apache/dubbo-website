{
  "filename": "dubbo-compatible.md",
  "__html": "<h1>Dubbo 2.7.x repackage后的兼容实现方案</h1>\n<p>Dubbo至加入Apache孵化器以来，一个很强的诉求就是需要rename groupId和package name，这两项工作在项目毕业前需要完成。其中rename package相对来说复杂一些，除了要修改所有类的包名为<code>org.apache.dubbo</code>外，更多的是需要考虑如何老版本的兼容性。</p>\n<p>常见的兼容性包括但不限于以下几种情况：</p>\n<ul>\n<li>用户API\n<ul>\n<li>编程API</li>\n<li>Spring注解</li>\n</ul>\n</li>\n<li>扩展SPI\n<ul>\n<li>扩展Filter</li>\n</ul>\n</li>\n</ul>\n<p>2.7.x里就是通过增加了一个新的模块<code>dubbo-compatible</code>来解决以上兼容性问题。</p>\n<h2>编程使用API</h2>\n<p>编程使用API是最直接最原始的使用方式，其他方式诸如Spring schema、注解等方式都是基于原始API的；因此非常有必要对API编程形式进行兼容。</p>\n<p>所有编程相关API的兼容代码均在<code>com.alibaba.dubbo.config</code>包下，下面我们看看几个常见API的兼容实现。</p>\n<h3>ApplicationConfig</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.alibaba.dubbo.config;\n\n<span class=\"hljs-meta\">@Deprecated</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ApplicationConfig</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">org</span>.<span class=\"hljs-title\">apache</span>.<span class=\"hljs-title\">dubbo</span>.<span class=\"hljs-title\">config</span>.<span class=\"hljs-title\">ApplicationConfig</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ApplicationConfig</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">super</span>();\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ApplicationConfig</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(name);\n    }\n}\n</code></pre>\n<h3>ProtocolConfig</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.alibaba.dubbo.config;\n\n<span class=\"hljs-meta\">@Deprecated</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProtocolConfig</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">org</span>.<span class=\"hljs-title\">apache</span>.<span class=\"hljs-title\">dubbo</span>.<span class=\"hljs-title\">config</span>.<span class=\"hljs-title\">ProtocolConfig</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ProtocolConfig</span><span class=\"hljs-params\">()</span> </span>{\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ProtocolConfig</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(name);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ProtocolConfig</span><span class=\"hljs-params\">(String name, <span class=\"hljs-keyword\">int</span> port)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(name, port);\n    }\n}\n</code></pre>\n<p>可以看到：</p>\n<ol>\n<li>兼容类是直接通过继续repacakge后的类，达到最大程度的代码复用；</li>\n<li>构造函数也需要保持兼容；</li>\n</ol>\n<p>整个兼容包中，除了上述API以外，包括一些常用的类比如<code>Constants</code>、<code>URL</code>以及绝大部分的兼容类都是通过简单的继承，让用户基于老的API实现的类能正确运行。</p>\n<h2>Spring注解</h2>\n<p>Spring注解诸如<code>@EnableDubbo</code>、<code>@Service</code>以及<code>@Reference</code>，由于不能使用继承，故这些注解类是通过代码拷贝来实现的；用于处理这些注解的Spring BeanPostProcessor以及Parser等相关的类，也是通过拷贝来实现；</p>\n<p>这类兼容代码分别位于兼容包的以下几个package中：</p>\n<ul>\n<li>com.alibaba.dubbo.config.annotation</li>\n<li>com.alibaba.dubbo.config.spring.context.annotation</li>\n<li>org.apache.dubbo.config.spring</li>\n</ul>\n<p>所以这里要特别强调的是，这类代码在2.7.x里存在2份，因此有修改的同时需要同步修改。</p>\n<h2>扩展SPI</h2>\n<p>Dubbo的SPI扩展机制，可以通过<a href=\"http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi.html\">Dubbo可扩展机制实战</a>这篇博客详细了解。</p>\n<p>以Filter扩展为例，简单来说就是：</p>\n<ol>\n<li>\n<p>MyFilter需要实现Filter接口</p>\n</li>\n<li>\n<p>在META-INF/dubbo下，增加META-INF/dubbo/com.alibaba.dubbo.rpc.Filter，内容为：</p>\n<pre><code>myFilter=com.test.MyFilter\n</code></pre>\n</li>\n</ol>\n<p>看似简单的两点，对Dubbo框架来说，需要：</p>\n<ol>\n<li>正确加载配置文件META-INF/dubbo/com.alibaba.dubbo.rpc.Filter</li>\n<li>正确加载MyFilter类并执行invoke方法</li>\n</ol>\n<p>下面分别介绍Dubbo框架怎么实现以上几点。</p>\n<h3>正确加载META-INF/dubbo/com.alibaba.dubbo.rpc.Filter</h3>\n<p>Dubbo SPI机制在查找配置文件时，是根据扩展点的类名来查找的，以Filter为例，在包名变为org.apache.dubbo后，查询的目录变成：</p>\n<ul>\n<li>META-INF/dubbo/internal/org.apache.dubbo.rpc.Filter</li>\n<li>META-INF/dubbo/org.apache.dubbo.rpc.Filter</li>\n<li>META-INF/services/org.apache.dubbo.rpc.Filter</li>\n</ul>\n<p>但是用户之前按老的包实现的Filter，其配置是放在类似<code>META-INF/dubbo/com.alibaba.dubbo.rpc.Filter</code>的，如果框架不做特殊处理，是不会加载老配置的。</p>\n<p>因此在<code>ExtensionLoader</code>这个类里，做了特殊的处理：</p>\n<pre><code class=\"language-java\">    <span class=\"hljs-comment\">// synchronized in getExtensionClasses</span>\n    <span class=\"hljs-keyword\">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() {\n        <span class=\"hljs-keyword\">final</span> SPI defaultAnnotation = type.getAnnotation(SPI.class);\n        <span class=\"hljs-keyword\">if</span> (defaultAnnotation != <span class=\"hljs-keyword\">null</span>) {\n            String value = defaultAnnotation.value();\n            <span class=\"hljs-keyword\">if</span> ((value = value.trim()).length() &gt; <span class=\"hljs-number\">0</span>) {\n                String[] names = NAME_SEPARATOR.split(value);\n                <span class=\"hljs-keyword\">if</span> (names.length &gt; <span class=\"hljs-number\">1</span>) {\n                    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"more than 1 default extension name on extension \"</span> + type.getName()\n                            + <span class=\"hljs-string\">\": \"</span> + Arrays.toString(names));\n                }\n                <span class=\"hljs-keyword\">if</span> (names.length == <span class=\"hljs-number\">1</span>) cachedDefaultName = names[<span class=\"hljs-number\">0</span>];\n            }\n        }\n\n        Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();\n        loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName());\n        loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace(<span class=\"hljs-string\">\"org.apache\"</span>, <span class=\"hljs-string\">\"com.alibaba\"</span>));\n        loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName());\n        loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace(<span class=\"hljs-string\">\"org.apache\"</span>, <span class=\"hljs-string\">\"com.alibaba\"</span>));\n        loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName());\n        loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace(<span class=\"hljs-string\">\"org.apache\"</span>, <span class=\"hljs-string\">\"com.alibaba\"</span>));\n        <span class=\"hljs-keyword\">return</span> extensionClasses;\n    }\n</code></pre>\n<p>可以看到，除了加载新配置外，老配置文件也会进行扫描。</p>\n<h3>正确加载MyFilter类</h3>\n<p><code>com.alibaba.dubbo.rpc.Filter</code>接口除了要继承自<code>org.apache.dubbo.rpc.Filter</code>以外，其唯一的方法invoke也需要做特殊处理。我们看看它的方法签名：</p>\n<p><code>Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException;</code></p>\n<p>这里参数、返回值、异常都会被实现类<code>MyFilter</code>用到，因此这些类也需要有兼容类；而参数、返回值不同，对于接口来说是不同的方法，因此：</p>\n<ul>\n<li>需要在com.alibaba.dubbo.rpc.Filter里，定义老的invoke方法，MyFilter会覆盖这个方法；</li>\n<li>org.apache.dubbo.rpc.Filter里的invoke方法，需要找一个地方来实现桥接，框架调用Filter链执行到新的invoke方法时，新的参数如何转换成老参数，老返回值如何转换成新的返回值；</li>\n</ul>\n<p>这里就用到了JDK8的新特性：接口default方法。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Deprecated</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Filter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">org</span>.<span class=\"hljs-title\">apache</span>.<span class=\"hljs-title\">dubbo</span>.<span class=\"hljs-title\">rpc</span>.<span class=\"hljs-title\">Filter</span> </span>{\n\n    <span class=\"hljs-function\">Result <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> RpcException</span>;\n\n    <span class=\"hljs-keyword\">default</span> org.apache.dubbo.rpc.<span class=\"hljs-function\">Result <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(org.apache.dubbo.rpc.Invoker&lt;?&gt; invoker,\n                                               org.apache.dubbo.rpc.Invocation invocation)</span>\n            <span class=\"hljs-keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>{\n        Result.CompatibleResult result = (Result.CompatibleResult) invoke(<span class=\"hljs-keyword\">new</span> Invoker.CompatibleInvoker&lt;&gt;(invoker),\n                <span class=\"hljs-keyword\">new</span> Invocation.CompatibleInvocation(invocation));\n        <span class=\"hljs-keyword\">return</span> result.getDelegate();\n    }\n}\n</code></pre>\n<p>可以看到，default方法里，对参数进行了包装，然后调用老的invoke方法，并将返回值进行解包后返回给Dubbo框架。这里Result.CompatibleResult、Invocation.CompatibleInvocation以及Invoker.CompatibleInvoker都用到了代理模式。</p>\n<p>感兴趣的同学可以详细看一下以下几个类：</p>\n<ul>\n<li>com.alibaba.dubbo.rpc.Invocation</li>\n<li>com.alibaba.dubbo.rpc.Invoker</li>\n<li>com.alibaba.dubbo.rpc.Result</li>\n</ul>\n<h2>后续todo list</h2>\n<p>目前兼容包仅仅是对常见的API及SPI做了支持，列表如下：</p>\n<ul>\n<li>com.alibaba.dubbo.rpc.Filter / Invocation / Invoker / Result / RpcContext / RpcException</li>\n<li>com.alibaba.dubbo.config.*Config</li>\n<li>com.alibaba.dubbo.config.annotation.Reference / Service</li>\n<li>com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo</li>\n<li>com.alibaba.dubbo.common.Constants / URL</li>\n<li>com.alibaba.dubbo.common.extension.ExtensionFactory</li>\n<li>com.alibaba.dubbo.common.serialize.Serialization / ObjectInput / ObjectOutput</li>\n<li>com.alibaba.dubbo.cache.CacheFactory / Cache</li>\n<li>com.alibaba.dubbo.rpc.service.EchoService / GenericService</li>\n</ul>\n<p>大家如果在试用的过程中发现有任何问题请及时提出；同时如果对其他扩展点有兼容需求，也请大家提出来，也非常欢迎大家自己解决并贡献出来。</p>\n",
  "link": "/zh-cn/blog/dubbo-compatible.html",
  "meta": {
    "title": "Dubbo 2.7.x repackage后的兼容实现方案",
    "keywords": "Dubbo, repackage, 兼容",
    "description": "本文简单描述了2.7.x repackage后对老版本的兼容性实现方案。"
  }
}