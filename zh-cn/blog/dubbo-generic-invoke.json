{
  "filename": "dubbo-generic-invoke.md",
  "__html": "<h1>Dubbo的泛化调用</h1>\n<p>以下几种场景可以考虑使用泛化调用：</p>\n<ul>\n<li>服务测试平台</li>\n<li>API 服务网关</li>\n</ul>\n<p>泛化调用主要用于消费端没有 API 接口的情况；不需要引入接口 jar 包，而是直接通过 GenericService 接口来发起服务调用，参数及返回值中的所有 POJO 均用 <code>Map</code> 表示。泛化调用对于服务端无需关注，按正常服务进行暴露即可。</p>\n<p>下面来看看消费端如何使用泛化调用进行服务调用。</p>\n<h4>通过 Spring XML 配置进行泛化调用</h4>\n<p>在 Spring 配置申明 <code>generic=&quot;true&quot;</code>，如：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"userService\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.generic.api.IUserService\"</span> <span class=\"hljs-attr\">generic</span>=<span class=\"hljs-string\">\"true\"</span>/&gt;</span>\n</code></pre>\n<p>需要使用的地方，通过强制类型转化为 GenericService 进行调用：</p>\n<pre><code class=\"language-java\">GenericService userService = (GenericService) context.getBean(<span class=\"hljs-string\">\"userService\"</span>);\n<span class=\"hljs-comment\">// primary param and return value</span>\nString name = (String) userService.$invoke(<span class=\"hljs-string\">\"delete\"</span>, <span class=\"hljs-keyword\">new</span> String[]{<span class=\"hljs-keyword\">int</span>.class.getName()}, <span class=\"hljs-keyword\">new</span> Object[]{<span class=\"hljs-number\">1</span>});\nSystem.out.println(name);\n</code></pre>\n<p>其中：</p>\n<ol>\n<li>GenericService 这个接口只有一个方法，名为 <code>$invoke</code>，它接受三个参数，分别为方法名、方法参数类型数组和参数值数组；</li>\n<li>对于方法参数类型数组\n<ol>\n<li>如果是基本类型，如 int 或 long，可以使用 <code>int.class.getName()</code>获取其类型；</li>\n<li>如果是基本类型数组，如 int[]，则可以使用 <code>int[].class.getName()</code>；</li>\n<li>如果是 POJO，则直接使用全类名，如 <code>com.alibaba.dubbo.samples.generic.api.Params</code>。</li>\n</ol>\n</li>\n</ol>\n<h4>通过 API 编程进行泛化调用</h4>\n<pre><code>ApplicationConfig application = new ApplicationConfig()ApplicationConfig application = new ApplicationConfig();\napplication.setName(&quot;api-generic-consumer&quot;);\n\nRegistryConfig registry = new RegistryConfig();\nregistry.setAddress(&quot;zookeeper://127.0.0.1:2181&quot;);\n\napplication.setRegistry(registry);\n\nReferenceConfig&lt;GenericService&gt; reference = new ReferenceConfig&lt;GenericService&gt;();\n// 弱类型接口名\nreference.setInterface(&quot;com.alibaba.dubbo.samples.generic.api.IUserService&quot;);\n// 声明为泛化接口\nreference.setGeneric(true);\n\nreference.setApplication(application);\n\n// 用com.alibaba.dubbo.rpc.service.GenericService可以替代所有接口引用\nGenericService genericService = reference.get();\n\nString name = (String) genericService.$invoke(&quot;delete&quot;, new String[]{int.class.getName()}, new Object[]{1});\nSystem.out.println(name);\n</code></pre>\n<p>通过 API 的方式，不需要像 XML 的方式需要提前将服务配置好，可以动态构建 ReferenceConfig；相对 XML 来说，API 的方式更常见。</p>\n<h4>参数或返回值是 POJO 的场景</h4>\n<p>比如方法签名是 <code>User get(Params params);</code>其中 User 有 id 和 name 两个属性，Params 有 query 一个属性。</p>\n<p>以下是消费端的调用代码：</p>\n<pre><code class=\"language-java\">String[] parameterTypes = <span class=\"hljs-keyword\">new</span> String[]{<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.generic.api.Params\"</span>};\nMap&lt;String, Object&gt; params = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, Object&gt;();\nparam.put(<span class=\"hljs-string\">\"class\"</span>, <span class=\"hljs-string\">\"com.alibaba.dubbo.samples.generic.api.Params\"</span>);\nparam.put(<span class=\"hljs-string\">\"query\"</span>, <span class=\"hljs-string\">\"a=b\"</span>);\nObject user = userService.$invoke(<span class=\"hljs-string\">\"get\"</span>, parameterTypes, <span class=\"hljs-keyword\">new</span> Object[]{param});\nSystem.out.println(<span class=\"hljs-string\">\"sample one result: \"</span> + user);\n</code></pre>\n<p>上述代码的输出结果为：</p>\n<pre><code class=\"language-shell\">sample one result: {name=charles, id=1, class=com.alibaba.dubbo.samples.generic.api.User}\n</code></pre>\n<p>这里，Dubbo 框架会自动将 POJO 的返回值转换成 Map。可以看到，返回值 <code>user</code> 是一个 HashMap，里面分别存放了 name、id、class 三个 k/v。</p>\n<h4>泛接口实现</h4>\n<p>泛接口实现方式主要用于服务端没有 API 接口的情况，参数及返回值中的所有 POJO 均用 Map 表示，通常用于框架集成，如实现一个通用的远程服务 Mock 框架，可通过实现 GenericService 接口处理所有服务请求。</p>\n<h5>服务端实现 GenericService</h5>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GenericServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">GenericService</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> Object $invoke(String method, String[] parameterTypes, Object[] args) <span class=\"hljs-keyword\">throws</span> GenericException {\n        <span class=\"hljs-keyword\">if</span> (method.equals(<span class=\"hljs-string\">\"hi\"</span>)) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hi, \"</span> + args[<span class=\"hljs-number\">0</span>];\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (method.equals(<span class=\"hljs-string\">\"hello\"</span>)) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello, \"</span> + args[<span class=\"hljs-number\">0</span>];\n        }\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"welcome\"</span>;\n    }\n}\n</code></pre>\n<h5>服务端暴露服务</h5>\n<pre><code class=\"language-java\">ApplicationConfig application = <span class=\"hljs-keyword\">new</span> ApplicationConfig();\napplication.setName(<span class=\"hljs-string\">\"api-generic-provider\"</span>);\n\nRegistryConfig registry = <span class=\"hljs-keyword\">new</span> RegistryConfig();\nregistry.setAddress(<span class=\"hljs-string\">\"zookeeper://127.0.0.1:2181\"</span>);\n\napplication.setRegistry(registry);\n\nGenericService genericService = <span class=\"hljs-keyword\">new</span> GenericServiceImpl();\n\nServiceConfig&lt;GenericService&gt; service = <span class=\"hljs-keyword\">new</span> ServiceConfig&lt;GenericService&gt;();\nservice.setApplication(application);\nservice.setInterface(<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.generic.api.HelloService\"</span>);\nservice.setRef(genericService);\nservice.export();\n\nServiceConfig&lt;GenericService&gt; service2 = <span class=\"hljs-keyword\">new</span> ServiceConfig&lt;GenericService&gt;();\nservice2.setApplication(application);\nservice2.setInterface(<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.generic.api.HiService\"</span>);\nservice2.setRef(genericService);\nservice2.export();\n</code></pre>\n<p>同样，也可以使用 XML 配置的方式暴露服务；此时服务端是没有依赖 HiService 和 HelloService 这两个接口的。</p>\n<h5>消费端进行服务调用</h5>\n<pre><code class=\"language-java\">ApplicationConfig application = <span class=\"hljs-keyword\">new</span> ApplicationConfig();\napplication.setName(<span class=\"hljs-string\">\"api-generic-consumer\"</span>);\n\nRegistryConfig registry = <span class=\"hljs-keyword\">new</span> RegistryConfig();\nregistry.setAddress(<span class=\"hljs-string\">\"zookeeper://127.0.0.1:2181\"</span>);\n\napplication.setRegistry(registry);\n\nReferenceConfig&lt;GenericService&gt; reference = <span class=\"hljs-keyword\">new</span> ReferenceConfig&lt;GenericService&gt;();\n<span class=\"hljs-comment\">// 弱类型接口名</span>\nreference.setInterface(HiService.class);\nreference.setApplication(application);\n\nHiService hiService = (HiService) reference.get();\nSystem.out.println(hiService.hi(<span class=\"hljs-string\">\"dubbo\"</span>));\n\nReferenceConfig&lt;GenericService&gt; reference2 = <span class=\"hljs-keyword\">new</span> ReferenceConfig&lt;GenericService&gt;();\n<span class=\"hljs-comment\">// 弱类型接口名</span>\nreference2.setInterface(HelloService.class);\nreference2.setApplication(application);\n\nHelloService helloService = (HelloService) reference2.get();\nSystem.out.println(helloService.hello(<span class=\"hljs-string\">\"community\"</span>));\n</code></pre>\n<p>同样，消费端也可以使用 XML 配置的方式引用服务，然后进行调用。这里可以看到调用方式为普通的服务调用，并非泛化调用。当然使用泛化调用也是可以的。</p>\n<p>到这里为止，一个简易的服务 Mock 平台就成功上线了！</p>\n<h4>其他</h4>\n<ul>\n<li>本文介绍的泛化调用和泛接口实现，都是在原生的 <code>Dubbo</code> 协议之上的。在 2.6.2 版本之前，其他协议如 http/hessian 等是不支持泛化调用的，2.6.3 版本将会对这两个协议的泛化调用做支持。</li>\n<li>本文中提到的相关示例代码可以在 dubbo-samples中找到：<a href=\"https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-generic\">https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-generic</a></li>\n</ul>\n"
}