{
  "filename": "dubbo-invoke.md",
  "__html": "<h1>Dubbo 关于同步/异步调用的几种方式</h1>\n<p>我们知道，Dubbo 缺省协议采用单一长连接，底层实现是 Netty 的 NIO 异步通讯机制；基于这种机制，Dubbo 实现了以下几种调用方式：</p>\n<ul>\n<li>同步调用</li>\n<li>异步调用</li>\n<li>参数回调</li>\n<li>事件通知</li>\n</ul>\n<h3>同步调用</h3>\n<p>同步调用是一种阻塞式的调用方式，即 Consumer 端代码一直阻塞等待，直到 Provider 端返回为止；</p>\n<p>通常，一个典型的同步调用过程如下：</p>\n<ol>\n<li>Consumer 业务线程调用远程接口，向 Provider 发送请求，同时当前线程处于<code>阻塞</code>状态；</li>\n<li>Provider 接到 Consumer 的请求后，开始处理请求，将结果返回给 Consumer；</li>\n<li>Consumer 收到结果后，当前线程继续往后执行。</li>\n</ol>\n<p>这里有 2 个问题：</p>\n<ol>\n<li>Consumer 业务线程是怎么进入<code>阻塞</code>状态的？</li>\n<li>Consumer 收到结果后，如果唤醒业务线程往后执行的？</li>\n</ol>\n<p>其实，Dubbo 的底层 IO 操作都是异步的。Consumer 端发起调用后，得到一个 Future 对象。对于同步调用，业务线程通过<code>Future#get(timeout)</code>，阻塞等待 Provider 端将结果返回；<code>timeout</code>则是 Consumer 端定义的超时时间。当结果返回后，会设置到此 Future，并唤醒阻塞的业务线程；当超时时间到结果还未返回时，业务线程将会异常返回。</p>\n<h3>异步调用</h3>\n<p>基于 Dubbo 底层的异步 NIO 实现异步调用，对于 Provider 响应时间较长的场景是必须的，它能有效利用 Consumer 端的资源，相对于 Consumer 端使用多线程来说开销较小。</p>\n<p>异步调用，对于 Provider 端不需要做特别的配置。下面的例子中，Provider 端接口定义如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">AsyncService</span> </span>{\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">goodbye</span><span class=\"hljs-params\">(String name)</span></span>;\n}\n</code></pre>\n<h5>Consumer 配置</h5>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"asyncService\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.async.api.AsyncService\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"goodbye\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"true\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dubbo:reference</span>&gt;</span>\n</code></pre>\n<p>需要异步调用的方法，均需要使用 <code>&lt;dubbo:method/&gt;</code>标签进行描述。</p>\n<h5>Consumer 端发起调用</h5>\n<pre><code class=\"language-java\">AsyncService service = ...;\nString result = service.goodbye(<span class=\"hljs-string\">\"samples\"</span>);<span class=\"hljs-comment\">// 这里的返回值为空，请不要使用</span>\nFuture&lt;String&gt; future = RpcContext.getContext().getFuture();\n... <span class=\"hljs-comment\">// 业务线程可以开始做其他事情</span>\nresult = future.get(); <span class=\"hljs-comment\">// 阻塞需要获取异步结果时，也可以使用 get(timeout, unit) 设置超时时间</span>\n</code></pre>\n<p>Dubbo Consumer 端发起调用后，同时通过<code>RpcContext.getContext().getFuture()</code>获取跟返回结果关联的<code>Future</code>对象，然后就可以开始处理其他任务；当需要这次异步调用的结果时，可以在任意时刻通过<code>future.get(timeout)</code>来获取。</p>\n<p>一些特殊场景下，为了尽快调用返回，可以设置是否等待消息发出：</p>\n<ul>\n<li><code>sent=&quot;true&quot;</code> 等待消息发出，消息发送失败将抛出异常；</li>\n<li><code>sent=&quot;false&quot;</code> 不等待消息发出，将消息放入 IO 队列，即刻返回。</li>\n</ul>\n<p>默认为<code>fase</code>。配置方式如下：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"goodbye\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"true\"</span> <span class=\"hljs-attr\">sent</span>=<span class=\"hljs-string\">\"true\"</span> /&gt;</span>\n</code></pre>\n<p>如果你只是想异步，完全忽略返回值，可以配置 <code>return=&quot;false&quot;</code>，以减少 Future 对象的创建和管理成本：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"goodbye\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"true\"</span> <span class=\"hljs-attr\">return</span>=<span class=\"hljs-string\">\"false\"</span>/&gt;</span>\n</code></pre>\n<p>此时，<code>RpcContext.getContext().getFuture()</code>将返回<code>null</code>。</p>\n<p>整个异步调用的时序图如下：</p>\n<p><img src=\"../../img/blog/dubbo-async.svg\" alt=\"异步调用\"></p>\n<p>此示例代码位于：<a href=\"https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-async\">https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-async</a></p>\n<h3>参数回调</h3>\n<p>参数回调有点类似于本地 Callback 机制，但 Callback 并不是 Dubbo 内部的类或接口，而是由 Provider 端自定义的；Dubbo 将基于长连接生成反向代理，从而实现从 Provider 端调用 Consumer 端的逻辑。</p>\n<h5>Provider 端定义 Service 和 Callback</h5>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">CallbackService</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addListener</span><span class=\"hljs-params\">(String key, CallbackListener listener)</span></span>;\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">CallbackListener</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">changed</span><span class=\"hljs-params\">(String msg)</span></span>;\n}\n</code></pre>\n<h5>Provider 端 Service 实现</h5>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CallbackServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">CallbackService</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Map&lt;String, CallbackListener&gt; listeners = <span class=\"hljs-keyword\">new</span> ConcurrentHashMap&lt;String, CallbackListener&gt;();\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">CallbackServiceImpl</span><span class=\"hljs-params\">()</span> </span>{\n        Thread t = <span class=\"hljs-keyword\">new</span> Thread(<span class=\"hljs-keyword\">new</span> Runnable() {\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n                <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">true</span>) {\n                    <span class=\"hljs-keyword\">try</span> {\n                        <span class=\"hljs-keyword\">for</span> (Map.Entry&lt;String, CallbackListener&gt; entry : listeners.entrySet()) {\n                            <span class=\"hljs-keyword\">try</span> {\n                                entry.getValue().changed(getChanged(entry.getKey()));\n                            } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n                                listeners.remove(entry.getKey());\n                            }\n                        }\n                        Thread.sleep(<span class=\"hljs-number\">5000</span>); <span class=\"hljs-comment\">// timely trigger change event</span>\n                    } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n                        t.printStackTrace();\n                    }\n                }\n            }\n        });\n        t.setDaemon(<span class=\"hljs-keyword\">true</span>);\n        t.start();\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addListener</span><span class=\"hljs-params\">(String key, CallbackListener listener)</span> </span>{\n        listeners.put(key, listener);\n        listener.changed(getChanged(key)); <span class=\"hljs-comment\">// send notification for change</span>\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> String <span class=\"hljs-title\">getChanged</span><span class=\"hljs-params\">(String key)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Changed: \"</span> + <span class=\"hljs-keyword\">new</span> SimpleDateFormat(<span class=\"hljs-string\">\"yyyy-MM-dd HH:mm:ss\"</span>).format(<span class=\"hljs-keyword\">new</span> Date());\n    }\n}\n</code></pre>\n<h5>Provider 端暴露服务</h5>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"callbackService\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.callback.impl.CallbackServiceImpl\"</span>/&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.callback.api.CallbackService\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"callbackService\"</span> <span class=\"hljs-attr\">connections</span>=<span class=\"hljs-string\">\"1\"</span> <span class=\"hljs-attr\">callbacks</span>=<span class=\"hljs-string\">\"1000\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"addListener\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:argument</span> <span class=\"hljs-attr\">index</span>=<span class=\"hljs-string\">\"1\"</span> <span class=\"hljs-attr\">callback</span>=<span class=\"hljs-string\">\"true\"</span>/&gt;</span>\n        <span class=\"hljs-comment\">&lt;!--&lt;dubbo:argument type=\"com.demo.CallbackListener\" callback=\"true\" /&gt;--&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dubbo:method</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dubbo:service</span>&gt;</span>\n</code></pre>\n<p>这里，Provider 需要在方法中声明哪个参数是 Callback 参数。</p>\n<h5>Consumer 端实现 Callback 接口</h5>\n<pre><code class=\"language-java\">CallbackService callbackService = ...;\ncallbackService.addListener(<span class=\"hljs-string\">\"foo.bar\"</span>, <span class=\"hljs-keyword\">new</span> CallbackListener() {\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">changed</span><span class=\"hljs-params\">(String msg)</span> </span>{\n            System.out.println(<span class=\"hljs-string\">\"callback1:\"</span> + msg);\n        }\n});\n</code></pre>\n<p>Callback 接口的实现类在 Consumer 端，当方法发生调用时，Consumer 端会自动 export 一个 Callback 服务。而 Provider 端在处理调用时，判断如果参数是 Callback，则生成了一个 proxy，因此服务实现类里在调用 Callback 方法的时候，会被传递到 Consumer 端执行 Callback 实现类的代码。</p>\n<p>上述示例代码位于：此示例代码位于：<a href=\"https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-callback\">https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-callback</a></p>\n<p>这种调用方式有点像消息的发布和订阅，但又有区别。比如当 Consumer 端 完成了Callback 服务的 export 后，如果后续重启了，这时 Provider 端就会调不通；同时 Provider 端如何清理掉这个 proxy 也是一个问题。</p>\n<h3>事件通知</h3>\n<p>事件通知允许 Consumer 端在调用之前、调用正常返回之后或调用出现异常时，触发 <code>oninvoke</code>、<code>onreturn</code>、<code>onthrow</code> 三个事件。</p>\n<p>可以通过在配置 Consumer 时，指定事件需要通知的方法，如：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demoCallback\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.notify.impl.NotifyImpl\"</span> /&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">check</span>=<span class=\"hljs-string\">\"false\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.notify.api.DemoService\"</span> <span class=\"hljs-attr\">version</span>=<span class=\"hljs-string\">\"1.0.0\"</span> <span class=\"hljs-attr\">group</span>=<span class=\"hljs-string\">\"cn\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"sayHello\"</span> <span class=\"hljs-attr\">onreturn</span>=<span class=\"hljs-string\">\"demoCallback.onreturn\"</span> <span class=\"hljs-attr\">onthrow</span>=<span class=\"hljs-string\">\"demoCallback.onthrow\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dubbo:reference</span>&gt;</span>\n</code></pre>\n<p>其中，NotifyImpl 的代码如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NotifyImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Notify</span></span>{\n\n    <span class=\"hljs-keyword\">public</span> Map&lt;Integer, String&gt; ret = <span class=\"hljs-keyword\">new</span> HashMap&lt;Integer, String&gt;();\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onreturn</span><span class=\"hljs-params\">(String name, <span class=\"hljs-keyword\">int</span> id)</span> </span>{\n        ret.put(id, name);\n        System.out.println(<span class=\"hljs-string\">\"onreturn: \"</span> + name);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onthrow</span><span class=\"hljs-params\">(Throwable ex, String name, <span class=\"hljs-keyword\">int</span> id)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"onthrow: \"</span> + name);\n    }\n}\n</code></pre>\n<p>这里要强调一点，自定义 Notify 接口中的三个方法的参数规则如下：</p>\n<ul>\n<li><code>oninvoke</code> 方法参数与调用方法的参数相同；</li>\n<li><code>onreturn</code>方法第一个参数为调用方法的返回值，其余为调用方法的参数；</li>\n<li><code>onthrow</code>方法第一个参数为调用异常，其余为调用方法的参数。</li>\n</ul>\n<p>上述配置中，<code>sayHello</code>方法为同步调用，因此事件通知方法的执行也是同步执行。可以配置 <code>async=true</code>让方法调用为异步，这时事件通知的方法也是异步执行的。特别强调一下，<code>oninvoke</code>方法不管是否异步调用，都是同步执行的。</p>\n<p>事件通知的示例代码请参考：<a href=\"https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-notify\">https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-notify</a></p>\n"
}