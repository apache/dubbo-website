{
  "filename": "dubbo-loadbalance.md",
  "__html": "<h1>Dubbo的负载均衡</h1>\n<h1>背景</h1>\n<p>Dubbo是一个分布式服务框架，能避免单点故障和支持服务的横向扩容。一个服务通常会部署多个实例。如何从多个服务提供者组成的集群中挑选出一个进行调用，就涉及到一个负载均衡的策略。</p>\n<h1>几个概念</h1>\n<p>在讨论负载均衡之前，我想先解释一下这3个概念。</p>\n<ol>\n<li>负载均衡</li>\n<li>集群容错</li>\n<li>服务路由</li>\n</ol>\n<p>这3个概念容易混淆。他们都描述了怎么从多个Provider中选择一个来进行调用。那他们到底有什么区别呢?下面我来举一个简单的例子，把这几个概念阐述清楚吧。</p>\n<p>有一个Dubbo的用户服务，在北京部署了10个，在上海部署了20个。一个杭州的服务消费方发起了一次调用，然后发生了以下的事情:</p>\n<ol>\n<li>根据配置的路由规则，如果杭州发起的调用，会路由到比较近的上海的20个Provider。</li>\n<li>根据配置的随机负载均衡策略。在20个Provider中随机选择了一个来调用，假设随机到了第7个Provider。</li>\n<li>结果调用第7个Provider失败了。</li>\n<li>根据配置的Failover集群容错模式，重试其他服务器。</li>\n<li>重试了第13个Provider，调用成功。</li>\n</ol>\n<p>上面的第1，2，4步骤就分别对应了路由，负载均衡和集群容错。 Dubbo中，先通过路由，从多个Provider中按照路由规则，选出一个子集。再根据负载均衡从子集中选出一个Provider进行本次调用。如果调用失败了，根据集群容错策略，进行重试或定时重发或快速失败等。 可以看到Dubbo中的路由，负载均衡和集群容错发生在一次RPC调用的不同阶段。最先是路由，然后是负载均衡，最后是集群容错。 本文档只讨论负载均衡，路由和集群容错在其他的文档中进行说明。</p>\n<h1>Dubbo内置负载均衡策略</h1>\n<p>Dubbo内置了4种负载均衡策略:</p>\n<ol>\n<li>RandomLoadBalance:随机负载均衡。随机的选择一个。是Dubbo的<strong>默认</strong>负载均衡策略。</li>\n<li>RoundRobinLoadBalance:轮询负载均衡。轮询选择一个。</li>\n<li>LeastActiveLoadBalance:最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li>\n<li>ConsistentHashLoadBalance:一致性哈希负载均衡。相同参数的请求总是落在同一台机器上。</li>\n</ol>\n<h3>1.随机负载均衡</h3>\n<p>顾名思义，随机负载均衡策略就是从多个Provider中随机选择一个。但是Dubbo中的随机负载均衡有一个权重的概念，即按照权重设置随机概率。比如说，有10个Provider，并不是说，每个Provider的概率都是一样的，而是要结合这10个provider的权重来分配概率。</p>\n<p>Dubbo中，可以对Provider设置权重。比如机器性能好的，可以设置大一点的权重，性能差的，可以设置小一点的权重。权重会对负载均衡产生影响。可以在Dubbo Admin中对provider进行权重的设置。</p>\n<p><strong>基于权重的负载均衡算法</strong></p>\n<p>随机策略会先判断所有的invoker的权重是不是一样的，如果都是一样的，那么处理就比较简单了。使用random.nexInt(length)就可以随机生成一个invoker的序号,根据序号选择对应的invoker。如果没有在Dubbo Admin中对服务提供者设置权重，那么所有的invoker的权重就是一样的，默认是100。 如果权重不一样，那就需要结合权重来设置随机概率了。算法大概如下： 假如有4个invoker</p>\n<table>\n<thead>\n<tr>\n<th>invoker</th>\n<th>weight</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>10</td>\n</tr>\n<tr>\n<td>B</td>\n<td>20</td>\n</tr>\n<tr>\n<td>C</td>\n<td>20</td>\n</tr>\n<tr>\n<td>D</td>\n<td>30</td>\n</tr>\n</tbody>\n</table>\n<p>A，B，C和D总的权重是10 + 20 + 20 + 30 = 80。将80个数分布在如下的图中:</p>\n<pre><code>+-----------------------------------------------------------------------------------+\n|          |                    |                    |                              |\n+-----------------------------------------------------------------------------------+\n1          10                   30                   50                             80            \n\n|-----A----|---------B----------|----------C---------|---------------D--------------|\n\n\n---------------------15\n\n-------------------------------------------37\n\n-----------------------------------------------------------54\n</code></pre>\n<p>上面的图中一共有4块区域，长度分别是A，B，C和D的权重。使用random.nextInt(10 + 20 + 20 + 30)，从80个数中随机选择一个。然后再判断该数分布在哪个区域。比如，如果随机到37，37是分布在C区域的，那么就选择inboker C。15是在B区域，54是在D区域。</p>\n<p><strong>随机负载均衡源码</strong></p>\n<p>下面是随机负载均衡的源码，为了方便阅读和理解，我把无关部分都去掉了。</p>\n<pre><code>public class RandomLoadBalance extends AbstractLoadBalance {\n\n    private final Random random = new Random();\n\n    protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) {\n        int length = invokers.size();      // invoker总数\n        int totalWeight = 0;               // 所有invoker的权重的和\n        \n        // 判断是不是所有的invoker的权重都是一样的\n        // 如果权重都一样，就简单了。直接用Random生成索引就可以了。\n        boolean sameWeight = true; \n        for (int i = 0; i &lt; length; i++) {\n            int weight = getWeight(invokers.get(i), invocation);\n            totalWeight += weight; // Sum\n            if (sameWeight &amp;&amp; i &gt; 0 &amp;&amp; weight != getWeight(invokers.get(i - 1), invocation)) {\n                sameWeight = false;\n            }\n        }\n        \n        if (totalWeight &gt; 0 &amp;&amp; !sameWeight) {\n            // 如果不是所有的invoker权重都相同，那么基于权重来随机选择。权重越大的，被选中的概率越大\n            int offset = random.nextInt(totalWeight);\n            for (int i = 0; i &lt; length; i++) {\n                offset -= getWeight(invokers.get(i), invocation);\n                if (offset &lt; 0) {\n                    return invokers.get(i);\n                }\n            }\n        }\n        // 如果所有invoker权重相同\n        return invokers.get(random.nextInt(length));\n    }\n}\n</code></pre>\n<h3>2.轮循负载均衡</h3>\n<p>轮询负载均衡，就是依次的调用所有的Provider。和随机负载均衡策略一样，轮询负载均衡策略也有权重的概念。 轮询负载均衡算法可以让RPC调用严格按照我们设置的比例来分配。不管是少量的调用还是大量的调用。但是轮询负载均衡算法也有不足的地方，存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上，导致整个系统变慢。</p>\n<h3>3.最少活跃调用数负载均衡</h3>\n<p>官方解释：</p>\n<blockquote>\n<p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差，使慢的机器收到更少。</p>\n</blockquote>\n<p>这个解释好像说的不是太明白。知道了目的是让慢的机器收到更少，但具体怎么实现的还是不太清楚。让我来举个例子吧： 例如，每个服务维护一个活跃数计数器。当A机器开始处理请求，该计数器加1，此时A还未处理完成。若处理完毕则计数器减1。而B机器接受到请求后很快处理完毕。那么A,B的活跃数分别是1，0。当又产生了一个新的请求，则选择B机器去执行(B活跃数最小)，这样使慢的机器A收到少的请求。</p>\n<p>处理一个新的请求时，Consumer会检查所有Provider的活跃数，如果具有最小活跃数的invoker只有一个，直接返回该Invoker：</p>\n<pre><code>if (leastCount == 1) {\n    // 如果只有一个最小则直接返回\n    return invokers.get(leastIndexs[0]);\n}\n</code></pre>\n<p>如果最小活跃数的invoker有多个，且权重不相等同时总权重大于0，这时随机生成一个权重，范围在0，totalWeight 间内。最后根据随机生成的权重，来选择invoker。</p>\n<pre><code>if (! sameWeight &amp;&amp; totalWeight &gt; 0) {\n    // 如果权重不相同且权重大于0则按总权重数随机\n    int offsetWeight = random.nextInt(totalWeight);\n    // 并确定随机值落在哪个片断上\n    for (int i = 0; i &lt; leastCount; i++) {\n        int leastIndex = leastIndexs[i];\n        offsetWeight -= getWeight(invokers.get(leastIndex), invocation);\n        if (offsetWeight &lt;= 0)\n            return invokers.get(leastIndex);\n    }\n}\n</code></pre>\n<h3>4.一致性Hash算法</h3>\n<p>使用一致性 Hash，让相同参数的请求总是发到同一提供者。 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。 算法参见：<a href=\"http://en.wikipedia.org/wiki/Consistent_hashing\">http://en.wikipedia.org/wiki/Consistent_hashing</a>。</p>\n<p>缺省只对第一个参数Hash，如果要修改，请配置:</p>\n<pre><code>&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;\n</code></pre>\n<p>缺省用160份虚拟节点，如果要修改，请配置:</p>\n<pre><code>&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;\n</code></pre>\n<p>一致性Hash算法可以和缓存机制配合起来使用。比如有一个服务getUserInfo(String userId)。设置了Hash算法后，相同的userId的调用，都会发送到同一个提供者。这个提供者上可以把用户数据在内存中进行缓存，减少访问数据库或分布式缓存的次数。如果业务上允许这部分数据有一段时间的不一致，可以考虑这种做法。减少对数据库，缓存等中间件的依赖和访问次数，同时减少了网络IO操作，提高系统性能。\b</p>\n<h1>负载均衡配置</h1>\n<p>如果不指定负载均衡，默认使用随机负载均衡。我们也可以根据自己的需要，显式指定一个负载均衡。 可以在多个地方类来配置负载均衡，比如Provider端，Consumer端，服务级别，方法级别等。</p>\n<h3>服务端服务级别</h3>\n<pre><code>&lt;dubbo:service interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;\n</code></pre>\n<p>该服务的所有方法都使用roundrobin负载均衡。</p>\n<h3>客户端服务级别</h3>\n<pre><code>&lt;dubbo:reference interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;\n</code></pre>\n<p>该服务的所有方法都使用roundrobin负载均衡。</p>\n<h3>服务端方法级别</h3>\n<pre><code>&lt;dubbo:service interface=&quot;...&quot;&gt;\n    &lt;dubbo:method name=&quot;hello&quot; loadbalance=&quot;roundrobin&quot;/&gt;\n&lt;/dubbo:service&gt;\n</code></pre>\n<p>只有该服务的hello方法使用roundrobin负载均衡。</p>\n<h3>客户端方法级别</h3>\n<pre><code>&lt;dubbo:reference interface=&quot;...&quot;&gt;\n    &lt;dubbo:method name=&quot;hello&quot; loadbalance=&quot;roundrobin&quot;/&gt;\n&lt;/dubbo:reference&gt;\n</code></pre>\n<p>只有该服务的hello方法使用roundrobin负载均衡。</p>\n<p>和Dubbo其他的配置类似，多个配置是有覆盖关系的：</p>\n<ol>\n<li>方法级优先，接口级次之，全局配置再次之。</li>\n<li>如果级别一样，则消费方优先，提供方次之。</li>\n</ol>\n<p>所以，上面4种配置的优先级是:</p>\n<ol>\n<li>客户端方法级别配置。</li>\n<li>客户端接口级别配置。</li>\n<li>服务端方法级别配置。</li>\n<li>服务端接口级别配置。</li>\n</ol>\n<h1>扩展负载均衡</h1>\n<p>Dubbo的4种负载均衡的实现，大多数情况下能满足要求。有时候，因为业务的需要，我们可能需要实现自己的负载均衡策略。本章只说明如何配置负载均衡算法。关于Dubbo扩展机制的更多内容，请前往<a href=\"https://lark.alipay.com/aliware_articles/vtpf9h/pe9pyr\">Dubbo可扩展机制实战</a>。</p>\n<ol>\n<li>实现LoadBalance接口 以下是Dubbo的LoadBalance接口:</li>\n</ol>\n<pre><code>@SPI(RandomLoadBalance.NAME)\npublic interface LoadBalance {\n    @Adaptive(&quot;loadbalance&quot;)\n    &lt;T&gt; Invoker&lt;T&gt; select(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException;\n}\n</code></pre>\n<p>这是SPI的接口，select方法的参数如下:</p>\n<ul>\n<li>invokers: 所有的服务提供者列表。</li>\n<li>url: 一些配置信息，比如接口名，是否check，序列化方式。</li>\n<li>invocation: RPC调用的信息，包括方法名，方法参数类型，方法参数。 下面是我们自己实现的一个LoadBalance，实现很简单，选择第一个invoker:</li>\n</ul>\n<pre><code>package com.demo.dubbo;\npublic class DemoLoadBalance implements LoadBalance {\n    @Override\n    public &lt;T&gt; Invoker&lt;T&gt; select(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException {\n        System.out.println(&quot;[DemoLoadBalance]Select the first invoker...&quot;);\n        return invokers.get(0);\n    }\n}\n</code></pre>\n<ol>\n<li>添加资源文件 添加文件:<code>src/main/resource/META-INF/dubbo/com.alibaba.dubbo.rpc.cluster.LoadBalance</code>。这是一个简单的文本文件。文件内容如下:</li>\n</ol>\n<pre><code>demo=my=com.demo.dubbo.DemoLoadBalance\n</code></pre>\n<ol>\n<li>配置使用自定义LoadBalance</li>\n</ol>\n<pre><code>&lt;dubbo:reference id=&quot;helloService&quot; interface=&quot;com.demo.dubbo.api.IHelloService&quot; loadbalance=&quot;demo&quot; /&gt;\n</code></pre>\n<p>在consumer端的dubbo:reference中配置&lt;loadbalance=&quot;demo&quot;&gt;</p>\n<p>经过上面的3个步骤，我们编写了一个自定义的LoadBalance，并告诉Dubbo使用它了。启动Dubbo，我们就能看到Dubbo已经使用了自定义的DemoLoadBalance。</p>\n"
}