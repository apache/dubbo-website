{
  "filename": "dubbo-new-async.md",
  "__html": "<h1>如何基于Dubbo实现全异步调用链</h1>\n<p>基于Dubbo实现全异步编程，是在2.7.0版本中对现有异步方式增强后新引入的功能。本文先是回顾2.6.x及之前版本对异步的支持情况及存在的问题，引出了2.7.0版本基于CompletableFuture做了哪些针对性的增强，通过几个示例详细阐述了增强后的异步编程的使用方式，最后总结了引入异步模式带来的新问题及Dubbo的解决方法。通过阅读这篇文章，可以很容易的基于Dubbo2.7.0+版本实现一个全异步的远程服务调用链路。</p>\n<h2>2.6.x版本之前的异步方式</h2>\n<p>在2.6.x及之前的版本提供了一定的异步编程能力，包括Consumer端<a href=\"http://dubbo.apache.org/books/dubbo-user-book/demos/async-call.html\">异步调用</a>、<a href=\"http://dubbo.apache.org/books/dubbo-user-book/demos/callback-parameter.html\">参数回调</a>、<a href=\"http://dubbo.apache.org/books/dubbo-user-book/demos/events-notify.html\">事件通知</a>等，在上面的文档链接中有关于使用方式的简单介绍和Demo。</p>\n<p>但当前的异步方式存在以下问题：</p>\n<ul>\n<li>Future获取方式不够直接</li>\n<li>Future接口无法实现自动回调，而自定义ResponseFuture虽支持回调但支持的异步场景有限，如不支持Future间的相互协调或组合等</li>\n<li>不支持Provider端异步</li>\n</ul>\n<p>以Consumer端异步使用方式为例：</p>\n<ol>\n<li>定义一个普通的同步接口并声明支持异步调用</li>\n</ol>\n<pre><code>public interface FooService {\n    String findFoo(String name);\n}\n</code></pre>\n<pre><code>&lt;dubbo:reference id=&quot;fooService&quot; interface=&quot;com.alibaba.foo.FooService&quot;&gt;\n      &lt;dubbo:method name=&quot;findFoo&quot; async=&quot;true&quot; /&gt;\n&lt;/dubbo:reference&gt;\n</code></pre>\n<ol>\n<li>通过RpcContext获取Future</li>\n</ol>\n<pre><code>// 此调用会立即返回null\nfooService.findFoo(fooId);\n// 拿到调用的Future引用，当结果返回后，会被通知和设置到此Future\nFuture&lt;Foo&gt; fooFuture = RpcContext.getContext().getFuture();\nfooFuture.get();\n</code></pre>\n<p>或</p>\n<pre><code>// 此调用会立即返回null\nfooService.findFoo(fooId);\n// 拿到Dubbo内置的ResponseFuture并设置回调\nResponseFuture future = ((FutureAdapter)RpcContext.getContext().getFuture()).getFuture();\nfuture.setCallback(new ResponseCallback() {\n    @Override\n    public void done(Object response) {\n        System.out.print(response);\n    }\n\n    @Override\n    public void caught(Throwable exception) {\n        exception.printStackTrace();\n    }\n});\n</code></pre>\n<p>从这个简单的示例我们可以体会到一些使用中的不便之处：</p>\n<ol>\n<li>findFoo的同步接口，不能直接返回代表异步结果的Future，通过RpcContext进一步获取。</li>\n<li>Future只支持阻塞式的get()接口获取结果。</li>\n<li>通过获取内置的ResponseFuture接口，可以设置回调。但获取ResponseFuture的API使用不便，且仅支持设置回调其他异步场景均不支持，如多个Future协同工作的场景等。</li>\n</ol>\n<h2>2.7.0基于CompletableFuture的增强</h2>\n<p>了解Java中Future演进历史的同学应该知道，Dubbo 2.6.x及之前版本中使用的Future是在java 5中引入的，所以存在以上一些功能设计上的问题，而在java 8中引入的CompletableFuture进一步丰富了Future接口，很好的解决了这些问题。</p>\n<p>Dubbo在2.7.0版本已经升级了对Java 8的支持，同时基于CompletableFuture对当前的异步功能进行了增强。</p>\n<ol>\n<li>\n<p>支持直接定义返回CompletableFuture的服务接口。通过这种类型的接口，我们可以更自然的实现Consumer、Provider端的异步编程。</p>\n<pre><code>public interface AsyncService {\n    CompletableFuture&lt;String&gt; sayHello(String name);\n}\n</code></pre>\n</li>\n<li>\n<p>如果你不想将接口的返回值定义为Future类型，或者存在定义好的同步类型接口，则可以额外定义一个异步接口并提供Future类型的方法。</p>\n<pre><code>public interface GreetingsService {\n    String sayHi(String name);\n}\n</code></pre>\n<pre><code>@AsyncFor(AsyncService.class)\npublic interface GrettingServiceAsync extends GreetingsService {\n    CompletableFuture&lt;String&gt; sayHiAsync(String name);\n}\n</code></pre>\n<p>这样，Provider可以只实现sayHi方法；而Consumer通过直接调用sayHiAsync可以拿到一个Future实例，Dubbo框架在Provider端会自动转换为对sayHi方法的调用。</p>\n<p>为每个同步方法提供一个异步方法定义会比较麻烦，更进一步的，利用Dubbo生态中的<a href=\"https://github.com/dubbo/dubbo-async-processor\">Annotation Processor实现</a>，可以自动帮我们自动生成异步方法定义。</p>\n</li>\n<li>\n<p>同样的，如果你的原始接口定义不是Future类型的返回值，Provider端异步也提供了类似Servlet3.0里的Async Servlet的编程接口: <code>RpcContext.startAsync()</code>。</p>\n<pre><code>public interface AsyncService {\n    String sayHello(String name);\n}\n</code></pre>\n<pre><code>public class AsyncServiceImpl implements AsyncService {\n    public String sayHello(String name) {\n        final AsyncContext asyncContext = RpcContext.startAsync();\n        new Thread(() -&gt; {\n            asyncContext.write(&quot;Hello &quot; + name + &quot;, response from provider.&quot;);\n        }).start();\n        return null;\n    }\n}\n</code></pre>\n<p>在方法体的开始<code>RpcContext.startAsync()</code>启动异步，并开启新线程异步的执行业务逻辑，在耗时操作完成后通过<code>asyncContext.write</code>将结果写回。</p>\n</li>\n<li>\n<p>RpcContext直接返回CompletableFuture</p>\n<pre><code>CompletableFuture&lt;String&gt; f = RpcContext.getContext().getCompletableFuture();\n</code></pre>\n</li>\n</ol>\n<p>以上所有的增强，是在兼容已有异步编程的基础上进行的，因此基于2.6.x版本编写的异步程序不用做任何改造即可顺利编译通过。</p>\n<p>接下来，我们通过几个示例看一下如何实现一个全异步的Dubbo服务调用链。</p>\n<h2>示例1：CompletableFuture类型接口</h2>\n<p>CompletableFuture类型的接口既可以用作同步调用，也可以实现Consumer或Provider的异步调用。本示例实现了Consumer和Provider端异步调用，代码参见<a href=\"https://github.com/dubbo/dubbo-samples/tree/samples-for-2.7.0-SNAPSHOT/dubbo-samples-async-original-future\">dubbo-samples-async-original-future</a>。</p>\n<ol>\n<li>\n<p>定义接口</p>\n<pre><code>public interface AsyncService {\n    CompletableFuture&lt;String&gt; sayHello(String name);\n}\n</code></pre>\n<p>注意接口的返回类型是<code>CompletableFuture&lt;String&gt;</code>。</p>\n</li>\n<li>\n<p>Provider端</p>\n<ul>\n<li>\n<p>实现</p>\n<pre><code>public class AsyncServiceImpl implements AsyncService {\n    public CompletableFuture&lt;String&gt; sayHello(String name) {\n        return CompletableFuture.supplyAsync(() -&gt; {\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return &quot;async response from provider.&quot;;\n        });\n    }\n}\n</code></pre>\n<p>可以看到这里通过supplyAsync将业务代码切换到了新的线程执行，因此实现了Provider端异步。</p>\n</li>\n<li>\n<p>配置</p>\n<pre><code>&lt;bean id=&quot;asyncService&quot; class=&quot;com.alibaba.dubbo.samples.async.impl.AsyncServiceImpl&quot;/&gt;\n&lt;dubbo:service interface=&quot;com.alibaba.dubbo.samples.async.api.AsyncService&quot; ref=&quot;asyncService&quot;/&gt;\n</code></pre>\n<p>配置方式和普通接口是一样。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Consumer端</p>\n<ul>\n<li>配置</li>\n</ul>\n<pre><code>&lt;dubbo:reference id=&quot;asyncService&quot; timeout=&quot;10000&quot; interface=&quot;com.alibaba.dubbo.samples.async.api.AsyncService&quot;/&gt;\n</code></pre>\n<p>​\t配置方式和普通接口是一样。</p>\n<ul>\n<li>调用远程服务</li>\n</ul>\n<pre><code>public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{&quot;META-INF/spring/async-consumer.xml&quot;});\n        context.start();\n        final AsyncService asyncService = (AsyncService) context.getBean(&quot;asyncService&quot;);\n    \n        CompletableFuture&lt;String&gt; future = asyncService.sayHello(&quot;async call request&quot;);\n        future.whenComplete((v, t) -&gt; {\n            if (t != null) {\n                t.printStackTrace();\n            } else {\n                System.out.println(&quot;Response: &quot; + v);\n            }\n        });\n        System.out.println(&quot;Executed before response return.&quot;);\n        System.in.read();\n    }\n</code></pre>\n<p><code>CompletableFuture&lt;String&gt; future = asyncService.sayHello(&quot;async call request&quot;);</code>很自然的返回了Future示例，这样就实现了Consumer端的异步服务调用。</p>\n</li>\n</ol>\n<h2>示例2：同步接口使用Annotation Processor</h2>\n<p>这个示例演示了如何在只定义同步接口的基础上，使用Annotation Processor实现Consumer端异步方服务调用，具体代码参见地址<a href=\"https://github.com/dubbo/dubbo-samples/tree/samples-for-2.7.0-SNAPSHOT/dubbo-samples-async-generated-future\">dubbo-samples-async-generated-future</a></p>\n<ol>\n<li>\n<p>定义接口</p>\n<pre><code>@DubboAsync\npublic interface GreetingsService {\n    String sayHi(String name);\n}\n</code></pre>\n<p>这是一个普通的Dubbo服务接口定义。注意，使用Annotation Processor要加上@DubboAsync注解。</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;dubbo-async-processer&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n    &lt;version&gt;3.7.0&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;source&gt;1.8&lt;/source&gt;\n        &lt;target&gt;1.8&lt;/target&gt;\n        &lt;annotationProcessorPaths&gt;\n            &lt;path&gt;\n                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n                &lt;artifactId&gt;dubbo-async-processer&lt;/artifactId&gt;\n                &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n            &lt;/path&gt;\n        &lt;/annotationProcessorPaths&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre>\n<p>以上是引入dubbo-async-processer处理器的Maven依赖，通常定义接口（提供API）的开发者将以上依赖加到工程中，这样在做API打包的时候，API中会自动生成以下接口定义：</p>\n<pre><code>/**\n* Generated by dubbo-async-processer\n*/\npackage com.alibaba.dubbo.samples.api;\nimport java.util.concurrent.CompletableFuture;\n@javax.annotation.Generated(&quot;com.alibaba.dubbo.async.processor.AsyncAnnotationProcessor&quot;)\n@org.apache.dubbo.common.config.AsyncFor(com.alibaba.dubbo.samples.api.GreetingsService.class)\npublic interface GreetingsServiceAsync extends GreetingsService {\nCompletableFuture&lt;java.lang.String&gt; sayHiAsync(java.lang.String name);\n}\n</code></pre>\n</li>\n<li>\n<p>Provider端</p>\n<ul>\n<li>配置</li>\n</ul>\n<pre><code>&lt;bean id=&quot;greetingsService&quot; class=&quot;com.alibaba.dubbo.samples.async.impl.GreetingsServiceImpl&quot;/&gt;\n&lt;dubbo:service interface=&quot;com.alibaba.dubbo.samples.api.GreetingsService&quot; ref=&quot;greetingsService&quot;/&gt;\n</code></pre>\n<ul>\n<li>服务实现</li>\n</ul>\n<pre><code>public class GreetingsServiceImpl implements GreetingsService {\n    @Override\n    public String sayHi(String name) {\n        return &quot;hi, &quot; + name;\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>Consumer端</p>\n<ul>\n<li>配置</li>\n</ul>\n<pre><code> &lt;dubbo:reference id=&quot;greetingsService&quot; interface=&quot;com.alibaba.dubbo.samples.api.GreetingsServiceAsync&quot;/&gt;\n</code></pre>\n<p>注意，服务接口用的是<strong>GreetingsServiceAsync</strong></p>\n<ul>\n<li>调用服务</li>\n</ul>\n<pre><code> public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{&quot;META-INF/spring/async-consumer.xml&quot;});\n        context.start();\n\n        GreetingsServiceAsync greetingsService = (GreetingsServiceAsync) context.getBean(&quot;greetingsService&quot;);\n        CompletableFuture&lt;String&gt; future = greetingsService.sayHiAsync(&quot;async call reqeust&quot;);\n        System.out.println(&quot;async call ret :&quot; + future.get());\n     \n        System.in.read();\n    }\n</code></pre>\n<p>这样，我们就可以直接使用<code>CompletableFuture&lt;String&gt; future = greetingsService.sayHiAsync(&quot;async call reqeust&quot;);</code>，直接返回CompletableFuture。</p>\n</li>\n</ol>\n<h2>示例3：使用AsyncContext</h2>\n<p>本示例演示了如何在同步接口的基础上，通过AsyncContext实现Provider端异步执行，示例代码参见<a href=\"https://github.com/dubbo/dubbo-samples/tree/samples-for-2.7.0-SNAPSHOT/dubbo-samples-async-provider\">dubbo-samples-async-provider</a>。</p>\n<ol>\n<li>\n<p>定义接口</p>\n<pre><code>public interface AsyncService {\n    String sayHello(String name);\n}\n</code></pre>\n</li>\n<li>\n<p>Provider端</p>\n<ul>\n<li>配置</li>\n</ul>\n<pre><code>&lt;bean id=&quot;asyncService&quot; class=&quot;com.alibaba.dubbo.samples.async.impl.AsyncServiceImpl&quot;/&gt;\n&lt;dubbo:service async=&quot;true&quot; interface=&quot;com.alibaba.dubbo.samples.async.api.AsyncService&quot; ref=&quot;asyncService&quot;/&gt;\n</code></pre>\n<p>注意，要加上<code>async=&quot;true&quot;</code>表明这是一个开启Provider端异步执行的服务。</p>\n<ul>\n<li>异步执行实现</li>\n</ul>\n<pre><code>public class AsyncServiceImpl implements AsyncService {\n    public String sayHello(String name) {\n        final AsyncContext asyncContext = RpcContext.startAsync();\n        new Thread(() -&gt; {\n            asyncContext.signalContextSwitch();\n            try {\n                Thread.sleep(500);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            asyncContext.write(&quot;Hello &quot; + name + &quot;, response from provider.&quot;);\n        }).start();\n        return null;\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>Consumer端</p>\n<ul>\n<li>配置</li>\n</ul>\n<pre><code>&lt;dubbo:reference id=&quot;asyncService&quot; interface=&quot;com.alibaba.dubbo.samples.async.api.AsyncService&quot;/&gt;\n</code></pre>\n<ul>\n<li>服务调用</li>\n</ul>\n<pre><code> public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{&quot;META-INF/spring/async-consumer.xml&quot;});\n        context.start();\n\n        AsyncService asyncService = (AsyncService) context.getBean(&quot;asyncService&quot;);\n        System.out.println(asyncService.sayHello(&quot;async call request&quot;));\n     \n        System.in.read();\n    }\n</code></pre>\n</li>\n</ol>\n<h2>异步引入的新问题</h2>\n<h3>Filter链</h3>\n<p>以下是一次普通Dubbo调用的完整Filter链</p>\n<p>而采用异步调用后，由于异步结果在异步线程中单独执行，所以流经后半段Filter链的Result是空值，当真正的结果返回时已无法被Filter链处理。</p>\n<p>为了解决这个问题，2.7.0中引入了PostProcessFilter和AbstractPostProcessFilter，其中，PostProcessFilter接口继承自Filter接口，AbstractPostProcessFilter是PostProcessFilter的抽象实现。</p>\n<p>以下是一个扩展Filter并支持异步Filter链的例子</p>\n<pre><code>@Activate(group = {Constants.PROVIDER, Constants.CONSUMER})\npublic class AsyncPostprocessFilter extends AbstractPostProcessFilter {\n\n    @Override\n    public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException {\n        return postProcessResult(invoker.invoke(invocation), invoker, invocation);\n    }\n\n    @Override\n    protected Result doPostProcess(Result result, Invoker&lt;?&gt; invoker, Invocation invocation) {\n        System.out.println(&quot;Filter get the return value: &quot; + result.getValue());\n        return result;\n    }\n}\n</code></pre>\n<h3>上下文传递</h3>\n<p>当前我们考虑的上下文主要是指保存在RpcContext中的数据，大多数场景是需要用户在切换业务线程前自己完成Context的传递。</p>\n<pre><code>public class AsyncServiceImpl implements AsyncService {\n    // 保存当前线程的上下文\n    RpcContext context = RpcContext.getContext();\n    public CompletableFuture&lt;String&gt; sayHello(String name) {\n        return CompletableFuture.supplyAsync(() -&gt; {\n            // 设置到新线程中\n            RpcContext.setContext(context);\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return &quot;async response from provider.&quot;;\n        });\n    }\n}\n</code></pre>\n<p>不过AsyncContext也提供了signalContextSwitch()的方法来实现方便的Context切换。</p>\n<pre><code>public class AsyncServiceImpl implements AsyncService {\n    public String sayHello(String name) {\n        final AsyncContext asyncContext = RpcContext.startAsync();\n        new Thread(() -&gt; {\n            asyncContext.signalContextSwitch();\n            try {\n                Thread.sleep(500);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            asyncContext.write(&quot;Hello &quot; + name + &quot;, response from provider.&quot;);\n        }).start();\n        return null;\n    }\n}\n</code></pre>\n"
}