{
  "filename": "first-dubbo-filter.md",
  "__html": "<h1>第一个Dubbo Filter</h1>\n<h3>概述</h3>\n<p>在Dubbo的整体设计中，Filter是一个很重要的概念，包括Dubbo本身的大多数功能，都是基于此扩展点实现的，在每次的调用过程中，Filter的拦截都会被执行。</p>\n<h4>Dubbo Filter的加载机制</h4>\n<p>Dubbo中已经实现的Filter大概有二十几个，它们的入口都是ProtocolFilterWrapper，ProtocolFilterWrapper对Protocol做了Wrapper，会在加载扩展的时候被加载进来，下面我们来看下然后我们看一下这个Filter链是如何构造的。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">//ProtocolFilterWrapper.java</span>\n<span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">refer</span><span class=\"hljs-params\">(Class&lt;T&gt; type, URL url)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n        <span class=\"hljs-keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n            <span class=\"hljs-keyword\">return</span> protocol.refer(type, url);\n        }\n        <span class=\"hljs-keyword\">return</span> buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);\n    }\n    \n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">buildInvokerChain</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>{\n        Invoker&lt;T&gt; last = invoker;\n        List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);\n        <span class=\"hljs-keyword\">if</span> (filters.size() &gt; <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = filters.size() - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i --) {\n                <span class=\"hljs-keyword\">final</span> Filter filter = filters.get(i);\n                <span class=\"hljs-keyword\">final</span> Invoker&lt;T&gt; next = last;\n                last = <span class=\"hljs-keyword\">new</span> Invoker&lt;T&gt;() {\n\n                    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Class&lt;T&gt; <span class=\"hljs-title\">getInterface</span><span class=\"hljs-params\">()</span> </span>{\n                        <span class=\"hljs-keyword\">return</span> invoker.getInterface();\n                    }\n\n                    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> URL <span class=\"hljs-title\">getUrl</span><span class=\"hljs-params\">()</span> </span>{\n                        <span class=\"hljs-keyword\">return</span> invoker.getUrl();\n                    }\n\n                    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isAvailable</span><span class=\"hljs-params\">()</span> </span>{\n                        <span class=\"hljs-keyword\">return</span> invoker.isAvailable();\n                    }\n\n                    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Result <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n                        <span class=\"hljs-keyword\">return</span> filter.invoke(next, invocation);\n                    }\n\n                    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">()</span> </span>{\n                        invoker.destroy();\n                    }\n\n                    <span class=\"hljs-meta\">@Override</span>\n                    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">()</span> </span>{\n                        <span class=\"hljs-keyword\">return</span> invoker.toString();\n                    }\n                };\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> last;\n    }\n\n</code></pre>\n<h4>Dubbo Filter的激活机制</h4>\n<p>通过上述代码我们可以看到，在<code>buildInvokerChain</code>中,先获取所有已经激活的调用链，这里的调用链是已经排好序的。再通过Invoker来构造出一个Filter的调用链，最后构建出的调用链大致可以表示为：Filter1-&gt;Filter2-&gt;Filter3-&gt;......-&gt;Invoker,下面我们来看一下，第一步中获取已经激活的调用链的详细流程：</p>\n<pre><code class=\"language-java\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> List&lt;T&gt; <span class=\"hljs-title\">getActivateExtension</span><span class=\"hljs-params\">(URL url, String key, String group)</span> </span>{\n        String value = url.getParameter(key);\n        <span class=\"hljs-keyword\">return</span> getActivateExtension(url, value == <span class=\"hljs-keyword\">null</span> || value.length() == <span class=\"hljs-number\">0</span> ? <span class=\"hljs-keyword\">null</span> : Constants.COMMA_SPLIT_PATTERN.split(value), group);\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> List&lt;T&gt; <span class=\"hljs-title\">getActivateExtension</span><span class=\"hljs-params\">(URL url, String[] values, String group)</span> </span>{\n        List&lt;T&gt; exts = <span class=\"hljs-keyword\">new</span> ArrayList&lt;T&gt;();\n        \n        List&lt;String&gt; names = values == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-keyword\">new</span> ArrayList&lt;String&gt;(<span class=\"hljs-number\">0</span>) : Arrays.asList(values);\n\n        <span class=\"hljs-keyword\">if</span> (! names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) {\n            getExtensionClasses();\n            <span class=\"hljs-keyword\">for</span> (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) {\n                String name = entry.getKey();\n                Activate activate = entry.getValue();\n                <span class=\"hljs-keyword\">if</span> (isMatchGroup(group, activate.group())) {\n                    T ext = getExtension(name);\n                    <span class=\"hljs-keyword\">if</span> (! names.contains(name) &amp;&amp; ! names.contains(Constants.REMOVE_VALUE_PREFIX + name) \n                            &amp;&amp; isActive(activate, url)) {\n                        exts.add(ext);\n                    }\n                }\n            }\n            Collections.sort(exts, ActivateComparator.COMPARATOR);\n        }\n        List&lt;T&gt; usrs = <span class=\"hljs-keyword\">new</span> ArrayList&lt;T&gt;();\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; names.size(); i ++) {\n            String name = names.get(i);\n            <span class=\"hljs-keyword\">if</span> (! name.startsWith(Constants.REMOVE_VALUE_PREFIX)\n                    &amp;&amp; ! names.contains(Constants.REMOVE_VALUE_PREFIX + name)) {\n                           <span class=\"hljs-keyword\">if</span> (Constants.DEFAULT_KEY.equals(name)) {\n                    <span class=\"hljs-keyword\">if</span> (usrs.size() &gt; <span class=\"hljs-number\">0</span>) {\n                        exts.addAll(<span class=\"hljs-number\">0</span>, usrs);\n                        usrs.clear();\n                    }\n                } <span class=\"hljs-keyword\">else</span> {\n                    T ext = getExtension(name);\n                    usrs.add(ext);\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">if</span> (usrs.size() &gt; <span class=\"hljs-number\">0</span>) {\n            exts.addAll(usrs);\n        }\n        <span class=\"hljs-keyword\">return</span> exts;\n    }\n</code></pre>\n<p>通过以上代码可以看到，用户自己配置的Filter中，有些是默认激活，有些是需要通过配置文件来激活。而所有Filter的加载顺序，也是先处理Dubbo的默认Filter，再来处理用户自己定义并且配置的Filter。通过&quot;-&quot;配置，可以替换掉Dubbo的原生Filter，通过这样的设计，可以灵活地替换或者修改Filter的加载顺序。</p>\n<h4>Dubbo原生的Filter</h4>\n<p>Dubbo原生的Filter很多，RpcContext，accesslog等功能都可以通过Dubbo来实现，下面我们来介绍一下Consumer端用于上下文传递的ConsumerContextFilter：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Result <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n        RpcContext.getContext()\n                .setInvoker(invoker)\n                .setInvocation(invocation)\n                .setLocalAddress(NetUtils.getLocalHost(), <span class=\"hljs-number\">0</span>)\n                .setRemoteAddress(invoker.getUrl().getHost(), \n                                  invoker.getUrl().getPort());\n        <span class=\"hljs-keyword\">if</span> (invocation <span class=\"hljs-keyword\">instanceof</span> RpcInvocation) {\n            ((RpcInvocation)invocation).setInvoker(invoker);\n        }\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">return</span> invoker.invoke(invocation);\n        } <span class=\"hljs-keyword\">finally</span> {\n            RpcContext.getContext().clearAttachments();\n        }\n    }\n</code></pre>\n<p>此Filter记录了调用过程中的状态信息，并且通过invocation对象将客户端设置的attachments参数传递到服务端。并且在调用完成后清除这些参数，这就是为什么请求状态信息可以按次记录并且进行传递。</p>\n<h4>实现一个Dubbo Filter</h4>\n<p>得益于Dubbo灵活的设计和良好的可扩展性，我们可以通过实现自己的Dubbo Filter来完成调用链路中的逻辑嵌入，比如，耗时统计，monitor信息统计等，下面我们来实现一个简单的Filter:</p>\n<p>Maven 项目结构：</p>\n<pre><code>src\n |-main\n    |-java\n        |-com\n            |-xxx\n                |-XxxFilter.java (实现Filter接口)\n    |-resources\n        |-META-INF\n            |-dubbo\n                |-com.alibaba.dubbo.rpc.Filter (纯文本文件，内容为：xxx=com.xxx.XxxFilter)\n</code></pre>\n<p>XxxFilter.java：</p>\n<pre><code>public class XxxFilter implements Filter {\n    public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException {\n        // before filter ...\n        Result result = invoker.invoke(invocation);\n        // after filter ...\n        return result;\n    }\n}\n</code></pre>\n<p>META-INF/dubbo/com.alibaba.dubbo.rpc.Filter：</p>\n<pre><code>xxx=com.xxx.XxxFilter\n</code></pre>\n<p>在before和after中，可以实现自己的业务逻辑来赋予改filter一定的功能。编写和配置完成后，该filter就会被Dubbo框架激活并且在调用链中执行。</p>\n",
  "link": "/zh-cn/blog/first-dubbo-filter.html",
  "meta": {}
}