<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dubbo 3.0.8 源码解析 on Apache Dubbo</title><link>https://dubbo.apache.org/zh-cn/blog/java/codeanalysis/3.0.8/</link><description>Recent content in Dubbo 3.0.8 源码解析 on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://dubbo.apache.org/zh-cn/blog/java/codeanalysis/3.0.8/index.xml" rel="self" type="application/rss+xml"/><item><title>22-Dubbo3消费者自动感应决策应用级服务发现原理</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/22/22-dubbo3%E6%B6%88%E8%B4%B9%E8%80%85%E8%87%AA%E5%8A%A8%E6%84%9F%E5%BA%94%E5%86%B3%E7%AD%96%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 22 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/22/22-dubbo3%E6%B6%88%E8%B4%B9%E8%80%85%E8%87%AA%E5%8A%A8%E6%84%9F%E5%BA%94%E5%86%B3%E7%AD%96%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>22-Dubbo3消费者自动感应决策应用级服务发现原理 22.1 简介 这里要说的内容对Dubbo2迁移到Dubbo3的应用比较有帮助，消费者应用级服务发现做了一些自动决策的逻辑来决定当前消费者是应用级发现还是接口级服务发现，这里与前面说的提供者双注册的原理是对等的，提供者默认同时进行应用级注册和接口级注册，消费者对提供者注册的数据来决定使用应用级发现或者接口级发现。这些都是默认的行为，当然对于消费者来说还可以自定义其他的迁移规则，具体的需要我们详细来看逻辑。
如果说对于迁移过程比较感兴趣可以直接去官网看文档相对来说还是比较清晰:https://dubbo.apache.org/zh-cn/docs/migration/migration-service-discovery/
这里再借官网的图来用用，迁移过程主要如下所示： 第一个图是提供者双注册的图： 第二个图是消费者订阅决策的图： 第三个图就是精确到消费者订阅的代码层的逻辑了，消费者服务间调用通过一个Invoker类型对象来进行对象，如下图所示消费者代理对象通过创建一个迁移容错的调用器对象来对应用级或者接口级订阅进行适配如下所示 第二个图和第三个图是重点要关注的这一个文章的内容主要就是说这里的逻辑。
关于代码位置如果不知道是如何调用到这一块逻辑的可以查看博文《21-Dubbo3消费者引用服务入口》
这里直接将代码位置定位到：RegistryProtocol类型的interceptInvoker方法中： 如下所示：
RegistryProtocol类型的interceptInvoker方法
protected &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; interceptInvoker(ClusterInvoker&amp;lt;T&amp;gt; invoker, URL url, URL consumerUrl) { //目前存在的扩展类型为RegistryProtocolListener监听器的实现类型MigrationRuleListener List&amp;lt;RegistryProtocolListener&amp;gt; listeners = findRegistryProtocolListeners(url); if (CollectionUtils.isEmpty(listeners)) { return invoker; } for (RegistryProtocolListener listener : listeners) { listener.onRefer(this, invoker, consumerUrl, url); } return invoker; } 该方法尝试加载所有RegistryProtocolListener定义，这些定义通过与定义的交互来控制调用器的行为，然后使用这些侦听器更改MigrationInvoker的状态和行为。当前可用的监听器是MigrationRuleListener，用于通过动态变化的规则控制迁移行为。
22.2 MigrationRuleListener 类型的onRefer方法 直接来看代码：
@Override public void onRefer(RegistryProtocol registryProtocol, ClusterInvoker&amp;lt;?&amp;gt; invoker, URL consumerUrl, URL registryURL) { //创建一个对应invoker对象的MigrationRuleHandler类型对象 然后将其存放在缓存Map&amp;lt;MigrationInvoker, MigrationRuleHandler&amp;gt;类型对象handles中 MigrationRuleHandler&amp;lt;?&amp;gt; migrationRuleHandler = handlers.</description></item><item><title>21-Dubbo3消费者引用服务入口</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/21/21-dubbo3%E6%B6%88%E8%B4%B9%E8%80%85%E5%BC%95%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%85%A5%E5%8F%A3/</link><pubDate>Sun, 21 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/21/21-dubbo3%E6%B6%88%E8%B4%B9%E8%80%85%E5%BC%95%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%85%A5%E5%8F%A3/</guid><description>21-Dubbo3消费者引用服务入口 21.1 简介 前面我们通过Demo说了一个服务引用配置的创建。另外也在前面的文章说了服务提供者的启动完整过程，不过在说服务提供者启动的过程中并未提到服务消费者是如何发现服务，如果调用服务的，这里先就不再说关于服务消费者启动的一个细节了，直接来看前面未提到的服务消费者是如何引用到服务提供者提供的服务的。 先来回顾下样例代码：
public class ConsumerApplication { public static void main(String[] args) { runWithBootstrap(); } private static void runWithBootstrap() { ReferenceConfig&amp;lt;DemoService&amp;gt; reference = new ReferenceConfig&amp;lt;&amp;gt;(); reference.setInterface(DemoService.class); reference.setGeneric(&amp;#34;true&amp;#34;); reference.setProtocol(&amp;#34;&amp;#34;); DubboBootstrap bootstrap = DubboBootstrap.getInstance(); ApplicationConfig applicationConfig = new ApplicationConfig(&amp;#34;dubbo-demo-api-consumer&amp;#34;); applicationConfig.setQosEnable(false); applicationConfig.setQosPort(-1); bootstrap.application(applicationConfig) .registry(new RegistryConfig(&amp;#34;zookeeper://8.131.79.126:2181&amp;#34;)) .protocol(new ProtocolConfig(CommonConstants.DUBBO, -1)) .reference(reference) .start(); DemoService demoService = bootstrap.getCache().get(reference); String message = demoService.sayHello(&amp;#34;dubbo&amp;#34;); System.out.println(message); // generic invoke GenericService genericService = (GenericService) demoService; Object genericInvokeResult = genericService.$invoke(&amp;#34;sayHello&amp;#34;, new String[]{String.</description></item><item><title>20-Dubbo3服务引用配置ReferenceConfig</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/20/20-dubbo3%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8%E9%85%8D%E7%BD%AEreferenceconfig/</link><pubDate>Sat, 20 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/20/20-dubbo3%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8%E9%85%8D%E7%BD%AEreferenceconfig/</guid><description>20-Dubbo3服务引用配置ReferenceConfig 20.1 简介 前面简单介绍了一下消费者的例子，消费者创建的第一步就是先进行消费者信息的配置对应类型为ReferenceConfig，这里详细来看ReferenceConfig包含哪些信息？先简单了解下消费者配置的类型关系如下图所示：引用配置与服务配置类型都是通过继承接口配置来扩展的，在分析生产者的时候详细介绍过服务相关的配置，这里来详细看消费者引用者的相关配置信息. 前面例子说了消费者配置对象的创建主要是通过如下代码：
ReferenceConfig&amp;lt;DemoService&amp;gt; reference = new ReferenceConfig&amp;lt;&amp;gt;(); 这个配置类型的对象创建过程并没有太多的逻辑这里主要来说下各种配置信息： 服务消费者引用服务配置。对应的配置类： org.apache.dubbo.config.ReferenceConfig
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 id string 必填 配置关联 服务引用BeanId 1.0.0以上版本 interface class 必填 服务发现 服务接口名 1.0.0以上版本 version version string 可选 服务发现 服务版本，与服务提供者的版本一致 1.0.0以上版本 group group string 可选 服务发现 服务分组，当一个接口有多个实现，可以用分组区分，必需和服务提供方一致 1.0.7以上版本 timeout timeout long 可选 缺省使用dubbo:consumer的timeout 性能调优 服务方法调用超时时间(毫秒) 1.0.5以上版本 retries retries int 可选 缺省使用dubbo:consumer的retries 性能调优 远程服务调用重试次数，不包括第一次调用，不需要重试请设为0 2.0.0以上版本 connections connections int 可选 缺省使用dubbo:consumer的connections 性能调优 对每个提供者的最大连接数，rmi、http、hessian等短连接协议表示限制连接数，dubbo等长连接协表示建立的长连接个数 2.</description></item><item><title>19 重新来过从一个服务消费者的Demo说起</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/19/19-%E9%87%8D%E6%96%B0%E6%9D%A5%E8%BF%87%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84demo%E8%AF%B4%E8%B5%B7/</link><pubDate>Fri, 19 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/19/19-%E9%87%8D%E6%96%B0%E6%9D%A5%E8%BF%87%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84demo%E8%AF%B4%E8%B5%B7/</guid><description>19 重新来过从一个服务消费者的Demo说起 为了更方便了解原理,我们先来编写一个Demo,从例子中来看源码实现:，前面说了提供者现在已经有服务注册上去了，那接下来我们编写一个消费者的例子来进行服务发现与服务RPC调用。
19.1 启动Zookeeper 为了Demo可以正常启动,需要我们先在本地启动一个Zookeeper如下图所示: 19.2 服务消费者 接下来给大家贴一下示例源码,这个源码来源于Dubbo源码目录的	dubbo-demo/dubbo-demo-api 目录下面的dubbo-demo-api-consumer子项目,这里我做了删减,方便看核心代码: 首先我们定义一个服务接口如下所示:
import java.util.concurrent.CompletableFuture; public interface DemoService { /** * 同步处理的服务方法 * @param name * @return */ String sayHello(String name); /** * 用于异步处理的服务方法 * @param name * @return */ default CompletableFuture&amp;lt;String&amp;gt; sayHelloAsync(String name) { return CompletableFuture.completedFuture(sayHello(name)); } } 服务实现类如下: import org.apache.dubbo.rpc.RpcContext; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.util.concurrent.CompletableFuture; public class DemoServiceImpl implements DemoService { private static final Logger logger = LoggerFactory.getLogger(DemoServiceImpl.class); @Override public String sayHello(String name) { logger.</description></item><item><title>18-Dubbo3元数据服务MetadataService的导出</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/18/18-dubbo3%E5%85%83%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1metadataservice%E7%9A%84%E5%AF%BC%E5%87%BA/</link><pubDate>Thu, 18 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/18/18-dubbo3%E5%85%83%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1metadataservice%E7%9A%84%E5%AF%BC%E5%87%BA/</guid><description>18-Dubbo3元数据服务MetadataService的导出 18.1 简介 MetadataService 此服务用于公开Dubbo进程内的元数据信息。典型用途包括：
使用者查询提供者的元数据信息，以列出接口和每个接口的配置 控制台（dubbo admin）查询特定进程的元数据，或聚合所有进程的数据。在Dubbo2.x的时候，所有的服务数据都是以接口的形式注册在注册中心. Dubbo3将部分数据抽象为元数据的形式来将数据存放在元数据中心，然后元数据由服务提供者提供给消费者而不是再由注册中心进行推送，如下图所示：
引入 MetadataService 元数据服务服务的好处 • 由中心化推送转向点对点拉取（Consumer - Proroder） • 易于扩展更多的参数 • 更多的数据量 • 对外暴露更多的治理数据
18.2 MetadataService的导出过程 了解元数据的到处过程，这个就要继续前面博客往后的代码了前面博客说了一个服务发布之后的服务信息的双注册数据，这里继续看下导出服务之后的代码： 先来简单回顾下模块发布的启动生命周期方法：
DefaultModuleDeployer类型的start方法：
@Override public synchronized Future start() throws IllegalStateException { ... try { ... onModuleStarting(); // initialize applicationDeployer.initialize(); initialize(); // export services exportServices(); // prepare application instance // exclude internal module to avoid wait itself if (moduleModel != moduleModel.getApplicationModel().getInternalModule()) { applicationDeployer.prepareInternalModule(); } // refer services referServices(); // if no async export/refer services, just set started if (asyncExportingFutures.</description></item><item><title>17-Dubbo服务提供者的双注册原理</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/17/17-dubbo%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E7%9A%84%E5%8F%8C%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86/</link><pubDate>Wed, 17 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/17/17-dubbo%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E7%9A%84%E5%8F%8C%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86/</guid><description>17-Dubbo服务提供者的双注册原理 17.1 简介 上个博客《15-Dubbo的三大中心之元数据中心源码解析》导出服务端的时候多次提到了元数据中心，注册信息的注册。 Dubbo3出来时间不太长，对于现在的用户来说大部分使用的仍旧是Dubbo2.x， Dubbo3 比较有特色也是会直接使用到的功能就是应用级服务发现：
应用级服务发现 从服务/接口粒度到应用粒度的升级，使得 Dubbo 在集群可伸缩性、连接异构微服务体系上更具优势。应用粒度能以更低的资源消耗支持超百万实例规模集群程； 实现与 Spring Cloud、Kubernetes Service 等异构微服务体系的互联互通。 对于直接使用Dubbo3的用户还好，可以仅仅开启应用级注册，但是对于Dubbo2.x的用户升级到Dubbo3的用户来说前期都是要开启双注册来慢慢迁移的，既注册传统的接口信息到注册中心，又注册应用信息到注册中心，同时注册应用与接口关系的元数据信息。 关于双注册与服务迁移的过程的使用可以参考官网： 应用级地址发现迁移指南
关于官网提供者双注册的图我这里贴一下，方便了解： 17.2 双注册配置的读取 17.2.1 注册中心地址作为元数据中心 这个配置的解析过程在前面的博客介绍元数据中心的时候很详细的说了相关链接：15-Dubbo的三大中心之元数据中心源码解析
对应代码位于：DefaultApplicationDeployer类型的startMetadataCenter()方法
private void startMetadataCenter() { //如果未配置元数据中心的地址等配置则使用注册中心的地址等配置做为元数据中心的配置 useRegistryAsMetadataCenterIfNecessary(); //...省略掉其他代码防止受到干扰 } 具体逻辑是这个方法： useRegistryAsMetadataCenterIfNecessary
private void useRegistryAsMetadataCenterIfNecessary() { //配置缓存中查询元数据配置 Collection&amp;lt;MetadataReportConfig&amp;gt; metadataConfigs = configManager.getMetadataConfigs(); //...省略掉空判断 //查询是否有注册中心设置了默认配置isDefault 设置为true的注册中心则为默认注册中心列表,如果没有注册中心设置为默认注册中心,则获取所有未设置默认配置的注册中心列表 List&amp;lt;RegistryConfig&amp;gt; defaultRegistries = configManager.getDefaultRegistries(); if (defaultRegistries.size() &amp;gt; 0) { //多注册中心遍历 defaultRegistries .stream() //筛选符合条件的注册中心 (筛选逻辑就是查看是否有对应协议的扩展支持) .filter(this::isUsedRegistryAsMetadataCenter) //注册中心配置映射为元数据中心 映射就是获取需要的配置 .map(this::registryAsMetadataCenter) //将元数据中心配置存储在配置缓存中方便后续使用 .forEach(metadataReportConfig -&amp;gt; { //.</description></item><item><title>16-模块发布器发布服务全过程</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/16/16-%E6%A8%A1%E5%9D%97%E5%8F%91%E5%B8%83%E5%99%A8%E5%8F%91%E5%B8%83%E6%9C%8D%E5%8A%A1%E5%85%A8%E8%BF%87%E7%A8%8B/</link><pubDate>Tue, 16 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/16/16-%E6%A8%A1%E5%9D%97%E5%8F%91%E5%B8%83%E5%99%A8%E5%8F%91%E5%B8%83%E6%9C%8D%E5%8A%A1%E5%85%A8%E8%BF%87%E7%A8%8B/</guid><description>16-模块发布器发布服务全过程 16.1 简介 Dubbo做为服务治理框架,比较核心的就是服务相关的概念,这里我先贴个找到的关于Dubbo工作原理的架构图: 如果按完整服务启动与订阅的顺序我们可以归结为以下6点:
导出服务(提供者) 服务提供方通过指定端口对外暴露服务 注册服务(提供者) 提供方向注册中心注册自己的信息 (服务发现)-订阅服务(消费者) 服务调用方通过注册中心订阅自己感兴趣的服务 (服务发现)-服务推送(消费者) 注册中心向调用方推送地址列表 调用服务(消费者调用提供者) 调用方选择一个地址发起RPC调用 监控服务 服务提供方和调用方的统计数据由监控模块收集展示 上面的完整的服务启动订阅与调用流程不仅仅适用于Dubbo 同样也适用于其他服务治理与发现的模型, 一般服务发现与服务调用的思路就是这样的,我们将以上内容扩展,暴漏服务可以使用http,tcp,udp等各种协议,注册服务可以注册到Redis,Dns,Etcd,Zookeeper等注册中心中,订阅服务可以主动去注册中心查询服务列表,服务发现可以让注册中心将服务数据动态推送给消费者.Dubbo其实就是基于这种简单的服务模型来扩展出各种功能的支持,来满足服务治理的各种场景,了解了这里可能各位同学就想着自行开发一个简单的微服务框架了。
回到主题,从以上的服务完整发布调用流程可以看到,所有的功能都是由导出服务(提供者)开始的,只有提供者先提供了服务才可以有真正的服务让消费者调用。
之前的博客内容 链接:&amp;laquo;12-全局视野来看Dubbo3.0.8的服务启动生命周期&amp;raquo; 我们了解了 DefaultModuleDeployer模块器启动的流程,其中在start代码的模版方法中开始了导出服务的功能,这里我们来详细看下服务发布的全过程:
入口代码: DefaultModuleDeployer的发布服务方法
private void exportServices() { //从配置管缓存中查询缓存的所有的服务配置然后逐个服务发布 for (ServiceConfigBase sc : configManager.getServices()) { exportServiceInternal(sc); } } 16.2 导出服务的入口 入口代码: DefaultModuleDeployer的发布服务方法
private void exportServices() { //从配置管缓存中查询缓存的所有的服务配置然后逐个服务发布 for (ServiceConfigBase sc : configManager.getServices()) { exportServiceInternal(sc); } } 主要流程为遍历初始化的服务配置列表然后逐个服务开始到处 内部导出服务代码: exportServiceInternal方法:
private void exportServiceInternal(ServiceConfigBase sc) { ServiceConfig&amp;lt;?&amp;gt; serviceConfig = (ServiceConfig&amp;lt;?</description></item><item><title>15-Dubbo的三大中心之元数据中心源码解析</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/15/15-dubbo%E7%9A%84%E4%B8%89%E5%A4%A7%E4%B8%AD%E5%BF%83%E4%B9%8B%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 15 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/15/15-dubbo%E7%9A%84%E4%B8%89%E5%A4%A7%E4%B8%AD%E5%BF%83%E4%B9%8B%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>15-Dubbo的三大中心之元数据中心源码解析 15.1 简介 关于元数据中心的概念对于大部分用户来说是比较陌生的,配置中心的话我们还好理解,对于元数据中心是什么,我们来看下我从官网拷贝过来的一段文字:
元数据中心在2.7.x版本开始支持，随着应用级别的服务注册和服务发现在Dubbo中落地，元数据中心也变的越来越重要。在以下几种情况下会需要部署元数据中心：
对于一个原先采用老版本Dubbo搭建的应用服务，在迁移到Dubbo 3时，Dubbo 3 会需要一个元数据中心来维护RPC服务与应用的映射关系（即接口与应用的映射关系），因为如果采用了应用级别的服务发现和服务注册，在注册中心中将采用“应用 —— 实例列表”结构的数据组织形式，不再是以往的“接口 —— 实例列表”结构的数据组织形式，而以往用接口级别的服务注册和服务发现的应用服务在迁移到应用级别时，得不到接口与应用之间的对应关系，从而无法从注册中心得到实例列表信息，所以Dubbo为了兼容这种场景，在Provider端启动时，会往元数据中心存储接口与应用的映射关系。 为了让注册中心更加聚焦与地址的发现和推送能力，减轻注册中心的负担，元数据中心承载了所有的服务元数据、大量接口/方法级别配置信息等，无论是接口粒度还是应用粒度的服务发现和注册，元数据中心都起到了重要的作用。 如果有以上两种需求，都可以选择部署元数据中心，并通过Dubbo的配置来集成该元数据中心。 元数据中心并不依赖于注册中心和配置中心，用户可以自由选择是否集成和部署元数据中心，如下图所示：
该图中不配备配置中心，意味着可以不需要全局管理配置的能力。该图中不配备注册中心，意味着可能采用了Dubbo mesh的方案，也可能不需要进行服务注册，仅仅接收直连模式的服务调用。 官网参考文章地址:
部署架构（注册中心 配置中心 元数据中心 元数据参考手册 综上所述可以用几句话概括下:
元数据中心来维护RPC服务与应用的映射关系（即接口与应用的映射关系）来兼容接口与应用之间的对应关系 让注册中心更加聚焦与地址的发现和推送能力 元数据中心的启动是在DefaultApplicationDeployer中的初始化方法 initialize() 中:如下所示
这里只看下 startMetadataCenter();方法即可
@Override public void initialize() { if (initialized) { return; } // Ensure that the initialization is completed when concurrent calls synchronized (startLock) { if (initialized) { return; } // register shutdown hook registerShutdownHook(); startConfigCenter(); loadApplicationConfigs(); initModuleDeployers(); // @since 2.7.8 startMetadataCenter(); initialized = true; if (logger.</description></item><item><title>14-Dubbo配置加载全解析</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/14/14-dubbo%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%A7%A3%E6%9E%90/</link><pubDate>Sun, 14 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/14/14-dubbo%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%A7%A3%E6%9E%90/</guid><description>14-Dubbo配置加载全解析 14.1 回到启动器的初始化过程 在应用程序启动的时候会调用发布器的启动方法 ,然后调用初始化方法,在发布器DefaultApplicationDeployer中的初始化方法initialize() 如下:
@Override public void initialize() { if (initialized) { return; } // Ensure that the initialization is completed when concurrent calls synchronized (startLock) { if (initialized) { return; } // register shutdown hook registerShutdownHook(); startConfigCenter(); loadApplicationConfigs(); initModuleDeployers(); // @since 2.7.8 startMetadataCenter(); initialized = true; if (logger.isInfoEnabled()) { logger.info(getIdentifier() + &amp;#34; has been initialized!&amp;#34;); } } } 初始化过程中会先启动配置中心配置信息处理,然后 调用加载初始化应用程序配置方法loadApplicationConfigs();进行配置加载 关于配置的官方文档链接为 配置概述
Dubbo框架的配置项比较繁多，为了更好地管理各种配置，将其按照用途划分为不同的组件，最终所有配置项都会汇聚到URL中，传递给后续处理模块。
常用配置组件如下：
application: Dubbo应用配置 registry: 注册中心 protocol: 服务提供者RPC协议 config-center: 配置中心 metadata-report: 元数据中心 service: 服务提供者配置 reference: 远程服务引用配置 provider: service的默认配置或分组配置 consumer: reference的默认配置或分组配置 module: 模块配置 monitor: 监控配置 metrics: 指标配置 ssl: SSL/TLS配置 配置还有几个比较重要的点:</description></item><item><title>13-Dubbo的三大中心之配置中心</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/13/13-dubbo%E7%9A%84%E4%B8%89%E5%A4%A7%E4%B8%AD%E5%BF%83%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</link><pubDate>Sat, 13 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/13/13-dubbo%E7%9A%84%E4%B8%89%E5%A4%A7%E4%B8%AD%E5%BF%83%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</guid><description>13-Dubbo的三大中心之配置中心 13.1 配置中心简介 百度了一段不错的文字来介绍配置中心，我看了下肯定比我写的好多了，那我就直接拷贝过来一起看：
对于传统的单体应用而言，常使用配置文件来管理所有配置，比如SpringBoot的application.yml文件，但是在微服务架构中全部手动修改的话很麻烦而且不易维护。微服务的配置管理一般有以下需求：
集中配置管理，一个微服务架构中可能有成百上千个微服务，所以集中配置管理是很重要的。 不同环境不同配置，比如数据源配置在不同环境（开发，生产，测试）中是不同的。 运行期间可动态调整。例如，可根据各个微服务的负载情况，动态调整数据源连接池大小等。 配置修改后可自动更新。如配置内容发生变化，微服务可以自动更新配置。 综上所述对于微服务架构而言，一套统一的，通用的管理配置机制是不可缺少的主要组成部分。常见的做法就是通过配置服务器进行管理。
不过对于来看这个文章的小伙伴应该大部分对配置中心都会比较了解，分布式配置中心实现简单一点就是借助Zookeeper来协助存储，变更推送，不过为了实现各种不同的业务需求，市面上已经有很多很可靠的配置中心可用了，比如我从其他地方拷贝过来的图（虽然不是最新的但是可以供大家参考下）：
每个配置中心都有自己的实现，如果对配置中心感兴趣的小伙伴可以自行去对应开源项目官网查看，我们这里来看Dubbo对配置中心的支持
多配置中心： Dubbo支持多配置中心，来 保证其中一个配置中心集群出现不可用时能够切换到另一个配置中心集群 ，保证能够正常从配置中心获取全局的配置、路由规则等信息。这也能够满足配置中心在部署上适应各类高可用的部署架构模式。-来自官网
做中间件可能考虑更多的的不仅仅是性能，还要过多的考虑高可用，高可用怎么做呢，其实就是失效转移，主备切换，降级，降级再降级这些理论的运用，多多考虑某一个服务挂了怎么办，Dubbo的多配置中心支持增加了复杂性，不过降低了服务不可用的风险，有一定的人手的公司还是值得做的。
关于Dubbo的配置中心这里我来贴个官网的图: 关于官网的介绍可以自行去官网看详细内容: 部署架构(注册中心、配置中心、元数据中心
13.2 启动配置中心 在上一个博客中说到了《12-全局视野来看Dubbo3.0.8的服务启动生命周期》Dubbo应用的启动过程DefaultApplicationDeployer的initialize()方法的全生命周期，在初始化方法中通过调用startConfigCenter();方法来启动配置中心的加载。后面就来详细看下：
DefaultApplicationDeployer类型的startConfigCenter()代码如下：
private void startConfigCenter() { // load application config //加载应用程序配置 （配置可能有多个地方可以配置需要遵循Dubbo约定的优先级进行设置，也可能是多应用，多注册中心这样的配置） configManager.loadConfigsOfTypeFromProps(ApplicationConfig.class); // try set model name if (StringUtils.isBlank(applicationModel.getModelName())) { //设置一下模块名字和模块描述（我们再Debug里面经常会看到这个描述信息 toString直接返回了Dubbo为我们改造的对象信息） applicationModel.setModelName(applicationModel.tryGetApplicationName()); } // load config centers //加载配置中心配置 //配置可能有多个地方可以配置需要遵循Dubbo约定的优先级进行设置，也可能是多应用，多注册中心这样的配置） configManager.loadConfigsOfTypeFromProps(ConfigCenterConfig.class); //出于兼容性目的，如果没有明确指定配置中心，并且registryConfig的UseAConfigCenter为null或true，请使用registry作为默认配置中心 useRegistryAsConfigCenterIfNecessary(); // check Config Center //配置管理器中获取配置中心 Collection&amp;lt;ConfigCenterConfig&amp;gt; configCenters = configManager.getConfigCenters(); //配置中心配置不为空则刷新配置中心配置将其放入配置管理器中 //下面开始刷新配置中心配置,如果配置中心配置为空则执行空刷新 if (CollectionUtils.isEmpty(configCenters)) { //配置中心不存在的配置刷新 ConfigCenterConfig configCenterConfig = new ConfigCenterConfig(); configCenterConfig.</description></item><item><title>12 全局视野来看Dubbo3的服务启动生命周期</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/12/12-%E5%85%A8%E5%B1%80%E8%A7%86%E9%87%8E%E6%9D%A5%E7%9C%8Bdubbo3%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link><pubDate>Fri, 12 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/12/12-%E5%85%A8%E5%B1%80%E8%A7%86%E9%87%8E%E6%9D%A5%E7%9C%8Bdubbo3%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid><description>12 全局视野来看Dubbo3的服务启动生命周期 12.1 启动方法简介 在说启动方法之前先把视野拉回第一章《1-从一个服务提供者的Demo说起》我们的Demo代码,下面只贴一下核心代码:
public class Application { public static void main(String[] args) throws Exception { startWithBootstrap(); } private static void startWithBootstrap() { //前面的文章都在说这个服务配置对象的创建,中间又说了分层域模型,扩展加载机制 ServiceConfig&amp;lt;DemoServiceImpl&amp;gt; service = new ServiceConfig&amp;lt;&amp;gt;(); //为服务配置下服务接口和服务实现,下面两行用来初始化对象就不详细说了 service.setInterface(DemoService.class); service.setRef(new DemoServiceImpl()); //这一个篇章主要说这里: DubboBootstrap bootstrap = DubboBootstrap.getInstance(); //初始化应用配置 bootstrap.application(new ApplicationConfig(&amp;#34;dubbo-demo-api-provider&amp;#34;)) //初始化注册中心配置 .registry(new RegistryConfig(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;)) //初始化协议配置 .protocol(new ProtocolConfig(CommonConstants.DUBBO, -1)) //初始化服务配置 .service(service) //启动 .start() .await(); } } 前面我们介绍了Dubbo启动器DubboBootstrap类型对象的创建,又介绍了为DubboBootstrap启动器初始化各种配置信息,这一个博客就开始到了分析启动方法的位置了,Dubbo启动器借助Deployer发布器来启动和发布服务,发布器的启动过程包含了启动配置中心,加载配置,启动元数据中心,启动服务等操作都是比较重要又比较复杂的过程,这里我们先来看下启动过程的生命周期来为后面的内容做好铺垫。
12.2 启动器启动方法的调用逻辑start() 这里我们就直接来看DubboBootstrap的start()方法:
public DubboBootstrap start() { //调用重载的方法进行启动参数代表是否等待启动结束 this.start(true); return this; } 我们再来看重载的start方法:</description></item><item><title>11-Dubbo启动器DubboBootstrap添加协议配置信息ProtocolConfig</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/11/11-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E6%B7%BB%E5%8A%A0%E5%8D%8F%E8%AE%AE%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AFprotocolconfig/</link><pubDate>Thu, 11 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/11/11-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E6%B7%BB%E5%8A%A0%E5%8D%8F%E8%AE%AE%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AFprotocolconfig/</guid><description>11-Dubbo启动器DubboBootstrap添加协议配置信息ProtocolConfig 11.1 简介 先贴个代码用来参考:
DubboBootstrap bootstrap = DubboBootstrap.getInstance(); bootstrap.application(new ApplicationConfig(&amp;#34;dubbo-demo-api-provider&amp;#34;)) .registry(new RegistryConfig(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;)) .protocol(new ProtocolConfig(CommonConstants.DUBBO, -1)) .service(service) .start() .await(); 上个博客我们说了 RegistryConfig对象的创建,启动器对象在启动之前是要初始化一些配置信息的,这里我们来看这一行代码协议配置信息:
.protocol(new ProtocolConfig(CommonConstants.DUBBO, -1)) 11.2 协议的配置相关 下面的配置来源于官网
服务提供者协议配置。对应的配置类： org.apache.dubbo.config.ProtocolConfig。同时，如果需要支持多协议，可以声明多个 dubbo:protocol 标签，并在 dubbo:service 中通过 protocol 属性指定使用的协议。
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 id string 可选 dubbo 配置关联 协议BeanId，可以在&amp;lt;dubbo:service protocol=&amp;quot;&amp;quot;&amp;gt;中引用此ID，如果ID不填，缺省和name属性值一样，重复则在name后加序号。 2.0.5以上版本 name string 必填 dubbo 性能调优 协议名称 2.0.5以上版本 port int 可选 dubbo协议缺省端口为20880，rmi协议缺省端口为1099，http和hessian协议缺省端口为80；如果没有配置port，则自动采用默认端口，如果配置为**-1**，则会分配一个没有被占用的端口。Dubbo 2.4.0+，分配的端口在协议缺省端口的基础上增长，确保端口段可控。 服务发现 服务端口 2.0.5以上版本 host string 可选 自动查找本机IP 服务发现 -服务主机名，多网卡选择或指定VIP及域名时使用，为空则自动查找本机IP，-建议不要配置，让Dubbo自动获取本机IP 2.</description></item><item><title>10-Dubbo启动器DubboBootstrap添加注册中心配置信息RegistryConfig</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/10/10-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E6%B7%BB%E5%8A%A0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AFregistryconfig/</link><pubDate>Wed, 10 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/10/10-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E6%B7%BB%E5%8A%A0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AFregistryconfig/</guid><description>10-Dubbo启动器DubboBootstrap添加注册中心配置信息RegistryConfig 10.1 简介 先贴个代码用来参考:
DubboBootstrap bootstrap = DubboBootstrap.getInstance(); bootstrap.application(new ApplicationConfig(&amp;#34;dubbo-demo-api-provider&amp;#34;)) .registry(new RegistryConfig(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;)) .protocol(new ProtocolConfig(CommonConstants.DUBBO, -1)) .service(service) .start() .await(); 上个博客我们说了启动器ApplicationConfig对象的创建,启动器对象在启动之前是要初始化一些配置信息的,这里我们来看这一行代码注册中心配置信息:
registry(new RegistryConfig(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;)) 10.2 注册中心的配置相关 下面的配置来源于官网
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 id string 可选 配置关联 注册中心引用BeanId，可以在&amp;lt;dubbo:service registry=&amp;quot;&amp;quot;&amp;gt;或&amp;lt;dubbo:reference registry=&amp;quot;&amp;quot;&amp;gt;中引用此ID 1.0.16以上版本 address host:port string 必填 服务发现 注册中心服务器地址，如果地址没有端口缺省为9090，同一集群内的多个地址用逗号分隔，如：ip:port,ip:port，不同集群的注册中心，请配置多个dubbo:registry标签 1.0.16以上版本 protocol string 可选 dubbo 服务发现 注册中心地址协议，支持dubbo, multicast, zookeeper, redis, consul(2.7.1), sofa(2.7.2), etcd(2.7.2), nacos(2.7.2)等协议 2.0.0以上版本 port int 可选 9090 服务发现 注册中心缺省端口，当address没有带端口时使用此端口做为缺省值 2.0.0以上版本 username string 可选 服务治理 登录注册中心用户名，如果注册中心不需要验证可不填 2.</description></item><item><title>9-Dubbo启动器DubboBootstrap添加应用程序的配置信息ApplicationConfig</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/09/9-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E6%B7%BB%E5%8A%A0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AFapplicationconfig/</link><pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/09/9-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E6%B7%BB%E5%8A%A0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AFapplicationconfig/</guid><description>9-Dubbo启动器DubboBootstrap添加应用程序的配置信息ApplicationConfig 9.1 简介 先贴个代码用来参考:
DubboBootstrap bootstrap = DubboBootstrap.getInstance(); bootstrap.application(new ApplicationConfig(&amp;#34;dubbo-demo-api-provider&amp;#34;)) .registry(new RegistryConfig(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;)) .protocol(new ProtocolConfig(CommonConstants.DUBBO, -1)) .service(service) .start() .await(); 上个博客我们说了启动器对象的创建,启动器对象在启动之前是要初始化一些配置信息的,这里我们来看这一行代码:
bootstrap.application(new ApplicationConfig(&amp;#34;dubbo-demo-api-provider&amp;#34;)) 9.2 应用程序ApplicationConfig的配置信息 ApplicationConfig的构造器比较简单就是为他的成员变量name赋值来标识这个应用程序的名字 下面我们直接参考下官网的配置表格:
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 name application string 必填 服务治理 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样，此参数不是匹配条件，你当前项目叫什么名字就填什么，和提供者消费者角色无关，比如：kylin应用调用了morgan应用的服务，则kylin项目配成kylin，morgan项目配成morgan，可能kylin也提供其它服务给别人使用，但kylin项目永远配成kylin，这样注册中心将显示kylin依赖于morgan 1.0.16以上版本 version application.version string 可选 服务治理 当前应用的版本 2.2.0以上版本 owner owner string 可选 服务治理 应用负责人，用于服务治理，请填写负责人公司邮箱前缀 2.0.5以上版本 organization organization string 可选 服务治理 组织名称(BU或部门)，用于注册中心区分服务来源，此配置项建议不要使用autoconfig，直接写死在配置中，比如china,intl,itu,crm,asc,dw,aliexpress等 2.0.0以上版本 architecture architecture string 可选 服务治理 用于服务分层对应的架构。如，intl、china。不同的架构使用不同的分层。 2.0.7以上版本 environment environment string 可选 服务治理 应用环境，如：develop/test/product，不同环境使用不同的缺省值，以及作为只用于开发测试功能的限制条件 2.</description></item><item><title>8-Dubbo启动器DubboBootstrap借助双重校验锁的单例模式进行对象的初始化</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/08/8-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E5%80%9F%E5%8A%A9%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</link><pubDate>Mon, 08 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/08/8-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E5%80%9F%E5%8A%A9%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</guid><description>8-Dubbo启动器DubboBootstrap借助双重校验锁的单例模式进行对象的初始化 8.1 启动器简介 在说启动器之前先把视野拉回第一章《1-从一个服务提供者的Demo说起》我们的Demo代码,下面只贴一下核心代码:
public class Application { public static void main(String[] args) throws Exception { startWithBootstrap(); } private static void startWithBootstrap() { //前面的文章都在说这个服务配置对象的创建,中间又说了分层域模型,扩展加载机制 ServiceConfig&amp;lt;DemoServiceImpl&amp;gt; service = new ServiceConfig&amp;lt;&amp;gt;(); //为服务配置下服务接口和服务实现,下面两行用来初始化对象就不详细说了 service.setInterface(DemoService.class); service.setRef(new DemoServiceImpl()); //这一个篇章主要说这里: DubboBootstrap bootstrap = DubboBootstrap.getInstance(); bootstrap.application(new ApplicationConfig(&amp;#34;dubbo-demo-api-provider&amp;#34;)) .registry(new RegistryConfig(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;)) .protocol(new ProtocolConfig(CommonConstants.DUBBO, -1)) .service(service) .start() .await(); } } Dubbo3 往云原生的方向走自然要针对云原生应用的应用启动,应用运行,应用发布等信息做一些建模,这个DubboBootstrap就是用来启动Dubbo服务的.类似于Netty的Bootstrap类型和ServerBootstrap启动器
8.2 双重校验锁的单例模式创建启动器对象的 Dubbo的bootstrap类为啥要用单例模式:
通过调用静态方法getInstance()获取单例实例。之所以设计为单例，是因为Dubbo中的一些类（如ExtensionLoader）只为每个进程设计一个实例。
下面就来直接看代码吧,代码胜千言: 对象的调用代码如下:
DubboBootstrap bootstrap = DubboBootstrap.getInstance(); DubboBootstrap获取对象的getInstance()方法:
public static DubboBootstrap getInstance() { //双重校验锁第一次判断空 if (instance == null) { //为空都进行排队 synchronized (DubboBootstrap.</description></item><item><title>7-Dubbo的SPI扩展机制之自动激活扩展Activate源码解析</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/07/7-dubbo%E7%9A%84spi%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%BF%80%E6%B4%BB%E6%89%A9%E5%B1%95activate%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Sun, 07 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/07/7-dubbo%E7%9A%84spi%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%BF%80%E6%B4%BB%E6%89%A9%E5%B1%95activate%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>7-Dubbo的SPI扩展机制之自动激活扩展Activate源码解析 7.1 Activate扩展的说明 此注解对于使用给定条件自动激活某些扩展非常有用，例如：@Activate可用于在有多个实现时加载某些筛选器扩展。
group() 指定组条件。框架SPI定义了有效的组值。 value() 指定URL条件中的参数键。 SPI提供程序可以调用ExtensionLoader。getActivateExtension(URL、String、String)方法以查找具有给定条件的所有已激活扩展。
比如后面我们会说到的过滤器扩展对象的获取,如下通过调用getActivateExtension方法的代码:
List&amp;lt;Filter&amp;gt; filters; filters = ScopeModelUtil.getExtensionLoader(Filter.class, moduleModels.get(0)).getActivateExtension(url, key, group); 7.2 获取自动激活扩展的源码 前面我们看了激活扩展是通过调用getActivateExtension方法来获取对象的,那接下来就来看下这个方法做了什么操作:
/** * @param url 服务的url * @param key 用于获取扩展点名称的url参数键 比如监听器:exporter.listener,过滤器:params-filter,telnet处理器:telnet */ public List&amp;lt;T&amp;gt; getActivateExtension(URL url, String key) { return getActivateExtension(url, key, null); } 继续调用重载的方法
/** * * * @param url 服务的url * @param key 用于获取扩展点名称的url参数键 比如监听器:exporter.listener,过滤器:params-filter,telnet处理器:telnet * @param group group 用于筛选的分组,比如过滤器中使用此参数来区分消费者使用这个过滤器还是提供者使用这个过滤器他们的group参数分表为consumer,provider * @return 已激活的扩展列表。 */ public List&amp;lt;T&amp;gt; getActivateExtension(URL url, String key, String group) { //从参数中获取url指定的值 String value = url.</description></item><item><title>06-Dubbo的SPI扩展机制之普通扩展对象的创建与Wrapper机制的源码解析</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/06/06-dubbo%E7%9A%84spi%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%99%AE%E9%80%9A%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8Ewrapper%E6%9C%BA%E5%88%B6%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Sat, 06 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/06/06-dubbo%E7%9A%84spi%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%99%AE%E9%80%9A%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8Ewrapper%E6%9C%BA%E5%88%B6%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>6 Dubbo的SPI扩展机制之普通扩展对象的创建与Wrapper机制的源码解析 6.1 普通扩展对象的加载与创建 这里我们要分析的是ExtensionLoader类型的getExtension(String name)方法, 有了前面自适应扩展的铺垫,这里就更容易来看了getExtension是根据扩展名字获取具体扩展的通用方法,我们来根据某个类型来获取扩展的时候就是走的这里,比如在这个博客开头的介绍:
ApplicationModel中获取配置管理器对象 configManager = (ConfigManager) this.getExtensionLoader(ApplicationExt.class) .getExtension(ConfigManager.NAME); 6.1.1 getExtension方法源码 先来看下getExtension方法的源码,根据扩展名字查询扩展对象
public T getExtension(String name) { //这里并不能看到什么,只多传了个参数wrap为true调用另外一个重载的方法 T extension = getExtension(name, true); if (extension == null) { throw new IllegalArgumentException(&amp;#34;Not find extension: &amp;#34; + name); } return extension; } public T getExtension(String name, boolean wrap) { //检查扩展加载器是否已被销毁 checkDestroyed(); if (StringUtils.isEmpty(name)) { throw new IllegalArgumentException(&amp;#34;Extension name == null&amp;#34;); } //扩展名字为true则加载默认扩展 if (&amp;#34;true&amp;#34;.equals(name)) { return getDefaultExtension(); } //非wrap类型则将缓存的扩展名字key加上_origin后缀 //wrap是aop机制 俗称切面,这个origin在aop里面可以称为切点,下面的wrap扩展可以称为增强通知的类型,普通扩展和wrap扩展的扩展名字是一样的 String cacheKey = name; if (!</description></item><item><title>05-自适应扩展对象的创建getAdaptiveExtension方法</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/05/05-%E8%87%AA%E9%80%82%E5%BA%94%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BAgetadaptiveextension%E6%96%B9%E6%B3%95/</link><pubDate>Fri, 05 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/05/05-%E8%87%AA%E9%80%82%E5%BA%94%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BAgetadaptiveextension%E6%96%B9%E6%B3%95/</guid><description>5 自适应扩展对象的创建getAdaptiveExtension方法 自适应扩展又称为动态扩展,可以在运行时生成扩展对象
ExtensionLoader中的getAdaptiveExtension()方法,这个方法也是我们看到的第一个获取扩展对象的方法. ,这个方法可以帮助我们通过SPI机制从扩展文件中找到需要的扩展类型并创建它的对象, 自适应扩展:如果对设计模式比较了解的可能会联想到适配器模式,自适应扩展其实就是适配器模式的思路,自适应扩展有两种策略:
一种是我们自己实现自适应扩展:然后使用@Adaptive修饰这个时候适配器的逻辑由我们自己实现,当扩展加载器去查找具体的扩展的时候可以通过找到我们这个对应的适配器扩展,然后适配器扩展帮忙去查询真正的扩展,这个比如我们下面要举的扩展注入器的例子,具体扩展通过扩展注入器适配器,注入器适配器来查询具体的注入器扩展实现来帮忙查找扩展。
还有一种方式是我们未实现这个自适应扩展,Dubbo在运行时通过字节码动态代理的方式在运行时生成一个适配器,使用这个适配器映射到具体的扩展. 第二种情况往往用在比如 Protocol、Cluster、LoadBalance 等。有时，有些拓展并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载。(如果还不了解可以考虑看下@Adaptive注解加载方法上面的时候扩展是如何加载的)
public T getAdaptiveExtension() { //检查当前扩展加载器是否已经被销毁 checkDestroyed(); //从自适应扩展缓存中查询扩展对象如果存在就直接返回,这个自适应扩展类型只会有一个扩展实现类型如果是多个的话根据是否可以覆盖参数决定扩展实现类是否可以相互覆盖 Object instance = cachedAdaptiveInstance.get(); //这个if判断不太优雅 容易多层嵌套,上面instance不为空就可以直接返回了 if (instance == null) { //创建异常则抛出异常直接返回(多线程场景下可能第一个线程异常了第二个线程进来之后走到这里) if (createAdaptiveInstanceError != null) { throw new IllegalStateException(&amp;#34;Failed to create adaptive instance: &amp;#34; + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError); } //加锁排队 (单例模式创建对象的思想 双重校验锁) synchronized (cachedAdaptiveInstance) { //加锁的时候对象都是空的,进来之后先判断下防止重复创建 instance = cachedAdaptiveInstance.get(); //只有第一个进来锁的对象为空开始创建扩展对象 if (instance == null) { try { //根据SPI机制获取类型,创建对象 instance = createAdaptiveExtension(); //存入缓存 cachedAdaptiveInstance.</description></item><item><title>04-Dubbo的扩展机制</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/04/04-dubbo%E7%9A%84%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/</link><pubDate>Thu, 04 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/04/04-dubbo%E7%9A%84%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/</guid><description>4-Dubbo的扩展机制 4.1 回顾我们前面使用到扩展场景 在上一章中我们初始化应用模型对象的时候,了解到有几个地方用到了扩展机制来创建对象,这一章我们会详细来讲一下这个扩展对象的加载过程,这里我们先来回顾下哪些地方用到了扩展机制:
// 使用扩展机制获取TypeBuilder Set&amp;lt;TypeBuilder&amp;gt; tbs = model.getExtensionLoader(TypeBuilder.class).getSupportedExtensionInstances(); //获取域模型初始化器ScopeModelInitializer扩展对象,执行初始化方法 ExtensionLoader&amp;lt;ScopeModelInitializer&amp;gt; initializerExtensionLoader = this.getExtensionLoader(ScopeModelInitializer.class); Set&amp;lt;ScopeModelInitializer&amp;gt; initializers = initializerExtensionLoader.getSupportedExtensionInstances(); // OrderedPropertiesConfiguration 中获取有序配置提供器对象 ExtensionLoader&amp;lt;OrderedPropertiesProvider&amp;gt; propertiesProviderExtensionLoader = moduleModel.getExtensionLoader(OrderedPropertiesProvider.class); // ApplicationModel中获取配置管理器对象 configManager = (ConfigManager) this.getExtensionLoader(ApplicationExt.class) .getExtension(ConfigManager.NAME); //ModuleModel中获取模块扩展对象 Set&amp;lt;ModuleExt&amp;gt; exts = this.getExtensionLoader(ModuleExt.class).getSupportedExtensionInstances(); // ApplicationModel中获Environment对象 environment = (Environment) this.getExtensionLoader(ApplicationExt.class) .getExtension(Environment.NAME); // ApplicationModel中获取应用初始化监听器ApplicationInitListener扩展对象 ExtensionLoader&amp;lt;ApplicationInitListener&amp;gt; extensionLoader = this.getExtensionLoader(ApplicationInitListener.class); Set&amp;lt;String&amp;gt; listenerNames = extensionLoader.getSupportedExtensions(); //ScopeModel中创建扩展访问器: this.extensionDirector = new ExtensionDirector(parent != null ? parent.getExtensionDirector() : null, scope, this); 有了以上的应用场景我们可以来看下扩展机制了
4.2 为什么要用到扩展机制?</description></item><item><title>03-框架,应用程序,模块领域模型Model对象的初始化</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/03/03-%E6%A1%86%E6%9E%B6%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8Bmodel%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</link><pubDate>Wed, 03 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/03/03-%E6%A1%86%E6%9E%B6%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8Bmodel%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</guid><description>3-框架,应用程序,模块领域模型Model对象的初始化 在上一章中我们详细看了服务配置ServiceConfig类型的初始化，不过我们跳过了AbstractMethodConfig的构造器中创建模块模型对象的过程，那这一章我们就来看下模块模型对象的初始化过程:
public AbstractMethodConfig() { super(ApplicationModel.defaultModel().getDefaultModule()); } 那为什么会在Dubbo3的新版本中加入这个域模型呢，主要有如下原因 之前dubbo都是只有一个作用域的，通过静态类 属性共享 增加域模型是为了:
让Dubbo支持多应用的部署，这块一些大企业有诉求 从架构设计上，解决静态属性资源共享、清理的问题 分层模型将应用的管理和服务的管理分开 可能比较抽象，可以具体点来看。Dubbo3中在启动时候需要启动配置中心、元数据中心，这个配置中心和元数据中心可以归应用模型来管理。Dubbo作为RPC框架又需要启动服务和引用服务，服务级别的管理就交给了这个模块模型来管理。分层次的管理方便我们理解和处理逻辑，父子级别的模型又方便了数据传递。
了解过JVM类加载机制的同学应该就比较清楚JVM类加载过程中的数据访问模型。子类加载器先交给父类加载器查找，找不到再从子类加载器中查找。Dubbo的分层模型类似这样一种机制，这一章先来简单了解下，后面用到时候具体细说。
3.1 模型对象的关系 为了不增加复杂性，我们这里仅仅列出模型对象类型类型之间的继承关系如下所示: 图3.1 模型对象的继承关系 模型对象一共有4个，公共的属性和操作放在了域模型类型中，下面我们来详细说下这几个模型类型:
ExtensionAccessor 扩展的统一访问器
用于获取扩展加载管理器ExtensionDirector对象 获取扩展对象ExtensionLoader 根据扩展名字获取具体扩展对象 获取自适应扩展对象 获取默认扩展对象 ScopeModel 模型对象的公共抽象父类型
内部id用于表示模型树的层次结构 公共模型名称，可以被用户设置 描述信息 类加载器管理 父模型管理parent 当前模型的所属域ExtensionScope有:FRAMEWORK(框架)，APPLICATION(应用)，MODULE(模块)，SELF(自给自足，为每个作用域创建一个实例，用于特殊的SPI扩展，如ExtensionInjector) 具体的扩展加载程序管理器对象的管理:ExtensionDirector 域Bean工厂管理，一个内部共享的Bean工厂ScopeBeanFactory 等等 FrameworkModel dubbo框架模型，可与多个应用程序共享
FrameworkModel实例对象集合，allInstances 所有ApplicationModel实例对象集合，applicationModels 发布的ApplicationModel实例对象集合pubApplicationModels 框架的服务存储库FrameworkServiceRepository类型对象(数据存储在内存中) 内部的应用程序模型对象internalApplicationModel ApplicationModel 表示正在使用Dubbo的应用程序，并存储基本元数据信息，以便在RPC调用过程中使用。 ApplicationModel包括许多关于发布服务的ProviderModel和许多关于订阅服务的Consumer Model。
ExtensionLoader、DubboBootstrap和这个类目前被设计为单例或静态（本身完全静态或使用一些静态字段）。因此，从它们返回的实例属于流程范围。如果想在一个进程中支持多个dubbo服务器，可能需要重构这三个类。 所有ModuleModel实例对象集合moduleModels 发布的ModuleModel实例对象集合pubModuleModels 环境信息Environment实例对象environment 配置管理ConfigManager实例对象configManager 服务存储库ServiceRepository实例对象serviceRepository 应用程序部署器ApplicationDeployer实例对象deployer 所属框架FrameworkModel实例对象frameworkModel 内部的模块模型ModuleModel实例对象internalModule 默认的模块模型ModuleModel实例对象defaultModule ModuleModel 服务模块的模型
所属应用程序模型ApplicationModel实例对象applicationModel 模块环境信息ModuleEnvironment实例对象moduleEnvironment 模块服务存储库ModuleServiceRepository实例对象serviceRepository 模块的服务配置管理ModuleConfigManager实例对象moduleConfigManager 模块部署器ModuleDeployer实例对象deployer用于导出和引用服务 了解了这几个模型对象的关系我们可以了解到这几个模型对象的管理层级从框架到应用程序，然后到模块的管理(FrameworkModel-&amp;gt;ApplicationModel-&amp;gt;ModuleModel)，他们主要用来针对框架，应用程序，模块的存储，发布管理，，配置管理
看来Dubbo3 针对应用服务治理与运维这一块也是在努力尝试.</description></item><item><title>02-启动服务前服务配置ServiceConfig类型是如何初始化的?</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/02/02-%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%89%8D%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AEserviceconfig%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84/</link><pubDate>Tue, 02 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/02/02-%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%89%8D%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AEserviceconfig%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84/</guid><description>2-启动服务前服务配置ServiceConfig类型是如何初始化的? 2.1 示例源码回顾: 为了方便我们理解记忆,这里先来回顾下上一章我们说的示例代码,如下所示:
public class Application { public static void main(String[] args) throws Exception { startWithBootstrap(); } private static void startWithBootstrap() { ServiceConfig&amp;lt;DemoServiceImpl&amp;gt; service = new ServiceConfig&amp;lt;&amp;gt;(); service.setInterface(DemoService.class); service.setRef(new DemoServiceImpl()); DubboBootstrap bootstrap = DubboBootstrap.getInstance(); bootstrap.application(new ApplicationConfig(&amp;#34;dubbo-demo-api-provider&amp;#34;)) .registry(new RegistryConfig(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;)) .protocol(new ProtocolConfig(CommonConstants.DUBBO, -1)) .service(service) .start() .await(); } } 上面这几行代码虽然看似简单,仅仅几行的启动,但是完全掌握也得下一翻大功夫,接下来我们重点看启动代码中的第一行,创建一个服务配置对象:
ServiceConfig&amp;lt;DemoServiceImpl&amp;gt; service = new ServiceConfig&amp;lt;&amp;gt;(); 2.2 了解一下服务配置的建模 下面是一个简单的UML继承关系图,当然这个图很是简单的,这里仅仅列出了当前服务提供者的相关服务配置继承关系, 服务提供者独有的配置标注颜色为蓝色,一些可能与服务引用配置所共有的父类型我们用红色背景,当然这里为了简便起见不会提起服务引用相关的配置类型,这里列举了如下服务提供者类型,他们各司其职: 图2.1 服务引用类继承关系UML AbstractConfig 抽象的配置类型,也是最顶层的服务配置类型,封装着解析配置的实用方法和公共方法,比如服务id的设置,服务标签名字的处理,服务参数的添加,属性的提取等等 AbstractMethodConfig 抽象的方法配置,同样这个类型也是见名知意,服务方法的相关配置处理,这个类型主要用于对服务方法的一些配置信息建模比如服务方法的调用超时时间,重试次数,最大并发调用数,负载均衡策略,是否异步调用,是否确认异步发送等等配置信息. AbstractInterfaceConfig 抽象的接口配置,与前面介绍的方法配置类似,这个类型是对服务接口的建模,主要的配置信息有暴漏服务的接口名字,服务接口的版本号,客户/提供方将引用的远程服务分组,服务元数据,服务接口的本地impl类名,服务监控配置,对于生成动态代理的策略，可以选择两种策略：jdk和javassist,容错类型等等配置 AbstractServiceConfig 抽象的服务配置,这个就与我们的服务提供者有了具体的关系了,主要记录了一些服务提供者的公共配置,如服务版本,服务分组,服务延迟注册毫秒数,是否暴漏服务,服务权重,是否为动态服务,服务协议类型,是否注册等等. ServiceConfigBase 服务的基础配置类,这个类型仍旧是个抽象的类型提取了一些基础的配置:导出服务的接口类,服务名称,接口实现的引用类型,提供者配置,是否是通用服务GenericService ServiceConfig 服务配置实现类, 上面的类型都是抽象类型不能做为具体存在的事物,这个类型是我们出现的第一个服务配置实现类型,服务配置实现类已经从父类型中继承了这么多的属性,这里主要为实现服务提供了一些配置如服务的协议配置,服务的代理工厂JavassistProxyFactory是将生成导出服务代理的ProxyFactory实现，是其默认实现,服务提供者模型,是否导出服务,导出的服务列表,服务监听器等等.</description></item><item><title>01 从一个服务提供者的Demo说起</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/01/01-%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E7%9A%84demo%E8%AF%B4%E8%B5%B7/</link><pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/01/01-%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E7%9A%84demo%E8%AF%B4%E8%B5%B7/</guid><description>1 从一个服务提供者的Demo说起 为了更方便了解原理,我们先来编写一个Demo,从例子中来看源码实现:
1.1 启动Zookeeper 为了Demo可以正常启动,需要我们先在本地启动一个Zookeeper如下图所示: 1.2 服务提供者 接下来给大家贴一下示例源码,这个源码来源于Dubbo源码目录的	dubbo-demo/dubbo-demo-api 目录下面的dubbo-demo-api-provider子项目,这里我做了删减,方便看核心代码: 首先我们定义一个服务接口如下所示:
import java.util.concurrent.CompletableFuture; public interface DemoService { /** * 同步处理的服务方法 * @param name * @return */ String sayHello(String name); /** * 用于异步处理的服务方法 * @param name * @return */ default CompletableFuture&amp;lt;String&amp;gt; sayHelloAsync(String name) { return CompletableFuture.completedFuture(sayHello(name)); } } 服务实现类如下: import org.apache.dubbo.rpc.RpcContext; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.util.concurrent.CompletableFuture; public class DemoServiceImpl implements DemoService { private static final Logger logger = LoggerFactory.getLogger(DemoServiceImpl.class); @Override public String sayHello(String name) { logger.</description></item></channel></rss>