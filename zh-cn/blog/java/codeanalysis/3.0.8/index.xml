<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Apache Dubbo – Dubbo 3.0.8 源码解析</title><link>https://cn.dubbo.apache.org/zh-cn/blog/java/codeanalysis/3.0.8/</link><description>Recent content in Dubbo 3.0.8 源码解析 on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://cn.dubbo.apache.org/zh-cn/blog/java/codeanalysis/3.0.8/index.xml" rel="self" type="application/rss+xml"/><item><title>Blog: 22-Dubbo3消费者自动感应决策应用级服务发现原理</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/22/22-dubbo3%E6%B6%88%E8%B4%B9%E8%80%85%E8%87%AA%E5%8A%A8%E6%84%9F%E5%BA%94%E5%86%B3%E7%AD%96%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 22 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/22/22-dubbo3%E6%B6%88%E8%B4%B9%E8%80%85%E8%87%AA%E5%8A%A8%E6%84%9F%E5%BA%94%E5%86%B3%E7%AD%96%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>
&lt;h1 id="22-dubbo3消费者自动感应决策应用级服务发现原理">22-Dubbo3消费者自动感应决策应用级服务发现原理&lt;/h1>
&lt;h2 id="221-简介">22.1 简介&lt;/h2>
&lt;p>这里要说的内容对Dubbo2迁移到Dubbo3的应用比较有帮助，消费者应用级服务发现做了一些自动决策的逻辑来决定当前消费者是应用级发现还是接口级服务发现，这里与前面说的提供者双注册的原理是对等的，提供者默认同时进行应用级注册和接口级注册，消费者对提供者注册的数据来决定使用应用级发现或者接口级发现。这些都是默认的行为，当然对于消费者来说还可以自定义其他的迁移规则，具体的需要我们详细来看逻辑。&lt;/p>
&lt;p>如果说对于迁移过程比较感兴趣可以直接去官网看文档相对来说还是比较清晰:&lt;a href="https://cn.dubbo.apache.org/zh-cn/docs/migration/migration-service-discovery/">https://dubbo.apache.org/zh-cn/docs/migration/migration-service-discovery/&lt;/a>&lt;/p>
&lt;p>这里再借官网的图来用用，迁移过程主要如下所示：
第一个图是提供者双注册的图：
&lt;img src="https://cn.dubbo.apache.org/imgs/v3/migration/provider-registration.png" alt="在这里插入图片描述">&lt;/p>
&lt;p>第二个图是消费者订阅决策的图：
&lt;img src="https://cn.dubbo.apache.org/imgs/v3/migration/consumer-subscription.png" alt="在这里插入图片描述">&lt;/p>
&lt;p>第三个图就是精确到消费者订阅的代码层的逻辑了，消费者服务间调用通过一个Invoker类型对象来进行对象，如下图所示消费者代理对象通过创建一个迁移容错的调用器对象来对应用级或者接口级订阅进行适配如下所示
&lt;img src="https://cn.dubbo.apache.org/imgs/v3/migration/migration-cluster-invoker.png" alt="在这里插入图片描述">&lt;/p>
&lt;p>第二个图和第三个图是重点要关注的这一个文章的内容主要就是说这里的逻辑。&lt;/p>
&lt;p>关于代码位置如果不知道是如何调用到这一块逻辑的可以查看博文&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/21-dubbo-xiao-fei-zhe-yin-yong-fu-wu-de-ru-kou/">《21-Dubbo3消费者引用服务入口》&lt;/a>&lt;/p>
&lt;p>这里直接将代码位置定位到：RegistryProtocol类型的interceptInvoker方法中：
如下所示：&lt;/p>
&lt;p>RegistryProtocol类型的interceptInvoker方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">interceptInvoker&lt;/span>(ClusterInvoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> invoker, URL url, URL consumerUrl) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//目前存在的扩展类型为RegistryProtocolListener监听器的实现类型MigrationRuleListener &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>RegistryProtocolListener&lt;span style="color:#719e07">&amp;gt;&lt;/span> listeners &lt;span style="color:#719e07">=&lt;/span> findRegistryProtocolListeners(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isEmpty(listeners)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> invoker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (RegistryProtocolListener listener : listeners) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> listener.onRefer(&lt;span style="color:#719e07">this&lt;/span>, invoker, consumerUrl, url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> invoker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该方法尝试加载所有RegistryProtocolListener定义，这些定义通过与定义的交互来控制调用器的行为，然后使用这些侦听器更改MigrationInvoker的状态和行为。当前可用的监听器是MigrationRuleListener，用于通过动态变化的规则控制迁移行为。&lt;/p>
&lt;h2 id="222-migrationrulelistener-类型的onrefer方法">22.2 MigrationRuleListener 类型的onRefer方法&lt;/h2>
&lt;p>直接来看代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">onRefer&lt;/span>(RegistryProtocol registryProtocol, ClusterInvoker&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> invoker, URL consumerUrl, URL registryURL) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建一个对应invoker对象的MigrationRuleHandler类型对象 然后将其存放在缓存Map&amp;lt;MigrationInvoker, MigrationRuleHandler&amp;gt;类型对象handles中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MigrationRuleHandler&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> migrationRuleHandler &lt;span style="color:#719e07">=&lt;/span> handlers.computeIfAbsent((MigrationInvoker&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span>) invoker, _key &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ((MigrationInvoker&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span>) invoker).setMigrationRuleListener(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> MigrationRuleHandler&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>((MigrationInvoker&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span>) invoker, consumerUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//迁移规则执行 rule是封装了迁移的配置规则的信息对应类型MigrationRule类型，在初始化对象的时候进行了配置初始化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> migrationRuleHandler.doMigrate(rule);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>关于这个igrationRule的文可以直接看官方的文档比较详细：&lt;a href="https://cn.dubbo.apache.org/zh-cn/docs/advanced/migration-invoker/#1-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8B%E5%8F%91%E6%8E%A8%E8%8D%90">地址迁移规则说明&lt;/a>&lt;/p>
&lt;p>这个迁移规则是为了更细粒度的迁移决策：
相关配置可以参考下面这个样例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">key&lt;/span>: 消费者应用名（必填）
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">step&lt;/span>: 状态名（必填）
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">threshold&lt;/span>: 决策阈值（默认1.0）
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">proportion&lt;/span>: 灰度比例（默认100）
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">delay&lt;/span>: 延迟决策时间（默认0）
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">force&lt;/span>: 强制切换（默认 false）
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">interfaces&lt;/span>: 接口粒度配置（可选）
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#268bd2">serviceKey: 接口名（接口 + &lt;/span>: + 版本号）（必填）
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">threshold&lt;/span>: 决策阈值
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">proportion&lt;/span>: 灰度比例
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">delay&lt;/span>: 延迟决策时间
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">force&lt;/span>: 强制切换
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">step&lt;/span>: 状态名（必填）
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#268bd2">serviceKey: 接口名（接口 + &lt;/span>: + 版本号）
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">step&lt;/span>: 状态名
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">applications&lt;/span>: 应用粒度配置（可选）
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#268bd2">serviceKey&lt;/span>: 应用名（消费的上游应用名）（必填）
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">threshold&lt;/span>: 决策阈值
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">proportion&lt;/span>: 灰度比例
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">delay&lt;/span>: 延迟决策时间
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">force&lt;/span>: 强制切换
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">step&lt;/span>: 状态名（必填）
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不过为了简单起见暂时先不详细说这个配置细节，我们继续往下看&lt;/p>
&lt;h2 id="223-迁移规则处理器执行迁移规则migrationrulehandler类型的domigrate方法">22.3 迁移规则处理器执行迁移规则MigrationRuleHandler类型的doMigrate方法&lt;/h2>
&lt;h3 id="2231-迁移规则的模版方法">22.3.1 迁移规则的模版方法：&lt;/h3>
&lt;p>MigrationRuleHandler类型的doMigrate方法代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">synchronized&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">doMigrate&lt;/span>(MigrationRule rule) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//默认情况下这个类型是MigrationInvoker&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (migrationInvoker &lt;span style="color:#719e07">instanceof&lt;/span> ServiceDiscoveryMigrationInvoker) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> refreshInvoker(MigrationStep.FORCE_APPLICATION, 1.0f, rule);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//迁移步骤，MigrationStep 一共有3种枚举情况：FORCE_INTERFACE, APPLICATION_FIRST, FORCE_APPLICATION&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// initial step : APPLICATION_FIRST&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MigrationStep step &lt;span style="color:#719e07">=&lt;/span> MigrationStep.APPLICATION_FIRST;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">float&lt;/span> threshold &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">-&lt;/span>1f;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取配置的类型 默认走APPLICATION_FIRST&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> step &lt;span style="color:#719e07">=&lt;/span> rule.getStep(consumerURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//threshold: 决策阈值（默认-1.0）计算与获取&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> threshold &lt;span style="color:#719e07">=&lt;/span> rule.getThreshold(consumerURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(&lt;span style="color:#2aa198">&amp;#34;Failed to get step and threshold info from rule: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> rule, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//刷洗调用器对象 来进行决策服务发现模式&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (refreshInvoker(step, threshold, rule)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// refresh success, update rule&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setMigrationRule(rule);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2232-服务发现调用器对象的选择决策服务发现策略">22.3.2 服务发现调用器对象的选择（决策服务发现策略）&lt;/h3>
&lt;p>这里就是关键代码了：通过迁移配置和当前提供者注册信息来决定创建什么类型的调用器对象（Invoker)来为后续服务调用做准备&lt;/p>
&lt;p>MigrationRuleHandler的refreshInvoker，注意默认情况下这个step参数为APPLICATION_FIRST&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">boolean&lt;/span> &lt;span style="color:#268bd2">refreshInvoker&lt;/span>(MigrationStep step, Float threshold, MigrationRule newRule) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (step &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> threshold &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;Step or threshold of migration rule cannot be null&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MigrationStep originStep &lt;span style="color:#719e07">=&lt;/span> currentStep;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> ((currentStep &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> currentStep &lt;span style="color:#719e07">!=&lt;/span> step) &lt;span style="color:#719e07">||&lt;/span> &lt;span style="color:#719e07">!&lt;/span>currentThreshold.equals(threshold)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">boolean&lt;/span> success &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">switch&lt;/span> (step) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">case&lt;/span> APPLICATION_FIRST:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//默认和配置了应用级优先的服务发现则走这里&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> migrationInvoker.migrateToApplicationFirstInvoker(newRule);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">case&lt;/span> FORCE_APPLICATION:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置了应用级服务发现则走这里&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> success &lt;span style="color:#719e07">=&lt;/span> migrationInvoker.migrateToForceApplicationInvoker(newRule);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">case&lt;/span> FORCE_INTERFACE:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置了接口级服务发现则走这里&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> success &lt;span style="color:#719e07">=&lt;/span> migrationInvoker.migrateToForceInterfaceInvoker(newRule);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (success) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setCurrentStepAndThreshold(step, threshold);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;Succeed Migrated to &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> step &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; mode. Service Name: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> consumerURL.getDisplayServiceKey());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> report(step, originStep, &lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// migrate failed, do not save new step and rule&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(&lt;span style="color:#2aa198">&amp;#34;Migrate to &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> step &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; mode failed. Probably not satisfy the threshold you set &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">+&lt;/span> threshold &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;. Please try re-publish configuration if you still after check.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> report(step, originStep, &lt;span style="color:#2aa198">&amp;#34;false&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> success;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ignore if step is same with previous, will continue override rule for MigrationInvoker&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到这个代码做了判断的逻辑分别对应了Dubbo3消费者迁移的一个状态逻辑：
三种状态分别如下枚举类型：
当前共存在三种状态，&lt;/p>
&lt;ul>
&lt;li>FORCE_INTERFACE（强制接口级）&lt;/li>
&lt;li>APPLICATION_FIRST（应用级优先）&lt;/li>
&lt;li>FORCE_APPLICATION（强制应用级）&lt;/li>
&lt;/ul>
&lt;p>通过代码我们可以看到默认情况下都会走APPLICATION_FIRST（应用级优先）的策略，这里我们也重点来说 APPLICATION_FIRST（应用级优先）来看下Dubbo3是如何决策使用接口级还是应用级发现模型来兼容迁移的服务的。&lt;/p>
&lt;h3 id="2233-应用级优先的服务发现规则逻辑">22.3.3 应用级优先的服务发现规则逻辑&lt;/h3>
&lt;p>这个规则就是智能选择应用级还是接口级的代码了，对应类型为MigrationInvoker的migrateToApplicationFirstInvoker方法，接下来我们详细看下：&lt;/p>
&lt;p>MigrationInvoker类型的migrateToApplicationFirstInvoker方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">migrateToApplicationFirstInvoker&lt;/span>(MigrationRule newRule) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CountDownLatch latch &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> CountDownLatch(0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//刷新接口级服务发现Invoker &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> refreshInterfaceInvoker(latch);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//刷新应用级服务发现Invoker类型对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> refreshServiceDiscoveryInvoker(latch);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// directly calculate preferred invoker, will not wait until address notify&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// calculation will re-occurred when address notify later&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//计算当前使用应用级还是接口级服务发现的Invoker对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> calcPreferredInvoker(newRule);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2234-刷新接口级服务发现invoker">22.3.4 刷新接口级服务发现Invoker&lt;/h3>
&lt;p>MigrationInvoker类型的refreshInterfaceInvoker方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">refreshInterfaceInvoker&lt;/span>(CountDownLatch latch) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clearListener(invoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (needRefresh(invoker)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (logger.isDebugEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.debug(&lt;span style="color:#2aa198">&amp;#34;Re-subscribing interface addresses for interface &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> type.getName());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (invoker &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> invoker.destroy();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> invoker &lt;span style="color:#719e07">=&lt;/span> registryProtocol.getInvoker(cluster, registry, type, url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setListener(invoker, () &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> latch.countDown();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (reportService.hasReporter()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reportService.reportConsumptionStatus(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reportService.createConsumptionReport(consumerUrl.getServiceInterface(), consumerUrl.getVersion(), consumerUrl.getGroup(), &lt;span style="color:#2aa198">&amp;#34;interface&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (step &lt;span style="color:#719e07">==&lt;/span> APPLICATION_FIRST) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> calcPreferredInvoker(rule);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2235-刷新应用级服务发现invoker类型对象">22.3.5 刷新应用级服务发现Invoker类型对象&lt;/h3>
&lt;p>MigrationInvoker类型的refreshServiceDiscoveryInvoker方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">refreshServiceDiscoveryInvoker&lt;/span>(CountDownLatch latch) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clearListener(serviceDiscoveryInvoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (needRefresh(serviceDiscoveryInvoker)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (logger.isDebugEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.debug(&lt;span style="color:#2aa198">&amp;#34;Re-subscribing instance addresses, current interface &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> type.getName());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (serviceDiscoveryInvoker &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceDiscoveryInvoker.destroy();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceDiscoveryInvoker &lt;span style="color:#719e07">=&lt;/span> registryProtocol.getServiceDiscoveryInvoker(cluster, registry, type, url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setListener(serviceDiscoveryInvoker, () &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> latch.countDown();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (reportService.hasReporter()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reportService.reportConsumptionStatus(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reportService.createConsumptionReport(consumerUrl.getServiceInterface(), consumerUrl.getVersion(), consumerUrl.getGroup(), &lt;span style="color:#2aa198">&amp;#34;app&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (step &lt;span style="color:#719e07">==&lt;/span> APPLICATION_FIRST) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> calcPreferredInvoker(rule);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2236-计算当前使用应用级还是接口级服务发现的invoker对象">22.3.6 计算当前使用应用级还是接口级服务发现的Invoker对象&lt;/h3>
&lt;p>MigrationInvoker类型的的calcPreferredInvoker方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">synchronized&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">calcPreferredInvoker&lt;/span>(MigrationRule migrationRule) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (serviceDiscoveryInvoker &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> invoker &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>MigrationAddressComparator&lt;span style="color:#719e07">&amp;gt;&lt;/span> detectors &lt;span style="color:#719e07">=&lt;/span> ScopeModelUtil.getApplicationModel(consumerUrl &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">?&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> : consumerUrl.getScopeModel())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .getExtensionLoader(MigrationAddressComparator.class).getSupportedExtensionInstances();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isNotEmpty(detectors)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// pick preferred invoker&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// the real invoker choice in invocation will be affected by promotion&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (detectors.stream().allMatch(comparator &lt;span style="color:#719e07">-&amp;gt;&lt;/span> comparator.shouldMigrate(serviceDiscoveryInvoker, invoker, migrationRule))) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.currentAvailableInvoker &lt;span style="color:#719e07">=&lt;/span> serviceDiscoveryInvoker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.currentAvailableInvoker &lt;span style="color:#719e07">=&lt;/span> invoker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>currentAvailableInvoker是后期服务调用使用的Invoker对象&lt;/p>
&lt;p>原文地址：&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/22-dubbo3-xiao-fei-zhe-zi-dong-gan-ying-jue-ce-ying-yong-ji-fu-wu-fa-xian-yuan-li/">22-Dubbo3消费者自动感应决策应用级服务发现原理&lt;/a>&lt;/p></description></item><item><title>Blog: 21-Dubbo3消费者引用服务入口</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/21/21-dubbo3%E6%B6%88%E8%B4%B9%E8%80%85%E5%BC%95%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%85%A5%E5%8F%A3/</link><pubDate>Sun, 21 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/21/21-dubbo3%E6%B6%88%E8%B4%B9%E8%80%85%E5%BC%95%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%85%A5%E5%8F%A3/</guid><description>
&lt;h1 id="21-dubbo3消费者引用服务入口">21-Dubbo3消费者引用服务入口&lt;/h1>
&lt;h2 id="211-简介">21.1 简介&lt;/h2>
&lt;p>前面我们通过Demo说了一个服务引用配置的创建。另外也在前面的文章说了服务提供者的启动完整过程，不过在说服务提供者启动的过程中并未提到服务消费者是如何发现服务，如果调用服务的，这里先就不再说关于服务消费者启动的一个细节了，直接来看前面未提到的服务消费者是如何引用到服务提供者提供的服务的。
先来回顾下样例代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">ConsumerApplication&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>(String&lt;span style="color:#719e07">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> runWithBootstrap();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">runWithBootstrap&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ReferenceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>DemoService&lt;span style="color:#719e07">&amp;gt;&lt;/span> reference &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ReferenceConfig&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reference.setInterface(DemoService.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reference.setGeneric(&lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reference.setProtocol(&lt;span style="color:#2aa198">&amp;#34;&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DubboBootstrap bootstrap &lt;span style="color:#719e07">=&lt;/span> DubboBootstrap.getInstance();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ApplicationConfig applicationConfig &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ApplicationConfig(&lt;span style="color:#2aa198">&amp;#34;dubbo-demo-api-consumer&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationConfig.setQosEnable(&lt;span style="color:#cb4b16">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationConfig.setQosPort(&lt;span style="color:#719e07">-&lt;/span>1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bootstrap.application(applicationConfig)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .registry(&lt;span style="color:#719e07">new&lt;/span> RegistryConfig(&lt;span style="color:#2aa198">&amp;#34;zookeeper://8.131.79.126:2181&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .protocol(&lt;span style="color:#719e07">new&lt;/span> ProtocolConfig(CommonConstants.DUBBO, &lt;span style="color:#719e07">-&lt;/span>1))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .reference(reference)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .start();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DemoService demoService &lt;span style="color:#719e07">=&lt;/span> bootstrap.getCache().get(reference);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String message &lt;span style="color:#719e07">=&lt;/span> demoService.sayHello(&lt;span style="color:#2aa198">&amp;#34;dubbo&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.out.println(message);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// generic invoke&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GenericService genericService &lt;span style="color:#719e07">=&lt;/span> (GenericService) demoService;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object genericInvokeResult &lt;span style="color:#719e07">=&lt;/span> genericService.$invoke(&lt;span style="color:#2aa198">&amp;#34;sayHello&amp;#34;&lt;/span>, &lt;span style="color:#719e07">new&lt;/span> String&lt;span style="color:#719e07">[]&lt;/span>{String.class.getName()},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">new&lt;/span> Object&lt;span style="color:#719e07">[]&lt;/span>{&lt;span style="color:#2aa198">&amp;#34;dubbo generic invoke&amp;#34;&lt;/span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.out.println(genericInvokeResult);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段代码我们前面详细说了服务引用的配置ReferenceConfig和Dubbo启动器启动应用的过程DubboBootstrap，后面我们直接定位到消费者引用服务的代码位置来看。&lt;/p>
&lt;h2 id="212-入口代码">21.2 入口代码&lt;/h2>
&lt;h3 id="2121-defaultmoduledeployer的start方法">21.2.1 DefaultModuleDeployer的start方法&lt;/h3>
&lt;p>第一个要关注的就是模块发布器DefaultModuleDeployer的start方法，这个start方法包含了Dubbo应用启动的过程&lt;/p>
&lt;p>DefaultModuleDeployer的start方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">synchronized&lt;/span> Future &lt;span style="color:#268bd2">start&lt;/span>() &lt;span style="color:#268bd2">throws&lt;/span> IllegalStateException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...省略掉若干代码
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> onModuleStarting();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// initialize&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationDeployer.initialize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initialize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// export services&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exportServices();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// prepare application instance&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// exclude internal module to avoid wait itself&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (moduleModel &lt;span style="color:#719e07">!=&lt;/span> moduleModel.getApplicationModel().getInternalModule()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationDeployer.prepareInternalModule();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// refer services&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> referServices();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...省略掉若干代码
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> startFuture;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个方法大部分代码已经省略，也不会详细去说了，感兴趣的可以看之前讲到的博客，这里主要来看引用服务方法referServices&lt;/p>
&lt;h3 id="2122-defaultmoduledeployer的referservices方法">21.2.2 DefaultModuleDeployer的referServices方法&lt;/h3>
&lt;p>下面就要来看消费者应用如何引用的服务的入口了，这个方法主要从大的方面做了一些服务引用生命周期的代码，看懂了这个方法我们就可以不依赖Dubbo负载的启动逻辑可以单独调用ReferenceConfigBase类型的对应方法来刷新，启动，销毁引用的服务了这里先来看下代码再详细介绍内容：&lt;/p>
&lt;p>DefaultModuleDeployer的referServices方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">referServices&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个是获取配置的所有的ReferenceConfigBase类型对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configManager.getReferences().forEach(rc &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ReferenceConfig&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> referenceConfig &lt;span style="color:#719e07">=&lt;/span> (ReferenceConfig&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span>) rc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>referenceConfig.isRefreshed()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//刷新引用配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> referenceConfig.refresh();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (rc.shouldInit()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (referAsync &lt;span style="color:#719e07">||&lt;/span> rc.shouldReferAsync()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ExecutorService executor &lt;span style="color:#719e07">=&lt;/span> executorRepository.getServiceReferExecutor();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CompletableFuture&lt;span style="color:#719e07">&amp;lt;&lt;/span>Void&lt;span style="color:#719e07">&amp;gt;&lt;/span> future &lt;span style="color:#719e07">=&lt;/span> CompletableFuture.runAsync(() &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//间接的通过缓存对象来引用服务配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> referenceCache.get(rc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(getIdentifier() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; refer async catch error : &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> t.getMessage(), t);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, executor);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> asyncReferringFutures.add(future);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//间接的通过缓存对象来引用服务配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> referenceCache.get(rc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(getIdentifier() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; refer catch error.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//出现异常销毁引用配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> referenceCache.destroy(rc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> t;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个代码中我们核心需要关心的就是SimpleReferenceCache类型的get方法了，在获取服务对象之外包装了一层缓存。&lt;/p>
&lt;p>如果出现了异常则执行referenceCache的destroy方法进行销毁引用配置。&lt;/p>
&lt;h2 id="213-开始引用服务">21.3 开始引用服务&lt;/h2>
&lt;h3 id="2131-simplereferencecache是什么">21.3.1 SimpleReferenceCache是什么？&lt;/h3>
&lt;p>一个用于缓存引用ReferenceConfigBase的util工具类。
ReferenceConfigBase是一个重对象，对于频繁创建ReferenceConfigBase的框架来说，有必要缓存这些对象。
如果需要使用复杂的策略，可以实现并使用自己的ReferenceConfigBase缓存
这个Cache是引用服务的开始如果我们想在代码中自定义一些服务引用的逻辑，可以直接创建SimpleReferenceCache类型对象然后调用其get方法进行引用服务。那这个缓存对象是和缓存与引用服务的可以继续往下看。&lt;/p>
&lt;h3 id="2132-引用服务之前的缓存处理逻辑">21.3.2 引用服务之前的缓存处理逻辑？&lt;/h3>
&lt;p>关于逻辑的处理，看代码有时候比文字更清晰明了，这里可以直接来看 SimpleReferenceCache类型的get方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@SuppressWarnings&lt;/span>(&lt;span style="color:#2aa198">&amp;#34;unchecked&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> T &lt;span style="color:#268bd2">get&lt;/span>(ReferenceConfigBase&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> rc) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个生成的key规则是这样的 服务分组/服务接口:版本号 详细的代码就不看了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//例如： group/link.elastic.dubbo.entity.DemoService:1.0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String key &lt;span style="color:#719e07">=&lt;/span> generator.generateKey(rc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务类型 如果是泛化调用则这个类型为GenericService&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> type &lt;span style="color:#719e07">=&lt;/span> rc.getInterfaceClass();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务是否为单例的这里默认值都为空，为单例模式&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">boolean&lt;/span> singleton &lt;span style="color:#719e07">=&lt;/span> rc.getSingleton() &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> rc.getSingleton();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T proxy &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Check existing proxy of the same &amp;#39;key&amp;#39; and &amp;#39;type&amp;#39; first.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (singleton) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//一般为单例的 这个方法是从缓存中获取&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> proxy &lt;span style="color:#719e07">=&lt;/span> get(key, (Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span>) type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//非单例容易造成内存泄露，无法从缓存中获取&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(&lt;span style="color:#2aa198">&amp;#34;Using non-singleton ReferenceConfig and ReferenceCache at the same time may cause memory leak. &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;Call ReferenceConfig#get() directly for non-singleton ReferenceConfig instead of using ReferenceCache#get(ReferenceConfig)&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//前面是从缓存中拿，如果缓存中获取不到则开始引用服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (proxy &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取或者创建值，为引用类型referencesOfType对象（类型为Map&amp;lt;Class&amp;lt;?&amp;gt;, List&amp;lt;ReferenceConfigBase&amp;lt;?&amp;gt;&amp;gt;&amp;gt;）缓存对象生成值（值不存咋时候会生成一个）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>ReferenceConfigBase&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> referencesOfType &lt;span style="color:#719e07">=&lt;/span> referenceTypeMap.computeIfAbsent(type, _t &lt;span style="color:#719e07">-&amp;gt;&lt;/span> Collections.synchronizedList(&lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//每次走到这里都会添加一个ReferenceConfigBase 引用配置对象（单例的从缓存中拿到就可以直接返回了）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> referencesOfType.add(rc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//与前面一样 前面是类型映射，这里是key映射&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>ReferenceConfigBase&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> referenceConfigList &lt;span style="color:#719e07">=&lt;/span> referenceKeyMap.computeIfAbsent(key, _k &lt;span style="color:#719e07">-&amp;gt;&lt;/span> Collections.synchronizedList(&lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> referenceConfigList.add(rc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//开始引用服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> proxy &lt;span style="color:#719e07">=&lt;/span> rc.get();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> proxy;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到这个逻辑使用了享元模式（其实就是先查缓存，缓存不存在则创建对象存入缓存）来进行引用对象的管理这样一个过程，这里一共有两个缓存对象referencesOfType和referenceConfigList
key分别为引用类型和引用的服务的key，值是引用服务的基础配置对象列表List&amp;lt;ReferenceConfigBase&lt;?>&amp;gt;&lt;/p>
&lt;p>后面可以详细看下如果借助ReferenceConfigBase类型对象来进行具体类型的引用。&lt;/p>
&lt;h2 id="214-初始化引用服务的过程">21.4 初始化引用服务的过程&lt;/h2>
&lt;h3 id="2141-初始化引用服务的调用入口">21.4.1 初始化引用服务的调用入口&lt;/h3>
&lt;p>引用服务的逻辑其实是相对复杂一点的，包含了服务发现，引用对象的创建等等，接下来就让我们详细看下:&lt;/p>
&lt;p>ReferenceConfig类型的get方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> T &lt;span style="color:#268bd2">get&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (destroyed) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;The invoker of ReferenceConfig(&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> url &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;) has already destroyed!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//ref类型为 transient volatile T ref;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (ref &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ensure start module, compatible with old api usage&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个前面已经调用了模块发布器启动过了，这里有这么一行代码是有一定作用的，如果使用方直接调用了ReferenceConfigBase的get方法或者缓存对象SimpleReferenceCache类型的对象的get方法来引用服务端的时候就会造成很多配置没有初始化下面执行逻辑的时候出现问题，这个代码其实就是启动模块进行一些基础配置的初始化操作 比如元数据中心默认配置选择，注册中心默认配置选择这些都是比较重要的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getScopeModel().getDeployer().start();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (&lt;span style="color:#719e07">this&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (ref &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> init();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> ref;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里有一段代码是：getScopeModel().getDeployer().start();
这个前面已经调用了模块发布器启动过了，这里有这么一行代码是有一定作用的，如果使用方直接调用了ReferenceConfigBase的get方法或者缓存对象SimpleReferenceCache类型的对象的get方法来引用服务端的时候就会造成很多配置没有初始化下面执行逻辑的时候出现问题，这个代码其实就是启动模块进行一些基础配置的初始化操作 比如元数据中心默认配置选择，注册中心默认配置选择这些都是比较重要的。&lt;/p>
&lt;p>另外可以看到的是这里使用了双重校验锁来保证单例对象的创建，发现Dubbo种大量的使用了双重校验锁的逻辑。&lt;/p>
&lt;h3 id="2142-初始化引用服务">21.4.2 初始化引用服务&lt;/h3>
&lt;p>这个就直接看代码了这，初始化过程相对复杂一点，我们一点点来看
ReferenceConfig类型init()方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#268bd2">synchronized&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">init&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化标记变量保证只初始化一次，这里又是加锁🔐又是加标记变量的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (initialized) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initialized &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//刷新配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>&lt;span style="color:#719e07">this&lt;/span>.isRefreshed()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.refresh();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// init serviceMetadata&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化ServiceMetadata类型对象serviceMetadata 为其设置服务基本属性比如版本号，分组，服务接口名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initServiceMetadata(consumer);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//继续初始化元数据信息 服务接口类型和key&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceMetadata.setServiceType(getServiceInterfaceClass());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// TODO, uncomment this line once service key is unified&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceMetadata.setServiceKey(URL.buildKey(interfaceName, group, version));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置转Map类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&lt;/span> referenceParameters &lt;span style="color:#719e07">=&lt;/span> appendConfig();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// init service-application mapping&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//来自本地存储和url参数的初始化映射。 参数转URL配置初始化 Dubbo中喜欢用url作为配置的一种处理方式&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initServiceAppsMapping(referenceParameters);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//本地内存模块服务存储库&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ModuleServiceRepository repository &lt;span style="color:#719e07">=&lt;/span> getScopeModel().getServiceRepository();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//ServiceModel和ServiceMetadata在某种程度上是相互重复的。我们将来应该合并它们。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServiceDescriptor serviceDescriptor;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CommonConstants.NATIVE_STUB.equals(getProxy())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceDescriptor &lt;span style="color:#719e07">=&lt;/span> StubSuppliers.getServiceDescriptor(interfaceName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repository.registerService(serviceDescriptor);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//本地存储库注册服务接口类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceDescriptor &lt;span style="color:#719e07">=&lt;/span> repository.registerService(interfaceClass);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//消费者模型对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumerModel &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ConsumerModel(serviceMetadata.getServiceKey(), proxy, serviceDescriptor, &lt;span style="color:#719e07">this&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getScopeModel(), serviceMetadata, createAsyncMethodInfo());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//本地存储库注册消费者模型对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repository.registerConsumer(consumerModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//与前面代码一样基础初始化服务元数据对象为其设置附加参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceMetadata.getAttachments().putAll(referenceParameters);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建服务的代理对象 ！！！核心代码在这里&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ref &lt;span style="color:#719e07">=&lt;/span> createProxy(referenceParameters);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//为服务元数据对象设置代理对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceMetadata.setTarget(ref);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceMetadata.addAttribute(PROXY_CLASS_REF, ref);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumerModel.setProxyObject(ref);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumerModel.initMethodModels();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//检查invoker对象初始结果&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkInvokerAvailable();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="215-referenceconfig创建服务引用代理对象的原理">21.5 ReferenceConfig创建服务引用代理对象的原理&lt;/h2>
&lt;h3 id="2151-代理对象的创建过程">21.5.1 代理对象的创建过程&lt;/h3>
&lt;p>这里就要继续看 ReferenceConfig类型的创建代理方法createProxy了
直接贴一下源码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> T &lt;span style="color:#268bd2">createProxy&lt;/span>(Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&lt;/span> referenceParameters) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//本地引用 这里为false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (shouldJvmRefer(referenceParameters)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> createInvokerForLocal(referenceParameters);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> urls.clear();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isNotEmpty(url)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//url存在则为点对点引用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// user specified URL, could be peer-to-peer address, or register center&amp;#39;s address.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parseUrl(referenceParameters);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// if protocols not in jvm checkRegistry&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里不是local协议默认这里为空&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//从注册表中获取URL并将其聚合。这个其实就是初始化一下注册中心的url配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> aggregateUrlFromRegistry(referenceParameters);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个代码非常重要 创建远程引用，创建远程引用调用器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> createInvokerForRemote();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (logger.isInfoEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;Referred dubbo service: [&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> referenceParameters.get(INTERFACE_KEY) &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;].&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (Boolean.parseBoolean(referenceParameters.get(GENERIC_KEY)) &lt;span style="color:#719e07">?&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34; it&amp;#39;s GenericService reference&amp;#34;&lt;/span> : &lt;span style="color:#2aa198">&amp;#34; it&amp;#39;s not GenericService reference&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL consumerUrl &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ServiceConfigURL(CONSUMER_PROTOCOL, referenceParameters.get(REGISTER_IP_KEY), 0,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> referenceParameters.get(INTERFACE_KEY), referenceParameters);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumerUrl &lt;span style="color:#719e07">=&lt;/span> consumerUrl.setScopeModel(getScopeModel());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumerUrl &lt;span style="color:#719e07">=&lt;/span> consumerUrl.setServiceModel(consumerModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MetadataUtils.publishServiceDefinition(consumerUrl, consumerModel.getServiceModel(), getApplicationModel());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// create service proxy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> (T) proxyFactory.getProxy(invoker, ProtocolUtils.isGeneric(generic));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2152-创建远程引用创建远程引用调用器">21.5.2 创建远程引用，创建远程引用调用器&lt;/h3>
&lt;p>ReferenceConfig类型的createInvokerForRemote方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">createInvokerForRemote&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个url 为注册协议如registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-consumer&amp;amp;dubbo=2.0.2&amp;amp;pid=6204&amp;amp;qos.enable=false&amp;amp;qos.port=-1&amp;amp;registry=zookeeper&amp;amp;release=3.0.9&amp;amp;timestamp=1657439419495&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (urls.size() &lt;span style="color:#719e07">==&lt;/span> 1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL curUrl &lt;span style="color:#719e07">=&lt;/span> urls.get(0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个SPI对象是由字节码动态生成的自适应对象Protocol$Adaptie直接看看不到源码，后续可以解析一个字节码生成的类型，这里后续来调用链路即可&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> invoker &lt;span style="color:#719e07">=&lt;/span> protocolSPI.refer(interfaceClass, curUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>UrlUtils.isRegistry(curUrl)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>Invoker&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> invokers &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> invokers.add(invoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> invoker &lt;span style="color:#719e07">=&lt;/span> Cluster.getCluster(scopeModel, Cluster.DEFAULT).join(&lt;span style="color:#719e07">new&lt;/span> StaticDirectory(curUrl, invokers), &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>Invoker&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> invokers &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL registryUrl &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (URL url : urls) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// For multi-registry scenarios, it is not checked whether each referInvoker is available.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Because this invoker may become available later.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> invokers.add(protocolSPI.refer(interfaceClass, url));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (UrlUtils.isRegistry(url)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// use last registry url&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registryUrl &lt;span style="color:#719e07">=&lt;/span> url;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (registryUrl &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// registry url is available&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// for multi-subscription scenario, use &amp;#39;zone-aware&amp;#39; policy by default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String cluster &lt;span style="color:#719e07">=&lt;/span> registryUrl.getParameter(CLUSTER_KEY, ZoneAwareCluster.NAME);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// The invoker wrap sequence would be: ZoneAwareClusterInvoker(StaticDirectory) -&amp;gt; FailoverClusterInvoker&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// (RegistryDirectory, routing happens here) -&amp;gt; Invoker&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> invoker &lt;span style="color:#719e07">=&lt;/span> Cluster.getCluster(registryUrl.getScopeModel(), cluster, &lt;span style="color:#cb4b16">false&lt;/span>).join(&lt;span style="color:#719e07">new&lt;/span> StaticDirectory(registryUrl, invokers), &lt;span style="color:#cb4b16">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// not a registry url, must be direct invoke.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isEmpty(invokers)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException(&lt;span style="color:#2aa198">&amp;#34;invokers == null&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL curUrl &lt;span style="color:#719e07">=&lt;/span> invokers.get(0).getUrl();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String cluster &lt;span style="color:#719e07">=&lt;/span> curUrl.getParameter(CLUSTER_KEY, Cluster.DEFAULT);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> invoker &lt;span style="color:#719e07">=&lt;/span> Cluster.getCluster(scopeModel, cluster).join(&lt;span style="color:#719e07">new&lt;/span> StaticDirectory(curUrl, invokers), &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2153-invoker对象创建的全过程">21.5.3 Invoker对象创建的全过程&lt;/h3>
&lt;p>为了更好理解Protocol$Adaptie内部的引用执行过程这里我把Debug的链路截图了过来
按照固定的顺序先执行AOP的逻辑再执行具体的逻辑:&lt;/p>
&lt;ul>
&lt;li>Protocol$Adaptie的refer方法&lt;/li>
&lt;li>ProtocolSerializationWrapper AOP类型的协议序列化器refer方法&lt;/li>
&lt;li>ProtocolFilterWrapper AOP类型的协议过滤器的refer方法&lt;/li>
&lt;li>QosProtocolWrapper AOP类型的QOS协议包装器的refer方法&lt;/li>
&lt;li>ProtocolListenerWrapper APO类型监听器包装器的refer方法&lt;/li>
&lt;li>RegistryProtocol 注册协议的refer方法 （会添加容错逻辑）&lt;/li>
&lt;li>RegistryProtocol 注册协议的doRefer方法（调用方法创建Invoker对象）&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://cn.dubbo.apache.org/imgs/blog/source-blog/21-createInvokerRemote.png">&lt;/a>&lt;/p>
&lt;p>这里我们不再详细说这个引用链的具体过程直接定位到RegistryProtocol中创建Invoker类型的地方。
先来看RegistryProtocol类型的refer方法，如下代码所示：&lt;/p>
&lt;p>RegistryProtocol类型的refer方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@SuppressWarnings&lt;/span>(&lt;span style="color:#2aa198">&amp;#34;unchecked&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">refer&lt;/span>(Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type, URL url) &lt;span style="color:#268bd2">throws&lt;/span> RpcException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个url已经被转换为具体的注册中心协议类型了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//zookeeper://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-consumer&amp;amp;dubbo=2.0.2&amp;amp;pid=7944&amp;amp;qos.enable=false&amp;amp;qos.port=-1&amp;amp;release=3.0.9&amp;amp;timestamp=1657440673100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url &lt;span style="color:#719e07">=&lt;/span> getRegistryUrl(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取用于操作Zookeeper的Registry类型 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Registry registry &lt;span style="color:#719e07">=&lt;/span> getRegistry(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (RegistryService.class.equals(type)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> proxyFactory.getInvoker((T) registry, type, url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// group=&amp;#34;a,b&amp;#34; or group=&amp;#34;*&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&lt;/span> qs &lt;span style="color:#719e07">=&lt;/span> (Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&lt;/span>) url.getAttribute(REFER_KEY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String group &lt;span style="color:#719e07">=&lt;/span> qs.get(GROUP_KEY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isNotEmpty(group)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> ((COMMA_SPLIT_PATTERN.split(group)).length &lt;span style="color:#719e07">&amp;gt;&lt;/span> 1 &lt;span style="color:#719e07">||&lt;/span> &lt;span style="color:#2aa198">&amp;#34;*&amp;#34;&lt;/span>.equals(group)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> doRefer(Cluster.getCluster(url.getScopeModel(), MergeableCluster.NAME), registry, type, url, qs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//降级容错的逻辑处理对象 类型为Cluster 实际类型为MockClusterWrapper 内部包装的是FailoverCluster&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//后续调用服务失败时候会先失效转移再降级&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Cluster cluster &lt;span style="color:#719e07">=&lt;/span> Cluster.getCluster(url.getScopeModel(), qs.get(CLUSTER_KEY));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里才是具体的Invoker对象的创建&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> doRefer(cluster, registry, type, url, qs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>RegistryProtocol类型的doRefer方法创建Invoker对象
直接来看代码了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">doRefer&lt;/span>(Cluster cluster, Registry registry, Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type, URL url, Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&lt;/span> parameters) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, Object&lt;span style="color:#719e07">&amp;gt;&lt;/span> consumerAttribute &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> HashMap&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(url.getAttributes());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumerAttribute.remove(REFER_KEY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String p &lt;span style="color:#719e07">=&lt;/span> isEmpty(parameters.get(PROTOCOL_KEY)) &lt;span style="color:#719e07">?&lt;/span> CONSUMER : parameters.get(PROTOCOL_KEY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL consumerUrl &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ServiceConfigURL (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#cb4b16">null&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#cb4b16">null&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parameters.get(REGISTER_IP_KEY),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0, getPath(parameters, type),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parameters,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumerAttribute
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url &lt;span style="color:#719e07">=&lt;/span> url.putAttribute(CONSUMER_URL_KEY, consumerUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//重点看这一行 带迁移性质的Invoker对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ClusterInvoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> migrationInvoker &lt;span style="color:#719e07">=&lt;/span> getMigrationInvoker(&lt;span style="color:#719e07">this&lt;/span>, cluster, registry, type, url, consumerUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这一行回来执行迁移规则创建应用级优先的服务发现Invoker对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> interceptInvoker(migrationInvoker, url, consumerUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里代码比较重要的其实只有两行getMigrationInvoker和interceptInvoker方法
比较核心也是Dubbo3比较重要的消费者启动逻辑基本都在这个方法里面interceptInvoker，这个方法执行了消费者应用级发现和接口级发现迁移的逻辑，会自动帮忙决策一个Invoker类型对象，不过这个逻辑这里先简单看下，后续单独整个文章来说。&lt;/p>
&lt;p>这里我们先来看 ClusterInvoker对象的创建，下面先看代码：&lt;/p>
&lt;p>RegistryProtocol类型的getMigrationInvoker方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> ClusterInvoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">getMigrationInvoker&lt;/span>(RegistryProtocol registryProtocol, Cluster cluster, Registry registry, Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type, URL url, URL consumerUrl) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ServiceDiscoveryMigrationInvoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span>(registryProtocol, cluster, registry, type, url, consumerUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>详细的逻辑这里就不再看了，我们继续看RegistryProtocol类型的interceptInvoker方法：&lt;/p>
&lt;p>具体代码如下：
RegistryProtocol类型的interceptInvoker方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">interceptInvoker&lt;/span>(ClusterInvoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> invoker, URL url, URL consumerUrl) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取激活的注册协议监听器扩展里面registry.protocol.listener，这里激活的类型为MigrationRuleListener&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>RegistryProtocolListener&lt;span style="color:#719e07">&amp;gt;&lt;/span> listeners &lt;span style="color:#719e07">=&lt;/span> findRegistryProtocolListeners(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isEmpty(listeners)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> invoker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (RegistryProtocolListener listener : listeners) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里执行MigrationRuleListener类型的onRefer方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> listener.onRefer(&lt;span style="color:#719e07">this&lt;/span>, invoker, consumerUrl, url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> invoker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该方法尝试加载所有RegistryProtocolListener定义，这些定义通过与定义的交互来控制调用器的行为，然后使用这些侦听器更改MigrationInvoker的状态和行为。
当前可用的监听器是MigrationRuleListener，用于通过动态变化的规则控制迁移行为。&lt;/p>
&lt;p>可以看到核心的逻辑集中在了这个位置MigrationRuleListener类型的onRefer方法，这个这里就不深入往下说了，后续会有个文章专门来看Dubbo2迁移Dubbo3时候处理的逻辑。&lt;/p>
&lt;p>Invoker对象的创建完成其实就代表了服务引用执行完成，不过这里核心的协议并没有来说&lt;/p>
&lt;p>原文地址：&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/21-dubbo-xiao-fei-zhe-yin-yong-fu-wu-de-ru-kou/">21-Dubbo3消费者引用服务入口&lt;/a>&lt;/p></description></item><item><title>Blog: 20-Dubbo3服务引用配置ReferenceConfig</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/20/20-dubbo3%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8%E9%85%8D%E7%BD%AEreferenceconfig/</link><pubDate>Sat, 20 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/20/20-dubbo3%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8%E9%85%8D%E7%BD%AEreferenceconfig/</guid><description>
&lt;h1 id="20-dubbo3服务引用配置referenceconfig">20-Dubbo3服务引用配置ReferenceConfig&lt;/h1>
&lt;h2 id="201-简介">20.1 简介&lt;/h2>
&lt;p>前面简单介绍了一下消费者的例子，消费者创建的第一步就是先进行消费者信息的配置对应类型为ReferenceConfig，这里详细来看ReferenceConfig包含哪些信息？先简单了解下消费者配置的类型关系如下图所示：引用配置与服务配置类型都是通过继承接口配置来扩展的，在分析生产者的时候详细介绍过服务相关的配置，这里来详细看消费者引用者的相关配置信息.
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/20-refe.png" alt="在这里插入图片描述">&lt;/p>
&lt;p>前面例子说了消费者配置对象的创建主要是通过如下代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ReferenceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>DemoService&lt;span style="color:#719e07">&amp;gt;&lt;/span> reference &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ReferenceConfig&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个配置类型的对象创建过程并没有太多的逻辑这里主要来说下各种配置信息：
服务消费者引用服务配置。对应的配置类： &lt;code>org.apache.dubbo.config.ReferenceConfig&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>id&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>&lt;strong>必填&lt;/strong>&lt;/td>
&lt;td>&lt;/td>
&lt;td>配置关联&lt;/td>
&lt;td>服务引用BeanId&lt;/td>
&lt;td>1.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>interface&lt;/td>
&lt;td>&lt;/td>
&lt;td>class&lt;/td>
&lt;td>&lt;strong>必填&lt;/strong>&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务接口名&lt;/td>
&lt;td>1.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>version&lt;/td>
&lt;td>version&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务版本，与服务提供者的版本一致&lt;/td>
&lt;td>1.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>group&lt;/td>
&lt;td>group&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务分组，当一个接口有多个实现，可以用分组区分，必需和服务提供方一致&lt;/td>
&lt;td>1.0.7以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>timeout&lt;/td>
&lt;td>timeout&lt;/td>
&lt;td>long&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省使用&lt;a href="dubbo:consumer">dubbo:consumer&lt;/a>的timeout&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务方法调用超时时间(毫秒)&lt;/td>
&lt;td>1.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>retries&lt;/td>
&lt;td>retries&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省使用&lt;a href="dubbo:consumer">dubbo:consumer&lt;/a>的retries&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>远程服务调用重试次数，不包括第一次调用，不需要重试请设为0&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>connections&lt;/td>
&lt;td>connections&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省使用&lt;a href="dubbo:consumer">dubbo:consumer&lt;/a>的connections&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>对每个提供者的最大连接数，rmi、http、hessian等短连接协议表示限制连接数，dubbo等长连接协表示建立的长连接个数&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>loadbalance&lt;/td>
&lt;td>loadbalance&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省使用&lt;a href="dubbo:consumer">dubbo:consumer&lt;/a>的loadbalance&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>async&lt;/td>
&lt;td>async&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省使用&lt;a href="dubbo:consumer">dubbo:consumer&lt;/a>的async&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>是否异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>generic&lt;/td>
&lt;td>generic&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省使用&lt;a href="dubbo:consumer">dubbo:consumer&lt;/a>的generic&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>是否缺省泛化接口，如果为泛化接口，将返回GenericService&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>check&lt;/td>
&lt;td>check&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省使用&lt;a href="dubbo:consumer">dubbo:consumer&lt;/a>的check&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>启动时检查提供者是否存在，true报错，false忽略&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>url&lt;/td>
&lt;td>url&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>点对点直连服务提供者地址，将绕过注册中心&lt;/td>
&lt;td>1.0.6以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>stub&lt;/td>
&lt;td>stub&lt;/td>
&lt;td>class/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务接口客户端本地代理类名，用于在客户端执行本地逻辑，如本地缓存等，该本地代理类的构造函数必须允许传入远程代理对象，构造函数如：public XxxServiceLocal(XxxService xxxService)&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>mock&lt;/td>
&lt;td>mock&lt;/td>
&lt;td>class/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务接口调用失败Mock实现类名，该Mock类必须有一个无参构造函数，与Local的区别在于，Local总是被执行，而Mock只在出现非业务异常(比如超时，网络异常等)时执行，Local在远程调用之前执行，Mock在远程调用后执行。&lt;/td>
&lt;td>Dubbo1.0.13及其以上版本支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cache&lt;/td>
&lt;td>cache&lt;/td>
&lt;td>string/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>以调用参数为key，缓存返回结果，可选：lru, threadlocal, jcache等&lt;/td>
&lt;td>Dubbo2.1.0及其以上版本支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>validation&lt;/td>
&lt;td>validation&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>是否启用JSR303标准注解验证，如果启用，将对方法参数上的注解进行校验&lt;/td>
&lt;td>Dubbo2.1.0及其以上版本支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>proxy&lt;/td>
&lt;td>proxy&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>javassist&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>选择动态代理实现策略，可选：javassist, jdk&lt;/td>
&lt;td>2.0.2以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>client&lt;/td>
&lt;td>client&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>客户端传输类型设置，如Dubbo协议的netty或mina。&lt;/td>
&lt;td>Dubbo2.0.0以上版本支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>registry&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省将从所有注册中心获服务列表后合并结果&lt;/td>
&lt;td>配置关联&lt;/td>
&lt;td>从指定注册中心注册获取服务列表，在多个注册中心时使用，值为&lt;a href="dubbo:registry">dubbo:registry&lt;/a>的id属性，多个注册中心ID用逗号分隔&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>owner&lt;/td>
&lt;td>owner&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>调用服务负责人，用于服务治理，请填写负责人公司邮箱前缀&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>actives&lt;/td>
&lt;td>actives&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>每服务消费者每服务每方法最大并发调用数&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cluster&lt;/td>
&lt;td>cluster&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>failover&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>集群方式，可选：failover/failfast/failsafe/failback/forking&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>filter&lt;/td>
&lt;td>reference.filter&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>default&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务消费方远程调用过程拦截器名称，多个名称用逗号分隔&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>listener&lt;/td>
&lt;td>invoker.listener&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>default&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务消费方引用服务监听器名称，多个名称用逗号分隔&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>layer&lt;/td>
&lt;td>layer&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务调用者所在的分层。如：biz、dao、intl:web、china:acton。&lt;/td>
&lt;td>2.0.7以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>init&lt;/td>
&lt;td>init&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>是否在afterPropertiesSet()时饥饿初始化引用，否则等到有人注入或引用该实例时再初始化。&lt;/td>
&lt;td>2.0.10以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>protocol&lt;/td>
&lt;td>protocol&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>只调用指定协议的服务提供方，其它协议忽略。&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>原文地址：&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/20-dubbo3-fu-wu-yin-yong-pei-zhi-referenceconfig/">20-Dubbo3服务引用配置ReferenceConfig&lt;/a>&lt;/p></description></item><item><title>Blog: 19 重新来过从一个服务消费者的Demo说起</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/19/19-%E9%87%8D%E6%96%B0%E6%9D%A5%E8%BF%87%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84demo%E8%AF%B4%E8%B5%B7/</link><pubDate>Fri, 19 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/19/19-%E9%87%8D%E6%96%B0%E6%9D%A5%E8%BF%87%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84demo%E8%AF%B4%E8%B5%B7/</guid><description>
&lt;h1 id="19-重新来过从一个服务消费者的demo说起">19 重新来过从一个服务消费者的Demo说起&lt;/h1>
&lt;p>为了更方便了解原理,我们先来编写一个Demo,从例子中来看源码实现:，前面说了提供者现在已经有服务注册上去了，那接下来我们编写一个消费者的例子来进行服务发现与服务RPC调用。&lt;/p>
&lt;h2 id="191-启动zookeeper">19.1 启动Zookeeper&lt;/h2>
&lt;p>为了Demo可以正常启动,需要我们先在本地启动一个Zookeeper如下图所示:
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/19-zk.png" alt="在这里插入图片描述">&lt;/p>
&lt;h2 id="192-服务消费者">19.2 服务消费者&lt;/h2>
&lt;p>接下来给大家贴一下示例源码,这个源码来源于Dubbo源码目录的 dubbo-demo/dubbo-demo-api 目录下面的dubbo-demo-api-consumer子项目,这里我做了删减,方便看核心代码:
首先我们定义一个服务接口如下所示:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> java.util.concurrent.CompletableFuture;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">DemoService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * 同步处理的服务方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param name
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @return
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String &lt;span style="color:#268bd2">sayHello&lt;/span>(String name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * 用于异步处理的服务方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param name
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @return
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">default&lt;/span> CompletableFuture&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">sayHelloAsync&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> CompletableFuture.completedFuture(sayHello(name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>服务实现类如下:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.RpcContext;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.slf4j.Logger;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.slf4j.LoggerFactory;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> java.util.concurrent.CompletableFuture;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">DemoServiceImpl&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> DemoService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#268bd2">final&lt;/span> Logger logger &lt;span style="color:#719e07">=&lt;/span> LoggerFactory.getLogger(DemoServiceImpl.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> String &lt;span style="color:#268bd2">sayHello&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;Hello &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> name &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, request from consumer: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> RpcContext.getServiceContext().getRemoteAddress());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Hello &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> name &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, response from provider: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> RpcContext.getServiceContext().getLocalAddress();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> CompletableFuture&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">sayHelloAsync&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="193-启用服务消费者">19.3 启用服务消费者&lt;/h2>
&lt;p>有了服务接口之后我们来启用服务,启用服务的源码如下:
这里如果要启动消费者,主要要修改QOS端口这里我已经配置可以直接复用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">package&lt;/span> link.elastic.dubbo.consumer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> link.elastic.dubbo.entity.DemoService;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.common.constants.CommonConstants;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.config.ApplicationConfig;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.config.MetadataReportConfig;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.config.ProtocolConfig;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.config.ReferenceConfig;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.config.RegistryConfig;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.config.bootstrap.DubboBootstrap;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.service.GenericService;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">ConsumerApplication&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>(String&lt;span style="color:#719e07">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> runWithBootstrap();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">runWithBootstrap&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ReferenceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>DemoService&lt;span style="color:#719e07">&amp;gt;&lt;/span> reference &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ReferenceConfig&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reference.setInterface(DemoService.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reference.setGeneric(&lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reference.setProtocol(&lt;span style="color:#2aa198">&amp;#34;&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DubboBootstrap bootstrap &lt;span style="color:#719e07">=&lt;/span> DubboBootstrap.getInstance();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ApplicationConfig applicationConfig &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ApplicationConfig(&lt;span style="color:#2aa198">&amp;#34;dubbo-demo-api-consumer&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationConfig.setQosEnable(&lt;span style="color:#cb4b16">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationConfig.setQosPort(&lt;span style="color:#719e07">-&lt;/span>1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bootstrap.application(applicationConfig)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .registry(&lt;span style="color:#719e07">new&lt;/span> RegistryConfig(&lt;span style="color:#2aa198">&amp;#34;zookeeper://8.131.79.126:2181&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .protocol(&lt;span style="color:#719e07">new&lt;/span> ProtocolConfig(CommonConstants.DUBBO, &lt;span style="color:#719e07">-&lt;/span>1))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .reference(reference)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .start();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DemoService demoService &lt;span style="color:#719e07">=&lt;/span> bootstrap.getCache().get(reference);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String message &lt;span style="color:#719e07">=&lt;/span> demoService.sayHello(&lt;span style="color:#2aa198">&amp;#34;dubbo&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.out.println(message);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// generic invoke&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GenericService genericService &lt;span style="color:#719e07">=&lt;/span> (GenericService) demoService;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object genericInvokeResult &lt;span style="color:#719e07">=&lt;/span> genericService.$invoke(&lt;span style="color:#2aa198">&amp;#34;sayHello&amp;#34;&lt;/span>, &lt;span style="color:#719e07">new&lt;/span> String&lt;span style="color:#719e07">[]&lt;/span>{String.class.getName()},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">new&lt;/span> Object&lt;span style="color:#719e07">[]&lt;/span>{&lt;span style="color:#2aa198">&amp;#34;dubbo generic invoke&amp;#34;&lt;/span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.out.println(genericInvokeResult);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="14-启用服务后写入zookeeper的节点数据">1.4 启用服务后写入Zookeeper的节点数据&lt;/h2>
&lt;p>启动服务,这个时候我们打开Zookeeper图形化客户端来看看这个服务在Zookeeper上面写入来哪些数据,如下图:
在这里插入图片描述
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/19-zk2.png" alt="在这里插入图片描述">&lt;/p>
&lt;p>写入Zookeper上的节点用于服务在分布式场景下的协调,这些节点是比较重要的。&lt;/p>
&lt;p>如果了解过Dubbo的同学,应该会知道Dubbo在低版本的时候会向注册中心中写入服务接口,具体路径在上面的 &lt;strong>dubbo目录下&lt;/strong> ,然后在 &lt;strong>/dubbo/服务接口/&lt;/strong> 路径下写入如下信息:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>服务提供者&lt;/strong>配置信息URL形式&lt;/li>
&lt;li>&lt;strong>服务消费者&lt;/strong>的配置信息URL形式&lt;/li>
&lt;li>服务&lt;strong>路由信息&lt;/strong>&lt;/li>
&lt;li>&lt;strong>配置信息&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>上面这个图就是Dubbo3的注册信息了,后面我们也会围绕细节来说明下,这里可以看下新增了:&lt;/p>
&lt;ul>
&lt;li>/dubbo/metadata &lt;strong>元数据信息&lt;/strong>&lt;/li>
&lt;li>/dubbo/mapping 服务和应用的&lt;strong>映射信息&lt;/strong>&lt;/li>
&lt;li>/dubbo/config &lt;strong>注册中心配置&lt;/strong>&lt;/li>
&lt;li>/services目录&lt;strong>应用信息&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>在这里可以大致了解下,在后面会有更详细的源码解析这个示例代码.通过透析代码来看透Dubbo3服务注册原理,服务提供原理。&lt;/p>
&lt;p>原文地址：&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/19-chong-xin-lai-guo-cong-yi-ge-fu-wu-xiao-fei-zhe-de-demo-shuo-qi/">19-重新来过从一个服务消费者的Demo说起&lt;/a>&lt;/p></description></item><item><title>Blog: 18-Dubbo3元数据服务MetadataService的导出</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/18/18-dubbo3%E5%85%83%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1metadataservice%E7%9A%84%E5%AF%BC%E5%87%BA/</link><pubDate>Thu, 18 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/18/18-dubbo3%E5%85%83%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1metadataservice%E7%9A%84%E5%AF%BC%E5%87%BA/</guid><description>
&lt;h1 id="18-dubbo3元数据服务metadataservice的导出">18-Dubbo3元数据服务MetadataService的导出&lt;/h1>
&lt;h2 id="181-简介">18.1 简介&lt;/h2>
&lt;p>MetadataService
此服务用于公开Dubbo进程内的元数据信息。典型用途包括：&lt;/p>
&lt;ul>
&lt;li>使用者查询提供者的元数据信息，以列出接口和每个接口的配置&lt;/li>
&lt;li>控制台（dubbo admin）查询特定进程的元数据，或聚合所有进程的数据。在Dubbo2.x的时候，所有的服务数据都是以接口的形式注册在注册中心.&lt;/li>
&lt;/ul>
&lt;p>Dubbo3将部分数据抽象为元数据的形式来将数据存放在元数据中心，然后元数据由服务提供者提供给消费者而不是再由注册中心进行推送，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/18-metadata.png" alt="在这里插入图片描述">&lt;/p>
&lt;p>&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/18-metadata3.png" alt="在这里插入图片描述">
引入 MetadataService 元数据服务服务的好处
• 由中心化推送转向点对点拉取（Consumer - Proroder）
• 易于扩展更多的参数
• 更多的数据量
• 对外暴露更多的治理数据&lt;/p>
&lt;h2 id="182-metadataservice的导出过程">18.2 MetadataService的导出过程&lt;/h2>
&lt;p>了解元数据的到处过程，这个就要继续前面博客往后的代码了前面博客说了一个服务发布之后的服务信息的双注册数据，这里继续看下导出服务之后的代码：
先来简单回顾下模块发布的启动生命周期方法：&lt;/p>
&lt;p>DefaultModuleDeployer类型的start方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">synchronized&lt;/span> Future &lt;span style="color:#268bd2">start&lt;/span>() &lt;span style="color:#268bd2">throws&lt;/span> IllegalStateException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> onModuleStarting();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// initialize&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationDeployer.initialize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initialize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// export services&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exportServices();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// prepare application instance&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// exclude internal module to avoid wait itself&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (moduleModel &lt;span style="color:#719e07">!=&lt;/span> moduleModel.getApplicationModel().getInternalModule()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationDeployer.prepareInternalModule();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// refer services&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> referServices();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// if no async export/refer services, just set started&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (asyncExportingFutures.isEmpty() &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> asyncReferringFutures.isEmpty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> onModuleStarted();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ....
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> startFuture;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前面的博客我们已经说了服务提供者导出服务的方法如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// export services&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exportServices();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在导出服务之后如果代码中配置了引用服务的代码将会执行引用服务的功能，调用代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>referServices();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不过我们样例代码并没有介绍引用服务的功能，这里先不说，等服务提供者完全启动成功之后我们再来看消费者的逻辑。&lt;/p>
&lt;p>接下来我们要看的是模块启动成功之后的方法 onModuleStarted();，在这个方法中会去发布服务元数据信息。&lt;/p>
&lt;h2 id="183-模块启动成功时候的逻辑-onmodulestarted">18.3 模块启动成功时候的逻辑 onModuleStarted();&lt;/h2>
&lt;p>这里我们直接先看代码再来分析下逻辑：&lt;/p>
&lt;p>DefaultModuleDeployer类型的onModuleStarted方法如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">onModuleStarted&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//状态判断是否为启动中如果是则将状态设置为STARTED&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (isStarting()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//先修改状态&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setStarted();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(getIdentifier() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; has started.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//状态修改成功之后开始通知应用程序发布器模块发布器启动成功了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationDeployer.notifyModuleChanged(moduleModel, DeployState.STARTED);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// complete module start future after application state changed&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> completeStartFuture(&lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>应用程序发布器处理启动成功的逻辑：
DefaultApplicationDeployer类型的notifyModuleChanged方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">notifyModuleChanged&lt;/span>(ModuleModel moduleModel, DeployState state) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//根据所有模块的状态来判断应用发布器的状态&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkState(moduleModel, state);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// notify module state changed or module changed&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//通知所有模块状态更新&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (stateLock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stateLock.notifyAll();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>应用发布器模型DefaultApplicationDeployer检查状态方法checkState代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">checkState&lt;/span>(ModuleModel moduleModel, DeployState moduleState) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//存在写操作 先加个锁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (stateLock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//非内部模块，并且模块的状态是发布成功了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>moduleModel.isInternal() &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> moduleState &lt;span style="color:#719e07">==&lt;/span> DeployState.STARTED) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prepareApplicationInstance();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//应用下所有模块状态进行汇总计算&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DeployState newState &lt;span style="color:#719e07">=&lt;/span> calculateState();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">switch&lt;/span> (newState) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">case&lt;/span> STARTED:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> onStarted();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">case&lt;/span> STARTING:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> onStarting();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">case&lt;/span> STOPPING:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> onStopping();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">case&lt;/span> STOPPED:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> onStopped();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">case&lt;/span> FAILED:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Throwable error &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ModuleModel errorModule &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (ModuleModel module : applicationModel.getModuleModels()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ModuleDeployer deployer &lt;span style="color:#719e07">=&lt;/span> module.getDeployer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (deployer.isFailed() &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> deployer.getError() &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> error &lt;span style="color:#719e07">=&lt;/span> deployer.getError();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> errorModule &lt;span style="color:#719e07">=&lt;/span> module;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> onFailed(getIdentifier() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; found failed module: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> errorModule.getDesc(), error);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">case&lt;/span> PENDING:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// cannot change to pending from other state&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// setPending();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="184-准备发布元数据信息和应用实例信息">18.4 准备发布元数据信息和应用实例信息&lt;/h2>
&lt;p>前面有个代码调用比较重要：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>prepareApplicationInstance()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>DefaultApplicationDeployer类型的prepareApplicationInstance方法如下所示&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">prepareApplicationInstance&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//已经注册过应用实例数据了 直接返回 （下面CAS逻辑判断了）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (hasPreparedApplicationInstance.get()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注册开关控制默认为true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//通过将registerConsumer默认设置为“false”来关闭纯使用者进程实例的注册。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (isRegisterConsumerInstance()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exportMetadataService();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (hasPreparedApplicationInstance.compareAndSet(&lt;span style="color:#cb4b16">false&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// register the local ServiceInstance if required&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registerServiceInstance();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1841-导出元数据服务方法exportmetadataservice">18.4.1 导出元数据服务方法exportMetadataService&lt;/h3>
&lt;p>这里我们就先直接来贴一下代码：&lt;/p>
&lt;p>DefaultApplicationDeployer类型的exportMetadataService方法如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">exportMetadataService&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>isStarting()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里监听器我们主要关注的类型是ExporterDeployListener类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (DeployListener&lt;span style="color:#719e07">&amp;lt;&lt;/span>ApplicationModel&lt;span style="color:#719e07">&amp;gt;&lt;/span> listener : listeners) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (listener &lt;span style="color:#719e07">instanceof&lt;/span> ApplicationDeployListener) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 回调监听器的模块启动成功方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ((ApplicationDeployListener) listener).onModuleStarted(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(getIdentifier() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; an exception occurred when handle starting event&amp;#34;&lt;/span>, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前面我们主要关注ExporterDeployListener类型的监听器的回调方法，这里我贴一下代码：
ExporterDeployListener类型的onModuleStarted方法如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">synchronized&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">onModuleStarted&lt;/span>(ApplicationModel applicationModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// start metadata service exporter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//MetadataServiceDelegation类型为实现提供远程RPC服务以方便元数据信息的查询功能的类型。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MetadataServiceDelegation metadataService &lt;span style="color:#719e07">=&lt;/span> applicationModel.getBeanFactory().getOrRegisterBean(MetadataServiceDelegation.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (metadataServiceExporter &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataServiceExporter &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ConfigurableMetadataServiceExporter(applicationModel, metadataService);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// fixme, let&amp;#39;s disable local metadata service export at this moment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//默认我们是没有配置这个元数据类型的这里元数据类型默认为local 条件是不是remote则开始导出，在前面的博客&amp;lt;&amp;lt;Dubbo启动器DubboBootstrap添加应用程序的配置信息ApplicationConfig&amp;gt;&amp;gt; 中有提到这个配置下面我再说下&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>REMOTE_METADATA_STORAGE_TYPE.equals(getMetadataType(applicationModel))) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataServiceExporter.export();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在前面的博客&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/9-dubbo-qi-dong-qi-dubbobootstrap-tian-jia-ying-yong-cheng-xu-de-pei-zhi-xin-xi-applicationconfig/">&amp;laquo;Dubbo启动器DubboBootstrap添加应用程序的配置信息ApplicationConfig&amp;raquo;&lt;/a> 中有提到这个配置下面我再说下&lt;/p>
&lt;p>metadata-type&lt;/p>
&lt;p>metadata 传递方式，是以 Provider 视角而言的，Consumer 侧配置无效，可选值有：&lt;/p>
&lt;ul>
&lt;li>remote - Provider 把 metadata 放到远端&lt;strong>注册中心&lt;/strong>，Consumer 从&lt;strong>注册中心获取&lt;/strong>。&lt;/li>
&lt;li>local - Provider &lt;strong>把 metadata 放在本地&lt;/strong>，&lt;strong>Consumer 从 Provider 处直接获取&lt;/strong> 。&lt;/li>
&lt;/ul>
&lt;p>可以看到默认的local配置元数据信息的获取是由消费者从提供者拉的，那提供者怎么拉取对应服务的元数据信息那就要要用到这个博客说到的MetadataService服务，传递方式为remote的方式其实就要依赖注册中心了相对来说增加了注册中心的压力。&lt;/p>
&lt;h3 id="1842-可配置元数据服务的导出configurablemetadataserviceexporter的export">18.4.2 可配置元数据服务的导出ConfigurableMetadataServiceExporter的export&lt;/h3>
&lt;p>前面了解了导出服务的调用链路，这里详细看下ConfigurableMetadataServiceExporter的export过程源码如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">synchronized&lt;/span> ConfigurableMetadataServiceExporter &lt;span style="color:#268bd2">export&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//元数据服务配置已经存在或者已经导出或者不可导出情况下是无需导出的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (serviceConfig &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> &lt;span style="color:#719e07">!&lt;/span>isExported()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建服务配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.serviceConfig &lt;span style="color:#719e07">=&lt;/span> buildServiceConfig();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// export&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//导出服务 ,导出服务的具体过程这里就不再说了可以看上一个博客，这个导出服务的过程会绑定端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceConfig.export();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataService.setMetadataURL(serviceConfig.getExportedUrls().get(0));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (logger.isInfoEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;The MetadataService exports urls : &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> serviceConfig.getExportedUrls());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (logger.isWarnEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(&lt;span style="color:#2aa198">&amp;#34;The MetadataService has been exported : &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> serviceConfig.getExportedUrls());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1843-元数据服务配置对象的创建">18.4.3 元数据服务配置对象的创建&lt;/h3>
&lt;p>前面我们看到了构建元数据服务对象的代码调用ServiceConfig&lt;MetadataService>，接下来我们详细看下构建源码如下所示：
ConfigurableMetadataServiceExporter类型的buildServiceConfig构建元数据服务配置对象方法如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> ServiceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>MetadataService&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">buildServiceConfig&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//1 获取当前的应用配置 然后初始化应用配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ApplicationConfig applicationConfig &lt;span style="color:#719e07">=&lt;/span> getApplicationConfig();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建服务配置对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServiceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>MetadataService&lt;span style="color:#719e07">&amp;gt;&lt;/span> serviceConfig &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ServiceConfig&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//设置域模型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceConfig.setScopeModel(applicationModel.getInternalModule());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceConfig.setApplication(applicationConfig);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//2 创建注册中心配置对象 然后并初始化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RegistryConfig registryConfig &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> RegistryConfig(&lt;span style="color:#2aa198">&amp;#34;N/A&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registryConfig.setId(&lt;span style="color:#2aa198">&amp;#34;internal-metadata-registry&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//3 创建服务配置对象，并初始化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceConfig.setRegistry(registryConfig);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceConfig.setRegister(&lt;span style="color:#cb4b16">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//4 生成协议配置 ，这里会配置一下元数据使用的服务端口号默认使用其他服务的端口20880&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceConfig.setProtocol(generateMetadataProtocol());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceConfig.setInterface(MetadataService.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceConfig.setDelay(0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里也是需要注意的地方服务引用的类型为MetadataServiceDelegation&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceConfig.setRef(metadataService);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceConfig.setGroup(applicationConfig.getName());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceConfig.setVersion(MetadataService.VERSION);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//5 生成方法配置 这里目前提供的服务方法为getAndListenInstanceMetadata方法 后续可以看下这个方法的视线&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceConfig.setMethods(generateMethodConfig());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceConfig.setConnections(1); &lt;span style="color:#586e75">// separate connection&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceConfig.setExecutes(100); &lt;span style="color:#586e75">// max tasks running at the same time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> serviceConfig;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个服务配置对象的创建非常像我们第一个博客提到的服务配置过程，不过这个元数据服务对象有几个比较特殊的配置&lt;/p>
&lt;ul>
&lt;li>注册中心的配置register设置为了false 则为不向注册中心注册具体的服务配置信息&lt;/li>
&lt;li>对每个提供者的最大连接数connections为1&lt;/li>
&lt;li>服务提供者每服务每方法最大可并行执行请求数executes为100&lt;/li>
&lt;/ul>
&lt;p>在使用过程中可以知道上面这几个配置值&lt;/p>
&lt;h2 id="185-应用级数据注册---registerserviceinstance">18.5 应用级数据注册 registerServiceInstance()&lt;/h2>
&lt;p>在前面导出元数据服务之后也会调用一行代码来注册应用级数据来保证应用上线&lt;/p>
&lt;p>主要涉及到的代码为DefaultApplicationDeployer类型中的registerServiceInstance方法如下所示&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">registerServiceInstance&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//标记变量设置为true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registered &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServiceInstanceMetadataUtils.registerMetadataAndInstance(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(&lt;span style="color:#2aa198">&amp;#34;Register instance error&amp;#34;&lt;/span>, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (registered) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// scheduled task for updating Metadata and ServiceInstance&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> asyncMetadataFuture &lt;span style="color:#719e07">=&lt;/span> frameworkExecutorRepository.getSharedScheduledExecutor().scheduleWithFixedDelay(() &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ignore refresh metadata on stopping&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (applicationModel.isDestroyed()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>applicationModel.isDestroyed() &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> registered) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServiceInstanceMetadataUtils.refreshMetadataAndInstance(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>applicationModel.isDestroyed()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(&lt;span style="color:#2aa198">&amp;#34;Refresh instance and metadata error&amp;#34;&lt;/span>, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, 0, ConfigurationUtils.get(applicationModel, METADATA_PUBLISH_DELAY_KEY, DEFAULT_METADATA_PUBLISH_DELAY), TimeUnit.MILLISECONDS);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个方法先将应用元数据注册到注册中心，然后开始开启定时器每隔30秒同步一次元数据向注册中心。&lt;/p>
&lt;h3 id="1851-服务实例元数据工具类注册服务发现的元数据信息">18.5.1 服务实例元数据工具类注册服务发现的元数据信息&lt;/h3>
&lt;p>前面通过调用类型ServiceInstanceMetadataUtils工具类的registerMetadataAndInstance方法来进行服务实例数据和元数据的注册这里我们详细看下代码如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">registerMetadataAndInstance&lt;/span>(ApplicationModel applicationModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOGGER.info(&lt;span style="color:#2aa198">&amp;#34;Start registering instance address to registry.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RegistryManager registryManager &lt;span style="color:#719e07">=&lt;/span> applicationModel.getBeanFactory().getBean(RegistryManager.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// register service instance&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//注意这里服务发现的类型只有ServiceDiscoveryRegistry类型的注册协议才满足 registryManager.getServiceDiscoveries().forEach(ServiceDiscovery::register);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1852-abstractservicediscovery中的服务发现数据注册的模版方法">18.5.2 AbstractServiceDiscovery中的服务发现数据注册的模版方法&lt;/h3>
&lt;p>AbstractServiceDiscovery类型的注册方法register()方法这个是一个模版方法，真正执行的注册逻辑封装在了doRegister方法中由扩展的服务发现子类来完成&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">synchronized&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">register&lt;/span>() &lt;span style="color:#268bd2">throws&lt;/span> RuntimeException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//第一步创建应用的实例信息等待下面注册到注册中心&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.serviceInstance &lt;span style="color:#719e07">=&lt;/span> createServiceInstance(&lt;span style="color:#719e07">this&lt;/span>.metadataInfo);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>isValidInstance(&lt;span style="color:#719e07">this&lt;/span>.serviceInstance)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(&lt;span style="color:#2aa198">&amp;#34;No valid instance found, stop registering instance address to registry.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//是否需要更新&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">boolean&lt;/span> revisionUpdated &lt;span style="color:#719e07">=&lt;/span> calOrUpdateInstanceRevision(&lt;span style="color:#719e07">this&lt;/span>.serviceInstance);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (revisionUpdated) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reportMetadata(&lt;span style="color:#719e07">this&lt;/span>.metadataInfo);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//应用的实例信息注册到注册中心之上 ，这个&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doRegister(&lt;span style="color:#719e07">this&lt;/span>.serviceInstance);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1853-应用级实例对象创建">18.5.3 应用级实例对象创建&lt;/h3>
&lt;p>可以看到在AbstractServiceDiscovery服务发现的第一步创建应用的实例信息等待下面注册到注册中心&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">this&lt;/span>.serviceInstance &lt;span style="color:#719e07">=&lt;/span> createServiceInstance(&lt;span style="color:#719e07">this&lt;/span>.metadataInfo);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最终创建的serviceInstance类型为ServiceInstance 这个是Dubbo封装的一个接口，具体实现类型为DefaultServiceInstance，我们可以看下应用级的元数据有哪些&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> ServiceInstance &lt;span style="color:#268bd2">createServiceInstance&lt;/span>(MetadataInfo metadataInfo) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里的服务名字为：dubbo-demo-api-provider&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DefaultServiceInstance instance &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> DefaultServiceInstance(serviceName, applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//应用服务的元数据 ，可以看下面debug的数据信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instance.setServiceMetadata(metadataInfo);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//metadataType的值为local 这个方法是将元数据类型存储到英勇的元数据对象中 对应内容为dubbo.metadata.storage-type:local&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setMetadataStorageType(instance, metadataType);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 这个是自定义元数据数据 我们也可以通过实现扩展ServiceInstanceCustomizer来自定义一些元数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServiceInstanceMetadataUtils.customizeInstance(instance, applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> instance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个方法的主要目的就是将应用的元数据信息都封装到ServiceInstance类型中，不过额外提供了一个扩展性比较好的方法可以自定义元数据信息&lt;/p>
&lt;p>前面的metadataInfo对象的信息如下图所示：
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/18-metadata2.png" alt="在这里插入图片描述">&lt;/p>
&lt;p>自定义元数据类型Dubbo官方提供了一个默认的实现类型为：ServiceInstanceMetadataCustomizer&lt;/p>
&lt;p>最终封装好的元数据信息如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>DefaultServiceInstance{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>serviceName&lt;span style="color:#719e07">=&lt;/span>&amp;#39;dubbo&lt;span style="color:#719e07">-&lt;/span>demo&lt;span style="color:#719e07">-&lt;/span>api&lt;span style="color:#719e07">-&lt;/span>provider&amp;#39;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>host&lt;span style="color:#719e07">=&lt;/span>&amp;#39;192.168.1.169&amp;#39;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>port&lt;span style="color:#719e07">=&lt;/span>20880,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>enabled&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#cb4b16">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>healthy&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#cb4b16">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadata&lt;span style="color:#719e07">=&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dubbo.metadata&lt;span style="color:#719e07">-&lt;/span>service.url&lt;span style="color:#719e07">-&lt;/span>params&lt;span style="color:#719e07">=&lt;/span>{&lt;span style="color:#2aa198">&amp;#34;connections&amp;#34;&lt;/span>:&lt;span style="color:#2aa198">&amp;#34;1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;version&amp;#34;&lt;/span>:&lt;span style="color:#2aa198">&amp;#34;1.0.0&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;dubbo&amp;#34;&lt;/span>:&lt;span style="color:#2aa198">&amp;#34;2.0.2&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;release&amp;#34;&lt;/span>:&lt;span style="color:#2aa198">&amp;#34;3.0.9&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;side&amp;#34;&lt;/span>:&lt;span style="color:#2aa198">&amp;#34;provider&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;port&amp;#34;&lt;/span>:&lt;span style="color:#2aa198">&amp;#34;20880&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;protocol&amp;#34;&lt;/span>:&lt;span style="color:#2aa198">&amp;#34;dubbo&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dubbo.endpoints&lt;span style="color:#719e07">=[&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#2aa198">&amp;#34;port&amp;#34;&lt;/span>:20880,&lt;span style="color:#2aa198">&amp;#34;protocol&amp;#34;&lt;/span>:&lt;span style="color:#2aa198">&amp;#34;dubbo&amp;#34;&lt;/span>}&lt;span style="color:#719e07">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dubbo.metadata.storage&lt;span style="color:#719e07">-&lt;/span>type&lt;span style="color:#719e07">=&lt;/span>local,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> timestamp&lt;span style="color:#719e07">=&lt;/span>1656227493387}}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1854-应用级实例数据配置变更的的版本号获取">18.5.4 应用级实例数据配置变更的的版本号获取&lt;/h3>
&lt;p>前面创建元应用的实例信息后开始创建版本号来判断是否需要更新，对应AbstractServiceDiscovery类型的calOrUpdateInstanceRevision&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#dc322f">boolean&lt;/span> &lt;span style="color:#268bd2">calOrUpdateInstanceRevision&lt;/span>(ServiceInstance instance) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取元数据版本号对应字段dubbo.metadata.revision&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String existingInstanceRevision &lt;span style="color:#719e07">=&lt;/span> getExportedServicesRevision(instance);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取实例的服务元数据信息：metadata{app=&amp;#39;dubbo-demo-api-provider&amp;#39;,revision=&amp;#39;null&amp;#39;,size=1,services=[link.elastic.dubbo.entity.DemoService:dubbo]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MetadataInfo metadataInfo &lt;span style="color:#719e07">=&lt;/span> instance.getServiceMetadata();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//必须在不同线程之间同步计算此实例的状态，如同一实例的修订和修改。此方法的使用仅限于某些点，例如在注册期间。始终尝试使用此选项。改为getRevision（）。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String newRevision &lt;span style="color:#719e07">=&lt;/span> metadataInfo.calAndGetRevision();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//版本号发生了变更（元数据发生了变更）版本号是md5元数据信息计算出来HASH验证&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>newRevision.equals(existingInstanceRevision)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//版本号添加到dubbo.metadata.revision字段中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instance.getMetadata().put(EXPORTED_SERVICES_REVISION_PROPERTY_NAME, metadataInfo.getRevision());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="18541-元数据版本号的计算与hash校验-calandgetrevision">18.5.4.1 元数据版本号的计算与HASH校验 calAndGetRevision&lt;/h4>
&lt;p>这个方法其实比较重要，决定了什么时候会更新元数据，Dubbo使用了一种Hash验证的方式将元数据转MD5值与之前的存在的版本号（也是元数据转MD5得到的） 如果数据发生了变更则MD5值会发生变化 以此来更新元数据，不过发生了MD5冲突的话就会导致配置不更新这个冲突的概率非常小。
好了直接来看代码吧：
MetadataInfo类型的calAndGetRevision方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">synchronized&lt;/span> String &lt;span style="color:#268bd2">calAndGetRevision&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (revision &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>updated) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> revision;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updated &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//应用下没有服务则使用一个空的版本号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isEmptyMap(services)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.revision &lt;span style="color:#719e07">=&lt;/span> EMPTY_REVISION;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StringBuilder sb &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> StringBuilder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//app是应用名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sb.append(app);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (Map.Entry&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, ServiceInfo&lt;span style="color:#719e07">&amp;gt;&lt;/span> entry : &lt;span style="color:#719e07">new&lt;/span> TreeMap&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(services).entrySet()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sb.append(entry.getValue().toDescString());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String tempRevision &lt;span style="color:#719e07">=&lt;/span> RevisionResolver.calRevision(sb.toString());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>StringUtils.isEquals(&lt;span style="color:#719e07">this&lt;/span>.revision, tempRevision)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//元数据重新注册的话我们可以看看这个日志metadata revision change&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (logger.isInfoEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(String.format(&lt;span style="color:#2aa198">&amp;#34;metadata revision changed: %s -&amp;gt; %s, app: %s, services: %d&amp;#34;&lt;/span>, &lt;span style="color:#719e07">this&lt;/span>.revision, tempRevision, &lt;span style="color:#719e07">this&lt;/span>.app, &lt;span style="color:#719e07">this&lt;/span>.services.size()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.revision &lt;span style="color:#719e07">=&lt;/span> tempRevision;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.rawMetadataInfo &lt;span style="color:#719e07">=&lt;/span> JsonUtils.getJson().toJson(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> revision;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>RevisionResolver类型的Md5运算计算版本号&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>md5Utils.getMd5(metadata);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1855-reportmetadata">18.5.5 reportMetadata&lt;/h3>
&lt;p>回到18.5.2 AbstractServiceDiscovery中的模版方法register，这里我们来看下reportMetadata方法，不过这个方法目前并不会走到，因为我们默认的配置元数据是local不会直接把应用的元数据注册在元数据中心&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">reportMetadata&lt;/span>(MetadataInfo metadataInfo) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (metadataReport &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//订阅元数据的标识符&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SubscriberMetadataIdentifier identifier &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> SubscriberMetadataIdentifier(serviceName, metadataInfo.getRevision());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//是否远程发布元数据，这里我们是本地注册这个就不会在元数据中心发布这个元数据信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> ((DEFAULT_METADATA_STORAGE_TYPE.equals(metadataType) &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> metadataReport.shouldReportMetadata()) &lt;span style="color:#719e07">||&lt;/span> REMOTE_METADATA_STORAGE_TYPE.equals(metadataType)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataReport.publishAppMetadata(identifier, metadataInfo);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1856-扩展的注册中心来注册应用级服务发现数据doregister方法">18.5.6 扩展的注册中心来注册应用级服务发现数据doRegister方法&lt;/h3>
&lt;p>前面我们说了AbstractServiceDiscovery中的模版方法register，在register会调用一个doRegister方法来注册应用级数据，这个方法是需要扩展注册中心的服务发现来自行实现的，我们这里以官方实现的Zookeeper服务发现模型为例:&lt;/p>
&lt;p>ZookeeperServiceDiscovery中的doRegister方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">doRegister&lt;/span>(ServiceInstance serviceInstance) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//Dubbo实现的ServiceInstance类型对象转 Curator的ServiceInstance&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceDiscovery.registerService(build(serviceInstance));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> RpcException(REGISTRY_EXCEPTION, &lt;span style="color:#2aa198">&amp;#34;Failed register instance &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> serviceInstance.toString(), e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前面我们介绍了ZookeeperServiceDiscovery发现的构造器连接注册中心，这里来看下服务注册，
应用级实例数据注册一共分为两步
第一步是：Dubbo实现的ServiceInstance类型对象转 Curator的ServiceInstance
第二步是：执行registerService方法将数据注册到注册中心&lt;/p>
&lt;p>先来看第一步：Dubbo实现的ServiceInstance类型对象转 Curator的ServiceInstance
关于Curator的服务发现原理可以参考官网的文章博客&lt;a href="https://curator.apache.org/docs/service-discovery/index.html">curator-x-discovery&lt;/a>&lt;/p>
&lt;p>&lt;strong>什么是发现服务？&lt;/strong>
在 SOA/分布式系统中，服务需要找到彼此。即，Web 服务可能需要找到缓存服务等。DNS 可以用于此，但对于不断变化的服务来说，它远不够灵活。服务发现系统提供了一种机制：&lt;/p>
&lt;ul>
&lt;li>注册其可用性的服务&lt;/li>
&lt;li>定位特定服务的单个实例&lt;/li>
&lt;li>在服务实例更改时通知&lt;/li>
&lt;/ul>
&lt;p>服务实例由类表示：ServiceInstance。ServiceInstances 具有名称、id、地址、端口和/或 ssl 端口，以及可选的有效负载（用户定义）。ServiceInstances 通过以下方式序列化并存储在 ZooKeeper 中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>base path
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">|&lt;/span>_______ service A name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">|&lt;/span>__________ instance 1 id &lt;span style="color:#719e07">--&amp;gt;&lt;/span> (serialized ServiceInstance)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">|&lt;/span>__________ instance 2 id &lt;span style="color:#719e07">--&amp;gt;&lt;/span> (serialized ServiceInstance)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">|&lt;/span>__________ ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">|&lt;/span>_______ service B name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">|&lt;/span>__________ instance 1 id &lt;span style="color:#719e07">--&amp;gt;&lt;/span> (serialized ServiceInstance)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">|&lt;/span>__________ instance 2 id &lt;span style="color:#719e07">--&amp;gt;&lt;/span> (serialized ServiceInstance)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">|&lt;/span>__________ ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">|&lt;/span>_______ ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个应用最终注册应用级服务数据如下：
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/18-metadata4.png" alt="在这里插入图片描述">
这里需要注意的是这个 应用的IP+端口的服务元数据信息是临时节点
build方法内容对应着上图的JSON数据 可以看菜build方法封装的过程：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> org.apache.curator.x.discovery.ServiceInstance&lt;span style="color:#719e07">&amp;lt;&lt;/span>ZookeeperInstance&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">build&lt;/span>(ServiceInstance serviceInstance) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServiceInstanceBuilder builder;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String serviceName &lt;span style="color:#719e07">=&lt;/span> serviceInstance.getServiceName();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String host &lt;span style="color:#719e07">=&lt;/span> serviceInstance.getHost();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> port &lt;span style="color:#719e07">=&lt;/span> serviceInstance.getPort();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&lt;/span> metadata &lt;span style="color:#719e07">=&lt;/span> serviceInstance.getSortedMetadata();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String id &lt;span style="color:#719e07">=&lt;/span> generateId(host, port);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//ZookeeperInstance是Dubbo封装的用于存放payload数据 包含服务id，服务名字和元数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ZookeeperInstance zookeeperInstance &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ZookeeperInstance(id, serviceName, metadata);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> builder &lt;span style="color:#719e07">=&lt;/span> builder()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .id(id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .name(serviceName)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .address(host)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .port(port)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .payload(zookeeperInstance);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> RuntimeException(e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> builder.build();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在《18.5 应用级数据注册 registerServiceInstance() 》 小节中介绍了应用元数据信息的注册调用代码，其实后面还有个update的逻辑定期30秒同步元数据到元数据中心，这里就不详细介绍了。&lt;/p>
&lt;p>原文地址：&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/18-dubbo3-yuan-shu-ju-fu-wu-metadataservice-de-dao-chu/">18-Dubbo3元数据服务MetadataService的导出&lt;/a>&lt;/p></description></item><item><title>Blog: 17-Dubbo服务提供者的双注册原理</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/17/17-dubbo%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E7%9A%84%E5%8F%8C%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86/</link><pubDate>Wed, 17 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/17/17-dubbo%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E7%9A%84%E5%8F%8C%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86/</guid><description>
&lt;h1 id="17-dubbo服务提供者的双注册原理">17-Dubbo服务提供者的双注册原理&lt;/h1>
&lt;h2 id="171-简介">17.1 简介&lt;/h2>
&lt;p>上个博客&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/15-dubbo-de-san-da-zhong-xin-zhi-yuan-shu-ju-zhong-xin-yuan-ma-jie-xi/">《15-Dubbo的三大中心之元数据中心源码解析》&lt;/a>导出服务端的时候多次提到了元数据中心，注册信息的注册。
Dubbo3出来时间不太长，对于现在的用户来说大部分使用的仍旧是Dubbo2.x，
Dubbo3 比较有特色也是会直接使用到的功能就是&lt;strong>应用级服务发现&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>应用级服务发现
&lt;em>从服务/接口粒度到应用粒度的升级，使得 Dubbo 在集群可伸缩性、连接异构微服务体系上更具优势。应用粒度能以更低的资源消耗支持超百万实例规模集群程； 实现与 Spring Cloud、Kubernetes Service 等异构微服务体系的互联互通。&lt;/em>&lt;/li>
&lt;/ul>
&lt;p>对于直接使用Dubbo3的用户还好，可以仅仅开启应用级注册，但是对于Dubbo2.x的用户升级到Dubbo3的用户来说前期都是要开启双注册来慢慢迁移的，既注册传统的接口信息到注册中心，又注册应用信息到注册中心，同时注册应用与接口关系的元数据信息。
关于双注册与服务迁移的过程的使用可以参考官网：
&lt;a href="https://cn.dubbo.apache.org/zh-cn/docs/migration/migration-service-discovery/">应用级地址发现迁移指南&lt;/a>&lt;/p>
&lt;p>关于官网提供者双注册的图我这里贴一下，方便了解：
&lt;img src="https://cn.dubbo.apache.org/imgs/v3/migration/provider-registration.png" alt="在这里插入图片描述">&lt;/p>
&lt;h2 id="172-双注册配置的读取">17.2 双注册配置的读取&lt;/h2>
&lt;h3 id="1721-注册中心地址作为元数据中心">17.2.1 注册中心地址作为元数据中心&lt;/h3>
&lt;p>这个配置的解析过程在前面的博客介绍元数据中心的时候很详细的说了相关链接：&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/15-dubbo-de-san-da-zhong-xin-zhi-yuan-shu-ju-zhong-xin-yuan-ma-jie-xi/">15-Dubbo的三大中心之元数据中心源码解析&lt;/a>&lt;/p>
&lt;p>对应代码位于：DefaultApplicationDeployer类型的startMetadataCenter()方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">startMetadataCenter&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果未配置元数据中心的地址等配置则使用注册中心的地址等配置做为元数据中心的配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> useRegistryAsMetadataCenterIfNecessary();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//...省略掉其他代码防止受到干扰&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>具体逻辑是这个方法：
useRegistryAsMetadataCenterIfNecessary&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">useRegistryAsMetadataCenterIfNecessary&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置缓存中查询元数据配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collection&lt;span style="color:#719e07">&amp;lt;&lt;/span>MetadataReportConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> metadataConfigs &lt;span style="color:#719e07">=&lt;/span> configManager.getMetadataConfigs();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//...省略掉空判断&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//查询是否有注册中心设置了默认配置isDefault 设置为true的注册中心则为默认注册中心列表,如果没有注册中心设置为默认注册中心,则获取所有未设置默认配置的注册中心列表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>RegistryConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> defaultRegistries &lt;span style="color:#719e07">=&lt;/span> configManager.getDefaultRegistries();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (defaultRegistries.size() &lt;span style="color:#719e07">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//多注册中心遍历&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defaultRegistries
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .stream()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//筛选符合条件的注册中心 (筛选逻辑就是查看是否有对应协议的扩展支持)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter(&lt;span style="color:#719e07">this&lt;/span>::isUsedRegistryAsMetadataCenter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注册中心配置映射为元数据中心 映射就是获取需要的配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map(&lt;span style="color:#719e07">this&lt;/span>::registryAsMetadataCenter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将元数据中心配置存储在配置缓存中方便后续使用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .forEach(metadataReportConfig &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//...省略掉具体的逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>关于元数据中心地址的获取，主要经过如下逻辑：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>查询：&lt;/strong> 所有可用的默认注册中心列表&lt;/li>
&lt;li>&lt;strong>遍历：&lt;/strong> 多注册中心遍历&lt;/li>
&lt;li>&lt;strong>筛选：&lt;/strong> 选符合条件的注册中心 (筛选逻辑就是查看是否有对应协议的扩展支持)&lt;/li>
&lt;li>&lt;strong>转化：&lt;/strong> 注册中心配置RegistryConfig映射转换为元数据中心配置类型MetadataReportConfig&lt;/li>
&lt;/ul>
&lt;p>MetadataReportConfig 映射就是获取需要的配置。&lt;/p>
&lt;p>最后会把查询到的元数据中心配置存储在配置缓存中方便后续使用。&lt;/p>
&lt;h3 id="1722-双注册模式配置">17.2.2 双注册模式配置&lt;/h3>
&lt;p>双注册配置类型是这个&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>dubbo.application.register&lt;span style="color:#719e07">-&lt;/span>mode&lt;span style="color:#719e07">=&lt;/span>all
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认值为all代表应用级注册和接口级注册，当前在完全迁移到应用级注册之后可以将服务直接迁移到应用级配置上去。
配置值解释：&lt;/p>
&lt;ul>
&lt;li>all 双注册&lt;/li>
&lt;li>instance 应用级注册&lt;/li>
&lt;li>interface 接口级注册&lt;/li>
&lt;/ul>
&lt;p>后面的代码如果想要看更详细的代码可以看博客&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/16-mo-kuai-fa-bu-qi-fa-bu-fu-wu-quan-guo-cheng/">《16-模块发布器发布服务全过程》&lt;/a>
关于这个配置的使用我们详细来看下，在Dubbo服务注册时候会先通过此配置查询需要注册服务地址，具体代码位于ServiceConfig的doExportUrls()方法中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">doExportUrls&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//省略掉前面的代码...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> registryURLs &lt;span style="color:#719e07">=&lt;/span> ConfigValidationUtils.loadRegistries(&lt;span style="color:#719e07">this&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//省略掉后面的代码...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后就是具体注册中心地址的获取过程我们看下：
ConfigValidationUtils的加载注册中心地址方法loadRegistries&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">loadRegistries&lt;/span>(AbstractInterfaceConfig interfaceConfig, &lt;span style="color:#dc322f">boolean&lt;/span> provider) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// check &amp;amp;&amp;amp; override if necessary&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//省略掉前面的代码...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里会获取到一个接口配置注册地址例如：registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;pid=9008&amp;amp;registry=zookeeper&amp;amp;release=3.0.8&amp;amp;timestamp=1653703292768&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>RegistryConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> registries &lt;span style="color:#719e07">=&lt;/span> interfaceConfig.getRegistries();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//省略掉中间的的代码...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> genCompatibleRegistries(interfaceConfig.getScopeModel(), registryList, provider);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ConfigValidationUtils的双注册地址的获取genCompatibleRegistries方法.
前面代码获取到了一个注册中心地址列表例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>registry:&lt;span style="color:#586e75">//127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;pid=9008&amp;amp;registry=zookeeper&amp;amp;release=3.0.8&amp;amp;timestamp=1653703292768&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面可以看下如果根据配置来转换为应用级注册地址+接口级注册地址&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">genCompatibleRegistries&lt;/span>(ScopeModel scopeModel, List&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> registryList, &lt;span style="color:#dc322f">boolean&lt;/span> provider) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> result &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(registryList.size());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registryList.forEach(registryURL &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (provider) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// for registries enabled service discovery, automatically register interface compatible addresses.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String registerMode;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (SERVICE_REGISTRY_PROTOCOL.equals(registryURL.getProtocol())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//为了更好理解这里简化掉服务发现注册地址配置的逻辑判断过程仅仅看当前例子提供的值走的逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//双注册模式配置查询 对应参数为dubbo.application.register-mode 默认值为all&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registerMode &lt;span style="color:#719e07">=&lt;/span> registryURL.getParameter(REGISTER_MODE_KEY, ConfigurationUtils.getCachedDynamicProperty(scopeModel, DUBBO_REGISTER_MODE_DEFAULT_KEY, DEFAULT_REGISTER_MODE_ALL));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果用户配置了一个错误的注册模式配置则只走接口级配置 这里默认值为interface&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>isValidRegisterMode(registerMode)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registerMode &lt;span style="color:#719e07">=&lt;/span> DEFAULT_REGISTER_MODE_INTERFACE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个逻辑是满足应用级注册就添加一个应用级注册的地址&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> ((DEFAULT_REGISTER_MODE_INSTANCE.equalsIgnoreCase(registerMode) &lt;span style="color:#719e07">||&lt;/span> DEFAULT_REGISTER_MODE_ALL.equalsIgnoreCase(registerMode))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> registryNotExists(registryURL, registryList, SERVICE_REGISTRY_PROTOCOL)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL serviceDiscoveryRegistryURL &lt;span style="color:#719e07">=&lt;/span> URLBuilder.from(registryURL)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setProtocol(SERVICE_REGISTRY_PROTOCOL)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .removeParameter(REGISTRY_TYPE_KEY)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .build();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.add(serviceDiscoveryRegistryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个逻辑是满足接口级注册配置就添加一个接口级注册地址&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (DEFAULT_REGISTER_MODE_INTERFACE.equalsIgnoreCase(registerMode) &lt;span style="color:#719e07">||&lt;/span> DEFAULT_REGISTER_MODE_ALL.equalsIgnoreCase(registerMode)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.add(registryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//省略掉若干代码和括号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到这里简化的配置比较容易理解了&lt;/p>
&lt;ul>
&lt;li>双注册模式配置查询 对应参数为dubbo.application.register-mode ，默认值为all&lt;/li>
&lt;li>如果用户配置了一个错误的注册模式配置则只走接口级配置 这里默认值为interface&lt;/li>
&lt;li>满足应用级注册就添加一个应用级注册的地址&lt;/li>
&lt;li>满足接口级注册配置就添加一个接口级注册地址&lt;/li>
&lt;/ul>
&lt;p>这个方法是根据服务注册模式来判断使用接口级注册地址还是应用级注册地址分别如下所示：
配置信息：
dubbo.application.register-mode
配置值：&lt;/p>
&lt;ul>
&lt;li>interface
&lt;ul>
&lt;li>接口级注册&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>instance
&lt;ul>
&lt;li>应用级注册&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>all
&lt;ul>
&lt;li>接口级别和应用级都注册&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>最终的注册地址配置如下：
接口级注册地址：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>registry:&lt;span style="color:#586e75">//127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;pid=9008&amp;amp;registry=zookeeper&amp;amp;release=3.0.8&amp;amp;timestamp=1653703292768&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>应用级注册地址：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>service&lt;span style="color:#719e07">-&lt;/span>discovery&lt;span style="color:#719e07">-&lt;/span>registry:&lt;span style="color:#586e75">//127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;pid=10275&amp;amp;registry=zookeeper&amp;amp;release=3.0.8&amp;amp;timestamp=1653704425920&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="173-双注册服务数据的注册">17.3 双注册服务数据的注册&lt;/h2>
&lt;h3 id="1731-双注册代码逻辑调用简介">17.3.1 双注册代码逻辑调用简介&lt;/h3>
&lt;p>前面说了这个注册服务的配置地址会由Dubbo内部进行判断如果判断是all的话会自动将一个配置的注册地址转变为两个一个是传统的接口级注册，一个是应用级注册使用的配置地址&lt;/p>
&lt;p>然后我们先看注册中心，注册服务数据的源码
如果想要查看源码细节可以在RegistryProtocol类型的export(final Invoker&lt;T> originInvoker) 方法的如下代码位置打断点：&lt;/p>
&lt;p>RegistryProtocol的export方法的注册中心注册数据代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// url to registry 注册服务对外的接口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果url为service-discovery-registry发现则这个实现类型为ServiceDiscoveryRegistry&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">final&lt;/span> Registry registry &lt;span style="color:#719e07">=&lt;/span> getRegistry(registryUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务发现的提供者url: dubbo://192.168.1.9:20880/link.elastic.dubbo.entity.DemoService?anyhost=true&amp;amp;application=dubbo-demo-api-provider&amp;amp;background=false&amp;amp;deprecated=false&amp;amp;dubbo=2.0.2&amp;amp;dynamic=true&amp;amp;generic=false&amp;amp;interface=link.elastic.dubbo.entity.DemoService&amp;amp;methods=sayHello,sayHelloAsync&amp;amp;pid=19559&amp;amp;release=3.0.8&amp;amp;service-name-mapping=true&amp;amp;side=provider&amp;amp;timestamp=1654938441023&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">final&lt;/span> URL registeredProviderUrl &lt;span style="color:#719e07">=&lt;/span> getUrlToRegistry(providerUrl, registryUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// decide if we need to delay publish (provider itself and registry should both need to register)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//register参数是否 注册数据到注册中心&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">boolean&lt;/span> register &lt;span style="color:#719e07">=&lt;/span> providerUrl.getParameter(REGISTER_KEY, &lt;span style="color:#cb4b16">true&lt;/span>) &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> registryUrl.getParameter(REGISTER_KEY, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (register) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里有两种情况 接口级注册会将接口级服务提供者数据直接注册到Zookeper上面，服务发现（应用级注册）这里仅仅会将注册数据转换为服务元数据等后面来发布元数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> register(registry, registeredProviderUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// register stated url on provider model&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//向提供者模型注册提供者配置ProviderModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registerStatedUrl(registryUrl, registeredProviderUrl, register);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exporter.setRegisterUrl(registeredProviderUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exporter.setSubscribeUrl(overrideSubscribeUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>registry.isServiceDiscovery()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Deprecated! Subscribe to override rules in 2.6.x or before.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上个博客中我们整体说了下服务注册时候的一个流程，关于数据向注册中心的注册细节这里可以详细看下&lt;/p>
&lt;h3 id="1732--注册中心领域对象的初始化">17.3.2 注册中心领域对象的初始化&lt;/h3>
&lt;p>前面的代码使用url来获取注册中心操作对象如下调用代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// url to registry 注册服务对外的接口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">final&lt;/span> Registry registry &lt;span style="color:#719e07">=&lt;/span> getRegistry(registryUrl);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对应代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> Registry &lt;span style="color:#268bd2">getRegistry&lt;/span>(&lt;span style="color:#268bd2">final&lt;/span> URL registryUrl) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里分为两步先获取注册中心工厂对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RegistryFactory registryFactory &lt;span style="color:#719e07">=&lt;/span> ScopeModelUtil.getExtensionLoader(RegistryFactory.class, registryUrl.getScopeModel()).getAdaptiveExtension();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//使用注册中心工厂对象获取注册中心操作对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> registryFactory.getRegistry(registryUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>关于参数URL有两个在前面已经说过，url信息如下：&lt;/p>
&lt;p>接口级注册地址：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>registry:&lt;span style="color:#586e75">//127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;pid=9008&amp;amp;registry=zookeeper&amp;amp;release=3.0.8&amp;amp;timestamp=1653703292768&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>应用级注册地址：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>service&lt;span style="color:#719e07">-&lt;/span>discovery&lt;span style="color:#719e07">-&lt;/span>registry:&lt;span style="color:#586e75">//127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;pid=10275&amp;amp;registry=zookeeper&amp;amp;release=3.0.8&amp;amp;timestamp=1653704425920&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注册中心工厂对象与注册中心操作对象的获取与执行我们通过Debug来看比较麻烦，这里涉及到很多扩展机制动态生成的代码我们无法看到，这里我直接来贴一下比较关键的一些类型，以Zookeeper注册中心来举例子：&lt;/p>
&lt;p>先来看下注册工厂相关的类型：
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/17-register.png" alt="在这里插入图片描述">&lt;/p>
&lt;ul>
&lt;li>RegistryFactory 注册中心对象获取&lt;/li>
&lt;li>AbstractRegistryFactory 模板类型封装注册中心对象获取的基本逻辑，比如缓存和基本的逻辑判断&lt;/li>
&lt;li>ServiceDiscoveryRegistryFactory 用于创建服务发现注册中心工厂对象 用于创建ServiceDiscoveryRegistry对象&lt;/li>
&lt;li>ZookeeperRegistryFactory 用于创建ZookeeperRegistry类型对象&lt;/li>
&lt;li>NacosRegistryFactory Nacos注册中心工厂对象 用于创建NacosRegistry&lt;/li>
&lt;/ul>
&lt;p>接下来看封装了注册中心操作逻辑的注册中心领域对象：&lt;/p>
&lt;p>&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/17-register2.png" alt="在这里插入图片描述">&lt;/p>
&lt;ul>
&lt;li>Node 节点信息开放接口 比如节点 url的获取 ，销毁&lt;/li>
&lt;li>RegistryService 注册服务接口，比如注册，订阅，查询等操作&lt;/li>
&lt;li>Registry 注册中心接口，是否服务发现查询，注册，取消注册方法&lt;/li>
&lt;li>AbstractRegistry 注册中心逻辑抽象模板类型，封装了注册，订阅，通知的基本逻辑，和本地缓存注册中心信息的基本逻辑&lt;/li>
&lt;li>FailbackRegistry 封装了失败重试的逻辑&lt;/li>
&lt;li>NacosRegistry 封装了以nacos作为注册中心的基本逻辑&lt;/li>
&lt;li>ServiceDiscoveryRegistry 应用级服务发现注册中心逻辑，现在不需要这种网桥实现，协议可以直接与服务发现交互。ServiceDiscoveryRegistry是一种非常特殊的注册表实现，用于以兼容的方式将旧的接口级服务发现模型与3.0中引入的新服务发现模型连接起来。
它完全符合注册表SPI的扩展规范，但与zookeeper和Nacos的具体实现不同，因为它不与任何真正的第三方注册表交互，而只与过程中ServiceDiscovery的相关组件交互。简而言之，它架起了旧接口模型和新服务发现模型之间的桥梁：register()方法主要通过与MetadataService交互，将接口级数据聚合到MetadataInfo中subscribe() 触发应用程序级服务发现模型的整个订阅过程。-根据ServiceNameMapping将接口映射到应用程序。-启动新的服务发现侦听器（InstanceListener），并使NotifierListener成为InstanceListener的一部分。&lt;/li>
&lt;li>CacheableFailbackRegistry 提供了一些本地内存缓存的逻辑 对注册中心有用，注册中心的sdk将原始字符串作为提供程序实例返回，例如zookeeper和etcd&lt;/li>
&lt;li>ZookeeperRegistry Zookeeper作为注册中心的基本操作逻辑封装&lt;/li>
&lt;/ul>
&lt;p>了解了这几个领域对象这里我们回到代码逻辑，这里直接看将会执行的一些核心逻辑：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> Registry &lt;span style="color:#268bd2">getRegistry&lt;/span>(&lt;span style="color:#268bd2">final&lt;/span> URL registryUrl) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里分为两步先获取注册中心工厂对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RegistryFactory registryFactory &lt;span style="color:#719e07">=&lt;/span> ScopeModelUtil.getExtensionLoader(RegistryFactory.class, registryUrl.getScopeModel()).getAdaptiveExtension();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//使用注册中心工厂对象获取注册中心操作对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> registryFactory.getRegistry(registryUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前面注册中心工厂不论那种协议的地址信息获取到的都是一个RegistryFactory$Adaptive类型（由扩展机制的字节码工具自动生成的代码）&lt;/p>
&lt;p>如果getRegistry参数为应用级注册地址。如下所示将获取到的类型为ServiceDiscoveryRegistryFactory逻辑来获取注册中心：
（这个逻辑是@Adaptive注解产生的了逻辑具体原理可以看扩展机制中@Adaptive的实现）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>service&lt;span style="color:#719e07">-&lt;/span>discovery&lt;span style="color:#719e07">-&lt;/span>registry:&lt;span style="color:#586e75">//127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;pid=10275&amp;amp;registry=zookeeper&amp;amp;release=3.0.8&amp;amp;timestamp=1653704425920&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>getRegistry方法优先走的逻辑是这里：AbstractRegistryFactory模板类型中的getRegistry方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> Registry &lt;span style="color:#268bd2">getRegistry&lt;/span>(URL url) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (registryManager &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;Unable to fetch RegistryManager from ApplicationModel BeanFactory. &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;Please check if `setApplicationModel` has been override.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//销毁状态直接返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Registry defaultNopRegistry &lt;span style="color:#719e07">=&lt;/span> registryManager.getDefaultNopRegistryIfDestroyed();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">!=&lt;/span> defaultNopRegistry) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> defaultNopRegistry;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url &lt;span style="color:#719e07">=&lt;/span> URLBuilder.from(url)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setPath(RegistryService.class.getName())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .addParameter(INTERFACE_KEY, RegistryService.class.getName())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .removeParameter(TIMESTAMP_KEY)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .removeAttribute(EXPORT_KEY)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .removeAttribute(REFER_KEY)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .build();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个key为 service-discovery-registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String key &lt;span style="color:#719e07">=&lt;/span> createRegistryCacheKey(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Registry registry &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//check配置 是否检查注册中心连通 默认为true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">boolean&lt;/span> check &lt;span style="color:#719e07">=&lt;/span> url.getParameter(CHECK_KEY, &lt;span style="color:#cb4b16">true&lt;/span>) &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> url.getPort() &lt;span style="color:#719e07">!=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Lock the registry access process to ensure a single instance of the registry&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//给写操作加锁方式并发写问题&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registryManager.getRegistryLock().lock();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//锁内检查是否销毁的逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// double check&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// fix https://github.com/apache/dubbo/issues/7265.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defaultNopRegistry &lt;span style="color:#719e07">=&lt;/span> registryManager.getDefaultNopRegistryIfDestroyed();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">!=&lt;/span> defaultNopRegistry) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> defaultNopRegistry;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//锁内检查是否缓存中存在存在则直接返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registry &lt;span style="color:#719e07">=&lt;/span> registryManager.getRegistry(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (registry &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> registry;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//create registry by spi/ioc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//使用url创建注册中心操作的逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registry &lt;span style="color:#719e07">=&lt;/span> createRegistry(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//check配置检查&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (check) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> RuntimeException(&lt;span style="color:#2aa198">&amp;#34;Can not create registry &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> url, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOGGER.warn(&lt;span style="color:#2aa198">&amp;#34;Failed to obtain or create registry &amp;#34;&lt;/span>, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Release the lock&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registryManager.getRegistryLock().unlock();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (check &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> registry &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;Can not create registry &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//缓存逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (registry &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registryManager.putRegistry(key, registry);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> registry;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>逻辑其实吧比较简单，概括下上面的逻辑：&lt;/p>
&lt;ul>
&lt;li>销毁逻辑判断&lt;/li>
&lt;li>缓存获取，存在则直接返回&lt;/li>
&lt;li>根据注册中心url配置，创建注册中心操作对象&lt;/li>
&lt;li>注册中心连接失败的check配置逻辑处理&lt;/li>
&lt;li>将注册中心操作对象存入缓存&lt;/li>
&lt;/ul>
&lt;p>上面比较重要的逻辑是createRegistry这个
整个调用过程我给大家看下Debug的详情，这里很多逻辑由扩展机制产生的这里直接看下逻辑调用栈，有几个需要关注的地方我圈了起来：
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/17-register3.png" alt="在这里插入图片描述">
我们继续看服务发现的注册中心工厂对象的获取，代码如下：
ServiceDiscoveryRegistryFactory类型的createRegistry方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> Registry &lt;span style="color:#268bd2">createRegistry&lt;/span>(URL url) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//判断url是否是这个前缀：service-discovery-registry&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (UrlUtils.hasServiceDiscoveryRegistryProtocol(url)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//切换下协议：将服务发现协议切换为配置的注册中心协议这里是Zookeeper如下：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//zookeeper://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;interface=org.apache.dubbo.registry.RegistryService&amp;amp;pid=39884&amp;amp;release=3.0.8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String protocol &lt;span style="color:#719e07">=&lt;/span> url.getParameter(REGISTRY_KEY, DEFAULT_REGISTRY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url &lt;span style="color:#719e07">=&lt;/span> url.setProtocol(protocol).removeParameter(REGISTRY_KEY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建服务发现注册中心对象对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ServiceDiscoveryRegistry(url, applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过以上代码可以看到其实最终创建的是一个ServiceDiscoveryRegistry注册中心对象，这个url协议被转换为了对应注册中心的协议，也就是说双注册会有两个协议一个是原先的接口级注册注册中心对象（这个还未说到）和这里对应注册中心协议的服务发现注册中心对象ServiceDiscoveryRegistry&lt;/p>
&lt;h3 id="1733-servicediscoveryregistry">17.3.3 ServiceDiscoveryRegistry&lt;/h3>
&lt;p>ServiceDiscoveryRegistry服务发现注册中心对象的初始化过程：&lt;/p>
&lt;h4 id="17331-servicediscoveryregistry的构造器">17.3.3.1 ServiceDiscoveryRegistry的构造器：&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">ServiceDiscoveryRegistry&lt;/span>(URL registryURL, ApplicationModel applicationModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>(registryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//根据url创建一个服务发现对象类型为ServiceDiscovery&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.serviceDiscovery &lt;span style="color:#719e07">=&lt;/span> createServiceDiscovery(registryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个类型为是serviceNameMapping类型是MetadataServiceNameMapping类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.serviceNameMapping &lt;span style="color:#719e07">=&lt;/span> (AbstractServiceNameMapping) ServiceNameMapping.getDefaultExtension(registryURL.getScopeModel());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>.applicationModel &lt;span style="color:#719e07">=&lt;/span> applicationModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ServiceDiscoveryRegistry中创建服务发现对象createServiceDiscovery方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">protected&lt;/span> ServiceDiscovery &lt;span style="color:#268bd2">createServiceDiscovery&lt;/span>(URL registryURL) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> getServiceDiscovery(registryURL.addParameter(INTERFACE_KEY, ServiceDiscovery.class.getName())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .removeParameter(REGISTRY_TYPE_KEY));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ServiceDiscoveryRegistry中创建服务发现对象getServiceDiscovery方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> ServiceDiscovery &lt;span style="color:#268bd2">getServiceDiscovery&lt;/span>(URL registryURL) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//服务发现工厂对象的获取这里是ServiceDiscoveryFactory类型，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServiceDiscoveryFactory factory &lt;span style="color:#719e07">=&lt;/span> getExtension(registryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务发现工厂对象获取服务发现对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> factory.getServiceDiscovery(registryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ServiceDiscoveryFactory和ServiceDiscovery类型可以往后看&lt;/p>
&lt;h4 id="17332-父类型failbackregistry的构造器">17.3.3.2 父类型FailbackRegistry的构造器&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">FailbackRegistry&lt;/span>(URL url) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//重试间隔配置retry.period ，默认为5秒&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.retryPeriod &lt;span style="color:#719e07">=&lt;/span> url.getParameter(REGISTRY_RETRY_PERIOD_KEY, DEFAULT_REGISTRY_RETRY_PERIOD);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// since the retry task will not be very much. 128 ticks is enough.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//因为重试任务不会太多。128个刻度就足够了。Dubbo封装的时间轮用于高效率的重试，这个在Kafka也自定义实现了后续可以单独来看看&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> retryTimer &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> HashedWheelTimer(&lt;span style="color:#719e07">new&lt;/span> NamedThreadFactory(&lt;span style="color:#2aa198">&amp;#34;DubboRegistryRetryTimer&amp;#34;&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>), retryPeriod, TimeUnit.MILLISECONDS, 128);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="17333-abstractregistry的构造器">17.3.3.3 AbstractRegistry的构造器&lt;/h4>
&lt;p>参数url如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>zookeeper:&lt;span style="color:#586e75">//127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;interface=org.apache.dubbo.registry.RegistryService&amp;amp;pid=39884&amp;amp;release=3.0.8&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">AbstractRegistry&lt;/span>(URL url) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setUrl(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registryManager &lt;span style="color:#719e07">=&lt;/span> url.getOrDefaultApplicationModel().getBeanFactory().getBean(RegistryManager.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//是否本地缓存默认为true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> localCacheEnabled &lt;span style="color:#719e07">=&lt;/span> url.getParameter(REGISTRY_LOCAL_FILE_CACHE_ENABLED, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registryCacheExecutor &lt;span style="color:#719e07">=&lt;/span> url.getOrDefaultFrameworkModel().getBeanFactory()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .getBean(FrameworkExecutorRepository.class).getSharedExecutor();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (localCacheEnabled) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Start file save timer 是否同步缓存默认为false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> syncSaveFile &lt;span style="color:#719e07">=&lt;/span> url.getParameter(REGISTRY_FILESAVE_SYNC_KEY, &lt;span style="color:#cb4b16">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//默认缓存的文件路径与文件名字为：/Users/song/.dubbo/dubbo-registry-dubbo-demo-api-provider-127.0.0.1-2181.cache&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String defaultFilename &lt;span style="color:#719e07">=&lt;/span> System.getProperty(USER_HOME) &lt;span style="color:#719e07">+&lt;/span> DUBBO_REGISTRY &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url.getApplication() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;-&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> url.getAddress().replaceAll(&lt;span style="color:#2aa198">&amp;#34;:&amp;#34;&lt;/span>, &lt;span style="color:#2aa198">&amp;#34;-&amp;#34;&lt;/span>) &lt;span style="color:#719e07">+&lt;/span> CACHE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//未指定缓存的文件名字则用默认的文件名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String filename &lt;span style="color:#719e07">=&lt;/span> url.getParameter(FILE_KEY, defaultFilename);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File file &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//父目录创建，保证目录存在&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (ConfigUtils.isNotEmpty(filename)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> File(filename);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>file.exists() &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> file.getParentFile() &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>file.getParentFile().exists()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>file.getParentFile().mkdirs()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException(&lt;span style="color:#2aa198">&amp;#34;Invalid registry cache file &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> file &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, cause: Failed to create directory &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> file.getParentFile() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.file &lt;span style="color:#719e07">=&lt;/span> file;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// When starting the subscription center,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// we need to read the local cache file for future Registry fault tolerance processing.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加载本地磁盘文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadProperties();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//变更推送&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> notify(url.getBackupUrls());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1734-将服务提供者数据转换到本地内存的元数据信息中">17.3.4 将服务提供者数据转换到本地内存的元数据信息中&lt;/h3>
&lt;p>在前面我们看到了RegistryProtocol中调用register来注册服务提供者的数据到注册的中心，接下来详细看下实现原理：
下面参数为ServiceDiscoveryRegistry为情况下举例子：ServiceDiscoveryRegistry类型的register方法与ZookeeperRegister注册不一样传统的接口级注册在这个方法里面就将服务数据注册到注册中心了，服务发现的数据注册分为了两步，这里仅仅将数据封装到内存中如下：
url例子为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>dubbo:&lt;span style="color:#586e75">//192.168.1.9:20880/link.elastic.dubbo.entity.DemoService?anyhost=true&amp;amp;application=dubbo-demo-api-provider&amp;amp;background=false&amp;amp;deprecated=false&amp;amp;dubbo=2.0.2&amp;amp;dynamic=true&amp;amp;generic=false&amp;amp;interface=link.elastic.dubbo.entity.DemoService&amp;amp;methods=sayHello,sayHelloAsync&amp;amp;pid=19559&amp;amp;release=3.0.8&amp;amp;service-name-mapping=true&amp;amp;side=provider&amp;amp;timestamp=1654938441023&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>RegistryProtocol中的register方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">register&lt;/span>(Registry registry, URL registeredProviderUrl) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registry.register(registeredProviderUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面这个代码会优先走ListenerRegistryWrapper的一些逻辑来执行register方法来触发一些监听器的逻辑，我们直接跳到ServiceDiscoveryRegistry中的register方法来看&lt;/p>
&lt;p>ServiceDiscoveryRegistry的register方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">final&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">register&lt;/span>(URL url) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//逻辑判断比如只有side为提供者时候才能注册&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>shouldRegister(url)) { &lt;span style="color:#586e75">// Should Not Register&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doRegister(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ServiceDiscoveryRegistry的doRegister方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">doRegister&lt;/span>(URL url) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// fixme, add registry-cluster is not necessary anymore&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url &lt;span style="color:#719e07">=&lt;/span> addRegistryClusterKey(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceDiscovery.register(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>AbstractServiceDiscovery的register方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">register&lt;/span>(URL url) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//metadaInfo类型为MetadataInfo类型，用来操作元数据的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataInfo.addService(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>MetadataInfo 类型的addService方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">synchronized&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">addService&lt;/span>(URL url) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// fixme, pass in application mode context during initialization of MetadataInfo.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//元数据参数过滤器扩展获取:MetadataParamsFilter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">this&lt;/span>.loader &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.loader &lt;span style="color:#719e07">=&lt;/span> url.getOrDefaultApplicationModel().getExtensionLoader(MetadataParamsFilter.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//元数据参数过滤器获取&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>MetadataParamsFilter&lt;span style="color:#719e07">&amp;gt;&lt;/span> filters &lt;span style="color:#719e07">=&lt;/span> loader.getActivateExtension(url, &lt;span style="color:#2aa198">&amp;#34;params-filter&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// generate service level metadata&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//生成服务级别的元数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServiceInfo serviceInfo &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ServiceInfo(url, filters);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.services.put(serviceInfo.getMatchKey(), serviceInfo);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// extract common instance level params&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extractInstanceParams(url, filters);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (exportedServiceURLs &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exportedServiceURLs &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ConcurrentSkipListMap&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addURL(exportedServiceURLs, url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updated &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1735-接口级服务提供者配置的注册">17.3.5 接口级服务提供者配置的注册&lt;/h3>
&lt;p>前面我们通过服务发现的的url进行了举例子，其实在RegistryProtocol协议的export方法中还会注册接口级信息：
例如如下关键代码：
当registryUrl参数不是服务发现协议service-discovery-registry配置而是zookeeper如下时候获取到的扩展类型将是与Zookeeper相关的扩展对象&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>zookeeper:&lt;span style="color:#586e75">//8.131.79.126:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;pid=29386&amp;amp;release=3.0.8&amp;amp;timestamp=1655023329438&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>RegistryProtocol协议的export方法中接口级数据注册的核心代码如下：
如下代码的操作类型可以看注释&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// url to registry 这里registry对象的类型为ZookeeperRegistry&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">final&lt;/span> Registry registry &lt;span style="color:#719e07">=&lt;/span> getRegistry(registryUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">final&lt;/span> URL registeredProviderUrl &lt;span style="color:#719e07">=&lt;/span> getUrlToRegistry(providerUrl, registryUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// decide if we need to delay publish (provider itself and registry should both need to register)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">boolean&lt;/span> register &lt;span style="color:#719e07">=&lt;/span> providerUrl.getParameter(REGISTER_KEY, &lt;span style="color:#cb4b16">true&lt;/span>) &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> registryUrl.getParameter(REGISTER_KEY, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这一个方法里面会将提供者的url配置写入Zookeeper的provider节点下面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (register) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> register(registry, registeredProviderUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上代码是获取Zookeeper操作对象和向Zookeeper中写入服务提供者信息的代码，关于与Zookeeper连接和注册数据本地缓存的代码可以看ZookeeperRegistry类型和它的几个父类型比如：CacheableFailbackRegistry类型，关于接口级数据的注册可以看register方法，这个就不详细说了，下面我贴一下接口级数据注册的Zookeeper信息可以了解下就行：
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/17-register4.png" alt="在这里插入图片描述">
接口信息如下，上面我们需要注意的是这个 url配置为临时节点，当与Zookeeper断开连接或者Session超时的时候这个信息会被移除：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">/&lt;/span>dubbo&lt;span style="color:#719e07">/&lt;/span>link.elastic.dubbo.entity.DemoService&lt;span style="color:#719e07">/&lt;/span>providers&lt;span style="color:#719e07">/&lt;/span>dubbo&lt;span style="color:#719e07">%&lt;/span>3A&lt;span style="color:#719e07">%&lt;/span>2F&lt;span style="color:#719e07">%&lt;/span>2F192.168.1.9&lt;span style="color:#719e07">%&lt;/span>3A20880&lt;span style="color:#719e07">%&lt;/span>2Flink.elastic.dubbo.entity.DemoService&lt;span style="color:#719e07">%&lt;/span>3Fanyhost&lt;span style="color:#719e07">%&lt;/span>3Dtrue&lt;span style="color:#719e07">%&lt;/span>26application&lt;span style="color:#719e07">%&lt;/span>3Ddubbo&lt;span style="color:#719e07">-&lt;/span>demo&lt;span style="color:#719e07">-&lt;/span>api&lt;span style="color:#719e07">-&lt;/span>provider&lt;span style="color:#719e07">%&lt;/span>26background&lt;span style="color:#719e07">%&lt;/span>3Dfalse&lt;span style="color:#719e07">%&lt;/span>26deprecated&lt;span style="color:#719e07">%&lt;/span>3Dfalse&lt;span style="color:#719e07">%&lt;/span>26dubbo&lt;span style="color:#719e07">%&lt;/span>3D2.0.2&lt;span style="color:#719e07">%&lt;/span>26dynamic&lt;span style="color:#719e07">%&lt;/span>3Dtrue&lt;span style="color:#719e07">%&lt;/span>26generic&lt;span style="color:#719e07">%&lt;/span>3Dfalse&lt;span style="color:#719e07">%&lt;/span>26interface&lt;span style="color:#719e07">%&lt;/span>3Dlink.elastic.dubbo.entity.DemoService&lt;span style="color:#719e07">%&lt;/span>26methods&lt;span style="color:#719e07">%&lt;/span>3DsayHello&lt;span style="color:#719e07">%&lt;/span>2CsayHelloAsync&lt;span style="color:#719e07">%&lt;/span>26pid&lt;span style="color:#719e07">%&lt;/span>3D29386&lt;span style="color:#719e07">%&lt;/span>26release&lt;span style="color:#719e07">%&lt;/span>3D3.0.8&lt;span style="color:#719e07">%&lt;/span>26service&lt;span style="color:#719e07">-&lt;/span>name&lt;span style="color:#719e07">-&lt;/span>mapping&lt;span style="color:#719e07">%&lt;/span>3Dtrue&lt;span style="color:#719e07">%&lt;/span>26side&lt;span style="color:#719e07">%&lt;/span>3Dprovider&lt;span style="color:#719e07">%&lt;/span>26timestamp&lt;span style="color:#719e07">%&lt;/span>3D1655023329514
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="174-应用级服务发现功能的实现servicediscovery">17.4 应用级服务发现功能的实现ServiceDiscovery&lt;/h2>
&lt;p>在说这个实现之前我们先看看相关类型，这个服务发现相关的类型与注册中心相关的类型有点类似：&lt;/p>
&lt;p>服务发现工厂类型：
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/17-register5.png" alt="在这里插入图片描述">
服务发现类型：
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/17-register6.png" alt="在这里插入图片描述">&lt;/p>
&lt;p>刚刚在 ServiceDiscoveryRegistry中创建服务发现对象getServiceDiscovery方法看到了两个类型一个是服务发现工厂类型ServiceDiscoveryFactory，一个是服务发现类型ServiceDiscovery&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> ServiceDiscovery &lt;span style="color:#268bd2">getServiceDiscovery&lt;/span>(URL registryURL) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//服务发现工厂对象的获取这里是ServiceDiscoveryFactory类型，这里对应ZookeeperServiceDiscoveryFactory&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServiceDiscoveryFactory factory &lt;span style="color:#719e07">=&lt;/span> getExtension(registryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务发现工厂对象获取服务发现对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> factory.getServiceDiscovery(registryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>AbstractServiceDiscoveryFactory类型的getServiceDiscovery方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> ServiceDiscovery &lt;span style="color:#268bd2">getServiceDiscovery&lt;/span>(URL registryURL) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个key是 zookeeper://127.0.0.1:2181/org.apache.dubbo.registry.client.ServiceDiscovery&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//一个地址需要创建一个服务发现对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String key &lt;span style="color:#719e07">=&lt;/span> registryURL.toServiceStringWithoutResolving();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> discoveries.computeIfAbsent(key, k &lt;span style="color:#719e07">-&amp;gt;&lt;/span> createDiscovery(registryURL));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>createDiscovery方法对应ZookeeperServiceDiscoveryFactory类型中的createDiscovery方法&lt;/p>
&lt;p>如下代码所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> ServiceDiscovery &lt;span style="color:#268bd2">createDiscovery&lt;/span>(URL registryURL) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ZookeeperServiceDiscovery(applicationModel, registryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1741-zookeeperservicediscovery">17.4.1 ZookeeperServiceDiscovery&lt;/h3>
&lt;p>ZookeeperServiceDiscovery的构造器&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">ZookeeperServiceDiscovery&lt;/span>(ApplicationModel applicationModel, URL registryURL) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//先调用父类AbstractServiceDiscovery 模板类构造器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>(applicationModel, registryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建 创建CuratorFramework 类型对象用于操作Zookeeper&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.curatorFramework &lt;span style="color:#719e07">=&lt;/span> buildCuratorFramework(registryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取应用级服务发现的根路径 值为/services 这个可以在Zookeeper上面看到&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.rootPath &lt;span style="color:#719e07">=&lt;/span> ROOT_PATH.getParameterValue(registryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建服务发现对象 实现类型为ServiceDiscoveryImpl 这个实现来源于Curator框架中的discovery模块&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.serviceDiscovery &lt;span style="color:#719e07">=&lt;/span> buildServiceDiscovery(curatorFramework, rootPath);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//启动服务发现&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.serviceDiscovery.start();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;Create zookeeper service discovery failed.&amp;#34;&lt;/span>, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个方法比较重要是应用级服务发现的实现，这里主要关注下serviceDiscovery类型的创建与启动，这个应用级服务发现的实现其实是Dubbo使用了Curator来做的，Dubbo只是在这里封装了一些方法来进行调用Curator的实现：
关于Curator的官方文档可以看&lt;a href="https://curator.apache.org/">curator官网&lt;/a>&lt;/p>
&lt;p>关于Zookeeper上面注册服务应用级服务注册信息可以看如下图所示(后面会具体讲到数据注册时的调用）：
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/17-register7.png" alt="在这里插入图片描述">
我这个服务提供者注册的应用数据如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;name&amp;#34;&lt;/span> : &lt;span style="color:#2aa198">&amp;#34;dubbo-demo-api-provider&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;id&amp;#34;&lt;/span> : &lt;span style="color:#2aa198">&amp;#34;192.168.1.9:20880&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;address&amp;#34;&lt;/span> : &lt;span style="color:#2aa198">&amp;#34;192.168.1.9&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;port&amp;#34;&lt;/span> : 20880,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;sslPort&amp;#34;&lt;/span> : &lt;span style="color:#cb4b16">null&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;payload&amp;#34;&lt;/span> : {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;@class&amp;#34;&lt;/span> : &lt;span style="color:#2aa198">&amp;#34;org.apache.dubbo.registry.zookeeper.ZookeeperInstance&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;id&amp;#34;&lt;/span> : &lt;span style="color:#2aa198">&amp;#34;192.168.1.9:20880&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;name&amp;#34;&lt;/span> : &lt;span style="color:#2aa198">&amp;#34;dubbo-demo-api-provider&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;metadata&amp;#34;&lt;/span> : {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;dubbo.endpoints&amp;#34;&lt;/span> : &lt;span style="color:#2aa198">&amp;#34;[{\&amp;#34;port\&amp;#34;:20880,\&amp;#34;protocol\&amp;#34;:\&amp;#34;dubbo\&amp;#34;}]&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;dubbo.metadata-service.url-params&amp;#34;&lt;/span> : &lt;span style="color:#2aa198">&amp;#34;{\&amp;#34;connections\&amp;#34;:\&amp;#34;1\&amp;#34;,\&amp;#34;version\&amp;#34;:\&amp;#34;1.0.0\&amp;#34;,\&amp;#34;dubbo\&amp;#34;:\&amp;#34;2.0.2\&amp;#34;,\&amp;#34;release\&amp;#34;:\&amp;#34;3.0.8\&amp;#34;,\&amp;#34;side\&amp;#34;:\&amp;#34;provider\&amp;#34;,\&amp;#34;port\&amp;#34;:\&amp;#34;20880\&amp;#34;,\&amp;#34;protocol\&amp;#34;:\&amp;#34;dubbo\&amp;#34;}&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;dubbo.metadata.revision&amp;#34;&lt;/span> : &lt;span style="color:#2aa198">&amp;#34;a662fd2213a8a49dc6ff43a4c2ae7b9e&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;dubbo.metadata.storage-type&amp;#34;&lt;/span> : &lt;span style="color:#2aa198">&amp;#34;local&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;timestamp&amp;#34;&lt;/span> : &lt;span style="color:#2aa198">&amp;#34;1654916298616&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;registrationTimeUTC&amp;#34;&lt;/span> : 1654917265499,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;serviceType&amp;#34;&lt;/span> : &lt;span style="color:#2aa198">&amp;#34;DYNAMIC&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;uriSpec&amp;#34;&lt;/span> : &lt;span style="color:#cb4b16">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果感兴趣的话可以看更详细的curator服务发现文档&lt;a href="https://curator.apache.org/docs/service-discovery/index.html">curator-x-discovery&lt;/a>&lt;/p>
&lt;h3 id="1742-abstractservicediscovery的构造器">17.4.2 AbstractServiceDiscovery的构造器&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">AbstractServiceDiscovery&lt;/span>(ApplicationModel applicationModel, URL registryURL) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//调用重载的构造器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>(applicationModel.getApplicationName(), registryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.applicationModel &lt;span style="color:#719e07">=&lt;/span> applicationModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MetadataReportInstance metadataReportInstance &lt;span style="color:#719e07">=&lt;/span> applicationModel.getBeanFactory().getBean(MetadataReportInstance.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataType &lt;span style="color:#719e07">=&lt;/span> metadataReportInstance.getMetadataType();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.metadataReport &lt;span style="color:#719e07">=&lt;/span> metadataReportInstance.getMetadataReport(registryURL.getParameter(REGISTRY_CLUSTER_KEY));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// if (REMOTE_METADATA_STORAGE_TYPE.equals(metadataReportInstance.getMetadataType())) {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// this.metadataReport = metadataReportInstance.getMetadataReport(registryURL.getParameter(REGISTRY_CLUSTER_KEY));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// } else {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// this.metadataReport = metadataReportInstance.getNopMetadataReport();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>重载的构造器&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">AbstractServiceDiscovery&lt;/span>(String serviceName, URL registryURL) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.applicationModel &lt;span style="color:#719e07">=&lt;/span> ApplicationModel.defaultModel();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个url参考：zookeeper://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;interface=org.apache.dubbo.registry.client.ServiceDiscovery&amp;amp;pid=4570&amp;amp;release=3.0.8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.registryURL &lt;span style="color:#719e07">=&lt;/span> registryURL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个serviceName参考dubbo-demo-api-provider&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.serviceName &lt;span style="color:#719e07">=&lt;/span> serviceName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//MetadataInfo 用来封装元数据信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.metadataInfo &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> MetadataInfo(serviceName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个是元数据缓存信息管理的类型 缓存文件使用LRU策略 感兴趣的可以详细看看&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//对应缓存路径为：/Users/song/.dubbo/.metadata.zookeeper127.0.0.1%003a2181.dubbo.cache&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.metaCacheManager &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> MetaCacheManager(getCacheNameSuffix(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationModel.getFrameworkModel().getBeanFactory()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .getBean(FrameworkExecutorRepository.class).getCacheRefreshingScheduledExecutor());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="175-服务映射类型abstractservicenamemapping">17.5 服务映射类型AbstractServiceNameMapping&lt;/h2>
&lt;p>服务映射主要是通过服务名字来反查应用信息的应用名字如下图所示
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/17-register8.png" alt="在这里插入图片描述">
这里我们来看下服务映射相关的类型主要通过如下代码来获取扩展对象：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">this&lt;/span>.serviceNameMapping &lt;span style="color:#719e07">=&lt;/span> (AbstractServiceNameMapping) ServiceNameMapping.getDefaultExtension(registryURL.getScopeModel());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对应类型如下：
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/17-register9.png" alt="在这里插入图片描述">&lt;/p>
&lt;p>最终获取的扩展实现类型为：MetadataServiceNameMapping
构造器如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">MetadataServiceNameMapping&lt;/span>(ApplicationModel applicationModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataReportInstance &lt;span style="color:#719e07">=&lt;/span> applicationModel.getBeanFactory().getBean(MetadataReportInstance.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>服务映射元数据父类型AbstractServiceNameMapping如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">AbstractServiceNameMapping&lt;/span>(ApplicationModel applicationModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.applicationModel &lt;span style="color:#719e07">=&lt;/span> applicationModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//LRU缓存保存服务映射数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.mappingCacheManager &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> MappingCacheManager(&lt;span style="color:#2aa198">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationModel.getFrameworkModel().getBeanFactory()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .getBean(FrameworkExecutorRepository.class).getCacheRefreshingScheduledExecutor());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="174-双注册元数据信息发布到注册中心">17.4 双注册元数据信息发布到注册中心&lt;/h2>
&lt;h3 id="1741-回顾简介">17.4.1 回顾简介&lt;/h3>
&lt;p>前面注册数据的时候并没有把服务配置的元数据直接注册在注册中心而是需要在导出服务之后在ServiceConfig中来发布元数据，这个就需要我们回到ServiceConfig的exportUrl方法来看了如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">exportUrl&lt;/span>(URL url, List&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> registryURLs) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String scope &lt;span style="color:#719e07">=&lt;/span> url.getParameter(SCOPE_KEY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// don&amp;#39;t export when none is configured&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...省略到若干代码
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>SCOPE_LOCAL.equalsIgnoreCase(scope)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url &lt;span style="color:#719e07">=&lt;/span> exportRemote(url, registryURLs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>isGeneric(generic) &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>getScopeModel().isInternal()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MetadataUtils.publishServiceDefinition(url, providerModel.getServiceModel(), getApplicationModel());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.urls.add(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1742-元数据服务定义数据的发布">17.4.2 元数据服务定义数据的发布&lt;/h3>
&lt;p>在exportRemote之后单独调用发布元数据的方法来发布，通过调用元数据工具类来发布元数据信息接下来我们详细看下:
MetadataUtils类型的publishServiceDefinition方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">publishServiceDefinition&lt;/span>(URL url, ServiceDescriptor serviceDescriptor, ApplicationModel applicationModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//查询是否存在元数据存储对象 对应接口MetadataReport 这里对应实现类 ZookeeperMetadataReport&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (getMetadataReports(applicationModel).size() &lt;span style="color:#719e07">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String msg &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Remote Metadata Report Server is not provided or unavailable, will stop registering service definition to remote center!&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(msg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String side &lt;span style="color:#719e07">=&lt;/span> url.getSide();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务提供者走这个逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (PROVIDER_SIDE.equalsIgnoreCase(side)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String serviceKey &lt;span style="color:#719e07">=&lt;/span> url.getServiceKey();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取当前服务元数据信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FullServiceDefinition serviceDefinition &lt;span style="color:#719e07">=&lt;/span> serviceDescriptor.getFullServiceDefinition(serviceKey);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isNotEmpty(serviceKey) &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> serviceDefinition &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceDefinition.setParameters(url.getParameters());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (Map.Entry&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, MetadataReport&lt;span style="color:#719e07">&amp;gt;&lt;/span> entry : getMetadataReports(applicationModel).entrySet()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MetadataReport metadataReport &lt;span style="color:#719e07">=&lt;/span> entry.getValue();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>metadataReport.shouldReportDefinition()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;Report of service definition is disabled for &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> entry.getKey());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//存储服务提供者的元数据 metadataReport类型为ZookeeperMetadataReport 方法来源于父类模板方法： AbstractMetadataReport类型的storeProviderMetadata模板方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataReport.storeProviderMetadata(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">new&lt;/span> MetadataIdentifier(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url.getServiceInterface(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url.getVersion() &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">?&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&amp;#34;&lt;/span> : url.getVersion(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url.getGroup() &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">?&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&amp;#34;&lt;/span> : url.getGroup(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PROVIDER_SIDE,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationModel.getApplicationName())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> , serviceDefinition);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务消费者走这个逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (Map.Entry&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, MetadataReport&lt;span style="color:#719e07">&amp;gt;&lt;/span> entry : getMetadataReports(applicationModel).entrySet()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MetadataReport metadataReport &lt;span style="color:#719e07">=&lt;/span> entry.getValue();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>metadataReport.shouldReportDefinition()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;Report of service definition is disabled for &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> entry.getKey());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataReport.storeConsumerMetadata(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">new&lt;/span> MetadataIdentifier(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url.getServiceInterface(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url.getVersion() &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">?&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&amp;#34;&lt;/span> : url.getVersion(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url.getGroup() &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">?&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&amp;#34;&lt;/span> : url.getGroup(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CONSUMER_SIDE,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationModel.getApplicationName()),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url.getParameters());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//ignore error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(&lt;span style="color:#2aa198">&amp;#34;publish service definition metadata error.&amp;#34;&lt;/span>, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>AbstractMetadataReport的storeProviderMetadata方法如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">storeProviderMetadata&lt;/span>(MetadataIdentifier providerMetadataIdentifier, ServiceDefinition serviceDefinition) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//是否同步配置对应sync-report 默认为异步&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (syncReport) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> storeProviderMetadataTask(providerMetadataIdentifier, serviceDefinition);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reportCacheExecutor.execute(() &lt;span style="color:#719e07">-&amp;gt;&lt;/span> storeProviderMetadataTask(providerMetadataIdentifier, serviceDefinition));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>AbstractMetadataReport的存储元数据方法storeProviderMetadataTask&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">storeProviderMetadataTask&lt;/span>(MetadataIdentifier providerMetadataIdentifier, ServiceDefinition serviceDefinition) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (logger.isInfoEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;store provider metadata. Identifier : &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> providerMetadataIdentifier &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;; definition: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> serviceDefinition);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> allMetadataReports.put(providerMetadataIdentifier, serviceDefinition);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> failedReports.remove(providerMetadataIdentifier);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Gson gson &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> Gson();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String data &lt;span style="color:#719e07">=&lt;/span> gson.toJson(serviceDefinition);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doStoreProviderMetadata(providerMetadataIdentifier, data);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> saveProperties(providerMetadataIdentifier, data, &lt;span style="color:#cb4b16">true&lt;/span>, &lt;span style="color:#719e07">!&lt;/span>syncReport);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// retry again. If failed again, throw exception.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> failedReports.put(providerMetadataIdentifier, serviceDefinition);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataReportRetry.startRetryTask();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(&lt;span style="color:#2aa198">&amp;#34;Failed to put provider metadata &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> providerMetadataIdentifier &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; in &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> serviceDefinition &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, cause: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> e.getMessage(), e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/17-register10.png" alt="在这里插入图片描述">&lt;/p>
&lt;p>元数据信息如下：可以分为两类 应用元数据，服务元数据&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;parameters&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;side&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;provider&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;interface&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;link.elastic.dubbo.entity.DemoService&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;pid&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;22099&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;application&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;dubbo-demo-api-provider&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;dubbo&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;2.0.2&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;release&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;3.0.8&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;anyhost&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;bind.ip&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;192.168.1.9&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;methods&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;sayHello,sayHelloAsync&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;background&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;false&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;deprecated&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;false&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;dynamic&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;service-name-mapping&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;generic&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;false&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;bind.port&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;20880&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;timestamp&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;1654942353902&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;canonicalName&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;link.elastic.dubbo.entity.DemoService&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;codeSource&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;file:/Users/song/Desktop/dubbo-test/target/classes/&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;methods&amp;#34;&lt;/span>: [{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;sayHelloAsync&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;parameterTypes&amp;#34;&lt;/span>: [&lt;span style="color:#2aa198">&amp;#34;java.lang.String&amp;#34;&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;returnType&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.util.concurrent.CompletableFuture&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;annotations&amp;#34;&lt;/span>: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;sayHello&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;parameterTypes&amp;#34;&lt;/span>: [&lt;span style="color:#2aa198">&amp;#34;java.lang.String&amp;#34;&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;returnType&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.lang.String&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;annotations&amp;#34;&lt;/span>: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;types&amp;#34;&lt;/span>: [{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.util.concurrent.CompletableFuture&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;properties&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;result&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.lang.Object&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;stack&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.util.concurrent.CompletableFuture.Completion&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.lang.Object&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.lang.String&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.util.concurrent.CompletableFuture.Completion&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;properties&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;next&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.util.concurrent.CompletableFuture.Completion&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;status&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;int&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;int&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;annotations&amp;#34;&lt;/span>: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Zookeeper扩展类型ZookeeperMetadataReport实现的存储方法如下所示doStoreProviderMetadata：&lt;/p>
&lt;p>如果我们自己实现一套元数据就可以重写这个方法来进行元数据的额存储&lt;/p>
&lt;p>ZookeeperMetadataReport的doStoreProviderMetadata&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">doStoreProviderMetadata&lt;/span>(MetadataIdentifier providerMetadataIdentifier, String serviceDefinitions) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> storeMetadata(providerMetadataIdentifier, serviceDefinitions);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ZookeeperMetadataReport的storeMetadata&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">storeMetadata&lt;/span>(MetadataIdentifier metadataIdentifier, String v) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//参数false为非临时节点，这个元数据为持久节点，这个细节就暂时不看了就是将刚刚的json元数据存储到对应路径上面：路径为：/dubbo/metadata/link.elastic.dubbo.entity.DemoService/provider/dubbo-demo-api-provider&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zkClient.create(getNodePath(metadataIdentifier), v, &lt;span style="color:#cb4b16">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原文地址：&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/17-dubbo3-ying-yong-ji-zhu-ce-zhi-fu-wu-ti-gong-zhe-de-shuang-zhu-ce-yuan-li/">17-Dubbo服务提供者的双注册原理&lt;/a>&lt;/p></description></item><item><title>Blog: 16-模块发布器发布服务全过程</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/16/16-%E6%A8%A1%E5%9D%97%E5%8F%91%E5%B8%83%E5%99%A8%E5%8F%91%E5%B8%83%E6%9C%8D%E5%8A%A1%E5%85%A8%E8%BF%87%E7%A8%8B/</link><pubDate>Tue, 16 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/16/16-%E6%A8%A1%E5%9D%97%E5%8F%91%E5%B8%83%E5%99%A8%E5%8F%91%E5%B8%83%E6%9C%8D%E5%8A%A1%E5%85%A8%E8%BF%87%E7%A8%8B/</guid><description>
&lt;h1 id="16-模块发布器发布服务全过程">16-模块发布器发布服务全过程&lt;/h1>
&lt;h2 id="161-简介">16.1 简介&lt;/h2>
&lt;p>Dubbo做为服务治理框架,比较核心的就是服务相关的概念,这里我先贴个找到的关于Dubbo工作原理的架构图:
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/16-deploy.png" alt="在这里插入图片描述">
如果按完整服务启动与订阅的顺序我们可以归结为以下6点:&lt;/p>
&lt;ul>
&lt;li>导出服务(提供者)
&lt;ul>
&lt;li>服务提供方通过指定端口对外暴露服务&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>注册服务(提供者)
&lt;ul>
&lt;li>提供方向注册中心注册自己的信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>(服务发现)-订阅服务(消费者)
&lt;ul>
&lt;li>服务调用方通过注册中心订阅自己感兴趣的服务&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>(服务发现)-服务推送(消费者)
&lt;ul>
&lt;li>注册中心向调用方推送地址列表&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>调用服务(消费者调用提供者)
&lt;ul>
&lt;li>调用方选择一个地址发起RPC调用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>监控服务
&lt;ul>
&lt;li>服务提供方和调用方的统计数据由监控模块收集展示&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>上面的完整的服务启动订阅与调用流程不仅仅适用于Dubbo 同样也适用于其他服务治理与发现的模型, 一般服务发现与服务调用的思路就是这样的,我们将以上内容扩展,暴漏服务可以使用http,tcp,udp等各种协议,注册服务可以注册到Redis,Dns,Etcd,Zookeeper等注册中心中,订阅服务可以主动去注册中心查询服务列表,服务发现可以让注册中心将服务数据动态推送给消费者.Dubbo其实就是基于这种简单的服务模型来扩展出各种功能的支持,来满足服务治理的各种场景,了解了这里可能各位同学就想着自行开发一个简单的微服务框架了。&lt;/p>
&lt;p>回到主题,从以上的服务完整发布调用流程可以看到,所有的功能都是由导出服务(提供者)开始的,只有提供者先提供了服务才可以有真正的服务让消费者调用。&lt;/p>
&lt;p>之前的博客内容 链接:&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/12-quan-ju-shi-ye-lai-kan-dubbo3.0.8-de-fu-wu-qi-dong-sheng-ming-zhou-qi/">&amp;laquo;12-全局视野来看Dubbo3.0.8的服务启动生命周期&amp;raquo;&lt;/a> 我们了解了 DefaultModuleDeployer模块器启动的流程,其中在start代码的模版方法中开始了导出服务的功能,这里我们来详细看下服务发布的全过程:&lt;/p>
&lt;p>入口代码: DefaultModuleDeployer的发布服务方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">exportServices&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//从配置管缓存中查询缓存的所有的服务配置然后逐个服务发布&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (ServiceConfigBase sc : configManager.getServices()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exportServiceInternal(sc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="162-导出服务的入口">16.2 导出服务的入口&lt;/h2>
&lt;p>入口代码: DefaultModuleDeployer的发布服务方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">exportServices&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//从配置管缓存中查询缓存的所有的服务配置然后逐个服务发布&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (ServiceConfigBase sc : configManager.getServices()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exportServiceInternal(sc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>主要流程为遍历初始化的服务配置列表然后逐个服务开始到处
内部导出服务代码:
exportServiceInternal方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">exportServiceInternal&lt;/span>(ServiceConfigBase sc) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServiceConfig&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> serviceConfig &lt;span style="color:#719e07">=&lt;/span> (ServiceConfig&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span>) sc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务配置刷新 配置优先级覆盖&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>serviceConfig.isRefreshed()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceConfig.refresh();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务已经导出过了就直接返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (sc.isExported()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//是否异步方式导出 全局配置或者服务级其中一个配置了异步则异步处理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (exportAsync &lt;span style="color:#719e07">||&lt;/span> sc.shouldExportAsync()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//异步其实就是使用线程来导出服务serviceExportExecutor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ExecutorService executor &lt;span style="color:#719e07">=&lt;/span> executorRepository.getServiceExportExecutor();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CompletableFuture&lt;span style="color:#719e07">&amp;lt;&lt;/span>Void&lt;span style="color:#719e07">&amp;gt;&lt;/span> future &lt;span style="color:#719e07">=&lt;/span> CompletableFuture.runAsync(() &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>sc.isExported()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sc.export();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exportedServices.add(sc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(getIdentifier() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; export async catch error : &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> t.getMessage(), t);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, executor);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> asyncExportingFutures.add(future);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//同步导出服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>sc.isExported()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sc.export();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exportedServices.add(sc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个逻辑里面做了一些基本的操作,可以直接看注释然后调用ServiceConfig的export的来导出服务,继续往后看服务配置的导出服务方法。&lt;/p>
&lt;h2 id="163-服务配置导出服务模板方法">16.3 服务配置导出服务模板方法&lt;/h2>
&lt;p>核心的服务导出代码是在服务配置中来做的ServiceConfig的 export() 方法
ServiceConfig的 export() 方法代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">export&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//已经导出过服务直接放那会&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">this&lt;/span>.exported) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ensure start module, compatible with old api usage&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//确保模块启动了(基本的初始化操作执行了)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getScopeModel().getDeployer().start();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//悲观锁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (&lt;span style="color:#719e07">this&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//双重校验&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">this&lt;/span>.exported) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置是否刷新 前面初始化时候已经刷新过配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>&lt;span style="color:#719e07">this&lt;/span>.isRefreshed()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.refresh();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务导出配置配置为false则不导出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">this&lt;/span>.shouldExport()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务发布前初始化一下元数据对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.init();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (shouldDelay()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置了服务的延迟发布配置则走延迟发布逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doDelayExport();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//导出服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doExport();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1631-服务配置导出服务前的初始化方法">16.3.1 服务配置导出服务前的初始化方法&lt;/h3>
&lt;p>ServiceConfig 导出服务之前的初始化方法init&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">init&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">this&lt;/span>.initialized.compareAndSet(&lt;span style="color:#cb4b16">false&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加载服务监听器 这里暂时没有服务监听器扩展&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// load ServiceListeners from extension&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>ServiceListener&lt;span style="color:#719e07">&amp;gt;&lt;/span> extensionLoader &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.getExtensionLoader(ServiceListener.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.serviceListeners.addAll(extensionLoader.getSupportedExtensionInstances());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务提供者配置传递给元数据配置对象 一个服务提供者配置会有一个元数据配置，服务配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initServiceMetadata(provider);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//元数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceMetadata.setServiceType(getInterfaceClass());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceMetadata.setTarget(getRef());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//元数据的key格式为 group/服务接口:版本号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceMetadata.generateServiceKey();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="164-服务配置导出服务模板方法2">16.4 服务配置导出服务模板方法2&lt;/h2>
&lt;p>ServiceConfig 导出服务核心逻辑&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#268bd2">synchronized&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">doExport&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//取消发布&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (unexported) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;The service &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> interfaceClass.getName() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; has already unexported!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//已经发布&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (exported) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务路径 为空则设置为接口名，本例子中为link.elastic.dubbo.entity.DemoService&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isEmpty(path)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path &lt;span style="color:#719e07">=&lt;/span> interfaceName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//导出URL&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doExportUrls();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exported();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1641-导出服务的url配置逻辑">16.4.1 导出服务的URL配置逻辑&lt;/h3>
&lt;p>ServiceConfig 导出URL核心逻辑&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">doExportUrls&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//模块服务存储库&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ModuleServiceRepository repository &lt;span style="color:#719e07">=&lt;/span> getScopeModel().getServiceRepository();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServiceDescriptor serviceDescriptor;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//ref为服务实现类型 这里对应我们例子的DemoServiceImpl&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">final&lt;/span> &lt;span style="color:#dc322f">boolean&lt;/span> serverService &lt;span style="color:#719e07">=&lt;/span> ref &lt;span style="color:#719e07">instanceof&lt;/span> ServerService;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span>(serverService){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceDescriptor&lt;span style="color:#719e07">=&lt;/span>((ServerService) ref).getServiceDescriptor();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repository.registerService(serviceDescriptor);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }&lt;span style="color:#719e07">else&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//我们代码走这个逻辑 注册服务 这个注册不是向注册中心注册 这个是解析服务接口将服务方法等描述信息存放在了服务存储ModuleServiceRepository类型对象的成员变量services中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceDescriptor &lt;span style="color:#719e07">=&lt;/span> repository.registerService(getInterfaceClass());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//提供者领域模型， 提供者领域模型 封装了一些提供者需要的就基本属性同时内部解析封装方法信息 ProviderMethodModel 列表 ， 服务标识符 格式group/服务接:版本号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> providerModel &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ProviderModel(getUniqueServiceName(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务实现类DemoServiceImpl&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ref,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务描述符 描述符里面包含了服务接口的方法信息，不过服务接口通过反射也可以拿到方法信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceDescriptor,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//当前所处模型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getScopeModel(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//当前服务接口的元数据对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceMetadata);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//模块服务存储库存储提供者模型对象ModuleServiceRepository&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repository.registerProvider(providerModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取配置的注册中心列表 ，同时将注册中心配置转URL （在Dubbo中URL就是配置信息的一种形式）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里会获取到两个 由dubbo.application.register-mode 双注册配置决定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注册中心 registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;pid=9008&amp;amp;registry=zookeeper&amp;amp;release=3.0.8&amp;amp;timestamp=1653703292768&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//service-discovery-registry://8.131.79.126:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;pid=10275&amp;amp;registry=zookeeper&amp;amp;release=3.0.8&amp;amp;timestamp=1653704425920&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//参数dubbo是dubbo协议的版本不是Dubbo版本 Dubbo RPC protocol version, for compatibility, it must not be between 2.0.10 ~ 2.6.2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里后面详细说下 服务双注册 dubbo.application.register-mode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> registryURLs &lt;span style="color:#719e07">=&lt;/span> ConfigValidationUtils.loadRegistries(&lt;span style="color:#719e07">this&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (ProtocolConfig protocolConfig : protocols) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String pathKey &lt;span style="color:#719e07">=&lt;/span> URL.buildKey(getContextPath(protocolConfig)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map(p &lt;span style="color:#719e07">-&amp;gt;&lt;/span> p &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;/&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> path)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .orElse(path), group, version);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// stub service will use generated service name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span>(&lt;span style="color:#719e07">!&lt;/span>serverService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// In case user specified path, register service one more time to map it to path.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//模块服务存储库ModuleServiceRepository存储服务接口信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repository.registerService(pathKey, interfaceClass);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//导出根据协议导出配置到注册中心&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doExportUrlsFor1Protocol(protocolConfig, registryURLs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1642-应用级和接口级服务注册地址获取">16.4.2 应用级和接口级服务注册地址获取&lt;/h3>
&lt;p>这里主要看下注册中心的获取，这里涉及到服务的双注册配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> registryURLs &lt;span style="color:#719e07">=&lt;/span> ConfigValidationUtils.loadRegistries(&lt;span style="color:#719e07">this&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>关于loadRegistries方法的详情我们就不看了主要看loadRegistries方法中调用的genCompatibleRegistries添加服务发现注册中心&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param scopeModel 域模型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param registryList 配置的注册中心列表 例如：registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;pid=9008&amp;amp;registry=zookeeper&amp;amp;release=3.0.8&amp;amp;timestamp=1653703292768
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param provider 是否为服务提供者 这里Demo为true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">genCompatibleRegistries&lt;/span>(ScopeModel scopeModel, List&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> registryList, &lt;span style="color:#dc322f">boolean&lt;/span> provider) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> result &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(registryList.size());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//遍历所有的注册中心 为每个注册中心增加兼容的服务发现注册中心地址配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registryList.forEach(registryURL &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//是否为提供者 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (provider) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// for registries enabled service discovery, automatically register interface compatible addresses.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String registerMode;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注册协议配置了service-discovery-registry 走这个逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//前面这个逻辑是直接接给result结果中添加应用级注册，如果是all配置则增加接口级注册信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (SERVICE_REGISTRY_PROTOCOL.equals(registryURL.getProtocol())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registerMode &lt;span style="color:#719e07">=&lt;/span> registryURL.getParameter(REGISTER_MODE_KEY, ConfigurationUtils.getCachedDynamicProperty(scopeModel, DUBBO_REGISTER_MODE_DEFAULT_KEY, DEFAULT_REGISTER_MODE_INSTANCE));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>isValidRegisterMode(registerMode)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registerMode &lt;span style="color:#719e07">=&lt;/span> DEFAULT_REGISTER_MODE_INSTANCE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里配置的就是应用级配置 则先添加应用级地址，再根据条件判断是否添加接口级注册中心地址&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.add(registryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (DEFAULT_REGISTER_MODE_ALL.equalsIgnoreCase(registerMode)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> registryNotExists(registryURL, registryList, REGISTRY_PROTOCOL)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL interfaceCompatibleRegistryURL &lt;span style="color:#719e07">=&lt;/span> URLBuilder.from(registryURL)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setProtocol(REGISTRY_PROTOCOL)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .removeParameter(REGISTRY_TYPE_KEY)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .build();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.add(interfaceCompatibleRegistryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//正常情况下我们的配置会走这个逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 获取服务注册的注册模式 配置为dubbo.application.register-mode 默认值为all 既注册接口数据又注册应用级信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registerMode &lt;span style="color:#719e07">=&lt;/span> registryURL.getParameter(REGISTER_MODE_KEY, ConfigurationUtils.getCachedDynamicProperty(scopeModel, DUBBO_REGISTER_MODE_DEFAULT_KEY, DEFAULT_REGISTER_MODE_ALL));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>isValidRegisterMode(registerMode)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registerMode &lt;span style="color:#719e07">=&lt;/span> DEFAULT_REGISTER_MODE_INTERFACE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//根据逻辑条件判断是否添加应用级注册中心地址&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> ((DEFAULT_REGISTER_MODE_INSTANCE.equalsIgnoreCase(registerMode) &lt;span style="color:#719e07">||&lt;/span> DEFAULT_REGISTER_MODE_ALL.equalsIgnoreCase(registerMode))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> registryNotExists(registryURL, registryList, SERVICE_REGISTRY_PROTOCOL)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL serviceDiscoveryRegistryURL &lt;span style="color:#719e07">=&lt;/span> URLBuilder.from(registryURL)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setProtocol(SERVICE_REGISTRY_PROTOCOL)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .removeParameter(REGISTRY_TYPE_KEY)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .build();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.add(serviceDiscoveryRegistryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//根据逻辑条件判断是否添加接口级注册中心地址&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (DEFAULT_REGISTER_MODE_INTERFACE.equalsIgnoreCase(registerMode) &lt;span style="color:#719e07">||&lt;/span> DEFAULT_REGISTER_MODE_ALL.equalsIgnoreCase(registerMode)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.add(registryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FrameworkStatusReportService reportService &lt;span style="color:#719e07">=&lt;/span> ScopeModelUtil.getApplicationModel(scopeModel).getBeanFactory().getBean(FrameworkStatusReportService.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reportService.reportRegistrationStatus(reportService.createRegistrationReport(registerMode));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.add(registryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个方法是根据服务注册模式来判断使用接口级注册地址还是应用级注册地址分别如下所示：
配置信息：
dubbo.application.register-mode
配置值：&lt;/p>
&lt;ul>
&lt;li>interface
&lt;ul>
&lt;li>接口级注册&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>instance
&lt;ul>
&lt;li>应用级注册&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>all
&lt;ul>
&lt;li>接口级别和应用级都注册&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>接口级注册地址：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>registry:&lt;span style="color:#586e75">//127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;pid=9008&amp;amp;registry=zookeeper&amp;amp;release=3.0.8&amp;amp;timestamp=1653703292768&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>应用级注册地址：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>service&lt;span style="color:#719e07">-&lt;/span>discovery&lt;span style="color:#719e07">-&lt;/span>registry:&lt;span style="color:#586e75">//8.131.79.126:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;pid=10275&amp;amp;registry=zookeeper&amp;amp;release=3.0.8&amp;amp;timestamp=1653704425920&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="165-导出服务配置到本地和注册中心">16.5 导出服务配置到本地和注册中心&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> doExportUrlsFor1Protocol(protocolConfig, registryURLs);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>protocolConfig为：dubbo协议的配置
&amp;lt;dubbo:protocol port=&amp;quot;-1&amp;quot; name=&amp;ldquo;dubbo&amp;rdquo; /&amp;gt;&lt;/p>
&lt;p>registryURLs目前有两个 应用级注册地址和接口级注册地址：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>registry:&lt;span style="color:#586e75">//127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;pid=9008&amp;amp;registry=zookeeper&amp;amp;release=3.0.8&amp;amp;timestamp=1653703292768&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>service&lt;span style="color:#719e07">-&lt;/span>discovery&lt;span style="color:#719e07">-&lt;/span>registry:&lt;span style="color:#586e75">//8.131.79.126:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;pid=10275&amp;amp;registry=zookeeper&amp;amp;release=3.0.8&amp;amp;timestamp=1653704425920&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1651-导出服务配置的doexporturlsfor1protocol方法">16.5.1 导出服务配置的doExportUrlsFor1Protocol方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">doExportUrlsFor1Protocol&lt;/span>(ProtocolConfig protocolConfig, List&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> registryURLs) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//生成协议配置具体可见下图中的元数据配置中的attachments&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&lt;/span> map &lt;span style="color:#719e07">=&lt;/span> buildAttributes(protocolConfig);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// remove null key and null value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//移除空值 简化配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map.keySet().removeIf(key &lt;span style="color:#719e07">-&amp;gt;&lt;/span> key &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> map.get(key) &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// init serviceMetadata attachments&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//协议配置放到元数据对象中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceMetadata.getAttachments().putAll(map);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//协议配置 + 默认协议配置转URL类型的配置存储&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL url &lt;span style="color:#719e07">=&lt;/span> buildUrl(protocolConfig, map);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//导出url&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exportUrl(url, registryURLs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/16-deploy2.png" alt="在这里插入图片描述">&lt;/p>
&lt;h3 id="1652-导出服务配置模板方法">16.5.2 导出服务配置模板方法&lt;/h3>
&lt;p>继续看导出服务的模板方法，分为本地导出和注册中心导出
//参数url为协议配置url可以参考：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>dubbo:&lt;span style="color:#586e75">//192.168.1.9:20880/link.elastic.dubbo.entity.DemoService?anyhost=true&amp;amp;application=dubbo-demo-api-provider&amp;amp;background=false&amp;amp;bind.ip=192.168.1.9&amp;amp;bind.port=20880&amp;amp;deprecated=false&amp;amp;dubbo=2.0.2&amp;amp;dynamic=true&amp;amp;generic=false&amp;amp;interface=link.elastic.dubbo.entity.DemoService&amp;amp;methods=sayHello,sayHelloAsync&amp;amp;pid=10953&amp;amp;release=3.0.8&amp;amp;side=provider&amp;amp;timestamp=1653705630518&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">exportUrl&lt;/span>(URL url, List&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> registryURLs) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String scope &lt;span style="color:#719e07">=&lt;/span> url.getParameter(SCOPE_KEY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// don&amp;#39;t export when none is configured&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>SCOPE_NONE.equalsIgnoreCase(scope)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// export to local if the config is not remote (export to remote only when config is remote)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//未明确指定远程导出 则开启本地导出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>SCOPE_REMOTE.equalsIgnoreCase(scope)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exportLocal(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//未明确指定本地导出 则开启远程导出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// export to remote if the config is not local (export to local only when config is local)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>SCOPE_LOCAL.equalsIgnoreCase(scope)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url &lt;span style="color:#719e07">=&lt;/span> exportRemote(url, registryURLs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>isGeneric(generic) &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>getScopeModel().isInternal()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MetadataUtils.publishServiceDefinition(url, providerModel.getServiceModel(), getApplicationModel());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.urls.add(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="166-导出服务到本地">16.6 导出服务到本地&lt;/h2>
&lt;p>本地调用使用了 injvm 协议，是一个伪协议，它不开启端口，不发起远程调用，只在 JVM 内直接关联，但执行 Dubbo 的 Filter 链。&lt;/p>
&lt;p>直接通过代码来看吧&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">exportLocal&lt;/span>(URL url) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//协议转为injvm 代表本地导出 host为127.0.0.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL local &lt;span style="color:#719e07">=&lt;/span> URLBuilder.from(url)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setProtocol(LOCAL_PROTOCOL)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setHost(LOCALHOST_VALUE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setPort(0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .build();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> local &lt;span style="color:#719e07">=&lt;/span> local.setScopeModel(getScopeModel())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setServiceModel(providerModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doExportUrl(local, &lt;span style="color:#cb4b16">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;Export dubbo service &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> interfaceClass.getName() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; to local registry url : &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> local);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1661-doexporturl方法">16.6.1 doExportUrl方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">doExportUrl&lt;/span>(URL url, &lt;span style="color:#dc322f">boolean&lt;/span> withMetaData) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里是由adaptor扩展类型处理过的 我们直接看默认的类型javassist 对应JavassistProxyFactory代理工厂 获取调用对象 （&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Invoker&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> invoker &lt;span style="color:#719e07">=&lt;/span> proxyFactory.getInvoker(ref, (Class) interfaceClass, url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (withMetaData) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> invoker &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> DelegateProviderMetaDataInvoker(invoker, &lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Exporter&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> exporter &lt;span style="color:#719e07">=&lt;/span> protocolSPI.export(invoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exporters.add(exporter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1662-javassistproxyfactory类型的getinvoker方法">16.6.2 JavassistProxyFactory类型的getInvoker方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">getInvoker&lt;/span>(T proxy, Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type, URL url) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// TODO Wrapper cannot handle this scenario correctly: the classname contains &amp;#39;$&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 创建实际服务提供者的代理类型，代理类型后缀为DubboWrap在这里类型为 link.elastic.dubbo.entity.DemoServiceImplDubboWrap0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">final&lt;/span> Wrapper wrapper &lt;span style="color:#719e07">=&lt;/span> Wrapper.getWrapper(proxy.getClass().getName().indexOf(&lt;span style="color:#2aa198">&amp;#39;$&amp;#39;&lt;/span>) &lt;span style="color:#719e07">&amp;lt;&lt;/span> 0 &lt;span style="color:#719e07">?&lt;/span> proxy.getClass() : type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建一个匿名内部类对象 继承自AbstractProxyInvoker的Invoker对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> AbstractProxyInvoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span>(proxy, type, url) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> Object &lt;span style="color:#268bd2">doInvoke&lt;/span>(T proxy, String methodName,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;[]&lt;/span> parameterTypes,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object&lt;span style="color:#719e07">[]&lt;/span> arguments) &lt;span style="color:#268bd2">throws&lt;/span> Throwable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable fromJavassist) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// try fall back to JDK proxy factory&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1663-使用协议导出调用对象-export">16.6.3 使用协议导出调用对象 export&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> Exporter&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> exporter &lt;span style="color:#719e07">=&lt;/span> protocolSPI.export(invoker);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个使用了Adaptor扩展和Wrapper机制Debug起来不太方便这里贴一下调用堆栈&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/16-deploy3.png" alt="在这里插入图片描述">&lt;/p>
&lt;h3 id="16631-协议序列化机制protocolserializationwrapper">16.6.3.1 协议序列化机制ProtocolSerializationWrapper&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Exporter&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">export&lt;/span>(Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> invoker) &lt;span style="color:#268bd2">throws&lt;/span> RpcException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里主要逻辑是将服务提供者url添加到服务存储仓库中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getFrameworkModel(invoker.getUrl().getScopeModel()).getServiceRepository().registerProviderUrl(invoker.getUrl());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> protocol.export(invoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="16632-协议过滤器wrapper-protocolfilterwrapper">16.6.3.2 协议过滤器Wrapper ProtocolFilterWrapper&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Exporter&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">export&lt;/span>(Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> invoker) &lt;span style="color:#268bd2">throws&lt;/span> RpcException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注册中心的协议导出直接执行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (UrlUtils.isRegistry(invoker.getUrl())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> protocol.export(invoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//过滤器调用链FilterChainBuilder的扩展对象查询&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FilterChainBuilder builder &lt;span style="color:#719e07">=&lt;/span> getFilterChainBuilder(invoker.getUrl());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里分为2步 生成过滤器调用链 然后使用链表中的节点调用 这里值查询provider类型的过滤器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> protocol.export(builder.buildInvokerChain(invoker, SERVICE_FILTER_KEY, CommonConstants.PROVIDER));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>过滤器调用链的生成 对用DefaultFilterChainBuilder类型的buildInvokerChain方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">buildInvokerChain&lt;/span>(&lt;span style="color:#268bd2">final&lt;/span> Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> originalInvoker, String key, String group) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//originalInvoker代表真正的服务调用器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> last &lt;span style="color:#719e07">=&lt;/span> originalInvoker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL url &lt;span style="color:#719e07">=&lt;/span> originalInvoker.getUrl();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>ModuleModel&lt;span style="color:#719e07">&amp;gt;&lt;/span> moduleModels &lt;span style="color:#719e07">=&lt;/span> getModuleModelsFromUrl(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>Filter&lt;span style="color:#719e07">&amp;gt;&lt;/span> filters;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (moduleModels &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> moduleModels.size() &lt;span style="color:#719e07">==&lt;/span> 1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//类型Filter key为service.filter 分组为provider 所有提供者过滤器拉取&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filters &lt;span style="color:#719e07">=&lt;/span> ScopeModelUtil.getExtensionLoader(Filter.class, moduleModels.get(0)).getActivateExtension(url, key, group);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (moduleModels &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> moduleModels.size() &lt;span style="color:#719e07">&amp;gt;&lt;/span> 1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filters &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>ExtensionDirector&lt;span style="color:#719e07">&amp;gt;&lt;/span> directors &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (ModuleModel moduleModel : moduleModels) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>Filter&lt;span style="color:#719e07">&amp;gt;&lt;/span> tempFilters &lt;span style="color:#719e07">=&lt;/span> ScopeModelUtil.getExtensionLoader(Filter.class, moduleModel).getActivateExtension(url, key, group);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filters.addAll(tempFilters);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> directors.add(moduleModel.getExtensionDirector());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filters &lt;span style="color:#719e07">=&lt;/span> sortingAndDeduplication(filters, directors);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filters &lt;span style="color:#719e07">=&lt;/span> ScopeModelUtil.getExtensionLoader(Filter.class, &lt;span style="color:#cb4b16">null&lt;/span>).getActivateExtension(url, key, group);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//倒序拼接，将过滤器的调用对象添加到链表中 最后倒序遍历之后 last节点指向了调用链路链表头节点的对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>CollectionUtils.isEmpty(filters)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (&lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> filters.size() &lt;span style="color:#719e07">-&lt;/span> 1; i &lt;span style="color:#719e07">&amp;gt;=&lt;/span> 0; i&lt;span style="color:#719e07">--&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">final&lt;/span> Filter filter &lt;span style="color:#719e07">=&lt;/span> filters.get(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">final&lt;/span> Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> next &lt;span style="color:#719e07">=&lt;/span> last;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//每个invoker对象中都有originalInvoker对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> last &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> CopyOfFilterChainNode&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(originalInvoker, next, filter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> CallbackRegistrationInvoker&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(last, filters);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> last;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/16-deploy4.png" alt="在这里插入图片描述">&lt;/p>
&lt;h3 id="16633-协议监听器wrapper-protocollistenerwrapper">16.6.3.3 协议监听器Wrapper ProtocolListenerWrapper&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Exporter&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">export&lt;/span>(Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> invoker) &lt;span style="color:#268bd2">throws&lt;/span> RpcException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注册中心地址则直接导出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (UrlUtils.isRegistry(invoker.getUrl())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> protocol.export(invoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 先导出对象 再创建过滤器包装对象 执行监听器逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ListenerExporterWrapper&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span>(protocol.export(invoker),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collections.unmodifiableList(ScopeModelUtil.getExtensionLoader(ExporterListener.class, invoker.getUrl().getScopeModel())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .getActivateExtension(invoker.getUrl(), EXPORTER_LISTENER_KEY)));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="16634-qos的协议wrapper-qosprotocolwrapper">16.6.3.4 QOS的协议Wrapper QosProtocolWrapper&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Exporter&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">export&lt;/span>(Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> invoker) &lt;span style="color:#268bd2">throws&lt;/span> RpcException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注册中心导出的时候开启QOS 默认端口22222&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (UrlUtils.isRegistry(invoker.getUrl())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startQosServer(invoker.getUrl());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> protocol.export(invoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> protocol.export(invoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="16635-injvmprotocol-的导出方法">16.6.3.5 InjvmProtocol 的导出方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Exporter&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">export&lt;/span>(Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> invoker) &lt;span style="color:#268bd2">throws&lt;/span> RpcException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> InjvmExporter&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span>(invoker, invoker.getUrl().getServiceKey(), exporterMap);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="167-导出服务到注册中心">16.7 导出服务到注册中心&lt;/h2>
&lt;p>16.5.2 导出服务配置模板方法 中我们看到了服务导出会导出到本地和远程，接下来就看下导出到远程的方法exportRemote
参数url:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>dubbo:&lt;span style="color:#586e75">//192.168.1.9:20880/link.elastic.dubbo.entity.DemoService?anyhost=true&amp;amp;application=dubbo-demo-api-provider&amp;amp;background=false&amp;amp;bind.ip=192.168.1.9&amp;amp;bind.port=20880&amp;amp;deprecated=false&amp;amp;dubbo=2.0.2&amp;amp;dynamic=true&amp;amp;generic=false&amp;amp;interface=link.elastic.dubbo.entity.DemoService&amp;amp;methods=sayHello,sayHelloAsync&amp;amp;pid=12865&amp;amp;release=3.0.8&amp;amp;side=provider&amp;amp;timestamp=1653708351378&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>参数registryURLs目前有两个 应用级注册地址和接口级注册地址：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>registry:&lt;span style="color:#586e75">//127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;pid=9008&amp;amp;registry=zookeeper&amp;amp;release=3.0.8&amp;amp;timestamp=1653703292768&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>service&lt;span style="color:#719e07">-&lt;/span>discovery&lt;span style="color:#719e07">-&lt;/span>registry:&lt;span style="color:#586e75">//8.131.79.126:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;pid=10275&amp;amp;registry=zookeeper&amp;amp;release=3.0.8&amp;amp;timestamp=1653704425920&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> URL &lt;span style="color:#268bd2">exportRemote&lt;/span>(URL url, List&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> registryURLs) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isNotEmpty(registryURLs)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//遍历所有注册地址与注册模式 逐个注册&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (URL registryURL : registryURLs) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//为协议URL 添加应用级注册service-discovery-registry参数service-name-mapping为true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (SERVICE_REGISTRY_PROTOCOL.equals(registryURL.getProtocol())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url &lt;span style="color:#719e07">=&lt;/span> url.addParameterIfAbsent(SERVICE_NAME_MAPPING_KEY, &lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//if protocol is only injvm ,not register&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//为协议url 添加动态配置dynamic&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url &lt;span style="color:#719e07">=&lt;/span> url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//监控配置暂时为null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL monitorUrl &lt;span style="color:#719e07">=&lt;/span> ConfigValidationUtils.loadMonitor(&lt;span style="color:#719e07">this&lt;/span>, registryURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (monitorUrl &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url &lt;span style="color:#719e07">=&lt;/span> url.putAttribute(MONITOR_KEY, monitorUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// For providers, this is used to enable custom proxy to generate invoker&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String proxy &lt;span style="color:#719e07">=&lt;/span> url.getParameter(PROXY_KEY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isNotEmpty(proxy)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registryURL &lt;span style="color:#719e07">=&lt;/span> registryURL.addParameter(PROXY_KEY, proxy);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//开始注册服务了 打印个认知 提示下&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (logger.isInfoEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (url.getParameter(REGISTER_KEY, &lt;span style="color:#cb4b16">true&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;Register dubbo service &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> interfaceClass.getName() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; url &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> url &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; to registry &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> registryURL.getAddress());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;Export dubbo service &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> interfaceClass.getName() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; to url &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doExportUrl(registryURL.putAttribute(EXPORT_KEY, url), &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (logger.isInfoEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;Export dubbo service &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> interfaceClass.getName() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; to url &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doExportUrl(url, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> url;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1671---doexporturl方法">16.7.1 doExportUrl方法&lt;/h3>
&lt;p>与 16.6.1 doExportUrl方法 导出本地协议是一样的逻辑 ，我们来看看点不同地方&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">doExportUrl&lt;/span>(URL url, &lt;span style="color:#dc322f">boolean&lt;/span> withMetaData) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Invoker&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> invoker &lt;span style="color:#719e07">=&lt;/span> proxyFactory.getInvoker(ref, (Class) interfaceClass, url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (withMetaData) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//远程服务导出逐个值为true 元数据invoker包装一下&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> invoker &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> DelegateProviderMetaDataInvoker(invoker, &lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Exporter&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> exporter &lt;span style="color:#719e07">=&lt;/span> protocolSPI.export(invoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exporters.add(exporter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>与本地导出ProtocolFilterWrapper的不同之处
服务发现service-discovery-registry的导出UrlUtils.isRegistry(invoker.getUrl() 判断结果为true会走这个逻辑&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Exporter&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">export&lt;/span>(Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> invoker) &lt;span style="color:#268bd2">throws&lt;/span> RpcException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注册中心的协议导出直接执行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 服务发现service-discovery-registry的导出会走这个逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (UrlUtils.isRegistry(invoker.getUrl())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> protocol.export(invoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//过滤器调用链FilterChainBuilder的扩展对象查询&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FilterChainBuilder builder &lt;span style="color:#719e07">=&lt;/span> getFilterChainBuilder(invoker.getUrl());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里分为2步 生成过滤器调用链 然后使用链表中的节点调用 这里值查询provider类型的过滤器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> protocol.export(builder.buildInvokerChain(invoker, SERVICE_FILTER_KEY, CommonConstants.PROVIDER));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>与 协议监听器Wrapper ProtocolListenerWrapper 的不同之处&lt;/p>
&lt;p>服务发现service-discovery-registry的导出UrlUtils.isRegistry(invoker.getUrl() 判断结果为true会走这个逻辑&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Exporter&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">export&lt;/span>(Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> invoker) &lt;span style="color:#268bd2">throws&lt;/span> RpcException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注册中心地址则直接导出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 服务发现service-discovery-registry的导出会走这个逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (UrlUtils.isRegistry(invoker.getUrl())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> protocol.export(invoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 先导出对象 再创建过滤器包装对象 执行监听器逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ListenerExporterWrapper&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span>(protocol.export(invoker),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collections.unmodifiableList(ScopeModelUtil.getExtensionLoader(ExporterListener.class, invoker.getUrl().getScopeModel())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .getActivateExtension(invoker.getUrl(), EXPORTER_LISTENER_KEY)));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>与 16.6.3.4 QOS的协议Wrapper QosProtocolWrapper 不同之处&lt;/p>
&lt;p>服务发现service-discovery-registry的导出UrlUtils.isRegistry(invoker.getUrl() 判断结果为true会走这个逻辑&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Exporter&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">export&lt;/span>(Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> invoker) &lt;span style="color:#268bd2">throws&lt;/span> RpcException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注册中心导出的时候开启QOS 默认端口22222&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (UrlUtils.isRegistry(invoker.getUrl())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startQosServer(invoker.getUrl());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> protocol.export(invoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> protocol.export(invoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>启动QOS服务startQosServer&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">startQosServer&lt;/span>(URL url) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>hasStarted.compareAndSet(&lt;span style="color:#cb4b16">false&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">boolean&lt;/span> qosEnable &lt;span style="color:#719e07">=&lt;/span> url.getParameter(QOS_ENABLE, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>qosEnable) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;qos won&amp;#39;t be started because it is disabled. &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;Please check dubbo.application.qos.enable is configured either in system property, &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;dubbo.properties or XML/spring-boot configuration.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String host &lt;span style="color:#719e07">=&lt;/span> url.getParameter(QOS_HOST);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> port &lt;span style="color:#719e07">=&lt;/span> url.getParameter(QOS_PORT, QosConstants.DEFAULT_PORT);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">boolean&lt;/span> acceptForeignIp &lt;span style="color:#719e07">=&lt;/span> Boolean.parseBoolean(url.getParameter(ACCEPT_FOREIGN_IP, &lt;span style="color:#2aa198">&amp;#34;false&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Server server &lt;span style="color:#719e07">=&lt;/span> frameworkModel.getBeanFactory().getBean(Server.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server.setHost(host);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server.setPort(port);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server.setAcceptForeignIp(acceptForeignIp);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server.start();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable throwable) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(&lt;span style="color:#2aa198">&amp;#34;Fail to start qos server: &amp;#34;&lt;/span>, throwable);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>QOS的Server的启动方法start&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">start&lt;/span>() &lt;span style="color:#268bd2">throws&lt;/span> Throwable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>started.compareAndSet(&lt;span style="color:#cb4b16">false&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//1个主线程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> boss &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> NioEventLoopGroup(1, &lt;span style="color:#719e07">new&lt;/span> DefaultThreadFactory(&lt;span style="color:#2aa198">&amp;#34;qos-boss&amp;#34;&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//0个从线程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> worker &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> NioEventLoopGroup(0, &lt;span style="color:#719e07">new&lt;/span> DefaultThreadFactory(&lt;span style="color:#2aa198">&amp;#34;qos-worker&amp;#34;&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务端启动器，和参数设置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServerBootstrap serverBootstrap &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ServerBootstrap();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serverBootstrap.group(boss, worker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serverBootstrap.channel(NioServerSocketChannel.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serverBootstrap.option(ChannelOption.SO_REUSEADDR, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serverBootstrap.childOption(ChannelOption.TCP_NODELAY, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serverBootstrap.childHandler(&lt;span style="color:#719e07">new&lt;/span> ChannelInitializer&lt;span style="color:#719e07">&amp;lt;&lt;/span>Channel&lt;span style="color:#719e07">&amp;gt;&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initChannel&lt;/span>(Channel ch) &lt;span style="color:#268bd2">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ch.pipeline().addLast(&lt;span style="color:#719e07">new&lt;/span> QosProcessHandler(frameworkModel, welcome, acceptForeignIp));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isBlank(host)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serverBootstrap.bind(port).sync();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serverBootstrap.bind(host, port).sync();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;qos-server bind localhost:&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> port);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable throwable) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(&lt;span style="color:#2aa198">&amp;#34;qos-server can not bind localhost:&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> port, throwable);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> throwable;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>QOS处理器为QosProcessHandler关于QosProcessHandler的细节这里先不说&lt;/p>
&lt;p>最后一个不同的地方调用链路走的这个 RegistryProtocol&lt;/p>
&lt;h3 id="1672-通过注册协议导出服务与注册服务的流程">16.7.2 通过注册协议导出服务与注册服务的流程&lt;/h3>
&lt;p>RegistryProtocol的导出方法：
这个方法非常重要也是服务注册的核心代码，先概括下包含了哪些步骤&lt;/p>
&lt;ul>
&lt;li>覆盖配置&lt;/li>
&lt;li>导出协议端口开启TCP服务&lt;/li>
&lt;li>注册到注册中心&lt;/li>
&lt;li>通知服务启动了&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Exporter&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">export&lt;/span>(&lt;span style="color:#268bd2">final&lt;/span> Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> originInvoker) &lt;span style="color:#268bd2">throws&lt;/span> RpcException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//service-discovery-registry://8.131.79.126:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;amp;dubbo=2.0.2&amp;amp;pid=14256&amp;amp;registry=zookeeper&amp;amp;release=3.0.8&amp;amp;timestamp=1653710477057&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL registryUrl &lt;span style="color:#719e07">=&lt;/span> getRegistryUrl(originInvoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// url to export locally&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//dubbo://192.168.1.9:20880/link.elastic.dubbo.entity.DemoService?anyhost=true&amp;amp;application=dubbo-demo-api-provider&amp;amp;background=false&amp;amp;bind.ip=192.168.1.9&amp;amp;bind.port=20880&amp;amp;deprecated=false&amp;amp;dubbo=2.0.2&amp;amp;dynamic=true&amp;amp;generic=false&amp;amp;interface=link.elastic.dubbo.entity.DemoService&amp;amp;methods=sayHello,sayHelloAsync&amp;amp;pid=14256&amp;amp;release=3.0.8&amp;amp;service-name-mapping=true&amp;amp;side=provider&amp;amp;timestamp=1653710479073&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL providerUrl &lt;span style="color:#719e07">=&lt;/span> getProviderUrl(originInvoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Subscribe the override data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// the same service. Because the subscribed is cached key with the name of the service, it causes the&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// subscription information to cover.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//provider://192.168.1.9:20880/link.elastic.dubbo.entity.DemoService?anyhost=true&amp;amp;application=dubbo-demo-api-provider&amp;amp;background=false&amp;amp;bind.ip=192.168.1.9&amp;amp;bind.port=20880&amp;amp;category=configurators&amp;amp;check=false&amp;amp;deprecated=false&amp;amp;dubbo=2.0.2&amp;amp;dynamic=true&amp;amp;generic=false&amp;amp;interface=link.elastic.dubbo.entity.DemoService&amp;amp;methods=sayHello,sayHelloAsync&amp;amp;pid=14256&amp;amp;release=3.0.8&amp;amp;service-name-mapping=true&amp;amp;side=provider&amp;amp;timestamp=1653710479073&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">final&lt;/span> URL overrideSubscribeUrl &lt;span style="color:#719e07">=&lt;/span> getSubscribedOverrideUrl(providerUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//override配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">final&lt;/span> OverrideListener overrideSubscribeListener &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> OverrideListener(overrideSubscribeUrl, originInvoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL, NotifyListener&lt;span style="color:#719e07">&amp;gt;&lt;/span> overrideListeners &lt;span style="color:#719e07">=&lt;/span> getProviderConfigurationListener(providerUrl).getOverrideListeners();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> overrideListeners.put(registryUrl, overrideSubscribeListener);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> providerUrl &lt;span style="color:#719e07">=&lt;/span> overrideUrlWithConfig(providerUrl, overrideSubscribeListener);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//export invoker&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">final&lt;/span> ExporterChangeableWrapper&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> exporter &lt;span style="color:#719e07">=&lt;/span> doLocalExport(originInvoker, providerUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// url to registry&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//通过URL获取 注册中心Registry操作对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">final&lt;/span> Registry registry &lt;span style="color:#719e07">=&lt;/span> getRegistry(registryUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//需要向注册中心注册地址转换&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//dubbo://192.168.1.9:20880/link.elastic.dubbo.entity.DemoService?anyhost=true&amp;amp;application=dubbo-demo-api-provider&amp;amp;background=false&amp;amp;deprecated=false&amp;amp;dubbo=2.0.2&amp;amp;dynamic=true&amp;amp;generic=false&amp;amp;interface=link.elastic.dubbo.entity.DemoService&amp;amp;methods=sayHello,sayHelloAsync&amp;amp;pid=14656&amp;amp;release=3.0.8&amp;amp;service-name-mapping=true&amp;amp;side=provider&amp;amp;timestamp=1653711086189&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">final&lt;/span> URL registeredProviderUrl &lt;span style="color:#719e07">=&lt;/span> getUrlToRegistry(providerUrl, registryUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// decide if we need to delay publish (provider itself and registry should both need to register)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">boolean&lt;/span> register &lt;span style="color:#719e07">=&lt;/span> providerUrl.getParameter(REGISTER_KEY, &lt;span style="color:#cb4b16">true&lt;/span>) &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> registryUrl.getParameter(REGISTER_KEY, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//是否向注册中心注册&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (register) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> register(registry, registeredProviderUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// register stated url on provider model&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registerStatedUrl(registryUrl, registeredProviderUrl, register);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exporter.setRegisterUrl(registeredProviderUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exporter.setSubscribeUrl(overrideSubscribeUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>registry.isServiceDiscovery()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Deprecated! Subscribe to override rules in 2.6.x or before.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//内置监听器通知 这个不是通知消费者的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> notifyExport(exporter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//Ensure that a new exporter instance is returned every time export&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> DestroyableExporter&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(exporter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="168-dolocalexport本地导出协议开启端口">16.8 doLocalExport本地导出协议开启端口&lt;/h2>
&lt;p>前面已经看过了本地协议JVM协议的服务导出和注册中心配置的导出，这里可以直接看一些关键代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> ExporterChangeableWrapper&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">doLocalExport&lt;/span>(&lt;span style="color:#268bd2">final&lt;/span> Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> originInvoker, URL providerUrl) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String key &lt;span style="color:#719e07">=&lt;/span> getCacheKey(originInvoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> (ExporterChangeableWrapper&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span>) bounds.computeIfAbsent(key, s &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Invoker&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> invokerDelegate &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> InvokerDelegate&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(originInvoker, providerUrl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//代码中用的这个protoco对象是dubbo自动生成的适配器对象protocol$Adaptive 适配器对象会根据当前协议的参数来查询具体的协议扩展对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ExporterChangeableWrapper&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>((Exporter&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span>) protocol.export(invokerDelegate), originInvoker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面这个protocol$Adaptive 协议的export导出方法与之前的一样也会经历下面几个过程，具体细节可以参考JVM协议的导出：&lt;/p>
&lt;ul>
&lt;li>ProtocolSerializationWrapper&lt;/li>
&lt;li>ProtocolFilterWrapper&lt;/li>
&lt;li>ProtocolListenerWrapper&lt;/li>
&lt;li>QosProtocolWrapper&lt;/li>
&lt;li>唯一不同的是我们这里对应的协议扩展类型为DubboProtocol、
接下来来看下DubboProtocol的导出服务export方法实现：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> Exporter&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">export&lt;/span>(Invoker&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> invoker) &lt;span style="color:#268bd2">throws&lt;/span> RpcException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkDestroyed();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务提供者的url参考例子dubbo://192.168.1.9:20880/link.elastic.dubbo.entity.DemoService?anyhost=true&amp;amp;application=dubbo-demo-api-provider&amp;amp;background=false&amp;amp;bind.ip=192.168.1.9&amp;amp;bind.port=20880&amp;amp;deprecated=false&amp;amp;dubbo=2.0.2&amp;amp;dynamic=true&amp;amp;generic=false&amp;amp;interface=link.elastic.dubbo.entity.DemoService&amp;amp;methods=sayHello,sayHelloAsync&amp;amp;pid=6043&amp;amp;release=3.0.8&amp;amp;service-name-mapping=true&amp;amp;side=provider&amp;amp;timestamp=1654224285437&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL url &lt;span style="color:#719e07">=&lt;/span> invoker.getUrl();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// export service.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//生成服务的key参考：link.elastic.dubbo.entity.DemoService:20880&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String key &lt;span style="color:#719e07">=&lt;/span> serviceKey(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建导出服务用的导出器DubboExporter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DubboExporter&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> exporter &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> DubboExporter&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span>(invoker, key, exporterMap);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//export a stub service for dispatching event&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//stub配置校验&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Boolean isStubSupportEvent &lt;span style="color:#719e07">=&lt;/span> url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Boolean isCallbackservice &lt;span style="color:#719e07">=&lt;/span> url.getParameter(IS_CALLBACK_SERVICE, &lt;span style="color:#cb4b16">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (isStubSupportEvent &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>isCallbackservice) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String stubServiceMethods &lt;span style="color:#719e07">=&lt;/span> url.getParameter(STUB_EVENT_METHODS_KEY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (stubServiceMethods &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> stubServiceMethods.length() &lt;span style="color:#719e07">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (logger.isWarnEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(&lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;consumer [&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> url.getParameter(INTERFACE_KEY) &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;], has set stubproxy support event ,but no stub methods founded.&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建服务开启服务端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> openServer(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> optimizeSerialization(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> exporter;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="开启服务端口">开启服务端口&lt;/h3>
&lt;p>这里就到了RPC协议的TCP通信模块了，对应DubboProtocol 的 openServer(url);方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">openServer&lt;/span>(URL url) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkDestroyed();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// find server. 地址作为key这里是192.168.1.9:20880&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String key &lt;span style="color:#719e07">=&lt;/span> url.getAddress();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// client can export a service which only for server to invoke&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//默认提供者开启服务，消费者是不能开启服务的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">boolean&lt;/span> isServer &lt;span style="color:#719e07">=&lt;/span> url.getParameter(IS_SERVER_KEY, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (isServer) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//协议服务器 下面一个双重校验锁检查，如果为空则创建服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ProtocolServer server &lt;span style="color:#719e07">=&lt;/span> serverMap.get(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (server &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (&lt;span style="color:#719e07">this&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server &lt;span style="color:#719e07">=&lt;/span> serverMap.get(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (server &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serverMap.put(key, createServer(url));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }&lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server.reset(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// server supports reset, use together with override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server.reset(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为当前地址创建协议服务对应方法如下：
DubboProtocol的createServer方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> ProtocolServer &lt;span style="color:#268bd2">createServer&lt;/span>(URL url) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//下面将url增加了心跳参数最终如下dubbo://192.168.1.9:20880/link.elastic.dubbo.entity.DemoService?anyhost=true&amp;amp;application=dubbo-demo-api-provider&amp;amp;background=false&amp;amp;bind.ip=192.168.1.9&amp;amp;bind.port=20880&amp;amp;channel.readonly.sent=true&amp;amp;codec=dubbo&amp;amp;deprecated=false&amp;amp;dubbo=2.0.2&amp;amp;dynamic=true&amp;amp;generic=false&amp;amp;heartbeat=60000&amp;amp;interface=link.elastic.dubbo.entity.DemoService&amp;amp;methods=sayHello,sayHelloAsync&amp;amp;pid=6700&amp;amp;release=3.0.8&amp;amp;service-name-mapping=true&amp;amp;side=provider&amp;amp;timestamp=1654225251112&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url &lt;span style="color:#719e07">=&lt;/span> URLBuilder.from(url)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// send readonly event when server closes, it&amp;#39;s enabled by default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// enable heartbeat by default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .addParameter(CODEC_KEY, DubboCodec.NAME)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .build();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里服务端使用的网络库这里是默认值netty&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String str &lt;span style="color:#719e07">=&lt;/span> url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isNotEmpty(str) &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>url.getOrDefaultFrameworkModel().getExtensionLoader(Transporter.class).hasExtension(str)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> RpcException(&lt;span style="color:#2aa198">&amp;#34;Unsupported server type: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> str &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, url: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//dubbo交换器层对象创建&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ExchangeServer server;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个方法会绑定端口，关于交换器与传输网络层到后面统一说&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里通过绑定url和请求处理器来创建交换器对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server &lt;span style="color:#719e07">=&lt;/span> Exchangers.bind(url, requestHandler);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (RemotingException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> RpcException(&lt;span style="color:#2aa198">&amp;#34;Fail to start server(url: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> url &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;) &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> e.getMessage(), e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> str &lt;span style="color:#719e07">=&lt;/span> url.getParameter(CLIENT_KEY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isNotEmpty(str)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">&amp;gt;&lt;/span> supportedTypes &lt;span style="color:#719e07">=&lt;/span> url.getOrDefaultFrameworkModel().getExtensionLoader(Transporter.class).getSupportedExtensions();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>supportedTypes.contains(str)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> RpcException(&lt;span style="color:#2aa198">&amp;#34;Unsupported client type: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> str);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DubboProtocolServer protocolServer &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> DubboProtocolServer(server);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//关闭等待时长默认为10秒&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadServerProperties(protocolServer);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> protocolServer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="169-向注册中心注册服务register">16.9 向注册中心注册服务register&lt;/h2>
&lt;p>这个细节在下个博客中说涉及到Dubbo3的双注册&lt;/p>
&lt;p>原文地址：&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/16-mo-kuai-fa-bu-qi-fa-bu-fu-wu-quan-guo-cheng/">16-模块发布器发布服务全过程&lt;/a>&lt;/p></description></item><item><title>Blog: 15-Dubbo的三大中心之元数据中心源码解析</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/15/15-dubbo%E7%9A%84%E4%B8%89%E5%A4%A7%E4%B8%AD%E5%BF%83%E4%B9%8B%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 15 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/15/15-dubbo%E7%9A%84%E4%B8%89%E5%A4%A7%E4%B8%AD%E5%BF%83%E4%B9%8B%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>
&lt;h1 id="15-dubbo的三大中心之元数据中心源码解析">15-Dubbo的三大中心之元数据中心源码解析&lt;/h1>
&lt;h2 id="151-简介">15.1 简介&lt;/h2>
&lt;p>关于元数据中心的概念对于大部分用户来说是比较陌生的,配置中心的话我们还好理解,对于元数据中心是什么,我们来看下我从官网拷贝过来的一段文字:&lt;/p>
&lt;p>元数据中心在2.7.x版本开始支持，随着应用级别的服务注册和服务发现在Dubbo中落地，&lt;strong>元数据中心也变的越来越重要&lt;/strong>。在以下几种情况下会需要部署元数据中心：&lt;/p>
&lt;ul>
&lt;li>对于一个原先采用老版本Dubbo搭建的应用服务，在迁移到Dubbo 3时，Dubbo 3 会需要一个&lt;strong>元数据中心来维护RPC服务与应用的映射关系（即接口与应用的映射关系）&lt;/strong>，因为如果采用了&lt;strong>应用级别的服务发现和服务注册&lt;/strong>，在注册中心中将&lt;strong>采用“应用 —— 实例列表”结构&lt;/strong>的数据组织形式，&lt;strong>不再是以往的“接口 —— 实例列表”结构的数据组织形式&lt;/strong>，而以往用接口级别的服务注册和服务发现的应用服务在&lt;strong>迁移到应用级别&lt;/strong>时，&lt;strong>得不到接口与应用之间的对应关系&lt;/strong>，从而无法从注册中心得到实例列表信息，所以&lt;strong>Dubbo为了兼容这种场景，在Provider端启动时，会往元数据中心存储接口与应用的映射关系&lt;/strong>。&lt;/li>
&lt;li>为了让&lt;strong>注册中心更加聚焦与地址的发现和推送能力&lt;/strong>，&lt;strong>减轻注册中心的负担&lt;/strong>，元数据中心承载了所有的服务元数据、大量接口/方法级别配置信息等，无论是接口粒度还是应用粒度的服务发现和注册，元数据中心都起到了重要的作用。&lt;/li>
&lt;li>如果有以上两种需求，都可以选择部署元数据中心，并通过Dubbo的配置来集成该元数据中心。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>元数据中心并不依赖于注册中心和配置中心&lt;/strong>，用户可以自由选择是否集成和部署元数据中心，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://cn.dubbo.apache.org/imgs/v3/concepts/centers-metadata.png" alt="/imgs/v3/concepts/centers-metadata.png">&lt;/p>
&lt;p>该图中不配备配置中心，意味着可以不需要全局管理配置的能力。该图中不配备注册中心，意味着可能采用了Dubbo mesh的方案，也可能不需要进行服务注册，仅仅接收直连模式的服务调用。
官网参考文章地址:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://cn.dubbo.apache.org/zh-cn/docs/concepts/registry-configcenter-metadata/">部署架构（注册中心 配置中心 元数据中心&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cn.dubbo.apache.org/zh-cn/docs/references/metadata/">元数据参考手册&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>综上所述可以用几句话概括下:&lt;/p>
&lt;ul>
&lt;li>元数据中心来维护RPC服务与应用的映射关系（即接口与应用的映射关系）来兼容接口与应用之间的对应关系&lt;/li>
&lt;li>让注册中心更加聚焦与地址的发现和推送能力&lt;/li>
&lt;/ul>
&lt;p>元数据中心的启动是在DefaultApplicationDeployer中的初始化方法 initialize() 中:如下所示&lt;/p>
&lt;p>这里只看下 startMetadataCenter();方法即可&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initialize&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (initialized) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Ensure that the initialization is completed when concurrent calls&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (startLock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (initialized) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// register shutdown hook&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registerShutdownHook();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startConfigCenter();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadApplicationConfigs();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initModuleDeployers();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// @since 2.7.8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startMetadataCenter();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initialized &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (logger.isInfoEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(getIdentifier() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; has been initialized!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="152-深入探究元数据中心的启动过程">15.2 深入探究元数据中心的启动过程&lt;/h2>
&lt;h3 id="1521-启动元数据中心的代码全貌">15.2.1 启动元数据中心的代码全貌&lt;/h3>
&lt;p>关于元数据中心我们看下 startMetadataCenter()方法来大致了解下整个流程&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">startMetadataCenter&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果未配置元数据中心的地址等配置则使用注册中心的地址等配置做为元数据中心的配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> useRegistryAsMetadataCenterIfNecessary();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取应用的配置信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ApplicationConfig applicationConfig &lt;span style="color:#719e07">=&lt;/span> getApplication();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//元数据配置类型 元数据类型， local 或 remote,，如果选择远程，则需要进一步指定元数据中心&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String metadataType &lt;span style="color:#719e07">=&lt;/span> applicationConfig.getMetadataType();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// FIXME, multiple metadata config support.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//查询元数据中心的地址等配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collection&lt;span style="color:#719e07">&amp;lt;&lt;/span>MetadataReportConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> metadataReportConfigs &lt;span style="color:#719e07">=&lt;/span> configManager.getMetadataConfigs();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isEmpty(metadataReportConfigs)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个就是判断 如果选择远程，则需要进一步指定元数据中心 否则就抛出来异常&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (REMOTE_METADATA_STORAGE_TYPE.equals(metadataType)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;No MetadataConfig found, Metadata Center address is required when &amp;#39;metadata=remote&amp;#39; is enabled.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//MetadataReport实例的存储库对象获取&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MetadataReportInstance metadataReportInstance &lt;span style="color:#719e07">=&lt;/span> applicationModel.getBeanFactory().getBean(MetadataReportInstance.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>MetadataReportConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> validMetadataReportConfigs &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(metadataReportConfigs.size());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (MetadataReportConfig metadataReportConfig : metadataReportConfigs) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConfigValidationUtils.validateMetadataConfig(metadataReportConfig);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> validMetadataReportConfigs.add(metadataReportConfig);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化元数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataReportInstance.init(validMetadataReportConfigs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//MetadataReport实例的存储库对象初始化失败则抛出异常&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>metadataReportInstance.inited()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(String.format(&lt;span style="color:#2aa198">&amp;#34;%s MetadataConfigs found, but none of them is valid.&amp;#34;&lt;/span>, metadataReportConfigs.size()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1522-元数据中心未配置则使用注册中心配置">15.2.2 元数据中心未配置则使用注册中心配置&lt;/h3>
&lt;p>前面在说配置中心的时候有说过配置中心如果未配置会使用注册中心的地址等信息作为默认配置,这里元数据做了类似的操作:如代码:
DefaultApplicationDeployer类型的 useRegistryAsMetadataCenterIfNecessary()方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">useRegistryAsMetadataCenterIfNecessary&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置缓存中查询元数据配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collection&lt;span style="color:#719e07">&amp;lt;&lt;/span>MetadataReportConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> metadataConfigs &lt;span style="color:#719e07">=&lt;/span> configManager.getMetadataConfigs();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置存在则直接返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isNotEmpty(metadataConfigs)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">////查询是否有注册中心设置了默认配置isDefault 设置为true的注册中心则为默认注册中心列表,如果没有注册中心设置为默认注册中心,则获取所有未设置默认配置的注册中心列表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>RegistryConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> defaultRegistries &lt;span style="color:#719e07">=&lt;/span> configManager.getDefaultRegistries();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (defaultRegistries.size() &lt;span style="color:#719e07">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//多注册中心遍历&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defaultRegistries
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .stream()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//筛选符合条件的注册中心 (筛选逻辑就是查看是否有对应协议的扩展支持)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter(&lt;span style="color:#719e07">this&lt;/span>::isUsedRegistryAsMetadataCenter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注册中心配置映射为元数据中心 映射就是获取需要的配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map(&lt;span style="color:#719e07">this&lt;/span>::registryAsMetadataCenter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将元数据中心配置存储在配置缓存中方便后续使用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .forEach(metadataReportConfig &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (metadataReportConfig.getId() &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collection&lt;span style="color:#719e07">&amp;lt;&lt;/span>MetadataReportConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> metadataReportConfigs &lt;span style="color:#719e07">=&lt;/span> configManager.getMetadataConfigs();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isNotEmpty(metadataReportConfigs)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (MetadataReportConfig existedConfig : metadataReportConfigs) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (existedConfig.getId() &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> existedConfig.getAddress().equals(metadataReportConfig.getAddress())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configManager.addMetadataReport(metadataReportConfig);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Optional&lt;span style="color:#719e07">&amp;lt;&lt;/span>MetadataReportConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> configOptional &lt;span style="color:#719e07">=&lt;/span> configManager.getConfig(MetadataReportConfig.class, metadataReportConfig.getId());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (configOptional.isPresent()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configManager.addMetadataReport(metadataReportConfig);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;use registry as metadata-center: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> metadataReportConfig);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个代码有些细节就不细说了 我们概括下顺序梳理下思路:&lt;/p>
&lt;ul>
&lt;li>配置缓存中查询元数据配置,配置存在则直接返回&lt;/li>
&lt;li>查询所有可用的默认注册中心列表
&lt;ul>
&lt;li>多注册中心遍历&lt;/li>
&lt;li>选符合条件的注册中心 (筛选逻辑就是查看是否有对应协议的扩展支持)&lt;/li>
&lt;li>注册中心配置RegistryConfig映射转换为元数据中心配置类型MetadataReportConfig 映射就是获取需要的配置&lt;/li>
&lt;li>将元数据中心配置存储在配置缓存中方便后续使用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>元数据的配置可以参考官网:&lt;a href="https://cn.dubbo.apache.org/zh-cn/docs/references/metadata/">元数据参考手册&lt;/a>&lt;/p>
&lt;p>这里主要看下可配置项有哪些 对应类型为MetadataReportConfig 在官网暂时未找到合适的文档,这里整理下属性列表方便后续配置说明查看:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>配置变量&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>id&lt;/td>
&lt;td>String&lt;/td>
&lt;td>配置id&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>protocol&lt;/td>
&lt;td>String&lt;/td>
&lt;td>元数据协议&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>address&lt;/td>
&lt;td>String&lt;/td>
&lt;td>元数据中心地址&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>port&lt;/td>
&lt;td>Integer&lt;/td>
&lt;td>元数据中心端口&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>username&lt;/td>
&lt;td>String&lt;/td>
&lt;td>元数据中心认证用户名&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>password&lt;/td>
&lt;td>String&lt;/td>
&lt;td>元数据中心认证密码&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>timeout&lt;/td>
&lt;td>Integer&lt;/td>
&lt;td>元数据中心的请求超时（毫秒）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>group&lt;/td>
&lt;td>String&lt;/td>
&lt;td>该组将元数据保存在中。它与注册表相同&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>parameters&lt;/td>
&lt;td>Map&amp;lt;String, String&amp;gt;&lt;/td>
&lt;td>自定义参数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>retryTimes&lt;/td>
&lt;td>Integer&lt;/td>
&lt;td>重试次数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>retryPeriod&lt;/td>
&lt;td>Integer&lt;/td>
&lt;td>重试间隔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cycleReport&lt;/td>
&lt;td>Boolean&lt;/td>
&lt;td>默认情况下， 是否每天重复存储完整的元数据&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>syncReport&lt;/td>
&lt;td>Boolean&lt;/td>
&lt;td>Sync or Async report.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cluster&lt;/td>
&lt;td>Boolean&lt;/td>
&lt;td>需要群集支持，默认为false&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>registry&lt;/td>
&lt;td>String&lt;/td>
&lt;td>注册表配置id&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>file&lt;/td>
&lt;td>String&lt;/td>
&lt;td>元数据报告文件存储位置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>check&lt;/td>
&lt;td>Boolean&lt;/td>
&lt;td>连接到元数据中心时要应用的失败策略&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="1523-元数据中心的初始化逻辑">15.2.3 元数据中心的初始化逻辑&lt;/h3>
&lt;h4 id="15231-元数据中心的初始化调用逻辑">15.2.3.1 元数据中心的初始化调用逻辑&lt;/h4>
&lt;p>主要看这一行比较重要的逻辑:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化元数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataReportInstance.init(validMetadataReportConfigs);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在了解这一行逻辑之前我们先来看下元数据相关联的类型:&lt;/p>
&lt;p>MetadataReportInstance中的初始化方法init&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">init&lt;/span>(List&lt;span style="color:#719e07">&amp;lt;&lt;/span>MetadataReportConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> metadataReportConfigs) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//CAS判断是否有初始化过&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>init.compareAndSet(&lt;span style="color:#cb4b16">false&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//元数据类型配置如果未配置则默认为local &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.metadataType &lt;span style="color:#719e07">=&lt;/span> applicationModel.getApplicationConfigManager().getApplicationOrElseThrow().getMetadataType();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (metadataType &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.metadataType &lt;span style="color:#719e07">=&lt;/span> DEFAULT_METADATA_STORAGE_TYPE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取MetadataReportFactory 工厂类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MetadataReportFactory metadataReportFactory &lt;span style="color:#719e07">=&lt;/span> applicationModel.getExtensionLoader(MetadataReportFactory.class).getAdaptiveExtension();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//多元数据中心初始化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (MetadataReportConfig metadataReportConfig : metadataReportConfigs) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> init(metadataReportConfig, metadataReportFactory);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">init&lt;/span>(MetadataReportConfig config, MetadataReportFactory metadataReportFactory) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置转url&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL url &lt;span style="color:#719e07">=&lt;/span> config.toUrl();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (METADATA_REPORT_KEY.equals(url.getProtocol())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String protocol &lt;span style="color:#719e07">=&lt;/span> url.getParameter(METADATA_REPORT_KEY, DEFAULT_DIRECTORY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url &lt;span style="color:#719e07">=&lt;/span> URLBuilder.from(url)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setProtocol(protocol)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setScopeModel(config.getScopeModel())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .removeParameter(METADATA_REPORT_KEY)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .build();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url &lt;span style="color:#719e07">=&lt;/span> url.addParameterIfAbsent(APPLICATION_KEY, applicationModel.getCurrentConfig().getName());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String relatedRegistryId &lt;span style="color:#719e07">=&lt;/span> isEmpty(config.getRegistry()) &lt;span style="color:#719e07">?&lt;/span> (isEmpty(config.getId()) &lt;span style="color:#719e07">?&lt;/span> DEFAULT_KEY : config.getId()) : config.getRegistry();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//从元数据工厂中获取元数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MetadataReport metadataReport &lt;span style="color:#719e07">=&lt;/span> metadataReportFactory.getMetadataReport(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//缓存元数据到内存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (metadataReport &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataReports.put(relatedRegistryId, metadataReport);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>关于元数据的初始化我们主要看两个位置:&lt;/p>
&lt;ul>
&lt;li>一个是元数据工厂对象的创建与初始化MetadataReportFactory&lt;/li>
&lt;li>一个是元数据对象的创建与初始化MetadataReport&lt;/li>
&lt;/ul>
&lt;h4 id="15232-元数据工厂对象metadatareportfactory">15.2.3.2 元数据工厂对象MetadataReportFactory&lt;/h4>
&lt;p>关于元数据工厂类型MetadataReportFactory,元数据工厂 用于&lt;strong>创建与管理元数据对象&lt;/strong>, 相关类型如下:
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/15-config.png" alt="在这里插入图片描述">&lt;/p>
&lt;p>我们这里主要以为Zookeeper扩展的元数据工厂ZookeeperMetadataReportFactory类型为例子:
实现类型逻辑不复杂,这里就直接贴代码看看:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">ZookeeperMetadataReportFactory&lt;/span> &lt;span style="color:#268bd2">extends&lt;/span> AbstractMetadataReportFactory {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//与Zookeeper交互的传输器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> ZookeeperTransporter zookeeperTransporter;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//应用程序模型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> ApplicationModel applicationModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">ZookeeperMetadataReportFactory&lt;/span>(ApplicationModel applicationModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.applicationModel &lt;span style="color:#719e07">=&lt;/span> applicationModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.zookeeperTransporter &lt;span style="color:#719e07">=&lt;/span> ZookeeperTransporter.getExtension(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@DisableInject&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">setZookeeperTransporter&lt;/span>(ZookeeperTransporter zookeeperTransporter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.zookeeperTransporter &lt;span style="color:#719e07">=&lt;/span> zookeeperTransporter;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> MetadataReport &lt;span style="color:#268bd2">createMetadataReport&lt;/span>(URL url) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ZookeeperMetadataReport(url, zookeeperTransporter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>元数据工厂的实现比较简单&lt;/p>
&lt;ul>
&lt;li>继承抽象的元数据工厂AbstractMetadataReportFactory&lt;/li>
&lt;li>实现工厂方法createMetadataReport来创建一个元数据操作类型&lt;/li>
&lt;/ul>
&lt;p>如果我们想要实现一个元数据工厂扩展可以参考Zookeeper的这个方式&lt;/p>
&lt;h4 id="15233-元数据操作对象metadatareport的创建与初始化">15.2.3.3 元数据操作对象MetadataReport的创建与初始化&lt;/h4>
&lt;p>前面的从元数据工厂中获取元数据操作对象的逻辑处理代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//从元数据工厂中获取元数据 ,url对象可以理解为配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MetadataReport metadataReport &lt;span style="color:#719e07">=&lt;/span> metadataReportFactory.getMetadataReport(url);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>关于元数据对象,用于元数据信息的增删改查等逻辑的操作与元数据信息的缓存&lt;/p>
&lt;p>&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/15-config2.png" alt="在这里插入图片描述">&lt;/p>
&lt;p>我们这里还是以Zookeeper的实现ZookeeperMetadataReportFactory类型做为参考:&lt;/p>
&lt;p>我们先来看这个逻辑&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//从元数据工厂中获取元数据 ,url对象可以理解为配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MetadataReport metadataReport &lt;span style="color:#719e07">=&lt;/span> metadataReportFactory.getMetadataReport(url);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ZookeeperMetadataReportFactory的父类型AbstractMetadataReportFactory中的getMetadataReport方法如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> MetadataReport &lt;span style="color:#268bd2">getMetadataReport&lt;/span>(URL url) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//url值参考例子zookeeper://127.0.0.1:2181?application=dubbo-demo-api-provider&amp;amp;client=&amp;amp;port=2181&amp;amp;protocol=zookeeper&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果存在export则移除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url &lt;span style="color:#719e07">=&lt;/span> url.setPath(MetadataReport.class.getName())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .removeParameters(EXPORT_KEY, REFER_KEY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//生成元数据缓存key 元数据维度 地址+名字 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如: zookeeper://127.0.0.1:2181/org.apache.dubbo.metadata.report.MetadataReport&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String key &lt;span style="color:#719e07">=&lt;/span> url.toServiceString();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//缓存中查询 查到则直接返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MetadataReport metadataReport &lt;span style="color:#719e07">=&lt;/span> serviceStoreMap.get(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (metadataReport &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> metadataReport;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Lock the metadata access process to ensure a single instance of the metadata instance&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//存在写操作 加个锁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lock.lock();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//双重校验锁在查一下&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataReport &lt;span style="color:#719e07">=&lt;/span> serviceStoreMap.get(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (metadataReport &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> metadataReport;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//check参数 查元数据报错是否抛出异常&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">boolean&lt;/span> check &lt;span style="color:#719e07">=&lt;/span> url.getParameter(CHECK_KEY, &lt;span style="color:#cb4b16">true&lt;/span>) &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> url.getPort() &lt;span style="color:#719e07">!=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//关键模版方法 调用扩展实现的具体业务(创建元数据操作对象)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataReport &lt;span style="color:#719e07">=&lt;/span> createMetadataReport(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>check) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(&lt;span style="color:#2aa198">&amp;#34;The metadata reporter failed to initialize&amp;#34;&lt;/span>, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> e;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//check逻辑检查&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (check &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> metadataReport &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;Can not create metadata Report &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//缓存对象 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (metadataReport &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceStoreMap.put(key, metadataReport);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> metadataReport;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Release the lock&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lock.unlock();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面这个抽象类AbstractMetadataReportFactory中的获取元数据操作对象的模版方法getMetadataReport(URL url), 用了双重校验锁的逻辑来创建对象缓存对象,又用了模版方法设计模式,来让抽象类做通用的逻辑,让实现类型去做扩展, 虽然代码写的太长了些整体还是用了不少的设计思想.&lt;/p>
&lt;p>我们直接看这个代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>metadataReport &lt;span style="color:#719e07">=&lt;/span> createMetadataReport(url);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个创建元数据操作对象的代码实际上走的是实现类型的逻辑:&lt;/p>
&lt;p>来自工厂Bean ZookeeperMetadataReportFactory的工厂方法如下所示:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> MetadataReport &lt;span style="color:#268bd2">createMetadataReport&lt;/span>(URL url) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ZookeeperMetadataReport(url, zookeeperTransporter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建了元数据操作对象,这里我们继续看下元数据操作对象ZookeeperMetadataReport创建做了哪些逻辑:
来自ZookeeperMetadataReport的构造器:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">ZookeeperMetadataReport&lt;/span>(URL url, ZookeeperTransporter zookeeperTransporter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//url即配置 配置传递给抽象类 做一些公共的逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//url参考:zookeeper://127.0.0.1:2181/org.apache.dubbo.metadata.report.MetadataReport?application=dubbo-demo-api-provider&amp;amp;client=&amp;amp;port=2181&amp;amp;protocol=zookeeper&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (url.isAnyHost()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;registry address == null&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String group &lt;span style="color:#719e07">=&lt;/span> url.getGroup(DEFAULT_ROOT);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>group.startsWith(PATH_SEPARATOR)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> group &lt;span style="color:#719e07">=&lt;/span> PATH_SEPARATOR &lt;span style="color:#719e07">+&lt;/span> group;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.root &lt;span style="color:#719e07">=&lt;/span> group;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//连接Zookeeper&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zkClient &lt;span style="color:#719e07">=&lt;/span> zookeeperTransporter.connect(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>核心的公共的操作逻辑封装在父类AbstractMetadataReport里面
我们来看前面super调用的构造器逻辑:
如下所示:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">AbstractMetadataReport&lt;/span>(URL reportServerURL) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//设置url 如:zookeeper://127.0.0.1:2181/org.apache.dubbo.metadata.report.MetadataReport?application=dubbo-demo-api-provider&amp;amp;client=&amp;amp;port=2181&amp;amp;protocol=zookeeper&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setUrl(reportServerURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Start file save timer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//缓存的文件名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//格式为: 用户目录+/.dubbo/dubbo-metadata- + 应用程序名字application + url地址(IP+端口) + 后缀.cache 如下所示&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">///Users/song/.dubbo/dubbo-metadata-dubbo-demo-api-provider-127.0.0.1-2181.cache&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String defaultFilename &lt;span style="color:#719e07">=&lt;/span> System.getProperty(USER_HOME) &lt;span style="color:#719e07">+&lt;/span> DUBBO_METADATA &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reportServerURL.getApplication() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;-&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> replace(reportServerURL.getAddress(), &lt;span style="color:#2aa198">&amp;#34;:&amp;#34;&lt;/span>, &lt;span style="color:#2aa198">&amp;#34;-&amp;#34;&lt;/span>) &lt;span style="color:#719e07">+&lt;/span> CACHE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果用户配置了缓存文件名字则以用户配置为准file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String filename &lt;span style="color:#719e07">=&lt;/span> reportServerURL.getParameter(FILE_KEY, defaultFilename);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File file &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//文件名字不为空&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (ConfigUtils.isNotEmpty(filename)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> File(filename);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//文件和父目录不存在则创建文件目录&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>file.exists() &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> file.getParentFile() &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>file.getParentFile().exists()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>file.getParentFile().mkdirs()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException(&lt;span style="color:#2aa198">&amp;#34;Invalid service store file &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> file &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, cause: Failed to create directory &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> file.getParentFile() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// if this file exists, firstly delete it.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//还未初始化则已存在的历史文件删除掉&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>initialized.getAndSet(&lt;span style="color:#cb4b16">true&lt;/span>) &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> file.exists()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file.delete();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//赋值给成员变量后续继续可以用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.file &lt;span style="color:#719e07">=&lt;/span> file;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//文件存在则直接加载文件中的内容&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadProperties();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//sync-report配置的值为同步配置还异步配置,true是同步配置,默认为false为异步配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> syncReport &lt;span style="color:#719e07">=&lt;/span> reportServerURL.getParameter(SYNC_REPORT_KEY, &lt;span style="color:#cb4b16">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//重试属性与逻辑也封装了一个类型 创建对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//retry-times重试次数配置 默认为100次&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//retry-period 重试间隔配置 默认为3000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataReportRetry &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> MetadataReportRetry(reportServerURL.getParameter(RETRY_TIMES_KEY, DEFAULT_METADATA_REPORT_RETRY_TIMES),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reportServerURL.getParameter(RETRY_PERIOD_KEY, DEFAULT_METADATA_REPORT_RETRY_PERIOD));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// cycle report the data switch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//是否定期从元数据中心同步配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//cycle-report配置默认为true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (reportServerURL.getParameter(CYCLE_REPORT_KEY, DEFAULT_METADATA_REPORT_CYCLE_REPORT)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//开启重试定时器 24个小时间隔从元数据中心同步一次&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reportTimerScheduler &lt;span style="color:#719e07">=&lt;/span> Executors.newSingleThreadScheduledExecutor(&lt;span style="color:#719e07">new&lt;/span> NamedThreadFactory(&lt;span style="color:#2aa198">&amp;#34;DubboMetadataReportTimer&amp;#34;&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reportTimerScheduler.scheduleAtFixedRate(&lt;span style="color:#719e07">this&lt;/span>::publishAll, calculateStartTime(), ONE_DAY_IN_MILLISECONDS, TimeUnit.MILLISECONDS);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.reportMetadata &lt;span style="color:#719e07">=&lt;/span> reportServerURL.getParameter(REPORT_METADATA_KEY, &lt;span style="color:#cb4b16">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.reportDefinition &lt;span style="color:#719e07">=&lt;/span> reportServerURL.getParameter(REPORT_DEFINITION_KEY, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="15234-内存中元数据自动同步到zookeeper和本地文件">15.2.3.4 内存中元数据自动同步到Zookeeper和本地文件&lt;/h4>
&lt;p>这里来总结下元数据操作的初始化逻辑:&lt;/p>
&lt;ul>
&lt;li>首次初始化清理历史元数据文件如:
Users/song/.dubbo/dubbo-metadata-dubbo-demo-api-provider-127.0.0.1-2181.cache&lt;/li>
&lt;li>如果非首次进来则直接加载缓存在本地的缓存文件,赋值给properties成员变量&lt;/li>
&lt;li>初始化同步配置是否异步(默认为false), sync-report配置的值为同步配置还异步配置,true是同步配置,默认为false为异步配置&lt;/li>
&lt;li>初始化重试属性&lt;/li>
&lt;li>是否定期从元数据中心同步配置初始化 默认为true 24小时自动同步一次&lt;/li>
&lt;/ul>
&lt;p>关于元数据同步可以看AbstractMetadataReport类型的publishAll方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> reportTimerScheduler &lt;span style="color:#719e07">=&lt;/span> Executors.newSingleThreadScheduledExecutor(&lt;span style="color:#719e07">new&lt;/span> NamedThreadFactory(&lt;span style="color:#2aa198">&amp;#34;DubboMetadataReportTimer&amp;#34;&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reportTimerScheduler.scheduleAtFixedRate(&lt;span style="color:#719e07">this&lt;/span>::publishAll, calculateStartTime(), ONE_DAY_IN_MILLISECONDS, TimeUnit.MILLISECONDS);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里有个方法叫做calculateStartTime 这个代码是随机时间的between 2:00 am to 6:00 am, the time is random. 2点到6点之间启动, 低峰期启动自动同步
返回值:&lt;/p>
&lt;p>AbstractMetadataReport类型的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">publishAll&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;start to publish all metadata.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.doHandleMetadataCollection(allMetadataReports);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>AbstractMetadataReport类型的doHandleMetadataCollection&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">boolean&lt;/span> &lt;span style="color:#268bd2">doHandleMetadataCollection&lt;/span>(Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>MetadataIdentifier, Object&lt;span style="color:#719e07">&amp;gt;&lt;/span> metadataMap) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (metadataMap.isEmpty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Iterator&lt;span style="color:#719e07">&amp;lt;&lt;/span>Map.Entry&lt;span style="color:#719e07">&amp;lt;&lt;/span>MetadataIdentifier, Object&lt;span style="color:#719e07">&amp;gt;&amp;gt;&lt;/span> iterable &lt;span style="color:#719e07">=&lt;/span> metadataMap.entrySet().iterator();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">while&lt;/span> (iterable.hasNext()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map.Entry&lt;span style="color:#719e07">&amp;lt;&lt;/span>MetadataIdentifier, Object&lt;span style="color:#719e07">&amp;gt;&lt;/span> item &lt;span style="color:#719e07">=&lt;/span> iterable.next();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (PROVIDER_SIDE.equals(item.getKey().getSide())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//提供端的元数据则存储提供端元数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.storeProviderMetadata(item.getKey(), (FullServiceDefinition) item.getValue());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (CONSUMER_SIDE.equals(item.getKey().getSide())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//消费端的元数据则存储提供端元数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.storeConsumerMetadata(item.getKey(), (Map) item.getValue());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>提供端元数据的存储:
AbstractMetadataReport类型的storeProviderMetadata&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">storeProviderMetadata&lt;/span>(MetadataIdentifier providerMetadataIdentifier, ServiceDefinition serviceDefinition) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (syncReport) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> storeProviderMetadataTask(providerMetadataIdentifier, serviceDefinition);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reportCacheExecutor.execute(() &lt;span style="color:#719e07">-&amp;gt;&lt;/span> storeProviderMetadataTask(providerMetadataIdentifier, serviceDefinition));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>AbstractMetadataReport类型的storeProviderMetadataTask
具体同步代码:storeProviderMetadataTask&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">storeProviderMetadataTask&lt;/span>(MetadataIdentifier providerMetadataIdentifier, ServiceDefinition serviceDefinition) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (logger.isInfoEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;store provider metadata. Identifier : &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> providerMetadataIdentifier &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;; definition: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> serviceDefinition);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> allMetadataReports.put(providerMetadataIdentifier, serviceDefinition);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> failedReports.remove(providerMetadataIdentifier);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Gson gson &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> Gson();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String data &lt;span style="color:#719e07">=&lt;/span> gson.toJson(serviceDefinition);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//内存中的元数据同步到元数据中心&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doStoreProviderMetadata(providerMetadataIdentifier, data);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//内存中的元数据同步到本地文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> saveProperties(providerMetadataIdentifier, data, &lt;span style="color:#cb4b16">true&lt;/span>, &lt;span style="color:#719e07">!&lt;/span>syncReport);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// retry again. If failed again, throw exception.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> failedReports.put(providerMetadataIdentifier, serviceDefinition);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataReportRetry.startRetryTask();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(&lt;span style="color:#2aa198">&amp;#34;Failed to put provider metadata &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> providerMetadataIdentifier &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; in &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> serviceDefinition &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, cause: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> e.getMessage(), e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码我们主要看本地内存中的元数据同步到元数据中心和存本地的两个点:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//内存中的元数据同步到元数据中心&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>doStoreProviderMetadata(providerMetadataIdentifier, data);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//内存中的元数据同步到本地文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>saveProperties(providerMetadataIdentifier, data, &lt;span style="color:#cb4b16">true&lt;/span>,
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>//内存中的元数据同步到元数据中心&lt;/p>
&lt;p>这个方法会调用当前子类重写的具体存储逻辑:这里我们以
ZookeeperMetadataReport的doStoreProviderMetadata举例:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">storeMetadata&lt;/span>(MetadataIdentifier metadataIdentifier, String v) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//使用zkClient创建一个节点数据为参数V v是前面说的服务定义数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zkClient.create(getNodePath(metadataIdentifier), v, &lt;span style="color:#cb4b16">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里参数我们举个例子: 提供者的元数据内容如下:
节点路径为:&lt;/p>
&lt;ul>
&lt;li>/dubbo/metadata/link.elastic.dubbo.entity.DemoService/provider/dubbo-demo-api-provider&lt;/li>
&lt;/ul>
&lt;p>格式:&lt;/p>
&lt;ul>
&lt;li>/dubbo/metadata前缀&lt;/li>
&lt;li>服务提供者接口&lt;/li>
&lt;li>提供者类型provider&lt;/li>
&lt;li>应用名&lt;/li>
&lt;/ul>
&lt;p>具体的元数据内容如下:
比较详细的记录了应用信息,服务接口信息和服务接口对应的方法信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;parameters&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;side&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;provider&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;interface&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;link.elastic.dubbo.entity.DemoService&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;pid&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;38680&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;application&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;dubbo-demo-api-provider&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;dubbo&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;2.0.2&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;release&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;3.0.8&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;anyhost&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;bind.ip&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;192.168.1.9&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;methods&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;sayHello,sayHelloAsync&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;background&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;false&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;deprecated&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;false&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;dynamic&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;service-name-mapping&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;generic&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;false&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;bind.port&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;20880&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;timestamp&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;1653097653865&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;canonicalName&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;link.elastic.dubbo.entity.DemoService&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;codeSource&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;file:/Users/song/Desktop/Computer/A/code/gitee/weaving-a-net/weaving-test/dubbo-test/target/classes/&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;methods&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;sayHello&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;parameterTypes&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;java.lang.String&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;returnType&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.lang.String&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;annotations&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;sayHelloAsync&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;parameterTypes&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;java.lang.String&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;returnType&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.util.concurrent.CompletableFuture&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;annotations&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;types&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.util.concurrent.CompletableFuture&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;properties&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;result&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.lang.Object&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;stack&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.util.concurrent.CompletableFuture.Completion&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.lang.Object&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.lang.String&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.util.concurrent.CompletableFuture.Completion&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;properties&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;next&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.util.concurrent.CompletableFuture.Completion&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;status&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;int&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;int&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;annotations&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>本地缓存文件的写入 可以看下如下代码
AbstractMetadataReport类型的saveProperties方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">saveProperties&lt;/span>(MetadataIdentifier metadataIdentifier, String value, &lt;span style="color:#dc322f">boolean&lt;/span> add, &lt;span style="color:#dc322f">boolean&lt;/span> sync) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (file &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (add) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> properties.setProperty(metadataIdentifier.getUniqueKey(KeyTypeEnum.UNIQUE_KEY), value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> properties.remove(metadataIdentifier.getUniqueKey(KeyTypeEnum.UNIQUE_KEY));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">long&lt;/span> version &lt;span style="color:#719e07">=&lt;/span> lastCacheChanged.incrementAndGet();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (sync) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取最新修改版本持久化到磁盘&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">new&lt;/span> SaveProperties(version).run();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reportCacheExecutor.execute(&lt;span style="color:#719e07">new&lt;/span> SaveProperties(version));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(t.getMessage(), t);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>主要看如下代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">new&lt;/span> SaveProperties(version).run();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>SaveProperties类型代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">SaveProperties&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> Runnable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">long&lt;/span> version;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">SaveProperties&lt;/span>(&lt;span style="color:#dc322f">long&lt;/span> version) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.version &lt;span style="color:#719e07">=&lt;/span> version;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">run&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doSaveProperties(version);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>继续看doSaveProperties方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">doSaveProperties&lt;/span>(&lt;span style="color:#dc322f">long&lt;/span> version) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//不是最新的就不要持久化了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (version &lt;span style="color:#719e07">&amp;lt;&lt;/span> lastCacheChanged.get()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (file &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Save&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建本地文件锁:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//路径为:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">///Users/song/.dubbo/dubbo-metadata-dubbo-demo-api-provider-127.0.0.1-2181.cache.lock&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File lockfile &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> File(file.getAbsolutePath() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;.lock&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//锁文件不存在则创建锁文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>lockfile.exists()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lockfile.createNewFile();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//随机访问文件工具类对象创建 读写权限&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> (RandomAccessFile raf &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> RandomAccessFile(lockfile, &lt;span style="color:#2aa198">&amp;#34;rw&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//文件文件Channel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//返回与此文件关联的唯一FileChannel对象。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FileChannel channel &lt;span style="color:#719e07">=&lt;/span> raf.getChannel()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//FileChannel中的lock()与tryLock()方法都是尝试去获取在某一文件上的独有锁（以下简称独有锁），可以实现进程间操作的互斥。区别在于lock()会阻塞（blocking）方法的执行，tryLock()则不会。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FileLock lock &lt;span style="color:#719e07">=&lt;/span> channel.tryLock();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果多个线程同时进来未获取锁的则抛出异常&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (lock &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IOException(&lt;span style="color:#2aa198">&amp;#34;Can not lock the metadataReport cache file &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> file.getAbsolutePath() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, ignore and retry later, maybe multi java process use the file, please config: dubbo.metadata.file=xxx.properties&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Save&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//文件不存在则创建本地元数据缓存文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">///Users/song/.dubbo/dubbo-metadata-dubbo-demo-api-provider-127.0.0.1-2181.cache&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>file.exists()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file.createNewFile();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Properties tmpProperties;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>syncReport) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// When syncReport = false, properties.setProperty and properties.store are called from the same&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// thread(reportCacheExecutor), so deep copy is not required&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmpProperties &lt;span style="color:#719e07">=&lt;/span> properties;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Using store method and setProperty method of the this.properties will cause lock contention&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// under multi-threading, so deep copy a new container&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//异步存储会导致锁争用 使用此的store方法和setProperty方法。属性将导致多线程下的锁争用，因此深度复制新容器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmpProperties &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> Properties();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>Map.Entry&lt;span style="color:#719e07">&amp;lt;&lt;/span>Object, Object&lt;span style="color:#719e07">&amp;gt;&amp;gt;&lt;/span> entries &lt;span style="color:#719e07">=&lt;/span> properties.entrySet();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (Map.Entry&lt;span style="color:#719e07">&amp;lt;&lt;/span>Object, Object&lt;span style="color:#719e07">&amp;gt;&lt;/span> entry : entries) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmpProperties.setProperty((String) entry.getKey(), (String) entry.getValue());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> (FileOutputStream outputFile &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> FileOutputStream(file)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//Properties类型自带的方法:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将此属性表中的属性列表（键和元素对）以适合使用load（Reader）方法的格式写入输出字符流。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmpProperties.store(outputFile, &lt;span style="color:#2aa198">&amp;#34;Dubbo metadataReport Cache&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lock.release();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (version &lt;span style="color:#719e07">&amp;lt;&lt;/span> lastCacheChanged.get()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reportCacheExecutor.execute(&lt;span style="color:#719e07">new&lt;/span> SaveProperties(lastCacheChanged.incrementAndGet()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个代码太诡异了如果是lock失败也会打印异常给人非常疑惑的感觉 后续会修复&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(&lt;span style="color:#2aa198">&amp;#34;Failed to save service store file, cause: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> e.getMessage(), e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>写入文件的内容大致如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>link.elastic.dubbo.entity.DemoService:::provider:dubbo-demo-api-provider -&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;parameters&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;side&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;provider&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;interface&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;link.elastic.dubbo.entity.DemoService&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;pid&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;41457&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;application&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;dubbo-demo-api-provider&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;dubbo&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;2.0.2&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;release&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;3.0.8&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;anyhost&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;bind.ip&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;192.168.1.9&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;methods&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;sayHello,sayHelloAsync&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;background&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;false&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;deprecated&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;false&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;dynamic&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;service-name-mapping&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;generic&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;false&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;bind.port&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;20880&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;timestamp&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;1653100253548&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;canonicalName&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;link.elastic.dubbo.entity.DemoService&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;codeSource&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;file:/Users/song/Desktop/Computer/A/code/gitee/weaving-a-net/weaving-test/dubbo-test/target/classes/&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;methods&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;sayHelloAsync&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;parameterTypes&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;java.lang.String&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;returnType&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.util.concurrent.CompletableFuture&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;annotations&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;sayHello&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;parameterTypes&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;java.lang.String&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;returnType&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.lang.String&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;annotations&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;types&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.util.concurrent.CompletableFuture&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;properties&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;result&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.lang.Object&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;stack&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.util.concurrent.CompletableFuture.Completion&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.lang.Object&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.lang.String&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.util.concurrent.CompletableFuture.Completion&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;properties&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;next&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;java.util.concurrent.CompletableFuture.Completion&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;status&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;int&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#2aa198">&amp;#34;int&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;#34;annotations&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原文地址：&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/15-dubbo-de-san-da-zhong-xin-zhi-yuan-shu-ju-zhong-xin-yuan-ma-jie-xi/">15-Dubbo的三大中心之元数据中心源码解析&lt;/a>&lt;/p></description></item><item><title>Blog: 14-Dubbo配置加载全解析</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/14/14-dubbo%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%A7%A3%E6%9E%90/</link><pubDate>Sun, 14 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/14/14-dubbo%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%A7%A3%E6%9E%90/</guid><description>
&lt;h1 id="14-dubbo配置加载全解析">14-Dubbo配置加载全解析&lt;/h1>
&lt;h2 id="141-回到启动器的初始化过程">14.1 回到启动器的初始化过程&lt;/h2>
&lt;p>在应用程序启动的时候会调用发布器的启动方法 ,然后调用初始化方法,在发布器DefaultApplicationDeployer中的初始化方法initialize() 如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initialize&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (initialized) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Ensure that the initialization is completed when concurrent calls&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (startLock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (initialized) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// register shutdown hook&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registerShutdownHook();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startConfigCenter();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadApplicationConfigs();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initModuleDeployers();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// @since 2.7.8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startMetadataCenter();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initialized &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (logger.isInfoEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(getIdentifier() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; has been initialized!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>初始化过程中会先启动配置中心配置信息处理,然后 调用加载初始化应用程序配置方法loadApplicationConfigs();进行配置加载
关于配置的官方文档链接为 &lt;a href="https://cn.dubbo.apache.org/zh-cn/docs/references/configuration/overview/">配置概述&lt;/a>&lt;/p>
&lt;p>Dubbo框架的配置项比较繁多，为了更好地管理各种配置，将其按照用途划分为不同的组件，最终所有配置项都会汇聚到URL中，传递给后续处理模块。&lt;/p>
&lt;p>&lt;strong>常用配置组件如下&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>application: Dubbo应用配置&lt;/li>
&lt;li>registry: 注册中心&lt;/li>
&lt;li>protocol: 服务提供者RPC协议&lt;/li>
&lt;li>config-center: 配置中心&lt;/li>
&lt;li>metadata-report: 元数据中心&lt;/li>
&lt;li>service: 服务提供者配置&lt;/li>
&lt;li>reference: 远程服务引用配置&lt;/li>
&lt;li>provider: service的默认配置或分组配置&lt;/li>
&lt;li>consumer: reference的默认配置或分组配置&lt;/li>
&lt;li>module: 模块配置&lt;/li>
&lt;li>monitor: 监控配置&lt;/li>
&lt;li>metrics: 指标配置&lt;/li>
&lt;li>ssl: SSL/TLS配置&lt;/li>
&lt;/ul>
&lt;p>配置还有几个比较重要的点:&lt;/p>
&lt;p>&lt;strong>配置来源&lt;/strong>
从Dubbo支持的配置来源说起，默认有6种配置来源：&lt;/p>
&lt;ul>
&lt;li>JVM System Properties，JVM -D 参数&lt;/li>
&lt;li>System environment，JVM进程的环境变量&lt;/li>
&lt;li>Externalized Configuration，外部化配置，从配置中心读取&lt;/li>
&lt;li>Application Configuration，应用的属性配置，从Spring应用的Environment中提取&amp;quot;dubbo&amp;quot;打头的属性集&lt;/li>
&lt;li>API / XML /注解等编程接口采集的配置可以被理解成配置来源的一种，是直接面向用户编程的配置采集方式&lt;/li>
&lt;li>从classpath读取配置文件 dubbo.properties&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>覆盖关系&lt;/strong>
下图展示了配置覆盖关系的优先级，从上到下优先级依次降低： &lt;img src="https://cn.dubbo.apache.org/imgs/blog/configuration.jpg" alt="在这里插入图片描述">&lt;/p>
&lt;p>&lt;strong>配置方式&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Java API配置&lt;/li>
&lt;li>XML配置&lt;/li>
&lt;li>Annotation配置&lt;/li>
&lt;li>属性配置&lt;/li>
&lt;/ul>
&lt;p>配置虽然非常多,但是我们掌握一下配置加载的原理,再了解下官网的文档说明路径应该基础的配置搞定是没问题的,更深入的配置很多参数还是需要了解下源码的.&lt;/p>
&lt;h2 id="142-配置信息的初始化回顾">14.2 配置信息的初始化回顾&lt;/h2>
&lt;p>前面我们在讲ModuleModel对象的创建的时候ModuleModel模型中包含了一个成员变量为ModuleEnvironment 代表当前的模块环境和ModuleConfigManager配置管理器
而ModuleModel模型对象的父模型对象ApplicationModel中包含了一个成员变量Environment环境和ConfigManager配置管理器.&lt;/p>
&lt;p>在回顾调用过程之前我们先看下模型,配置管理器和环境与配置之间的关系如下图:
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/14-config.png" alt="在这里插入图片描述">&lt;/p>
&lt;p>在ModuleModel对象初始化方法initialize()中创建了模块配置管理器:ModuleConfigManager
如下代码所示:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initialize&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>.initialize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.serviceRepository &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ModuleServiceRepository(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.moduleConfigManager &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ModuleConfigManager(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.moduleConfigManager.initialize();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ModuleEnvironment环境信息对象也会在配置管理器创建的时候被调用到:
如下代码所示:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> ModuleEnvironment &lt;span style="color:#268bd2">getModelEnvironment&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (moduleEnvironment &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> moduleEnvironment &lt;span style="color:#719e07">=&lt;/span> (ModuleEnvironment) &lt;span style="color:#719e07">this&lt;/span>.getExtensionLoader(ModuleExt.class)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .getExtension(ModuleEnvironment.NAME);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> moduleEnvironment;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在扩展对象ExtensionLoader进行对象ModuleEnvironment创建之后会对对象进行初始化调用 initExtension(instance)方法 初始化的时候调用如下代码:
ExtensionLoader中的初始化方法如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initExtension&lt;/span>(T instance) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (instance &lt;span style="color:#719e07">instanceof&lt;/span> Lifecycle) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Lifecycle lifecycle &lt;span style="color:#719e07">=&lt;/span> (Lifecycle) instance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lifecycle.initialize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="143-属性加载">14.3 属性加载&lt;/h2>
&lt;h3 id="1431-environment中属性的初始化方法">14.3.1 Environment中属性的初始化方法&lt;/h3>
&lt;p>这个初始化方法对应ModuleEnvironment的父类型Environment中的初始化方法如下:initialize()&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initialize&lt;/span>() &lt;span style="color:#268bd2">throws&lt;/span> IllegalStateException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (initialized.compareAndSet(&lt;span style="color:#cb4b16">false&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加载在JVM或者环境变量指定的dubbo.properties配置文件 配置的key为dubbo.properties.file ,如果未指定则查找类路径下的dubbo.properties&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.propertiesConfiguration &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> PropertiesConfiguration(scopeModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//系统JVM参数的配置无需我们来加载到内存,系统已经加载好了放到了System中,我们只需System.getProperty(key)来调用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.systemConfiguration &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> SystemConfiguration();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//系统环境变量的配置,无需我们来加载到内存,系统已经加载好了放到了System中,我们只需System.getenv(key)来获取就可以&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.environmentConfiguration &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> EnvironmentConfiguration();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//从远程配置中心的全局配置获取对应配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.externalConfiguration &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> InmemoryConfiguration(&lt;span style="color:#2aa198">&amp;#34;ExternalConfig&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//从远程配置中心的应用配置获取对应配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.appExternalConfiguration &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> InmemoryConfiguration(&lt;span style="color:#2aa198">&amp;#34;AppExternalConfig&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//应用内的配置比如: Spring Environment/PropertySources/application.properties&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.appConfiguration &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> InmemoryConfiguration(&lt;span style="color:#2aa198">&amp;#34;AppConfig&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加载迁移配置,用户在JVM参数或者环境变量中指定的dubbo.migration.file,如果用户未指定测尝试加载类路径下的dubbo-migration.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadMigrationRule();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1442--属性变量说明">14.4.2 属性变量说明&lt;/h3>
&lt;p>前面我们已经基本上介绍了各个属性的含义下面用一个表格列举一下方便查看:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性变量名&lt;/th>
&lt;th>属性类型&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>propertiesConfiguration&lt;/td>
&lt;td>PropertiesConfiguration&lt;/td>
&lt;td>dubbo.properties文件中的属性&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>systemConfiguration&lt;/td>
&lt;td>SystemConfiguration&lt;/td>
&lt;td>JVM参数 启动进程时指定的 (-D)配置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>environmentConfiguration&lt;/td>
&lt;td>EnvironmentConfiguration&lt;/td>
&lt;td>环境变量中的配置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>externalConfiguration&lt;/td>
&lt;td>InmemoryConfiguration&lt;/td>
&lt;td>外部配置全局配置 例如配置中心中 config-center global/default config&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>appExternalConfiguration&lt;/td>
&lt;td>InmemoryConfiguration&lt;/td>
&lt;td>外部的应用配置 例如配置中心中执行的当前应用的配置 config-center app config&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>appConfiguration&lt;/td>
&lt;td>InmemoryConfiguration&lt;/td>
&lt;td>来自应用中的配置例如:Spring Environment/PropertySources/application.properties&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>globalConfiguration&lt;/td>
&lt;td>CompositeConfiguration&lt;/td>
&lt;td>前面6个配置属性放到一起就是这个&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>globalConfigurationMaps&lt;/td>
&lt;td>List&amp;lt;Map&amp;lt;String, String&amp;raquo;&lt;/td>
&lt;td>最前面的6个属性转换为map放到一起就是这个可以理解为将全局配置globalConfiguration转换成了列表 这个列表顺序在这里是:SystemConfiguration -&amp;gt; EnvironmentConfiguration -&amp;gt; AppExternalConfiguration -&amp;gt; ExternalConfiguration -&amp;gt; AppConfiguration -&amp;gt; AbstractConfig -&amp;gt; PropertiesConfiguration&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>defaultDynamicGlobalConfiguration&lt;/td>
&lt;td>CompositeConfiguration&lt;/td>
&lt;td>这个也是一个组合配置将defaultDynamicConfiguration动态配置(来自配置中心的配置)和全局配置添加到了自己的配置列表中 列表顺序为defaultDynamicConfiguration -&amp;gt; globalConfiguration&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>localMigrationRule&lt;/td>
&lt;td>String&lt;/td>
&lt;td>,用户在JVM参数或者环境变量中指定的dubbo.migration.file,如果用户未指定测尝试加载类路径下的dubbo-migration.yaml&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>关于每个配置信息这里还是来了解下细节,方便大家了解原理.&lt;/p>
&lt;h3 id="1433-dubboproperties配置文件加载解析原理">14.3.3 dubbo.properties配置文件加载解析原理&lt;/h3>
&lt;p>如前面所示:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//加载在JVM或者环境变量指定的dubbo.properties配置文件 配置的key为dubbo.properties.file ,如果未指定则查找类路径下的dubbo.properties&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.propertiesConfiguration &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> PropertiesConfiguration(scopeModel);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面就直接提构造器的PropertiesConfiguration代码了:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">PropertiesConfiguration&lt;/span>(ScopeModel scopeModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.scopeModel &lt;span style="color:#719e07">=&lt;/span> scopeModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> refresh();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">refresh&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置获取的过程是借助工具类ConfigUtils来获取的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> properties &lt;span style="color:#719e07">=&lt;/span> ConfigUtils.getProperties(scopeModel.getClassLoaders());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>继续看ConfigUtils的getProperties方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> Properties &lt;span style="color:#268bd2">getProperties&lt;/span>(Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>ClassLoader&lt;span style="color:#719e07">&amp;gt;&lt;/span> classLoaders) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个配置的KEY是dubbo.properties.file System.getProperty是从JVM参数中获取配置的 一般情况下我们在启动Java进程的时候会指定Dubbo配置文件 如配置:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//-Ddubbo.properties.file=/dubbo.properties&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String path &lt;span style="color:#719e07">=&lt;/span> System.getProperty(CommonConstants.DUBBO_PROPERTIES_KEY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isEmpty(path)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//优先级最高的JVM参数拿不到数据则从 环境变量中获取,这个配置key也是dubbo.properties.file System.getenv是从环境变量中获取数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//例如我们在环境变量中配置 dubbo.properties.file=/dubbo.properties&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path &lt;span style="color:#719e07">=&lt;/span> System.getenv(CommonConstants.DUBBO_PROPERTIES_KEY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isEmpty(path)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果在JVM参数和环境变量都拿不到这个配置文件的路径我们就用默认的吧&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//默认的路径是类路径下的资源文件 这个路径是: dubbo.properties &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path &lt;span style="color:#719e07">=&lt;/span> CommonConstants.DEFAULT_DUBBO_PROPERTIES;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> ConfigUtils.loadProperties(classLoaders, path, &lt;span style="color:#cb4b16">false&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>路径获取之后加载详细的配置内容:&lt;/p>
&lt;p>ConfigUtils的loadProperties代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ConfigUtils.loadProperties(classLoaders, path, &lt;span style="color:#cb4b16">false&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> Properties &lt;span style="color:#268bd2">loadProperties&lt;/span>(Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>ClassLoader&lt;span style="color:#719e07">&amp;gt;&lt;/span> classLoaders, String fileName, &lt;span style="color:#dc322f">boolean&lt;/span> allowMultiFile, &lt;span style="color:#dc322f">boolean&lt;/span> optional) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Properties properties &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> Properties();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// add scene judgement in windows environment Fix 2557&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//检查文件是否存在 直接加载配置文件如果加载到了配置文件则直接返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (checkFileNameExist(fileName)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FileInputStream input &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> FileInputStream(fileName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> properties.load(input);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> input.close();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(&lt;span style="color:#2aa198">&amp;#34;Failed to load &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> fileName &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; file from &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> fileName &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;(ignore this file): &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> e.getMessage(), e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> properties;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//为什么会有下面的逻辑呢,如果仅仅使用上面的加载方式只能加载到本系统下的配置文件,无法加载封装在jar中的根路径的配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>java.net.URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> set &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>ClassLoader&lt;span style="color:#719e07">&amp;gt;&lt;/span> classLoadersToLoad &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> LinkedList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> classLoadersToLoad.add(ClassUtils.getClassLoader());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> classLoadersToLoad.addAll(classLoaders);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个方法loadResources在扩展加载的时候说过&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> set &lt;span style="color:#719e07">=&lt;/span> ClassLoaderResourceLoader.loadResources(fileName, classLoadersToLoad).values().stream().reduce(&lt;span style="color:#719e07">new&lt;/span> LinkedHashSet&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(), (a, i) &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a.addAll(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(&lt;span style="color:#2aa198">&amp;#34;Fail to load &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> fileName &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; file: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> t.getMessage(), t);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isEmpty(set)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>optional) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(&lt;span style="color:#2aa198">&amp;#34;No &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> fileName &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; found on the class path.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> properties;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>allowMultiFile) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (set.size() &lt;span style="color:#719e07">&amp;gt;&lt;/span> 1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String errMsg &lt;span style="color:#719e07">=&lt;/span> String.format(&lt;span style="color:#2aa198">&amp;#34;only 1 %s file is expected, but %d dubbo.properties files found on class path: %s&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fileName, set.size(), set);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(errMsg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// fall back to use method getResourceAsStream&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> properties.load(ClassUtils.getClassLoader().getResourceAsStream(fileName));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(&lt;span style="color:#2aa198">&amp;#34;Failed to load &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> fileName &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; file from &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> fileName &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;(ignore this file): &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> e.getMessage(), e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> properties;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;load &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> fileName &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; properties file from &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> set);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (java.net.URL url : set) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Properties p &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> Properties();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InputStream input &lt;span style="color:#719e07">=&lt;/span> url.openStream();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (input &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p.load(input);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> properties.putAll(p);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> input.close();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(&lt;span style="color:#2aa198">&amp;#34;Fail to load &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> fileName &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; file from &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> url &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;(ignore this file): &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> e.getMessage(), e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> properties;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>完整的配置加载流程这里用简单的话描述下:&lt;/p>
&lt;ul>
&lt;li>项目内配置查询
&lt;ul>
&lt;li>路径查询
&lt;ul>
&lt;li>从JVM参数中获取配置的 dubbo.properties.file配置文件路径&lt;/li>
&lt;li>如果前面未获取到路径则从环境变量参数中获取配置的dubbo.properties.file配置文件路径&lt;/li>
&lt;li>如果前面未获取到路径则使用默认路径dubbo.propertie&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>配置加载
&lt;ul>
&lt;li>将路径转为FileInputStream 然后使用Properties加载&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>依赖中的配置扫描查询
&lt;ul>
&lt;li>使用类加载器扫描所有资源URL&lt;/li>
&lt;li>url转InputStream 如 url.openStream() 然后使用Properties加载&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="1434-加载jvm参数的配置">14.3.4 加载JVM参数的配置&lt;/h3>
&lt;p>这里我们继续看SystemConfiguration配置的加载
这个直接看下代码就可以了:&lt;/p>
&lt;p>这个类型仅仅是使用System.getProperty来获取JVM配置即可&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">SystemConfiguration&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> Configuration {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> Object &lt;span style="color:#268bd2">getInternalProperty&lt;/span>(String key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> System.getProperty(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">getProperties&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> (Map) System.getProperties();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1435-加载环境变量参数的配置">14.3.5 加载环境变量参数的配置&lt;/h3>
&lt;p>这里我们来看EnvironmentConfiguration,这里我们直接来看代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">EnvironmentConfiguration&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> Configuration {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> Object &lt;span style="color:#268bd2">getInternalProperty&lt;/span>(String key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String value &lt;span style="color:#719e07">=&lt;/span> System.getenv(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isEmpty(value)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value &lt;span style="color:#719e07">=&lt;/span> System.getenv(StringUtils.toOSStyleKey(key));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">getProperties&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> System.getenv();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1436-内存配置的封装inmemoryconfiguration">14.3.6 内存配置的封装:InmemoryConfiguration&lt;/h3>
&lt;p>这里我们看下InmemoryConfiguration的设计,这个直接看代码吧内部使用了一个LinkedHashMap来存储配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">InmemoryConfiguration&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> Configuration {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// stores the configuration key-value pairs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&lt;/span> store &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> LinkedHashMap&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">InmemoryConfiguration&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">InmemoryConfiguration&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.name &lt;span style="color:#719e07">=&lt;/span> name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">InmemoryConfiguration&lt;/span>(Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&lt;/span> properties) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.setProperties(properties);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> Object &lt;span style="color:#268bd2">getInternalProperty&lt;/span>(String key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> store.get(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * Add one property into the store, the previous value will be replaced if the key exists
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">addProperty&lt;/span>(String key, String value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> store.put(key, value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * Add a set of properties into the store
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">addProperties&lt;/span>(Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&lt;/span> properties) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (properties &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.store.putAll(properties);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * set store
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">setProperties&lt;/span>(Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&lt;/span> properties) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (properties &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.store &lt;span style="color:#719e07">=&lt;/span> properties;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">getProperties&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> store;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1437-dubbo迁移新版本的配置文件加载dubbo-migrationyaml">14.3.7 Dubbo迁移新版本的配置文件加载dubbo-migration.yaml&lt;/h3>
&lt;p>关于配置迁移文件的用法可以看下这个Dubbo官方的&lt;a href="https://cn.dubbo.apache.org/zh-cn/docs/advanced/migration-invoker/">地址迁移规则说明&lt;/a>&lt;/p>
&lt;p>这个配置文件的文件名字为:dubbo-migration.yaml&lt;/p>
&lt;p>这个和14.3.4加载JVM参数配置的过程是相似的细节可以看14.3.4节&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">loadMigrationRule&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//JVM参数的dubbo.migration.file配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String path &lt;span style="color:#719e07">=&lt;/span> System.getProperty(CommonConstants.DUBBO_MIGRATION_KEY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isEmpty(path)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//环境变量的dubbo.migration.file配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path &lt;span style="color:#719e07">=&lt;/span> System.getenv(CommonConstants.DUBBO_MIGRATION_KEY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isEmpty(path)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//默认的迁移配置文件 dubbo-migration.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path &lt;span style="color:#719e07">=&lt;/span> CommonConstants.DEFAULT_DUBBO_MIGRATION_FILE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.localMigrationRule &lt;span style="color:#719e07">=&lt;/span> ConfigUtils.loadMigrationRule(scopeModel.getClassLoaders(), path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="144-初始化加载应用配置">14.4 初始化加载应用配置&lt;/h2>
&lt;p>加载配置涉及到了配置优先级的处理,&lt;/p>
&lt;p>下面来看加载配置代码 loadApplicationConfigs()方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">loadApplicationConfigs&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//发布器还是不处理配置加载的逻辑还是交给配置管理器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configManager.loadConfigs();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置管理器加载配置:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">loadConfigs&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// application config has load before starting config center&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// load dubbo.applications.xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加载应用配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadConfigsOfTypeFromProps(ApplicationConfig.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// load dubbo.monitors.xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加载监控配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadConfigsOfTypeFromProps(MonitorConfig.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// load dubbo.metrics.xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加载指标监控配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadConfigsOfTypeFromProps(MetricsConfig.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// load multiple config types:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// load dubbo.protocols.xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加载协议配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadConfigsOfTypeFromProps(ProtocolConfig.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// load dubbo.registries.xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadConfigsOfTypeFromProps(RegistryConfig.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// load dubbo.metadata-report.xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加载元数据配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadConfigsOfTypeFromProps(MetadataReportConfig.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// config centers has bean loaded before starting config center&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//loadConfigsOfTypeFromProps(ConfigCenterConfig.class);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//刷新配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> refreshAll();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//检查配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkConfigs();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// set model name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isBlank(applicationModel.getModelName())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationModel.setModelName(applicationModel.getApplicationName());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原文地址：&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/14-dubbo-pei-zhi-jia-zai-quan-jie-xi/">Dubbo配置加载全解析&lt;/a>&lt;/p></description></item><item><title>Blog: 13-Dubbo的三大中心之配置中心</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/13/13-dubbo%E7%9A%84%E4%B8%89%E5%A4%A7%E4%B8%AD%E5%BF%83%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</link><pubDate>Sat, 13 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/13/13-dubbo%E7%9A%84%E4%B8%89%E5%A4%A7%E4%B8%AD%E5%BF%83%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</guid><description>
&lt;h1 id="13-dubbo的三大中心之配置中心">13-Dubbo的三大中心之配置中心&lt;/h1>
&lt;h2 id="131-配置中心简介">13.1 配置中心简介&lt;/h2>
&lt;p>百度了一段不错的文字来介绍配置中心，我看了下肯定比我写的好多了，那我就直接拷贝过来一起看：&lt;/p>
&lt;p>&lt;em>对于传统的单体应用而言，常使用配置文件来管理所有配置，比如SpringBoot的application.yml文件，但是在微服务架构中全部手动修改的话很麻烦而且不易维护。微服务的配置管理一般有以下需求：&lt;/em>&lt;/p>
&lt;ul>
&lt;li>&lt;em>&lt;strong>集中配置管理&lt;/strong>，一个微服务架构中可能有成百上千个微服务，所以集中配置管理是很重要的。&lt;/em>&lt;/li>
&lt;li>&lt;em>&lt;strong>不同环境不同配置&lt;/strong>，比如数据源配置在不同环境（开发，生产，测试）中是不同的。&lt;/em>&lt;/li>
&lt;li>&lt;em>&lt;strong>运行期间可动态调整&lt;/strong>。例如，可根据各个微服务的负载情况，动态调整数据源连接池大小等。&lt;/em>&lt;/li>
&lt;li>&lt;em>&lt;strong>配置修改后可自动更新&lt;/strong>。如配置内容发生变化，微服务可以自动更新配置。&lt;/em>&lt;/li>
&lt;/ul>
&lt;p>综上所述对于微服务架构而言，一套统一的，通用的管理配置机制是不可缺少的主要组成部分。常见的做法就是通过配置服务器进行管理。&lt;/p>
&lt;p>不过对于来看这个文章的小伙伴应该大部分对配置中心都会比较了解，分布式配置中心实现简单一点就是借助Zookeeper来协助存储，变更推送，不过为了实现各种不同的业务需求，市面上已经有很多很可靠的配置中心可用了，比如我从其他地方拷贝过来的图（虽然不是最新的但是可以供大家参考下）：&lt;/p>
&lt;p>&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/register.png" alt="在这里插入图片描述">&lt;/p>
&lt;p>每个配置中心都有自己的实现，如果对配置中心感兴趣的小伙伴可以自行去对应开源项目官网查看，我们这里来看Dubbo对配置中心的支持&lt;/p>
&lt;p>&lt;em>&lt;strong>多配置中心：&lt;/strong> Dubbo支持多配置中心，来 &lt;strong>保证其中一个配置中心集群出现不可用时能够切换到另一个配置中心集群&lt;/strong> ，保证能够正常从配置中心获取全局的配置、路由规则等信息。这也能够满足配置中心在部署上适应各类高可用的部署架构模式。-来自官网&lt;/em>&lt;/p>
&lt;p>做中间件可能考虑更多的的不仅仅是性能，还要过多的考虑高可用，高可用怎么做呢，其实就是失效转移，主备切换，降级，降级再降级这些理论的运用，多多考虑某一个服务挂了怎么办，Dubbo的多配置中心支持增加了复杂性，不过降低了服务不可用的风险，有一定的人手的公司还是值得做的。&lt;/p>
&lt;p>关于Dubbo的配置中心这里我来贴个官网的图:
&lt;img src="https://cn.dubbo.apache.org/imgs/v3/concepts/centers-config.png" alt="在这里插入图片描述">
关于官网的介绍可以自行去官网看详细内容: &lt;a href="https://cn.dubbo.apache.org/zh-cn/docs/concepts/registry-configcenter-metadata/">部署架构(注册中心、配置中心、元数据中心&lt;/a>&lt;/p>
&lt;h2 id="132-启动配置中心">13.2 启动配置中心&lt;/h2>
&lt;p>在上一个博客中说到了&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/12-quan-ju-shi-ye-lai-kan-dubbo3.0.8-de-fu-wu-qi-dong-sheng-ming-zhou-qi/">《12-全局视野来看Dubbo3.0.8的服务启动生命周期》&lt;/a>Dubbo应用的启动过程DefaultApplicationDeployer的initialize()方法的全生命周期，在初始化方法中通过调用startConfigCenter();方法来启动配置中心的加载。后面就来详细看下：&lt;/p>
&lt;p>DefaultApplicationDeployer类型的startConfigCenter()代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">startConfigCenter&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// load application config&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加载应用程序配置 （配置可能有多个地方可以配置需要遵循Dubbo约定的优先级进行设置，也可能是多应用，多注册中心这样的配置）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configManager.loadConfigsOfTypeFromProps(ApplicationConfig.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// try set model name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isBlank(applicationModel.getModelName())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//设置一下模块名字和模块描述（我们再Debug里面经常会看到这个描述信息 toString直接返回了Dubbo为我们改造的对象信息）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationModel.setModelName(applicationModel.tryGetApplicationName());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// load config centers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加载配置中心配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置可能有多个地方可以配置需要遵循Dubbo约定的优先级进行设置，也可能是多应用，多注册中心这样的配置）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configManager.loadConfigsOfTypeFromProps(ConfigCenterConfig.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//出于兼容性目的，如果没有明确指定配置中心，并且registryConfig的UseAConfigCenter为null或true，请使用registry作为默认配置中心&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> useRegistryAsConfigCenterIfNecessary();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// check Config Center&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置管理器中获取配置中心&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collection&lt;span style="color:#719e07">&amp;lt;&lt;/span>ConfigCenterConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> configCenters &lt;span style="color:#719e07">=&lt;/span> configManager.getConfigCenters();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置中心配置不为空则刷新配置中心配置将其放入配置管理器中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//下面开始刷新配置中心配置,如果配置中心配置为空则执行空刷新&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isEmpty(configCenters)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置中心不存在的配置刷新&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConfigCenterConfig configCenterConfig &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ConfigCenterConfig();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configCenterConfig.setScopeModel(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configCenterConfig.refresh();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//验证配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConfigValidationUtils.validateConfigCenterConfig(configCenterConfig);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (configCenterConfig.isValid()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置合法则将配置放入配置管理器中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configManager.addConfigCenter(configCenterConfig);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configCenters &lt;span style="color:#719e07">=&lt;/span> configManager.getConfigCenters();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//一个或者多个配置中心配置存在的情况下的配置刷新&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (ConfigCenterConfig configCenterConfig : configCenters) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configCenterConfig.refresh();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//验证配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConfigValidationUtils.validateConfigCenterConfig(configCenterConfig);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置中心配置不为空则将配置中心配置添加到environment中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isNotEmpty(configCenters)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//多配置中心本地动态配置对象创建CompositeDynamicConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CompositeDynamicConfiguration compositeDynamicConfiguration &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> CompositeDynamicConfiguration();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取配置中心的相关配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (ConfigCenterConfig configCenter : configCenters) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Pass config from ConfigCenterBean to environment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将配置中心的外部化配置,更新到环境里面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> environment.updateExternalConfigMap(configCenter.getExternalConfiguration());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将配置中心的应用配置,添加到环境里面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> environment.updateAppExternalConfigMap(configCenter.getAppExternalConfiguration());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Fetch config from remote config center&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//从配置中心拉取配置添加到组合配置中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> compositeDynamicConfiguration.addConfiguration(prepareEnvironment(configCenter));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将配置中心中的动态配置信息 设置到environment的动态配置属性中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> environment.setDynamicConfiguration(compositeDynamicConfiguration);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1321-配置管理器加载配置">13.2.1 配置管理器加载配置&lt;/h3>
&lt;p>前面我们看到了配置管理器会从系统属性中加载配置这里我们来详细看下，配置往往是我们使用者比较关注的内容，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>configManager.loadConfigsOfTypeFromProps(ApplicationConfig.class);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置管理器加载配置代码:
来自ConfigManager的父类型AbstractConfigManager中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T &lt;span style="color:#268bd2">extends&lt;/span> AbstractConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">loadConfigsOfTypeFromProps&lt;/span>(Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> cls) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> tmpConfigs &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取属性配置 dubbo properties in classpath&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个配置信息回头说&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PropertiesConfiguration properties &lt;span style="color:#719e07">=&lt;/span> environment.getPropertiesConfiguration();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// load multiple configs with id&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//多注册中心配置id查询&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> 搜索属性并提取指定类型的配置ID。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> 例如如下配置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> # 配置信息 properties
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> dubbo.registries.registry1.address=xxx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> dubbo.registries.registry2.port=xxx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> # 提取配置的id extract
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> Set configIds = getConfigIds(RegistryConfig.class)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> # 提取的配置id结果 result
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> configIds: [&amp;#34;registry1&amp;#34;, &amp;#34;registry2&amp;#34;]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">&amp;gt;&lt;/span> configIds &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.getConfigIdsFromProps(cls);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configIds.forEach(id &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//遍历这些配置id 判断配置缓存(configsCache成员变量)中是否已经存在当前配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>&lt;span style="color:#719e07">this&lt;/span>.getConfig(cls, id).isPresent()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T config;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建配置对象 为配置对象初始化配置id&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config &lt;span style="color:#719e07">=&lt;/span> createConfig(cls, scopeModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.setId(id);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;create config instance failed, id: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> id &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, type:&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> cls.getSimpleName());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String key &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">boolean&lt;/span> addDefaultNameConfig &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// add default name config (same as id), e.g. dubbo.protocols.rest.port=1234&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key &lt;span style="color:#719e07">=&lt;/span> DUBBO &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;.&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> AbstractConfig.getPluralTagName(cls) &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;.&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> id &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;.name&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (properties.getProperty(key) &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> properties.setProperty(key, id);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addDefaultNameConfig &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//刷新配置信息 好理解点就是Dubbo配置属性重写 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.refresh();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将当前配置信息添加到配置缓存中configsCache成员变量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.addConfig(config);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmpConfigs.add(config);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(&lt;span style="color:#2aa198">&amp;#34;load config failed, id: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> id &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, type:&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> cls.getSimpleName(), e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;load config failed, id: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> id &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, type:&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> cls.getSimpleName());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (addDefaultNameConfig &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> key &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> properties.remove(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// If none config of the type, try load single config&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果没有该类型的配置，请尝试加载单个配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">this&lt;/span>.getConfigs(cls).isEmpty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// load single config&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&amp;gt;&lt;/span> configurationMaps &lt;span style="color:#719e07">=&lt;/span> environment.getConfigurationMaps();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (ConfigurationUtils.hasSubProperties(configurationMaps, AbstractConfig.getTypePrefix(cls))) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T config;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config &lt;span style="color:#719e07">=&lt;/span> createConfig(cls, scopeModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.refresh();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;create default config instance failed, type:&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> cls.getSimpleName());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.addConfig(config);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmpConfigs.add(config);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> tmpConfigs;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="1322--默认使用注册中心地址为配置中心">13.2.2 默认使用注册中心地址为配置中心&lt;/h2>
&lt;p>出于兼容性目的，如果没有明确指定配置中心，并且registryConfig的UseAConfigCenter为null或true，请使用registry作为默认配置中心
调用方法useRegistryAsConfigCenterIfNecessary()来处理逻辑
我们来看下代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">useRegistryAsConfigCenterIfNecessary&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// we use the loading status of DynamicConfiguration to decide whether ConfigCenter has been initiated.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//我们使用DynamicConfiguration的加载状态来决定是否已启动ConfigCenter。配置中心配置加载完成之后会初始化动态配置defaultDynamicConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (environment.getDynamicConfiguration().isPresent()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//从配置缓存中查询是否存在config-center相关配置 ,如果已经存在配置了就无需使用注册中心的配置地址直接返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isNotEmpty(configManager.getConfigCenters())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// load registry&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加载注册中心相关配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configManager.loadConfigsOfTypeFromProps(RegistryConfig.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//查询是否有注册中心设置了默认配置isDefault 设置为true的注册中心则为默认注册中心列表,如果没有注册中心设置为默认注册中心,则获取所有未设置默认配置的注册中心列表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>RegistryConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> defaultRegistries &lt;span style="color:#719e07">=&lt;/span> configManager.getDefaultRegistries();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//存在注册中心&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (defaultRegistries.size() &lt;span style="color:#719e07">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defaultRegistries
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .stream()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//判断当前注册中心是否可以作为配置中心&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter(&lt;span style="color:#719e07">this&lt;/span>::isUsedRegistryAsConfigCenter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将注册中心配置映射转换为配置中心&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map(&lt;span style="color:#719e07">this&lt;/span>::registryAsConfigCenter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//遍历配置中心流&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .forEach(configCenter &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (configManager.getConfigCenter(configCenter.getId()).isPresent()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置管理器中添加配置中心,方便后去读取配置中心的配置信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configManager.addConfigCenter(configCenter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;use registry as config-center: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> configCenter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="13221-如何判断当前注册中心是否可以为配置中心">13.2.2.1 如何判断当前注册中心是否可以为配置中心&lt;/h4>
&lt;p>isUsedRegistryAsConfigCenter&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">boolean&lt;/span> &lt;span style="color:#268bd2">isUsedRegistryAsCenter&lt;/span>(RegistryConfig registryConfig, Supplier&lt;span style="color:#719e07">&amp;lt;&lt;/span>Boolean&lt;span style="color:#719e07">&amp;gt;&lt;/span> usedRegistryAsCenter,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String centerType,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> extensionClass) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">final&lt;/span> &lt;span style="color:#dc322f">boolean&lt;/span> supported;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个useAsConfigCenter参数是来自注册中心的配置 如果配置了这个值则以这个值为准,如果配置了false则这个注册中心不能做为配置中心&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Boolean configuredValue &lt;span style="color:#719e07">=&lt;/span> usedRegistryAsCenter.get();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (configuredValue &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) { &lt;span style="color:#586e75">// If configured, take its value.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> supported &lt;span style="color:#719e07">=&lt;/span> configuredValue.booleanValue();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> { &lt;span style="color:#586e75">// Or check the extension existence&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个逻辑的话是判断下注册中心的协议是否满足要求,我们例子代码中使用的是zookeeper&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String protocol &lt;span style="color:#719e07">=&lt;/span> registryConfig.getProtocol();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个扩展是否支持的逻辑判断是这样的扫描扩展类 看一下当前扩展类型是否有对应协议的扩展 比如在扩展文件里面这样配置过后是支持的 protocol=xxxImpl&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//动态配置的扩展类型为:interface org.apache.dubbo.common.config.configcenter.DynamicConfigurationFactory&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//zookeeper协议肯定是支持的因为zookeeper协议实现了这个动态配置工厂 ,这个扩展类型为ZookeeperDynamicConfigurationFactory&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//代码位置在dubbo-configcenter-zookeeper包中的org.apache.dubbo.common.config.configcenter.DynamicConfigurationFactory扩展配置中内容为zookeeper=org.apache.dubbo.configcenter.support.zookeeper.ZookeeperDynamicConfigurationFactory&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> supported &lt;span style="color:#719e07">=&lt;/span> supportsExtension(extensionClass, protocol);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置中心走注册中心会打印一条日志&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (logger.isInfoEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(format(&lt;span style="color:#2aa198">&amp;#34;No value is configured in the registry, the %s extension[name : %s] %s as the %s center&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> , extensionClass.getSimpleName(), protocol, supported &lt;span style="color:#719e07">?&lt;/span> &lt;span style="color:#2aa198">&amp;#34;supports&amp;#34;&lt;/span> : &lt;span style="color:#2aa198">&amp;#34;does not support&amp;#34;&lt;/span>, centerType));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置中心走注册中心会打印一条日志&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (logger.isInfoEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(format(&lt;span style="color:#2aa198">&amp;#34;The registry[%s] will be %s as the %s center&amp;#34;&lt;/span>, registryConfig,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> supported &lt;span style="color:#719e07">?&lt;/span> &lt;span style="color:#2aa198">&amp;#34;used&amp;#34;&lt;/span> : &lt;span style="color:#2aa198">&amp;#34;not used&amp;#34;&lt;/span>, centerType));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> supported;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个扩展是否支持的逻辑判断是这样的扫描扩展类 看一下当前扩展类型是否有对应协议的扩展 比如在扩展文件里面这样配置过后是支持的 protocol=xxxImpl
配置中心的动态配置的扩展类型为 org.apache.dubbo.common.config.configcenter.DynamicConfigurationFactory&lt;/p>
&lt;p>zookeeper协议肯定是支持的因为zookeeper协议实现了这个动态配置工厂 ,这个扩展类型为ZookeeperDynamicConfigurationFactory代码位置在dubbo-configcenter-zookeeper包中的org.apache.dubbo.common.config.configcenter.DynamicConfigurationFactory扩展配置中内容为&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>zookeeper=org.apache.dubbo.configcenter.support.zookeeper.ZookeeperDynamicConfigurationFactory
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="13222-注册中心配置转配置中心配置">13.2.2.2 注册中心配置转配置中心配置&lt;/h4>
&lt;p>这个逻辑是registryAsConfigCenter方法,我来贴一下代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> ConfigCenterConfig &lt;span style="color:#268bd2">registryAsConfigCenter&lt;/span>(RegistryConfig registryConfig) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注册中心协议获取这里例子中的是zookeeper协议&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String protocol &lt;span style="color:#719e07">=&lt;/span> registryConfig.getProtocol();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注册中心端口 2181&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Integer port &lt;span style="color:#719e07">=&lt;/span> registryConfig.getPort();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//在Dubbo中配置信息 很多情况下都以URL形式表示,这里转换后的地址为zookeeper://127.0.0.1:2181&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL url &lt;span style="color:#719e07">=&lt;/span> URL.valueOf(registryConfig.getAddress(), registryConfig.getScopeModel());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//生成当前配置中心的id 封装之后的内容为:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//config-center-zookeeper-127.0.0.1-2181&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String id &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;config-center-&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> protocol &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;-&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> url.getHost() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;-&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> port;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置中心配置对象创建&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConfigCenterConfig cc &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ConfigCenterConfig();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//config-center-zookeeper-127.0.0.1-2181&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cc.setId(id);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cc.setScopeModel(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (cc.getParameters() &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cc.setParameters(&lt;span style="color:#719e07">new&lt;/span> HashMap&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isNotEmptyMap(registryConfig.getParameters())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cc.getParameters().putAll(registryConfig.getParameters()); &lt;span style="color:#586e75">// copy the parameters&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cc.getParameters().put(CLIENT_KEY, registryConfig.getClient());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//zookeeper&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cc.setProtocol(protocol);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//2181&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cc.setPort(port);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isNotEmpty(registryConfig.getGroup())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cc.setGroup(registryConfig.getGroup());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个方法转换地址是修复bug用的可以看bug https://github.com/apache/dubbo/issues/6476&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cc.setAddress(getRegistryCompatibleAddress(registryConfig));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注册中心分组做为配置中心命名空间 这里为null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cc.setNamespace(registryConfig.getGroup());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//zk认证信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cc.setUsername(registryConfig.getUsername());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//zk认证信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cc.setPassword(registryConfig.getPassword());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (registryConfig.getTimeout() &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cc.setTimeout(registryConfig.getTimeout().longValue());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个属性注释中已经建议了已经弃用了默认就是false了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果配置中心被赋予最高优先级，它将覆盖所有其他配置，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cc.setHighestPriority(&lt;span style="color:#cb4b16">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> cc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="133-配置刷新逻辑">13.3 配置刷新逻辑&lt;/h2>
&lt;p>来自AbstractConfig类型的refresh()方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">refresh&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> refreshed.set(&lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// check and init before do refresh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//刷新之前执行的逻辑 这里并做什么逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> preProcessRefresh();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取当前域模型的环境信息对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Environment environment &lt;span style="color:#719e07">=&lt;/span> getScopeModel().getModelEnvironment();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&amp;gt;&lt;/span> configurationMaps &lt;span style="color:#719e07">=&lt;/span> environment.getConfigurationMaps();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Search props starts with PREFIX in order&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String preferredPrefix &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (String prefix : getPrefixes()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (ConfigurationUtils.hasSubProperties(configurationMaps, prefix)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> preferredPrefix &lt;span style="color:#719e07">=&lt;/span> prefix;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (preferredPrefix &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> preferredPrefix &lt;span style="color:#719e07">=&lt;/span> getPrefixes().get(0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Extract sub props (which key was starts with preferredPrefix)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collection&lt;span style="color:#719e07">&amp;lt;&lt;/span>Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&amp;gt;&lt;/span> instanceConfigMaps &lt;span style="color:#719e07">=&lt;/span> environment.getConfigurationMaps(&lt;span style="color:#719e07">this&lt;/span>, preferredPrefix);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&lt;/span> subProperties &lt;span style="color:#719e07">=&lt;/span> ConfigurationUtils.getSubProperties(instanceConfigMaps, preferredPrefix);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InmemoryConfiguration subPropsConfiguration &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> InmemoryConfiguration(subProperties);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (logger.isDebugEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String idOrName &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.hasText(&lt;span style="color:#719e07">this&lt;/span>.getId())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> idOrName &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;[id=&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.getId() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;]&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String name &lt;span style="color:#719e07">=&lt;/span> ReflectUtils.getProperty(&lt;span style="color:#719e07">this&lt;/span>, &lt;span style="color:#2aa198">&amp;#34;getName&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.hasText(name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> idOrName &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;[name=&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> name &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;]&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.debug(&lt;span style="color:#2aa198">&amp;#34;Refreshing &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.getClass().getSimpleName() &lt;span style="color:#719e07">+&lt;/span> idOrName &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34; with prefix [&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> preferredPrefix &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;], extracted props: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> subProperties);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assignProperties(&lt;span style="color:#719e07">this&lt;/span>, environment, subProperties, subPropsConfiguration);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// process extra refresh of subclass, e.g. refresh method configs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> processExtraRefresh(preferredPrefix, subPropsConfiguration);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(&lt;span style="color:#2aa198">&amp;#34;Failed to override field value of config bean: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#719e07">this&lt;/span>, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;Failed to override field value of config bean: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#719e07">this&lt;/span>, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> postProcessRefresh();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/13-config-1.png" alt="在这里插入图片描述">&lt;/p>
&lt;p>&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/13-config2.png" alt="在这里插入图片描述">&lt;/p>
&lt;h2 id="134-配置中心配置大全">13.4 配置中心配置大全&lt;/h2>
&lt;p>ConfigCenterConfig类型
下面配置信息来自官网
dubbo:config-center 配置&lt;/p>
&lt;p>配置中心。对应的配置类：&lt;code>org.apache.dubbo.config.ConfigCenterConfig&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>protocol&lt;/td>
&lt;td>config.protocol&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>zookeeper&lt;/td>
&lt;td>使用哪个配置中心：apollo、zookeeper、nacos等。 以zookeeper为例 1. 指定protocol，则address可以简化为&lt;code>127.0.0.1:2181&lt;/code>； 2. 不指定protocol，则address取值为&lt;code>zookeeper://127.0.0.1:2181&lt;/code>&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>address&lt;/td>
&lt;td>config.address&lt;/td>
&lt;td>string&lt;/td>
&lt;td>必填&lt;/td>
&lt;td>&lt;/td>
&lt;td>配置中心地址。 取值参见protocol说明&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>highest-priority&lt;/td>
&lt;td>config.highestPriority&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>来自配置中心的配置项具有最高优先级，即会覆盖本地配置项。&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>namespace&lt;/td>
&lt;td>config.namespace&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>通常用于多租户隔离，实际含义视具体配置中心而不同。 如： zookeeper - 环境隔离，默认值&lt;code>dubbo&lt;/code>； apollo - 区分不同领域的配置集合，默认使用&lt;code>dubbo&lt;/code>和&lt;code>application&lt;/code>&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cluster&lt;/td>
&lt;td>config.cluster&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>含义视所选定的配置中心而不同。 如Apollo中用来区分不同的配置集群&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>group&lt;/td>
&lt;td>config.group&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>含义视所选定的配置中心而不同。 nacos - 隔离不同配置集 zookeeper - 隔离不同配置集&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>check&lt;/td>
&lt;td>config.check&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>当配置中心连接失败时，是否终止应用启动。&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>config-file&lt;/td>
&lt;td>config.configFile&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo.properties&lt;/td>
&lt;td>全局级配置文件所映射到的key zookeeper - 默认路径/dubbo/config/dubbo/dubbo.properties apollo - dubbo namespace中的dubbo.properties键&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>timeout&lt;/td>
&lt;td>config.timeout&lt;/td>
&lt;td>integer&lt;/td>
&lt;td>&lt;/td>
&lt;td>3000ms&lt;/td>
&lt;td>获取配置的超时时间&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>username&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>如果配置中心需要做校验，用户名 Apollo暂未启用&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>password&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>如果配置中心需要做校验，密码 Apollo暂未启用&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>parameters&lt;/td>
&lt;td>&lt;/td>
&lt;td>Map&amp;lt;string, string&amp;gt;&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>扩展参数，用来支持不同配置中心的定制化配置参数&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>include-spring-env&lt;/td>
&lt;td>&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>使用Spring框架时支持，为true时，会自动从Spring Environment中读取配置。 默认依次读取 key为dubbo.properties的配置 key为dubbo.properties的PropertySource&lt;/td>
&lt;td>2.7.0+&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>原文：&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/13-dubbo-de-san-da-zhong-xin-zhi-pei-zhi-zhong-xin-yuan-ma-jie-xi/">Dubbo的三大中心之配置中心&lt;/a>&lt;/p></description></item><item><title>Blog: 12 全局视野来看Dubbo3的服务启动生命周期</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/12/12-%E5%85%A8%E5%B1%80%E8%A7%86%E9%87%8E%E6%9D%A5%E7%9C%8Bdubbo3%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link><pubDate>Fri, 12 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/12/12-%E5%85%A8%E5%B1%80%E8%A7%86%E9%87%8E%E6%9D%A5%E7%9C%8Bdubbo3%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid><description>
&lt;h1 id="12-全局视野来看dubbo3的服务启动生命周期">12 全局视野来看Dubbo3的服务启动生命周期&lt;/h1>
&lt;h2 id="121-启动方法简介">12.1 启动方法简介&lt;/h2>
&lt;p>在说启动方法之前先把视野拉回第一章&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/1-cong-yi-ge-demo-shuo-qi/">《1-从一个服务提供者的Demo说起》&lt;/a>我们的Demo代码,下面只贴一下核心代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">Application&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>(String&lt;span style="color:#719e07">[]&lt;/span> args) &lt;span style="color:#268bd2">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startWithBootstrap();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">startWithBootstrap&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//前面的文章都在说这个服务配置对象的创建,中间又说了分层域模型,扩展加载机制&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServiceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>DemoServiceImpl&lt;span style="color:#719e07">&amp;gt;&lt;/span> service &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ServiceConfig&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//为服务配置下服务接口和服务实现,下面两行用来初始化对象就不详细说了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> service.setInterface(DemoService.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> service.setRef(&lt;span style="color:#719e07">new&lt;/span> DemoServiceImpl());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这一个篇章主要说这里:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DubboBootstrap bootstrap &lt;span style="color:#719e07">=&lt;/span> DubboBootstrap.getInstance();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化应用配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bootstrap.application(&lt;span style="color:#719e07">new&lt;/span> ApplicationConfig(&lt;span style="color:#2aa198">&amp;#34;dubbo-demo-api-provider&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化注册中心配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .registry(&lt;span style="color:#719e07">new&lt;/span> RegistryConfig(&lt;span style="color:#2aa198">&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化协议配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .protocol(&lt;span style="color:#719e07">new&lt;/span> ProtocolConfig(CommonConstants.DUBBO, &lt;span style="color:#719e07">-&lt;/span>1))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化服务配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .service(service)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//启动&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .start()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .await();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前面我们介绍了Dubbo启动器DubboBootstrap类型对象的创建,又介绍了为DubboBootstrap启动器初始化各种配置信息,这一个博客就开始到了分析启动方法的位置了,Dubbo启动器借助Deployer发布器来启动和发布服务,发布器的启动过程包含了启动配置中心,加载配置,启动元数据中心,启动服务等操作都是比较重要又比较复杂的过程,这里我们先来看下启动过程的生命周期来为后面的内容做好铺垫。&lt;/p>
&lt;h2 id="122-启动器启动方法的调用逻辑start">12.2 启动器启动方法的调用逻辑start()&lt;/h2>
&lt;p>这里我们就直接来看DubboBootstrap的start()方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> DubboBootstrap &lt;span style="color:#268bd2">start&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//调用重载的方法进行启动参数代表是否等待启动结束&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.start(&lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们再来看重载的start方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> DubboBootstrap &lt;span style="color:#268bd2">start&lt;/span>(&lt;span style="color:#dc322f">boolean&lt;/span> wait) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个发布器是在ApplicationModel对象创建之后初始化的时候进行初始化的具体类型为DefaultApplicationDeployer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Future future &lt;span style="color:#719e07">=&lt;/span> applicationDeployer.start();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (wait) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//等待异步启动的结果&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> future.get();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//启动失败则抛出一个异常&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;await dubbo application start finish failure&amp;#34;&lt;/span>, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="123-应用程序发布器defaultapplicationdeployer的启动方法">12.3 应用程序发布器DefaultApplicationDeployer的启动方法&lt;/h2>
&lt;p>发布器是帮助我们发布服务和引用服务的,在Dubbo3中不论是服务提供者还是服务消费者如果想要启动服务都需要走这个启动方法的逻辑,所以务必重视&lt;/p>
&lt;p>我们直接来看DefaultApplicationDeployer的start()代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> Future &lt;span style="color:#268bd2">start&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//启动锁，防止重复启动&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (startLock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//发布器,状态已经设置为停止或者失败了就直接抛出异常&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (isStopping() &lt;span style="color:#719e07">||&lt;/span> isStopped() &lt;span style="color:#719e07">||&lt;/span> isFailed()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(getIdentifier() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; is stopping or stopped, can not start again&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// maybe call start again after add new module, check if any new module&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//可能在添加新模块后再次调用start，检查是否有任何新模块&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里遍历当前应用程序下的所有模块如果某个模块是PENDING状态则这里hasPendingModule的值为true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">boolean&lt;/span> hasPendingModule &lt;span style="color:#719e07">=&lt;/span> hasPendingModule();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//发布器状态正在启动中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (isStarting()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// currently, is starting, maybe both start by module and application&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// if it has new modules, start them&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//存在挂起的模块&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (hasPendingModule) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//启动模块&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startModules();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// if it is starting, reuse previous startFuture&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//模块异步启动中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> startFuture;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// if is started and no new module, just return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果已启动且没有新模块，直接返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (isStarted() &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>hasPendingModule) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> CompletableFuture.completedFuture(&lt;span style="color:#cb4b16">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// pending -&amp;gt; starting : first start app&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// started -&amp;gt; starting : re-start app&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//启动状态切换，将启动状态切换到STARTING（pending和started状态无需切换）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> onStarting();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//核心初始化逻辑，这里主要做一些应用级别启动比如配置中心，元数据中心&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initialize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//启动模块（我们的服务提供和服务引用是在这个模块级别的）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doStart();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> onFailed(getIdentifier() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; start failure&amp;#34;&lt;/span>, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> e;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> startFuture;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个启动方法逻辑不多 主要三个方法我们重点来看：&lt;/p>
&lt;ul>
&lt;li>onStarting() 这个是启动之前的状态切换&lt;/li>
&lt;li>initialize() 应用的初始化逻辑 比如配置中心，元数据中心的初始化&lt;/li>
&lt;li>doStart() 启动模块比如启动我们的服务提供和服务引用的）&lt;/li>
&lt;/ul>
&lt;p>继续看后面的细节吧，代码胜千言。&lt;/p>
&lt;h2 id="124-应用程序发布器对应用级别的初始化逻辑">12.4 应用程序发布器对应用级别的初始化逻辑&lt;/h2>
&lt;p>这个我们先来看DefaultApplicationDeployer的初始化方法initialize()：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initialize&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//状态判断 如果已经初始化过了就直接返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (initialized) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Ensure that the initialization is completed when concurrent calls&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//启动锁，确保在并发调用时完成初始化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (startLock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//双重校验锁 如果已经初始化过了就直接返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (initialized) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// register shutdown hook&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注册关闭钩子，这个逻辑基本每个中间件应用都必须要要做的事情了，正常关闭应用回收资源，一般没这个逻辑情况下容易出现一些异常，让我们开发人员很疑惑，而这个逻辑往往并不好处理的干净。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registerShutdownHook();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//启动配置中心，感觉Dubbo3耦合了这个玩意&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startConfigCenter();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加载配置，一般配置信息当前机器的来源：环境变量，JVM启动参数，配置文字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadApplicationConfigs();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化模块发布器 （发布服务提供和服务引用使用）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initModuleDeployers();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// @since 2.7.8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//启动元数据中心&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startMetadataCenter();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化完成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initialized &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (logger.isInfoEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(getIdentifier() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; has been initialized!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个是个生命周期整体概览的方法，将具体逻辑拆分到各个子方法中，是代码重构的一种策略，上面注释也很清楚了就不细说了，上面每个方法在后面会有单独的博客来分析。&lt;/p>
&lt;h2 id="125-应用下模块的启动服务的发布与引用">12.5 应用下模块的启动（服务的发布与引用）&lt;/h2>
&lt;p>我们回过头来详细看DefaultApplicationDeployer的doStart()代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">doStart&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 启动模块&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startModules();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>DefaultApplicationDeployer的 startModules()方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">startModules&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ensure init and start internal module first&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//确保初始化并首先启动内部模块,Dubbo3中将模块分为内部和外部，内部是核心代码已经提供的一些服务比如元数据服务，外部是我们自己写的服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prepareInternalModule();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// filter and start pending modules, ignore new module during starting, throw exception of module start&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//启动所有的模块 （启动所有的服务）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (ModuleModel moduleModel : &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(applicationModel.getModuleModels())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个状态默认就是PENDING的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (moduleModel.getDeployer().isPending()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//模块启动器，发布服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> moduleModel.getDeployer().start();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个模块的启动其实就是用来启动服务的 先启动内部服务，再启动外部服务
内部服务有个元数据服务Dubbo3中每个服务都可以对外提供服务的元数据信息，来简化服务配置，不论是内部服务还是外部服务调用的代码逻辑都是模块发布器ModuleDeployer的start()方法，接下来我们详细看下模块发布器的生命周期函数。&lt;/p>
&lt;h2 id="126-模块发布器发布服务的过程">12.6 模块发布器发布服务的过程&lt;/h2>
&lt;p>前面我们说到了所有的服务都是经过模块发布器，ModuleDeployer的start()方法来启动的，那我们接下来就来看看这个模块发布器的启动方法。&lt;/p>
&lt;p>ModuleDeployer的start()方法代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">synchronized&lt;/span> Future &lt;span style="color:#268bd2">start&lt;/span>() &lt;span style="color:#268bd2">throws&lt;/span> IllegalStateException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//模块发布器已经停止或者启动失败则直接抛出异常返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (isStopping() &lt;span style="color:#719e07">||&lt;/span> isStopped() &lt;span style="color:#719e07">||&lt;/span> isFailed()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(getIdentifier() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; is stopping or stopped, can not start again&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//启动中或者已经启动了则直接返回一个Future对象 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (isStarting() &lt;span style="color:#719e07">||&lt;/span> isStarted()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> startFuture;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//切换模块启动状态为STARTING&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> onModuleStarting();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// initialize&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果应用未初始化则初始化（非正常逻辑）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationDeployer.initialize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//模块发布器进行初始化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initialize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// export services&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//暴露服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exportServices();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// prepare application instance&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// exclude internal module to avoid wait itself&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (moduleModel &lt;span style="color:#719e07">!=&lt;/span> moduleModel.getApplicationModel().getInternalModule()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationDeployer.prepareInternalModule();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// refer services&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//引用服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> referServices();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// if no async export/refer services, just set started&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//非异步启动则直接切换状态为STARTED&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (asyncExportingFutures.isEmpty() &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> asyncReferringFutures.isEmpty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> onModuleStarted();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果是异步的则等待服务发布和服务引用异步回调&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> frameworkExecutorRepository.getSharedExecutor().submit(() &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// wait for export finish&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> waitExportFinish();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// wait for refer finish&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> waitReferFinish();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(&lt;span style="color:#2aa198">&amp;#34;wait for export/refer services occurred an exception&amp;#34;&lt;/span>, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//异步回调完成 所有服务都启动了，再切换状态&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> onModuleStarted();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> onModuleFailed(getIdentifier() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; start failed: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> e, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> e;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> startFuture;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>好了整体的服务启动生命周期就如上代码，后续我们再详细来看每个细节。&lt;/p>
&lt;h2 id="127-发布器简介">12.7 发布器简介&lt;/h2>
&lt;p>前面主要说了应用和模块的发布器的启动和初始化，下面简单了解下它们的关系，如下所示
&lt;img src="https://img-blog.csdnimg.cn/37e7c05796ab4b38aa7658377e16c0aa.png" alt="在这里插入图片描述">
可以发布器主要包含&lt;/p>
&lt;ul>
&lt;li>应用的发布器ApplicationDeployer用于初始化并启动应用程序实例&lt;/li>
&lt;li>模块发布器ModuleDeployer 模块（服务）的导出/引用服务&lt;/li>
&lt;/ul>
&lt;p>两种发布器有各自的接口，他们都继承了抽象的发布器AbstractDeployer 封装了一些公共的操作比如状态切换，状态查询的逻辑。&lt;/p>
&lt;p>另外我们再来看下发布过程的状态枚举DeployState如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">enum&lt;/span> DeployState {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * Unknown state
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UNKNOWN,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * Pending, wait for start
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PENDING,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * Starting
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> STARTING,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * Started
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> STARTED,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * Stopping
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> STOPPING,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * Stopped
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> STOPPED,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * Failed
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FAILED
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Dubbo这一块后续可以优化以下，这里的状态切换全部耦合在一起了，可以考虑使用状态机将状态与行为解耦。&lt;/p>
&lt;p>原文：&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/12-quan-ju-shi-ye-lai-kan-dubbo3.0.8-de-fu-wu-qi-dong-sheng-ming-zhou-qi/">Dubbo启动器DubboBootstrap添加协议配置信息ProtocolConfig&lt;/a>&lt;/p></description></item><item><title>Blog: 11-Dubbo启动器DubboBootstrap添加协议配置信息ProtocolConfig</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/11/11-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E6%B7%BB%E5%8A%A0%E5%8D%8F%E8%AE%AE%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AFprotocolconfig/</link><pubDate>Thu, 11 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/11/11-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E6%B7%BB%E5%8A%A0%E5%8D%8F%E8%AE%AE%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AFprotocolconfig/</guid><description>
&lt;h1 id="11-dubbo启动器dubbobootstrap添加协议配置信息protocolconfig">11-Dubbo启动器DubboBootstrap添加协议配置信息ProtocolConfig&lt;/h1>
&lt;h2 id="111-简介">11.1 简介&lt;/h2>
&lt;p>先贴个代码用来参考:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> DubboBootstrap bootstrap &lt;span style="color:#719e07">=&lt;/span> DubboBootstrap.getInstance();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bootstrap.application(&lt;span style="color:#719e07">new&lt;/span> ApplicationConfig(&lt;span style="color:#2aa198">&amp;#34;dubbo-demo-api-provider&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .registry(&lt;span style="color:#719e07">new&lt;/span> RegistryConfig(&lt;span style="color:#2aa198">&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .protocol(&lt;span style="color:#719e07">new&lt;/span> ProtocolConfig(CommonConstants.DUBBO, &lt;span style="color:#719e07">-&lt;/span>1))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .service(service)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .start()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .await();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上个博客我们说了 RegistryConfig对象的创建,启动器对象在启动之前是要初始化一些配置信息的,这里我们来看这一行代码协议配置信息:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>.protocol(&lt;span style="color:#719e07">new&lt;/span> ProtocolConfig(CommonConstants.DUBBO, &lt;span style="color:#719e07">-&lt;/span>1))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="112--协议的配置相关">11.2 协议的配置相关&lt;/h2>
&lt;p>下面的配置来源于官网&lt;/p>
&lt;p>服务提供者协议配置。对应的配置类： org.apache.dubbo.config.ProtocolConfig。同时，如果需要支持多协议，可以声明多个 &lt;a href="dubbo:protocol">dubbo:protocol&lt;/a> 标签，并在 &lt;a href="dubbo:service">dubbo:service&lt;/a> 中通过 protocol 属性指定使用的协议。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>id&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>配置关联&lt;/td>
&lt;td>协议BeanId，可以在&amp;lt;dubbo:service protocol=&amp;quot;&amp;quot;&amp;gt;中引用此ID，如果ID不填，缺省和name属性值一样，重复则在name后加序号。&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>name&lt;/td>
&lt;td>&lt;protocol>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>&lt;strong>必填&lt;/strong>&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议名称&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>port&lt;/td>
&lt;td>&lt;port>&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo协议缺省端口为20880，rmi协议缺省端口为1099，http和hessian协议缺省端口为80；如果&lt;strong>没有&lt;/strong>配置port，则自动采用默认端口，如果配置为**-1**，则会分配一个没有被占用的端口。Dubbo 2.4.0+，分配的端口在协议缺省端口的基础上增长，确保端口段可控。&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务端口&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>host&lt;/td>
&lt;td>&lt;host>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>自动查找本机IP&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>-服务主机名，多网卡选择或指定VIP及域名时使用，为空则自动查找本机IP，-建议不要配置，让Dubbo自动获取本机IP&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>threadpool&lt;/td>
&lt;td>threadpool&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>fixed&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>线程池类型，可选：fixed/cached&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>threads&lt;/td>
&lt;td>threads&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>200&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务线程池大小(固定大小)&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>iothreads&lt;/td>
&lt;td>threads&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>cpu个数+1&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>io线程池大小(固定大小)&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>accepts&lt;/td>
&lt;td>accepts&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务提供方最大可接受连接数&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>payload&lt;/td>
&lt;td>payload&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>8388608(=8M)&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>请求及响应数据包大小限制，单位：字节&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>codec&lt;/td>
&lt;td>codec&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议编码方式&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>serialization&lt;/td>
&lt;td>serialization&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo协议缺省为hessian2，rmi协议缺省为java，http协议缺省为json&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议序列化方式，当协议支持多种序列化方式时使用，比如：dubbo协议的dubbo,hessian2,java,compactedjava，以及http协议的json等&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>accesslog&lt;/td>
&lt;td>accesslog&lt;/td>
&lt;td>string/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>设为true，将向logger中输出访问日志，也可填写访问日志文件路径，直接把访问日志输出到指定文件&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>path&lt;/td>
&lt;td>&lt;path>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>提供者上下文路径，为服务path的前缀&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>transporter&lt;/td>
&lt;td>transporter&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo协议缺省为netty&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议的服务端和客户端实现类型，比如：dubbo协议的mina,netty等，可以分拆为server和client配置&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>server&lt;/td>
&lt;td>server&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo协议缺省为netty，http协议缺省为servlet&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议的服务器端实现类型，比如：dubbo协议的mina,netty等，http协议的jetty,servlet等&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>client&lt;/td>
&lt;td>client&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo协议缺省为netty&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议的客户端实现类型，比如：dubbo协议的mina,netty等&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>dispatcher&lt;/td>
&lt;td>dispatcher&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo协议缺省为all&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>协议的消息派发方式，用于指定线程模型，比如：dubbo协议的all, direct, message, execution, connection等&lt;/td>
&lt;td>2.1.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>queues&lt;/td>
&lt;td>queues&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>线程池队列大小，当线程池满时，排队等待执行的队列大小，建议不要设置，当线程池满时应立即失败，重试其它服务提供机器，而不是排队，除非有特殊需求。&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>charset&lt;/td>
&lt;td>charset&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>UTF-8&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>序列化编码&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>buffer&lt;/td>
&lt;td>buffer&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>8192&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>网络读写缓冲区大小&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>heartbeat&lt;/td>
&lt;td>heartbeat&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>心跳间隔，对于长连接，当物理层断开时，比如拔网线，TCP的FIN消息来不及发送，对方收不到断开事件，此时需要心跳来帮助检查连接是否已断开&lt;/td>
&lt;td>2.0.10以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>telnet&lt;/td>
&lt;td>telnet&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>所支持的telnet命令，多个命令用逗号分隔&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>register&lt;/td>
&lt;td>register&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>该协议的服务是否注册到注册中心&lt;/td>
&lt;td>2.0.8以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>contextpath&lt;/td>
&lt;td>contextpath&lt;/td>
&lt;td>String&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省为空串&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>&lt;/td>
&lt;td>2.0.6以上版本&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>同样官网提供的参数里面并未包含所有的属性 下面我就将其余的属性列举一下方便学习参考:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>变量&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>threadname&lt;/td>
&lt;td>String&lt;/td>
&lt;td>线程池名称&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>corethreads&lt;/td>
&lt;td>Integer&lt;/td>
&lt;td>线程池核心线程大小&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>alive&lt;/td>
&lt;td>Integer&lt;/td>
&lt;td>线程池keepAliveTime，默认单位时间单位。毫秒&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>exchanger&lt;/td>
&lt;td>String&lt;/td>
&lt;td>交换器配置信息如何交换&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>prompt&lt;/td>
&lt;td>String&lt;/td>
&lt;td>命令行提示符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>status&lt;/td>
&lt;td>String&lt;/td>
&lt;td>状态检查&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>sslEnabled&lt;/td>
&lt;td>Boolean&lt;/td>
&lt;td>ssl是否启用&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="113-协议配置对象创建与添加">11.3 协议配置对象创建与添加&lt;/h2>
&lt;p>前面例子中调用的代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> .protocol(&lt;span style="color:#719e07">new&lt;/span> ProtocolConfig(CommonConstants.DUBBO, &lt;span style="color:#719e07">-&lt;/span>1))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里我们配置了协议类型为dubbo 端口为-1则会分配一个没有被占用的端口&lt;/p>
&lt;p>继续看下DubboBootstrap的protocol方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> DubboBootstrap &lt;span style="color:#268bd2">protocol&lt;/span>(ProtocolConfig protocolConfig) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置信息转List&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> protocols(singletonList(protocolConfig));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>继续看protocols方法 ,这个代码与前面两个博客中看到的向配置管理器添加配置对象的逻辑是一样的
这里就不说了可以看前面的博客&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/9-dubbo-qi-dong-qi-dubbobootstrap-tian-jia-ying-yong-cheng-xu-de-pei-zhi-xin-xi-applicationconfig/">《9-Dubbo启动器DubboBootstrap添加应用程序的配置信息ApplicationConfig》&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> DubboBootstrap &lt;span style="color:#268bd2">protocols&lt;/span>(List&lt;span style="color:#719e07">&amp;lt;&lt;/span>ProtocolConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> protocolConfigs) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isEmpty(protocolConfigs)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (ProtocolConfig protocolConfig : protocolConfigs) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> protocolConfig.setScopeModel(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configManager.addProtocol(protocolConfig);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原文：&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/11-dubbo-qi-dong-qi-dubbobootstrap-tian-jia-xie-yi-pei-zhi-xin-xi-protocolconfig/">Dubbo启动器DubboBootstrap添加协议配置信息ProtocolConfig&lt;/a>&lt;/p></description></item><item><title>Blog: 10-Dubbo启动器DubboBootstrap添加注册中心配置信息RegistryConfig</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/10/10-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E6%B7%BB%E5%8A%A0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AFregistryconfig/</link><pubDate>Wed, 10 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/10/10-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E6%B7%BB%E5%8A%A0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AFregistryconfig/</guid><description>
&lt;h1 id="10-dubbo启动器dubbobootstrap添加注册中心配置信息registryconfig">10-Dubbo启动器DubboBootstrap添加注册中心配置信息RegistryConfig&lt;/h1>
&lt;h2 id="101-简介">10.1 简介&lt;/h2>
&lt;p>先贴个代码用来参考:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> DubboBootstrap bootstrap &lt;span style="color:#719e07">=&lt;/span> DubboBootstrap.getInstance();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bootstrap.application(&lt;span style="color:#719e07">new&lt;/span> ApplicationConfig(&lt;span style="color:#2aa198">&amp;#34;dubbo-demo-api-provider&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .registry(&lt;span style="color:#719e07">new&lt;/span> RegistryConfig(&lt;span style="color:#2aa198">&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .protocol(&lt;span style="color:#719e07">new&lt;/span> ProtocolConfig(CommonConstants.DUBBO, &lt;span style="color:#719e07">-&lt;/span>1))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .service(service)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .start()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .await();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上个博客我们说了启动器ApplicationConfig对象的创建,启动器对象在启动之前是要初始化一些配置信息的,这里我们来看这一行代码注册中心配置信息:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>registry(&lt;span style="color:#719e07">new&lt;/span> RegistryConfig(&lt;span style="color:#2aa198">&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="102--注册中心的配置相关">10.2 注册中心的配置相关&lt;/h2>
&lt;p>下面的配置来源于官网&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>id&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>配置关联&lt;/td>
&lt;td>注册中心引用BeanId，可以在&amp;lt;dubbo:service registry=&amp;quot;&amp;quot;&amp;gt;或&amp;lt;dubbo:reference registry=&amp;quot;&amp;quot;&amp;gt;中引用此ID&lt;/td>
&lt;td>1.0.16以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>address&lt;/td>
&lt;td>&lt;a href="host:port">host:port&lt;/a>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>&lt;strong>必填&lt;/strong>&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>注册中心服务器地址，如果地址没有端口缺省为9090，同一集群内的多个地址用逗号分隔，如：ip:port,ip:port，不同集群的注册中心，请配置多个&lt;a href="dubbo:registry">dubbo:registry&lt;/a>标签&lt;/td>
&lt;td>1.0.16以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>protocol&lt;/td>
&lt;td>&lt;protocol>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>注册中心地址协议，支持&lt;code>dubbo&lt;/code>, &lt;code>multicast&lt;/code>, &lt;code>zookeeper&lt;/code>, &lt;code>redis&lt;/code>, &lt;code>consul(2.7.1)&lt;/code>, &lt;code>sofa(2.7.2)&lt;/code>, &lt;code>etcd(2.7.2)&lt;/code>, &lt;code>nacos(2.7.2)&lt;/code>等协议&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>port&lt;/td>
&lt;td>&lt;port>&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>9090&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>注册中心缺省端口，当address没有带端口时使用此端口做为缺省值&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>username&lt;/td>
&lt;td>&lt;username>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>登录注册中心用户名，如果注册中心不需要验证可不填&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>password&lt;/td>
&lt;td>&lt;password>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>登录注册中心密码，如果注册中心不需要验证可不填&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>transport&lt;/td>
&lt;td>registry.transporter&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>netty&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>网络传输方式，可选mina,netty&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>timeout&lt;/td>
&lt;td>registry.timeout&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>5000&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>注册中心请求超时时间(毫秒)&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>session&lt;/td>
&lt;td>registry.session&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>60000&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>注册中心会话超时时间(毫秒)，用于检测提供者非正常断线后的脏数据，比如用心跳检测的实现，此时间就是心跳间隔，不同注册中心实现不一样。&lt;/td>
&lt;td>2.1.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>file&lt;/td>
&lt;td>registry.file&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>使用文件缓存注册中心地址列表及服务提供者列表，应用重启时将基于此文件恢复，注意：两个注册中心不能使用同一文件存储&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>wait&lt;/td>
&lt;td>registry.wait&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>停止时等待通知完成时间(毫秒)&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>check&lt;/td>
&lt;td>check&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>注册中心不存在时，是否报错&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>register&lt;/td>
&lt;td>register&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>是否向此注册中心注册服务，如果设为false，将只订阅，不注册&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>subscribe&lt;/td>
&lt;td>subscribe&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>是否向此注册中心订阅服务，如果设为false，将只注册，不订阅&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>dynamic&lt;/td>
&lt;td>dynamic&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务是否动态注册，如果设为false，注册后将显示为disable状态，需人工启用，并且服务提供者停止时，也不会自动取消注册，需人工禁用。&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>group&lt;/td>
&lt;td>group&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务注册分组，跨组的服务不会相互影响，也无法相互调用，适用于环境隔离。&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>simplified&lt;/td>
&lt;td>simplified&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>注册到注册中心的URL是否采用精简模式的（与低版本兼容）&lt;/td>
&lt;td>2.7.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>extra-keys&lt;/td>
&lt;td>extraKeys&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>在simplified=true时，extraKeys允许你在默认参数外将额外的key放到URL中，格式：“interface,key1,key2”。&lt;/td>
&lt;td>2.7.0以上版本&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>同样官网提供的参数里面并未包含所有的属性 下面我就将其余的属性列举一下方便学习参考:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>变量&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>server&lt;/td>
&lt;td>String&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>client&lt;/td>
&lt;td>String&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cluster&lt;/td>
&lt;td>String&lt;/td>
&lt;td>影响流量在注册中心之间的分布，在订阅多个注册中心时很有用，可用选项：1。区域感知，特定类型的流量总是根据流量的来源进入一个注册表。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>zone&lt;/td>
&lt;td>String&lt;/td>
&lt;td>注册表所属的区域，通常用于隔离流量&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>parameters&lt;/td>
&lt;td>Map&amp;lt;String, String&amp;gt;&lt;/td>
&lt;td>自定义参数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>useAsConfigCenter&lt;/td>
&lt;td>Boolean&lt;/td>
&lt;td>该地址是否用作配置中心&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>useAsMetadataCenter&lt;/td>
&lt;td>Boolean&lt;/td>
&lt;td>该地址是否用作远程元数据中心&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>accepts&lt;/td>
&lt;td>String&lt;/td>
&lt;td>此注册表接受的rpc协议列表，例如“dubbo，rest”&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>preferred&lt;/td>
&lt;td>Boolean&lt;/td>
&lt;td>如果设置为true，则始终首先使用此注册表，这在订阅多个注册表时非常有用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>weight&lt;/td>
&lt;td>Integer&lt;/td>
&lt;td>影响注册中心之间的流量分布，当订阅多个注册中心仅在未指定首选注册中心时才生效时，此功能非常有用。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>registerMode&lt;/td>
&lt;td>String&lt;/td>
&lt;td>注册模式:实例级,接口级,所有&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>enableEmptyProtection&lt;/td>
&lt;td>Boolean&lt;/td>
&lt;td>收到的空url地址列表和空保护被禁用，将清除当前可用地址&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="103-注册中心配置对象创建与添加">10.3 注册中心配置对象创建与添加&lt;/h2>
&lt;p>前面例子中调用的代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>.registry(&lt;span style="color:#719e07">new&lt;/span> RegistryConfig(&lt;span style="color:#2aa198">&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>首先我们要来看的是RegistryConfig类型的构造器&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">RegistryConfig&lt;/span>(String address) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setAddress(address);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>继续看setAddress方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">setAddress&lt;/span>(String address) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//保存地址&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.address &lt;span style="color:#719e07">=&lt;/span> address;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//下面是支持将参数在url地址后面 比如用户名,密码,协议,端口,这几个参数提前做解析放入成员变量中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (address &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//地址转Dubbo的URL对象 这个URL是Dubbo自行实现的URL封装信息的类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL url &lt;span style="color:#719e07">=&lt;/span> URL.valueOf(address);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Refactor since 2.7.8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//值不存在时候更新属性,非常巧妙的代码 重构了多个if判断&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//第一个参数值不存在则调用第二个方法,第二个方法的参数为第三方方法 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updatePropertyIfAbsent(&lt;span style="color:#719e07">this&lt;/span>::getUsername, &lt;span style="color:#719e07">this&lt;/span>::setUsername, url.getUsername());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updatePropertyIfAbsent(&lt;span style="color:#719e07">this&lt;/span>::getPassword, &lt;span style="color:#719e07">this&lt;/span>::setPassword, url.getPassword());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updatePropertyIfAbsent(&lt;span style="color:#719e07">this&lt;/span>::getProtocol, &lt;span style="color:#719e07">this&lt;/span>::setProtocol, url.getProtocol());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updatePropertyIfAbsent(&lt;span style="color:#719e07">this&lt;/span>::getPort, &lt;span style="color:#719e07">this&lt;/span>::setPort, url.getPort());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//移除掉url中的backup自定义参数 (备份的注册中心地址)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, String&lt;span style="color:#719e07">&amp;gt;&lt;/span> params &lt;span style="color:#719e07">=&lt;/span> url.getParameters();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isNotEmptyMap(params)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> params.remove(BACKUP_KEY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将自定义参数存储到成员变量中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updateParameters(params);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception ignored) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后再回过头来看DubboBootstrap的registry方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> DubboBootstrap &lt;span style="color:#268bd2">registry&lt;/span>(RegistryConfig registryConfig) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将applicationModel对象设置给注册中心配置对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registryConfig.setScopeModel(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将注册中心配置对象添加到配置管理器中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configManager.addRegistry(registryConfig);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>直接来看配置管理器configManager的添加注册中心配置addRegistry方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">addRegistry&lt;/span>(RegistryConfig registryConfig) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addConfig(registryConfig);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>configManager 的addConfig方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">final&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T &lt;span style="color:#268bd2">extends&lt;/span> AbstractConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> T &lt;span style="color:#268bd2">addConfig&lt;/span>(AbstractConfig config) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (config &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ignore MethodConfig&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//检查当前配置管理器支持管理的配置对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//目前支持的配置有ApplicationConfig,MonitorConfig,MetricsConfig,SslConfig,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//ProtocolConfig,RegistryConfig,ConfigCenterConfig,MetadataReportConfig &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>isSupportConfigType(config.getClass())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException(&lt;span style="color:#2aa198">&amp;#34;Unsupported config type: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> config);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (config.getScopeModel() &lt;span style="color:#719e07">!=&lt;/span> scopeModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.setScopeModel(scopeModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//缓存中是否存在&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, AbstractConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> configsMap &lt;span style="color:#719e07">=&lt;/span> configsCache.computeIfAbsent(getTagName(config.getClass()), type &lt;span style="color:#719e07">-&amp;gt;&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ConcurrentHashMap&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//不是服务级接口配置则直接从缓存中读取到配置之后直接返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// fast check duplicated equivalent config before write lock&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>(config &lt;span style="color:#719e07">instanceof&lt;/span> ReferenceConfigBase &lt;span style="color:#719e07">||&lt;/span> config &lt;span style="color:#719e07">instanceof&lt;/span> ServiceConfigBase)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (AbstractConfig value : configsMap.values()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (value.equals(config)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> (T) value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// lock by config type&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//添加配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (configsMap) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> (T) addIfAbsent(config, configsMap);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ConfigManager配置管理器的addIfAbsent方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>C &lt;span style="color:#268bd2">extends&lt;/span> AbstractConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> C &lt;span style="color:#268bd2">addIfAbsent&lt;/span>(C config, Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, C&lt;span style="color:#719e07">&amp;gt;&lt;/span> configsMap)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">throws&lt;/span> IllegalStateException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置信息为空直接返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (config &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> configsMap &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> config;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// find by value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//根据配置规则判断,配置存在则返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Optional&lt;span style="color:#719e07">&amp;lt;&lt;/span>C&lt;span style="color:#719e07">&amp;gt;&lt;/span> prevConfig &lt;span style="color:#719e07">=&lt;/span> findDuplicatedConfig(configsMap, config);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (prevConfig.isPresent()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> prevConfig.get();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//生成配置key&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String key &lt;span style="color:#719e07">=&lt;/span> config.getId();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (key &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// generate key if id is not set&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key &lt;span style="color:#719e07">=&lt;/span> generateConfigId(config);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">while&lt;/span> (configsMap.containsKey(key));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//不相同的配置key重复则抛出异常&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> C existedConfig &lt;span style="color:#719e07">=&lt;/span> configsMap.get(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (existedConfig &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>isEquals(existedConfig, config)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String type &lt;span style="color:#719e07">=&lt;/span> config.getClass().getSimpleName();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(String.format(&lt;span style="color:#2aa198">&amp;#34;Duplicate %s found, there already has one default %s or more than two %ss have the same id, &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;you can try to give each %s a different id, override previous config with later config. id: %s, prev: %s, later: %s&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type, type, type, type, key, existedConfig, config));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// override existed config if any&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将配置对象存入configsMap对象中,configsMap来源于configsCache&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configsMap.put(key, config);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> config;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原文： &lt;a href="https://blog.elastic.link/2022/07/10/dubbo/10-dubbo-qi-dong-qi-dubbobootstrap-tian-jia-zhu-ce-zhong-xin-pei-zhi-xin-xi-registryconfig//">&amp;laquo;Dubbo启动器DubboBootstrap添加注册中心配置信息RegistryConfig&amp;raquo;&lt;/a>&lt;/p></description></item><item><title>Blog: 9-Dubbo启动器DubboBootstrap添加应用程序的配置信息ApplicationConfig</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/09/9-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E6%B7%BB%E5%8A%A0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AFapplicationconfig/</link><pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/09/9-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E6%B7%BB%E5%8A%A0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AFapplicationconfig/</guid><description>
&lt;h1 id="9-dubbo启动器dubbobootstrap添加应用程序的配置信息applicationconfig">9-Dubbo启动器DubboBootstrap添加应用程序的配置信息ApplicationConfig&lt;/h1>
&lt;h2 id="91-简介">9.1 简介&lt;/h2>
&lt;p>先贴个代码用来参考:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> DubboBootstrap bootstrap &lt;span style="color:#719e07">=&lt;/span> DubboBootstrap.getInstance();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bootstrap.application(&lt;span style="color:#719e07">new&lt;/span> ApplicationConfig(&lt;span style="color:#2aa198">&amp;#34;dubbo-demo-api-provider&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .registry(&lt;span style="color:#719e07">new&lt;/span> RegistryConfig(&lt;span style="color:#2aa198">&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .protocol(&lt;span style="color:#719e07">new&lt;/span> ProtocolConfig(CommonConstants.DUBBO, &lt;span style="color:#719e07">-&lt;/span>1))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .service(service)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .start()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .await();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上个博客我们说了启动器对象的创建,启动器对象在启动之前是要初始化一些配置信息的,这里我们来看这一行代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>bootstrap.application(&lt;span style="color:#719e07">new&lt;/span> ApplicationConfig(&lt;span style="color:#2aa198">&amp;#34;dubbo-demo-api-provider&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="92-应用程序applicationconfig的配置信息">9.2 应用程序ApplicationConfig的配置信息&lt;/h2>
&lt;p>ApplicationConfig的构造器比较简单就是为他的成员变量name赋值来标识这个应用程序的名字
下面我们直接参考下官网的配置表格:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>name&lt;/td>
&lt;td>application&lt;/td>
&lt;td>string&lt;/td>
&lt;td>&lt;strong>必填&lt;/strong>&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样，此参数不是匹配条件，你当前项目叫什么名字就填什么，和提供者消费者角色无关，比如：kylin应用调用了morgan应用的服务，则kylin项目配成kylin，morgan项目配成morgan，可能kylin也提供其它服务给别人使用，但kylin项目永远配成kylin，这样注册中心将显示kylin依赖于morgan&lt;/td>
&lt;td>1.0.16以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>version&lt;/td>
&lt;td>application.version&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>当前应用的版本&lt;/td>
&lt;td>2.2.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>owner&lt;/td>
&lt;td>owner&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>应用负责人，用于服务治理，请填写负责人公司邮箱前缀&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>organization&lt;/td>
&lt;td>organization&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>组织名称(BU或部门)，用于注册中心区分服务来源，此配置项建议不要使用autoconfig，直接写死在配置中，比如china,intl,itu,crm,asc,dw,aliexpress等&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>architecture&lt;/td>
&lt;td>architecture&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>用于服务分层对应的架构。如，intl、china。不同的架构使用不同的分层。&lt;/td>
&lt;td>2.0.7以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>environment&lt;/td>
&lt;td>environment&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>应用环境，如：develop/test/product，不同环境使用不同的缺省值，以及作为只用于开发测试功能的限制条件&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>compiler&lt;/td>
&lt;td>compiler&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>javassist&lt;/td>
&lt;td>性能优化&lt;/td>
&lt;td>Java字节码编译器，用于动态类的生成，可选：jdk或javassist&lt;/td>
&lt;td>2.1.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>logger&lt;/td>
&lt;td>logger&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>slf4j&lt;/td>
&lt;td>性能优化&lt;/td>
&lt;td>日志输出方式，可选：slf4j,jcl,log4j,log4j2,jdk&lt;/td>
&lt;td>2.2.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>metadata-type&lt;/td>
&lt;td>metadata-type&lt;/td>
&lt;td>String&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>local&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>metadata 传递方式，是以 Provider 视角而言的，Consumer 侧配置无效，可选值有： remote - Provider 把 metadata 放到远端注册中心，Consumer 从注册中心获取 local - Provider 把 metadata 放在本地，Consumer 从 Provider 处直接获取&lt;/td>
&lt;td>2.7.6以上版本&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>官网的配置很详细了上面有一些属性是值得注意的比如这个name,compiler,logger,metadata-type 我们可能要多看下默认值是什么,方便我们在使用过程中遇到问题的排查&lt;/p>
&lt;p>常用的属性参考官网的表格已经足够了,不过上面的属性不是列举了所有的属性,后续应该官方文档回更新:
我这里把缺失的一些属性列举出来:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>变量&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>registries&lt;/td>
&lt;td>List&lt;RegistryConfig>&lt;/td>
&lt;td>应用级注册中心列表&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>registryIds&lt;/td>
&lt;td>String&lt;/td>
&lt;td>注册中心id列表&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>monitor&lt;/td>
&lt;td>MonitorConfig&lt;/td>
&lt;td>应用级监控配置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>dumpDirectory&lt;/td>
&lt;td>String&lt;/td>
&lt;td>保存线程转储的目录&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>qosEnable&lt;/td>
&lt;td>Boolean&lt;/td>
&lt;td>是否启用qos&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>qosHost&lt;/td>
&lt;td>String&lt;/td>
&lt;td>要侦听的qos主机地址&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>qosPort&lt;/td>
&lt;td>Integer&lt;/td>
&lt;td>要侦听的qos端口&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>qosAcceptForeignIp&lt;/td>
&lt;td>Boolean&lt;/td>
&lt;td>qos是否接收外部IP&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>parameters&lt;/td>
&lt;td>Map&amp;lt;String, String&amp;gt;&lt;/td>
&lt;td>自定义参数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>shutwait&lt;/td>
&lt;td>String&lt;/td>
&lt;td>应用程序关闭时间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>hostname&lt;/td>
&lt;td>String&lt;/td>
&lt;td>主机名&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>registerConsumer&lt;/td>
&lt;td>Boolean&lt;/td>
&lt;td>用于控制是否将实例注册到注册表。仅当实例是纯消费者时才设置为“false”。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>repository&lt;/td>
&lt;td>String&lt;/td>
&lt;td>没找到哪里用了&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>enableFileCache&lt;/td>
&lt;td>Boolean&lt;/td>
&lt;td>是否开启本地文件缓存&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>protocol&lt;/td>
&lt;td>String&lt;/td>
&lt;td>此应用程序的首选协议（名称）适用于难以确定哪个是首选协议的地方&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>metadataServiceProtocol&lt;/td>
&lt;td>String&lt;/td>
&lt;td>用于点对点的元数据传输的协议&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>metadataServicePort&lt;/td>
&lt;td>Integer&lt;/td>
&lt;td>元数据服务端口号，用于服务发现&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>livenessProbe&lt;/td>
&lt;td>String&lt;/td>
&lt;td>Liveness 存活探针 用于设置qos中探测器的扩展&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>readinessProbe&lt;/td>
&lt;td>String&lt;/td>
&lt;td>Readiness 就绪探针&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>startupProbe&lt;/td>
&lt;td>String&lt;/td>
&lt;td>Startup 启动探针&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>registerMode&lt;/td>
&lt;td>String&lt;/td>
&lt;td>注册模式,实例级,接口集,所有&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>enableEmptyProtection&lt;/td>
&lt;td>Boolean&lt;/td>
&lt;td>接收到的空url地址列表和空保护被禁用，将清除当前可用地址&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>这里我们先来简单了解下这个实体类型的基本配置,直接看配置可能不太好理解,后面我们讲到每个配置的时候可以回来参考一下&lt;/p>
&lt;h2 id="应用程序配置对象添加到启动器中的配置管理器中">应用程序配置对象添加到启动器中的配置管理器中&lt;/h2>
&lt;p>了解了配置信息再回过头来看下这个配置信息如何存放到启动器里面的:&lt;/p>
&lt;p>我们的Demo调用代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> DubboBootstrap bootstrap &lt;span style="color:#719e07">=&lt;/span> DubboBootstrap.getInstance();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bootstrap.application(&lt;span style="color:#719e07">new&lt;/span> ApplicationConfig(&lt;span style="color:#2aa198">&amp;#34;dubbo-demo-api-provider&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>DubboBootstrap的application方法设置一个应用程序配置ApplicationConfig对象&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> DubboBootstrap &lt;span style="color:#268bd2">application&lt;/span>(ApplicationConfig applicationConfig) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将启动器构造器中初始化的默认应用程序模型对象传递给配置对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationConfig.setScopeModel(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将配置信息添加到配置管理器中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configManager.setApplication(applicationConfig);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ConfigManager配置管理器的setApplication方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@DisableInject&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">setApplication&lt;/span>(ApplicationConfig application) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addConfig(application);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ConfigManager配置管理器的addConfig方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">final&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T &lt;span style="color:#268bd2">extends&lt;/span> AbstractConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> T &lt;span style="color:#268bd2">addConfig&lt;/span>(AbstractConfig config) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (config &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ignore MethodConfig&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//检查当前配置管理器支持管理的配置对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//目前支持的配置有ApplicationConfig,MonitorConfig,MetricsConfig,SslConfig,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//ProtocolConfig,RegistryConfig,ConfigCenterConfig,MetadataReportConfig&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>isSupportConfigType(config.getClass())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException(&lt;span style="color:#2aa198">&amp;#34;Unsupported config type: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> config);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (config.getScopeModel() &lt;span style="color:#719e07">!=&lt;/span> scopeModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.setScopeModel(scopeModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//缓存中是否存在&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, AbstractConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> configsMap &lt;span style="color:#719e07">=&lt;/span> configsCache.computeIfAbsent(getTagName(config.getClass()), type &lt;span style="color:#719e07">-&amp;gt;&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ConcurrentHashMap&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// fast check duplicated equivalent config before write lock&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//不是服务级配置则直接从缓存中读取到配置之后直接返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>(config &lt;span style="color:#719e07">instanceof&lt;/span> ReferenceConfigBase &lt;span style="color:#719e07">||&lt;/span> config &lt;span style="color:#719e07">instanceof&lt;/span> ServiceConfigBase)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (AbstractConfig value : configsMap.values()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (value.equals(config)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> (T) value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// lock by config type&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//添加配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (configsMap) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> (T) addIfAbsent(config, configsMap);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ConfigManager配置管理器的addIfAbsent方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>C &lt;span style="color:#268bd2">extends&lt;/span> AbstractConfig&lt;span style="color:#719e07">&amp;gt;&lt;/span> C &lt;span style="color:#268bd2">addIfAbsent&lt;/span>(C config, Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, C&lt;span style="color:#719e07">&amp;gt;&lt;/span> configsMap)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">throws&lt;/span> IllegalStateException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//配置信息为空直接返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (config &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> configsMap &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> config;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// find by value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//根据配置规则判断,配置存在则返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Optional&lt;span style="color:#719e07">&amp;lt;&lt;/span>C&lt;span style="color:#719e07">&amp;gt;&lt;/span> prevConfig &lt;span style="color:#719e07">=&lt;/span> findDuplicatedConfig(configsMap, config);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (prevConfig.isPresent()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> prevConfig.get();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//生成配置key&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String key &lt;span style="color:#719e07">=&lt;/span> config.getId();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (key &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// generate key if id is not set&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key &lt;span style="color:#719e07">=&lt;/span> generateConfigId(config);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">while&lt;/span> (configsMap.containsKey(key));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//不相同的配置key重复则抛出异常&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> C existedConfig &lt;span style="color:#719e07">=&lt;/span> configsMap.get(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (existedConfig &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>isEquals(existedConfig, config)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String type &lt;span style="color:#719e07">=&lt;/span> config.getClass().getSimpleName();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(String.format(&lt;span style="color:#2aa198">&amp;#34;Duplicate %s found, there already has one default %s or more than two %ss have the same id, &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;you can try to give each %s a different id, override previous config with later config. id: %s, prev: %s, later: %s&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type, type, type, type, key, existedConfig, config));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// override existed config if any&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将配置对象存入configsMap对象中,configsMap来源于configsCache&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configsMap.put(key, config);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> config;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原文： &lt;a href="https://blog.elastic.link/2022/07/10/dubbo/9-dubbo-qi-dong-qi-dubbobootstrap-tian-jia-ying-yong-cheng-xu-de-pei-zhi-xin-xi-applicationconfig/">&amp;laquo;Dubbo启动器DubboBootstrap添加应用程序的配置信息ApplicationConfig&amp;raquo;&lt;/a>&lt;/p></description></item><item><title>Blog: 8-Dubbo启动器DubboBootstrap借助双重校验锁的单例模式进行对象的初始化</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/08/8-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E5%80%9F%E5%8A%A9%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</link><pubDate>Mon, 08 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/08/8-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E5%80%9F%E5%8A%A9%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</guid><description>
&lt;h1 id="8-dubbo启动器dubbobootstrap借助双重校验锁的单例模式进行对象的初始化">8-Dubbo启动器DubboBootstrap借助双重校验锁的单例模式进行对象的初始化&lt;/h1>
&lt;h2 id="81-启动器简介">8.1 启动器简介&lt;/h2>
&lt;p>在说启动器之前先把视野拉回第一章&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/1-cong-yi-ge-demo-shuo-qi/">《1-从一个服务提供者的Demo说起》&lt;/a>我们的Demo代码,下面只贴一下核心代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">Application&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>(String&lt;span style="color:#719e07">[]&lt;/span> args) &lt;span style="color:#268bd2">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startWithBootstrap();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">startWithBootstrap&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//前面的文章都在说这个服务配置对象的创建,中间又说了分层域模型,扩展加载机制&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServiceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>DemoServiceImpl&lt;span style="color:#719e07">&amp;gt;&lt;/span> service &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ServiceConfig&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//为服务配置下服务接口和服务实现,下面两行用来初始化对象就不详细说了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> service.setInterface(DemoService.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> service.setRef(&lt;span style="color:#719e07">new&lt;/span> DemoServiceImpl());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这一个篇章主要说这里:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DubboBootstrap bootstrap &lt;span style="color:#719e07">=&lt;/span> DubboBootstrap.getInstance();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bootstrap.application(&lt;span style="color:#719e07">new&lt;/span> ApplicationConfig(&lt;span style="color:#2aa198">&amp;#34;dubbo-demo-api-provider&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .registry(&lt;span style="color:#719e07">new&lt;/span> RegistryConfig(&lt;span style="color:#2aa198">&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .protocol(&lt;span style="color:#719e07">new&lt;/span> ProtocolConfig(CommonConstants.DUBBO, &lt;span style="color:#719e07">-&lt;/span>1))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .service(service)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .start()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .await();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Dubbo3 往云原生的方向走自然要针对云原生应用的应用启动,应用运行,应用发布等信息做一些建模,这个DubboBootstrap就是用来启动Dubbo服务的.类似于Netty的Bootstrap类型和ServerBootstrap启动器&lt;/p>
&lt;h2 id="82-双重校验锁的单例模式创建启动器对象的">8.2 双重校验锁的单例模式创建启动器对象的&lt;/h2>
&lt;p>Dubbo的bootstrap类为啥要用单例模式:&lt;/p>
&lt;p>通过调用静态方法getInstance()获取单例实例。之所以设计为单例，是因为Dubbo中的一些类（如ExtensionLoader）只为每个进程设计一个实例。&lt;/p>
&lt;p>下面就来直接看代码吧,代码胜千言:
对象的调用代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>DubboBootstrap bootstrap &lt;span style="color:#719e07">=&lt;/span> DubboBootstrap.getInstance();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>DubboBootstrap获取对象的getInstance()方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> DubboBootstrap &lt;span style="color:#268bd2">getInstance&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//双重校验锁第一次判断空&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (instance &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//为空都进行排队&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (DubboBootstrap.class) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//双重校验锁第二次判断空 上面为空的都排队了这里得判断下&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (instance &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//调用重载方法获取对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instance &lt;span style="color:#719e07">=&lt;/span> DubboBootstrap.getInstance(ApplicationModel.defaultModel());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> instance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>DubboBootstrap获取对象重载的getInstance(ApplicationModel applicationModel)方法:&lt;/p>
&lt;p>&lt;em>computeIfAbsent() 方法对 hashMap 中指定 key 的值进行重新计算，如果不存在这个 key，则添加到 hashMap 中。&lt;/em>&lt;/p>
&lt;p>instanceMap设计为Map&amp;lt;ApplicationModel, DubboBootstrap&amp;gt;类型 Key,意味着可以为多个应用程序模型创建不同的启动器,启动多个服务&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> DubboBootstrap &lt;span style="color:#268bd2">getInstance&lt;/span>(ApplicationModel applicationModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> instanceMap.computeIfAbsent(applicationModel, _k &lt;span style="color:#719e07">-&amp;gt;&lt;/span> &lt;span style="color:#719e07">new&lt;/span> DubboBootstrap(applicationModel));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="83-dubbobootstrap的构造器代码">8.3 DubboBootstrap的构造器代码&lt;/h2>
&lt;p>构造器代码是逻辑比较复杂的地方,我们先来看下代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">DubboBootstrap&lt;/span>(ApplicationModel applicationModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//存储应用程序启动模型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.applicationModel &lt;span style="color:#719e07">=&lt;/span> applicationModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取配置管理器ConfigManager: 配置管理器的扩展类型ApplicationExt ,扩展名字config&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configManager &lt;span style="color:#719e07">=&lt;/span> applicationModel.getApplicationConfigManager();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取环境信息Environment: 环境信息的扩展类型为ApplicationExt,扩展名字为environment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> environment &lt;span style="color:#719e07">=&lt;/span> applicationModel.getModelEnvironment();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//执行器存储仓库(线程池)ExecutorRepository: 扩展类型为ExecutorRepository,默认扩展扩展名字为default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> executorRepository &lt;span style="color:#719e07">=&lt;/span> applicationModel.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化并启动应用程序实例ApplicationDeployer,DefaultApplicationDeployer类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationDeployer &lt;span style="color:#719e07">=&lt;/span> applicationModel.getDeployer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// listen deploy events&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//为发布器 设置生命周期回调&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationDeployer.addDeployListener(&lt;span style="color:#719e07">new&lt;/span> DeployListenerAdapter&lt;span style="color:#719e07">&amp;lt;&lt;/span>ApplicationModel&lt;span style="color:#719e07">&amp;gt;&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">onStarted&lt;/span>(ApplicationModel scopeModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> notifyStarted(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">onStopped&lt;/span>(ApplicationModel scopeModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> notifyStopped(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">onFailure&lt;/span>(ApplicationModel scopeModel, Throwable cause) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> notifyStopped(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将启动器对象注册到应用程序模型applicationModel的Bean工厂中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// register DubboBootstrap bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationModel.getBeanFactory().registerBean(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原文： &lt;a href="https://blog.elastic.link/2022/07/10/dubbo/8-dubbo-qi-dong-qi-dubbobootstrap-jie-zhu-shuang-chong-xiao-yan-suo-de-dan-li-mo-shi-jin-xing-dui-xiang-de-chu-shi-hua/">&amp;laquo;Dubbo启动器DubboBootstrap借助双重校验锁的单例模式进行对象的初始化&amp;raquo;&lt;/a>&lt;/p></description></item><item><title>Blog: 7-Dubbo的SPI扩展机制之自动激活扩展Activate源码解析</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/07/7-dubbo%E7%9A%84spi%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%BF%80%E6%B4%BB%E6%89%A9%E5%B1%95activate%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Sun, 07 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/07/7-dubbo%E7%9A%84spi%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%BF%80%E6%B4%BB%E6%89%A9%E5%B1%95activate%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>
&lt;h1 id="7-dubbo的spi扩展机制之自动激活扩展activate源码解析">7-Dubbo的SPI扩展机制之自动激活扩展Activate源码解析&lt;/h1>
&lt;h2 id="71-activate扩展的说明">7.1 Activate扩展的说明&lt;/h2>
&lt;p>此注解对于使用给定条件自动激活某些扩展非常有用，例如：@Activate可用于在有多个实现时加载某些筛选器扩展。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>group()&lt;/strong> 指定组条件。框架SPI定义了有效的组值。&lt;/li>
&lt;li>&lt;strong>value()&lt;/strong> 指定URL条件中的参数键。&lt;/li>
&lt;/ul>
&lt;p>SPI提供程序可以调用ExtensionLoader。getActivateExtension(URL、String、String)方法以查找具有给定条件的所有已激活扩展。&lt;/p>
&lt;p>比如后面我们会说到的&lt;strong>过滤器扩展对象&lt;/strong>的获取,如下通过调用&lt;strong>getActivateExtension方法的&lt;/strong>代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>Filter&lt;span style="color:#719e07">&amp;gt;&lt;/span> filters;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filters &lt;span style="color:#719e07">=&lt;/span> ScopeModelUtil.getExtensionLoader(Filter.class, moduleModels.get(0)).getActivateExtension(url, key, group);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="72-获取自动激活扩展的源码">7.2 获取自动激活扩展的源码&lt;/h2>
&lt;p>前面我们看了激活扩展是通过调用getActivateExtension方法来获取对象的,那接下来就来看下这个方法做了什么操作:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">* @param url 服务的url
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">* @param key 用于获取扩展点名称的url参数键 比如监听器:exporter.listener,过滤器:params-filter,telnet处理器:telnet
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">getActivateExtension&lt;/span>(URL url, String key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> getActivateExtension(url, key, &lt;span style="color:#cb4b16">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>继续调用重载的方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param url 服务的url
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param key 用于获取扩展点名称的url参数键 比如监听器:exporter.listener,过滤器:params-filter,telnet处理器:telnet
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param group group 用于筛选的分组,比如过滤器中使用此参数来区分消费者使用这个过滤器还是提供者使用这个过滤器他们的group参数分表为consumer,provider
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @return 已激活的扩展列表。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">getActivateExtension&lt;/span>(URL url, String key, String group) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//从参数中获取url指定的值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String value &lt;span style="color:#719e07">=&lt;/span> url.getParameter(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//调用下个重载的方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> getActivateExtension(url, StringUtils.isEmpty(value) &lt;span style="color:#719e07">?&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> : COMMA_SPLIT_PATTERN.split(value), group);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的重载方法都是用来转换参数的,下面这个方法才是真正的逻辑&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * 获取激活扩展.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param url 服务的url
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param values 这个value是扩展点的名字 当指定了时候会使用指定的名字的扩展
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param group group 用于筛选的分组,比如过滤器中使用此参数来区分消费者使用这个过滤器还是提供者使用这个过滤器他们的group参数分表为consumer,provider
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @return 获取激活扩展.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">getActivateExtension&lt;/span>(URL url, String&lt;span style="color:#719e07">[]&lt;/span> values, String group) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//检查扩展加载器是否被销毁了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkDestroyed();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// solve the bug of using @SPI&amp;#39;s wrapper method to report a null pointer exception.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建个有序的Map集合,用来对扩展进行排序&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span>, T&lt;span style="color:#719e07">&amp;gt;&lt;/span> activateExtensionsMap &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> TreeMap&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(activateComparator);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化扩展名字,指定了扩展名字values不为空&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">&amp;gt;&lt;/span> names &lt;span style="color:#719e07">=&lt;/span> values &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">?&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(0) : asList(values);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//扩展名字使用Set集合进行去重&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">&amp;gt;&lt;/span> namesSet &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> HashSet&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(names);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//参数常量是 -default 扩展名字是否不包含默认的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>namesSet.contains(REMOVE_VALUE_PREFIX &lt;span style="color:#719e07">+&lt;/span> DEFAULT_KEY)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//第一次进来肯定是没有缓存对象双重校验锁检查下&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (cachedActivateGroups.size() &lt;span style="color:#719e07">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (cachedActivateGroups) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// cache all extensions&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (cachedActivateGroups.size() &lt;span style="color:#719e07">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加载扩展类型对应的扩展类,这个具体细节参考源码或者《[Dubbo3.0.7源码解析系列]-5-Dubbo的SPI扩展机制与自适应扩展对象的创建与扩展文件的扫描源码解析》章节&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getExtensionClasses();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (Map.Entry&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, Object&lt;span style="color:#719e07">&amp;gt;&lt;/span> entry : cachedActivates.entrySet()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String name &lt;span style="color:#719e07">=&lt;/span> entry.getKey();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object activate &lt;span style="color:#719e07">=&lt;/span> entry.getValue();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#719e07">[]&lt;/span> activateGroup, activateValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//遍历所有的activates列表获取group()和value()值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (activate &lt;span style="color:#719e07">instanceof&lt;/span> Activate) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> activateGroup &lt;span style="color:#719e07">=&lt;/span> ((Activate) activate).group();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> activateValue &lt;span style="color:#719e07">=&lt;/span> ((Activate) activate).value();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (activate &lt;span style="color:#719e07">instanceof&lt;/span> com.alibaba.dubbo.common.extension.Activate) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> activateGroup &lt;span style="color:#719e07">=&lt;/span> ((com.alibaba.dubbo.common.extension.Activate) activate).group();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> activateValue &lt;span style="color:#719e07">=&lt;/span> ((com.alibaba.dubbo.common.extension.Activate) activate).value();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//缓存分组值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cachedActivateGroups.put(name, &lt;span style="color:#719e07">new&lt;/span> HashSet&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(Arrays.asList(activateGroup)));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#719e07">[][]&lt;/span> keyPairs &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> String&lt;span style="color:#719e07">[&lt;/span>activateValue.length&lt;span style="color:#719e07">][]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//遍历指定的激活扩展的扩展名字列表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (&lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> 0; i &lt;span style="color:#719e07">&amp;lt;&lt;/span> activateValue.length; i&lt;span style="color:#719e07">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (activateValue&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">]&lt;/span>.contains(&lt;span style="color:#2aa198">&amp;#34;:&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> keyPairs&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">]&lt;/span> &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> String&lt;span style="color:#719e07">[&lt;/span>2&lt;span style="color:#719e07">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#719e07">[]&lt;/span> arr &lt;span style="color:#719e07">=&lt;/span> activateValue&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">]&lt;/span>.split(&lt;span style="color:#2aa198">&amp;#34;:&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> keyPairs&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">][&lt;/span>0&lt;span style="color:#719e07">]&lt;/span> &lt;span style="color:#719e07">=&lt;/span> arr&lt;span style="color:#719e07">[&lt;/span>0&lt;span style="color:#719e07">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> keyPairs&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">][&lt;/span>1&lt;span style="color:#719e07">]&lt;/span> &lt;span style="color:#719e07">=&lt;/span> arr&lt;span style="color:#719e07">[&lt;/span>1&lt;span style="color:#719e07">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> keyPairs&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">]&lt;/span> &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> String&lt;span style="color:#719e07">[&lt;/span>1&lt;span style="color:#719e07">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> keyPairs&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">][&lt;/span>0&lt;span style="color:#719e07">]&lt;/span> &lt;span style="color:#719e07">=&lt;/span> activateValue&lt;span style="color:#719e07">[&lt;/span>i&lt;span style="color:#719e07">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//缓存指定扩展信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cachedActivateValues.put(name, keyPairs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// traverse all cached extensions&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//遍历所有激活的扩展名字和扩展分组集合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cachedActivateGroups.forEach((name, activateGroup) &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//筛选当前扩展的扩展分组与激活扩展的扩展分组是否可以匹配&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (isMatchGroup(group, activateGroup)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//不能是指定的扩展名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>namesSet.contains(name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//也不能是带有 -指定扩展名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>namesSet.contains(REMOVE_VALUE_PREFIX &lt;span style="color:#719e07">+&lt;/span> name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果在Active注解中配置了value则当指定的键出现在URL的参数中时，激活当前扩展名。 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果未配置value属性则默认都是匹配的(cachedActivateValues中不存在对应扩展名字的缓存的时候默认为true)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> isActive(cachedActivateValues.get(name), url)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//缓存激活的扩展类型映射的扩展名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> activateExtensionsMap.put(getExtensionClass(name), getExtension(name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (namesSet.contains(DEFAULT_KEY)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// will affect order&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// `ext1,default,ext2` means ext1 will happens before all of the default extensions while ext2 will after them&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ArrayList&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> extensionsResult &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(activateExtensionsMap.size() &lt;span style="color:#719e07">+&lt;/span> names.size());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (&lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> 0; i &lt;span style="color:#719e07">&amp;lt;&lt;/span> names.size(); i&lt;span style="color:#719e07">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String name &lt;span style="color:#719e07">=&lt;/span> names.get(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>name.startsWith(REMOVE_VALUE_PREFIX)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>namesSet.contains(REMOVE_VALUE_PREFIX &lt;span style="color:#719e07">+&lt;/span> name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>DEFAULT_KEY.equals(name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (containsExtension(name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extensionsResult.add(getExtension(name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extensionsResult.addAll(activateExtensionsMap.values());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> extensionsResult;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// add extensions, will be sorted by its order&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (&lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> 0; i &lt;span style="color:#719e07">&amp;lt;&lt;/span> names.size(); i&lt;span style="color:#719e07">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String name &lt;span style="color:#719e07">=&lt;/span> names.get(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>name.startsWith(REMOVE_VALUE_PREFIX)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>namesSet.contains(REMOVE_VALUE_PREFIX &lt;span style="color:#719e07">+&lt;/span> name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>DEFAULT_KEY.equals(name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (containsExtension(name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> activateExtensionsMap.put(getExtensionClass(name), getExtension(name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(activateExtensionsMap.values());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再来回顾下扫描扩展类型的时候,与激活扩展的相关扫描代码:
与激活注解关键的代码位置在这里ExtensionLoader的loadClass方法中
我来贴下loadClass方法核心的代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">if&lt;/span> (clazz.isAnnotationPresent(Adaptive.class)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cacheAdaptiveClass(clazz, overridden);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (isWrapperClass(clazz)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cacheWrapperClass(clazz);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isEmpty(name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name &lt;span style="color:#719e07">=&lt;/span> findAnnotationName(clazz);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (name.length() &lt;span style="color:#719e07">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;No such extension name for the class &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> clazz.getName() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; in the config &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> resourceURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#719e07">[]&lt;/span> names &lt;span style="color:#719e07">=&lt;/span> NAME_SEPARATOR.split(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (ArrayUtils.isNotEmpty(names)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//位置在这里其他地方就不标记注释了,前面判断了如果不是Adaptive也不是Wrapper类型则我们可以来判断是否为Activate 类型如果是的话调用cacheActivateClass方法将扩展缓存进cachedActivates缓存中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cacheActivateClass(clazz, names&lt;span style="color:#719e07">[&lt;/span>0&lt;span style="color:#719e07">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (String n : names) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cacheName(clazz, n);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> saveInExtensionClass(extensionClasses, clazz, n, overridden);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">cacheActivateClass&lt;/span>(Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> clazz, String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Activate activate &lt;span style="color:#719e07">=&lt;/span> clazz.getAnnotation(Activate.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (activate &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注解存在则加入激活注解缓存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cachedActivates.put(name, activate);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// support com.alibaba.dubbo.common.extension.Activate&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> com.alibaba.dubbo.common.extension.Activate oldActivate &lt;span style="color:#719e07">=&lt;/span> clazz.getAnnotation(com.alibaba.dubbo.common.extension.Activate.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (oldActivate &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cachedActivates.put(name, oldActivate);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原文： &lt;a href="https://blog.elastic.link/2022/07/10/dubbo/7-dubbo-de-spi-kuo-zhan-ji-zhi-zhi-zi-dong-ji-huo-kuo-zhan-activate-yuan-ma-jie-xi/">《Dubbo的SPI扩展机制之自动激活扩展Activate源码解析》&lt;/a>&lt;/p></description></item><item><title>Blog: 06-Dubbo的SPI扩展机制之普通扩展对象的创建与Wrapper机制的源码解析</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/06/06-dubbo%E7%9A%84spi%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%99%AE%E9%80%9A%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8Ewrapper%E6%9C%BA%E5%88%B6%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Sat, 06 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/06/06-dubbo%E7%9A%84spi%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%99%AE%E9%80%9A%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8Ewrapper%E6%9C%BA%E5%88%B6%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>
&lt;h1 id="6-dubbo的spi扩展机制之普通扩展对象的创建与wrapper机制的源码解析">6 Dubbo的SPI扩展机制之普通扩展对象的创建与Wrapper机制的源码解析&lt;/h1>
&lt;h2 id="61-普通扩展对象的加载与创建">6.1 普通扩展对象的加载与创建&lt;/h2>
&lt;p>这里我们要分析的是ExtensionLoader类型的getExtension(String name)方法, 有了前面自适应扩展的铺垫,这里就更容易来看了getExtension是根据扩展名字获取具体扩展的通用方法,我们来根据某个类型来获取扩展的时候就是走的这里,比如在这个博客开头的介绍:&lt;/p>
&lt;ul>
&lt;li>ApplicationModel中获取配置管理器对象&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> configManager &lt;span style="color:#719e07">=&lt;/span> (ConfigManager) &lt;span style="color:#719e07">this&lt;/span>.getExtensionLoader(ApplicationExt.class)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .getExtension(ConfigManager.NAME);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="611-getextension方法源码">6.1.1 getExtension方法源码&lt;/h3>
&lt;p>先来看下getExtension方法的源码,根据扩展名字查询扩展对象&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">public&lt;/span> T &lt;span style="color:#268bd2">getExtension&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里并不能看到什么,只多传了个参数wrap为true调用另外一个重载的方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> T extension &lt;span style="color:#719e07">=&lt;/span> getExtension(name, &lt;span style="color:#b58900">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (extension &lt;span style="color:#719e07">==&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException(&lt;span style="color:#2aa198">&amp;#34;Not find extension: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> extension;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> T &lt;span style="color:#268bd2">getExtension&lt;/span>(String name, &lt;span style="color:#dc322f">boolean&lt;/span> wrap) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//检查扩展加载器是否已被销毁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkDestroyed();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isEmpty(name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException(&lt;span style="color:#2aa198">&amp;#34;Extension name == null&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//扩展名字为true则加载默认扩展&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>.equals(name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> getDefaultExtension();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//非wrap类型则将缓存的扩展名字key加上_origin后缀&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//wrap是aop机制 俗称切面,这个origin在aop里面可以称为切点,下面的wrap扩展可以称为增强通知的类型,普通扩展和wrap扩展的扩展名字是一样的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String cacheKey &lt;span style="color:#719e07">=&lt;/span> name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>wrap) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cacheKey &lt;span style="color:#719e07">+=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;_origin&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//从cachedInstances缓存中查询&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">final&lt;/span> Holder&lt;span style="color:#719e07">&amp;lt;&lt;/span>Object&lt;span style="color:#719e07">&amp;gt;&lt;/span> holder &lt;span style="color:#719e07">=&lt;/span> getOrCreateHolder(cacheKey);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object instance &lt;span style="color:#719e07">=&lt;/span> holder.get();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//缓存中不存在则创建扩展对象 双重校验锁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (instance &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (holder) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//双重校验锁的方式&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instance &lt;span style="color:#719e07">=&lt;/span> holder.get();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (instance &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建扩展对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instance &lt;span style="color:#719e07">=&lt;/span> createExtension(name, wrap);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> holder.set(instance);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> (T) instance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们先来看一下默认扩展的加载代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> T &lt;span style="color:#268bd2">getDefaultExtension&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加载扩展类型对应的所有扩展SPI实现类型,在加载所有扩展实现类型的时候会缓存这个扩展的默认实现类型,将对象缓存在cachedDefaultName中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getExtensionClasses();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isBlank(cachedDefaultName) &lt;span style="color:#719e07">||&lt;/span> &lt;span style="color:#2aa198">&amp;#34;true&amp;#34;&lt;/span>.equals(cachedDefaultName)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//再回到加载扩展的方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> getExtension(cachedDefaultName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建扩展对象方法这个和自适应扩展的创建扩展类似
createExtension:
具体过程如下:&lt;/p>
&lt;ul>
&lt;li>加载扩展类型:getExtensionClasses()&lt;/li>
&lt;li>创建扩展对象:createExtensionInstance(clazz)&lt;/li>
&lt;li>注入自适应扩展: injectExtension(instance);&lt;/li>
&lt;li>wrap处理&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">private&lt;/span> T &lt;span style="color:#268bd2">createExtension&lt;/span>(String name, boolean wrap) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//扩展的创建的第一步扫描所有jar中的扩展实现,这里扫描完之后获取对应扩展名字的扩展实现类型的Class对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> clazz &lt;span style="color:#719e07">=&lt;/span> getExtensionClasses().get(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//出现异常了 转换下异常信息 再抛出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (clazz &lt;span style="color:#719e07">==&lt;/span> null &lt;span style="color:#719e07">||&lt;/span> unacceptableExceptions.contains(name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> findException(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//当前扩展对象是否已经创建过了则直接从缓存中获取
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> T instance &lt;span style="color:#719e07">=&lt;/span> (T) extensionInstances.get(clazz);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (instance &lt;span style="color:#719e07">==&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//第一次获取缓存中肯定没有则创建扩展对象然后缓存起来
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//createExtensionInstance 这个是与自适应扩展对象创建对象的不同之处
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> extensionInstances.putIfAbsent(clazz, createExtensionInstance(clazz));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instance &lt;span style="color:#719e07">=&lt;/span> (T) extensionInstances.get(clazz);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instance &lt;span style="color:#719e07">=&lt;/span> postProcessBeforeInitialization(instance, name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注入扩展自适应方法,这个方法前面讲自适应扩展时候说了,注入自适应扩展方法的自适应扩展对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> injectExtension(instance);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instance &lt;span style="color:#719e07">=&lt;/span> postProcessAfterInitialization(instance, name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//是否开启了wrap
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//Dubbo通过Wrapper实现AOP的方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (wrap) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个可以参考下Dubbo扩展的加载
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> wrapperClassesList &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//wrap类型排序 这个wrap类型是如何来的呢,在前面扫描扩展类型的时候如果当前扩展类型不是Adaptive注解修饰的,并且当前类型type有个构造器参数是type自身的也是前面加载扩展类型时候说的装饰器模式 可以参考DubboProtocol的构造器
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (cachedWrapperClasses &lt;span style="color:#719e07">!=&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wrapperClassesList.addAll(cachedWrapperClasses);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//根据Wrapper注解的order值来进行排序值越小越在列表的前面
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> wrapperClassesList.sort(WrapperComparator.COMPARATOR);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//反转之后值越大就会在列表的前面
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> Collections.reverse(wrapperClassesList);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//从缓存中查到了wrapper扩展则遍历这些wrapp扩展进行筛选
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isNotEmpty(wrapperClassesList)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> wrapperClass : wrapperClassesList) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Wrapper wrapper &lt;span style="color:#719e07">=&lt;/span> wrapperClass.getAnnotation(Wrapper.&lt;span style="color:#719e07">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//需要包装的扩展名。当此数组为空时，默认值为匹配
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//看下当前扩展是否匹配这个wrap,如何判断呢?
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//wrapper注解不存在或者matches匹配,或者mismatches不包含当前扩展
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//如果匹配到了当前扩展对象是需要进行wrapp的就为当前扩展创建当前wrapper扩展对象进行包装
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> boolean match &lt;span style="color:#719e07">=&lt;/span> (wrapper &lt;span style="color:#719e07">==&lt;/span> null) &lt;span style="color:#719e07">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ((ArrayUtils.isEmpty(wrapper.matches()) &lt;span style="color:#719e07">||&lt;/span> ArrayUtils.contains(wrapper.matches(), name)) &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">!&lt;/span>ArrayUtils.contains(wrapper.mismatches(), name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这是扩展类型是匹配wrapp的则开始注入
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (match) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//匹配到了就创建所有的wrapper类型的对象同时构造器参数设置为当前类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> instance &lt;span style="color:#719e07">=&lt;/span> injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instance &lt;span style="color:#719e07">=&lt;/span> postProcessAfterInitialization(instance, name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Warning: After an instance of Lifecycle is wrapped by cachedWrapperClasses, it may not still be Lifecycle instance, this application may not invoke the lifecycle.initialize hook.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//初始化扩展,如果当前扩展是Lifecycle类型则调用初始化方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> initExtension(instance);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> instance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> &lt;span style="color:#268bd2">IllegalStateException&lt;/span>(&lt;span style="color:#2aa198">&amp;#34;Extension instance (name: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> name &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, class: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;)&lt;/span> couldn&amp;#39;t be instantiated: &lt;span style="color:#2aa198">&amp;#34; + t.getMessage(), t)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="612-创建扩展对象">6.1.2 创建扩展对象&lt;/h3>
&lt;p>前面加载扩展类型在自适应扩展的时候已经说过了这里就不重复了,这里我们来看下
扩展对象的创建过程:createExtensionInstance(clazz)&lt;/p>
&lt;p>前面看自适应扩展对象创建的时候自适应扩展对象仅仅是使用反射newInstance了一个扩展对象,而普通的扩展类型创建对象的过程就相对复杂一点,接下来我们来看下:&lt;/p>
&lt;p>ExtensionLoader的createExtensionInstance方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">private&lt;/span> Object &lt;span style="color:#268bd2">createExtensionInstance&lt;/span>(Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> type) &lt;span style="color:#719e07">throws&lt;/span> ReflectiveOperationException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//在ExtensionLoader构造器中,有个initInstantiationStrategy()方法中new了一个初始化策略InstantiationStrategy类型对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> instantiationStrategy.instantiate(type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>InstantiationStrategy的实例化对象方法instantiate&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> T instantiate(Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type) &lt;span style="color:#719e07">throws&lt;/span> ReflectiveOperationException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// should not use default constructor directly, maybe also has another constructor matched scope model arguments
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 1. try to get default constructor
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> Constructor&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> defaultConstructor &lt;span style="color:#719e07">=&lt;/span> null;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//反射获取对应类型的无参构造器
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> defaultConstructor &lt;span style="color:#719e07">=&lt;/span> type.getConstructor();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (NoSuchMethodException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ignore no default constructor
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 2. use matched constructor if found
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>Constructor&lt;span style="color:#719e07">&amp;gt;&lt;/span> matchedConstructors &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取所有构造器
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> Constructor&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span>[] declaredConstructors &lt;span style="color:#719e07">=&lt;/span> type.getConstructors();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//遍历构造器列表,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">for&lt;/span> (Constructor&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> constructor : declaredConstructors) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果存在构造器则构造器参数类型是否为ScopeModel类型,如果为ScopeModel则为匹配的构造器 说明我们扩展类型在这个版本如果想要让这个构造器生效必须参数类型为ScopeModel
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (isMatched(constructor)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> matchedConstructors.add(constructor);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// remove default constructor from matchedConstructors
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (defaultConstructor &lt;span style="color:#719e07">!=&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> matchedConstructors.remove(defaultConstructor);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// match order:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 1. the only matched constructor with parameters
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">// 2. default constructor if absent
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Constructor targetConstructor;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//匹配的参数ScopeModel的构造器太多了就抛出异常
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (matchedConstructors.size() &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> &lt;span style="color:#268bd2">IllegalArgumentException&lt;/span>(&lt;span style="color:#2aa198">&amp;#34;Expect only one but found &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> matchedConstructors.size() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; matched constructors for type: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> type.getName() &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;, matched constructors: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> matchedConstructors);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#268bd2">if&lt;/span> (matchedConstructors.size() &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//一个参数一般为一个参数类型ScopeModel的构造器
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> targetConstructor &lt;span style="color:#719e07">=&lt;/span> matchedConstructors.get(&lt;span style="color:#2aa198">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#268bd2">if&lt;/span> (defaultConstructor &lt;span style="color:#719e07">!=&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果没有自定义构造器则使用空参数构造器
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> targetConstructor &lt;span style="color:#719e07">=&lt;/span> defaultConstructor;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//一个构造器也没匹配上也要报错
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> &lt;span style="color:#268bd2">IllegalArgumentException&lt;/span>(&lt;span style="color:#2aa198">&amp;#34;None matched constructor was found for type: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> type.getName());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// create instance with arguments
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//反射获取构造器参数的参数类型列表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> Class[] parameterTypes &lt;span style="color:#719e07">=&lt;/span> targetConstructor.getParameterTypes();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果存在参数则为参数设置值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> Object[] args &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> Object[parameterTypes.length];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (&lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">0&lt;/span>; i &lt;span style="color:#719e07">&amp;lt;&lt;/span> parameterTypes.length; i&lt;span style="color:#719e07">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//借助scopeModelAccessor工具获取参数类型,这个参数类型为当前的域模型对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> args[i] &lt;span style="color:#719e07">=&lt;/span> getArgumentValueForType(parameterTypes[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建扩展对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> (T) targetConstructor.newInstance(args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="62-wrap机制">6.2 wrap机制&lt;/h2>
&lt;h3 id="621-wrapper机制说明">6.2.1 Wrapper机制说明&lt;/h3>
&lt;p>Dubbo通过Wrapper实现AOP的方法&lt;/p>
&lt;p>Wrapper机制，即扩展点自动包装。Wrapper 类同样实现了扩展点接口，但是 Wrapper 不是扩展点的真正实现。它的用途主要是用于从 ExtensionLoader 返回扩展点时，包装在真正的扩展点实现外。即从 ExtensionLoader 中返回的实际上是 Wrapper 类的实例，Wrapper 持有了实际的扩展点实现类。
扩展点的 Wrapper 类可以有多个，也可以根据需要新增。
通过 Wrapper 类可以把所有扩展点公共逻辑移至 Wrapper 中。新加的 Wrapper 在所有的扩展点上添加了逻辑，有些类似 AOP，即 Wrapper 代理了扩展点。&lt;/p>
&lt;p>Wrapper的规范
Wrapper 机制不是通过注解实现的，而是通过一套 Wrapper 规范实现的。
Wrapper 类在定义时需要遵循如下规范。&lt;/p>
&lt;ul>
&lt;li>该类要实现 SPI 接口&lt;/li>
&lt;li>该类中要有 SPI 接口的引用&lt;/li>
&lt;li>该类中必须含有一个含参的构造方法且参数只能有一个类型为SPI接口&lt;/li>
&lt;li>在接口实现方法中要调用 SPI 接口引用对象的相应方法&lt;/li>
&lt;li>该类名称以 Wrapper 结尾&lt;/li>
&lt;/ul>
&lt;p>比如如下几个扩展类型&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">class&lt;/span> &lt;span style="color:#268bd2">org&lt;/span>.apache.dubbo.rpc.protocol.ProtocolListenerWrapper
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">class&lt;/span> &lt;span style="color:#268bd2">org&lt;/span>.apache.dubbo.qos.protocol.QosProtocolWrapper
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">class&lt;/span> &lt;span style="color:#268bd2">org&lt;/span>.apache.dubbo.rpc.protocol.ProtocolListenerWrapper
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">class&lt;/span> &lt;span style="color:#268bd2">org&lt;/span>.apache.dubbo.qos.protocol.QosProtocolWrapper
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>回顾下Wrapper扩展类型的扫描于对象的创建&lt;/p>
&lt;h3 id="622-wrapper类型的扫描">6.2.2 Wrapper类型的扫描&lt;/h3>
&lt;p>&lt;strong>Wrapper类型的扫描代码如下:&lt;/strong>&lt;/p>
&lt;p>来自4.5.2.3小节ExtensionLoader类型中的loadClass方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//扩展子类型是否存在这个注解@Adaptive
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (clazz.isAnnotationPresent(Adaptive.&lt;span style="color:#719e07">class&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cacheAdaptiveClass(clazz, overridden);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#268bd2">if&lt;/span> (isWrapperClass(clazz)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//扩展子类型构造器中是否有这个类型的接口 (这个可以想象下我们了解的Java IO流中的类型使用到的装饰器模式 构造器传个类型)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> cacheWrapperClass(clazz);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>isWrapperClass方法通过判断构造器类型是否为当前类型来判断是否为Wrapper类型&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">private&lt;/span> boolean &lt;span style="color:#268bd2">isWrapperClass&lt;/span>(Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> clazz) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clazz.getConstructor(type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#b58900">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (NoSuchMethodException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#b58900">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="623-wrapper类型的创建">6.2.3 Wrapper类型的创建&lt;/h3>
&lt;p>这个可以看下4.6.1 getExtension方法源码的获取扩展对象时候查询扩展对象是否有对应的Wrapper类型的扩展为其创建Wrapper扩展对象,如下代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//Dubbo通过Wrapper实现AOP的方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (wrap) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个可以参考下Dubbo扩展的加载
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> wrapperClassesList &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//wrap类型排序 这个wrap类型是如何来的呢,在前面扫描扩展类型的时候如果当前扩展类型不是Adaptive注解修饰的,并且当前类型type有个构造器参数是type自身的也是前面加载扩展类型时候说的装饰器模式 可以参考DubboProtocol的构造器
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (cachedWrapperClasses &lt;span style="color:#719e07">!=&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wrapperClassesList.addAll(cachedWrapperClasses);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//根据Wrapper注解的order值来进行排序值越小越在列表的前面
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> wrapperClassesList.sort(WrapperComparator.COMPARATOR);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//反转之后值越大就会在列表的前面
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> Collections.reverse(wrapperClassesList);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//从缓存中查到了wrapper扩展则遍历这些wrapp扩展进行筛选
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isNotEmpty(wrapperClassesList)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> wrapperClass : wrapperClassesList) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Wrapper wrapper &lt;span style="color:#719e07">=&lt;/span> wrapperClass.getAnnotation(Wrapper.&lt;span style="color:#719e07">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//需要包装的扩展名。当此数组为空时，默认值为匹配
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//看下当前扩展是否匹配这个wrap,如何判断呢?
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//wrapper注解不存在或者matches匹配,或者mismatches不包含当前扩展
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//如果匹配到了当前扩展对象是需要进行wrapp的就为当前扩展创建当前wrapper扩展对象进行包装
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> boolean match &lt;span style="color:#719e07">=&lt;/span> (wrapper &lt;span style="color:#719e07">==&lt;/span> null) &lt;span style="color:#719e07">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ((ArrayUtils.isEmpty(wrapper.matches()) &lt;span style="color:#719e07">||&lt;/span> ArrayUtils.contains(wrapper.matches(), name)) &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">!&lt;/span>ArrayUtils.contains(wrapper.mismatches(), name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这是扩展类型是匹配wrapp的则开始注入
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (match) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//匹配到了就创建所有的wrapper类型的对象同时构造器参数设置为当前类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> instance &lt;span style="color:#719e07">=&lt;/span> injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instance &lt;span style="color:#719e07">=&lt;/span> postProcessAfterInitialization(instance, name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>主要来看下什么情况下才为当前扩展类型创建Wrapper包装类型:&lt;/p>
&lt;ul>
&lt;li>wrapper注解不存在(前面判断过Wrapper类型是构造器满足条件的)&lt;/li>
&lt;li>存在Wrapper注解:
&lt;ul>
&lt;li>matches匹配,&lt;/li>
&lt;li>或者mismatches不包含当前扩展&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>如果匹配到了当前扩展对象是需要进行wrapp的就为当前扩展创建当前wrapper扩展对象进行包装&lt;/p>
&lt;p>原文： &lt;a href="https://blog.elastic.link/2022/07/10/dubbo/6-dubbo-de-spi-kuo-zhan-ji-zhi-zhi-pu-tong-kuo-zhan-dui-xiang-de-chuang-jian-yu-wrapper-ji-zhi-de-yuan-ma-jie-xi/">《Dubbo的SPI扩展机制之普通扩展对象的创建与Wrapper机制的源码解析》&lt;/a>&lt;/p></description></item><item><title>Blog: 05-自适应扩展对象的创建getAdaptiveExtension方法</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/05/05-%E8%87%AA%E9%80%82%E5%BA%94%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BAgetadaptiveextension%E6%96%B9%E6%B3%95/</link><pubDate>Fri, 05 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/05/05-%E8%87%AA%E9%80%82%E5%BA%94%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BAgetadaptiveextension%E6%96%B9%E6%B3%95/</guid><description>
&lt;h2 id="5-自适应扩展对象的创建getadaptiveextension方法">5 自适应扩展对象的创建getAdaptiveExtension方法&lt;/h2>
&lt;p>自适应扩展又称为动态扩展,可以在运行时生成扩展对象&lt;/p>
&lt;p>ExtensionLoader中的getAdaptiveExtension()方法,这个方法也是我们看到的第一个获取扩展对象的方法. ,这个方法可以帮助我们通过SPI机制从扩展文件中找到需要的扩展类型并创建它的对象,
&lt;strong>自适应扩展:&lt;strong>如果对设计模式比较了解的可能会联想到&lt;/strong>适配器模式&lt;/strong>,自适应扩展其实就是适配器模式的思路,自适应扩展有两种策略:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一种是我们自己实现自适应扩展:然后使用@Adaptive修饰这个时候适配器的逻辑由我们自己实现,当扩展加载器去查找具体的扩展的时候可以通过找到我们这个对应的适配器扩展,然后适配器扩展帮忙去查询真正的扩展,这个比如我们下面要举的扩展注入器的例子,具体扩展通过扩展注入器适配器,注入器适配器来查询具体的注入器扩展实现来帮忙查找扩展。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>还有一种方式是我们未实现这个自适应扩展,Dubbo在运行时通过字节码动态代理的方式在运行时生成一个适配器,使用这个适配器映射到具体的扩展. 第二种情况往往用在比如 Protocol、Cluster、LoadBalance 等。有时，有些拓展并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载。(如果还不了解可以考虑看下@Adaptive注解加载方法上面的时候扩展是如何加载的)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> T &lt;span style="color:#268bd2">getAdaptiveExtension&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//检查当前扩展加载器是否已经被销毁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkDestroyed();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//从自适应扩展缓存中查询扩展对象如果存在就直接返回,这个自适应扩展类型只会有一个扩展实现类型如果是多个的话根据是否可以覆盖参数决定扩展实现类是否可以相互覆盖&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object instance &lt;span style="color:#719e07">=&lt;/span> cachedAdaptiveInstance.get();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个if判断不太优雅 容易多层嵌套,上面instance不为空就可以直接返回了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (instance &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建异常则抛出异常直接返回(多线程场景下可能第一个线程异常了第二个线程进来之后走到这里)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (createAdaptiveInstanceError &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;Failed to create adaptive instance: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> createAdaptiveInstanceError.toString(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> createAdaptiveInstanceError);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加锁排队 (单例模式创建对象的思想 双重校验锁)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (cachedAdaptiveInstance) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加锁的时候对象都是空的,进来之后先判断下防止重复创建&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instance &lt;span style="color:#719e07">=&lt;/span> cachedAdaptiveInstance.get();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//只有第一个进来锁的对象为空开始创建扩展对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (instance &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//根据SPI机制获取类型,创建对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instance &lt;span style="color:#719e07">=&lt;/span> createAdaptiveExtension();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//存入缓存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cachedAdaptiveInstance.set(instance);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> createAdaptiveInstanceError &lt;span style="color:#719e07">=&lt;/span> t;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;Failed to create adaptive instance: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> t.toString(), t);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> (T) instance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前面使用单例思想来调用创建自适应扩展对象的方法,下面就让我们深入探究下创建自适应扩展对象的整个过程createAdaptiveExtension();方法:&lt;/p>
&lt;h2 id="51-创建扩展对象的生命周期方法-注意这个后续会详细解析这个声明周期方法的细节">5.1 创建扩展对象的生命周期方法-注意这个后续会详细解析这个声明周期方法的细节&lt;/h2>
&lt;p>createAdaptiveExtension()
我们先来看ExtensionLoader类型中的createAdaptiveExtension();方法,这个方法包含了扩展对象创建初始化的整个生命周期,如下代码所示:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> T &lt;span style="color:#268bd2">createAdaptiveExtension&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取扩展类型实现类, 创建扩展对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T instance &lt;span style="color:#719e07">=&lt;/span> (T) getAdaptiveExtensionClass().newInstance();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注入扩展对象之前的回调方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instance &lt;span style="color:#719e07">=&lt;/span> postProcessBeforeInitialization(instance, &lt;span style="color:#cb4b16">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注入扩展对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instance &lt;span style="color:#719e07">=&lt;/span> injectExtension(instance);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注入扩展对象之后的回调方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instance &lt;span style="color:#719e07">=&lt;/span> postProcessAfterInitialization(instance, &lt;span style="color:#cb4b16">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化扩展对象的属性,如果当前扩展实例的类型实现了Lifecycle则调用当前扩展对象的生命周期回调方法initialize()(来自Lifecycle接口)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//参考样例第一个instance为ExtensionInjector的自适应扩展对象类型为AdaptiveExtensionInjector,自适应扩展注入器(适配器)用来查询具体支持的扩展注入器比如scope,spi,spring注入器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initExtension(instance);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> instance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;Can&amp;#39;t create adaptive extension &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> type &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, cause: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> e.getMessage(), e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="52-spi机制获取扩展对象实现类型getadaptiveextensionclass">5.2 SPI机制获取扩展对象实现类型getAdaptiveExtensionClass()&lt;/h2>
&lt;p>这个方法可以帮助我们了解具体的Dubbo SPI机制 如果找到扩展类型的实现类,会寻找哪些文件,扩展文件的优先级又是什么,对我们自己写扩展方法很有帮助,接下来我们就来看下它的源码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> getAdaptiveExtensionClass() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取扩展类型,将扩展类型存入成员变量cachedClasses中进行缓存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getExtensionClasses();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//在上个方法的详细解析中的最后一步loadClass方法中如果扩展类型存在Adaptive注解将会将扩展类型赋值给cachedAdaptiveClass,否则的话会把扩展类型都缓存起来存储在扩展集合extensionClasses中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (cachedAdaptiveClass &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> cachedAdaptiveClass;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//扩展实现类型没有一个这个自适应注解Adaptive时候会走到这里&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//刚刚我们扫描到了扩展类型然后将其存入cachedClasses集合中了 接下来我们看下如何创建扩展类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> cachedAdaptiveClass &lt;span style="color:#719e07">=&lt;/span> createAdaptiveExtensionClass();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>继续看获取扩展类型的方法&lt;strong>getExtensionClasses()&lt;/strong>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> getExtensionClasses() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//缓存中查询扩展类型是否存在&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> classes &lt;span style="color:#719e07">=&lt;/span> cachedClasses.get();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (classes &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//单例模式双重校验锁判断&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (cachedClasses) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> classes &lt;span style="color:#719e07">=&lt;/span> cachedClasses.get();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (classes &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加载扩展类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> classes &lt;span style="color:#719e07">=&lt;/span> loadExtensionClasses();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将我们扫描到的扩展类型存入成员变量cachedClasses中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cachedClasses.set(classes);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> classes;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="521-使用不同的的策略加载加载不同目录下的扩展">5.2.1 使用不同的的策略加载加载不同目录下的扩展&lt;/h3>
&lt;p>加载扩展类型的方法&lt;strong>loadExtensionClasses()&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">private&lt;/span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> loadExtensionClasses() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//检查扩展加载器是否被销毁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> checkDestroyed();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//缓存默认的扩展名到成员变量cachedDefaultName中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> cacheDefaultExtensionName();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加载到的扩展集合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> extensionClasses &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> HashMap&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//扩展策略,在4.3章节中我们介绍了这个类型的UML与说明
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//LoadingStrategy扩展加载策略,目前有3个扩展加载策略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//DubboInternalLoadingStrategy:Dubbo内置的扩展加载策略,将加载文件目录为META-INF/dubbo/internal/的扩展
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//DubboLoadingStrategy:Dubbo普通的扩展加载策略,将加载目录为META-INF/dubbo/的扩展
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//ServicesLoadingStrategy:JAVA SPI加载策略 ,将加载目录为META-INF/services/的扩展
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//扩展策略集合对象在什么时候初始化的呢在成员变量初始化的时候就创建了集合对象,这个可以看方法loadLoadingStrategies() 通过Java的 SPI加载策略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">for&lt;/span> (LoadingStrategy strategy : strategies) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//根据策略从指定文件目录中加载扩展类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> loadDirectory(extensionClasses, strategy, type.getName());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// compatible with old ExtensionFactory
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//如果当前要加载的扩展类型是扩展注入类型则扫描下ExtensionFactory类型的扩展
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">this&lt;/span>.type &lt;span style="color:#719e07">==&lt;/span> ExtensionInjector.&lt;span style="color:#719e07">class&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个方法和上面那个方法是一样的就不详细说了 扫描文件 找到扩展类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> loadDirectory(extensionClasses, strategy, ExtensionFactory.&lt;span style="color:#719e07">class&lt;/span>.&lt;span style="color:#268bd2">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//通过loadDirectory扫描 扫描到了ExtensionInjector类型的扩展实现类有3个 我们将会得到这样一个集合例子:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//&amp;#34;spring&amp;#34; -&amp;gt; &amp;#34;class org.apache.dubbo.config.spring.extension.SpringExtensionInjector&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//&amp;#34;scopeBean&amp;#34; -&amp;gt; &amp;#34;class org.apache.dubbo.common.beans.ScopeBeanExtensionInjector&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//&amp;#34;spi&amp;#34; -&amp;gt; &amp;#34;class org.apache.dubbo.common.extension.inject.SpiExtensionInjector&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> extensionClasses;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从文件中加载扩展实现loadDirectory方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">loadDirectory&lt;/span>(Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> extensionClasses, LoadingStrategy strategy, String type) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加载并根据策略的参数来加载&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadDirectory(extensionClasses, strategy.directory(), type, strategy.preferExtensionClassLoader(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> strategy.overridden(), strategy.includedPackages(), strategy.excludedPackages(), strategy.onlyExtensionClassLoaderPackages());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//下面两行就是要兼容alibaba的扩展包了 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String oldType &lt;span style="color:#719e07">=&lt;/span> type.replace(&lt;span style="color:#2aa198">&amp;#34;org.apache&amp;#34;&lt;/span>, &lt;span style="color:#2aa198">&amp;#34;com.alibaba&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadDirectory(extensionClasses, strategy.directory(), oldType, strategy.preferExtensionClassLoader(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> strategy.overridden(), strategy.includedPackagesInCompatibleType(), strategy.excludedPackages(), strategy.onlyExtensionClassLoaderPackages());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>带扩展策略参数的loadDirectory方法&lt;/p>
&lt;p>关于扩展策略的参数列表我这里列个表格方便大家来看&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>扩展类型&lt;/th>
&lt;th>dir(目录)&lt;/th>
&lt;th>extensionLoaderClassLoaderFirst(优先扩展类型的类加载器)&lt;/th>
&lt;th>overridden(是否允许覆盖同名扩展)&lt;/th>
&lt;th>includedPackages (明确包含的扩展包)&lt;/th>
&lt;th>excludedPackages (明确排除的扩展包)&lt;/th>
&lt;th>onlyExtensionClassLoaderPackages(限制应该从Dubbo的类加载器加载的类)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>DubboInternalLoadingStrategy&lt;/td>
&lt;td>META-INF/dubbo/internal/&lt;/td>
&lt;td>false&lt;/td>
&lt;td>false&lt;/td>
&lt;td>null&lt;/td>
&lt;td>null&lt;/td>
&lt;td>[]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DubboLoadingStrategy&lt;/td>
&lt;td>META-INF/dubbo/&lt;/td>
&lt;td>false&lt;/td>
&lt;td>true&lt;/td>
&lt;td>null&lt;/td>
&lt;td>null&lt;/td>
&lt;td>[]&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ServicesLoadingStrategy&lt;/td>
&lt;td>META-INF/services/&lt;/td>
&lt;td>false&lt;/td>
&lt;td>true&lt;/td>
&lt;td>null&lt;/td>
&lt;td>null&lt;/td>
&lt;td>[]&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * 不同的扩展策略传递了不同的参数,但是扩展的加载流程是相同的,这里我们可以参考上面表格
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param extensionClasses
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param dir
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param type 这里我们参考的示例这个值为org.apache.dubbo.common.extension.ExtensionInjector
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param extensionLoaderClassLoaderFirst
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param overridden false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param includedPackages
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param excludedPackages
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param onlyExtensionClassLoaderPackages
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">loadDirectory&lt;/span>(Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> extensionClasses, String dir, String type,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">boolean&lt;/span> extensionLoaderClassLoaderFirst, &lt;span style="color:#dc322f">boolean&lt;/span> overridden, String&lt;span style="color:#719e07">[]&lt;/span> includedPackages,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#719e07">[]&lt;/span> excludedPackages, String&lt;span style="color:#719e07">[]&lt;/span> onlyExtensionClassLoaderPackages) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//扩展目录 + 扩展类型全路径 比如: META-INF/dubbo/internal/org.apache.dubbo.common.extension.ExtensionInjector&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String fileName &lt;span style="color:#719e07">=&lt;/span> dir &lt;span style="color:#719e07">+&lt;/span> type;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>ClassLoader&lt;span style="color:#719e07">&amp;gt;&lt;/span> classLoadersToLoad &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> LinkedList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// try to load from ExtensionLoader&amp;#39;s ClassLoader first&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//是否优先使用扩展加载器的 类加载器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (extensionLoaderClassLoaderFirst) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ClassLoader extensionLoaderClassLoader &lt;span style="color:#719e07">=&lt;/span> ExtensionLoader.class.getClassLoader();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (ClassLoader.getSystemClassLoader() &lt;span style="color:#719e07">!=&lt;/span> extensionLoaderClassLoader) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> classLoadersToLoad.add(extensionLoaderClassLoader);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// load from scope model&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取域模型对象的类型加载器 ,这个域模型对象在初始化的时候会将自己的类加载器放入集合中可以参考《3.2.2 初始化ScopeModel》章节&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>ClassLoader&lt;span style="color:#719e07">&amp;gt;&lt;/span> classLoaders &lt;span style="color:#719e07">=&lt;/span> scopeModel.getClassLoaders();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//没有可用的类加载器则从使用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isEmpty(classLoaders)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//从用于加载类的搜索路径中查找指定名称的所有资源。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Enumeration&lt;span style="color:#719e07">&amp;lt;&lt;/span>java.net.URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> resources &lt;span style="color:#719e07">=&lt;/span> ClassLoader.getSystemResources(fileName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (resources &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">while&lt;/span> (resources.hasMoreElements()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadResource(extensionClasses, &lt;span style="color:#cb4b16">null&lt;/span>, resources.nextElement(), overridden, includedPackages, excludedPackages, onlyExtensionClassLoaderPackages);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> classLoadersToLoad.addAll(classLoaders);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//使用类加载资源加载器(ClassLoaderResourceLoader)来加载具体的资源&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>ClassLoader, Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>java.net.URL&lt;span style="color:#719e07">&amp;gt;&amp;gt;&lt;/span> resources &lt;span style="color:#719e07">=&lt;/span> ClassLoaderResourceLoader.loadResources(fileName, classLoadersToLoad);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//遍历从所有资源文件中读取到资源url地址,key为类加载器,值为扩展文件url如夏所示&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//jar:file:/Users/song/.m2/repository/org/apache/dubbo/dubbo/3.0.7/dubbo-3.0.7.jar!/META-INF/dubbo/internal/org.apache.dubbo.common.extension.ExtensionInjector&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resources.forEach(((classLoader, urls) &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//从文件中加载完资源之后开始根据类加载器和url加载具体的扩展类型,最后将扩展存放进extensionClasses集合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadFromClass(extensionClasses, overridden, urls, classLoader, includedPackages, excludedPackages, onlyExtensionClassLoaderPackages);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(&lt;span style="color:#2aa198">&amp;#34;Exception occurred when loading extension class (interface: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, description file: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> fileName &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;).&amp;#34;&lt;/span>, t);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="522-借助类加载器的getresources方法遍历所有文件进行扩展文件的查询">5.2.2 借助类加载器的getResources方法遍历所有文件进行扩展文件的查询&lt;/h3>
&lt;p>查找扩展类型对应的扩展文件的url方法:ClassLoaderResourceLoader类型的loadResources源码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">public&lt;/span> &lt;span style="color:#719e07">static&lt;/span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>ClassLoader, Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&amp;gt;&lt;/span> loadResources(String fileName, List&lt;span style="color:#719e07">&amp;lt;&lt;/span>ClassLoader&lt;span style="color:#719e07">&amp;gt;&lt;/span> classLoaders) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>ClassLoader, Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&amp;gt;&lt;/span> resources &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ConcurrentHashMap&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//不同的类加载器之间使用不同的线程异步的方式进行扫描
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> CountDownLatch countDownLatch &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> CountDownLatch(classLoaders.size());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (ClassLoader classLoader : classLoaders) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//多线程扫描,这个是个newCachedThreadPool的类型的线程池
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> GlobalResourcesRepository.getGlobalExecutorService().submit(() &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> resources.put(classLoader, loadResources(fileName, classLoader));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> countDownLatch.countDown();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> countDownLatch.await();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (InterruptedException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e.printStackTrace();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> Collections.unmodifiableMap(&lt;span style="color:#719e07">new&lt;/span> LinkedHashMap&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(resources));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>加载具体类加载器中的资源文件的loadResources方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">public&lt;/span> &lt;span style="color:#719e07">static&lt;/span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> loadResources(String fileName, ClassLoader currentClassLoader) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>ClassLoader, Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&amp;gt;&amp;gt;&lt;/span> classLoaderCache;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//第一次进来类加载器资源缓存是空的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (classLoaderResourcesCache &lt;span style="color:#719e07">==&lt;/span> null &lt;span style="color:#719e07">||&lt;/span> (classLoaderCache &lt;span style="color:#719e07">=&lt;/span> classLoaderResourcesCache.get()) &lt;span style="color:#719e07">==&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//类对象锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> synchronized (ClassLoaderResourceLoader.&lt;span style="color:#719e07">class&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (classLoaderResourcesCache &lt;span style="color:#719e07">==&lt;/span> null &lt;span style="color:#719e07">||&lt;/span> (classLoaderCache &lt;span style="color:#719e07">=&lt;/span> classLoaderResourcesCache.get()) &lt;span style="color:#719e07">==&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> classLoaderCache &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ConcurrentHashMap&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建一个类资源映射url的软引用缓存对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//软引用(soft references)，用于帮助垃圾收集器管理内存使用和消除潜在的内存泄漏。当内存快要不足的时候，GC会迅速的把所有的软引用清除掉，释放内存空间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> classLoaderResourcesCache &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> SoftReference&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(classLoaderCache);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//第一次进来时候类加载器url映射缓存是空的,给类加载器缓存对象新增一个值,key是类加载器,值是map类型用来存储文件名对应的url集合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>classLoaderCache.containsKey(currentClassLoader)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> classLoaderCache.putIfAbsent(currentClassLoader, &lt;span style="color:#719e07">new&lt;/span> ConcurrentHashMap&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&amp;gt;&lt;/span> urlCache &lt;span style="color:#719e07">=&lt;/span> classLoaderCache.get(currentClassLoader);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//缓存中没有就从文件里面找
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>urlCache.containsKey(fileName)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> set &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> LinkedHashSet&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Enumeration&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> urls;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//getResources这个方法是这样的:加载当前类加载器以及父类加载器所在路径的资源文件,将遇到的所有资源文件全部返回！这个可以理解为使用双亲委派模型中的类加载器 加载各个位置的资源文件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> urls &lt;span style="color:#719e07">=&lt;/span> currentClassLoader.getResources(fileName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//native配置 是否为本地镜像(k可以参考官方文档:https://dubbo.apache.org/zh-cn/docs/references/graalvm/support-graalvm/
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> boolean isNative &lt;span style="color:#719e07">=&lt;/span> NativeUtils.isNative();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (urls &lt;span style="color:#719e07">!=&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//遍历找到的对应扩展的文件url将其加入集合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">while&lt;/span> (urls.hasMoreElements()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL url &lt;span style="color:#719e07">=&lt;/span> urls.nextElement();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (isNative) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//In native mode, the address of each URL is the same instead of different paths, so it is necessary to set the ref to make it different
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//动态修改jdk底层url对象的ref变量为可访问,让我们在用反射时访问私有变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> setRef(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> set.add(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (IOException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e.printStackTrace();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//存入缓存
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> urlCache.put(fileName, set);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//返回结果
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> urlCache.get(fileName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="523-使用找到的扩展资源url加载具体扩展类型到内存">5.2.3 使用找到的扩展资源url加载具体扩展类型到内存&lt;/h3>
&lt;p>ExtensionLoader类型中的loadFromClass方法 遍历url 开始加载扩展类型&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">loadFromClass&lt;/span>(Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> extensionClasses, &lt;span style="color:#dc322f">boolean&lt;/span> overridden, Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>java.net.URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> urls, ClassLoader classLoader,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#719e07">[]&lt;/span> includedPackages, String&lt;span style="color:#719e07">[]&lt;/span> excludedPackages, String&lt;span style="color:#719e07">[]&lt;/span> onlyExtensionClassLoaderPackages) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isNotEmpty(urls)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (java.net.URL url : urls) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadResource(extensionClasses, classLoader, url, overridden, includedPackages, excludedPackages, onlyExtensionClassLoaderPackages);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ExtensionLoader类型中的loadResource方法 使用IO流读取扩展文件的内容
读取内容之前我这里先贴一下我们参考的扩展注入类型的文件中的内容如下所示:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>adaptive&lt;span style="color:#719e07">=&lt;/span>org.apache.dubbo.common.extension.inject.AdaptiveExtensionInjector
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spi&lt;span style="color:#719e07">=&lt;/span>org.apache.dubbo.common.extension.inject.SpiExtensionInjector
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scopeBean&lt;span style="color:#719e07">=&lt;/span>org.apache.dubbo.common.beans.ScopeBeanExtensionInjector
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>扩展中的文件都是一行一行的,并且扩展名字和扩展类型之间使用等号隔开=
了解了文件内容之后 应该下面的代码大致思路就知道了,我们可以详细看下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">loadResource&lt;/span>(Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> extensionClasses, ClassLoader classLoader,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> java.net.URL resourceURL, &lt;span style="color:#dc322f">boolean&lt;/span> overridden, String&lt;span style="color:#719e07">[]&lt;/span> includedPackages, String&lt;span style="color:#719e07">[]&lt;/span> excludedPackages, String&lt;span style="color:#719e07">[]&lt;/span> onlyExtensionClassLoaderPackages) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里固定了文件的格式为utf8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> (BufferedReader reader &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> BufferedReader(&lt;span style="color:#719e07">new&lt;/span> InputStreamReader(resourceURL.openStream(), StandardCharsets.UTF_8))) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String line;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String clazz;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//按行读取 例如读取到的内容:spring=org.apache.dubbo.config.spring.extension.SpringExtensionInjector&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">while&lt;/span> ((line &lt;span style="color:#719e07">=&lt;/span> reader.readLine()) &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//不知道为何会有这么一行代码删除#之后的字符串&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">final&lt;/span> &lt;span style="color:#dc322f">int&lt;/span> ci &lt;span style="color:#719e07">=&lt;/span> line.indexOf(&lt;span style="color:#2aa198">&amp;#39;#&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (ci &lt;span style="color:#719e07">&amp;gt;=&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> line &lt;span style="color:#719e07">=&lt;/span> line.substring(0, ci);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> line &lt;span style="color:#719e07">=&lt;/span> line.trim();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (line.length() &lt;span style="color:#719e07">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String name &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//扩展文件可能如上面我贴的那样 名字和类型等号隔开,也可能是无类型的,例如扩展加载策略使用的是JDK自带的方式services内容中只包含具体的扩展类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> i &lt;span style="color:#719e07">=&lt;/span> line.indexOf(&lt;span style="color:#2aa198">&amp;#39;=&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (i &lt;span style="color:#719e07">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name &lt;span style="color:#719e07">=&lt;/span> line.substring(0, i).trim();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clazz &lt;span style="color:#719e07">=&lt;/span> line.substring(i &lt;span style="color:#719e07">+&lt;/span> 1).trim();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clazz &lt;span style="color:#719e07">=&lt;/span> line;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//isExcluded是否为加载策略要排除的配置,参数这里为空代表全部类型不排除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//isIncluded是否为加载策略包含的类型,参数这里为空代表全部文件皆可包含 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//onlyExtensionClassLoaderPackages参数是否只有扩展类的类加载器可以加载扩展,其他扩展类型的类加载器不能加载扩展 这里结果为false 不排除任何类加载器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isNotEmpty(clazz) &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>isExcluded(clazz, excludedPackages) &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> isIncluded(clazz, includedPackages)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>isExcludedByClassLoader(clazz, classLoader, onlyExtensionClassLoaderPackages)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//根据类全路径加载类到内存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadClass(extensionClasses, resourceURL, Class.forName(clazz, &lt;span style="color:#cb4b16">true&lt;/span>, classLoader), name, overridden);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IllegalStateException e &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;Failed to load extension class (interface: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> type &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;, class line: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> line &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;) in &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> resourceURL &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, cause: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> t.getMessage(), t);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exceptions.put(line, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(&lt;span style="color:#2aa198">&amp;#34;Exception occurred when loading extension class (interface: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, class file: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> resourceURL &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;) in &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> resourceURL, t);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ExtensionLoader类型中的loadClass方法加载具体的类到内存&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">loadClass&lt;/span>(Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> extensionClasses, java.net.URL resourceURL, Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> clazz, String name,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">boolean&lt;/span> overridden) &lt;span style="color:#268bd2">throws&lt;/span> NoSuchMethodException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//当前clazz是否为type的子类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里第一次访问到的type是ExtensionInjector,clazz是SpringExtensionInjector 父子类型关系满足情况&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>type.isAssignableFrom(clazz)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;Error occurred when loading extension class (interface: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, class line: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> clazz.getName() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;), class &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">+&lt;/span> clazz.getName() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; is not subtype of interface.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//扩展子类型是否存在这个注解@Adaptive&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (clazz.isAnnotationPresent(Adaptive.class)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cacheAdaptiveClass(clazz, overridden);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (isWrapperClass(clazz)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//扩展子类型构造器中是否有这个类型的接口 (这个可以想象下我们了解的Java IO流中的类型使用到的装饰器模式 构造器传个类型)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cacheWrapperClass(clazz);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//无自适应注解,也没有构造器是扩展类型参数 ,这个name我们在扩展文件中找到了就是等号前面那个&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isEmpty(name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//低版本中可以使用@Extension 扩展注解来标注扩展类型,这里获取注解有两个渠道:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//先查询@Extension注解是否存在如果存在则取value值,如果不存在@Extension注解则获取当前类型的名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name &lt;span style="color:#719e07">=&lt;/span> findAnnotationName(clazz);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (name.length() &lt;span style="color:#719e07">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;No such extension name for the class &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> clazz.getName() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; in the config &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> resourceURL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取扩展名字数组,扩展名字可能为逗号隔开的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#719e07">[]&lt;/span> names &lt;span style="color:#719e07">=&lt;/span> NAME_SEPARATOR.split(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (ArrayUtils.isNotEmpty(names)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//@Activate注解修饰的扩展&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cacheActivateClass(clazz, names&lt;span style="color:#719e07">[&lt;/span>0&lt;span style="color:#719e07">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (String n : names) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//cachedNames缓存集合缓存当前扩展类型的扩展名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cacheName(clazz, n);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将扩展类型加入结果集合extensionClasses中,不允许覆盖的话出现同同名字扩展将抛出异常&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> saveInExtensionClass(extensionClasses, clazz, n, overridden);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ExtensionLoader类型中cacheAdaptiveClass
Adaptive 机制，即扩展类的自适应机制。即其可以指定想要加载的扩展名，也可以不指定。若不指定，则直接加载默认的扩展类。即其会自动匹配，做到自适应。其是通过@Adaptive注解实现的。
自适应注解修饰的扩展同一个扩展名字只能有一个扩展实现类型, 扩展策略中提供的参数overridden是否允许覆盖扩展覆盖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">cacheAdaptiveClass&lt;/span>(Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> clazz, &lt;span style="color:#dc322f">boolean&lt;/span> overridden) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (cachedAdaptiveClass &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">||&lt;/span> overridden) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//成员变量存储这个自适应扩展类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cachedAdaptiveClass &lt;span style="color:#719e07">=&lt;/span> clazz;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>cachedAdaptiveClass.equals(clazz)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;More than 1 adaptive class found: &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">+&lt;/span> cachedAdaptiveClass.getName()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> clazz.getName());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ExtensionLoader类型中cacheWrapperClass
Wrapper 机制，即扩展类的包装机制。就是对扩展类中的 SPI 接口方法进行增强，进行包装，是 AOP 思想的体现，是 Wrapper 设计模式的应用。一个 SPI 可以包含多个 Wrapper。这个也是可以同一个类型多个&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">cacheWrapperClass&lt;/span>(Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> clazz) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (cachedWrapperClasses &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cachedWrapperClasses &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ConcurrentHashSet&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//缓存这个Wrapper类型的扩展&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cachedWrapperClasses.add(clazz);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ExtensionLoader类型中cacheActivateClass
Activate用于激活扩展类的。 这个扩展类型可以出现多个比如过滤器可以同一个扩展名字多个过滤器实现,所以不需要有override判断
Activate 机制，即扩展类的激活机制。通过指定的条件来激活当前的扩展类。其是通过@Activate 注解实现的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">cacheActivateClass&lt;/span>(Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> clazz, String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Activate activate &lt;span style="color:#719e07">=&lt;/span> clazz.getAnnotation(Activate.&lt;span style="color:#719e07">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (activate &lt;span style="color:#719e07">!=&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//缓存Activate类型的扩展
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> cachedActivates.put(name, activate);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// support com.alibaba.dubbo.common.extension.Activate
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> com.alibaba.dubbo.common.extension.Activate oldActivate &lt;span style="color:#719e07">=&lt;/span> clazz.getAnnotation(com.alibaba.dubbo.common.extension.Activate.&lt;span style="color:#719e07">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (oldActivate &lt;span style="color:#719e07">!=&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cachedActivates.put(name, oldActivate);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ExtensionLoader类型中的saveInExtensionClass方法&lt;/p>
&lt;p>上面扩展对象加载了这么多最终的目的就是将这个扩展类型存放进结果集合extensionClasses中,扩展策略中提供的参数overridden是否允许覆盖扩展覆盖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">saveInExtensionClass&lt;/span>(Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> extensionClasses, Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> clazz, String name, boolean overridden) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> c &lt;span style="color:#719e07">=&lt;/span> extensionClasses.get(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (c &lt;span style="color:#719e07">==&lt;/span> null &lt;span style="color:#719e07">||&lt;/span> overridden) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//上面扩展对象加载了这么多最终的目的就是将这个扩展类型存放进结果集合中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> extensionClasses.put(name, clazz);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (c &lt;span style="color:#719e07">!=&lt;/span> clazz) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// duplicate implementation is unacceptable
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> unacceptableExceptions.add(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String duplicateMsg &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Duplicate extension &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> type.getName() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; name &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> name &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; on &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> c.getName() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; and &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> clazz.getName();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(duplicateMsg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(duplicateMsg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="53-自适应扩展代理对象的代码生成与编译">5.3 自适应扩展代理对象的代码生成与编译&lt;/h2>
&lt;h3 id="531-自适应扩展对象的创建">5.3.1 自适应扩展对象的创建&lt;/h3>
&lt;p>Dubbo 的&lt;strong>自适应扩展机制&lt;/strong>中如果 &lt;strong>自己生成了自适应扩展的代理类&lt;/strong>&lt;/p>
&lt;p>Dubbo 的自适应扩展为了做什么：&lt;strong>在运行时动态调用扩展方法&lt;/strong>。以及怎么做的：生成扩展代理类。比如: 代理类中根据 URL 获取扩展名，使用 SPI 加载扩展类，并调用同名方法，返回执行结果。&lt;/p>
&lt;p>看了上一个章节,我们了解到了Dubbo是如何通过扫描目录来查询扩展实现类的这一次我们看下扩展类我们找到了之后,如果这个扩展类型未加上这个@Adaptive注解那么是如何创建这个类型的,接下来看createAdaptiveExtensionClass方法,这个方法是借助字节码工具来动态生成所需要的扩展类型的包装类型的代码,这个代码在编译时我们可能看不到,但是在Debug的时候,我们还是可以看到这个对象名字的,但是往往Debug的时候又进不到具体的代码位置,这里可以注意下&lt;/p>
&lt;p>当扩展点的方法被@Adaptive修饰时，在Dubbo初始化扩展点时会自动生成和编译一个动态的Adaptive类。&lt;/p>
&lt;p>下面我们可以以interface org.apache.dubbo.rpc.Protocol 这个协议扩展类型来看 协议扩展类型目前没有一个是带有自适应注解的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> createAdaptiveExtensionClass() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Adaptive Classes&amp;#39; ClassLoader should be the same with Real SPI interface classes&amp;#39; ClassLoader&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取加载器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ClassLoader classLoader &lt;span style="color:#719e07">=&lt;/span> type.getClassLoader();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// //native配置 是否为本地镜像(可以参考官方文档:https://dubbo.apache.org/zh-cn/docs/references/graalvm/support-graalv&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (NativeUtils.isNative()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> classLoader.loadClass(type.getName() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;$Adaptive&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable ignore) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建一个代码生成器,来生成代码 详细内容我们就下一章来看&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String code &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> AdaptiveClassCodeGenerator(type, cachedDefaultName).generate();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取编译器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> org.apache.dubbo.common.compiler.Compiler compiler &lt;span style="color:#719e07">=&lt;/span> extensionDirector.getExtensionLoader(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//生成的代码进行编译&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> compiler.compile(type, code, classLoader);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="54-为扩展对象的set方法注入自适应扩展对象">5.4 为扩展对象的set方法注入自适应扩展对象&lt;/h2>
&lt;p>在4.4.5小节中我们已经讲解了获取扩展类型实现类, 创建扩展对象&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> T instance &lt;span style="color:#719e07">=&lt;/span> (T) getAdaptiveExtensionClass().newInstance();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来就让我们来看下为扩展对象的set方法注入自适应的扩展对象
调用方法代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//注入扩展对象之前的回调方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>injectExtension(instance);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ExtensionLoader类型的injectExtension方法具体代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">private&lt;/span> T &lt;span style="color:#268bd2">injectExtension&lt;/span>(T instance) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果注入器为空则直接返回当前对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (injector &lt;span style="color:#719e07">==&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> instance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取当前对象的当前类的所有方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">for&lt;/span> (Method method : instance.getClass().getMethods()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//是否为set方法 不是的话则跳过,在这里合法的set方法满足3个条件:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//set开头,参数只有一个,public修饰
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>isSetter(method)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * Check {@link DisableInject} to see if we need auto injection for this property
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//方法上面是否有注解DisableInject修饰,这种情况也直接跳过
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (method.isAnnotationPresent(DisableInject.&lt;span style="color:#719e07">class&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//方法的参数如果是原生类型也跳过
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> pt &lt;span style="color:#719e07">=&lt;/span> method.getParameterTypes()[&lt;span style="color:#2aa198">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (ReflectUtils.isPrimitives(pt)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取set方法对应的成员变量如setProtocol 属性为protocol
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> String property &lt;span style="color:#719e07">=&lt;/span> getSetterProperty(method);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//根据参数类型如Protocol和属性名字如protocol获取应该注入的对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> Object object &lt;span style="color:#719e07">=&lt;/span> injector.getInstance(pt, property);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (object &lt;span style="color:#719e07">!=&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//执行对应对象和对应参数的这个方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> method.invoke(instance, object);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(&lt;span style="color:#2aa198">&amp;#34;Failed to inject via method &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> method.getName()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; of interface &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> type.getName() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> e.getMessage(), e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(e.getMessage(), e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> instance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="541-获取注入对象">5.4.1 获取注入对象&lt;/h3>
&lt;p>这里我们主要来看下如何通过注入器找到需要注入的那个对象 调用代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span> Object object &lt;span style="color:#719e07">=&lt;/span> injector.getInstance(pt, property);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在前面看注入器扩展对象的获取的时候是会获取到ExtensionInjector扩展的一个自适应扩展注入器实现类型 AdaptiveExtensionInjector,这个地方对应的getInstance也是这个扩展里面的,我们来看下它的方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> T &lt;span style="color:#268bd2">getInstance&lt;/span>(Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type, String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//遍历所有的扩展注入器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (ExtensionInjector injector : injectors) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//遍历所有的扩展注入器,如果可以获取到扩展对象则直接返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T extension &lt;span style="color:#719e07">=&lt;/span> injector.getInstance(type, name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (extension &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> extension;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到上面代码按扩展注入器顺序来遍历的第一个找到的对象就直接返回了,&lt;/p>
&lt;p>这个AdaptiveExtensionInjector在初始化的时候会获取所有的ExtensionInjector的扩展,非自适应的,它本身自适应的扩展,这里会获取非自适应的扩展列表一共有3个按顺序为:&lt;/p>
&lt;ul>
&lt;li>ScopeBeanExtensionInjector&lt;/li>
&lt;li>SpiExtensionInjector&lt;/li>
&lt;li>SpringExtensionInjector&lt;/li>
&lt;/ul>
&lt;p>接下来我们详细看下每种扩展注入器加载扩展对象的策略:&lt;/p>
&lt;h3 id="542-域模型中的bean扩展注入器scopebeanextensioninjector">5.4.2 域模型中的Bean扩展注入器ScopeBeanExtensionInjector&lt;/h3>
&lt;p>ScopeBeanExtensionInjector的getInstance方法:
每个域模型都会有个ScopeBeanFactory类型的对象用于存储共享对象,并且域模型之间按照层级子类型的Bean工厂可以从父域的Bean工厂中查询对象,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>@Override
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> T getInstance(Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type, String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> beanFactory.getBean(name, type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ScopeBeanFactory的getBean方法
先从当前域空间查询对象,如果找不到对应类型的扩展对象则从父域工厂查询扩展对象&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> T getBean(String name, Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//当前域下注册的扩展对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> T bean &lt;span style="color:#719e07">=&lt;/span> getBeanInternal(name, type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (bean &lt;span style="color:#719e07">==&lt;/span> null &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> parent &lt;span style="color:#719e07">!=&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//父域中查找扩展对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> parent.getBean(name, type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> bean;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ScopeBeanFactory的getBeanInternal方法
从当前域下找注册的参数类型的对象&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">private&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> T getBeanInternal(String name, Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkDestroyed();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// All classes are derived from java.lang.Object, cannot filter bean by it
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (type &lt;span style="color:#719e07">==&lt;/span> Object.&lt;span style="color:#719e07">class&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> null;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>BeanInfo&lt;span style="color:#719e07">&amp;gt;&lt;/span> candidates &lt;span style="color:#719e07">=&lt;/span> null;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BeanInfo firstCandidate &lt;span style="color:#719e07">=&lt;/span> null;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//遍历列表查询
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">for&lt;/span> (BeanInfo beanInfo : registeredBeanInfos) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// if required bean type is same class/superclass/interface of the registered bean
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (type.isAssignableFrom(beanInfo.instance.getClass())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isEquals(beanInfo.name, name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> (T) beanInfo.instance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// optimize for only one matched bean
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (firstCandidate &lt;span style="color:#719e07">==&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> firstCandidate &lt;span style="color:#719e07">=&lt;/span> beanInfo;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (candidates &lt;span style="color:#719e07">==&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> candidates &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> candidates.add(firstCandidate);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> candidates.add(beanInfo);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// if bean name not matched and only single candidate
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (candidates &lt;span style="color:#719e07">!=&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (candidates.size() &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> (T) candidates.get(&lt;span style="color:#2aa198">0&lt;/span>).instance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#268bd2">if&lt;/span> (candidates.size() &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">&amp;gt;&lt;/span> candidateBeanNames &lt;span style="color:#719e07">=&lt;/span> candidates.stream().map(beanInfo &lt;span style="color:#719e07">-&amp;gt;&lt;/span> beanInfo.name).collect(Collectors.toList());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ScopeBeanException(&lt;span style="color:#2aa198">&amp;#34;expected single matching bean but found &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> candidates.size() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; candidates for type [&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> type.getName() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;]: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> candidateBeanNames);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#268bd2">if&lt;/span> (firstCandidate &lt;span style="color:#719e07">!=&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> (T) firstCandidate.instance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> null;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="543-spi扩展机制注入器spiextensioninjector">5.4.3 SPI扩展机制注入器SpiExtensionInjector&lt;/h3>
&lt;p>SPI是Dubbo自行实现的一套扩展机制,我们来看下它是如何查找扩展对象的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>@Override
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> T getInstance(Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type, String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果是一个标准的被@SPI注解修饰的扩展接口则满足条件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (type.isInterface() &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> type.isAnnotationPresent(SPI.&lt;span style="color:#719e07">class&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//使用扩展访问器来获取对应类型的扩展加载器
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> loader &lt;span style="color:#719e07">=&lt;/span> extensionAccessor.getExtensionLoader(type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (loader &lt;span style="color:#719e07">==&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> null;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//使用对应类型的扩展加载器来加载自适应扩展 这个加载的扩展可以参考4.4.6小节
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>loader.getSupportedExtensions().isEmpty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> loader.getAdaptiveExtension();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> null;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="544-spring扩展注入器">5.4.4 Spring扩展注入器&lt;/h3>
&lt;p>SpringExtensionInjector&lt;/p>
&lt;p>Spring扩展注入器主要是用来从Spring容器中查询当前类型的Bean是否存在的,如下代码直接看代码吧&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>@Override
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @SuppressWarnings(&lt;span style="color:#2aa198">&amp;#34;unchecked&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> T getInstance(Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type, String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (context &lt;span style="color:#719e07">==&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ignore if spring context is not bound
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> null;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//check @SPI annotation ,类型需要满足SPI机制 @SPI修饰的接口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (type.isInterface() &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> type.isAnnotationPresent(SPI.&lt;span style="color:#719e07">class&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> null;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//从Spring容器中查询Bean
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> T bean &lt;span style="color:#719e07">=&lt;/span> getOptionalBean(context, name, type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (bean &lt;span style="color:#719e07">!=&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> bean;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//logger.warn(&amp;#34;No spring extension (bean) named:&amp;#34; + name + &amp;#34;, try to find an extension (bean) of type &amp;#34; + type.getName());
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> null;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">private&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> T getOptionalBean(ListableBeanFactory beanFactory, String name, Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//要搜索的扩展名字为空就根据类型搜索
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isEmpty(name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//返回与给定类型（包括子类）匹配的bean的名称，对于FactoryBeans
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> String[] beanNamesForType &lt;span style="color:#719e07">=&lt;/span> beanFactory.getBeanNamesForType(type, &lt;span style="color:#b58900">true&lt;/span>, &lt;span style="color:#b58900">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (beanNamesForType &lt;span style="color:#719e07">!=&lt;/span> null) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (beanNamesForType.length &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//返回指定bean的实例，该实例可以是共享的，也可以是独立的。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#586e75">//根据Bean Name和类型 查询具体的扩展对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">return&lt;/span> beanFactory.getBean(beanNamesForType[&lt;span style="color:#2aa198">0&lt;/span>], type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#268bd2">if&lt;/span> (beanNamesForType.length &lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#2aa198">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;Expect single but found &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> beanNamesForType.length &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; beans in spring context: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Arrays.toString(beanNamesForType));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//扩展名字不为空则直接通过名字搜索Bean
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (beanFactory.containsBean(name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> beanFactory.getBean(name, type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> null;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原文： &lt;a href="https://blog.elastic.link/2022/07/10/dubbo/5-dubbo-de-spi-kuo-zhan-ji-zhi-yu-zi-gua-ying-kuo-zhan-dui-xiang-de-chuang-jian-yu-kuo-zhan-wen-jian-de-sao-miao-yuan-ma-jie-xi/">《自适应扩展对象的创建getAdaptiveExtension方法》&lt;/a>&lt;/p></description></item><item><title>Blog: 04-Dubbo的扩展机制</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/04/04-dubbo%E7%9A%84%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/</link><pubDate>Thu, 04 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/04/04-dubbo%E7%9A%84%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/</guid><description>
&lt;h1 id="4-dubbo的扩展机制">4-Dubbo的扩展机制&lt;/h1>
&lt;h2 id="41-回顾我们前面使用到扩展场景">4.1 回顾我们前面使用到扩展场景&lt;/h2>
&lt;p>在上一章中我们初始化应用模型对象的时候,了解到有几个地方用到了扩展机制来创建对象,这一章我们会详细来讲一下这个扩展对象的加载过程,这里我们先来回顾下哪些地方用到了扩展机制:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 使用扩展机制获取TypeBuilder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>TypeBuilder&lt;span style="color:#719e07">&amp;gt;&lt;/span> tbs &lt;span style="color:#719e07">=&lt;/span> model.getExtensionLoader(TypeBuilder.class).getSupportedExtensionInstances();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//获取域模型初始化器ScopeModelInitializer扩展对象,执行初始化方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>ScopeModelInitializer&lt;span style="color:#719e07">&amp;gt;&lt;/span> initializerExtensionLoader &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.getExtensionLoader(ScopeModelInitializer.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>ScopeModelInitializer&lt;span style="color:#719e07">&amp;gt;&lt;/span> initializers &lt;span style="color:#719e07">=&lt;/span> initializerExtensionLoader.getSupportedExtensionInstances();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// OrderedPropertiesConfiguration 中获取有序配置提供器对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>OrderedPropertiesProvider&lt;span style="color:#719e07">&amp;gt;&lt;/span> propertiesProviderExtensionLoader &lt;span style="color:#719e07">=&lt;/span> moduleModel.getExtensionLoader(OrderedPropertiesProvider.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// ApplicationModel中获取配置管理器对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configManager &lt;span style="color:#719e07">=&lt;/span> (ConfigManager) &lt;span style="color:#719e07">this&lt;/span>.getExtensionLoader(ApplicationExt.class)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .getExtension(ConfigManager.NAME);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//ModuleModel中获取模块扩展对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>ModuleExt&lt;span style="color:#719e07">&amp;gt;&lt;/span> exts &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.getExtensionLoader(ModuleExt.class).getSupportedExtensionInstances();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// ApplicationModel中获Environment对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>environment &lt;span style="color:#719e07">=&lt;/span> (Environment) &lt;span style="color:#719e07">this&lt;/span>.getExtensionLoader(ApplicationExt.class)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .getExtension(Environment.NAME);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// ApplicationModel中获取应用初始化监听器ApplicationInitListener扩展对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>ApplicationInitListener&lt;span style="color:#719e07">&amp;gt;&lt;/span> extensionLoader &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.getExtensionLoader(ApplicationInitListener.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">&amp;gt;&lt;/span> listenerNames &lt;span style="color:#719e07">=&lt;/span> extensionLoader.getSupportedExtensions();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//ScopeModel中创建扩展访问器:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">this&lt;/span>.extensionDirector &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ExtensionDirector(parent &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">?&lt;/span> parent.getExtensionDirector() : &lt;span style="color:#cb4b16">null&lt;/span>, scope, &lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有了以上的应用场景我们可以来看下扩展机制了&lt;/p>
&lt;h2 id="42-为什么要用到扩展机制">4.2 为什么要用到扩展机制?&lt;/h2>
&lt;p>为什么要用到扩展这个想必每个编程人员都比较了解,一个好的程序是要遵循一定的设计规范比如设计模式中的&lt;strong>开闭原则&lt;/strong> 英文全称是 Open Closed Principle，简写为 OCP,对扩展开放、对修改关闭:&lt;/p>
&lt;p>&lt;strong>对扩展开放：&lt;/strong> 指的是我们系统中的模块、类、方法对它们的提供者（开发者）应该是开放的，提供者可以对系统进行扩展（新增）新的功能。&lt;/p>
&lt;p>&lt;strong>对修改关闭：&lt;/strong> 指的是系统中的模块、类、方法对它们的使用者（调用者）应该是关闭的。使用者使用这些功能时，不会因为提供方新增了功能而导致使用者也进行相应修改。&lt;/p>
&lt;p>我们再来了解下Dubbo的一些基本特性:
下面这句话是我摘自官网的:
&lt;em>Apache Dubbo 是一款微服务开发框架，它提供了 &lt;strong>RPC通信&lt;/strong> 与 &lt;strong>微服务治理&lt;/strong> 两大关键能力。这意味着，使用 Dubbo 开发的微服务，将具备相互之间的远程发现与通信能力， 同时利用 Dubbo 提供的丰富服务治理能力，可以实现诸如服务发现、负载均衡、流量调度等服务治理诉求。同时 Dubbo 是高度可扩展的，用户几乎可以在&lt;strong>任意功能点去定制自己的实现&lt;/strong>，以改变框架的默认行为来满足自己的业务需求。
Dubbo3 基于 Dubbo2 演进而来，在保持原有核心功能特性的同时， Dubbo3 在易用性、超大规模微服务实践、云原生基础设施适配、安全设计等几大方向上进行了全面升级。 以下文档都将基于 Dubbo3 展开。&lt;/em>&lt;/p>
&lt;p>&lt;strong>对修改关闭的地方:&lt;/strong> 对于Apache Dubbo来说 不变的是RPC调用流程,微服务治理这些抽象的概念,我们可以用摘自官网的下面几个图表示:
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/4-dubbo-arch.png" alt="在这里插入图片描述">&lt;/p>
&lt;center>图4.1 Dubbo架构图&lt;/center>
&lt;p>再来看一个调用链路的架构图&lt;/p>
&lt;p>&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/4-dubbo-arch2.png" alt="在这里插入图片描述">&lt;/p>
&lt;center>图4.2 Dubbo RPC调用链路&lt;/center>
&lt;br/>
上面两个图整体来看都是Dubbo不变的地方涉及到服务的RPC调用和服务治理的一些概念与流程,但是对于每个环节又可以使用各种方式实现,比如序列化机制可以是Json,Java序列化,Hession2或者Protobuf等等,网络传输层可以是netty实现的tcp通信,也可以使用http协议,那Dubbo又是如何封装不变部分扩展这种可变部分呢?,那就是接下来要说的**微内核机制**,这个我们待会说
&lt;p>&lt;strong>对扩展开放：&lt;/strong> : 对于Apache Dubbo来说 变化的是RPC调用流程和微服务治理这些抽象的概念的具体实现,每个点应该用什么技术实现,又是用什么场景,这个可以用如下图来表示下:
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/4-dubbo-arch3.png" alt="在这里插入图片描述">&lt;/p>
&lt;center>图4.3 Dubbo的扩展生态&lt;/center>
&lt;/br>
&lt;p>看到这里 应该各位就明白了,我们写程序是为了业务,而针对不同的业务需求很多场景下我们是需要使用不同的实现来满足的,Dubbo使用微内核的架构,将具体的实现开放出来,让使用者可以根据自己的需求来选择,定制. Dubbo开放了很多的扩展点供大家扩展,可想而知使用Dubbo的灵活性是非常高的。&lt;/p>
&lt;p>&lt;strong>微内核架构:&lt;/strong>
微内核架构由两大架构模块组成：&lt;strong>核心系统&lt;/strong>与&lt;strong>插件模块&lt;/strong>,设计一个微内核体系关键工作全部集中于核心系统怎么构建。
&lt;strong>核心系统&lt;/strong> : 负责和具体业务功能无关的通用功能，例如模块加载、模块间通信等,这个其实对应着Dubbo的SPI机制。
&lt;strong>插件模块&lt;/strong> : 负责实现具体的业务逻辑，Dubbo,SPI接口与实现。&lt;/p>
&lt;h2 id="43-dubbo的扩展机制包含了哪些重要的组成部分">4.3 Dubbo的扩展机制包含了哪些重要的组成部分?&lt;/h2>
&lt;p>前面我们说了为什么要使用扩展机制,这里我们来看下具体实现&lt;/p>
&lt;p>先将扩展包里面的代码截个图认识认识各类型的单词
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/4-dubbo-extension.png" alt="在这里插入图片描述">&lt;/p>
&lt;p>顺便我们先简单看下类结构图,后续再详细看每个类型的解释:
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/4-dubbo-extension2.png" alt="在这里插入图片描述">&lt;/p>
&lt;p>为了后续看具体的扩展加载流程我们先看下以上类型的解释说明:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>ExtensionAccessor&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>扩展的统一访问器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ExtensionDirector&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>ExtensionDirector是一个作用域扩展加载程序管理器。&lt;/li>
&lt;li>ExtensionDirector支持多个级别，子级可以继承父级的扩展实例。
查找和创建扩展实例的方法类似于Java classloader。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ExtensionScope&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>扩展SPI域,目前有FRAMEWORK,APPLICATION,MODULE,SELF&lt;/li>
&lt;li>&lt;strong>FRAMEWORK&lt;/strong> : 扩展实例在框架内使用，与所有应用程序和模块共享。
框架范围SPI扩展只能获取FrameworkModel，无法获取ApplicationModel和ModuleModel。
考虑：
一些SPI需要在框架内的应用程序之间共享数据
无状态SPI在框架内是安全共享的&lt;/li>
&lt;li>&lt;strong>APPLICATION&lt;/strong> 扩展实例在一个应用程序中使用，与应用程序的所有模块共享，不同的应用程序创建不同的扩展实例。
应用范围SPI扩展可以获取FrameworkModel和ApplicationModel，无法获取ModuleModel。
考虑：
在框架内隔离不同应用程序中的扩展数据
在应用程序内部的所有模块之间共享扩展数据&lt;/li>
&lt;li>&lt;strong>MODULE&lt;/strong> 扩展实例在一个模块中使用，不同的模块创建不同的扩展实例。
模块范围SPI扩展可以获得FrameworkModel、ApplicationModel和ModuleModel。
考虑：
隔离应用程序内部不同模块中的扩展数据&lt;/li>
&lt;li>&lt;strong>SELF&lt;/strong> 自给自足，为每个作用域创建一个实例，用于特殊的SPI扩展，如ExtensionInjector&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ExtensionLoader&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>ApplicationModel、DubboBootstrap和这个类目前被设计为单例或静态（本身完全静态或使用一些静态字段）。因此，从它们返回的实例属于process或classloader范围。如果想在一个进程中支持多个dubbo服务器，可能需要重构这三个类。&lt;/li>
&lt;li>加载dubbo扩展&lt;/li>
&lt;li>自动注入依赖项扩展&lt;/li>
&lt;li>包装器中的自动包装扩展&lt;/li>
&lt;li>默认扩展是一个自适应实例&lt;/li>
&lt;li>JDK自带SPI参考地址 &lt;a href="https://docs.oracle.com/javase/1.5.0/docs/guide/jar/jar.html#Service%20Provider">点击查看&lt;/a>&lt;/li>
&lt;li>@SPI 服务扩展接口 详细内容看后面&lt;/li>
&lt;li>@Adaptive自适应扩展点注解 详细内容看后面&lt;/li>
&lt;li>@Activate自动激活扩展点注解 详细内容看后面&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ExtensionPostProcessor&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>在扩展初始化之前或之后调用的后处理器。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>LoadingStrategy&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>扩展加载策略,目前有3个扩展加载策略分别从不同文件目录加载扩展&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>DubboInternalLoadingStrategy&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Dubbo内置的扩展加载策略,将加载文件目录为META-INF/dubbo/internal/的扩展&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>DubboLoadingStrategy&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Dubbo普通的扩展加载策略,将加载目录为META-INF/dubbo/的扩展&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ServicesLoadingStrategy&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>JAVA SPI加载策略 ,将加载目录为META-INF/services/的扩展&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Wrapper&lt;/strong>注解&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SPI注解&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ExtensionInjector&lt;/strong>接口&lt;/p>
&lt;ul>
&lt;li>为SPI扩展提供资源的注入器。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ExtensionAccessorAware&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>SPI扩展可以实现这个感知接口，以获得适当的xtensionAccessor实例。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>DisableInject注解&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>AdaptiveClassCodeGenerator&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>自适应类的代码生成器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Adaptive&lt;/strong>注解&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为ExtensionLoader注入依赖扩展实例提供有用信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Activate&lt;/strong>注解&lt;/p>
&lt;ul>
&lt;li>Activate。此注解对于使用给定条件自动激活某些扩展非常有用，例如：@Activate可用于在有多个实现时加载某些筛选器扩展。
**group()**指定组条件。框架SPI定义了有效的组值。
**value()**指定URL条件中的参数键。
SPI提供程序可以调用ExtensionLoader。getActivateExtension(URL、String、String)方法以查找具有给定条件的所有已激活扩展。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ActivateComparator&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Activate扩展的排序器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>MultiInstanceActivateComparator&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>WrapperComparator&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>AdaptiveExtensionInjector&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>SpiExtensionInjector&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="44-扩展加载创建之前的调用过程">4.4 扩展加载创建之前的调用过程&lt;/h2>
&lt;h3 id="441-扩展的调用代码示例">4.4.1 扩展的调用代码示例&lt;/h3>
&lt;p>了解了这么多与扩展相关的概念,接下来我们就来从前面的代码调用中找几个例子来看下扩展的调用过程:&lt;/p>
&lt;p>代码来源于FrameworkModel对象的初始化initialize()中的如下代码调用:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> TypeDefinitionBuilder.initBuilders(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>TypeDefinitionBuilder中初始化类型构建器代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initBuilders&lt;/span>(FrameworkModel model) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>TypeBuilder&lt;span style="color:#719e07">&amp;gt;&lt;/span> tbs &lt;span style="color:#719e07">=&lt;/span> model.getExtensionLoader(TypeBuilder.class).getSupportedExtensionInstances();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BUILDERS &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(tbs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="442-dubbo的分层模型获取扩展加载器对象">4.4.2 Dubbo的分层模型获取扩展加载器对象&lt;/h3>
&lt;p>以上扩展调用的时候对于扩展加载器对象的获取代码如下所示,我们来看下它的调用链路&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>model.getExtensionLoader(TypeBuilder.class)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>getExtensionLoader方法来源于FrameworkModel类型的父类型ScopeModel的实现的接口ExtensionAccessor中的默认方法(JDK8 默认方法)&lt;/p>
&lt;p>ExtensionAccessor接口中的getExtensionLoader方法如下代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">default&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">getExtensionLoader&lt;/span>(Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.getExtensionDirector().getExtensionLoader(type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>获取扩展加载器之前需要先获取扩展访问器:
这里的链路先梳理下:&lt;/p>
&lt;p>&lt;strong>模型对象(FrameworkModel)-&lt;/strong>&amp;ndash;&amp;gt; &lt;strong>扩展访问器(ExtensionAccessor)&lt;/strong> &amp;mdash;&amp;gt; &lt;strong>作用域扩展加载程序管理器(ExtensionDirector)&lt;/strong> &amp;mdash;&amp;gt;&lt;/p>
&lt;p>这个getExtensionDirector()方法来源于FrameworkModel的抽象父类型ScopeModel中的getExtensionDirector()如下代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> ExtensionDirector &lt;span style="color:#268bd2">getExtensionDirector&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> extensionDirector;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里直接返回了extensionDirector,,不知道介绍到这里记得这个扩展加载程序管理器extensionDirector对象的由来不, 在上个章节&lt;a href="https://blog.elastic.link/2022/07/10/dubbo/3-kuang-jia-ying-yong-cheng-xu-mo-kuai-ling-yu-mo-xing-model-dui-xiang-de-chu-shi-hua/">《3-框架,应用程序,模块领域模型Model对象的初始化》&lt;/a>中3.2.2 初始化ScopeModel的章节中的ScopeModel类型的初始化方法initialize()方法中我们提到过这个对象的创建,具体代码如下所示(这个代码比较简单):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">this&lt;/span>.extensionDirector &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ExtensionDirector(parent &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">?&lt;/span> parent.getExtensionDirector() : &lt;span style="color:#cb4b16">null&lt;/span>, scope, &lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们继续前面getExtensionLoader(type)方法调用逻辑,前面我们知道了这个扩展访问器的对象是ExtensionDirector,接下来我们看下ExtensionDirector中获取扩展加载器的代码(如下所示):
在详细介绍扩展加载器对象获取之前我们先来看下当前我们要加载的扩展类型的源码,后续会用到:
我们要加载的扩展类型TypeBuilder接口&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@SPI&lt;/span>(scope &lt;span style="color:#719e07">=&lt;/span> ExtensionScope.FRAMEWORK)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">TypeBuilder&lt;/span> &lt;span style="color:#268bd2">extends&lt;/span> Prioritized {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * Whether the build accept the class passed in.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">boolean&lt;/span> &lt;span style="color:#268bd2">accept&lt;/span>(Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> clazz);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * Build type definition with the type or class.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TypeDefinition &lt;span style="color:#268bd2">build&lt;/span>(Type type, Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> clazz, Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, TypeDefinition&lt;span style="color:#719e07">&amp;gt;&lt;/span> typeCache);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ExtensionDirector类型中获取扩展加载器的代码
这个代码非常有意思 &lt;strong>其实就是前面说到的域模型架构的数据访问架构&lt;/strong>类似于JVM类加载器访问加载类的情况,但是这个顺序可能有所不同,Dubbo的扩展加载器是如何访问的呢? 遵循以下顺序:&lt;/p>
&lt;ul>
&lt;li>先从&lt;strong>缓存中&lt;/strong>查询扩展加载器&lt;/li>
&lt;li>如果前面没找到则查询扩展类型的scope所属域,如果是&lt;strong>当前域扩展&lt;/strong>则从直接创建扩展加载器&lt;/li>
&lt;li>如果前面没找到就从&lt;strong>父扩展访问器&lt;/strong>中查询,查询这个扩展是否数据父扩展域&lt;/li>
&lt;li>前面都没找到就尝试创建&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">getExtensionLoader&lt;/span>(Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果扩展加载器已经被销毁则抛出异常&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkDestroyed();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里参数类型传的是TypeBuilder.class不为空&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (type &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException(&lt;span style="color:#2aa198">&amp;#34;Extension type == null&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//扩展类型不为接口也要抛出异常,这个TypeBuilder.class具体类型代码往上看,这个类型是一个接口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>type.isInterface()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException(&lt;span style="color:#2aa198">&amp;#34;Extension type (&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> type &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;) is not an interface!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个判断逻辑是判断这个扩展接口是有有@SPI注解,TypeBuilder是有的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>withExtensionAnnotation(type)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException(&lt;span style="color:#2aa198">&amp;#34;Extension type (&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> type &lt;span style="color:#719e07">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2aa198">&amp;#34;) is not an extension, because it is NOT annotated with @&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> SPI.class.getSimpleName() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 1. find in local cache&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//被加载的扩展类型对应的扩展加载器会放到extensionLoadersMap这个ConcurrentHashMap类型的集合中方便缓存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> loader &lt;span style="color:#719e07">=&lt;/span> (ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span>) extensionLoadersMap.get(type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//查询扩展所属域,这个类型的扩展域是框架级别的ExtensionScope.FRAMEWORK&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//extensionScopeMap为ConcurrentHashMap类型的扩展域缓存集合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ExtensionScope scope &lt;span style="color:#719e07">=&lt;/span> extensionScopeMap.get(type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (scope &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SPI annotation &lt;span style="color:#719e07">=&lt;/span> type.getAnnotation(SPI.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scope &lt;span style="color:#719e07">=&lt;/span> annotation.scope();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extensionScopeMap.put(type, scope);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//首次访问的时候当前类型的扩展加载器类型肯定是空的,会走如下两个逻辑中的其中一个进行创建扩展加载器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//1)如果 扩展域为SELF 自给自足，为每个作用域创建一个实例，用于特殊的SPI扩展，如{@link ExtensionInjector}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (loader &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> scope &lt;span style="color:#719e07">==&lt;/span> ExtensionScope.SELF) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// create an instance in self scope&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loader &lt;span style="color:#719e07">=&lt;/span> createExtensionLoader0(type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 2. find in parent&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//3) 从父扩展加载器中查询当前扩展加载器是否存在,这里parent是空的先不考虑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (loader &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">this&lt;/span>.parent &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loader &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.parent.getExtensionLoader(type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 3. create it&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//4) 这个是我们本次会走的逻辑,大部分是会走这个逻辑来创建扩展加载器对象的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (loader &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loader &lt;span style="color:#719e07">=&lt;/span> createExtensionLoader(type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> loader;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前面提到的withExtensionAnnotation判断代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">boolean&lt;/span> &lt;span style="color:#268bd2">withExtensionAnnotation&lt;/span>(Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> type) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> type.isAnnotationPresent(SPI.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ExtensionDirector类型的createExtensionLoader方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">createExtensionLoader&lt;/span>(Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> loader &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//当前类型注解的scope与当前扩展访问器ExtensionDirector的scope是否一致,不一致则抛出异常&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//当前类型ExtensionDirector的scope是在构造器中传递的,在Model对象初始化的时候创建的本类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (isScopeMatched(type)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// if scope is matched, just create it&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loader &lt;span style="color:#719e07">=&lt;/span> createExtensionLoader0(type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// if scope is not matched, ignore it&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> loader;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ExtensionDirector类型的createExtensionLoader0方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">createExtensionLoader0&lt;/span>(Class&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> type) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//检查当前扩展访问器是否被销毁掉了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkDestroyed();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span> loader;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//为当前扩展类型创建一个扩展访问器并缓存到,当前成员变量extensionLoadersMap中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extensionLoadersMap.putIfAbsent(type, &lt;span style="color:#719e07">new&lt;/span> ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span>(type, &lt;span style="color:#719e07">this&lt;/span>, scopeModel));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loader &lt;span style="color:#719e07">=&lt;/span> (ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>T&lt;span style="color:#719e07">&amp;gt;&lt;/span>) extensionLoadersMap.get(type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> loader;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="443-扩展加载器对象extensionloader的构造器">4.4.3 扩展加载器对象ExtensionLoader的构造器&lt;/h3>
&lt;p>扩展加载器相对来说是比较复杂的实现内容比较多,用到哪里我们说下哪里,这里先来看ExtensionLoader的构造器代码如下所示:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> ExtensionLoader(Class&lt;span style="color:#719e07">&amp;lt;?&amp;gt;&lt;/span> type, ExtensionDirector extensionDirector, ScopeModel scopeModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//当前扩展加载器,需要加载的扩展的类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.type &lt;span style="color:#719e07">=&lt;/span> type;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建扩展加载器的扩展访问器对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.extensionDirector &lt;span style="color:#719e07">=&lt;/span> extensionDirector;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//从扩展访问器中获取扩展执行前后的回调器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.extensionPostProcessors &lt;span style="color:#719e07">=&lt;/span> extensionDirector.getExtensionPostProcessors();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建实例化对象的策略对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initInstantiationStrategy();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果当前扩展类型为扩展注入器类型则设置当前注入器变量为空,否则的话获取一个扩展注入器扩展对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.injector &lt;span style="color:#719e07">=&lt;/span> (type &lt;span style="color:#719e07">==&lt;/span> ExtensionInjector.class &lt;span style="color:#719e07">?&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> : extensionDirector.getExtensionLoader(ExtensionInjector.class)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .getAdaptiveExtension());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建Activate注解的排序器 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.activateComparator &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ActivateComparator(extensionDirector);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//为扩展加载器下的域模型对象赋值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.scopeModel &lt;span style="color:#719e07">=&lt;/span> scopeModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先来看 创建实例化对象的策略对象代码 initInstantiationStrategy();&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initInstantiationStrategy&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (ExtensionPostProcessor extensionPostProcessor : extensionPostProcessors) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//ScopeModelAwareExtensionProcessor在域模型对象时候为扩展访问器添加了这个域模型扩展处理器对象ScopeModelAwareExtensionProcessor,这个类型实现了ScopeModelAccessor域模型访问器可以用来获取域模型对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (extensionPostProcessor &lt;span style="color:#719e07">instanceof&lt;/span> ScopeModelAccessor) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instantiationStrategy &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> InstantiationStrategy((ScopeModelAccessor) extensionPostProcessor);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (instantiationStrategy &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instantiationStrategy &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> InstantiationStrategy();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再来看ExtensionInjector扩展对象的获取&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//1)这里有个type为空的判断,普通的扩展类型肯定不是ExtensionInjector类型 这里必定会为每个非扩展注入ExtensionInjector类型创建一个ExtensionInjector类型的扩展对象,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//2) 这里代码会走extensionDirector.getExtensionLoader(ExtensionInjector.class)这一步进去之后的代码刚刚看过就不再看了,这个代码会创建一个为ExtensionInjector扩展对象的加载器对象ExtensionLoader&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//3) getAdaptiveExtension() 这个方法就是通过扩展加载器获取具体的扩展对象的方法我们会详细说&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.injector &lt;span style="color:#719e07">=&lt;/span> (type &lt;span style="color:#719e07">==&lt;/span> ExtensionInjector.class &lt;span style="color:#719e07">?&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> : extensionDirector.getExtensionLoader(ExtensionInjector.class)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .getAdaptiveExtension());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原文： &lt;a href="https://blog.elastic.link/2022/07/10/dubbo/4-dubbo-de-spi-kuo-zhan-ji-zhi-yu-extensionloader-dui-xiang-de-chuang-jian-yuan-ma-jie-xi/">&amp;laquo;Dubbo的扩展机制&amp;raquo;&lt;/a>&lt;/p></description></item><item><title>Blog: 03-框架,应用程序,模块领域模型Model对象的初始化</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/03/03-%E6%A1%86%E6%9E%B6%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8Bmodel%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</link><pubDate>Wed, 03 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/03/03-%E6%A1%86%E6%9E%B6%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8Bmodel%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</guid><description>
&lt;h1 id="3-框架应用程序模块领域模型model对象的初始化">3-框架,应用程序,模块领域模型Model对象的初始化&lt;/h1>
&lt;p>在上一章中我们详细看了服务配置ServiceConfig类型的初始化，不过我们跳过了AbstractMethodConfig的构造器中创建模块模型对象的过程，那这一章我们就来看下模块模型对象的初始化过程:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">AbstractMethodConfig&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>(ApplicationModel.defaultModel().getDefaultModule());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>那为什么会在Dubbo3的新版本中加入这个域模型呢&lt;/strong>，主要有如下原因
之前dubbo都是只有一个作用域的，通过静态类 属性共享
增加域模型是为了:&lt;/p>
&lt;ol>
&lt;li>让Dubbo支持多应用的部署，这块一些大企业有诉求&lt;/li>
&lt;li>从架构设计上，解决静态属性资源共享、清理的问题&lt;/li>
&lt;li>分层模型将应用的管理和服务的管理分开&lt;/li>
&lt;/ol>
&lt;p>可能比较抽象，可以具体点来看。Dubbo3中在启动时候需要启动配置中心、元数据中心，这个配置中心和元数据中心可以归应用模型来管理。Dubbo作为RPC框架又需要启动服务和引用服务，服务级别的管理就交给了这个模块模型来管理。分层次的管理方便我们理解和处理逻辑，父子级别的模型又方便了数据传递。&lt;/p>
&lt;p>了解过JVM类加载机制的同学应该就比较清楚JVM类加载过程中的数据访问模型。子类加载器先交给父类加载器查找，找不到再从子类加载器中查找。Dubbo的分层模型类似这样一种机制，这一章先来简单了解下，后面用到时候具体细说。&lt;/p>
&lt;h2 id="31-模型对象的关系">3.1 模型对象的关系&lt;/h2>
&lt;p>为了不增加复杂性，我们这里仅仅列出模型对象类型类型之间的继承关系如下所示:
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/3-model.png" alt="在这里插入图片描述">&lt;/p>
&lt;center>图3.1 模型对象的继承关系&lt;/center>
&lt;p>模型对象一共有4个，公共的属性和操作放在了域模型类型中，下面我们来详细说下这几个模型类型:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>ExtensionAccessor&lt;/strong> 扩展的统一访问器&lt;/p>
&lt;ul>
&lt;li>用于获取扩展加载管理器ExtensionDirector对象&lt;/li>
&lt;li>&lt;strong>获取扩展对象ExtensionLoader&lt;/strong>&lt;/li>
&lt;li>根据扩展名字&lt;strong>获取具体扩展对象&lt;/strong>&lt;/li>
&lt;li>获取自适应扩展对象&lt;/li>
&lt;li>获取默认扩展对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ScopeModel&lt;/strong> 模型对象的公共抽象父类型&lt;/p>
&lt;ul>
&lt;li>内部id用于表示模型树的层次结构&lt;/li>
&lt;li>公共模型名称，可以被用户设置&lt;/li>
&lt;li>描述信息&lt;/li>
&lt;li>类加载器管理&lt;/li>
&lt;li>父模型管理parent&lt;/li>
&lt;li>当前模型的所属域ExtensionScope有:&lt;strong>FRAMEWORK(框架)&lt;/strong>，&lt;strong>APPLICATION(应用)&lt;/strong>，&lt;strong>MODULE(模块)&lt;/strong>，&lt;strong>SELF(自给自足&lt;/strong>，为每个作用域创建一个实例，用于特殊的SPI扩展，如ExtensionInjector)&lt;/li>
&lt;li>具体的扩展加载程序管理器对象的管理:&lt;strong>ExtensionDirector&lt;/strong>&lt;/li>
&lt;li>域Bean工厂管理，一个内部共享的Bean工厂&lt;strong>ScopeBeanFactory&lt;/strong>&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>FrameworkModel&lt;/strong> dubbo框架模型，可与多个应用程序共享&lt;/p>
&lt;ul>
&lt;li>FrameworkModel实例对象集合，allInstances&lt;/li>
&lt;li>所有ApplicationModel实例对象集合，applicationModels&lt;/li>
&lt;li>发布的ApplicationModel实例对象集合pubApplicationModels&lt;/li>
&lt;li>框架的服务存储库&lt;strong>FrameworkServiceRepository&lt;/strong>类型对象(数据存储在内存中)&lt;/li>
&lt;li>内部的应用程序模型对象internalApplicationModel&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ApplicationModel&lt;/strong> 表示正在使用Dubbo的应用程序，并存储基本&lt;strong>元数据信息&lt;/strong>，以便在RPC调用过程中使用。
ApplicationModel包括许多关于&lt;strong>发布服务&lt;/strong>的ProviderModel和许多关于订阅服务的Consumer Model。&lt;/p>
&lt;ul>
&lt;li>ExtensionLoader、DubboBootstrap和这个类目前被设计为单例或静态（本身完全静态或使用一些静态字段）。因此，从它们返回的实例属于流程范围。如果想在一个进程中支持多个dubbo服务器，可能需要重构这三个类。&lt;/li>
&lt;li>&lt;strong>所有ModuleModel实例&lt;/strong>对象集合moduleModels&lt;/li>
&lt;li>&lt;strong>发布的ModuleModel实例&lt;/strong>对象集合pubModuleModels&lt;/li>
&lt;li>&lt;strong>环境信息Environment实例&lt;/strong>对象environment&lt;/li>
&lt;li>&lt;strong>配置管理ConfigManager实例&lt;/strong>对象configManager&lt;/li>
&lt;li>&lt;strong>服务存储库ServiceRepository实例&lt;/strong>对象serviceRepository&lt;/li>
&lt;li>&lt;strong>应用程序部署器ApplicationDeployer实例&lt;/strong>对象deployer&lt;/li>
&lt;li>&lt;strong>所属框架FrameworkModel实例&lt;/strong>对象frameworkModel&lt;/li>
&lt;li>&lt;strong>内部的模块模型ModuleModel实例&lt;/strong>对象internalModule&lt;/li>
&lt;li>&lt;strong>默认的模块模型ModuleModel实例&lt;/strong>对象defaultModule&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ModuleModel&lt;/strong> 服务模块的模型&lt;/p>
&lt;ul>
&lt;li>&lt;strong>所属应用程序模型ApplicationModel实例&lt;/strong>对象applicationModel&lt;/li>
&lt;li>&lt;strong>模块环境信息ModuleEnvironment实例&lt;/strong>对象moduleEnvironment&lt;/li>
&lt;li>&lt;strong>模块服务存储库ModuleServiceRepository实例&lt;/strong>对象serviceRepository&lt;/li>
&lt;li>&lt;strong>模块的服务配置管理ModuleConfigManager实例&lt;/strong>对象moduleConfigManager&lt;/li>
&lt;li>&lt;strong>模块部署器ModuleDeployer实例&lt;/strong>对象deployer用于导出和引用服务&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>了解了这几个模型对象的关系我们可以了解到这几个模型对象的管理层级从框架到应用程序，然后到模块的管理(FrameworkModel-&amp;gt;ApplicationModel-&amp;gt;ModuleModel)，他们主要用来针对框架，应用程序，模块的&lt;strong>存储&lt;/strong>，&lt;strong>发布管理，&lt;/strong>，&lt;strong>配置管理&lt;/strong>&lt;/p>
&lt;p>看来Dubbo3 针对应用服务治理与运维这一块也是在努力尝试.&lt;/p>
&lt;h3 id="311-abstractmethodconfig-配置对象中获取模型对象的调用">3.1.1 AbstractMethodConfig 配置对象中获取模型对象的调用&lt;/h3>
&lt;p>模块模型(ModuleModel)参数对象的创建
这个AbstractMethodConfig构造器在初始化的时候调调用了这么一行代码做为参数向父类型传递对象.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ApplicationModel.defaultModel().getDefaultModule()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认情况下使用ApplicationModel的静态方法获取默认的模型对象和默认的模块对象&lt;/p>
&lt;p>&lt;strong>ApplicationModel&lt;/strong>(应用程序领域模型)类型中获取默认模型对象的方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> ApplicationModel &lt;span style="color:#268bd2">defaultModel&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// should get from default FrameworkModel, avoid out of sync&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> FrameworkModel.defaultModel().defaultApplication();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里可以看到要想获取应用程序模型必须先通过框架领域模型来获取层级也是框架领域模型到应用程序领域模型&lt;/p>
&lt;h3 id="312-使用双重校验锁获取框架模型对象">3.1.2 使用双重校验锁获取框架模型对象&lt;/h3>
&lt;p>FrameworkModel(框架模型)的默认模型获取工厂方法defaultModel()&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * 在源码的注释上有这么一句话:在销毁默认的 FrameworkModel 时， FrameworkModel.defaultModel()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> *或ApplicationModel.defaultModel() 将返回一个损坏的模型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> *可能会导致不可预知的问题。建议：尽量避免使用默认模型。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> FrameworkModel &lt;span style="color:#268bd2">defaultModel&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//双重校验锁的形式创建单例对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FrameworkModel instance &lt;span style="color:#719e07">=&lt;/span> defaultInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (instance &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (globalLock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//重置默认框架模型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resetDefaultFrameworkModel();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (defaultInstance &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defaultInstance &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> FrameworkModel();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instance &lt;span style="color:#719e07">=&lt;/span> defaultInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Assert.notNull(instance, &lt;span style="color:#2aa198">&amp;#34;Default FrameworkModel is null&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> instance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="313-刷新重置默认框架模型对象">3.1.3 刷新重置默认框架模型对象&lt;/h3>
&lt;p>FrameworkModel中的重置默认框架模型resetDefaultFrameworkModel&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">resetDefaultFrameworkModel&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//全局悲观锁，同一个时刻只能有一个线程执行重置操作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (globalLock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//defaultInstance为当前成员变量FrameworkModel类型代表当前默认的FrameworkModel类型的实例对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (defaultInstance &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>defaultInstance.isDestroyed()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FrameworkModel oldDefaultFrameworkModel &lt;span style="color:#719e07">=&lt;/span> defaultInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//存在实例模型列表则直接从内存缓存中查后续不需要创建了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (allInstances.size() &lt;span style="color:#719e07">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//当前存在的有FrameworkModel框架实例多个列表则取第一个为默认的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defaultInstance &lt;span style="color:#719e07">=&lt;/span> allInstances.get(0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defaultInstance &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (oldDefaultFrameworkModel &lt;span style="color:#719e07">!=&lt;/span> defaultInstance) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (LOGGER.isInfoEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOGGER.info(&lt;span style="color:#2aa198">&amp;#34;Reset global default framework from &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> safeGetModelDesc(oldDefaultFrameworkModel) &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; to &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> safeGetModelDesc(defaultInstance));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面单例做了很多的初始化操作，这里开始调用构造器来创建框架模型对象，如下代码:&lt;/p>
&lt;h2 id="32--创建frameworkmodel对象">3.2 创建FrameworkModel对象&lt;/h2>
&lt;p>FrameworkModel()构造器&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">FrameworkModel&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//调用父类型ScopeModel传递参数，这个构造器的第一个参数为空代表这是一个顶层的域模型，第二个代表了这个是框架FRAMEWORK域，第三个false不是内部域&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>(&lt;span style="color:#cb4b16">null&lt;/span>, ExtensionScope.FRAMEWORK, &lt;span style="color:#cb4b16">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//内部id用于表示模型树的层次结构，如层次结构:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//FrameworkModel（索引=1）-&amp;gt;ApplicationModel（索引=2）-&amp;gt;ModuleModel（索引=1，第一个用户模块）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个index变量是static类型的为静态全局变量默认值从1开始，如果有多个框架模型对象则internalId编号从1开始依次递增&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.setInternalId(String.valueOf(index.getAndIncrement()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// register FrameworkModel instance early&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将当前新创建的框架实例对象添加到容器中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (globalLock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将当前框架模型实例添加到所有框架模型缓存对象中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> allInstances.add(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如上面代码所示重置默认的框架模型对象，这里将会是缓存实例列表的第一个，新增了一个刷新默认实例对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resetDefaultFrameworkModel();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (LOGGER.isInfoEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOGGER.info(getDesc() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; is created&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化框架模型领域对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initialize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ExtensionScope.FRAMEWORK&lt;/p>
&lt;h3 id="321-初始化frameworkmodel">3.2.1 初始化FrameworkModel&lt;/h3>
&lt;p>FrameworkModel框架模型的初始化方法initialize()&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initialize&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这里初始化之前先调用下父类型ScopeModel的初始化方法我们在下面来看&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>.initialize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//使用TypeDefinitionBuilder的静态方法initBuilders来初始化类型构建器TypeBuilder类型集合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TypeDefinitionBuilder.initBuilders(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//框架服务存储仓库对象，可以用于快速查询服务提供者信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceRepository &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> FrameworkServiceRepository(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取ScopeModelInitializer类型(域模型初始化器)的扩展加载器ExtensionLoader，每个扩展类型都会创建一个扩展加载器缓存起来&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>ScopeModelInitializer&lt;span style="color:#719e07">&amp;gt;&lt;/span> initializerExtensionLoader &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.getExtensionLoader(ScopeModelInitializer.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取ScopeModelInitializer类型的支持的扩展集合，这里当前版本存在8个扩展类型实现&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>ScopeModelInitializer&lt;span style="color:#719e07">&amp;gt;&lt;/span> initializers &lt;span style="color:#719e07">=&lt;/span> initializerExtensionLoader.getSupportedExtensionInstances();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//遍历这些扩展实现调用他们的initializeFrameworkModel方法来传递FrameworkModel类型对象，细节我们待会再详细说下&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (ScopeModelInitializer initializer : initializers) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initializer.initializeFrameworkModel(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建一个内部的ApplicationModel类型，细节下面说&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> internalApplicationModel &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ApplicationModel(&lt;span style="color:#719e07">this&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建ApplicationConfig类型对象同时传递应用程序模型对象internalApplicationModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取ConfigManager类型对象，然后设置添加当前应用配置对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> internalApplicationModel.getApplicationConfigManager().setApplication(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">new&lt;/span> ApplicationConfig(internalApplicationModel, CommonConstants.DUBBO_INTERNAL_APPLICATION));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//设置公开的模块名字为常量DUBBO_INTERNAL_APPLICATION&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> internalApplicationModel.setModelName(CommonConstants.DUBBO_INTERNAL_APPLICATION);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>继续上面代码的调用链路，我们来看
FrameworkModel的super.initialize();方法 调用父类型ScopeModel的initialize()方法&lt;/p>
&lt;h3 id="322-初始化scopemodel">3.2.2 初始化ScopeModel&lt;/h3>
&lt;p>ScopeModel类型的初始化方法initialize():&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initialize&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化ExtensionDirector是一个作用域扩展加载程序管理器。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//ExtensionDirector支持多个级别，子级可以继承父级的扩展实例。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//查找和创建扩展实例的方法类似于Java classloader。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.extensionDirector &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ExtensionDirector(parent &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">?&lt;/span> parent.getExtensionDirector() : &lt;span style="color:#cb4b16">null&lt;/span>, scope, &lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个参考了Spring的生命周期回调思想，添加一个扩展初始化的前后调用的处理器，在扩展初始化之前或之后调用的后处理器，参数类型为ExtensionPostProcessor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.extensionDirector.addExtensionPostProcessor(&lt;span style="color:#719e07">new&lt;/span> ScopeModelAwareExtensionProcessor(&lt;span style="color:#719e07">this&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建一个内部共享的域工厂对象，用于注册Bean，创建Bean，获取Bean，初始化Bean等&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.beanFactory &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ScopeBeanFactory(parent &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">?&lt;/span> parent.getBeanFactory() : &lt;span style="color:#cb4b16">null&lt;/span>, extensionDirector);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//使用数据结构链表，创建销毁监听器容器，一般用于关闭进程，重置应用程序对象等操作时候调用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.destroyListeners &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> LinkedList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//使用ConcurrentHashMap属性集合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.attributes &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ConcurrentHashMap&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//使用ConcurrentHashSet存储当前域下的类加载器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.classLoaders &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ConcurrentHashSet&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// Add Framework&amp;#39;s ClassLoader by default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将当前类的加载器存入加载器集合classLoaders中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ClassLoader dubboClassLoader &lt;span style="color:#719e07">=&lt;/span> ScopeModel.class.getClassLoader();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (dubboClassLoader &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.addClassLoader(dubboClassLoader);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="323-初始类型定义构建器">3.2.3 初始类型定义构建器&lt;/h3>
&lt;p>TypeDefinitionBuilder的初始化类型构造器方法initBuilders&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initBuilders&lt;/span>(FrameworkModel model) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>TypeBuilder&lt;span style="color:#719e07">&amp;gt;&lt;/span> tbs &lt;span style="color:#719e07">=&lt;/span> model.getExtensionLoader(TypeBuilder.class).getSupportedExtensionInstances();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BUILDERS &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>(tbs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3231-服务存储仓库对象的创建">3.2.3.1 服务存储仓库对象的创建&lt;/h4>
&lt;p>FrameworkServiceRepository对象的初始化&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">FrameworkServiceRepository&lt;/span>(FrameworkModel frameworkModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.frameworkModel &lt;span style="color:#719e07">=&lt;/span> frameworkModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="324--域模型初始化器的获取与初始化回调">3.2.4 域模型初始化器的获取与初始化回调&lt;/h3>
&lt;p>域模型初始化器的获取与初始化(ScopeModelInitializer类型和initializeFrameworkModel方法)
加载到的ScopeModelInitializer类型的SPI扩展实现&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>ScopeModelInitializer&lt;span style="color:#719e07">&amp;gt;&lt;/span> initializerExtensionLoader &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.getExtensionLoader(ScopeModelInitializer.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取ScopeModelInitializer类型的支持的扩展集合，这里当前版本存在8个扩展类型实现&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>ScopeModelInitializer&lt;span style="color:#719e07">&amp;gt;&lt;/span> initializers &lt;span style="color:#719e07">=&lt;/span> initializerExtensionLoader.getSupportedExtensionInstances();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//遍历这些扩展实现调用他们的initializeFrameworkModel方法来传递FrameworkModel类型对象，细节我们待会再详细说下&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (ScopeModelInitializer initializer : initializers) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initializer.initializeFrameworkModel(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过Debug查到域模型初始化器的SPI扩展类型有如下8个:&lt;/p>
&lt;p>&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/3-initextent.png" alt="在这里插入图片描述">&lt;/p>
&lt;p>这里我随机找两个说一下吧:
容错域模型初始化器:ClusterScopeModelInitializer的initializeFrameworkModel方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">ClusterScopeModelInitializer&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> ScopeModelInitializer {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initializeFrameworkModel&lt;/span>(FrameworkModel frameworkModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ScopeBeanFactory beanFactory &lt;span style="color:#719e07">=&lt;/span> frameworkModel.getBeanFactory();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanFactory.registerBean(RouterSnapshotSwitcher.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">CommonScopeModelInitializer&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> ScopeModelInitializer {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initializeFrameworkModel&lt;/span>(FrameworkModel frameworkModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ScopeBeanFactory beanFactory &lt;span style="color:#719e07">=&lt;/span> frameworkModel.getBeanFactory();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanFactory.registerBean(FrameworkExecutorRepository.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">ConfigScopeModelInitializer&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> ScopeModelInitializer {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initializeFrameworkModel&lt;/span>(FrameworkModel frameworkModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> frameworkModel.addDestroyListener(&lt;span style="color:#719e07">new&lt;/span> FrameworkModelCleaner());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="325-将内部应用配置对象创建与添加至应用模型中">3.2.5 将内部应用配置对象创建与添加至应用模型中&lt;/h3>
&lt;p>创建ApplicationConfig对象让后将其添加至应用模型中
内部应用程序模型，这里为应用配置管理器设置一个应用配置对象，将这个应用配置的模块名字配置名字设置为DUBBO_INTERNAL_APPLICATION，应用配置记录着我们常见的应用配置信息，如下面表格所示:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取ConfigManager类型对象，然后设置添加当前应用配置对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> internalApplicationModel.getApplicationConfigManager().setApplication(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">new&lt;/span> ApplicationConfig(internalApplicationModel, CommonConstants.DUBBO_INTERNAL_APPLICATION));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//设置公开的模块名字为常量DUBBO_INTERNAL_APPLICATION&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> internalApplicationModel.setModelName(CommonConstants.DUBBO_INTERNAL_APPLICATION);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>来自官网目前版本的配置解释:
官网当前的配置描述知道到了元数据类型，后面我再补充几个&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>name&lt;/td>
&lt;td>application&lt;/td>
&lt;td>string&lt;/td>
&lt;td>必填&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样，此参数不是匹配条件，你当前项目叫什么名字就填什么，和提供者消费者角色无关，比如：kylin应用调用了morgan应用的服务，则kylin项目配成kylin，morgan项目配成morgan，可能kylin也提供其它服务给别人使用，但kylin项目永远配成kylin，这样注册中心将显示kylin依赖于morgan&lt;/td>
&lt;td>1.0.16以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>version&lt;/td>
&lt;td>application.version&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>当前应用的版本&lt;/td>
&lt;td>2.2.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>owner&lt;/td>
&lt;td>owner&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>应用负责人，用于服务治理，请填写负责人公司邮箱前缀&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>organization&lt;/td>
&lt;td>organization&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>组织名称(BU或部门)，用于注册中心区分服务来源，此配置项建议不要使用autoconfig，直接写死在配置中，比如china,intl,itu,crm,asc,dw,aliexpress等&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>architecture&lt;/td>
&lt;td>architecture&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>用于服务分层对应的架构。如，intl、china。不同的架构使用不同的分层。&lt;/td>
&lt;td>2.0.7以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>environment&lt;/td>
&lt;td>environment&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>应用环境，如：develop/test/product，不同环境使用不同的缺省值，以及作为只用于开发测试功能的限制条件&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>compiler&lt;/td>
&lt;td>compiler&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>javassist&lt;/td>
&lt;td>性能优化&lt;/td>
&lt;td>Java字节码编译器，用于动态类的生成，可选：jdk或javassist&lt;/td>
&lt;td>2.1.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>logger&lt;/td>
&lt;td>logger&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>slf4j&lt;/td>
&lt;td>性能优化&lt;/td>
&lt;td>日志输出方式，可选：slf4j,jcl,log4j,log4j2,jdk&lt;/td>
&lt;td>2.2.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>metadata-type&lt;/td>
&lt;td>metadata-type&lt;/td>
&lt;td>String&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>local&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>metadata 传递方式，是以 Provider 视角而言的，Consumer 侧配置无效，可选值有：remote - Provider 把 metadata 放到远端注册中心，Consumer 从注册中心获取local - Provider 把 metadata 放在本地，Consumer 从 Provider 处直接获取&lt;/td>
&lt;td>2.7.6以上版本&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>当前在Dubbo3.0.7中还有一些的配置我下面列举下:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>register-consumer&lt;/td>
&lt;td>register-consumer&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>是否注册使用者实例，默认为false。&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>register-mode&lt;/td>
&lt;td>register-mode&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>all&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>将interface/instance/all 地址注册到注册中心，默认为all。&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>enable-empty-protection&lt;/td>
&lt;td>enable-empty-protection&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>在空地址通知上启用空保护，默认为true&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>protocol&lt;/td>
&lt;td>protocol&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>dubbo&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>此应用程序的首选协议（名称）&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="33-创建applicationmodel对象">3.3 创建ApplicationModel对象&lt;/h2>
&lt;p>ApplicationModel对象的初始化调用
在前面 3.2.4 FrameworkModel框架模型的初始化方法initialize() 章节中，我们看到了代码ApplicationModel对象的初始化调用如下代码，这里我们来详细说一下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> internalApplicationModel &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ApplicationModel(&lt;span style="color:#719e07">this&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> internalApplicationModel.getApplicationConfigManager().setApplication(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">new&lt;/span> ApplicationConfig(internalApplicationModel, CommonConstants.DUBBO_INTERNAL_APPLICATION));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> internalApplicationModel.setModelName(CommonConstants.DUBBO_INTERNAL_APPLICATION);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="331-applicationmodel的构造器">3.3.1 ApplicationModel的构造器&lt;/h3>
&lt;p>ApplicationModel(FrameworkModel frameworkModel, boolean isInternal)
刚刚3.2.9那个地方我们看到了使用代码&lt;strong>new ApplicationModel(this, true)&lt;/strong> 来创建对象这里我们详细看下代码细节:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">ApplicationModel&lt;/span>(FrameworkModel frameworkModel, &lt;span style="color:#dc322f">boolean&lt;/span> isInternal) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//调用父类型ScopeModel传递参数，这个构造器的传递没与前面看到的FrameworkModel构造器的中的调用参数有些不同第一个参数我们为frameworkModel代表父域模型，第二个参数标记域为应用程序级别APPLICATION，第三个参数我们传递的为true代表为内部域&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>(frameworkModel, ExtensionScope.APPLICATION, isInternal);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Assert.notNull(frameworkModel, &lt;span style="color:#2aa198">&amp;#34;FrameworkModel can not be null&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//应用程序域成员变量记录frameworkModel对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.frameworkModel &lt;span style="color:#719e07">=&lt;/span> frameworkModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//frameworkModel对象添加当前应用程序域对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> frameworkModel.addApplication(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (LOGGER.isInfoEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOGGER.info(getDesc() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; is created&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化应用程序&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initialize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3311-将applicationmodel添加至frameworkmodel容器中">3.3.1.1 将ApplicationModel添加至FrameworkModel容器中&lt;/h4>
&lt;p>FrameworkModel的添加应用程序方法addApplication:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">addApplication&lt;/span>(ApplicationModel applicationModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// can not add new application if it&amp;#39;s destroying&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//检查FrameworkModel对象是否已经被标记为销毁状态，如果已经被销毁了则抛出异常无需执行逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkDestroyed();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (instLock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果还未添加过当前参数传递应用模型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>&lt;span style="color:#719e07">this&lt;/span>.applicationModels.contains(applicationModel)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//为当前应用模型生成内部id&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationModel.setInternalId(buildInternalId(getInternalId(), appIndex.getAndIncrement()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//添加到成员变量集合applicationModels中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.applicationModels.add(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果非内部的则也向公开应用模型集合pubApplicationModels中添加一下&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>applicationModel.isInternal()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.pubApplicationModels.add(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resetDefaultAppModel();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>内部id生成算法buildInternalId方法代码如下:
看代码胜过，文字解释&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> String &lt;span style="color:#268bd2">buildInternalId&lt;/span>(String parentInternalId, &lt;span style="color:#dc322f">long&lt;/span> childIndex) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// FrameworkModel 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ApplicationModel 1.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ModuleModel 1.1.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.hasText(parentInternalId)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> parentInternalId &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;.&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> childIndex;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> childIndex;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>重置默认的应用模型对象&lt;/strong>
FrameworkModel 重置默认的应用模型对象 resetDefaultAppModel()方法
与默认框架模型设置方式类似取集合的第一个，这里应用模型需要使用公开的应用模型的第一个做为默认应用模型，代码如下所示:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">resetDefaultAppModel&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (instLock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">this&lt;/span>.defaultAppModel &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">!&lt;/span>&lt;span style="color:#719e07">this&lt;/span>.defaultAppModel.isDestroyed()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//取第一个公开的应用模型做为默认应用模型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ApplicationModel oldDefaultAppModel &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.defaultAppModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (pubApplicationModels.size() &lt;span style="color:#719e07">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.defaultAppModel &lt;span style="color:#719e07">=&lt;/span> pubApplicationModels.get(0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.defaultAppModel &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (defaultInstance &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#719e07">this&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> oldDefaultAppModel &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.defaultAppModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (LOGGER.isInfoEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOGGER.info(&lt;span style="color:#2aa198">&amp;#34;Reset global default application from &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> safeGetModelDesc(oldDefaultAppModel) &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; to &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> safeGetModelDesc(&lt;span style="color:#719e07">this&lt;/span>.defaultAppModel));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="332-初始化applicationmodel">3.3.2 初始化ApplicationModel&lt;/h3>
&lt;p>ApplicationModel的初始化initialize()方法
在前面&lt;strong>3.2.10 ApplicationModel的构造器ApplicationModel(FrameworkModel frameworkModel, boolean isInternal)&lt;/strong> 中的最后一行开始初始化应用模型我们还未详细说明下面可以来看下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initialize&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个是调用域模型来初始化基础信息如扩展访问器等，可以参考 3.2.5 ScopeModel类型的初始化方法initialize()章节&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>.initialize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建一个内部的模块模型对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> internalModule &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ModuleModel(&lt;span style="color:#719e07">this&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建一个独立服务存储对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.serviceRepository &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ServiceRepository(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取应用程序初始化监听器ApplicationInitListener扩展&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>ApplicationInitListener&lt;span style="color:#719e07">&amp;gt;&lt;/span> extensionLoader &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.getExtensionLoader(ApplicationInitListener.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果存在应用程序初始化监听器扩展则执行这个初始化方法，在当前的版本还未看到有具体的扩展实现类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">&amp;gt;&lt;/span> listenerNames &lt;span style="color:#719e07">=&lt;/span> extensionLoader.getSupportedExtensions();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (String listenerName : listenerNames) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extensionLoader.getExtension(listenerName).init();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化扩展(这个是应用程序生命周期的方法调用，这里调用初始化方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initApplicationExts();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取域模型初始化器扩展对象列表，然后执行初始化方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>ScopeModelInitializer&lt;span style="color:#719e07">&amp;gt;&lt;/span> initializerExtensionLoader &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.getExtensionLoader(ScopeModelInitializer.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>ScopeModelInitializer&lt;span style="color:#719e07">&amp;gt;&lt;/span> initializers &lt;span style="color:#719e07">=&lt;/span> initializerExtensionLoader.getSupportedExtensionInstances();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (ScopeModelInitializer initializer : initializers) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initializer.initializeApplicationModel(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="334-initapplicationexts--初始化应用程序扩展方法">3.3.4 initApplicationExts() 初始化应用程序扩展方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initApplicationExts&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个扩展实现一共有两个可以看下面那个图扩展类型为ConfigManager和Environment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>ApplicationExt&lt;span style="color:#719e07">&amp;gt;&lt;/span> exts &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.getExtensionLoader(ApplicationExt.class).getSupportedExtensionInstances();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (ApplicationExt ext : exts) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ext.initialize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/3-extension.png" alt="在这里插入图片描述">&lt;/p>
&lt;h4 id="3341-configmanager类型的initialize方法">3.3.4.1 ConfigManager类型的initialize方法&lt;/h4>
&lt;p>先简单说下ConfigManager的作用，无锁配置管理器（通过ConcurrentHashMap），用于快速读取操作。写入操作锁带有配置类型的子配置映射，用于安全检查和添加新配置。
其实ConfigManager实现类中并没有这个初始化方法initialize，不过ConfigManager的父类型AbstractConfigManager中是有initialize方法的，如下所示:&lt;/p>
&lt;p>AbstractConfigManager的初始化方法initialize&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initialize&lt;/span>() &lt;span style="color:#268bd2">throws&lt;/span> IllegalStateException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//乐观锁判断是否初始化过&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>initialized.compareAndSet(&lt;span style="color:#cb4b16">false&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//从模块环境中获取组合配置，目前Environment中有6种重要的配置，我们后面详细说&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CompositeConfiguration configuration &lt;span style="color:#719e07">=&lt;/span> scopeModel.getModelEnvironment().getConfiguration();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// dubbo.config.mode获取配置模式，配置模式对应枚举类型ConfigMode，目前有这么几个STRICT，OVERRIDE，OVERRIDE_ALL，OVERRIDE_IF_ABSENT，IGNORE，这个配置决定了属性覆盖的顺序，当有同一个配置key多次出现时候，以最新配置为准，还是以最老的那个配置为准，还是配置重复则抛出异常，默认值为严格模式STRICT重复则抛出异常&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String configModeStr &lt;span style="color:#719e07">=&lt;/span> (String) configuration.getProperty(ConfigKeys.DUBBO_CONFIG_MODE);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.hasText(configModeStr)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.configMode &lt;span style="color:#719e07">=&lt;/span> ConfigMode.valueOf(configModeStr.toUpperCase());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String msg &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Illegal &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> ConfigKeys.DUBBO_CONFIG_MODE &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&amp;#39; config value [&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> configModeStr &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;], available values &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> Arrays.toString(ConfigMode.values());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(msg, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException(msg, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// dubbo.config.ignore-duplicated-interface&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//忽略重复的接口（服务/引用）配置。默认值为false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String ignoreDuplicatedInterfaceStr &lt;span style="color:#719e07">=&lt;/span> (String) configuration
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .getProperty(ConfigKeys.DUBBO_CONFIG_IGNORE_DUPLICATED_INTERFACE);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (ignoreDuplicatedInterfaceStr &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.ignoreDuplicatedInterface &lt;span style="color:#719e07">=&lt;/span> Boolean.parseBoolean(ignoreDuplicatedInterfaceStr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// print 打印配置信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, Object&lt;span style="color:#719e07">&amp;gt;&lt;/span> map &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> LinkedHashMap&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map.put(ConfigKeys.DUBBO_CONFIG_MODE, configMode);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map.put(ConfigKeys.DUBBO_CONFIG_IGNORE_DUPLICATED_INTERFACE, &lt;span style="color:#719e07">this&lt;/span>.ignoreDuplicatedInterface);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;Config settings: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> map);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3342-environment类型的initialize方法">3.3.4.2 Environment类型的initialize方法&lt;/h4>
&lt;p>这是一个与环境配置有关系的类型，我们先来简单了解下它的初始化方法，后期再详细说明:&lt;/p>
&lt;p>Environment类型的initialize方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initialize&lt;/span>() &lt;span style="color:#268bd2">throws&lt;/span> IllegalStateException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//乐观锁判断是否进行过初始化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (initialized.compareAndSet(&lt;span style="color:#cb4b16">false&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//PropertiesConfiguration从系统属性和dubbo.properties中获取配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.propertiesConfiguration &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> PropertiesConfiguration(scopeModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//SystemConfiguration获取的是JVM参数 启动命令中-D指定的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.systemConfiguration &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> SystemConfiguration();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//EnvironmentConfiguration是从环境变量中获取的配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.environmentConfiguration &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> EnvironmentConfiguration();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//外部的Global配置config-center global/default config&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.externalConfiguration &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> InmemoryConfiguration(&lt;span style="color:#2aa198">&amp;#34;ExternalConfig&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//外部的应用配置如:config-center中的应用配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.appExternalConfiguration &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> InmemoryConfiguration(&lt;span style="color:#2aa198">&amp;#34;AppExternalConfig&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//本地应用配置 ， 如Spring Environment/PropertySources/application.properties&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.appConfiguration &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> InmemoryConfiguration(&lt;span style="color:#2aa198">&amp;#34;AppConfig&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务迁移配置加载 dubbo2升级dubbo3的一些配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadMigrationRule();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务迁移配置加载 JVM &amp;gt; env &amp;gt; 代码路径dubbo-migration.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">loadMigrationRule&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//文件路径配置的key dubbo.migration.file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// JVM参数中获取&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String path &lt;span style="color:#719e07">=&lt;/span> System.getProperty(CommonConstants.DUBBO_MIGRATION_KEY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isEmpty(path)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//env环境变量中获取&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path &lt;span style="color:#719e07">=&lt;/span> System.getenv(CommonConstants.DUBBO_MIGRATION_KEY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.isEmpty(path)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//类路径下获取文件dubbo-migration.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path &lt;span style="color:#719e07">=&lt;/span> CommonConstants.DEFAULT_DUBBO_MIGRATION_FILE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.localMigrationRule &lt;span style="color:#719e07">=&lt;/span> ConfigUtils.loadMigrationRule(scopeModel.getClassLoaders(), path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>ConfigUtils中读取迁移规则配置文件loadMigrationRule&lt;/strong>
这个我们不细说了，贴一下代码感兴趣可以了解下，这个代码主要是读取文件到内存字符串:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> String &lt;span style="color:#268bd2">loadMigrationRule&lt;/span>(Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>ClassLoader&lt;span style="color:#719e07">&amp;gt;&lt;/span> classLoaders, String fileName) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String rawRule &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (checkFileNameExist(fileName)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> (FileInputStream input &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> FileInputStream(fileName)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> readString(input);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(&lt;span style="color:#2aa198">&amp;#34;Failed to load &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> fileName &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; file from &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> fileName &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;(ignore this file): &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> e.getMessage(), e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>ClassLoader&lt;span style="color:#719e07">&amp;gt;&lt;/span> classLoadersToLoad &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> LinkedList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> classLoadersToLoad.add(ClassUtils.getClassLoader());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> classLoadersToLoad.addAll(classLoaders);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>URL&lt;span style="color:#719e07">&amp;gt;&lt;/span> urls : ClassLoaderResourceLoader.loadResources(fileName, classLoadersToLoad).values()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (URL url : urls) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InputStream is &lt;span style="color:#719e07">=&lt;/span> url.openStream();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (is &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> readString(is);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Throwable e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.warn(&lt;span style="color:#2aa198">&amp;#34;Failed to load &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> fileName &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; file from &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> fileName &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;(ignore this file): &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> e.getMessage(), e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> rawRule;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> String &lt;span style="color:#268bd2">readString&lt;/span>(InputStream is) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StringBuilder stringBuilder &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> StringBuilder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">char&lt;/span>&lt;span style="color:#719e07">[]&lt;/span> buffer &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> &lt;span style="color:#dc322f">char&lt;/span>&lt;span style="color:#719e07">[&lt;/span>10&lt;span style="color:#719e07">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> (BufferedReader reader &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> BufferedReader(&lt;span style="color:#719e07">new&lt;/span> InputStreamReader(is))) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#dc322f">int&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">while&lt;/span> ((n &lt;span style="color:#719e07">=&lt;/span> reader.read(buffer)) &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#719e07">-&lt;/span>1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (n &lt;span style="color:#719e07">&amp;lt;&lt;/span> 10) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer &lt;span style="color:#719e07">=&lt;/span> Arrays.copyOf(buffer, n);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stringBuilder.append(String.valueOf(buffer));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> &lt;span style="color:#dc322f">char&lt;/span>&lt;span style="color:#719e07">[&lt;/span>10&lt;span style="color:#719e07">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (IOException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(&lt;span style="color:#2aa198">&amp;#34;Read migration file error.&amp;#34;&lt;/span>, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> stringBuilder.toString();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * check if the fileName can be found in filesystem
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param fileName
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @return
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">boolean&lt;/span> &lt;span style="color:#268bd2">checkFileNameExist&lt;/span>(String fileName) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File file &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> File(fileName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> file.exists();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>​&lt;/p>
&lt;h2 id="34-创建modulemodel对象">3.4 创建ModuleModel对象&lt;/h2>
&lt;p>前面ApplicationModel对象初始化的时候创建了ModuleModel如下代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>internalModule &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ModuleModel(&lt;span style="color:#719e07">this&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里我们来看下这个它所对应的构造器&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">ModuleModel&lt;/span>(ApplicationModel applicationModel, &lt;span style="color:#dc322f">boolean&lt;/span> isInternal) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//调用ScopeModel传递3个参数父模型，模型域为模块域，是否为内部模型参数为true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>(applicationModel, ExtensionScope.MODULE, isInternal);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Assert.notNull(applicationModel, &lt;span style="color:#2aa198">&amp;#34;ApplicationModel can not be null&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化成员变量applicationModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.applicationModel &lt;span style="color:#719e07">=&lt;/span> applicationModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//将模块模型添加至应用模型中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationModel.addModule(&lt;span style="color:#719e07">this&lt;/span>, isInternal);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (LOGGER.isInfoEnabled()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOGGER.info(getDesc() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34; is created&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化模块模型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initialize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Assert.notNull(serviceRepository, &lt;span style="color:#2aa198">&amp;#34;ModuleServiceRepository can not be null&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Assert.notNull(moduleConfigManager, &lt;span style="color:#2aa198">&amp;#34;ModuleConfigManager can not be null&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Assert.assertTrue(moduleConfigManager.isInitialized(), &lt;span style="color:#2aa198">&amp;#34;ModuleConfigManager can not be initialized&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// notify application check state&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取应用程序发布对象，通知检查状态&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ApplicationDeployer applicationDeployer &lt;span style="color:#719e07">=&lt;/span> applicationModel.getDeployer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (applicationDeployer &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationDeployer.notifyModuleChanged(&lt;span style="color:#719e07">this&lt;/span>, DeployState.PENDING);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="341-将模块模型添加至应用模型中">3.4.1 将模块模型添加至应用模型中&lt;/h3>
&lt;p>如上面代码所示调用如下代码将模块模型添加到应用模型中:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> applicationModel.addModule(&lt;span style="color:#719e07">this&lt;/span>, isInternal);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里我们来看下添加过程&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">addModule&lt;/span>(ModuleModel moduleModel, &lt;span style="color:#dc322f">boolean&lt;/span> isInternal) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//加锁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">synchronized&lt;/span> (moduleLock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//不存在则添加&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>&lt;span style="color:#719e07">this&lt;/span>.moduleModels.contains(moduleModel)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//检查应用模型是否已销毁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkDestroyed();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//添加至模块模型成员变量中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.moduleModels.add(moduleModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//设置模块模型内部id，这个内部id生成过程与上面将应用模型添加到框架模型中的方式是一致的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//可以参考 3.3.2 将ApplicationModel添加至FrameworkModel容器中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> moduleModel.setInternalId(buildInternalId(getInternalId(), moduleIndex.getAndIncrement()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果不是内部模型则添加到公开模块模型中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>isInternal) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pubModuleModels.add(moduleModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="342-初始化模块模型">3.4.2 初始化模块模型&lt;/h3>
&lt;p>前面ModuleModel构造器中通过initialize()方法来进行初始化操作如下代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initialize&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//调用域模型ScopeModel的初始化，可以参考 3.2.5 ScopeModel类型的初始化方法initialize()章节&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>.initialize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建模块服务存储库对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.serviceRepository &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ModuleServiceRepository(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建模块配置管理对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.moduleConfigManager &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ModuleConfigManager(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化模块配置管理对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.moduleConfigManager.initialize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化模块配置扩展&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initModuleExt();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化域模型扩展&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>ScopeModelInitializer&lt;span style="color:#719e07">&amp;gt;&lt;/span> initializerExtensionLoader &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.getExtensionLoader(ScopeModelInitializer.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>ScopeModelInitializer&lt;span style="color:#719e07">&amp;gt;&lt;/span> initializers &lt;span style="color:#719e07">=&lt;/span> initializerExtensionLoader.getSupportedExtensionInstances();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (ScopeModelInitializer initializer : initializers) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initializer.initializeModuleModel(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3421-模块服务存储库的创建">3.4.2.1 模块服务存储库的创建&lt;/h4>
&lt;p>ModuleServiceRepository是模块模型中用来存储服务的通过如下代码调用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//创建模块服务存储库对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.serviceRepository &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ModuleServiceRepository(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里我们来看下模块服务存储库的构造器代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">ModuleServiceRepository&lt;/span>(ModuleModel moduleModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化模块模型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.moduleModel &lt;span style="color:#719e07">=&lt;/span> moduleModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> frameworkServiceRepository &lt;span style="color:#719e07">=&lt;/span> ScopeModelUtil.getFrameworkModel(moduleModel).getServiceRepository();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ModuleServiceRepository存储库中使用框架存储库frameworkServiceRepository来间接存储
这里我们看下怎么通过模块模型获取框架服务存储库frameworkServiceRepository:通过代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ScopeModelUtil.getFrameworkModel(moduleModel).getServiceRepository()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ScopeModelUtil工具类获取getFrameworkModel代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> FrameworkModel &lt;span style="color:#268bd2">getFrameworkModel&lt;/span>(ScopeModel scopeModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (scopeModel &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> FrameworkModel.defaultModel();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//通过成员变量获取(构造器初始化的时候将FrameworkModel赋值给了ApplicationModel的成员变量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (scopeModel &lt;span style="color:#719e07">instanceof&lt;/span> ApplicationModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//直接获取&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> ((ApplicationModel) scopeModel).getFrameworkModel();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (scopeModel &lt;span style="color:#719e07">instanceof&lt;/span> ModuleModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ModuleModel moduleModel &lt;span style="color:#719e07">=&lt;/span> (ModuleModel) scopeModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//间接通过ApplicationModel获取，不越级获取&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> moduleModel.getApplicationModel().getFrameworkModel();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#719e07">if&lt;/span> (scopeModel &lt;span style="color:#719e07">instanceof&lt;/span> FrameworkModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> (FrameworkModel) scopeModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException(&lt;span style="color:#2aa198">&amp;#34;Unable to get FrameworkModel from &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> scopeModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3422-模块配置管理器对象的创建与初始化">3.4.2.2 模块配置管理器对象的创建与初始化&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//创建模块配置管理对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.moduleConfigManager &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ModuleConfigManager(&lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化模块配置管理对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.moduleConfigManager.initialize();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ModuleConfigManager的构造器代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">ModuleConfigManager&lt;/span>(ModuleModel moduleModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//向抽象的配置管理器AbstractConfigManager传递参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//模块模型参数，模块支持的配置类型集合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>(moduleModel, Arrays.asList(ModuleConfig.class, ServiceConfigBase.class, ReferenceConfigBase.class, ProviderConfig.class, ConsumerConfig.class));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取应用程序配置管理器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> applicationConfigManager &lt;span style="color:#719e07">=&lt;/span> moduleModel.getApplicationModel().getApplicationConfigManager();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ModuleConfigManager类型的初始化方法代码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initialize&lt;/span>() &lt;span style="color:#268bd2">throws&lt;/span> IllegalStateException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>initialized.compareAndSet(&lt;span style="color:#cb4b16">false&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取组合配置对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CompositeConfiguration configuration &lt;span style="color:#719e07">=&lt;/span> scopeModel.getModelEnvironment().getConfiguration();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// dubbo.config.mode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//3.3.4.1提到过这里再重复一次 dubbo.config.mode获取配置模式，配置模式对应枚举类型ConfigMode，目前有这么几个STRICT，OVERRIDE，OVERRIDE_ALL，OVERRIDE_IF_ABSENT，IGNORE，这个配置决定了属性覆盖的顺序，当有同一个配置key多次出现时候，以最新配置为准，还是以最老的那个配置为准，还是配置重复则抛出异常，默认值为严格模式STRICT重复则抛出异常&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String configModeStr &lt;span style="color:#719e07">=&lt;/span> (String) configuration.getProperty(ConfigKeys.DUBBO_CONFIG_MODE);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (StringUtils.hasText(configModeStr)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.configMode &lt;span style="color:#719e07">=&lt;/span> ConfigMode.valueOf(configModeStr.toUpperCase());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#719e07">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String msg &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Illegal &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> ConfigKeys.DUBBO_CONFIG_MODE &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;&amp;#39; config value [&amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> configModeStr &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;], available values &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> Arrays.toString(ConfigMode.values());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(msg, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException(msg, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// dubbo.config.ignore-duplicated-interface&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//忽略重复的接口（服务/引用）配置。默认值为false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String ignoreDuplicatedInterfaceStr &lt;span style="color:#719e07">=&lt;/span> (String) configuration
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .getProperty(ConfigKeys.DUBBO_CONFIG_IGNORE_DUPLICATED_INTERFACE);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (ignoreDuplicatedInterfaceStr &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.ignoreDuplicatedInterface &lt;span style="color:#719e07">=&lt;/span> Boolean.parseBoolean(ignoreDuplicatedInterfaceStr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// print 打印配置信息到控制台&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#719e07">&amp;lt;&lt;/span>String, Object&lt;span style="color:#719e07">&amp;gt;&lt;/span> map &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> LinkedHashMap&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map.put(ConfigKeys.DUBBO_CONFIG_MODE, configMode);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map.put(ConfigKeys.DUBBO_CONFIG_IGNORE_DUPLICATED_INTERFACE, &lt;span style="color:#719e07">this&lt;/span>.ignoreDuplicatedInterface);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;Config settings: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> map);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3423-模块配置扩展的初始化">3.4.2.3 模块配置扩展的初始化&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>initModuleExt();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initModuleExt&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//目前这里的扩展只支持有一个类型ModuleEnvironment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>ModuleExt&lt;span style="color:#719e07">&amp;gt;&lt;/span> exts &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.getExtensionLoader(ModuleExt.class).getSupportedExtensionInstances();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (ModuleExt ext : exts) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ext.initialize();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ModuleEnvironment的初始化&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">initialize&lt;/span>() &lt;span style="color:#268bd2">throws&lt;/span> IllegalStateException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.orderedPropertiesConfiguration &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> OrderedPropertiesConfiguration(moduleModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>OrderedPropertiesConfiguration对象的创建&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">OrderedPropertiesConfiguration&lt;/span>(ModuleModel moduleModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.moduleModel &lt;span style="color:#719e07">=&lt;/span> moduleModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> refresh();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">refresh&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> properties &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> Properties();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//有序的配置提供器扩展获取&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ExtensionLoader&lt;span style="color:#719e07">&amp;lt;&lt;/span>OrderedPropertiesProvider&lt;span style="color:#719e07">&amp;gt;&lt;/span> propertiesProviderExtensionLoader &lt;span style="color:#719e07">=&lt;/span> moduleModel.getExtensionLoader(OrderedPropertiesProvider.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">&amp;gt;&lt;/span> propertiesProviderNames &lt;span style="color:#719e07">=&lt;/span> propertiesProviderExtensionLoader.getSupportedExtensions();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isEmpty(propertiesProviderNames)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>OrderedPropertiesProvider&lt;span style="color:#719e07">&amp;gt;&lt;/span> orderedPropertiesProviders &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (String propertiesProviderName : propertiesProviderNames) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> orderedPropertiesProviders.add(propertiesProviderExtensionLoader.getExtension(propertiesProviderName));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//order the propertiesProvider according the priority descending&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//根据优先级进行排序，值越小优先级越高&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> orderedPropertiesProviders.sort((a, b) &lt;span style="color:#719e07">-&amp;gt;&lt;/span> b.priority() &lt;span style="color:#719e07">-&lt;/span> a.priority());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//override the properties. 目前没看到有具体的扩展实现&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (OrderedPropertiesProvider orderedPropertiesProvider : orderedPropertiesProviders) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> properties.putAll(orderedPropertiesProvider.initProperties());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原文： &lt;a href="https://blog.elastic.link/2022/07/10/dubbo/3-kuang-jia-ying-yong-cheng-xu-mo-kuai-ling-yu-mo-xing-model-dui-xiang-de-chu-shi-hua/">&amp;laquo;框架,应用程序,模块领域模型Model对象的初始化&amp;raquo;&lt;/a>&lt;/p></description></item><item><title>Blog: 02-启动服务前服务配置ServiceConfig类型是如何初始化的?</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/02/02-%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%89%8D%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AEserviceconfig%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84/</link><pubDate>Tue, 02 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/02/02-%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%89%8D%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AEserviceconfig%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84/</guid><description>
&lt;h1 id="2-启动服务前服务配置serviceconfig类型是如何初始化的">2-启动服务前服务配置ServiceConfig类型是如何初始化的?&lt;/h1>
&lt;h2 id="21-示例源码回顾">2.1 示例源码回顾:&lt;/h2>
&lt;p>为了方便我们理解记忆,这里先来回顾下上一章我们说的示例代码,如下所示:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">Application&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>(String&lt;span style="color:#719e07">[]&lt;/span> args) &lt;span style="color:#268bd2">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startWithBootstrap();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">startWithBootstrap&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServiceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>DemoServiceImpl&lt;span style="color:#719e07">&amp;gt;&lt;/span> service &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ServiceConfig&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> service.setInterface(DemoService.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> service.setRef(&lt;span style="color:#719e07">new&lt;/span> DemoServiceImpl());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DubboBootstrap bootstrap &lt;span style="color:#719e07">=&lt;/span> DubboBootstrap.getInstance();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bootstrap.application(&lt;span style="color:#719e07">new&lt;/span> ApplicationConfig(&lt;span style="color:#2aa198">&amp;#34;dubbo-demo-api-provider&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .registry(&lt;span style="color:#719e07">new&lt;/span> RegistryConfig(&lt;span style="color:#2aa198">&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .protocol(&lt;span style="color:#719e07">new&lt;/span> ProtocolConfig(CommonConstants.DUBBO, &lt;span style="color:#719e07">-&lt;/span>1))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .service(service)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .start()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .await();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面这几行代码虽然看似简单,仅仅几行的启动,但是完全掌握也得下一翻大功夫,接下来我们重点看启动代码中的第一行,创建一个服务配置对象:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ServiceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>DemoServiceImpl&lt;span style="color:#719e07">&amp;gt;&lt;/span> service &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ServiceConfig&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="22-了解一下服务配置的建模">2.2 了解一下服务配置的建模&lt;/h2>
&lt;p>下面是一个简单的UML继承关系图,当然这个图很是简单的,这里仅仅列出了当前服务提供者的相关服务配置继承关系, 服务提供者独有的配置标注颜色为蓝色,一些可能与服务引用配置所共有的父类型我们用红色背景,当然这里为了简便起见不会提起服务引用相关的配置类型,这里列举了如下服务提供者类型,他们各司其职:
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/2-ServiceConfig.png" alt="在这里插入图片描述">&lt;/p>
&lt;center>图2.1 服务引用类继承关系UML&lt;/center>
&lt;ul>
&lt;li>AbstractConfig
&lt;ul>
&lt;li>&lt;strong>抽象的配置类型&lt;/strong>,也是最顶层的服务配置类型,封装着解析配置的实用方法和公共方法,比如服务id的设置,服务标签名字的处理,服务参数的添加,属性的提取等等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>AbstractMethodConfig
&lt;ul>
&lt;li>&lt;strong>抽象的方法配置&lt;/strong>,同样这个类型也是见名知意,服务方法的相关配置处理,这个类型主要用于对服务方法的一些配置信息建模比如服务方法的调用超时时间,重试次数,最大并发调用数,负载均衡策略,是否异步调用,是否确认异步发送等等配置信息.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>AbstractInterfaceConfig
&lt;ul>
&lt;li>&lt;strong>抽象的接口配置&lt;/strong>,与前面介绍的方法配置类似,这个类型是对服务接口的建模,主要的配置信息有暴漏服务的接口名字,服务接口的版本号,客户/提供方将引用的远程服务分组,&lt;strong>服务元数据&lt;/strong>,服务接口的本地impl类名,服务监控配置,对于生成动态代理的策略，可以选择两种策略：jdk和javassist,容错类型等等配置&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>AbstractServiceConfig
&lt;ul>
&lt;li>&lt;strong>抽象的服务配置&lt;/strong>,这个就与我们的服务提供者有了具体的关系了,主要记录了一些服务提供者的公共配置,如服务版本,服务分组,服务延迟注册毫秒数,是否暴漏服务,服务权重,是否为动态服务,服务协议类型,是否注册等等.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ServiceConfigBase
&lt;ul>
&lt;li>&lt;strong>服务的基础配置类&lt;/strong>,这个类型仍旧是个抽象的类型提取了一些基础的配置:导出服务的接口类,服务名称,接口实现的引用类型,提供者配置,是否是通用服务GenericService&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ServiceConfig
&lt;ul>
&lt;li>&lt;strong>服务配置实现类&lt;/strong>, 上面的类型都是抽象类型不能做为具体存在的事物,这个类型是我们出现的第一个服务配置实现类型,服务配置实现类已经从父类型中继承了这么多的属性,这里主要为实现服务提供了一些配置如服务的协议配置,服务的代理工厂JavassistProxyFactory是将生成导出服务代理的ProxyFactory实现，是其默认实现,服务提供者模型,是否导出服务,导出的服务列表,服务监听器等等.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ServiceBean
&lt;ul>
&lt;li>&lt;strong>服务工厂Bean&lt;/strong> ,这个主要是Spring模块来简化配置的一个服务工厂Bean这里就先不详细介绍Spring相关的配置.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="23-serviceconfig构造器的初始化调用链">2.3 ServiceConfig构造器的初始化调用链&lt;/h2>
&lt;p>有了上面的类型继承关系我们就比较好分析了,接下来我们开始创建服务配置对象如下代码所示:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ServiceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>DemoServiceImpl&lt;span style="color:#719e07">&amp;gt;&lt;/span> service &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ServiceConfig&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>根据Java基础的构造器知识,在每个构造器的第一行都会有个super方法来调用父类的构造器,当前这个super方法我们可以不写但是Java编译器底层还是会为我们默认加上这么一行super()代码来调用父类构造器的.&lt;/p>
&lt;p>对于上面我提到的这几个构造器&lt;strong>根据代码被调用的先后顺序&lt;/strong>,这里重点说几个重要的,这里我仍旧按代码执行的先后顺序来说:&lt;/p>
&lt;h3 id="231-父类型abstractmethodconfig构造器的初始化">2.3.1 父类型AbstractMethodConfig构造器的初始化&lt;/h3>
&lt;p>根据super调用链这里先来看AbstractMethodConfig抽象方法配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">AbstractMethodConfig&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>(ApplicationModel.defaultModel().getDefaultModule());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个构造器中只有个super方法用来调用父类型的构造器,但是在调用之前会先使用代码 &lt;strong>ApplicationModel.defaultModel().getDefaultModule()&lt;/strong> 创建一个模块模型对象&lt;strong>ModuleModel&lt;/strong>
关于模型对象的细节我们会在下个章节来说,这里我们继续来看调用链&lt;/p>
&lt;h3 id="232-最顶层类型abstractconfig构造器的初始化">2.3.2 最顶层类型AbstractConfig构造器的初始化&lt;/h3>
&lt;p>&lt;strong>AbstractConfig&lt;/strong>的构造器初始化一共有两个,第一个步骤就是创建一个应用程序模型对象&lt;strong>ApplicationModel&lt;/strong>,刚刚我们在&lt;strong>AbstractMethodConfig&lt;/strong>的构造器中了解到使用这个代码&lt;strong>ApplicationModel.defaultModel().getDefaultModule()&lt;strong>创建了个模块模型对象&lt;/strong>ModuleModel&lt;/strong>,具体他们细节我们下一章细说,了解了子类型&lt;strong>AbstractMethodConfig&lt;/strong>的构造器是带参数的那我们就直接看第二个构造器&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">AbstractConfig&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>(ApplicationModel.defaultModel());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将会调用第二个构造器初始化域模型&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">AbstractConfig&lt;/span>(ScopeModel scopeModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.setScopeModel(scopeModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当前类型设置ScopeModel类型对象&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">final&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">setScopeModel&lt;/span>(ScopeModel scopeModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//第一次初始化的当前成员变量是空的可以设置变量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">this&lt;/span>.scopeModel &lt;span style="color:#719e07">!=&lt;/span> scopeModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//检查参数是否合法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkScopeModel(scopeModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ScopeModel oldScopeModel &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.scopeModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.scopeModel &lt;span style="color:#719e07">=&lt;/span> scopeModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// reinitialize spi extension and change referenced config&amp;#39;s scope model &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//被子类重写的方法,根据多态会调用具体子类型的这个方法我们下面来看&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//子类应该重写此方法以初始化其SPI扩展并更改引用的配置的范围模型。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.postProcessAfterScopeModelChanged(oldScopeModel, &lt;span style="color:#719e07">this&lt;/span>.scopeModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>检查ScopeModel参数是否合法,合法的参数是不能为空并且必须是ApplicationModel类型或者子类型&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">checkScopeModel&lt;/span>(ScopeModel scopeModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (scopeModel &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException(&lt;span style="color:#2aa198">&amp;#34;scopeModel cannot be null&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">!&lt;/span>(scopeModel &lt;span style="color:#719e07">instanceof&lt;/span> ApplicationModel)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException(&lt;span style="color:#2aa198">&amp;#34;Invalid scope model, expect to be a ApplicationModel but got: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> scopeModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2321-重写的postprocessafterscopemodelchanged调用逻辑">2.3.2.1 重写的postProcessAfterScopeModelChanged调用逻辑&lt;/h4>
&lt;p>当ScopeModel模型对象发生了改变,上面调用了postProcessAfterScopeModelChanged方法来通知模型对象改变的时候要执行的操作,根据多态重写的逻辑我们从实现类的postProcessAfterScopeModelChanged来看,在下面的调用链路中部分父类型并未实现postProcessAfterScopeModelChanged方法我们就直接忽略了&lt;/p>
&lt;p>第一个被调用到的是&lt;strong>ServiceConfig&lt;/strong>类型的postProcessAfterScopeModelChanged方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">postProcessAfterScopeModelChanged&lt;/span>(ScopeModel oldScopeModel, ScopeModel newScopeModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>.postProcessAfterScopeModelChanged(oldScopeModel, newScopeModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化当前协议对象,通过扩展机制获取协议Protocol类型的对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> protocolSPI &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.getExtensionLoader(Protocol.class).getAdaptiveExtension();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//初始化当前代理工厂对象,通过扩展机制获取ProxyFactory类型的对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> proxyFactory &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第二个被调用到的方法为&lt;strong>ServiceConfigBase&lt;/strong>的postProcessAfterScopeModelChanged方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">postProcessAfterScopeModelChanged&lt;/span>(ScopeModel oldScopeModel, ScopeModel newScopeModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>.postProcessAfterScopeModelChanged(oldScopeModel, newScopeModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//当服务提供者配置对象不为空时候为服务提供者对象设置域模型,这里服务提供者对象仍旧为空,这个一般用在兼容Dubbo低版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">this&lt;/span>.provider &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.provider.getScopeModel() &lt;span style="color:#719e07">!=&lt;/span> scopeModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.provider.setScopeModel(scopeModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第三个被调用到的是&lt;strong>AbstractInterfaceConfig&lt;/strong>类型的postProcessAfterScopeModelChanged方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">postProcessAfterScopeModelChanged&lt;/span>(ScopeModel oldScopeModel, ScopeModel newScopeModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">super&lt;/span>.postProcessAfterScopeModelChanged(oldScopeModel, newScopeModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// remove this config from old ConfigManager&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// if (oldScopeModel != null &amp;amp;&amp;amp; oldScopeModel instanceof ModuleModel) {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// ((ModuleModel)oldScopeModel).getConfigManager().removeConfig(this);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// change referenced config&amp;#39;s scope model&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//获取应用程序模型对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ApplicationModel applicationModel &lt;span style="color:#719e07">=&lt;/span> ScopeModelUtil.getApplicationModel(scopeModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//为配置中心对象设置ApplicationModel类型对象(当前阶段配置中心配置对象为空)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">this&lt;/span>.configCenter &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.configCenter.getScopeModel() &lt;span style="color:#719e07">!=&lt;/span> applicationModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.configCenter.setScopeModel(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//为元数据配置对象设置ApplicationModel类型对象(当前阶段数据配置配置对象为空)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">this&lt;/span>.metadataReportConfig &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.metadataReportConfig.getScopeModel() &lt;span style="color:#719e07">!=&lt;/span> applicationModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.metadataReportConfig.setScopeModel(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//为MonitorConfig服务监控配置对象设置ApplicationModel类型对象(当前阶段数据配置配置对象为空)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">this&lt;/span>.monitor &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.monitor.getScopeModel() &lt;span style="color:#719e07">!=&lt;/span> applicationModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.monitor.setScopeModel(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//这个if判断和上面的上面是重复的估计是写代码人加班加的太久了,没注意看&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (&lt;span style="color:#719e07">this&lt;/span>.metadataReportConfig &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#719e07">this&lt;/span>.metadataReportConfig.getScopeModel() &lt;span style="color:#719e07">!=&lt;/span> applicationModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.metadataReportConfig.setScopeModel(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//如果注册中心配置列表不为空则为每个注册中心配置设置一个ApplicationModel类型对象(当前注册中心对象都为空)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isNotEmpty(&lt;span style="color:#719e07">this&lt;/span>.registries)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.registries.forEach(registryConfig &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (registryConfig.getScopeModel() &lt;span style="color:#719e07">!=&lt;/span> applicationModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registryConfig.setScopeModel(applicationModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后被调用到的是最顶层父类型&lt;strong>AbstractConfig&lt;/strong>的postProcessAfterScopeModelChanged方法
这个方法什么也没干只是在父类型创建的模版方法让子类型来重写用的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">protected&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">postProcessAfterScopeModelChanged&lt;/span>(ScopeModel oldScopeModel, ScopeModel newScopeModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// remove this config from old ConfigManager&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// if (oldScopeModel != null &amp;amp;&amp;amp; oldScopeModel instanceof ApplicationModel) {&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// ((ApplicationModel)oldScopeModel).getApplicationConfigManager().removeConfig(this);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="233-serviceconfigbase构造器的初始化">2.3.3 ServiceConfigBase构造器的初始化&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">ServiceConfigBase&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//服务元数据对象创建&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceMetadata &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ServiceMetadata();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//为服务元数据对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceMetadata.addAttribute(&lt;span style="color:#2aa198">&amp;#34;ORIGIN_CONFIG&amp;#34;&lt;/span>, &lt;span style="color:#719e07">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>注意，&lt;/strong> &lt;strong>ServiceMetadata&lt;/strong>这个类目前在Dubbo中没有用法。与服务级别相关的数据，例如名称、版本、业务服务的类加载器、安全信息等，还带有用于扩展的AttributeMap。&lt;/p>
&lt;p>&lt;strong>服务配置对象的创建过程就这样结束了&lt;/strong>,当然有一些细节会&lt;strong>放到后面来写&lt;/strong>
上面主要顺序是按照代码执行的顺序来写的部分地方可能稍微做了调整,如果有条件的同学一定要&lt;strong>自己进行DEBUG&lt;/strong>了解下细节.&lt;/p>
&lt;p>关于服务配置官网提供了xml的配置信息这里我拷贝过来,可以做为参考:
当然这个配置不是最新的比如服务配置的&lt;strong>标签配置tag&lt;/strong>,
&lt;strong>warmup 预热时间&lt;/strong>单位毫秒,暂时还没有说明&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>属性&lt;/th>
&lt;th>对应URL参数&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>是否必填&lt;/th>
&lt;th>缺省值&lt;/th>
&lt;th>作用&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>兼容性&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>interface&lt;/td>
&lt;td>&lt;/td>
&lt;td>class&lt;/td>
&lt;td>必填&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务接口名&lt;/td>
&lt;td>1.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ref&lt;/td>
&lt;td>&lt;/td>
&lt;td>object&lt;/td>
&lt;td>必填&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务对象实现引用&lt;/td>
&lt;td>1.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>version&lt;/td>
&lt;td>version&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0.0.0&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务版本，建议使用两位数字版本，如：1.0，通常在接口不兼容时版本号才需要升级&lt;/td>
&lt;td>1.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>group&lt;/td>
&lt;td>group&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务分组，当一个接口有多个实现，可以用分组区分&lt;/td>
&lt;td>1.0.7以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>path&lt;/td>
&lt;td>&lt;code>&amp;lt;path&amp;gt;&lt;/code>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省为接口名&lt;/td>
&lt;td>服务发现&lt;/td>
&lt;td>服务路径 (注意：1.0不支持自定义路径，总是使用接口名，如果有1.0调2.0，配置服务路径可能不兼容)&lt;/td>
&lt;td>1.0.12以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>delay&lt;/td>
&lt;td>delay&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>延迟注册服务时间(毫秒) ，设为-1时，表示延迟到Spring容器初始化完成时暴露服务&lt;/td>
&lt;td>1.0.14以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>timeout&lt;/td>
&lt;td>timeout&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>1000&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>远程服务调用超时时间(毫秒)&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>retries&lt;/td>
&lt;td>retries&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>2&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>远程服务调用重试次数，不包括第一次调用，不需要重试请设为0&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>connections&lt;/td>
&lt;td>connections&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>100&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>对每个提供者的最大连接数，rmi、http、hessian等短连接协议表示限制连接数，dubbo等长连接协表示建立的长连接个数&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>loadbalance&lt;/td>
&lt;td>loadbalance&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>random&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>async&lt;/td>
&lt;td>async&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>是否缺省异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>local&lt;/td>
&lt;td>local&lt;/td>
&lt;td>class/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>设为true，表示使用缺省代理类名，即：接口名 + Local后缀，已废弃，请使用stub&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>stub&lt;/td>
&lt;td>stub&lt;/td>
&lt;td>class/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>设为true，表示使用缺省代理类名，即：接口名 + Stub后缀，服务接口客户端本地代理类名，用于在客户端执行本地逻辑，如本地缓存等，该本地代理类的构造函数必须允许传入远程代理对象，构造函数如：public XxxServiceStub(XxxService xxxService)&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>mock&lt;/td>
&lt;td>mock&lt;/td>
&lt;td>class/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>设为true，表示使用缺省Mock类名，即：接口名 + Mock后缀，服务接口调用失败Mock实现类，该Mock类必须有一个无参构造函数，与Local的区别在于，Local总是被执行，而Mock只在出现非业务异常(比如超时，网络异常等)时执行，Local在远程调用之前执行，Mock在远程调用后执行。&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>token&lt;/td>
&lt;td>token&lt;/td>
&lt;td>string/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>令牌验证，为空表示不开启，如果为true，表示随机生成动态令牌，否则使用静态令牌，令牌的作用是防止消费者绕过注册中心直接访问，保证注册中心的授权功能有效，如果使用点对点调用，需关闭令牌功能&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>registry&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省向所有registry注册&lt;/td>
&lt;td>配置关联&lt;/td>
&lt;td>向指定注册中心注册，在多个注册中心时使用，值为&lt;a href="dubbo:registry">dubbo:registry&lt;/a>的id属性，多个注册中心ID用逗号分隔，如果不想将该服务注册到任何registry，可将值设为N/A&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>provider&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>缺省使用第一个provider配置&lt;/td>
&lt;td>配置关联&lt;/td>
&lt;td>指定provider，值为&lt;a href="dubbo:provider">dubbo:provider&lt;/a>的id属性&lt;/td>
&lt;td>2.0.0以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>deprecated&lt;/td>
&lt;td>deprecated&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务是否过时，如果设为true，消费方引用时将打印服务过时警告error日志&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>dynamic&lt;/td>
&lt;td>dynamic&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务是否动态注册，如果设为false，注册后将显示后disable状态，需人工启用，并且服务提供者停止时，也不会自动取消册，需人工禁用。 2.0.5以上版本&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>accesslog&lt;/td>
&lt;td>accesslog&lt;/td>
&lt;td>string/boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>false&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>设为true，将向logger中输出访问日志，也可填写访问日志文件路径，直接把访问日志输出到指定文件&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>owner&lt;/td>
&lt;td>owner&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务负责人，用于服务治理，请填写负责人公司邮箱前缀&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>document&lt;/td>
&lt;td>document&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务文档URL&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>weight&lt;/td>
&lt;td>weight&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务权重&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>executes&lt;/td>
&lt;td>executes&lt;/td>
&lt;td>int&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>0&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务提供者每服务每方法最大可并行执行请求数&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>proxy&lt;/td>
&lt;td>proxy&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>javassist&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>生成动态代理方式，可选：jdk/javassist&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cluster&lt;/td>
&lt;td>cluster&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>failover&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>集群方式，可选：failover/failfast/failsafe/failback/forking&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>filter&lt;/td>
&lt;td>service.filter&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>default&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务提供方远程调用过程拦截器名称，多个名称用逗号分隔&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>listener&lt;/td>
&lt;td>exporter.listener&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>default&lt;/td>
&lt;td>性能调优&lt;/td>
&lt;td>服务提供方导出服务监听器名称，多个名称用逗号分隔&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>protocol&lt;/td>
&lt;td>&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>&lt;/td>
&lt;td>配置关联&lt;/td>
&lt;td>使用指定的协议暴露服务，在多协议时使用，值为&lt;a href="dubbo:protocol">dubbo:protocol&lt;/a>的id属性，多个协议ID用逗号分隔&lt;/td>
&lt;td>2.0.5以上版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>layer&lt;/td>
&lt;td>layer&lt;/td>
&lt;td>string&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>服务提供者所在的分层。如：biz、dao、intl:web、china:acton。&lt;/td>
&lt;td>2.0.7以上版本&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>register&lt;/td>
&lt;td>register&lt;/td>
&lt;td>boolean&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>true&lt;/td>
&lt;td>服务治理&lt;/td>
&lt;td>该协议的服务是否注册到注册中心&lt;/td>
&lt;td>2.0.8以上版本&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>原文： &lt;a href="https://blog.elastic.link/2022/07/10/dubbo/2-qi-dong-fu-wu-qian-fu-wu-pei-zhi-serviceconfig-lei-xing-shi-ru-he-chu-shi-hua-de/">&amp;laquo;ServiceConfig对象的建模&amp;raquo;&lt;/a>&lt;/p></description></item><item><title>Blog: 01 从一个服务提供者的Demo说起</title><link>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/01/01-%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E7%9A%84demo%E8%AF%B4%E8%B5%B7/</link><pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate><guid>https://cn.dubbo.apache.org/zh-cn/blog/2022/08/01/01-%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E7%9A%84demo%E8%AF%B4%E8%B5%B7/</guid><description>
&lt;h1 id="1-从一个服务提供者的demo说起">1 从一个服务提供者的Demo说起&lt;/h1>
&lt;p>为了更方便了解原理,我们先来编写一个Demo,从例子中来看源码实现:&lt;/p>
&lt;h2 id="11-启动zookeeper">1.1 启动Zookeeper&lt;/h2>
&lt;p>为了Demo可以正常启动,需要我们先在本地启动一个Zookeeper如下图所示:
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/1-zookeeper.png" alt="在这里插入图片描述">&lt;/p>
&lt;h2 id="12-服务提供者">1.2 服务提供者&lt;/h2>
&lt;p>接下来给大家贴一下示例源码,这个源码来源于Dubbo源码目录的 dubbo-demo/dubbo-demo-api 目录下面的dubbo-demo-api-provider子项目,这里我做了删减,方便看核心代码:
首先我们定义一个服务接口如下所示:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> java.util.concurrent.CompletableFuture;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">DemoService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * 同步处理的服务方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param name
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @return
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String &lt;span style="color:#268bd2">sayHello&lt;/span>(String name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * 用于异步处理的服务方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @param name
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> * @return
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">default&lt;/span> CompletableFuture&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">sayHelloAsync&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> CompletableFuture.completedFuture(sayHello(name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>服务实现类如下:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.RpcContext;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.slf4j.Logger;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.slf4j.LoggerFactory;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> java.util.concurrent.CompletableFuture;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">DemoServiceImpl&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> DemoService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#268bd2">final&lt;/span> Logger logger &lt;span style="color:#719e07">=&lt;/span> LoggerFactory.getLogger(DemoServiceImpl.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> String &lt;span style="color:#268bd2">sayHello&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#2aa198">&amp;#34;Hello &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> name &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, request from consumer: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> RpcContext.getServiceContext().getRemoteAddress());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Hello &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> name &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, response from provider: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> RpcContext.getServiceContext().getLocalAddress();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> CompletableFuture&lt;span style="color:#719e07">&amp;lt;&lt;/span>String&lt;span style="color:#719e07">&amp;gt;&lt;/span> &lt;span style="color:#268bd2">sayHelloAsync&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="13-启用服务">1.3 启用服务&lt;/h2>
&lt;p>有了服务接口之后我们来启用服务,启用服务的源码如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.common.constants.CommonConstants;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.config.ApplicationConfig;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.config.MetadataReportConfig;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.config.ProtocolConfig;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.config.RegistryConfig;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.config.ServiceConfig;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.config.bootstrap.DubboBootstrap;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.demo.DemoService;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">Application&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">main&lt;/span>(String&lt;span style="color:#719e07">[]&lt;/span> args) &lt;span style="color:#268bd2">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startWithBootstrap();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">startWithBootstrap&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServiceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>DemoServiceImpl&lt;span style="color:#719e07">&amp;gt;&lt;/span> service &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ServiceConfig&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> service.setInterface(DemoService.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> service.setRef(&lt;span style="color:#719e07">new&lt;/span> DemoServiceImpl());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DubboBootstrap bootstrap &lt;span style="color:#719e07">=&lt;/span> DubboBootstrap.getInstance();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bootstrap.application(&lt;span style="color:#719e07">new&lt;/span> ApplicationConfig(&lt;span style="color:#2aa198">&amp;#34;dubbo-demo-api-provider&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .registry(&lt;span style="color:#719e07">new&lt;/span> RegistryConfig(&lt;span style="color:#2aa198">&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .protocol(&lt;span style="color:#719e07">new&lt;/span> ProtocolConfig(CommonConstants.DUBBO, &lt;span style="color:#719e07">-&lt;/span>1))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .service(service)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .start()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .await();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="14-启用服务后写入zookeeper的节点数据">1.4 启用服务后写入Zookeeper的节点数据&lt;/h2>
&lt;p>启动服务,这个时候我们打开Zookeeper图形化客户端来看看这个服务在Zookeeper上面写入来哪些数据,如下图:
&lt;img src="https://cn.dubbo.apache.org/imgs/blog/source-blog/1-zookeeper-data.png" alt="在这里插入图片描述">
写入Zookeper上的节点用于服务在分布式场景下的协调,这些节点是比较重要的。&lt;/p>
&lt;p>如果了解过Dubbo的同学,应该会知道Dubbo在低版本的时候会向注册中心中写入服务接口,具体路径在上面的 &lt;strong>dubbo目录下&lt;/strong> ,然后在 &lt;strong>/dubbo/服务接口/&lt;/strong> 路径下写入如下信息:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>服务提供者&lt;/strong>配置信息URL形式&lt;/li>
&lt;li>&lt;strong>服务消费者&lt;/strong>的配置信息URL形式&lt;/li>
&lt;li>服务&lt;strong>路由信息&lt;/strong>&lt;/li>
&lt;li>&lt;strong>配置信息&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>上面这个图就是Dubbo3的注册信息了,后面我们也会围绕细节来说明下,这里可以看下新增了:&lt;/p>
&lt;ul>
&lt;li>/dubbo/metadata &lt;strong>元数据信息&lt;/strong>&lt;/li>
&lt;li>/dubbo/mapping 服务和应用的&lt;strong>映射信息&lt;/strong>&lt;/li>
&lt;li>/dubbo/config &lt;strong>注册中心配置&lt;/strong>&lt;/li>
&lt;li>/services目录&lt;strong>应用信息&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>在这里可以大致了解下,在后面会有更详细的源码解析这个示例代码.通过透析代码来看透Dubbo3服务注册原理,服务提供原理。&lt;/p>
&lt;p>原文： &lt;a href="https://blog.elastic.link/2022/07/10/dubbo/1-cong-yi-ge-demo-shuo-qi/">&amp;laquo;从一个服务提供者的Demo说起&amp;raquo;&lt;/a>&lt;/p></description></item></channel></rss>