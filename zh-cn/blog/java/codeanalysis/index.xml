<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>源码分析 on Apache Dubbo</title><link>https://dubbo.apache.org/zh-cn/blog/java/codeanalysis/</link><description>Recent content in 源码分析 on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://dubbo.apache.org/zh-cn/blog/java/codeanalysis/index.xml" rel="self" type="application/rss+xml"/><item><title>Dubbo 3 中的三层配置隔离</title><link>https://dubbo.apache.org/zh-cn/blog/1/01/01/dubbo-3-%E4%B8%AD%E7%9A%84%E4%B8%89%E5%B1%82%E9%85%8D%E7%BD%AE%E9%9A%94%E7%A6%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/1/01/01/dubbo-3-%E4%B8%AD%E7%9A%84%E4%B8%89%E5%B1%82%E9%85%8D%E7%BD%AE%E9%9A%94%E7%A6%BB/</guid><description>Models提供的隔离 Dubbo目前提供了三个级别上的隔离：JVM级别、应用级别、服务(模块)级别，从而实现各个级别上的生命周期及配置信息的单独管理。这三个层次上的隔离由 FrameworkModel、ApplicationModel 和 ModuleModel 及它们对应的 Config 来完成。
FrameworkModel ：Dubbo 框架的顶级模型，表示 Dubbo 框架的全局运行环境，适配多应用混合部署的场景，降低资源成本。
如：假设我们有一个在线教育平台，平台下有多个租户，而我们希望使这些租户的服务部署在同一个 JVM 上以节省资源，但它们之间可能使用不同的注册中心、监控设施、协议等，因此我们可以为每个租户分配一个 FrameWorkModel 实例来实现这种隔离。
FrameworkModel负责管理整个Dubbo框架的各种全局配置、元数据以及默认配置。
ApplicationModel ：应用程序级别模型，表示一个 Dubbo 应用（通常为一个 SpringApplication）。适配单JVM多应用场景，通常结合热发布使用，降低热发布对整个应用的影响范围。
如，以上的在线教育平台有多个子系统，如课程管理、学生管理，而每个子系统都是独立的 Spring 应用，在同个 JVM 中运行，共享一个 FrameworkModel，也会共享 Framework 级别的默认配置和资源：
//课程管理应用 @SpringBootApplication public class ClassApplication { private static ApplicationModel classAppModel; public static void main(String[] args) { classAppModel .getApplicationConfigManager() .addRegistry(new RegistryConfig(REGISTRY_URL_CLASS)); //...其它设置 SpringApplication.run(ClassApplication.class, args); } public static void setApplicationModel(ApplicationModel classAppModel){ this.classAppModel = classAppModel; } } //学生管理应用 @SpringBootApplication public class StudentApplication { private static ApplicationModel studentAppModel; public static void main(String[] args) { studentAppModel .</description></item><item><title>Dubbo 3 之 Triple 流控反压原理解析</title><link>https://dubbo.apache.org/zh-cn/blog/2022/12/28/dubbo-3-%E4%B9%8B-triple-%E6%B5%81%E6%8E%A7%E5%8F%8D%E5%8E%8B%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</link><pubDate>Wed, 28 Dec 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/12/28/dubbo-3-%E4%B9%8B-triple-%E6%B5%81%E6%8E%A7%E5%8F%8D%E5%8E%8B%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</guid><description>Triple 是 Dubbo 3 提出的基于 HTTP2 的开放协议， 旨在解决 Dubbo 2 私有协议带来的互通性问题。 Triple 基于 HTTP/2 定制自己的流控，支持通过特定的异常通知客户端业务层服务端负载高情况， 保护了服务端被大流量击垮，提高系统高可用能力。
一、流控反压现状 客户端和服务器端在接收数据的时候有一个缓冲区来临时存储数据， 但是缓冲区的大小是有限制的，所以有可能会出现缓冲区溢出的情况， HTTP 通过流控保护数据溢出丢失风险。
1、HTTP/1 流控 在 HTTP/1.1 中，流量的控制依赖的是底层TCP协议，在客户端和服务器端建立连接的时候， 会使用系统默认的设置来建立缓冲区。在数据进行通信的时候，会告诉对方它的接收窗口的大小， 这个接收窗口就是缓冲区中剩余的可用空间。如果接收窗口大小为零，则说明接收方缓冲区已满， 则发送方将不再发送数据，直到客户端清除其内部缓冲区，然后请求恢复数据传输。
2、HTTP/2 流控 HTTP/2 使用了多路复用机制，一个TCP连接可以有多个 HTTP/2 连接， 故在 HTTP/2 中，有更加精细的流控制机制，允许服务端实现自己数据流和连接级的流控制。 服务端与客户端第一次连接时，会通过发送 HTTP/2 SettingsFrame设置初始化的流控窗口大小， 用于 Stream 级别流控，默认为 65,535 字节。 定好流控窗口后，每次客户端发送数据就会减少流控窗口的大小， 服务端收到数据后会发送窗口更新包（WINDOW_UPDATE frame）通知客户端更新窗口。 客户端收到窗口更新包后就会增加对应值的流控窗口，从而达到动态控制的目的。
二、Triple流控反压 Netty 基于 HTTP/2 实现了基础的流控，当服务端负载过高，客户端发送窗口为 0 时， 新增请求就无法被发送出去，会在缓存到客户端待发送请求队列中，缓存数据过大， 就会造成客户端内存溢出，影响业务程序。
Triple 基于 Netty 实现了 HTTP/2 协议，通过 HTTP/2 FlowController接口统一封装， 在实现分为进站（inbound）和出站（outbound）两个维度的实现。 Triple 在 inbound 流量上使用了 Netty 的默认流控实现， 在 outbound 上实现了自己流控，基于服务端负载， 将服务端流量压力透传到客户端业务层，实现客户端的业务反压，暂停业务继续发送请求， 保护服务端不被大流量击垮。</description></item><item><title>Triple 协议支持 Java 异常回传的设计与实现</title><link>https://dubbo.apache.org/zh-cn/blog/2022/12/19/triple-%E5%8D%8F%E8%AE%AE%E6%94%AF%E6%8C%81-java-%E5%BC%82%E5%B8%B8%E5%9B%9E%E4%BC%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link><pubDate>Mon, 19 Dec 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/12/19/triple-%E5%8D%8F%E8%AE%AE%E6%94%AF%E6%8C%81-java-%E5%BC%82%E5%B8%B8%E5%9B%9E%E4%BC%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid><description>背景 在一些业务场景, 往往需要自定义异常来满足特定的业务, 主流用法是在catch里抛出异常, 例如：
public void deal() { try{ //doSomething ... } catch(IGreeterException e) { ... throw e; } } 或者通过ExceptionBuilder，把相关的异常对象返回给consumer：
provider.send(new ExceptionBuilders.IGreeterExceptionBuilder() .setDescription(&amp;#39;异常描述信息&amp;#39;); 在抛出异常后, 通过捕获和instanceof来判断特定的异常, 然后做相应的业务处理，例如：
try { greeterProxy.echo(REQUEST_MSG); } catch (IGreeterException e) { //做相应的处理 ... } 在 Dubbo 2.x 版本，可以通过上述方法来捕获 Provider 端的异常。 而随着云原生时代的到来， Dubbo 也开启了 3.0 的里程碑。
Dubbo 3.0 的一个很重要的目标就是全面拥抱云原生， 在 3.0 的许多特性中，很重要的一个改动就是支持新的一代Rpc协议Triple。
Triple 协议基于 HTTP 2.0 进行构建，对网关的穿透性强，兼容 gRPC， 提供 Request Response、Request Streaming、Response Streaming、 Bi-directional Streaming 等通信模型； 从 Triple 协议开始，Dubbo 还支持基于 IDL 的服务定义。</description></item><item><title>浅析 Dubbo 3.0 中接口级地址推送性能的优化</title><link>https://dubbo.apache.org/zh-cn/blog/2022/06/23/%E6%B5%85%E6%9E%90-dubbo-3.0-%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%BA%A7%E5%9C%B0%E5%9D%80%E6%8E%A8%E9%80%81%E6%80%A7%E8%83%BD%E7%9A%84%E4%BC%98%E5%8C%96/</link><pubDate>Thu, 23 Jun 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/06/23/%E6%B5%85%E6%9E%90-dubbo-3.0-%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%BA%A7%E5%9C%B0%E5%9D%80%E6%8E%A8%E9%80%81%E6%80%A7%E8%83%BD%E7%9A%84%E4%BC%98%E5%8C%96/</guid><description>URL 简介 在阐述地址推送性能的具体优化之前，我们有必要先了解一下与之息息相关的内容 &amp;mdash; URL。
定义 在不谈及 dubbo 时，我们大多数人对 URL 这个概念并不会感到陌生。统一资源定位器 (RFC1738――Uniform Resource Locators (URL))应该是最广为人知的一个 RFC 规范，它的定义也非常简单。
因特网上的可用资源可以用简单字符串来表示，该文档就是描述了这种字符串的语法和语 义。而这些字符串则被称为：“统一资源定位器”（URL）
一个标准的 URL 格式至多可以包含如下的几个部分
protocol://username:password@host:port/path?key=value&amp;amp;key=value 一些典型 URL
http://www.facebook.com/friends?param1=value1&amp;amp;amp;param2=value2 https://username:password@10.20.130.230:8080/list?version=1.0.0 ftp://username:password@192.168.1.7:21/1/read.txt 当然，也有一些不太符合常规的 URL，也被归类到了 URL 之中
192.168.1.3:20880 url protocol = null, url host = 192.168.1.3, port = 20880, url path = null file:///home/user1/router.js?type=script url protocol = file, url host = null, url path = home/user1/router.js file://home/user1/router.js?type=script&amp;lt;br&amp;gt; url protocol = file, url host = home, url path = user1/router.</description></item><item><title>Dubbo3 应用级服务发现</title><link>https://dubbo.apache.org/zh-cn/blog/2021/06/02/dubbo3-%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</link><pubDate>Wed, 02 Jun 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/06/02/dubbo3-%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</guid><description>1 服务发现（Service Discovery） 概述 从 Internet 刚开始兴起，如何动态感知后端服务的地址变化就是一个必须要面对的问题，为此人们定义了 DNS 协议，基于此协议，调用方只需要记住由固定字符串组成的域名，就能轻松完成对后端服务的访问，而不用担心流量最终会访问到哪些机器 IP，因为有代理组件会基于 DNS 地址解析后的地址列表，将流量透明的、均匀的分发到不同的后端机器上。
在使用微服务构建复杂的分布式系统时，如何感知 backend 服务实例的动态上下线，也是微服务框架最需要关心并解决的问题之一。业界将这个问题称之为 - 微服务的地址发现（Service Discovery），业界比较有代表性的微服务框架如 SpringCloud、Dubbo 等都抽象了强大的动态地址发现能力，并且为了满足微服务业务场景的需求，绝大多数框架的地址发现都是基于自己设计的一套机制来实现，因此在能力、灵活性上都要比传统 DNS 丰富得多。如 SpringCloud 中常用的 Eureka， Dubbo 中常用的 Zookeeper、Nacos 等，这些注册中心实现不止能够传递地址（IP + Port），还包括一些微服务的 Metadata 信息，如实例序列化类型、实例方法列表、各个方法级的定制化配置等。
下图是微服务中 Service Discovery 的基本工作原理图，微服务体系中的实例大概可分为三种角色：服务提供者（Provider）、服务消费者（Consumer）和注册中心（Registry）。而不同框架实现间最主要的区别就体现在注册中心数据的组织：地址如何组织、以什么粒度组织、除地址外还同步哪些数据？
我们今天这篇文章就是围绕这三个角色展开，重点看下 Dubbo 中对于服务发现方案的设计，包括之前老的服务发现方案的优势和缺点，以及 Dubbo 3.0 中正在设计、开发中的全新的面向应用粒度的地址发现方案，我们期待这个新的方案能做到：
支持几十万/上百万级集群实例的地址发现 与不同的微服务体系（如 Spring Cloud）实现在地址发现层面的互通 2 Dubbo 地址发现机制解析 我们先以一个 DEMO 应用为例，来快速的看一下 Dubbo “接口粒度”服务发现与“应用粒度”服务发现体现出来的区别。这里我们重点关注 Provider 实例是如何向注册中心注册的，并且，为了体现注册中心数据量变化，我们观察的是两个 Provider 实例的场景。
应用 DEMO 提供的服务列表如下：
&amp;lt;dubbo:service interface=&amp;#34;org.apache.dubbo.samples.basic.api.DemoService&amp;#34; ref=&amp;#34;demoService&amp;#34;/&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;org.apache.dubbo.samples.basic.api.GreetingService&amp;#34; ref=&amp;#34;greetingService&amp;#34;/&amp;gt; 我们示例注册中心实现采用的是 Zookeeper ，启动 192.</description></item><item><title>Dubbo 中的 URL 统一模型</title><link>https://dubbo.apache.org/zh-cn/blog/2019/10/17/dubbo-%E4%B8%AD%E7%9A%84-url-%E7%BB%9F%E4%B8%80%E6%A8%A1%E5%9E%8B/</link><pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/10/17/dubbo-%E4%B8%AD%E7%9A%84-url-%E7%BB%9F%E4%B8%80%E6%A8%A1%E5%9E%8B/</guid><description>定义 在不谈及 dubbo 时，我们大多数人对 URL 这个概念并不会感到陌生。统一资源定位器 (RFC1738――Uniform Resource Locators (URL)）应该是最广为人知的一个 RFC 规范，它的定义也非常简单
因特网上的可用资源可以用简单字符串来表示，该文档就是描述了这种字符串的语法和语 义。而这些字符串则被称为：“统一资源定位器”（URL）
一个标准的 URL 格式至多可以包含如下的几个部分
protocol://username:password@host:port/path?key=value&amp;amp;key=value 一些典型 URL
http://www.facebook.com/friends?param1=value1&amp;amp;amp;param2=value2 https://username:password@10.20.130.230:8080/list?version=1.0.0 ftp://username:password@192.168.1.7:21/1/read.txt 当然，也有一些不太符合常规的 URL，也被归类到了 URL 之中
192.168.1.3:20880 url protocol = null, url host = 192.168.1.3, port = 20880, url path = null file:///home/user1/router.js?type=script url protocol = file, url host = null, url path = home/user1/router.js file://home/user1/router.js?type=script&amp;lt;br&amp;gt; url protocol = file, url host = home, url path = user1/router.js file:///D:/1/router.js?type=script url protocol = file, url host = null, url path = D:/1/router.</description></item><item><title>发布使用不同协议的多个服务，通过单端口监听</title><link>https://dubbo.apache.org/zh-cn/blog/1/01/01/%E5%8F%91%E5%B8%83%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E9%80%9A%E8%BF%87%E5%8D%95%E7%AB%AF%E5%8F%A3%E7%9B%91%E5%90%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/1/01/01/%E5%8F%91%E5%B8%83%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E9%80%9A%E8%BF%87%E5%8D%95%E7%AB%AF%E5%8F%A3%E7%9B%91%E5%90%AC/</guid><description>通过对protocol进行配置，dubbo3可以支持端口的协议复用。 比如使用Triple协议启动端口复用后，可以在相同的端口上为服务增加 Dubbo协议支持，以及Qos协议支持。这些协议的识别都是由一个统一的端口复用 服务器进行处理的，可以用于服务的协议迁移，并且可以节约端口以及相关的资源，减少运维的复杂性。
在服务的创建阶段，通过从Config层获取到服务导出的协议配置从而创建不同的Protocol对象进行导出。在导出的过程 中，如果不是第一次创建端口复用的Server，那么Exchanger会将Protcol层传递的数据保存到Server，用于后续处理该协议类型的消息。
当客户端的消息传递过来后，首先会通过Server传递给ProtocolDetector，如果完成了识别，那么就会标记该客户端为对应的协议。并通过WireProtocol配置对应的处理逻辑，最后交给ChannelOperator完成底层的IO框架和对应的Dubbo框架的处理逻辑的绑定。
以上的协议识别完成之后，Channel已经确定了如何处理远程的客户端消息，通过对应的ServerPipeline进行处理即可（在处理的过程中也会根据配置信息决定消息的处理线程）。
使用方式 在同一主机上部署多个服务或需要通过负载均衡器访问多个服务。
参考用例 https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-port-unification
配置方式 关于Dubbo支持的配置方式，可以参考配置说明
服务多协议导出 ext-protocol参数支持配置多个不同的协议，协议之间通过&amp;quot;,&amp;ldquo;进行分隔。
xml 配置 &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;-1&amp;#34; ext-protocol=&amp;#34;tri,&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;greetingService&amp;#34; class=&amp;#34;org.apache.dubbo.demo.provider.GreetingServiceImpl&amp;#34;/&amp;gt; &amp;lt;dubbo:service delay=&amp;#34;5000&amp;#34; version=&amp;#34;1.0.0&amp;#34; group=&amp;#34;greeting&amp;#34; timeout=&amp;#34;5000&amp;#34; interface=&amp;#34;org.apache.dubbo.demo.GreetingService&amp;#34; ref=&amp;#34;greetingService&amp;#34; protocol=&amp;#34;dubbo&amp;#34;/&amp;gt; API 配置 ProtocolConfig config = new ProtocolConfig(CommonConstants.TRIPLE, -1); config.setExtProtocol(CommonConstants.DUBBO+&amp;#34;,&amp;#34;); yaml 配置 dubbo: application: name: dubbo-springboot-demo-provider protocol: name: tri port: -1 ext-protocol: dubbo, properties 配置 dubbo.protocol.name=tri dubbo.protocol.ext-protocol=dubbo, dubbo.protocol.port=20880 Qos接入 Qos模块导入 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-qos&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 完成Qos模块的导入之后，相关的配置项可参考Qos操作手册进行配置。
默认情况下，基于端口复用的Qos服务在模块导入后是启动的。
使用方式 Qos使用 将Qos协议接入到端口复用的场景下，需要在建立连接之后，客户端先向服务端发送消息，对比将Qos协议通过单个端口提供服务，端口复用版的Qos协议在处理telnet连接的情况下需要用户执行一些操作，完成协议识别（二选一）。</description></item></channel></rss>