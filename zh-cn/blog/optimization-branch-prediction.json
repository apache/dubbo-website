{
  "filename": "optimization-branch-prediction.md",
  "__html": "<h1>优化技巧：提前if判断帮助CPU分支预测</h1>\n<hr>\n<h2>分支预测</h2>\n<p>在stackoverflow上有一个非常有名的问题：<a href=\"https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array\">为什么处理有序数组要比非有序数组快？</a>，可见分支预测对代码运行效率有非常大的影响。</p>\n<p>现代CPU都支持分支预测(branch prediction)和指令流水线(instruction pipeline)，这两个结合可以极大提高CPU效率。对于像简单的if跳转，CPU是可以比较好地做分支预测的。但是对于switch跳转，CPU则没有太多的办法。switch本质上是据索引，从地址数组里取地址再跳转。</p>\n<p>要提高代码执行效率，一个重要的原则就是尽量避免CPU把流水线清空，那么提高分支预测的成功率就非常重要。</p>\n<p>那么对于代码里，如果某个switch分支概率很高，是否可以考虑代码层面帮CPU把判断提前，来提高代码执行效率呢？</p>\n<h2>Dubbo里ChannelEventRunnable的switch判断</h2>\n<p>在<code>ChannelEventRunnable</code>里有一个switch来判断channel state，然后做对应的逻辑：<a href=\"https://github.com/hengyunabc/incubator-dubbo/blob/dubbo-2.6.1/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/ChannelEventRunnable.java#L54\">查看</a></p>\n<p>一个channel建立起来之后，超过99.9%情况它的state都是<code>ChannelState.RECEIVED</code>，那么可以考虑把这个判断提前。</p>\n<h2>benchmark验证</h2>\n<p>下面通过jmh来验证下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestBenchMarks</span> </span>{\n\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> ChannelState {\n\t\tCONNECTED, DISCONNECTED, SENT, RECEIVED, CAUGHT\n\t}\n\n\t<span class=\"hljs-meta\">@State</span>(Scope.Benchmark)\n\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ExecutionPlan</span> </span>{\n\t\t<span class=\"hljs-meta\">@Param</span>({ <span class=\"hljs-string\">\"1000000\"</span> })\n\t\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> size;\n\t\t<span class=\"hljs-keyword\">public</span> ChannelState[] states = <span class=\"hljs-keyword\">null</span>;\n\n\t\t<span class=\"hljs-meta\">@Setup</span>\n\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setUp</span><span class=\"hljs-params\">()</span> </span>{\n\t\t\tChannelState[] values = ChannelState.values();\n\t\t\tstates = <span class=\"hljs-keyword\">new</span> ChannelState[size];\n\t\t\tRandom random = <span class=\"hljs-keyword\">new</span> Random(<span class=\"hljs-keyword\">new</span> Date().getTime());\n\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; i++) {\n\t\t\t\t<span class=\"hljs-keyword\">int</span> nextInt = random.nextInt(<span class=\"hljs-number\">1000000</span>);\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (nextInt &gt; <span class=\"hljs-number\">100</span>) {\n\t\t\t\t\tstates[i] = ChannelState.RECEIVED;\n\t\t\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\t\t\tstates[i] = values[nextInt % values.length];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t<span class=\"hljs-meta\">@Fork</span>(value = <span class=\"hljs-number\">5</span>)\n\t<span class=\"hljs-meta\">@Benchmark</span>\n\t<span class=\"hljs-meta\">@BenchmarkMode</span>(Mode.Throughput)\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">benchSiwtch</span><span class=\"hljs-params\">(ExecutionPlan plan, Blackhole bh)</span> </span>{\n\t\t<span class=\"hljs-keyword\">int</span> result = <span class=\"hljs-number\">0</span>;\n\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; plan.size; ++i) {\n\t\t\t<span class=\"hljs-keyword\">switch</span> (plan.states[i]) {\n\t\t\t<span class=\"hljs-keyword\">case</span> CONNECTED:\n\t\t\t\tresult += ChannelState.CONNECTED.ordinal();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t<span class=\"hljs-keyword\">case</span> DISCONNECTED:\n\t\t\t\tresult += ChannelState.DISCONNECTED.ordinal();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t<span class=\"hljs-keyword\">case</span> SENT:\n\t\t\t\tresult += ChannelState.SENT.ordinal();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t<span class=\"hljs-keyword\">case</span> RECEIVED:\n\t\t\t\tresult += ChannelState.RECEIVED.ordinal();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t<span class=\"hljs-keyword\">case</span> CAUGHT:\n\t\t\t\tresult += ChannelState.CAUGHT.ordinal();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t}\n\t\t}\n\t\tbh.consume(result);\n\t}\n\n\t<span class=\"hljs-meta\">@Fork</span>(value = <span class=\"hljs-number\">5</span>)\n\t<span class=\"hljs-meta\">@Benchmark</span>\n\t<span class=\"hljs-meta\">@BenchmarkMode</span>(Mode.Throughput)\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">benchIfAndSwitch</span><span class=\"hljs-params\">(ExecutionPlan plan, Blackhole bh)</span> </span>{\n\t\t<span class=\"hljs-keyword\">int</span> result = <span class=\"hljs-number\">0</span>;\n\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; plan.size; ++i) {\n\t\t\tChannelState state = plan.states[i];\n\t\t\t<span class=\"hljs-keyword\">if</span> (state == ChannelState.RECEIVED) {\n\t\t\t\tresult += ChannelState.RECEIVED.ordinal();\n\t\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\t\t<span class=\"hljs-keyword\">switch</span> (state) {\n\t\t\t\t<span class=\"hljs-keyword\">case</span> CONNECTED:\n\t\t\t\t\tresult += ChannelState.CONNECTED.ordinal();\n\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t\t<span class=\"hljs-keyword\">case</span> SENT:\n\t\t\t\t\tresult += ChannelState.SENT.ordinal();\n\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t\t<span class=\"hljs-keyword\">case</span> DISCONNECTED:\n\t\t\t\t\tresult += ChannelState.DISCONNECTED.ordinal();\n\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t\t<span class=\"hljs-keyword\">case</span> CAUGHT:\n\t\t\t\t\tresult += ChannelState.CAUGHT.ordinal();\n\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbh.consume(result);\n\t}\n}\n</code></pre>\n<ul>\n<li>benchSiwtch里是纯switch判断</li>\n<li>benchIfAndSwitch 里用一个if提前判断state是否<code>ChannelState.RECEIVED</code></li>\n</ul>\n<p>benchmark结果是：</p>\n<pre><code>Result &quot;io.github.hengyunabc.jmh.TestBenchMarks.benchSiwtch&quot;:\n  576.745 ±(99.9%) 6.806 ops/s [Average]\n  (min, avg, max) = (490.348, 576.745, 618.360), stdev = 20.066\n  CI (99.9%): [569.939, 583.550] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:06:48\n\nBenchmark                         (size)   Mode  Cnt     Score    Error  Units\nTestBenchMarks.benchIfAndSwitch  1000000  thrpt  100  1535.867 ± 61.212  ops/s\nTestBenchMarks.benchSiwtch       1000000  thrpt  100   576.745 ±  6.806  ops/s\n</code></pre>\n<p>可以看到提前if判断的确提高了代码效率，这种技巧可以放在性能要求严格的地方。</p>\n<p>Benchmark代码：<a href=\"https://github.com/hengyunabc/jmh-demo\">https://github.com/hengyunabc/jmh-demo</a></p>\n<h2>总结</h2>\n<ul>\n<li>switch对于CPU来说难以做分支预测</li>\n<li>某些switch条件如果概率比较高，可以考虑单独提前if判断，充分利用CPU的分支预测机制</li>\n</ul>\n"
}