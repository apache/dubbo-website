{
  "filename": "service-and-version.md",
  "__html": "<h1>Dubbo服务分组和版本聚合</h1>\n<p>我们在调用Dubbo服务的时候，一般只需要将Consumer端的<code>dubbo:reference</code>指定成服务端中<code>dubbo:service</code>暴露的服务，就可以找到服务端，完成调用，也就是说，Dubbo只需要服务接口信息就可以找到服务提供者。\n其实除了服务提供者以外，Dubbo也有服务分组和版本的概念，在客户端去寻找“匹配”的服务端的时候，需要服务接口，版本号，组别这三个信息都匹配，才算是一个有效的服务端：</p>\n<pre><code class=\"language-java\">   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isMatch</span><span class=\"hljs-params\">(URL consumerUrl, URL providerUrl)</span> </span>{\n        String consumerInterface = consumerUrl.getServiceInterface();\n        String providerInterface = providerUrl.getServiceInterface();\n        <span class=\"hljs-keyword\">if</span> (!(Constants.ANY_VALUE.equals(consumerInterface) || StringUtils.isEquals(consumerInterface, providerInterface)))\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n\n        <span class=\"hljs-keyword\">if</span> (!isMatchCategory(providerUrl.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY),\n                consumerUrl.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY))) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (!providerUrl.getParameter(Constants.ENABLED_KEY, <span class=\"hljs-keyword\">true</span>)\n                &amp;&amp; !Constants.ANY_VALUE.equals(consumerUrl.getParameter(Constants.ENABLED_KEY))) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n        }\n\n        String consumerGroup = consumerUrl.getParameter(Constants.GROUP_KEY);\n        String consumerVersion = consumerUrl.getParameter(Constants.VERSION_KEY);\n        String consumerClassifier = consumerUrl.getParameter(Constants.CLASSIFIER_KEY, Constants.ANY_VALUE);\n\n        String providerGroup = providerUrl.getParameter(Constants.GROUP_KEY);\n        String providerVersion = providerUrl.getParameter(Constants.VERSION_KEY);\n        String providerClassifier = providerUrl.getParameter(Constants.CLASSIFIER_KEY, Constants.ANY_VALUE);\n        <span class=\"hljs-keyword\">return</span> (Constants.ANY_VALUE.equals(consumerGroup) || StringUtils.isEquals(consumerGroup, providerGroup) || StringUtils.isContains(consumerGroup, providerGroup))\n                &amp;&amp; (Constants.ANY_VALUE.equals(consumerVersion) || StringUtils.isEquals(consumerVersion, providerVersion))\n                &amp;&amp; (consumerClassifier == <span class=\"hljs-keyword\">null</span> || Constants.ANY_VALUE.equals(consumerClassifier) || StringUtils.isEquals(consumerClassifier, providerClassifier));\n    }\n</code></pre>\n<p>如果没有配置组别和版本号，默认值为空。服务端和消费端都没有配，只有服务接口，其他两个信息都为空，也是可以“找到”对方的，那服务名和版本号可以如何使用呢？下面我们来看一下具体的场景：</p>\n<h3>服务分组</h3>\n<p>当一个接口有多种实现时，可以用 group 区分。</p>\n<p>服务</p>\n<pre><code>&lt;dubbo:service group=&quot;feedback&quot; interface=&quot;com.xxx.IndexService&quot; /&gt;\n&lt;dubbo:service group=&quot;member&quot; interface=&quot;com.xxx.IndexService&quot; /&gt;\n</code></pre>\n<p>引用</p>\n<pre><code>&lt;dubbo:reference id=&quot;feedbackIndexService&quot; group=&quot;feedback&quot; interface=&quot;com.xxx.IndexService&quot; /&gt;\n&lt;dubbo:reference id=&quot;memberIndexService&quot; group=&quot;member&quot; interface=&quot;com.xxx.IndexService&quot; /&gt;\n</code></pre>\n<p>任意组</p>\n<pre><code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; group=&quot;*&quot; /&gt;\n</code></pre>\n<h3>多版本</h3>\n<p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p>\n<p>可以按照以下的步骤进行版本迁移：</p>\n<ol>\n<li>在低压力时间段，先升级一半提供者为新版本</li>\n<li>再将所有消费者升级为新版本</li>\n<li>然后将剩下的一半提供者升级为新版本</li>\n</ol>\n<p>老版本服务提供者配置：</p>\n<pre><code>&lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt;  \n</code></pre>\n<p>新版本服务提供者配置：</p>\n<pre><code>&lt;dubbo:service interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt;\n</code></pre>\n<p>老版本服务消费者配置：</p>\n<pre><code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;1.0.0&quot; /&gt;\n</code></pre>\n<p>新版本服务消费者配置：</p>\n<pre><code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;2.0.0&quot; /&gt;\n</code></pre>\n<p>如果不需要区分版本，可以按照以下的方式配置：</p>\n<pre><code>&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;*&quot; /&gt; \n</code></pre>\n<h3>分组聚合</h3>\n<p>按组合并返回结果，比如菜单服务，接口一样，但有多种实现，用group区分，现在消费方需从每种group中调用一次返回结果，合并结果返回，这样就可以实现聚合菜单项。</p>\n<h4>配置</h4>\n<p>搜索所有分组</p>\n<pre><code>&lt;dubbo:reference interface=&quot;com.xxx.MenuService&quot; group=&quot;*&quot; merger=&quot;true&quot; /&gt;\n</code></pre>\n<p>合并指定分组</p>\n<pre><code>&lt;dubbo:reference interface=&quot;com.xxx.MenuService&quot; group=&quot;aaa,bbb&quot; merger=&quot;true&quot; /&gt;\n</code></pre>\n<p>指定方法合并结果，其它未指定的方法，将只调用一个 Group</p>\n<pre><code>&lt;dubbo:reference interface=&quot;com.xxx.MenuService&quot; group=&quot;*&quot;&gt;\n&lt;dubbo:method name=&quot;getMenuItems&quot; merger=&quot;true&quot; /&gt;\n&lt;/dubbo:service&gt;\n</code></pre>\n<p>某个方法不合并结果，其它都合并结果</p>\n<pre><code>&lt;dubbo:reference interface=&quot;com.xxx.MenuService&quot; group=&quot;*&quot; merger=&quot;true&quot;&gt;\n&lt;dubbo:method name=&quot;getMenuItems&quot; merger=&quot;false&quot; /&gt;\n&lt;/dubbo:service&gt;\n</code></pre>\n<p>指定合并策略，缺省根据返回值类型自动匹配，如果同一类型有两个合并器时，需指定合并器的名称</p>\n<pre><code>&lt;dubbo:reference interface=&quot;com.xxx.MenuService&quot; group=&quot;*&quot;&gt;\n&lt;dubbo:method name=&quot;getMenuItems&quot; merger=&quot;mymerge&quot; /&gt;\n&lt;/dubbo:service&gt;\n</code></pre>\n<p>指定合并方法，将调用返回结果的指定方法进行合并，合并方法的参数类型必须是返回结果类型本身</p>\n<pre><code>&lt;dubbo:reference interface=&quot;com.xxx.MenuService&quot; group=&quot;*&quot;&gt;\n&lt;dubbo:method name=&quot;getMenuItems&quot; merger=&quot;.addAll&quot; /&gt;\n&lt;/dubbo:service&gt;  \n</code></pre>\n<h4>实现原理</h4>\n<p>如果配置了merge，Dubbo会分别调用多个组别的服务提供者，然后把结果聚合，返回给消费端，具体的实现在<code>MergeableClusterInvoker.java</code>里：</p>\n<pre><code class=\"language-java\"> <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Result <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n        List&lt;Invoker&lt;T&gt;&gt; invokers = directory.list(invocation);\n\n        String merger = getUrl().getMethodParameter(invocation.getMethodName(), Constants.MERGER_KEY);\n        <span class=\"hljs-keyword\">if</span> (ConfigUtils.isEmpty(merger)) { <span class=\"hljs-comment\">// If a method doesn't have a merger, only invoke one Group</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">final</span> Invoker&lt;T&gt; invoker : invokers) {\n                <span class=\"hljs-keyword\">if</span> (invoker.isAvailable()) {\n                    <span class=\"hljs-keyword\">return</span> invoker.invoke(invocation);\n                }\n            }\n            <span class=\"hljs-keyword\">return</span> invokers.iterator().next().invoke(invocation);\n        }\n\n        Class&lt;?&gt; returnType;\n        <span class=\"hljs-keyword\">try</span> {\n            returnType = getInterface().getMethod(\n                    invocation.getMethodName(), invocation.getParameterTypes()).getReturnType();\n        } <span class=\"hljs-keyword\">catch</span> (NoSuchMethodException e) {\n            returnType = <span class=\"hljs-keyword\">null</span>;\n        }\n\n        Map&lt;String, Future&lt;Result&gt;&gt; results = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, Future&lt;Result&gt;&gt;();\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">final</span> Invoker&lt;T&gt; invoker : invokers) {\n            Future&lt;Result&gt; future = executor.submit(<span class=\"hljs-keyword\">new</span> Callable&lt;Result&gt;() {\n                <span class=\"hljs-meta\">@Override</span>\n                <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Result <span class=\"hljs-title\">call</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n                    <span class=\"hljs-keyword\">return</span> invoker.invoke(<span class=\"hljs-keyword\">new</span> RpcInvocation(invocation, invoker));\n                }\n            });\n            results.put(invoker.getUrl().getServiceKey(), future);\n        }\n\n        Object result = <span class=\"hljs-keyword\">null</span>;\n\n        List&lt;Result&gt; resultList = <span class=\"hljs-keyword\">new</span> ArrayList&lt;Result&gt;(results.size());\n\n        <span class=\"hljs-keyword\">int</span> timeout = getUrl().getMethodParameter(invocation.getMethodName(), Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n        <span class=\"hljs-keyword\">for</span> (Map.Entry&lt;String, Future&lt;Result&gt;&gt; entry : results.entrySet()) {\n            Future&lt;Result&gt; future = entry.getValue();\n            <span class=\"hljs-keyword\">try</span> {\n                Result r = future.get(timeout, TimeUnit.MILLISECONDS);\n                <span class=\"hljs-keyword\">if</span> (r.hasException()) {\n                    log.error(<span class=\"hljs-string\">\"Invoke \"</span> + getGroupDescFromServiceKey(entry.getKey()) + \n                                    <span class=\"hljs-string\">\" failed: \"</span> + r.getException().getMessage(), \n                            r.getException());\n                } <span class=\"hljs-keyword\">else</span> {\n                    resultList.add(r);\n                }\n            } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RpcException(<span class=\"hljs-string\">\"Failed to invoke service \"</span> + entry.getKey() + <span class=\"hljs-string\">\": \"</span> + e.getMessage(), e);\n            }\n        }\n\n        <span class=\"hljs-keyword\">if</span> (resultList.isEmpty()) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> RpcResult((Object) <span class=\"hljs-keyword\">null</span>);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (resultList.size() == <span class=\"hljs-number\">1</span>) {\n            <span class=\"hljs-keyword\">return</span> resultList.iterator().next();\n        }\n\n        <span class=\"hljs-keyword\">if</span> (returnType == <span class=\"hljs-keyword\">void</span>.class) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> RpcResult((Object) <span class=\"hljs-keyword\">null</span>);\n        }\n</code></pre>\n<p>如果配置了merger，会依次调用，结果都放在results里面，其中value都是future类型，等调用完成之后，再遍历results，通过future.get拿到真正的结果，到此为止，所有调用的结果都放在resultList里面了，接下来要做的是把结果进行聚合：</p>\n<pre><code class=\"language-java\">  Merger resultMerger;\n  <span class=\"hljs-keyword\">if</span> (ConfigUtils.isDefault(merger)) {\n      resultMerger = MergerFactory.getMerger(returnType);\n  } <span class=\"hljs-keyword\">else</span> {\n      resultMerger = ExtensionLoader.getExtensionLoader(Merger.class).getExtension(merger);\n  }\n  <span class=\"hljs-keyword\">if</span> (resultMerger != <span class=\"hljs-keyword\">null</span>) {\n      List&lt;Object&gt; rets = <span class=\"hljs-keyword\">new</span> ArrayList&lt;Object&gt;(resultList.size());\n      <span class=\"hljs-keyword\">for</span> (Result r : resultList) {\n          rets.add(r.getValue());\n      }\n      result = resultMerger.merge(\n                        rets.toArray((Object[]) Array.newInstance(returnType, <span class=\"hljs-number\">0</span>)));\n  } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RpcException(<span class=\"hljs-string\">\"There is no merger to merge result.\"</span>)\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> RpcResult(result);\n</code></pre>\n<p>这里会根据返回值的类型，获取到对应的resultMerger，除了Dubbo默认实现的类型外，也可以自己指定merger类型并且添加相应的扩展，通过实现<code>merge</code>方法类进行结果聚合。</p>\n",
  "link": "/zh-cn/blog/service-and-version.html",
  "meta": {}
}