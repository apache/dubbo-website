{
  "filename": "service-test.md",
  "__html": "<h1>Dubbo Admin服务测试功能</h1>\n<p>基于Dubbo2.7的元数据，Dubbo Admin实现了服务测试功能，可以通过泛化调用，在控制台上调用真实的服务提供者</p>\n<h2>使用方式</h2>\n<ul>\n<li>部署服务提供者： 可以在<a href=\"https://github.com/nzomkxia/dubbo-demo\">这里</a>下载demo，此工程基于spring boot，方便在IDE或者命令行启动，对于服务测试来说，只需要启动<code>dubbo-basic-provider</code>即可。</li>\n<li>服务查询： 完成服务端部署后，可以到Dubbo Admin的<code>服务测试</code>页面上查询对应的服务:\n<img src=\"../../img/blog/admin/testSearch.jpg\" alt=\"testSearch\"><br>\n这里的信息和元数据类似，包含方法名，参数类型和返回值信息，点击右边的标签就可以进入服务测试页面</li>\n<li>服务测试：\n<img src=\"../../img/blog/admin/testSuccess.jpg\" alt=\"testSuccess\"><br>\n服务测试页面包含了两个json编辑器，参数类型的信息都是以json格式保存，这里需要填入对应的参数值(本例中数类型时<code>String</code>)，填写完成后点击<code>执行</code>即可对服务端发起调用，调用结果展示在右边的编辑器中，如果调用失败，会显示详细的失败原因，下面来看一下调用失败的例子：<br>\n<img src=\"../../img/blog/admin/testFail.jpg\" alt=\"testFail\">\n本例中，先关掉Dubbo服务提供者的进程，再执行服务测试，可以看到返回的结果是<code>找不到服务提供者</code>的异常。和普通调用一样，业务和框架的异常都会返回在结果中，方便业务排查。</li>\n<li>复合类型参数<br>\n考虑<code>UserService</code>中的以下方法和类型：</li>\n</ul>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">//org.apache.dubbo.demo.api.UserService</span>\n<span class=\"hljs-function\">Result <span class=\"hljs-title\">getUser</span><span class=\"hljs-params\">(String name, UserInfoDO userInfoDO)</span></span>;\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserInfoDO</span> </span>{\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> id;\n    <span class=\"hljs-keyword\">private</span> LocationDO locationDO;\n    <span class=\"hljs-keyword\">private</span> DepartmentDO departmentDO;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"UserInfoDO{\"</span> +\n                <span class=\"hljs-string\">\"id=\"</span> + id +\n                <span class=\"hljs-string\">\", locationDO=\"</span> + locationDO.toString() +\n                <span class=\"hljs-string\">\", departmentDO=\"</span> + departmentDO.toString() +\n                <span class=\"hljs-string\">'}'</span>;\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DepartmentDO</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> String departName;\n    <span class=\"hljs-keyword\">private</span> LocationDO departLocation;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"DepartmentDO{\"</span> +\n                <span class=\"hljs-string\">\"departName='\"</span> + departName + <span class=\"hljs-string\">'\\''</span> +\n                <span class=\"hljs-string\">\", departLocation=\"</span> + departLocation.toString() +\n                <span class=\"hljs-string\">'}'</span>;\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LocationDO</span> </span>{\n    <span class=\"hljs-keyword\">private</span> String address;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> postNum;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"LocationDO{\"</span> +\n                <span class=\"hljs-string\">\"address='\"</span> + address + <span class=\"hljs-string\">'\\''</span> +\n                <span class=\"hljs-string\">\", postNum=\"</span> + postNum +\n                <span class=\"hljs-string\">'}'</span>;\n    }\n}\n</code></pre>\n<p>参数是比较复杂的符合类型参数，服务测试的时候，会逐层展开填写每一个field的值，如下图所示：<br>\n<img src=\"../../img/blog/admin/complex.jpg\" alt=\"complex\">\n同样可以调用成功并且返回结果</p>\n<h2>原理：数据来源</h2>\n<p>服务测试中，最重要的就是完整的方法签名信息，和参数的类型信息，有了这些信息才能够一步步填入每个参数的值，拼装出完整的服务消费者。在Dubbo2.7中，新增了元数据中心，Dubbo Admin的方法签名和参数类型信息就是从这里来的：<br>\n<img src=\"../../img/blog/admin/metadata.png\" alt=\"medatada\">\n如图所示，服务端在运行的时候会将服务的元数据信息注册到元数据中心，格式如下：</p>\n<pre><code class=\"language-json\">{\n    ...\n    \"methods\": [\n        {\n            \"name\": \"sayHello\",\n            \"parameterTypes\": [\n                \"org.apache.dubbo.demo.model.User\"\n            ],\n            \"returnType\": \"org.apache.dubbo.demo.model.Result\"\n        },\n      ...\n    ],\n    \"types\": [\n        {\n            \"type\": \"char\"\n        },\n        {\n            \"type\": \"long\"\n        },\n        {\n            \"type\": \"org.apache.dubbo.demo.model.Result\",\n            \"properties\": {\n                \"msg\": {\n                    \"type\": \"java.lang.String\",\n                    \"properties\": {\n                        \"value\": {\n                            \"type\": \"char[]\"\n                        },\n                        \"hash\": {\n                            \"type\": \"int\"\n                        }\n                    }\n                },\n                \"userName\": {\n                    \"type\": \"java.lang.String\",\n                    \"properties\": {\n                        \"value\": {\n                            \"type\": \"char[]\"\n                        },\n                        \"hash\": {\n                            \"type\": \"int\"\n                        }\n                    }\n                }\n            }\n        },\n        {\n            \"type\": \"org.apache.dubbo.demo.model.User\",\n            \"properties\": {\n                \"id\": {\n                    \"type\": \"java.lang.Long\",\n                    \"properties\": {\n                        \"value\": {\n                            \"type\": \"long\"\n                        }\n                    }\n                },\n                \"username\": {\n                    \"type\": \"java.lang.Sring\",\n                    \"properties\": {\n                        \"value\": {\n                            \"type\": \"char[]\"\n                        },\n                        \"hash\": {\n                            \"type\": \"int\"\n                        }\n                    }\n                }\n            }\n        },\n       ...\n    ]\n}\n</code></pre>\n<p>与服务测试相关的就是<code>methods</code>和<code>types</code>所包含的方法和类型信息，Dubbo Admin根据这些信息，将参数渲染到服务测试页面的Json Editor中，由用户来输入每个参数，每个成员变量的值。</p>\n<h2>原理： 泛化调用</h2>\n<p>有了参数类型，下一个问题就是怎么能够调用到服务端，在传统的Dubbo RPC调用中，客户端需要依赖服务端的API jar包(参考前文demo中的<a href=\"https://github.com/nzomkxia/dubbo-demo/tree/master/dubbo-basic-consumer\">dubbo-basic-consumer</a>)，这对于Dubbo Admin来说不太可能，因为服务的上下线是动态的，Dubbo Admin无法动态增加jar包依赖，因此需要用到Dubbo中的<strong>泛化调用</strong>，指的是在没有服务端API接口的情况下，客户端直接通过 <code>GenericService</code> 接口来发起服务调用，返回值中的数据对象都用Map来表示。泛化调用在服务端不需要做特殊处理，只需要客户端发起即可。</p>\n<h2>总结和展望</h2>\n<p>本文简单介绍了服务测试的用法和原理，后续会进一步针对该功能进行增强，比如处理抽象类的参数类型，支持从json文件导入参数值，支持对参数值的保存等等，方便对服务接口进行回归测试。</p>\n",
  "link": "/zh-cn/blog/service-test.html",
  "meta": {}
}