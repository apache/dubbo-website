{
  "filename": "SPI.md",
  "__html": "<h1>扩展点加载</h1>\n<h2>扩展点配置</h2>\n<h3>来源：</h3>\n<p>Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。</p>\n<p>Dubbo 改进了 JDK 标准的 SPI 的以下问题：</p>\n<ul>\n<li>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。</li>\n<li>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK 标准的 ScriptEngine，通过 <code>getName()</code> 获取脚本类型的名称，但如果 RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby  脚本时，会报不支持 ruby，而不是真正失败的原因。</li>\n<li>增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</li>\n</ul>\n<h3>约定：</h3>\n<p>在扩展类的 jar 包内 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>，放置扩展点配置文件 <code>META-INF/dubbo/接口全限定名</code>，内容为：<code>配置名=扩展实现类全限定名</code>，多个实现类用换行符分隔。</p>\n<h3>示例：</h3>\n<p>以扩展 Dubbo 的协议为例，在协议的实现 jar 包内放置文本文件：<code>META-INF/dubbo/com.alibaba.dubbo.rpc.Protocol</code>，内容为：</p>\n<pre><code class=\"language-properties\">xxx=com.alibaba.xxx.XxxProtocol\n</code></pre>\n<p>实现类内容 <sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.alibaba.xxx;\n \n<span class=\"hljs-keyword\">import</span> com.alibaba.dubbo.rpc.Protocol;\n \n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">XxxProtocol</span> <span class=\"hljs-title\">implemenets</span> <span class=\"hljs-title\">Protocol</span> </span>{ \n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<h3>配置模块中的配置</h3>\n<p>Dubbo 配置模块中，扩展点均有对应配置属性或标签，通过配置指定使用哪个扩展实现。比如：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"xxx\"</span> /&gt;</span>\n</code></pre>\n<h2>扩展点特性</h2>\n<h3>扩展点自动包装</h3>\n<p>自动包装扩展点的 Wrapper 类。<code>ExtensionLoader</code> 在加载扩展点时，如果加载到的扩展点有拷贝构造函数，则判定为扩展点 Wrapper 类。</p>\n<p>Wrapper类内容：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.alibaba.xxx;\n \n<span class=\"hljs-keyword\">import</span> com.alibaba.dubbo.rpc.Protocol;\n \n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">XxxProtocolWrapper</span> <span class=\"hljs-title\">implemenets</span> <span class=\"hljs-title\">Protocol</span> </span>{\n    Protocol impl;\n \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">XxxProtocol</span><span class=\"hljs-params\">(Protocol protocol)</span> </span>{ impl = protocol; }\n \n    <span class=\"hljs-comment\">// 接口方法做一个操作后，再调用extension的方法</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">refer</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">//... 一些操作</span>\n        impl.refer();\n        <span class=\"hljs-comment\">// ... 一些操作</span>\n    }\n \n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>Wrapper 类同样实现了扩展点接口，但是 Wrapper 不是扩展点的真正实现。它的用途主要是用于从 <code>ExtensionLoader</code> 返回扩展点时，包装在真正的扩展点实现外。即从 <code>ExtensionLoader</code> 中返回的实际上是 Wrapper 类的实例，Wrapper 持有了实际的扩展点实现类。</p>\n<p>扩展点的 Wrapper 类可以有多个，也可以根据需要新增。</p>\n<p>通过 Wrapper 类可以把所有扩展点公共逻辑移至 Wrapper 中。新加的 Wrapper 在所有的扩展点上添加了逻辑，有些类似 AOP，即 Wrapper 代理了扩展点。</p>\n<h3>扩展点自动装配</h3>\n<p>加载扩展点时，自动注入依赖的扩展点。加载扩展点时，扩展点实现类的成员如果为其它扩展点类型，<code>ExtensionLoader</code> 在会自动注入依赖的扩展点。<code>ExtensionLoader</code> 通过扫描扩展点实现类的所有 setter 方法来判定其成员。即 <code>ExtensionLoader</code> 会执行扩展点的拼装操作。</p>\n<p>示例：有两个为扩展点 <code>CarMaker</code>（造车者）、<code>WheelMaker</code> (造轮者)</p>\n<p>接口类如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">CarMaker</span> </span>{\n    <span class=\"hljs-function\">Car <span class=\"hljs-title\">makeCar</span><span class=\"hljs-params\">()</span></span>;\n}\n \n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">WheelMaker</span> </span>{\n    <span class=\"hljs-function\">Wheel <span class=\"hljs-title\">makeWheel</span><span class=\"hljs-params\">()</span></span>;\n}\n</code></pre>\n<p><code>CarMaker</code> 的一个实现类：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RaceCarMaker</span> <span class=\"hljs-title\">implemenets</span> <span class=\"hljs-title\">CarMaker</span> </span>{\n    WheelMaker wheelMaker;\n \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">setWheelMaker</span><span class=\"hljs-params\">(WheelMaker wheelMaker)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.wheelMaker = wheelMaker;\n    }\n \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Car <span class=\"hljs-title\">makeCar</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// ...</span>\n        Wheel wheel = wheelMaker.makeWheel();\n        <span class=\"hljs-comment\">// ...</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> RaceCar(wheel, ...);\n    }\n}\n</code></pre>\n<p><code>ExtensionLoader</code> 加载 <code>CarMaker</code> 的扩展点实现 <code>RaceCar</code> 时，<code>setWheelMaker</code> 方法的 <code>WheelMaker</code> 也是扩展点则会注入 <code>WheelMaker</code> 的实现。</p>\n<p>这里带来另一个问题，<code>ExtensionLoader</code> 要注入依赖扩展点时，如何决定要注入依赖扩展点的哪个实现。在这个示例中，即是在多个<code>WheelMaker</code> 的实现中要注入哪个。</p>\n<p>这个问题在下面一点 <a href=\"#%E6%89%A9%E5%B1%95%E7%82%B9%E8%87%AA%E9%80%82%E5%BA%94\">扩展点自适应</a> 中说明。</p>\n<h3>扩展点自适应</h3>\n<p><code>ExtensionLoader</code> 注入的依赖扩展点是一个 <code>Adaptive</code> 实例，直到扩展点方法执行时才决定调用是一个扩展点实现。</p>\n<p>Dubbo 使用 URL 对象（包含了Key-Value）传递配置信息。</p>\n<p>扩展点方法调用会有URL参数（或是参数有URL成员）</p>\n<p>这样依赖的扩展点也可以从URL拿到配置信息，所有的扩展点自己定好配置的Key后，配置信息从URL上从最外层传入。URL在配置传递上即是一条总线。</p>\n<p>示例：有两个为扩展点 <code>CarMaker</code>、<code>WheelMaker</code></p>\n<p>接口类如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">CarMaker</span> </span>{\n    <span class=\"hljs-function\">Car <span class=\"hljs-title\">makeCar</span><span class=\"hljs-params\">(URL url)</span></span>;\n}\n \n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">WheelMaker</span> </span>{\n    <span class=\"hljs-function\">Wheel <span class=\"hljs-title\">makeWheel</span><span class=\"hljs-params\">(URL url)</span></span>;\n}\n</code></pre>\n<p><code>CarMaker</code> 的一个实现类：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RaceCarMaker</span> <span class=\"hljs-title\">implemenets</span> <span class=\"hljs-title\">CarMaker</span> </span>{\n    WheelMaker wheelMaker;\n \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">setWheelMaker</span><span class=\"hljs-params\">(WheelMaker wheelMaker)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.wheelMaker = wheelMaker;\n    }\n \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Car <span class=\"hljs-title\">makeCar</span><span class=\"hljs-params\">(URL url)</span> </span>{\n        <span class=\"hljs-comment\">// ...</span>\n        Wheel wheel = wheelMaker.makeWheel(url);\n        <span class=\"hljs-comment\">// ...</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> RaceCar(wheel, ...);\n    }\n}\n</code></pre>\n<p>当上面执行</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// ...</span>\nWheel wheel = wheelMaker.makeWheel(url);\n<span class=\"hljs-comment\">// ...</span>\n</code></pre>\n<p>时，注入的 <code>Adaptive</code> 实例可以提取约定 Key 来决定使用哪个 <code>WheelMaker</code> 实现来调用对应实现的真正的 <code>makeWheel</code> 方法。如提取 <code>wheel.type</code>, key 即 <code>url.get(&quot;wheel.type&quot;)</code> 来决定 <code>WheelMake</code> 实现。<code>Adaptive</code> 实例的逻辑是固定，指定提取的 URL 的 Key，即可以代理真正的实现类上，可以动态生成。</p>\n<p>在 Dubbo 的 <code>ExtensionLoader</code> 的扩展点类对应的 <code>Adaptive</code> 实现是在加载扩展点里动态生成。指定提取的 URL 的 Key 通过 <code>@Adaptive</code> 注解在接口方法上提供。</p>\n<p>下面是 Dubbo 的 Transporter 扩展点的代码：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Transporter</span> </span>{\n    <span class=\"hljs-meta\">@Adaptive</span>({<span class=\"hljs-string\">\"server\"</span>, <span class=\"hljs-string\">\"transport\"</span>})\n    <span class=\"hljs-function\">Server <span class=\"hljs-title\">bind</span><span class=\"hljs-params\">(URL url, ChannelHandler handler)</span> <span class=\"hljs-keyword\">throws</span> RemotingException</span>;\n \n    <span class=\"hljs-meta\">@Adaptive</span>({<span class=\"hljs-string\">\"client\"</span>, <span class=\"hljs-string\">\"transport\"</span>})\n    <span class=\"hljs-function\">Client <span class=\"hljs-title\">connect</span><span class=\"hljs-params\">(URL url, ChannelHandler handler)</span> <span class=\"hljs-keyword\">throws</span> RemotingException</span>;\n}\n</code></pre>\n<p>对于 bind() 方法，Adaptive 实现先查找 <code>server</code> key，如果该 Key 没有值则找 <code>transport</code> key 值，来决定代理到哪个实际扩展点。</p>\n<h3>扩展点自动激活</h3>\n<p>对于集合类扩展点，比如：<code>Filter</code>, <code>InvokerListener</code>, <code>ExportListener</code>, <code>TelnetHandler</code>, <code>StatusChecker</code> 等，可以同时加载多个实现，此时，可以用自动激活来简化配置，如：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> com.alibaba.dubbo.common.extension.Activate;\n<span class=\"hljs-keyword\">import</span> com.alibaba.dubbo.rpc.Filter;\n \n<span class=\"hljs-meta\">@Activate</span> <span class=\"hljs-comment\">// 无条件自动激活</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">XxxFilter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Filter</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>或：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> com.alibaba.dubbo.common.extension.Activate;\n<span class=\"hljs-keyword\">import</span> com.alibaba.dubbo.rpc.Filter;\n \n<span class=\"hljs-meta\">@Activate</span>(<span class=\"hljs-string\">\"xxx\"</span>) <span class=\"hljs-comment\">// 当配置了xxx参数，并且参数为有效值时激活，比如配了cache=\"lru\"，自动激活CacheFilter。</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">XxxFilter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Filter</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>或：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> com.alibaba.dubbo.common.extension.Activate;\n<span class=\"hljs-keyword\">import</span> com.alibaba.dubbo.rpc.Filter;\n \n<span class=\"hljs-meta\">@Activate</span>(group = <span class=\"hljs-string\">\"provider\"</span>, value = <span class=\"hljs-string\">\"xxx\"</span>) <span class=\"hljs-comment\">// 只对提供方激活，group可选\"provider\"或\"consumer\"</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">XxxFilter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Filter</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>注意：这里的配置文件是放在你自己的 jar 包内，不是 dubbo 本身的 jar 包内，Dubbo 会全 ClassPath 扫描所有 jar 包内同名的这个文件，然后进行合并 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>注意：扩展点使用单一实例加载（请确保扩展实现的线程安全性），缓存在 <code>ExtensionLoader</code> 中 <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n"
}