{
  "filename": "coding.md",
  "__html": "<h1>编码约定</h1>\n<h2>代码风格</h2>\n<p>Dubbo 的源代码和 JavaDoc 遵循以下的规范：</p>\n<ul>\n<li><a href=\"http://www.oracle.com/technetwork/java/codeconvtoc-136057.html\">Code Conventions for the Java Programming Language</a></li>\n<li><a href=\"http://www.oracle.com/technetwork/java/javase/documentation/index-137868.html\">How to Write Doc Comments for the Javadoc Tool</a></li>\n</ul>\n<h2>异常和日志</h2>\n<ul>\n<li>尽可能携带完整的上下文信息，比如出错原因，出错的机器地址，调用对方的地址，连的注册中心地址，使用 Dubbo 的版本等。</li>\n<li>尽量将直接原因写在最前面，所有上下文信息，在原因后用键值对显示。</li>\n<li>抛出异常的地方不用打印日志，由最终处理异常者决定打印日志的级别，吃掉异常必需打印日志。</li>\n<li>打印 <code>ERROR</code> 日志表示需要报警，打印 <code>WARN</code> 日志表示可以自动恢复，打印 <code>INFO</code> 表示正常信息或完全不影响运行。</li>\n<li>建议应用方在监控中心配置 <code>ERROR</code> 日志实时报警，<code>WARN</code> 日志每周汇总发送通知。</li>\n<li><code>RpcException</code> 是 Dubbo 对外的唯一异常类型，所有内部异常，如果要抛出给用户，必须转为 <code>RpcException</code>。</li>\n<li><code>RpcException</code> 不能有子类型，所有类型信息用 ErrorCode 标识，以便保持兼容。</li>\n</ul>\n<h2>配置和 URL</h2>\n<ul>\n<li>配置对象属性首字母小写，多个单词用驼峰命名 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>。</li>\n<li>配置属性全部用小写，多个单词用&quot;-&quot;号分隔 <sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>。</li>\n<li>URL参数全部用小写，多个单词用&quot;.&quot;号分隔 <sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>。</li>\n<li>尽可能用 URL 传参，不要自定义 Map 或其它上下文格式，配置信息也转成 URL 格式使用。</li>\n<li>尽量减少 URL 嵌套，保持 URL 的简洁性。</li>\n</ul>\n<h2>单元和集成测试</h2>\n<ul>\n<li>单元测试统一用 JUnit 和 EasyMock，集成测试用 TestNG，数据库测试用 DBUnit。</li>\n<li>保持单元测试用例的运行速度，不要将性能和大的集成用例放在单元测试中。</li>\n<li>保持单元测试的每个用例都用 <code>try...finally</code> 或 <code>tearDown</code> 释放资源。</li>\n<li>减少 while 循环等待结果的测试用例，对定时器和网络的测试，用以将定时器中的逻辑抽为方法测试。</li>\n<li>对于容错行为的测试，比如 failsafe 的测试，统一用 <code>LogUtil</code> 断言日志输出。</li>\n</ul>\n<h2>扩展点基类与 AOP</h2>\n<ul>\n<li>AOP 类都命名为 <code>XxxWrapper</code>，基类都命名为 <code>AbstractXxx</code>。</li>\n<li>扩展点之间的组合将关系由 AOP 完成，<code>ExtensionLoader</code> 只负载加载扩展点，包括 AOP 扩展。</li>\n<li>尽量采用 IoC 注入扩展点之间的依赖，不要直接依赖 <code>ExtensionLoader</code> 的工厂方法。</li>\n<li>尽量采用 AOP 实现扩展点的通用行为，而不要用基类，比如负载均衡之前的 <code>isAvailable</code> 检查，它是独立于负载均衡之外的，不需要检查的是URL参数关闭。</li>\n<li>对多种相似类型的抽象，用基类实现，比如 RMI, Hessian 等第三方协议都已生成了接口代理，只需将将接口代理转成 <code>Invoker</code> 即可完成桥接，它们可以用公共基类实现此逻辑。</li>\n<li>基类也是 SPI 的一部分，每个扩展点都应该有方便使用的基类支持。</li>\n</ul>\n<h2>模块与分包</h2>\n<ul>\n<li>基于复用度分包，总是一起使用的放在同一包下，将接口和基类分成独立模块，大的实现也使用独立模块。</li>\n<li>所有接口都放在模块的根包下，基类放在 support 子包下，不同实现用放在以扩展点名字命名的子包下。</li>\n<li>尽量保持子包依赖父包，而不要反向。</li>\n</ul>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>Java 约定 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>Spring 约定 <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>Dubbo 约定 <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n"
}