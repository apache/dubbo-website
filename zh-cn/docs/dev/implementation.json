{
  "filename": "implementation.md",
  "__html": "<h1>实现细节</h1>\n<h2>初始化过程细节</h2>\n<h3>解析服务</h3>\n<p>基于 dubbo.jar 内的 <code>META-INF/spring.handlers</code> 配置，Spring 在遇到 dubbo 名称空间时，会回调 <code>DubboNamespaceHandler</code>。</p>\n<p>所有 dubbo 的标签，都统一用 <code>DubboBeanDefinitionParser</code> 进行解析，基于一对一属性映射，将 XML 标签解析为 Bean 对象。</p>\n<p>在 <code>ServiceConfig.export()</code> 或 <code>ReferenceConfig.get()</code> 初始化时，将 Bean 对象转换 URL 格式，所有 Bean 属性转成 URL 的参数。</p>\n<p>然后将 URL 传给 <a href=\"./impls/protocol.md\">协议扩展点</a>，基于扩展点的 <a href=\"./SPI.md\">扩展点自适应机制</a>，根据 URL 的协议头，进行不同协议的服务暴露或引用。</p>\n<h3>暴露服务</h3>\n<h4>1. 只暴露服务端口：</h4>\n<p>在没有注册中心，直接暴露提供者的情况下 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>，<code>ServiceConfig</code> 解析出的 URL 的格式为：\n<code>dubbo://service-host/com.foo.FooService?version=1.0.0</code>。</p>\n<p>基于扩展点自适应机制，通过 URL 的 <code>dubbo://</code> 协议头识别，直接调用 <code>DubboProtocol</code>的 <code>export()</code> 方法，打开服务端口。</p>\n<h4>2. 向注册中心暴露服务：</h4>\n<p>在有注册中心，需要注册提供者地址的情况下 <sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>，<code>ServiceConfig</code> 解析出的 URL 的格式为: <code>registry://registry-host/com.alibaba.dubbo.registry.RegistryService?export=URL.encode(&quot;dubbo://service-host/com.foo.FooService?version=1.0.0&quot;)</code>，</p>\n<p>基于扩展点自适应机制，通过 URL 的 <code>registry://</code> 协议头识别，就会调用  <code>RegistryProtocol</code> 的 <code>export()</code> 方法，将 <code>export</code> 参数中的提供者 URL，先注册到注册中心。</p>\n<p>再重新传给 <code>Protocol</code> 扩展点进行暴露： <code>dubbo://service-host/com.foo.FooService?version=1.0.0</code>，然后基于扩展点自适应机制，通过提供者 URL 的 <code>dubbo://</code> 协议头识别，就会调用 <code>DubboProtocol</code> 的 <code>export()</code> 方法，打开服务端口。</p>\n<h3>引用服务</h3>\n<h4>1. 直连引用服务：</h4>\n<p>在没有注册中心，直连提供者的情况下 <sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>，<code>ReferenceConfig</code> 解析出的 URL 的格式为：<code>dubbo://service-host/com.foo.FooService?version=1.0.0</code>。</p>\n<p>基于扩展点自适应机制，通过 URL 的 <code>dubbo://</code> 协议头识别，直接调用 <code>DubboProtocol</code> 的 <code>refer()</code> 方法，返回提供者引用。</p>\n<h4>2. 从注册中心发现引用服务：</h4>\n<p>在有注册中心，通过注册中心发现提供者地址的情况下 <sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup>，<code>ReferenceConfig</code> 解析出的 URL 的格式为：\n<code>registry://registry-host/com.alibaba.dubbo.registry.RegistryService?refer=URL.encode(&quot;consumer://consumer-host/com.foo.FooService?version=1.0.0&quot;)</code>。</p>\n<p>基于扩展点自适应机制，通过 URL 的 <code>registry://</code> 协议头识别，就会调用 <code>RegistryProtocol</code> 的 <code>refer()</code> 方法，基于 <code>refer</code> 参数中的条件，查询提供者 URL，如：\n<code>dubbo://service-host/com.foo.FooService?version=1.0.0</code>。</p>\n<p>基于扩展点自适应机制，通过提供者 URL 的 <code>dubbo://</code> 协议头识别，就会调用 <code>DubboProtocol</code> 的 <code>refer()</code> 方法，得到提供者引用。</p>\n<p>然后 <code>RegistryProtocol</code> 将多个提供者引用，通过 <code>Cluster</code> 扩展点，伪装成单个提供者引用返回。</p>\n<h3>拦截服务</h3>\n<p>基于扩展点自适应机制，所有的 <code>Protocol</code> 扩展点都会自动套上 <code>Wrapper</code> 类。</p>\n<p>基于 <code>ProtocolFilterWrapper</code> 类，将所有 <code>Filter</code> 组装成链，在链的最后一节调用真实的引用。</p>\n<p>基于 <code>ProtocolListenerWrapper</code> 类，将所有 <code>InvokerListener</code> 和 <code>ExporterListener</code> 组装集合，在暴露和引用前后，进行回调。</p>\n<p>包括监控在内，所有附加功能，全部通过 <code>Filter</code> 拦截实现。</p>\n<h2>远程调用细节</h2>\n<h3>服务提供者暴露一个服务的详细过程</h3>\n<p><img src=\"sources/images/dubbo_rpc_export.jpg\" alt=\"/dev-guide/images/dubbo_rpc_export.jpg\"></p>\n<p>上图是服务提供者暴露服务的主过程：</p>\n<p>首先 <code>ServiceConfig</code> 类拿到对外提供服务的实际类 ref(如：HelloWorldImpl),然后通过 <code>ProxyFactory</code> 类的 <code>getInvoker</code> 方法使用 ref 生成一个 <code>AbstractProxyInvoker</code> 实例，到这一步就完成具体服务到 <code>Invoker</code> 的转化。接下来就是 <code>Invoker</code> 转换到 <code>Exporter</code> 的过程。</p>\n<p>Dubbo 处理服务暴露的关键就在 <code>Invoker</code> 转换到 <code>Exporter</code> 的过程，上图中的红色部分。下面我们以 Dubbo 和 RMI 这两种典型协议的实现来进行说明：</p>\n<h4>Dubbo 的实现</h4>\n<p>Dubbo 协议的 <code>Invoker</code> 转为 <code>Exporter</code> 发生在 <code>DubboProtocol</code> 类的 <code>export</code> 方法，它主要是打开 socket 侦听服务，并接收客户端发来的各种请求，通讯细节由 Dubbo 自己实现。</p>\n<h4>RMI 的实现</h4>\n<p>RMI 协议的 <code>Invoker</code> 转为 <code>Exporter</code> 发生在 <code>RmiProtocol</code>类的 <code>export</code> 方法，它通过 Spring 或 Dubbo 或 JDK 来实现 RMI 服务，通讯细节这一块由 JDK 底层来实现，这就省了不少工作量。</p>\n<h3>服务消费者消费一个服务的详细过程</h3>\n<p><img src=\"sources/images/dubbo_rpc_refer.jpg\" alt=\"/dev-guide/images/dubbo_rpc_refer.jpg\"></p>\n<p>上图是服务消费的主过程：</p>\n<p>首先 <code>ReferenceConfig</code> 类的 <code>init</code> 方法调用 <code>Protocol</code> 的 <code>refer</code> 方法生成 <code>Invoker</code> 实例(如上图中的红色部分)，这是服务消费的关键。接下来把 <code>Invoker</code> 转换为客户端需要的接口(如：HelloWorld)。</p>\n<p>关于每种协议如 RMI/Dubbo/Web service 等它们在调用 <code>refer</code> 方法生成 <code>Invoker</code> 实例的细节和上一章节所描述的类似。</p>\n<h3>满眼都是 Invoker</h3>\n<p>由于 <code>Invoker</code> 是 Dubbo 领域模型中非常重要的一个概念，很多设计思路都是向它靠拢。这就使得 <code>Invoker</code> 渗透在整个实现代码里，对于刚开始接触 Dubbo 的人，确实容易给搞混了。\n下面我们用一个精简的图来说明最重要的两种 <code>Invoker</code>：服务提供 <code>Invoker</code> 和服务消费 <code>Invoker</code>：</p>\n<p><img src=\"sources/images/dubbo_rpc_invoke.jpg\" alt=\"/dev-guide/images/dubbo_rpc_invoke.jpg\"></p>\n<p>为了更好的解释上面这张图，我们结合服务消费和提供者的代码示例来进行说明：</p>\n<p>服务消费者代码：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoClientAction</span> </span>{\n \n    <span class=\"hljs-keyword\">private</span> DemoService demoService;\n \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setDemoService</span><span class=\"hljs-params\">(DemoService demoService)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.demoService = demoService;\n    }\n \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span> </span>{\n        String hello = demoService.sayHello(<span class=\"hljs-string\">\"world\"</span> + i);\n    }\n}\n</code></pre>\n<p>上面代码中的 <code>DemoService</code> 就是上图中服务消费端的 proxy，用户代码通过这个 proxy 调用其对应的 <code>Invoker</code> <sup class=\"footnote-ref\"><a href=\"#fn5\" id=\"fnref5\">[5]</a></sup>，而该 <code>Invoker</code> 实现了真正的远程服务调用。</p>\n<p>服务提供者代码：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">DemoService</span> </span>{\n \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span> <span class=\"hljs-keyword\">throws</span> RemoteException </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Hello \"</span> + name;\n    }\n}\n</code></pre>\n<p>上面这个类会被封装成为一个 <code>AbstractProxyInvoker</code> 实例，并新生成一个 <code>Exporter</code> 实例。这样当网络通讯层收到一个请求后，会找到对应的 <code>Exporter</code> 实例，并调用它所对应的 <code>AbstractProxyInvoker</code> 实例，从而真正调用了服务提供者的代码。Dubbo 里还有一些其他的 <code>Invoker</code> 类，但上面两种是最重要的。</p>\n<h2>远程通讯细节</h2>\n<h3>协议头约定</h3>\n<p><img src=\"sources/images/dubbo_protocol_header.jpg\" alt=\"/dev-guide/images/dubbo_protocol_header.jpg\"></p>\n<h3>线程派发模型</h3>\n<p><img src=\"sources/images/dubbo-protocol.jpg\" alt=\"/dev-guide/images/dubbo-protocol.jpg\"></p>\n<ul>\n<li>Dispather: <code>all</code>, <code>direct</code>, <code>message</code>, <code>execution</code>, <code>connection</code></li>\n<li>ThreadPool: <code>fixed</code>, <code>cached</code></li>\n</ul>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>即：<code>&lt;dubbo:service regisrty=&quot;N/A&quot; /&gt;</code> 或者 <code>&lt;dubbo:registry address=&quot;N/A&quot; /&gt;</code> <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>即: <code>&lt;dubbo:registry address=&quot;zookeeper://10.20.153.10:2181&quot; /&gt;</code> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>即：<code>&lt;dubbo:reference url=&quot;dubbo://service-host/com.foo.FooService?version=1.0.0&quot; /&gt;</code> <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p>即：<code>&lt;dubbo:registry address=&quot;zookeeper://10.20.153.10:2181&quot; /&gt;</code> <a href=\"#fnref4\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn5\" class=\"footnote-item\"><p><code>DubboInvoker</code>、 <code>HessianRpcInvoker</code>、 <code>InjvmInvoker</code>、 <code>RmiInvoker</code>、 <code>WebServiceInvoker</code> 中的任何一个 <a href=\"#fnref5\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n"
}