<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dubbo-go 1.5 on Apache Dubbo</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-1.5/</link><description>Recent content in Dubbo-go 1.5 on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-1.5/index.xml" rel="self" type="application/rss+xml"/><item><title>client</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-1.5/configuration/client/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-1.5/configuration/client/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
client 第一步：编写消费端的服务 编写需要被编码的结构体，由于使用 Hessian2 作为编码协议，User 需要实现 JavaClassName 方法，它的返回值在dubbo中对应User类的类名。
type User struct { Id string Name string Age int32 Time time.Time } func (u User) JavaClassName() string { return &amp;#34;org.apache.dubbo.User&amp;#34; } 与服务端不同的是，提供服务的方法作为结构体的参数，不需要编写具体业务逻辑。另外，Provider 不对应dubbo中的实现，而是对应一个接口。
type UserProvider struct { GetUser func(ctx context.Context, req []interface{}, rsp *User) error } func (u *UserProvider) Reference() string { return &amp;#34;UserProvider&amp;#34; } 注册服务和对象
func init() { config.SetConsumerService(userProvider) hessian.RegisterPOJO(&amp;amp;User{}) } 第二步：编写消费端主程序 引入必需的dubbo-go包
import ( hessian &amp;#34;github.com/apache/dubbo-go-hessian2&amp;#34; _ &amp;#34;github.</description></item><item><title>service providers</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-1.5/configuration/provider/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-1.5/configuration/provider/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
service providers 第一步：编写提供端的服务 编写需要被编码的结构体，由于使用 Hessian2 作为编码协议，User 需要实现 JavaClassName 方法，它的返回值在dubbo中对应User类的类名。
type User struct { Id string Name string Age int32 Time time.Time } func (u User) JavaClassName() string { return &amp;#34;org.apache.dubbo.User&amp;#34; } 编写业务逻辑，UserProvider 相当于dubbo中的一个服务实现。需要实现 Reference 方法，返回值是这个服务的唯一标识，对应dubbo的 beans 和 path 字段。
type UserProvider struct { } func (u *UserProvider) GetUser(ctx context.Context, req []interface{}) (*User, error) { println(&amp;#34;req:%#v&amp;#34;, req) rsp := User{&amp;#34;A001&amp;#34;, &amp;#34;hellowworld&amp;#34;, 18, time.Now()} println(&amp;#34;rsp:%#v&amp;#34;, rsp) return &amp;amp;rsp, nil } func (u *UserProvider) Reference() string { return &amp;#34;UserProvider&amp;#34; } 注册服务和对象</description></item><item><title>快速开始</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-1.5/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-1.5/quick-start/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
快速开始 通过一个 hellowworld 例子带领大家快速上手Dubbo-go框架。
协议：Dubbo 编码：Hessian2
注册中心：Zookeeper
环境 Go编程环境 启动zookeeper服务，也可以使用远程实例 从服务端开始 第一步：编写 Provider 结构体和提供服务的方法 https://github.com/dubbogo/dubbo-samples/blob/master/golang/helloworld/dubbo/go-server/app/user.go
编写需要被编码的结构体，由于使用 Hessian2 作为编码协议，User 需要实现 JavaClassName 方法，它的返回值在dubbo中对应User类的类名。 type User struct { Id string Name string Age int32 Time time.Time } func (u User) JavaClassName() string { return &amp;#34;com.ikurento.user.User&amp;#34; } 编写业务逻辑，UserProvider 相当于dubbo中的一个服务实现。需要实现 Reference 方法，返回值是这个服务的唯一标识，对应dubbo的 beans 和 path 字段。 type UserProvider struct { } func (u *UserProvider) GetUser(ctx context.Context, req []interface{}) (*User, error) { println(&amp;#34;req:%#v&amp;#34;, req) rsp := User{&amp;#34;A001&amp;#34;, &amp;#34;hellowworld&amp;#34;, 18, time.</description></item></channel></rss>