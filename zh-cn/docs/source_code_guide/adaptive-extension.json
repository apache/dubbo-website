{
  "filename": "adaptive-extension.md",
  "__html": "<h2>1.原理</h2>\n<p>在 Dubbo 中，很多拓展都是通过 SPI 机制进行加载的，比如 Protocol、Cluster、LoadBalance 等。有时，有些拓展并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载。这听起来有些矛盾。拓展未被加载，那么拓展方法就无法被调用（静态方法除外）。拓展方法未被调用，拓展就无法被加载。对于这个矛盾的问题，Dubbo 通过自适应拓展机制很好的解决了。自适应拓展机制的实现逻辑比较复杂，首先 Dubbo 会为拓展接口生成具有代理功能的代码。然后通过 javassist 或 jdk 编译这段代码，得到 Class 类。最后再通过反射创建代理类，整个过程比较复杂。为了让大家对自适应拓展有一个感性的认识，下面我们通过一个示例进行演示。这是一个与汽车相关的例子，我们有一个车轮制造厂接口 WheelMaker：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">WheelMaker</span> </span>{\n    <span class=\"hljs-function\">Wheel <span class=\"hljs-title\">makeWheel</span><span class=\"hljs-params\">(URL url)</span></span>;\n}\n</code></pre>\n<p>WheelMaker 接口的自适应实现类如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AdaptiveWheelMaker</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">WheelMaker</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Wheel <span class=\"hljs-title\">makeWheel</span><span class=\"hljs-params\">(URL url)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (url == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"url == null\"</span>);\n        }\n        \n    \t<span class=\"hljs-comment\">// 1.从 URL 中获取 WheelMaker 名称</span>\n        String wheelMakerName = url.getParameter(<span class=\"hljs-string\">\"Wheel.maker\"</span>);\n        <span class=\"hljs-keyword\">if</span> (wheelMakerName == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"wheelMakerName == null\"</span>);\n        }\n        \n        <span class=\"hljs-comment\">// 2.通过 SPI 加载具体的 WheelMaker</span>\n        WheelMaker wheelMaker = ExtensionLoader\n            .getExtensionLoader(WheelMaker.class).getExtension(wheelMakerName);\n        \n        <span class=\"hljs-comment\">// 3.调用目标方法</span>\n        <span class=\"hljs-keyword\">return</span> wheelMaker.makeWheel(URL url);\n    }\n}\n</code></pre>\n<p>AdaptiveWheelMaker 是一个代理类，与传统的代理逻辑不同，AdaptiveWheelMaker 所代理的对象是在 makeWheel 方法中通过 SPI 加载得到的。makeWheel 方法主要做了三件事情：</p>\n<ol>\n<li>从 URL 中获取 WheelMaker 名称</li>\n<li>通过 SPI 加载具体的 WheelMaker 实现类</li>\n<li>调用目标方法</li>\n</ol>\n<p>接下来，我们来看看汽车制造厂 CarMaker 接口与其实现类。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">CarMaker</span> </span>{\n    <span class=\"hljs-function\">Car <span class=\"hljs-title\">makeCar</span><span class=\"hljs-params\">(URL url)</span></span>;\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RaceCarMaker</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">CarMaker</span> </span>{\n    WheelMaker wheelMaker;\n \n    <span class=\"hljs-comment\">// 通过 setter 注入 AdaptiveWheelMaker</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">setWheelMaker</span><span class=\"hljs-params\">(WheelMaker wheelMaker)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.wheelMaker = wheelMaker;\n    }\n \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Car <span class=\"hljs-title\">makeCar</span><span class=\"hljs-params\">(URL url)</span> </span>{\n        Wheel wheel = wheelMaker.makeWheel(url);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> RaceCar(wheel, ...);\n    }\n}\n</code></pre>\n<p>RaceCarMaker 持有一个 WheelMaker 类型的成员变量，在程序启动时，我们可以将 AdaptiveWheelMaker 通过 setter 方法注入到 RaceCarMaker 中。在运行时，假设有这样一个 url 参数传入：</p>\n<pre><code class=\"language-url\">dubbo://192.168.0.101:20880/XxxService?wheel.maker=MichelinWheelMaker\n</code></pre>\n<p>RaceCarMaker 的 makeCar 方法将上面的 url 作为参数传给 AdaptiveWheelMaker 的 makeWheel 方法，makeWheel 方法从 url 中提取 wheel.maker 参数，得到 MichelinWheelMaker。之后再通过 SPI 加载配置名为 MichelinWheelMaker 的实现类，得到具体的 WheelMaker 实例。</p>\n<p>上面的示例展示了自适应拓展类的核心实现 ---- 在拓展接口的方法被调用时，通过 SPI 加载具体的拓展实现类，并调用拓展对象的同名方法。接下来，我们深入到源码中，探索自适应拓展类生成的过程。</p>\n<h2>2.源码分析</h2>\n<p>在对自适应拓展生成过程进行深入分析之前，我们先来看一下与自适应拓展息息相关的一个注解，即 Adaptive 注解。该注解的定义如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Documented</span>\n<span class=\"hljs-meta\">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class=\"hljs-meta\">@Target</span>({ElementType.TYPE, ElementType.METHOD})\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@interface</span> Adaptive {\n    String[] value() <span class=\"hljs-keyword\">default</span> {};\n}\n</code></pre>\n<p>从上面的代码中可知，Adaptive 可注解在类或方法上。当 Adaptive 注解在类上时，Dubbo 不会为该类生成代理类。注解在方法（接口方法）上时，Dubbo 则会为该方法生成代理逻辑。Adaptive 注解在类上的情况很少，在 Dubbo 中，仅有两个类被 Adaptive 注解了，分别是 AdaptiveCompiler 和 AdaptiveExtensionFactory。此种情况，表示拓展的加载逻辑由人工编码完成。更多时候，Adaptive 是注解在接口方法上的，表示拓展的加载逻辑需由框架自动生成。Adaptive 注解的地方不同，相应的处理逻辑也是不同的。注解在类上时，处理逻辑比较简单，本文就不分析了。注解在接口方法上时，处理逻辑较为复杂，本章将会重点分析此块逻辑。</p>\n<h3>2.1 获取自适应拓展</h3>\n<p>getAdaptiveExtension 方法是获取自适应拓展的入口方法，因此下面我们从这个方法进行分析。相关代码如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> T <span class=\"hljs-title\">getAdaptiveExtension</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// 从缓存中获取自适应拓展</span>\n    Object instance = cachedAdaptiveInstance.get();\n    <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {    <span class=\"hljs-comment\">// 缓存未命中</span>\n        <span class=\"hljs-keyword\">if</span> (createAdaptiveInstanceError == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">synchronized</span> (cachedAdaptiveInstance) {\n                instance = cachedAdaptiveInstance.get();\n                <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n                    <span class=\"hljs-keyword\">try</span> {\n                        <span class=\"hljs-comment\">// 创建自适应拓展</span>\n                        instance = createAdaptiveExtension();\n                        <span class=\"hljs-comment\">// 设置自适应拓展到缓存中</span>\n                        cachedAdaptiveInstance.set(instance);\n                    } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n                        createAdaptiveInstanceError = t;\n                        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"fail to create adaptive instance: ...\"</span>);\n                    }\n                }\n            }\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"fail to create adaptive instance:  ...\"</span>);\n        }\n    }\n\n    <span class=\"hljs-keyword\">return</span> (T) instance;\n}\n</code></pre>\n<p>getAdaptiveExtension 方法首先会检查缓存，缓存未命中，则调用 createAdaptiveExtension 方法创建自适应拓展。下面，我们看一下 createAdaptiveExtension 方法的代码。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> T <span class=\"hljs-title\">createAdaptiveExtension</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-comment\">// 获取自适应拓展类，并通过反射实例化</span>\n        <span class=\"hljs-keyword\">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());\n    } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"Can not create adaptive extension ...\"</span>);\n    }\n}\n</code></pre>\n<p>createAdaptiveExtension 方法的代码比较少，但却包含了三个逻辑，分别如下：</p>\n<ol>\n<li>调用 getAdaptiveExtensionClass 方法获取自适应拓展 Class 对象</li>\n<li>通过反射进行实例化</li>\n<li>调用 injectExtension 方法向拓展实例中注入依赖</li>\n</ol>\n<p>前两个逻辑比较好理解，第三个逻辑用于向自适应拓展对象中注入依赖。这个逻辑看似多余，但有存在的必要，这里简单说明一下。前面说过，Dubbo 中有两种类型的自适应拓展，一种是手工编码的，一种是自动生成的。手工编码的自适应拓展中可能存在着一些依赖，而自动生成的 Adaptive 拓展则不会依赖其他类。这里调用 injectExtension 方法的目的是为手工编码的自适应拓展注入依赖，这一点需要大家注意一下。关于 injectExtension 方法，前文已经分析过了，这里不再赘述。接下来，分析 getAdaptiveExtensionClass 方法的逻辑。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() {\n    <span class=\"hljs-comment\">// 通过 SPI 获取所有的拓展类</span>\n    getExtensionClasses();\n    <span class=\"hljs-comment\">// 检查缓存，若缓存不为空，则直接返回缓存</span>\n    <span class=\"hljs-keyword\">if</span> (cachedAdaptiveClass != <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-keyword\">return</span> cachedAdaptiveClass;\n    }\n    <span class=\"hljs-comment\">// 创建自适应拓展类</span>\n    <span class=\"hljs-keyword\">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();\n}\n</code></pre>\n<p>getAdaptiveExtensionClass 方法同样包含了三个逻辑，如下：</p>\n<ol>\n<li>调用 getExtensionClasses 获取所有的拓展类</li>\n<li>检查缓存，若缓存不为空，则返回缓存</li>\n<li>若缓存为空，则调用 createAdaptiveExtensionClass 创建自适应拓展类</li>\n</ol>\n<p>这三个逻辑看起来平淡无奇，似乎没有多讲的必要。但是这些平淡无奇的代码中隐藏了着一些细节，需要说明一下。首先从第一个逻辑说起，getExtensionClasses 这个方法用于获取某个接口的所有实现类。比如该方法可以获取 Protocol 接口的 DubboProtocol、HttpProtocol、InjvmProtocol 等实现类。在获取实现类的过程中，如果某个某个实现类被 Adaptive 注解修饰了，那么该类就会被赋值给 cachedAdaptiveClass 变量。此时，上面步骤中的第二步条件成立（缓存不为空），直接返回 cachedAdaptiveClass 即可。如果所有的实现类均未被 Adaptive 注解修饰，那么执行第三步逻辑，创建自适应拓展类。相关代码如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() {\n    <span class=\"hljs-comment\">// 构建自适应拓展代码</span>\n    String code = createAdaptiveExtensionClassCode();\n    ClassLoader classLoader = findClassLoader();\n    <span class=\"hljs-comment\">// 获取编译器实现类</span>\n    com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();\n    <span class=\"hljs-comment\">// 编译代码，生成 Class</span>\n    <span class=\"hljs-keyword\">return</span> compiler.compile(code, classLoader);\n}\n</code></pre>\n<p>createAdaptiveExtensionClass 方法用于生成自适应拓展类，该方法首先会生成自适应拓展类的源码，然后通过 Compiler 实例（Dubbo 默认使用 javassist 作为编译器）编译源码，得到代理类 Class 实例。接下来，我们把重点放在代理类代码生成的逻辑上，其他逻辑大家自行分析。</p>\n<h3>2.2 自适应拓展类代码生成</h3>\n<p>createAdaptiveExtensionClassCode 方法代码略多，约有两百行代码。因此本节将会对该方法的代码进行拆分分析，以帮助大家更好的理解代码逻辑。</p>\n<h4>2.2.1 Adaptive 注解检测</h4>\n<p>在生成代理类源码之前，createAdaptiveExtensionClassCode 方法首先会通过反射检测接口方法是否包含 Adaptive 注解。对于要生成自适应拓展的接口，Dubbo 要求该接口至少有一个方法被 Adaptive 注解修饰。若不满足此条件，就会抛出运行时异常。相关代码如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// 通过反射获取所有的方法</span>\nMethod[] methods = type.getMethods();\n<span class=\"hljs-keyword\">boolean</span> hasAdaptiveAnnotation = <span class=\"hljs-keyword\">false</span>;\n<span class=\"hljs-comment\">// 遍历方法列表</span>\n<span class=\"hljs-keyword\">for</span> (Method m : methods) {\n    <span class=\"hljs-comment\">// 检测方法上是否有 Adaptive 注解</span>\n    <span class=\"hljs-keyword\">if</span> (m.isAnnotationPresent(Adaptive.class)) {\n        hasAdaptiveAnnotation = <span class=\"hljs-keyword\">true</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    }\n}\n\n<span class=\"hljs-keyword\">if</span> (!hasAdaptiveAnnotation)\n    <span class=\"hljs-comment\">// 若所有的方法上均无 Adaptive 注解，则抛出异常</span>\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"No adaptive method on extension ...\"</span>);\n</code></pre>\n<h4>2.2.2 生成类</h4>\n<p>通过 Adaptive 注解检测后，即可开始生成代码。代码生成的顺序与 Java 文件内容顺序一致，首先会生成 package 语句，然后生成 import 语句，紧接着生成类名等代码。整个逻辑如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// 生成 package 代码：package + type 所在包</span>\ncodeBuilder.append(<span class=\"hljs-string\">\"package \"</span>).append(type.getPackage().getName()).append(<span class=\"hljs-string\">\";\"</span>);\n<span class=\"hljs-comment\">// 生成 import 代码：import + ExtensionLoader 全限定名</span>\ncodeBuilder.append(<span class=\"hljs-string\">\"\\nimport \"</span>).append(ExtensionLoader.class.getName()).append(<span class=\"hljs-string\">\";\"</span>);\n<span class=\"hljs-comment\">// 生成类代码：public class + type简单名称 + $Adaptive + implements + type全限定名 + {</span>\ncodeBuilder.append(<span class=\"hljs-string\">\"\\npublic class \"</span>)\n    .append(type.getSimpleName())\n    .append(<span class=\"hljs-string\">\"$Adaptive\"</span>)\n    .append(<span class=\"hljs-string\">\" implements \"</span>)\n    .append(type.getCanonicalName())\n    .append(<span class=\"hljs-string\">\" {\"</span>);\n\n<span class=\"hljs-comment\">// ${生成方法}</span>\n\ncodeBuilder.append(<span class=\"hljs-string\">\"\\n}\"</span>);\n</code></pre>\n<p>这里使用 ${...} 占位符代表其他代码的生成逻辑，该部分逻辑将在随后进行分析。上面代码不是很难理解，下面直接通过一个例子展示该段代码所生成的内容。以 Dubbo 的 Protocol 接口为例，生成的代码如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.alibaba.dubbo.rpc;\n<span class=\"hljs-keyword\">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Protocol</span>$<span class=\"hljs-title\">Adaptive</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">com</span>.<span class=\"hljs-title\">alibaba</span>.<span class=\"hljs-title\">dubbo</span>.<span class=\"hljs-title\">rpc</span>.<span class=\"hljs-title\">Protocol</span> </span>{\n    <span class=\"hljs-comment\">// 省略方法代码</span>\n}\n</code></pre>\n<h4>2.2.3 生成方法</h4>\n<p>一个方法可以被 Adaptive 注解修饰，也可以不被修饰。这里将未被 Adaptive 注解修饰的方法称为“无 Adaptive 注解方法”，下面我们先来看看此种方法的代码生成逻辑是怎样的。</p>\n<h5>2.2.3.1 无 Adaptive 注解方法代码生成逻辑</h5>\n<p>对于接口方法，我们可以按照需求标注  Adaptive 注解。以 Protocol 接口为例，该接口的 destroy 和 getDefaultPort 未标注 Adaptive 注解，其他方法均标注了 Adaptive 注解。Dubbo 不会为没有标注 Adaptive 注解的方法生成代理逻辑，对于该种类型的方法，仅会生成一句抛出异常的代码。生成逻辑如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">for</span> (Method method : methods) {\n    \n    <span class=\"hljs-comment\">// 省略无关逻辑</span>\n\n    Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);\n    StringBuilder code = <span class=\"hljs-keyword\">new</span> StringBuilder(<span class=\"hljs-number\">512</span>);\n    <span class=\"hljs-comment\">// 如果方法上无 Adaptive 注解，则生成 throw new UnsupportedOperationException(...) 代码</span>\n    <span class=\"hljs-keyword\">if</span> (adaptiveAnnotation == <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-comment\">// 生成的代码格式如下：</span>\n        <span class=\"hljs-comment\">// throw new UnsupportedOperationException(</span>\n        <span class=\"hljs-comment\">//     \"method \" + 方法签名 + of interface + 全限定接口名 + is not adaptive method!”)</span>\n        code.append(<span class=\"hljs-string\">\"throw new UnsupportedOperationException(\\\"method \"</span>)\n            .append(method.toString()).append(<span class=\"hljs-string\">\" of interface \"</span>)\n            .append(type.getName()).append(<span class=\"hljs-string\">\" is not adaptive method!\\\");\"</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 省略无关逻辑</span>\n    }\n    \n    <span class=\"hljs-comment\">// 省略无关逻辑</span>\n}\n</code></pre>\n<p>以 Protocol 接口的 destroy 方法为例，上面代码生成的内容如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnsupportedOperationException(\n            <span class=\"hljs-string\">\"method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!\"</span>);\n</code></pre>\n<h5>2.2.3.2 获取 URL 数据</h5>\n<p>前面说过方法代理逻辑会从 URL 中提取目标拓展的名称，因此代码生成逻辑的一个重要的任务是从方法的参数列表或者其他参数中获取 URL 数据。举例说明一下，我们要为 Protocol 接口的 refer 和 export 方法生成代理逻辑。在运行时，通过反射得到的方法定义大致如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\">Invoker <span class=\"hljs-title\">refer</span><span class=\"hljs-params\">(Class&lt;T&gt; arg0, URL arg1)</span> <span class=\"hljs-keyword\">throws</span> RpcException</span>;\n<span class=\"hljs-function\">Exporter <span class=\"hljs-title\">export</span><span class=\"hljs-params\">(Invoker&lt;T&gt; arg0)</span> <span class=\"hljs-keyword\">throws</span> RpcException</span>;\n</code></pre>\n<p>对于 refer 方法，通过遍历 refer 的参数列表即可获取 URL 数据，这个还比较简单。对于 export 方法，获取 URL 数据则要麻烦一些。export 参数列表中没有 URL 参数，因此需要从 Invoker 参数中获取 URL 数据。获取方式是调用 Invoker 中可返回 URL 的 getter 方法，比如 getUrl。如果 Invoker 中无相关 getter 方法，此时则会抛出异常。整个逻辑如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">for</span> (Method method : methods) {\n    Class&lt;?&gt; rt = method.getReturnType();\n    Class&lt;?&gt;[] pts = method.getParameterTypes();\n    Class&lt;?&gt;[] ets = method.getExceptionTypes();\n\n    Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);\n    StringBuilder code = <span class=\"hljs-keyword\">new</span> StringBuilder(<span class=\"hljs-number\">512</span>);\n    <span class=\"hljs-keyword\">if</span> (adaptiveAnnotation == <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-comment\">// ${无 Adaptive 注解方法代码生成逻辑}</span>\n    } <span class=\"hljs-keyword\">else</span> {\n    \t<span class=\"hljs-keyword\">int</span> urlTypeIndex = -<span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-comment\">// 遍历参数列表，确定 URL 参数位置</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; pts.length; ++i) {\n            <span class=\"hljs-keyword\">if</span> (pts[i].equals(URL.class)) {\n                urlTypeIndex = i;\n                <span class=\"hljs-keyword\">break</span>;\n            }\n        }\n        \n        <span class=\"hljs-comment\">// urlTypeIndex != -1，表示参数列表中存在 URL 参数</span>\n        <span class=\"hljs-keyword\">if</span> (urlTypeIndex != -<span class=\"hljs-number\">1</span>) {\n            <span class=\"hljs-comment\">// 为 URL 类型参数生成判空代码，格式如下：</span>\n            <span class=\"hljs-comment\">// if (arg + urlTypeIndex == null) </span>\n            <span class=\"hljs-comment\">//     throw new IllegalArgumentException(\"url == null\");</span>\n            String s = String.format(<span class=\"hljs-string\">\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"url == null\\\");\"</span>,\n                                     urlTypeIndex);\n            code.append(s);\n\n            <span class=\"hljs-comment\">// 为 URL 类型参数生成赋值代码，形如 URL url = arg1</span>\n            s = String.format(<span class=\"hljs-string\">\"\\n%s url = arg%d;\"</span>, URL.class.getName(), urlTypeIndex);\n            code.append(s);\n            \n        <span class=\"hljs-comment\">// 参数列表中不存在 URL 类型参数</span>\n        } <span class=\"hljs-keyword\">else</span> {\n            String attribMethod = <span class=\"hljs-keyword\">null</span>;\n\n            LBL_PTS:\n            <span class=\"hljs-comment\">// 遍历方法的参数类型列表</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; pts.length; ++i) {\n                <span class=\"hljs-comment\">// 获取某一类型参数的全部方法</span>\n                Method[] ms = pts[i].getMethods();\n                <span class=\"hljs-comment\">// 遍历方法列表，寻找可返回 URL 的 getter 方法</span>\n                <span class=\"hljs-keyword\">for</span> (Method m : ms) {\n                    String name = m.getName();\n                    <span class=\"hljs-comment\">// 1. 方法名以 get 开头，或方法名大于3个字符</span>\n                    <span class=\"hljs-comment\">// 2. 方法的访问权限为 public</span>\n                    <span class=\"hljs-comment\">// 3. 非静态方法</span>\n                    <span class=\"hljs-comment\">// 4. 方法参数数量为0</span>\n                    <span class=\"hljs-comment\">// 5. 方法返回值类型为 URL</span>\n                    <span class=\"hljs-keyword\">if</span> ((name.startsWith(<span class=\"hljs-string\">\"get\"</span>) || name.length() &gt; <span class=\"hljs-number\">3</span>)\n                        &amp;&amp; Modifier.isPublic(m.getModifiers())\n                        &amp;&amp; !Modifier.isStatic(m.getModifiers())\n                        &amp;&amp; m.getParameterTypes().length == <span class=\"hljs-number\">0</span>\n                        &amp;&amp; m.getReturnType() == URL.class) {\n                        urlTypeIndex = i;\n                        attribMethod = name;\n                        \n                        <span class=\"hljs-comment\">// 结束 for (int i = 0; i &lt; pts.length; ++i) 循环</span>\n                        <span class=\"hljs-keyword\">break</span> LBL_PTS;\n                    }\n                }\n            }\n            <span class=\"hljs-keyword\">if</span> (attribMethod == <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-comment\">// 如果所有参数中均不包含可返回 URL 的 getter 方法，则抛出异常</span>\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"fail to create adaptive class for interface ...\"</span>);\n            }\n\n            <span class=\"hljs-comment\">// 为可返回 URL 的参数生成判空代码，格式如下：</span>\n            <span class=\"hljs-comment\">// if (arg + urlTypeIndex == null) </span>\n            <span class=\"hljs-comment\">//     throw new IllegalArgumentException(\"参数全限定名 + argument == null\");</span>\n            String s = String.format(<span class=\"hljs-string\">\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"%s argument == null\\\");\"</span>,\n                                     urlTypeIndex, pts[urlTypeIndex].getName());\n            code.append(s);\n\n            <span class=\"hljs-comment\">// 为 getter 方法返回的 URL 生成判空代码，格式如下：</span>\n            <span class=\"hljs-comment\">// if (argN.getter方法名() == null) </span>\n            <span class=\"hljs-comment\">//     throw new IllegalArgumentException(参数全限定名 + argument getUrl() == null);</span>\n            s = String.format(<span class=\"hljs-string\">\"\\nif (arg%d.%s() == null) throw new IllegalArgumentException(\\\"%s argument %s() == null\\\");\"</span>,\n                              urlTypeIndex, attribMethod, pts[urlTypeIndex].getName(), attribMethod);\n            code.append(s);\n\n            <span class=\"hljs-comment\">// 生成赋值语句，格式如下：</span>\n            <span class=\"hljs-comment\">// URL全限定名 url = argN.getter方法名()，比如 </span>\n            <span class=\"hljs-comment\">// com.alibaba.dubbo.common.URL url = invoker.getUrl();</span>\n            s = String.format(<span class=\"hljs-string\">\"%s url = arg%d.%s();\"</span>, URL.class.getName(), urlTypeIndex, attribMethod);\n            code.append(s);\n        }\n        \n        <span class=\"hljs-comment\">// 省略无关代码</span>\n    }\n    \n    <span class=\"hljs-comment\">// 省略无关代码</span>\n}\n</code></pre>\n<p>上面代码有点多，需要耐心看一下。这段代码主要目的是为了获取 URL 数据，并为之生成判空和赋值代码。以 Protocol 的 refer 和 export 方法为例，上面的代码为它们生成如下内容（代码已格式化）：</p>\n<pre><code class=\"language-java\">refer:\n<span class=\"hljs-keyword\">if</span> (arg1 == <span class=\"hljs-keyword\">null</span>) \n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"url == null\"</span>);\ncom.alibaba.dubbo.common.URL url = arg1;\n\nexport:\n<span class=\"hljs-keyword\">if</span> (arg0 == <span class=\"hljs-keyword\">null</span>) \n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"com.alibaba.dubbo.rpc.Invoker argument == null\"</span>);\n<span class=\"hljs-keyword\">if</span> (arg0.getUrl() == <span class=\"hljs-keyword\">null</span>) \n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"com.alibaba.dubbo.rpc.Invoker argument getUrl() == null\"</span>);\ncom.alibaba.dubbo.common.URL url = arg0.getUrl();\n</code></pre>\n<h5>2.2.3.3 获取 Adaptive 注解值</h5>\n<p>Adaptive 注解值 value 类型为 String[]，可填写多个值，默认情况下为空数组。若 value 为非空数组，直接获取数组内容即可。若 value 为空数组，则需进行额外处理。处理过程是将类名转换为字符数组，然后遍历字符数组，并将字符放入 StringBuilder 中。若字符为大写字母，则向 StringBuilder 中添加点号，随后将字符变为小写存入 StringBuilder 中。比如 LoadBalance 经过处理后，得到 load.balance。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">for</span> (Method method : methods) {\n    Class&lt;?&gt; rt = method.getReturnType();\n    Class&lt;?&gt;[] pts = method.getParameterTypes();\n    Class&lt;?&gt;[] ets = method.getExceptionTypes();\n\n    Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);\n    StringBuilder code = <span class=\"hljs-keyword\">new</span> StringBuilder(<span class=\"hljs-number\">512</span>);\n    <span class=\"hljs-keyword\">if</span> (adaptiveAnnotation == <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-comment\">// ${无 Adaptive 注解方法代码生成逻辑}</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// ${获取 URL 数据}</span>\n        \n        String[] value = adaptiveAnnotation.value();\n        <span class=\"hljs-comment\">// value 为空数组</span>\n        <span class=\"hljs-keyword\">if</span> (value.length == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-comment\">// 获取类名，并将类名转换为字符数组</span>\n            <span class=\"hljs-keyword\">char</span>[] charArray = type.getSimpleName().toCharArray();\n            StringBuilder sb = <span class=\"hljs-keyword\">new</span> StringBuilder(<span class=\"hljs-number\">128</span>);\n            <span class=\"hljs-comment\">// 遍历字节数组</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; charArray.length; i++) {\n                <span class=\"hljs-comment\">// 检测当前字符是否为大写字母</span>\n                <span class=\"hljs-keyword\">if</span> (Character.isUpperCase(charArray[i])) {\n                    <span class=\"hljs-keyword\">if</span> (i != <span class=\"hljs-number\">0</span>) {\n                        <span class=\"hljs-comment\">// 向 sb 中添加点号</span>\n                        sb.append(<span class=\"hljs-string\">\".\"</span>);\n                    }\n                    <span class=\"hljs-comment\">// 将字符变为小写，并添加到 sb 中</span>\n                    sb.append(Character.toLowerCase(charArray[i]));\n                } <span class=\"hljs-keyword\">else</span> {\n                    <span class=\"hljs-comment\">// 添加字符到 sb 中</span>\n                    sb.append(charArray[i]);\n                }\n            }\n            value = <span class=\"hljs-keyword\">new</span> String[]{sb.toString()};\n        }\n        \n        <span class=\"hljs-comment\">// 省略无关代码</span>\n    }\n    \n    <span class=\"hljs-comment\">// 省略无关逻辑</span>\n}\n</code></pre>\n<h5>2.2.3.4 检测 Invocation 参数</h5>\n<p>此段逻辑是检测方法列表中是否存在 Invocation 类型的参数，若存在，则为其生成判空代码和其他一些代码。相应的逻辑如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">for</span> (Method method : methods) {\n    Class&lt;?&gt; rt = method.getReturnType();\n    Class&lt;?&gt;[] pts = method.getParameterTypes();    <span class=\"hljs-comment\">// 获取参数类型列表</span>\n    Class&lt;?&gt;[] ets = method.getExceptionTypes();\n\n    Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);\n    StringBuilder code = <span class=\"hljs-keyword\">new</span> StringBuilder(<span class=\"hljs-number\">512</span>);\n    <span class=\"hljs-keyword\">if</span> (adaptiveAnnotation == <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-comment\">// ${无 Adaptive 注解方法代码生成逻辑}</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// ${获取 URL 数据}</span>\n        \n        <span class=\"hljs-comment\">// ${获取 Adaptive 注解值}</span>\n        \n        <span class=\"hljs-keyword\">boolean</span> hasInvocation = <span class=\"hljs-keyword\">false</span>;\n        <span class=\"hljs-comment\">// 遍历参数类型列表</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; pts.length; ++i) {\n            <span class=\"hljs-comment\">// 判断当前参数名称是否等于 com.alibaba.dubbo.rpc.Invocation</span>\n            <span class=\"hljs-keyword\">if</span> (pts[i].getName().equals(<span class=\"hljs-string\">\"com.alibaba.dubbo.rpc.Invocation\"</span>)) {\n                <span class=\"hljs-comment\">// 为 Invocation 类型参数生成判空代码</span>\n                String s = String.format(<span class=\"hljs-string\">\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"invocation == null\\\");\"</span>, i);\n                code.append(s);\n                <span class=\"hljs-comment\">// 生成 getMethodName 方法调用代码，格式为：</span>\n                <span class=\"hljs-comment\">//    String methodName = argN.getMethodName();</span>\n                s = String.format(<span class=\"hljs-string\">\"\\nString methodName = arg%d.getMethodName();\"</span>, i);\n                code.append(s);\n                \n                <span class=\"hljs-comment\">// 设置 hasInvocation 为 true</span>\n                hasInvocation = <span class=\"hljs-keyword\">true</span>;\n                <span class=\"hljs-keyword\">break</span>;\n            }\n        }\n    }\n    \n    <span class=\"hljs-comment\">// 省略无关逻辑</span>\n}\n</code></pre>\n<h5>2.2.3.5 生成拓展名获取逻辑</h5>\n<p>本段逻辑用于根据 SPI 和 Adaptive 注解值生成“获取拓展名逻辑”，同时生成逻辑也受 Invocation 类型参数影响，综合因素导致本段逻辑相对复杂。本段逻辑可以会生成但不限于下面的代码：</p>\n<pre><code class=\"language-java\">String extName = (url.getProtocol() == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-string\">\"dubbo\"</span> : url.getProtocol());\n</code></pre>\n<p>或</p>\n<pre><code class=\"language-java\">String extName = url.getMethodParameter(methodName, <span class=\"hljs-string\">\"loadbalance\"</span>, <span class=\"hljs-string\">\"random\"</span>);\n</code></pre>\n<p>亦或是</p>\n<pre><code class=\"language-java\">String extName = url.getParameter(<span class=\"hljs-string\">\"client\"</span>, url.getParameter(<span class=\"hljs-string\">\"transporter\"</span>, <span class=\"hljs-string\">\"netty\"</span>));\n</code></pre>\n<p>本段逻辑复杂之处在于条件分支比较多，大家在阅读源码时需要知道每个条件分支的意义是什么，否则不太容易看懂相关代码。下面开始分析本段逻辑。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">for</span> (Method method : methods) {\n    Class&lt;?&gt; rt = method.getReturnType();\n    Class&lt;?&gt;[] pts = method.getParameterTypes();\n    Class&lt;?&gt;[] ets = method.getExceptionTypes();\n\n    Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);\n    StringBuilder code = <span class=\"hljs-keyword\">new</span> StringBuilder(<span class=\"hljs-number\">512</span>);\n    <span class=\"hljs-keyword\">if</span> (adaptiveAnnotation == <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-comment\">// $无 Adaptive 注解方法代码生成逻辑}</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// ${获取 URL 数据}</span>\n        \n        <span class=\"hljs-comment\">// ${获取 Adaptive 注解值}</span>\n        \n        <span class=\"hljs-comment\">// ${检测 Invocation 参数}</span>\n        \n        <span class=\"hljs-comment\">// 设置默认拓展名，cachedDefaultName 源于 SPI 注解值，默认情况下，</span>\n        <span class=\"hljs-comment\">// SPI 注解值为空串，此时 cachedDefaultName = null</span>\n        String defaultExtName = cachedDefaultName;\n        String getNameCode = <span class=\"hljs-keyword\">null</span>;\n        \n        <span class=\"hljs-comment\">// 遍历 value，这里的 value 是 Adaptive 的注解值，2.2.3.3 节分析过 value 变量的获取过程。</span>\n        <span class=\"hljs-comment\">// 此处循环目的是生成从 URL 中获取拓展名的代码，生成的代码会赋值给 getNameCode 变量。注意这</span>\n        <span class=\"hljs-comment\">// 个循环的遍历顺序是由后向前遍历的。</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = value.length - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; --i) {\n            <span class=\"hljs-comment\">// 当 i 为最后一个元素的坐标时</span>\n            <span class=\"hljs-keyword\">if</span> (i == value.length - <span class=\"hljs-number\">1</span>) {\n                <span class=\"hljs-comment\">// 默认拓展名非空</span>\n                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">null</span> != defaultExtName) {\n                    <span class=\"hljs-comment\">// protocol 是 url 的一部分，可通过 getProtocol 方法获取，其他的则是从</span>\n                    <span class=\"hljs-comment\">// URL 参数中获取。因为获取方式不同，所以这里要判断 value[i] 是否为 protocol</span>\n                    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-string\">\"protocol\"</span>.equals(value[i]))\n                    \t<span class=\"hljs-comment\">// hasInvocation 用于标识方法参数列表中是否有 Invocation 类型参数</span>\n                        <span class=\"hljs-keyword\">if</span> (hasInvocation)\n                            <span class=\"hljs-comment\">// 生成的代码功能等价于下面的代码：</span>\n                            <span class=\"hljs-comment\">//   url.getMethodParameter(methodName, value[i], defaultExtName)</span>\n                            <span class=\"hljs-comment\">// 以 LoadBalance 接口的 select 方法为例，最终生成的代码如下：</span>\n                            <span class=\"hljs-comment\">//   url.getMethodParameter(methodName, \"loadbalance\", \"random\")</span>\n                            getNameCode = String.format(<span class=\"hljs-string\">\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\"</span>, value[i], defaultExtName);\n                    \t<span class=\"hljs-keyword\">else</span>\n                    \t\t<span class=\"hljs-comment\">// 生成的代码功能等价于下面的代码：</span>\n\t                        <span class=\"hljs-comment\">//   url.getParameter(value[i], defaultExtName)</span>\n\t                        getNameCode = String.format(<span class=\"hljs-string\">\"url.getParameter(\\\"%s\\\", \\\"%s\\\")\"</span>, value[i], defaultExtName);\n                    <span class=\"hljs-keyword\">else</span>\n                    \t<span class=\"hljs-comment\">// 生成的代码功能等价于下面的代码：</span>\n                        <span class=\"hljs-comment\">//   ( url.getProtocol() == null ? defaultExtName : url.getProtocol() )</span>\n                        getNameCode = String.format(<span class=\"hljs-string\">\"( url.getProtocol() == null ? \\\"%s\\\" : url.getProtocol() )\"</span>, defaultExtName);\n                    \n                <span class=\"hljs-comment\">// 默认拓展名为空</span>\n                } <span class=\"hljs-keyword\">else</span> {\n                    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-string\">\"protocol\"</span>.equals(value[i]))\n                        <span class=\"hljs-keyword\">if</span> (hasInvocation)\n                        \t<span class=\"hljs-comment\">// 生成代码格式同上</span>\n                            getNameCode = String.format(<span class=\"hljs-string\">\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\"</span>, value[i], defaultExtName);\n\t                    <span class=\"hljs-keyword\">else</span>\n\t                    \t<span class=\"hljs-comment\">// 生成的代码功能等价于下面的代码：</span>\n\t                        <span class=\"hljs-comment\">//   url.getParameter(value[i])</span>\n\t                        getNameCode = String.format(<span class=\"hljs-string\">\"url.getParameter(\\\"%s\\\")\"</span>, value[i]);\n                    <span class=\"hljs-keyword\">else</span>\n                    \t<span class=\"hljs-comment\">// 生成从 url 中获取协议的代码，比如 \"dubbo\"</span>\n                        getNameCode = <span class=\"hljs-string\">\"url.getProtocol()\"</span>;\n                }\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-string\">\"protocol\"</span>.equals(value[i]))\n                    <span class=\"hljs-keyword\">if</span> (hasInvocation)\n                        <span class=\"hljs-comment\">// 生成代码格式同上</span>\n                        getNameCode = String.format(<span class=\"hljs-string\">\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\"</span>, value[i], defaultExtName);\n\t                <span class=\"hljs-keyword\">else</span>\n\t                \t<span class=\"hljs-comment\">// 生成的代码功能等价于下面的代码：</span>\n\t                    <span class=\"hljs-comment\">//   url.getParameter(value[i], getNameCode)</span>\n\t                    <span class=\"hljs-comment\">// 以 Transporter 接口的 connect 方法为例，最终生成的代码如下：</span>\n\t                    <span class=\"hljs-comment\">//   url.getParameter(\"client\", url.getParameter(\"transporter\", \"netty\"))</span>\n\t                    getNameCode = String.format(<span class=\"hljs-string\">\"url.getParameter(\\\"%s\\\", %s)\"</span>, value[i], getNameCode);\n                <span class=\"hljs-keyword\">else</span>\n                    <span class=\"hljs-comment\">// 生成的代码功能等价于下面的代码：</span>\n                    <span class=\"hljs-comment\">//   url.getProtocol() == null ? getNameCode : url.getProtocol()</span>\n                    <span class=\"hljs-comment\">// 以 Protocol 接口的 connect 方法为例，最终生成的代码如下：</span>\n                    <span class=\"hljs-comment\">//   url.getProtocol() == null ? \"dubbo\" : url.getProtocol()</span>\n                    getNameCode = String.format(<span class=\"hljs-string\">\"url.getProtocol() == null ? (%s) : url.getProtocol()\"</span>, getNameCode);\n            }\n        }\n        <span class=\"hljs-comment\">// 生成 extName 赋值代码</span>\n        code.append(<span class=\"hljs-string\">\"\\nString extName = \"</span>).append(getNameCode).append(<span class=\"hljs-string\">\";\"</span>);\n        <span class=\"hljs-comment\">// 生成 extName 判空代码</span>\n        String s = String.format(<span class=\"hljs-string\">\"\\nif(extName == null) \"</span> +\n                                 <span class=\"hljs-string\">\"throw new IllegalStateException(\\\"Fail to get extension(%s) name from url(\\\" + url.toString() + \\\") use keys(%s)\\\");\"</span>,\n                                 type.getName(), Arrays.toString(value));\n        code.append(s);\n    }\n    \n    <span class=\"hljs-comment\">// 省略无关逻辑</span>\n}\n</code></pre>\n<p>上面代码比较复杂，不是很好理解。对于这段代码，建议大家写点测试用例，对 Protocol、LoadBalance 以及 Transporter 等接口的自适应拓展类代码生成过程进行调试。这里我以 Transporter  接口的自适应拓展类代码生成过程举例说明。首先看一下 Transporter 接口的定义，如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@SPI</span>(<span class=\"hljs-string\">\"netty\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Transporter</span> </span>{\n\t<span class=\"hljs-comment\">// @Adaptive({server, transporter})</span>\n    <span class=\"hljs-meta\">@Adaptive</span>({Constants.SERVER_KEY, Constants.TRANSPORTER_KEY}) \n    <span class=\"hljs-function\">Server <span class=\"hljs-title\">bind</span><span class=\"hljs-params\">(URL url, ChannelHandler handler)</span> <span class=\"hljs-keyword\">throws</span> RemotingException</span>;\n\n    <span class=\"hljs-comment\">// @Adaptive({client, transporter})</span>\n    <span class=\"hljs-meta\">@Adaptive</span>({Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY})\n    <span class=\"hljs-function\">Client <span class=\"hljs-title\">connect</span><span class=\"hljs-params\">(URL url, ChannelHandler handler)</span> <span class=\"hljs-keyword\">throws</span> RemotingException</span>;\n}\n</code></pre>\n<p>下面对 connect 方法代理逻辑生成的过程进行分析，此时生成代理逻辑所用到的变量如下：</p>\n<pre><code class=\"language-java\">String defaultExtName = <span class=\"hljs-string\">\"netty\"</span>;\n<span class=\"hljs-keyword\">boolean</span> hasInvocation = <span class=\"hljs-keyword\">false</span>;\nString getNameCode = <span class=\"hljs-keyword\">null</span>;\nString[] value = [<span class=\"hljs-string\">\"client\"</span>, <span class=\"hljs-string\">\"transporter\"</span>];\n</code></pre>\n<p>下面对 value 数组进行遍历，此时 i = 1, value[i] = &quot;transporter&quot;，生成的代码如下：</p>\n<pre><code class=\"language-java\">getNameCode = url.getParameter(<span class=\"hljs-string\">\"transporter\"</span>, <span class=\"hljs-string\">\"netty\"</span>);\n</code></pre>\n<p>接下来，for 循环继续执行，此时 i = 0, value[i] = &quot;client&quot;，生成的代码如下：</p>\n<pre><code class=\"language-java\">getNameCode = url.getParameter(<span class=\"hljs-string\">\"client\"</span>, url.getParameter(<span class=\"hljs-string\">\"transporter\"</span>, <span class=\"hljs-string\">\"netty\"</span>));\n</code></pre>\n<p>for 循环结束运行，现在为  extName 变量生成赋值和判空代码，如下：</p>\n<pre><code class=\"language-java\">String extName = url.getParameter(<span class=\"hljs-string\">\"client\"</span>, url.getParameter(<span class=\"hljs-string\">\"transporter\"</span>, <span class=\"hljs-string\">\"netty\"</span>));\n<span class=\"hljs-keyword\">if</span> (extName == <span class=\"hljs-keyword\">null</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(\n        <span class=\"hljs-string\">\"Fail to get extension(com.alibaba.dubbo.remoting.Transporter) name from url(\"</span> + url.toString()\n        + <span class=\"hljs-string\">\") use keys([client, transporter])\"</span>);\n}\n</code></pre>\n<h5>2.2.3.6 生成拓展加载与目标方法调用逻辑</h5>\n<p>本段代码逻辑用于根据拓展名加载拓展实例，并调用拓展实例的目标方法。相关逻辑如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">for</span> (Method method : methods) {\n    Class&lt;?&gt; rt = method.getReturnType();\n    Class&lt;?&gt;[] pts = method.getParameterTypes();\n    Class&lt;?&gt;[] ets = method.getExceptionTypes();\n\n    Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);\n    StringBuilder code = <span class=\"hljs-keyword\">new</span> StringBuilder(<span class=\"hljs-number\">512</span>);\n    <span class=\"hljs-keyword\">if</span> (adaptiveAnnotation == <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-comment\">// $无 Adaptive 注解方法代码生成逻辑}</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// ${获取 URL 数据}</span>\n        \n        <span class=\"hljs-comment\">// ${获取 Adaptive 注解值}</span>\n        \n        <span class=\"hljs-comment\">// ${检测 Invocation 参数}</span>\n        \n        <span class=\"hljs-comment\">// ${生成拓展名获取逻辑}</span>\n        \n        <span class=\"hljs-comment\">// 生成拓展获取代码，格式如下：</span>\n        <span class=\"hljs-comment\">// type全限定名 extension = (type全限定名)ExtensionLoader全限定名</span>\n        <span class=\"hljs-comment\">//     .getExtensionLoader(type全限定名.class).getExtension(extName);</span>\n        <span class=\"hljs-comment\">// Tips: 格式化字符串中的 %&lt;s 表示使用前一个转换符所描述的参数，即 type 全限定名</span>\n        s = String.format(<span class=\"hljs-string\">\"\\n%s extension = (%&lt;s)%s.getExtensionLoader(%s.class).getExtension(extName);\"</span>,\n                        type.getName(), ExtensionLoader.class.getSimpleName(), type.getName());\n        code.append(s);\n\n\t\t<span class=\"hljs-comment\">// 如果方法返回值类型非 void，则生成 return 语句。</span>\n        <span class=\"hljs-keyword\">if</span> (!rt.equals(<span class=\"hljs-keyword\">void</span>.class)) {\n            code.append(<span class=\"hljs-string\">\"\\nreturn \"</span>);\n        }\n\n        <span class=\"hljs-comment\">// 生成目标方法调用逻辑，格式为：</span>\n        <span class=\"hljs-comment\">//     extension.方法名(arg0, arg2, ..., argN);</span>\n        s = String.format(<span class=\"hljs-string\">\"extension.%s(\"</span>, method.getName());\n        code.append(s);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; pts.length; i++) {\n            <span class=\"hljs-keyword\">if</span> (i != <span class=\"hljs-number\">0</span>)\n                code.append(<span class=\"hljs-string\">\", \"</span>);\n            code.append(<span class=\"hljs-string\">\"arg\"</span>).append(i);\n        }\n        code.append(<span class=\"hljs-string\">\");\"</span>);   \n    }\n    \n    <span class=\"hljs-comment\">// 省略无关逻辑</span>\n}\n</code></pre>\n<p>以 Protocol 接口举例说明，上面代码生成的内容如下：</p>\n<pre><code class=\"language-java\">com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol) ExtensionLoader\n    .getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);\n<span class=\"hljs-keyword\">return</span> extension.refer(arg0, arg1);\n</code></pre>\n<h5>2.2.3.7 生成完整的方法</h5>\n<p>本节进行代码生成的收尾工作，主要用于生成方法定义的代码。相关逻辑如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">for</span> (Method method : methods) {\n    Class&lt;?&gt; rt = method.getReturnType();\n    Class&lt;?&gt;[] pts = method.getParameterTypes();\n    Class&lt;?&gt;[] ets = method.getExceptionTypes();\n\n    Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);\n    StringBuilder code = <span class=\"hljs-keyword\">new</span> StringBuilder(<span class=\"hljs-number\">512</span>);\n    <span class=\"hljs-keyword\">if</span> (adaptiveAnnotation == <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-comment\">// $无 Adaptive 注解方法代码生成逻辑}</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// ${获取 URL 数据}</span>\n        \n        <span class=\"hljs-comment\">// ${获取 Adaptive 注解值}</span>\n        \n        <span class=\"hljs-comment\">// ${检测 Invocation 参数}</span>\n        \n        <span class=\"hljs-comment\">// ${生成拓展名获取逻辑}</span>\n        \n        <span class=\"hljs-comment\">// ${生成拓展加载与目标方法调用逻辑}</span>\n    }\n}\n    \n<span class=\"hljs-comment\">// public + 返回值全限定名 + 方法名 + (</span>\ncodeBuilder.append(<span class=\"hljs-string\">\"\\npublic \"</span>)\n    .append(rt.getCanonicalName())\n    .append(<span class=\"hljs-string\">\" \"</span>)\n    .append(method.getName())\n    .append(<span class=\"hljs-string\">\"(\"</span>);\n\n<span class=\"hljs-comment\">// 添加参数列表代码</span>\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; pts.length; i++) {\n    <span class=\"hljs-keyword\">if</span> (i &gt; <span class=\"hljs-number\">0</span>) {\n        codeBuilder.append(<span class=\"hljs-string\">\", \"</span>);\n    }\n    codeBuilder.append(pts[i].getCanonicalName());\n    codeBuilder.append(<span class=\"hljs-string\">\" \"</span>);\n    codeBuilder.append(<span class=\"hljs-string\">\"arg\"</span>).append(i);\n}\ncodeBuilder.append(<span class=\"hljs-string\">\")\"</span>);\n\n<span class=\"hljs-comment\">// 添加异常抛出代码</span>\n<span class=\"hljs-keyword\">if</span> (ets.length &gt; <span class=\"hljs-number\">0</span>) {\n    codeBuilder.append(<span class=\"hljs-string\">\" throws \"</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; ets.length; i++) {\n        <span class=\"hljs-keyword\">if</span> (i &gt; <span class=\"hljs-number\">0</span>) {\n            codeBuilder.append(<span class=\"hljs-string\">\", \"</span>);\n        }\n        codeBuilder.append(ets[i].getCanonicalName());\n    }\n}\ncodeBuilder.append(<span class=\"hljs-string\">\" {\"</span>);\ncodeBuilder.append(code.toString());\ncodeBuilder.append(<span class=\"hljs-string\">\"\\n}\"</span>);\n</code></pre>\n<p>以 Protocol 的 refer 方法为例，上面代码生成的内容如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> com.alibaba.dubbo.rpc.<span class=\"hljs-function\">Invoker <span class=\"hljs-title\">refer</span><span class=\"hljs-params\">(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1)</span> </span>{\n    <span class=\"hljs-comment\">// 方法体</span>\n}\n</code></pre>\n<h2>3.总结</h2>\n<p>到此，关于自适应拓展的原理，实现就分析完了。总的来说自适应拓展整个逻辑还是很复杂的，并不是很容易弄懂。因此，大家在阅读该部分源码时，耐心一些。同时多进行调试，也可以通过生成好的代码思考代码的生成逻辑。好了，本篇文章就分析到这里。</p>\n",
  "link": "/zh-cn/docs/source_code_guide/adaptive-extension.html",
  "meta": {
    "title": "SPI 自适应拓展",
    "keywords": "Dubbo, SPI, Adaptive Extension",
    "description": "本文介绍了自适应拓展的原理和实现细节"
  }
}