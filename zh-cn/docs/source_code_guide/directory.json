{
  "filename": "directory.md",
  "__html": "<h2>1. 简介</h2>\n<p>本篇文章，将开始分析 Dubbo 集群容错方面的源码。集群容错源码包含四个部分，分别是服务目录 Directory、服务路由 Router、集群 Cluster 和负载均衡 LoadBalance。这几个部分的源码逻辑相对比较独立，我们将会分四篇文章进行分析。本篇文章作为集群容错的开篇文章，将和大家一起分析服务目录相关的源码。在进行深入分析之前，我们先来了解一下服务目录是什么。服务目录中存储了一些和服务提供者有关的信息，通过服务目录，服务消费者可获取到服务提供者的信息，比如 ip、端口、服务协议等。通过这些信息，服务消费者就可通过 Netty 等客户端进行远程调用。在一个服务集群中，服务提供者数量并不是一成不变的，如果集群中新增了一台机器，相应地在服务目录中就要新增一条服务提供者记录。或者，如果服务提供者的配置修改了，服务目录中的记录也要做相应的更新。如果这样说，服务目录和注册中心的功能不就雷同了吗？确实如此，这里这么说是为了方便大家理解。实际上服务目录在获取注册中心的服务配置信息后，会为每条配置信息生成一个 Invoker 对象，并把这个 Invoker 对象存储起来，这个 Invoker 才是服务目录最终持有的对象。Invoker 有什么用呢？看名字就知道了，这是一个具有远程调用功能的对象。讲到这大家应该知道了什么是服务目录了，它可以看做是 Invoker 集合，且这个集合中的元素会随注册中心的变化而进行动态调整。</p>\n<p>关于服务目录这里就先介绍这些，大家先有个大致印象。接下来我们通过继承体系图来了解一下服务目录的家族成员都有哪些。</p>\n<h2>2. 继承体系</h2>\n<p>服务目录目前内置的实现有两个，分别为 StaticDirectory 和 RegistryDirectory，它们均是 AbstractDirectory 的子类。AbstractDirectory 实现了 Directory 接口，这个接口包含了一个重要的方法定义，即 list(Invocation)，用于列举 Invoker。下面我们来看一下他们的继承体系图。</p>\n<p><img src=\"./sources/images/directory-inherit-hierarchy.png\" alt=\"\"></p>\n<p>如上，Directory 继承自 Node 接口，Node 这个接口继承者比较多，像 Registry、Monitor、Invoker 等均继承了这个接口。这个接口包含了一个获取配置信息的方法 getUrl，实现该接口的类可以向外提供配置信息。另外，大家注意看 RegistryDirectory 实现了 NotifyListener 接口，当注册中心节点信息发生变化后，RegistryDirectory 可以通过此接口方法得到变更信息，并根据变更信息动态调整内部 Invoker 列表。</p>\n<h2>3. 源码分析</h2>\n<p>本章将分析 AbstractDirectory 和它两个子类的源码。AbstractDirectory 封装了 Invoker 列举流程，具体的列举逻辑则由子类实现，这是典型的模板模式。所以，接下来我们先来看一下 AbstractDirectory 的源码。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class=\"hljs-keyword\">throws</span> RpcException {\n    <span class=\"hljs-keyword\">if</span> (destroyed) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RpcException(<span class=\"hljs-string\">\"Directory already destroyed...\"</span>);\n    }\n    \n    <span class=\"hljs-comment\">// 调用 doList 方法列举 Invoker，doList 是模板方法，由子类实现</span>\n    List&lt;Invoker&lt;T&gt;&gt; invokers = doList(invocation);\n    \n    <span class=\"hljs-comment\">// 获取路由 Router 列表</span>\n    List&lt;Router&gt; localRouters = <span class=\"hljs-keyword\">this</span>.routers;\n    <span class=\"hljs-keyword\">if</span> (localRouters != <span class=\"hljs-keyword\">null</span> &amp;&amp; !localRouters.isEmpty()) {\n        <span class=\"hljs-keyword\">for</span> (Router router : localRouters) {\n            <span class=\"hljs-keyword\">try</span> {\n                <span class=\"hljs-comment\">// 获取 runtime 参数，并根据参数决定是否进行路由</span>\n                <span class=\"hljs-keyword\">if</span> (router.getUrl() == <span class=\"hljs-keyword\">null</span> || router.getUrl().getParameter(Constants.RUNTIME_KEY, <span class=\"hljs-keyword\">false</span>)) {\n                    <span class=\"hljs-comment\">// 进行服务路由</span>\n                    invokers = router.route(invokers, getConsumerUrl(), invocation);\n                }\n            } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n                logger.error(<span class=\"hljs-string\">\"Failed to execute router: ...\"</span>);\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> invokers;\n}\n\n<span class=\"hljs-comment\">// 模板方法，由子类实现</span>\n<span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) <span class=\"hljs-keyword\">throws</span> RpcException;\n</code></pre>\n<p>上面就是 AbstractDirectory 的 list 方法源码，这个方法封装了 Invoker 的列举过程。如下：</p>\n<ol>\n<li>调用 doList 获取 Invoker 列表</li>\n<li>根据 Router 的 getUrl 返回值为空与否，以及 runtime 参数决定是否进行服务路由</li>\n</ol>\n<p>以上步骤中，doList 是模板方法，需由子类实现。Router 的 runtime 参数这里简单说明一下，这个参数决定了是否在每次调用服务时都执行路由规则。如果 runtime 为 true，那么每次调用服务前，都需要进行服务路由。这个对性能造成影响，配置时需要注意。</p>\n<p>关于 AbstractDirectory 就分析这么多，下面开始分析子类的源码。</p>\n<h3>3.1 StaticDirectory</h3>\n<p>StaticDirectory 即静态服务目录，顾名思义，它内部存放的 Invoker 是不会变动的。所以，理论上它和不可变 List 的功能很相似。下面我们来看一下这个类的实现。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StaticDirectory</span>&lt;<span class=\"hljs-title\">T</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractDirectory</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>{\n\n    <span class=\"hljs-comment\">// Invoker 列表</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers;\n    \n    <span class=\"hljs-comment\">// 省略构造方法</span>\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Class&lt;T&gt; <span class=\"hljs-title\">getInterface</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// 获取接口类</span>\n        <span class=\"hljs-keyword\">return</span> invokers.get(<span class=\"hljs-number\">0</span>).getInterface();\n    }\n    \n    <span class=\"hljs-comment\">// 检测服务目录是否可用</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isAvailable</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (isDestroyed()) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n        }\n        <span class=\"hljs-keyword\">for</span> (Invoker&lt;T&gt; invoker : invokers) {\n            <span class=\"hljs-keyword\">if</span> (invoker.isAvailable()) {\n                <span class=\"hljs-comment\">// 只要有一个 Invoker 是可用的，就认为当前目录是可用的</span>\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (isDestroyed()) {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        <span class=\"hljs-comment\">// 调用父类销毁逻辑</span>\n        <span class=\"hljs-keyword\">super</span>.destroy();\n        <span class=\"hljs-comment\">// 遍历 Invoker 列表，并执行相应的销毁逻辑</span>\n        <span class=\"hljs-keyword\">for</span> (Invoker&lt;T&gt; invoker : invokers) {\n            invoker.destroy();\n        }\n        invokers.clear();\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) <span class=\"hljs-keyword\">throws</span> RpcException {\n        <span class=\"hljs-comment\">// 列举 Inovker，也就是直接返回 invokers 成员变量</span>\n        <span class=\"hljs-keyword\">return</span> invokers;\n    }\n}\n</code></pre>\n<p>以上就是 StaticDirectory 的代码逻辑，很简单，就不多说了。下面来看看 RegistryDirectory，这个类的逻辑比较复杂。</p>\n<h3>3.2 RegistryDirectory</h3>\n<p>RegistryDirectory 是一种动态服务目录，实现了 NotifyListener 接口。当注册中心服务配置发生变化后，RegistryDirectory 可收到与当前服务相关的变化。收到变更通知后，RegistryDirectory 可根据配置变更信息刷新 Invoker 列表。RegistryDirectory 中有几个比较重要的逻辑，第一是 Invoker 的列举逻辑，第二是接收服务配置变更的逻辑，第三是 Invoker 列表的刷新逻辑。接下来按顺序对这三块逻辑。</p>\n<h4>3.2.1 列举 Invoker</h4>\n<p>Invoker 列举逻辑封装在 doList 方法中，相关代码如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) {\n    <span class=\"hljs-keyword\">if</span> (forbidden) {\n        <span class=\"hljs-comment\">// 服务提供者关闭或禁用了服务，此时抛出 No provider 异常</span>\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RpcException(RpcException.FORBIDDEN_EXCEPTION,\n            <span class=\"hljs-string\">\"No provider available from registry ...\"</span>);\n    }\n    List&lt;Invoker&lt;T&gt;&gt; invokers = <span class=\"hljs-keyword\">null</span>;\n    <span class=\"hljs-comment\">// 获取 Invoker 本地缓存</span>\n    Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; localMethodInvokerMap = <span class=\"hljs-keyword\">this</span>.methodInvokerMap;\n    <span class=\"hljs-keyword\">if</span> (localMethodInvokerMap != <span class=\"hljs-keyword\">null</span> &amp;&amp; localMethodInvokerMap.size() &gt; <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-comment\">// 获取方法名和参数列表</span>\n        String methodName = RpcUtils.getMethodName(invocation);\n        Object[] args = RpcUtils.getArguments(invocation);\n        <span class=\"hljs-comment\">// 检测参数列表的第一个参数是否为 String 或 enum 类型</span>\n        <span class=\"hljs-keyword\">if</span> (args != <span class=\"hljs-keyword\">null</span> &amp;&amp; args.length &gt; <span class=\"hljs-number\">0</span> &amp;&amp; args[<span class=\"hljs-number\">0</span>] != <span class=\"hljs-keyword\">null</span>\n                &amp;&amp; (args[<span class=\"hljs-number\">0</span>] <span class=\"hljs-keyword\">instanceof</span> String || args[<span class=\"hljs-number\">0</span>].getClass().isEnum())) {\n            <span class=\"hljs-comment\">// 通过 方法名 + 第一个参数名称 查询 Invoker 列表，具体的使用场景暂时没想到</span>\n            invokers = localMethodInvokerMap.get(methodName + <span class=\"hljs-string\">\".\"</span> + args[<span class=\"hljs-number\">0</span>]);\n        }\n        <span class=\"hljs-keyword\">if</span> (invokers == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-comment\">// 通过方法名获取 Invoker 列表</span>\n            invokers = localMethodInvokerMap.get(methodName);\n        }\n        <span class=\"hljs-keyword\">if</span> (invokers == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-comment\">// 通过星号 * 获取 Invoker 列表</span>\n            invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);\n        }\n        \n        <span class=\"hljs-comment\">// 冗余逻辑，pull request #2861 移除了下面的 if 分支代码</span>\n        <span class=\"hljs-keyword\">if</span> (invokers == <span class=\"hljs-keyword\">null</span>) {\n            Iterator&lt;List&lt;Invoker&lt;T&gt;&gt;&gt; iterator = localMethodInvokerMap.values().iterator();\n            <span class=\"hljs-keyword\">if</span> (iterator.hasNext()) {\n                invokers = iterator.next();\n            }\n        }\n    }\n\n\t<span class=\"hljs-comment\">// 返回 Invoker 列表</span>\n    <span class=\"hljs-keyword\">return</span> invokers == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-keyword\">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(<span class=\"hljs-number\">0</span>) : invokers;\n}\n</code></pre>\n<p>以上代码进行多次尝试，以期从 localMethodInvokerMap 中获取到 Invoker 列表。一般情况下，普通的调用可通过方法名获取到对应的 Invoker 列表，泛化调用可通过 ***** 获取到 Invoker 列表。localMethodInvokerMap 源自 RegistryDirectory 类的成员变量 methodInvokerMap。doList 方法可以看做是对 methodInvokerMap 变量的读操作，至于对 methodInvokerMap 变量的写操作，下一节进行分析。</p>\n<h4>3.2.2 接收服务变更通知</h4>\n<p>RegistryDirectory 是一个动态服务目录，会随注册中心配置的变化进行动态调整。因此 RegistryDirectory 实现了 NotifyListener 接口，通过这个接口获取注册中心变更通知。下面我们来看一下具体的逻辑。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">notify</span><span class=\"hljs-params\">(List&lt;URL&gt; urls)</span> </span>{\n    <span class=\"hljs-comment\">// 定义三个集合，分别用于存放服务提供者 url，路由 url，配置器 url</span>\n    List&lt;URL&gt; invokerUrls = <span class=\"hljs-keyword\">new</span> ArrayList&lt;URL&gt;();\n    List&lt;URL&gt; routerUrls = <span class=\"hljs-keyword\">new</span> ArrayList&lt;URL&gt;();\n    List&lt;URL&gt; configuratorUrls = <span class=\"hljs-keyword\">new</span> ArrayList&lt;URL&gt;();\n    <span class=\"hljs-keyword\">for</span> (URL url : urls) {\n        String protocol = url.getProtocol();\n        <span class=\"hljs-comment\">// 获取 category 参数</span>\n        String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);\n        <span class=\"hljs-comment\">// 根据 category 参数将 url 分别放到不同的列表中</span>\n        <span class=\"hljs-keyword\">if</span> (Constants.ROUTERS_CATEGORY.equals(category)\n                || Constants.ROUTE_PROTOCOL.equals(protocol)) {\n            <span class=\"hljs-comment\">// 添加路由器 url</span>\n            routerUrls.add(url);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (Constants.CONFIGURATORS_CATEGORY.equals(category)\n                || Constants.OVERRIDE_PROTOCOL.equals(protocol)) {\n            <span class=\"hljs-comment\">// 添加配置器 url</span>\n            configuratorUrls.add(url);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (Constants.PROVIDERS_CATEGORY.equals(category)) {\n            <span class=\"hljs-comment\">// 添加服务提供者 url</span>\n            invokerUrls.add(url);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// 忽略不支持的 category</span>\n            logger.warn(<span class=\"hljs-string\">\"Unsupported category ...\"</span>);\n        }\n    }\n    <span class=\"hljs-keyword\">if</span> (configuratorUrls != <span class=\"hljs-keyword\">null</span> &amp;&amp; !configuratorUrls.isEmpty()) {\n        <span class=\"hljs-comment\">// 将 url 转成 Configurator</span>\n        <span class=\"hljs-keyword\">this</span>.configurators = toConfigurators(configuratorUrls);\n    }\n    <span class=\"hljs-keyword\">if</span> (routerUrls != <span class=\"hljs-keyword\">null</span> &amp;&amp; !routerUrls.isEmpty()) {\n        <span class=\"hljs-comment\">// 将 url 转成 Router</span>\n        List&lt;Router&gt; routers = toRouters(routerUrls);\n        <span class=\"hljs-keyword\">if</span> (routers != <span class=\"hljs-keyword\">null</span>) {\n            setRouters(routers);\n        }\n    }\n    List&lt;Configurator&gt; localConfigurators = <span class=\"hljs-keyword\">this</span>.configurators;\n    <span class=\"hljs-keyword\">this</span>.overrideDirectoryUrl = directoryUrl;\n    <span class=\"hljs-keyword\">if</span> (localConfigurators != <span class=\"hljs-keyword\">null</span> &amp;&amp; !localConfigurators.isEmpty()) {\n        <span class=\"hljs-keyword\">for</span> (Configurator configurator : localConfigurators) {\n            <span class=\"hljs-comment\">// 配置 overrideDirectoryUrl</span>\n            <span class=\"hljs-keyword\">this</span>.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);\n        }\n    }\n\n    <span class=\"hljs-comment\">// 刷新 Invoker 列表</span>\n    refreshInvoker(invokerUrls);\n}\n</code></pre>\n<p>如上，notify 方法首先是根据 url 的 category 参数对 url 进行分门别类存储，然后通过 toRouters 和 toConfigurators 将 url 列表转成 Router 和 Configurator 列表。最后调用 refreshInvoker 方法刷新 Invoker 列表。这里的 toRouters 和 toConfigurators 方法逻辑不复杂，大家自行分析。接下来，我们把重点放在 refreshInvoker 方法上。</p>\n<h4>3.2.3 刷新 Invoker 列表</h4>\n<p>refreshInvoker 方法是保证 RegistryDirectory 随注册中心变化而变化的关键所在。这一块逻辑比较多，接下来一一进行分析。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">refreshInvoker</span><span class=\"hljs-params\">(List&lt;URL&gt; invokerUrls)</span> </span>{\n    <span class=\"hljs-comment\">// invokerUrls 仅有一个元素，且 url 协议头为 empty，此时表示禁用所有服务</span>\n    <span class=\"hljs-keyword\">if</span> (invokerUrls != <span class=\"hljs-keyword\">null</span> &amp;&amp; invokerUrls.size() == <span class=\"hljs-number\">1</span> &amp;&amp; invokerUrls.get(<span class=\"hljs-number\">0</span>) != <span class=\"hljs-keyword\">null</span>\n            &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(<span class=\"hljs-number\">0</span>).getProtocol())) {\n        <span class=\"hljs-comment\">// 设置 forbidden 为 true</span>\n        <span class=\"hljs-keyword\">this</span>.forbidden = <span class=\"hljs-keyword\">true</span>;\n        <span class=\"hljs-keyword\">this</span>.methodInvokerMap = <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-comment\">// 销毁所有 Invoker</span>\n        destroyAllInvokers();\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">this</span>.forbidden = <span class=\"hljs-keyword\">false</span>;\n        Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class=\"hljs-keyword\">this</span>.urlInvokerMap;\n        <span class=\"hljs-keyword\">if</span> (invokerUrls.isEmpty() &amp;&amp; <span class=\"hljs-keyword\">this</span>.cachedInvokerUrls != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-comment\">// 添加缓存 url 到 invokerUrls 中</span>\n            invokerUrls.addAll(<span class=\"hljs-keyword\">this</span>.cachedInvokerUrls);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">this</span>.cachedInvokerUrls = <span class=\"hljs-keyword\">new</span> HashSet&lt;URL&gt;();\n            <span class=\"hljs-comment\">// 缓存 invokerUrls</span>\n            <span class=\"hljs-keyword\">this</span>.cachedInvokerUrls.addAll(invokerUrls);\n        }\n        <span class=\"hljs-keyword\">if</span> (invokerUrls.isEmpty()) {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        <span class=\"hljs-comment\">// 将 url 转成 Invoker</span>\n        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);\n        <span class=\"hljs-comment\">// 将 newUrlInvokerMap 转成方法名到 Invoker 列表的映射</span>\n        Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap);\n        <span class=\"hljs-comment\">// 转换出错，直接打印异常，并返回</span>\n        <span class=\"hljs-keyword\">if</span> (newUrlInvokerMap == <span class=\"hljs-keyword\">null</span> || newUrlInvokerMap.size() == <span class=\"hljs-number\">0</span>) {\n            logger.error(<span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"urls to invokers error ...\"</span>));\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        <span class=\"hljs-comment\">// 合并多个组的 Invoker</span>\n        <span class=\"hljs-keyword\">this</span>.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;\n        <span class=\"hljs-keyword\">this</span>.urlInvokerMap = newUrlInvokerMap;\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 销毁无用 Invoker</span>\n            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap);\n        } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n            logger.warn(<span class=\"hljs-string\">\"destroyUnusedInvokers error. \"</span>, e);\n        }\n    }\n}\n</code></pre>\n<p>refreshInvoker 方法首先会根据入参 invokerUrls 的数量和协议头判断是否禁用所有的服务，如果禁用，则将 forbidden 设为 true，并销毁所有的 Invoker。若不禁用，则将 url 转成 Invoker，得到 &lt;url, Invoker&gt; 的映射关系。然后进一步进行转换，得到 &lt;methodName, Invoker 列表&gt; 映射关系。之后进行多组 Invoker 合并操作，并将合并结果赋值给 methodInvokerMap。methodInvokerMap 变量在 doList 方法中会被用到，doList 会对该变量进行读操作，在这里是写操作。当新的 Invoker 列表生成后，还要一个重要的工作要做，就是销毁无用的 Invoker，避免服务消费者调用已下线的服务的服务。</p>\n<p>接下来对 refreshInvoker 方法中涉及到的调用一一进行分析。按照顺序，先来分析 url 到 Invoker 的转换过程。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) {\n    Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, Invoker&lt;T&gt;&gt;();\n    <span class=\"hljs-keyword\">if</span> (urls == <span class=\"hljs-keyword\">null</span> || urls.isEmpty()) {\n        <span class=\"hljs-keyword\">return</span> newUrlInvokerMap;\n    }\n    Set&lt;String&gt; keys = <span class=\"hljs-keyword\">new</span> HashSet&lt;String&gt;();\n    <span class=\"hljs-comment\">// 获取服务消费端配置的协议</span>\n    String queryProtocols = <span class=\"hljs-keyword\">this</span>.queryMap.get(Constants.PROTOCOL_KEY);\n    <span class=\"hljs-keyword\">for</span> (URL providerUrl : urls) {\n        <span class=\"hljs-keyword\">if</span> (queryProtocols != <span class=\"hljs-keyword\">null</span> &amp;&amp; queryProtocols.length() &gt; <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">boolean</span> accept = <span class=\"hljs-keyword\">false</span>;\n            String[] acceptProtocols = queryProtocols.split(<span class=\"hljs-string\">\",\"</span>);\n            <span class=\"hljs-comment\">// 检测服务提供者协议是否被服务消费者所支持</span>\n            <span class=\"hljs-keyword\">for</span> (String acceptProtocol : acceptProtocols) {\n                <span class=\"hljs-keyword\">if</span> (providerUrl.getProtocol().equals(acceptProtocol)) {\n                    accept = <span class=\"hljs-keyword\">true</span>;\n                    <span class=\"hljs-keyword\">break</span>;\n                }\n            }\n            <span class=\"hljs-keyword\">if</span> (!accept) {\n                <span class=\"hljs-comment\">// 若服务消费者协议头不被消费者所支持，则忽略当前 providerUrl</span>\n                <span class=\"hljs-keyword\">continue</span>;\n            }\n        }\n        <span class=\"hljs-comment\">// 忽略 empty 协议</span>\n        <span class=\"hljs-keyword\">if</span> (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) {\n            <span class=\"hljs-keyword\">continue</span>;\n        }\n        <span class=\"hljs-comment\">// 通过 SPI 检测服务端协议是否被消费端支持，不支持则抛出异常</span>\n        <span class=\"hljs-keyword\">if</span> (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) {\n            logger.error(<span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"Unsupported protocol...\"</span>));\n            <span class=\"hljs-keyword\">continue</span>;\n        }\n        \n        <span class=\"hljs-comment\">// 合并 url</span>\n        URL url = mergeUrl(providerUrl);\n\n        String key = url.toFullString();\n        <span class=\"hljs-keyword\">if</span> (keys.contains(key)) {\n            <span class=\"hljs-comment\">// 忽略重复 url</span>\n            <span class=\"hljs-keyword\">continue</span>;\n        }\n        keys.add(key);\n        <span class=\"hljs-comment\">// 将本地 Invoker 缓存赋值给 localUrlInvokerMap</span>\n        Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class=\"hljs-keyword\">this</span>.urlInvokerMap;\n        <span class=\"hljs-comment\">// 获取与 url 对应的 Invoker</span>\n        Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-keyword\">null</span> : localUrlInvokerMap.get(key);\n        <span class=\"hljs-comment\">// 缓存未命中</span>\n        <span class=\"hljs-keyword\">if</span> (invoker == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">try</span> {\n                <span class=\"hljs-keyword\">boolean</span> enabled = <span class=\"hljs-keyword\">true</span>;\n                <span class=\"hljs-keyword\">if</span> (url.hasParameter(Constants.DISABLED_KEY)) {\n                    <span class=\"hljs-comment\">// 获取 disable 配置，取反，然后赋值给 enable 变量</span>\n                    enabled = !url.getParameter(Constants.DISABLED_KEY, <span class=\"hljs-keyword\">false</span>);\n                } <span class=\"hljs-keyword\">else</span> {\n                    <span class=\"hljs-comment\">// 获取 enable 配置，并赋值给 enable 变量</span>\n                    enabled = url.getParameter(Constants.ENABLED_KEY, <span class=\"hljs-keyword\">true</span>);\n                }\n                <span class=\"hljs-keyword\">if</span> (enabled) {\n                    <span class=\"hljs-comment\">// 调用 refer 获取 Invoker</span>\n                    invoker = <span class=\"hljs-keyword\">new</span> InvokerDelegate&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl);\n                }\n            } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n                logger.error(<span class=\"hljs-string\">\"Failed to refer invoker for interface...\"</span>);\n            }\n            <span class=\"hljs-keyword\">if</span> (invoker != <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-comment\">// 缓存 Invoker 实例</span>\n                newUrlInvokerMap.put(key, invoker);\n            }\n            \n        <span class=\"hljs-comment\">// 缓存命中</span>\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// 将 invoker 存储到 newUrlInvokerMap 中</span>\n            newUrlInvokerMap.put(key, invoker);\n        }\n    }\n    keys.clear();\n    <span class=\"hljs-keyword\">return</span> newUrlInvokerMap;\n}\n</code></pre>\n<p>toInvokers 方法一开始会对服务提供者 url 进行检测，若服务消费端的配置不支持服务端的协议，或服务端 url 协议头为 empty 时，toInvokers 均会忽略服务提供方 url。必要的检测做完后，紧接着是合并 url，然后访问缓存，尝试获取与 url 对应的 invoker。如果缓存命中，直接将 Invoker 存入 newUrlInvokerMap 中即可。如果未命中，则需新建 Invoker。</p>\n<p>toInvokers 方法返回的是 &lt;url, Invoker&gt; 映射关系表，接下来还要对这个结果进行进一步处理，得到方法名到 Invoker 列表的映射关系。这个过程由 toMethodInvokers 方法完成，如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; toMethodInvokers(Map&lt;String, Invoker&lt;T&gt;&gt; invokersMap) {\n    <span class=\"hljs-comment\">// 方法名 -&gt; Invoker 列表</span>\n    Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt;();\n    List&lt;Invoker&lt;T&gt;&gt; invokersList = <span class=\"hljs-keyword\">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();\n    <span class=\"hljs-keyword\">if</span> (invokersMap != <span class=\"hljs-keyword\">null</span> &amp;&amp; invokersMap.size() &gt; <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-keyword\">for</span> (Invoker&lt;T&gt; invoker : invokersMap.values()) {\n            <span class=\"hljs-comment\">// 获取 methods 参数</span>\n            String parameter = invoker.getUrl().getParameter(Constants.METHODS_KEY);\n            <span class=\"hljs-keyword\">if</span> (parameter != <span class=\"hljs-keyword\">null</span> &amp;&amp; parameter.length() &gt; <span class=\"hljs-number\">0</span>) {\n                <span class=\"hljs-comment\">// 切分 methods 参数值，得到方法名数组</span>\n                String[] methods = Constants.COMMA_SPLIT_PATTERN.split(parameter);\n                <span class=\"hljs-keyword\">if</span> (methods != <span class=\"hljs-keyword\">null</span> &amp;&amp; methods.length &gt; <span class=\"hljs-number\">0</span>) {\n                    <span class=\"hljs-keyword\">for</span> (String method : methods) {\n                        <span class=\"hljs-comment\">// 方法名不为 *</span>\n                        <span class=\"hljs-keyword\">if</span> (method != <span class=\"hljs-keyword\">null</span> &amp;&amp; method.length() &gt; <span class=\"hljs-number\">0</span>\n                                &amp;&amp; !Constants.ANY_VALUE.equals(method)) {\n                            <span class=\"hljs-comment\">// 根据方法名获取 Invoker 列表</span>\n                            List&lt;Invoker&lt;T&gt;&gt; methodInvokers = newMethodInvokerMap.get(method);\n                            <span class=\"hljs-keyword\">if</span> (methodInvokers == <span class=\"hljs-keyword\">null</span>) {\n                                methodInvokers = <span class=\"hljs-keyword\">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();\n                                newMethodInvokerMap.put(method, methodInvokers);\n                            }\n                            <span class=\"hljs-comment\">// 存储 Invoker 到列表中</span>\n                            methodInvokers.add(invoker);\n                        }\n                    }\n                }\n            }\n            invokersList.add(invoker);\n        }\n    }\n    \n    <span class=\"hljs-comment\">// 进行服务级别路由，参考 pull request #749</span>\n    List&lt;Invoker&lt;T&gt;&gt; newInvokersList = route(invokersList, <span class=\"hljs-keyword\">null</span>);\n    <span class=\"hljs-comment\">// 存储 &lt;*, newInvokersList&gt; 映射关系</span>\n    newMethodInvokerMap.put(Constants.ANY_VALUE, newInvokersList);\n    <span class=\"hljs-keyword\">if</span> (serviceMethods != <span class=\"hljs-keyword\">null</span> &amp;&amp; serviceMethods.length &gt; <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-keyword\">for</span> (String method : serviceMethods) {\n            List&lt;Invoker&lt;T&gt;&gt; methodInvokers = newMethodInvokerMap.get(method);\n            <span class=\"hljs-keyword\">if</span> (methodInvokers == <span class=\"hljs-keyword\">null</span> || methodInvokers.isEmpty()) {\n                methodInvokers = newInvokersList;\n            }\n            <span class=\"hljs-comment\">// 进行方法级别路由</span>\n            newMethodInvokerMap.put(method, route(methodInvokers, method));\n        }\n    }\n    <span class=\"hljs-comment\">// 排序，转成不可变列表</span>\n    <span class=\"hljs-keyword\">for</span> (String method : <span class=\"hljs-keyword\">new</span> HashSet&lt;String&gt;(newMethodInvokerMap.keySet())) {\n        List&lt;Invoker&lt;T&gt;&gt; methodInvokers = newMethodInvokerMap.get(method);\n        Collections.sort(methodInvokers, InvokerComparator.getComparator());\n        newMethodInvokerMap.put(method, Collections.unmodifiableList(methodInvokers));\n    }\n    <span class=\"hljs-keyword\">return</span> Collections.unmodifiableMap(newMethodInvokerMap);\n}\n</code></pre>\n<p>上面方法主要做了三件事情， 第一是对入参进行遍历，然后从 Invoker 的 url 成员变量中获取 methods 参数，并切分成数组。随后以方法名为键，Invoker 列表为值，将映射关系存储到 newMethodInvokerMap 中。第二是分别基于类和方法对 Invoker 列表进行路由操作。第三是对 Invoker 列表进行排序，并转成不可变列表。关于 toMethodInvokers 方法就先分析到这，我们继续向下分析，这次要分析的多组服务的合并逻辑。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; toMergeMethodInvokerMap(Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; methodMap) {\n    Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; result = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt;();\n    <span class=\"hljs-comment\">// 遍历入参</span>\n    <span class=\"hljs-keyword\">for</span> (Map.Entry&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; entry : methodMap.entrySet()) {\n        String method = entry.getKey();\n        List&lt;Invoker&lt;T&gt;&gt; invokers = entry.getValue();\n        <span class=\"hljs-comment\">// group -&gt; Invoker 列表</span>\n        Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; groupMap = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt;();\n        <span class=\"hljs-comment\">// 遍历 Invoker 列表</span>\n        <span class=\"hljs-keyword\">for</span> (Invoker&lt;T&gt; invoker : invokers) {\n            <span class=\"hljs-comment\">// 获取分组配置</span>\n            String group = invoker.getUrl().getParameter(Constants.GROUP_KEY, <span class=\"hljs-string\">\"\"</span>);\n            List&lt;Invoker&lt;T&gt;&gt; groupInvokers = groupMap.get(group);\n            <span class=\"hljs-keyword\">if</span> (groupInvokers == <span class=\"hljs-keyword\">null</span>) {\n                groupInvokers = <span class=\"hljs-keyword\">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();\n                <span class=\"hljs-comment\">// 缓存 &lt;group, List&lt;Invoker&gt;&gt; 到 groupMap 中</span>\n                groupMap.put(group, groupInvokers);\n            }\n            <span class=\"hljs-comment\">// 存储 invoker 到 groupInvokers</span>\n            groupInvokers.add(invoker);\n        }\n        <span class=\"hljs-keyword\">if</span> (groupMap.size() == <span class=\"hljs-number\">1</span>) {\n            <span class=\"hljs-comment\">// 如果 groupMap 中仅包含一组键值对，此时直接取出该键值对的值即可</span>\n            result.put(method, groupMap.values().iterator().next());\n        \n        <span class=\"hljs-comment\">// groupMap.size() &gt; 1 成立，表示 groupMap 中包含多组键值对，比如：</span>\n        <span class=\"hljs-comment\">// {</span>\n        <span class=\"hljs-comment\">//     \"dubbo\": [invoker1, invoker2, invoker3, ...],</span>\n        <span class=\"hljs-comment\">//     \"hello\": [invoker4, invoker5, invoker6, ...]</span>\n        <span class=\"hljs-comment\">// }</span>\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (groupMap.size() &gt; <span class=\"hljs-number\">1</span>) {\n            List&lt;Invoker&lt;T&gt;&gt; groupInvokers = <span class=\"hljs-keyword\">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();\n            <span class=\"hljs-keyword\">for</span> (List&lt;Invoker&lt;T&gt;&gt; groupList : groupMap.values()) {\n                <span class=\"hljs-comment\">// 通过集群类合并每个分组对应的 Invoker 列表</span>\n                groupInvokers.add(cluster.join(<span class=\"hljs-keyword\">new</span> StaticDirectory&lt;T&gt;(groupList)));\n            }\n            <span class=\"hljs-comment\">// 缓存结果</span>\n            result.put(method, groupInvokers);\n        } <span class=\"hljs-keyword\">else</span> {\n            result.put(method, invokers);\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> result;\n}\n</code></pre>\n<p>上面方法首先是生成 group 到 Invoker 类比的映射关系表，若关系表中的映射关系数量大于1，表示有多组服务。此时通过集群类合并每组 Invoker，并将合并结果存储到 groupInvokers 中。之后将方法名与 groupInvokers   存到到 result 中，并返回，整个逻辑结束。</p>\n<p>接下来我们再来看一下 Invoker 列表刷新逻辑的最后一个动作 — 删除无用 Invoker。如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">destroyUnusedInvokers</span><span class=\"hljs-params\">(Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap, Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (newUrlInvokerMap == <span class=\"hljs-keyword\">null</span> || newUrlInvokerMap.size() == <span class=\"hljs-number\">0</span>) {\n        destroyAllInvokers();\n        <span class=\"hljs-keyword\">return</span>;\n    }\n   \n    List&lt;String&gt; deleted = <span class=\"hljs-keyword\">null</span>;\n    <span class=\"hljs-keyword\">if</span> (oldUrlInvokerMap != <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-comment\">// 获取新生成的 Invoker 列表</span>\n        Collection&lt;Invoker&lt;T&gt;&gt; newInvokers = newUrlInvokerMap.values();\n        <span class=\"hljs-comment\">// 遍历老的 &lt;url, Invoker&gt; 映射表</span>\n        <span class=\"hljs-keyword\">for</span> (Map.Entry&lt;String, Invoker&lt;T&gt;&gt; entry : oldUrlInvokerMap.entrySet()) {\n            <span class=\"hljs-comment\">// 检测 newInvokers 中是否包含老的 Invoker</span>\n            <span class=\"hljs-keyword\">if</span> (!newInvokers.contains(entry.getValue())) {\n                <span class=\"hljs-keyword\">if</span> (deleted == <span class=\"hljs-keyword\">null</span>) {\n                    deleted = <span class=\"hljs-keyword\">new</span> ArrayList&lt;String&gt;();\n                }\n                <span class=\"hljs-comment\">// 若不包含，则将老的 Invoker 对应的 url 存入 deleted 列表中</span>\n                deleted.add(entry.getKey());\n            }\n        }\n    }\n\n    <span class=\"hljs-keyword\">if</span> (deleted != <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-comment\">// 遍历 deleted 集合，并到老的 &lt;url, Invoker&gt; 映射关系表查出 Invoker，销毁之</span>\n        <span class=\"hljs-keyword\">for</span> (String url : deleted) {\n            <span class=\"hljs-keyword\">if</span> (url != <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-comment\">// 从 oldUrlInvokerMap 中移除 url 对应的 Invoker</span>\n                Invoker&lt;T&gt; invoker = oldUrlInvokerMap.remove(url);\n                <span class=\"hljs-keyword\">if</span> (invoker != <span class=\"hljs-keyword\">null</span>) {\n                    <span class=\"hljs-keyword\">try</span> {\n                        <span class=\"hljs-comment\">// 销毁 Invoker</span>\n                        invoker.destroy();\n                    } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n                        logger.warn(<span class=\"hljs-string\">\"destroy invoker...\"</span>);\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p>destroyUnusedInvokers 方法的主要逻辑是通过 newUrlInvokerMap 找出待删除 Invoker 对应的 url，并将 url 存入到 deleted 列表中。然后再遍历 deleted 列表，并从 oldUrlInvokerMap 中移除相应的 Invoker，销毁之。整个逻辑大致如此，不是很难理解。</p>\n<p>到此关于 Invoker 列表的刷新逻辑就分析了，这里对整个过程进行简单总结。如下：</p>\n<ol>\n<li>检测入参是否仅包含一个 url，且 url 协议头为 empty</li>\n<li>若第一步检测结果为 true，表示禁用所有服务，此时销毁所有的 Invoker</li>\n<li>若第一步检测结果为 false，此时将入参转为 Invoker 列表</li>\n<li>对将上一步逻辑生成的结果进行进一步处理，得到方法名到 Invoker 的映射关系表</li>\n<li>合并多组 Invoker</li>\n<li>销毁无用 Invoker</li>\n</ol>\n<p>Invoker 的刷新逻辑还是比较复杂的，大家在看的过程中多写点 demo 进行调试，以加深理解。</p>\n<h2>4. 总结</h2>\n<p>本篇文章对 Dubbo 服务目录进行了较为详细的分析，篇幅主要集中在 RegistryDirectory 的源码分析上。从代码量上可以看出，想让本地服务目录和注册中心保持一致还是需要做很多事情的，并不简单。服务目录是 Dubbo 集群容错的一部分，也是比较基础的部分，所以大家应尽量搞懂。</p>\n",
  "link": "/zh-cn/docs/source_code_guide/directory.html",
  "meta": {
    "title": "服务目录",
    "keywords": "Dubbo, Directory",
    "description": "本文介绍了服务目录的原理和实现细节"
  }
}