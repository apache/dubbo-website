{
  "filename": "dubbo-spi.md",
  "__html": "<h2>1.简介</h2>\n<p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。SPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI，我们可以很容易的对 Dubbo 进行拓展。如果大家想要学习 Dubbo 的源码，SPI 机制务必弄懂。接下来，我们先来了解一下 Java SPI 与 Dubbo SPI 的用法，然后再来分析 Dubbo SPI 的源码。</p>\n<h2>2.SPI 示例</h2>\n<h3>2.1  Java SPI 示例</h3>\n<p>前面简单介绍了 SPI 机制的原理，本节通过一个示例演示 Java SPI 的使用方法。首先，我们定义一个接口，名称为 Robot。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Robot</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">()</span></span>;\n}\n</code></pre>\n<p>接下来定义两个实现类，分别为 OptimusPrime 和 Bumblebee。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">OptimusPrime</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Robot</span> </span>{\n    \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"Hello, I am Optimus Prime.\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Bumblebee</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Robot</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"Hello, I am Bumblebee.\"</span>);\n    }\n}\n</code></pre>\n<p>接下来 META-INF/services 文件夹下创建一个文件，名称为 Robot 的全限定名 org.apache.spi.Robot。文件内容为实现类的全限定的类名，如下：</p>\n<pre><code>org.apache.spi.OptimusPrime\norg.apache.spi.Bumblebee\n</code></pre>\n<p>做好所需的准备工作，接下来编写代码进行测试。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">JavaSPITest</span> </span>{\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        ServiceLoader&lt;Robot&gt; serviceLoader = ServiceLoader.load(Robot.class);\n        System.out.println(<span class=\"hljs-string\">\"Java SPI\"</span>);\n        serviceLoader.forEach(Robot::sayHello);\n    }\n}\n</code></pre>\n<p>最后来看一下测试结果，如下：</p>\n<p><img src=\"./sources/images/java-spi-result.jpg\" alt=\"\"></p>\n<p>从测试结果可以看出，我们的两个实现类被成功的加载，并输出了相应的内容。关于 Java SPI 的演示先到这里，接下来演示 Dubbo SPI。</p>\n<h3>2.2 Dubbo SPI 示例</h3>\n<p>Dubbo 并未使用 Java SPI，而是重新实现了一套功能更强的 SPI 机制。Dubbo SPI 的相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 META-INF/dubbo 路径下，配置内容如下。</p>\n<pre><code>optimusPrime = org.apache.spi.OptimusPrime\nbumblebee = org.apache.spi.Bumblebee\n</code></pre>\n<p>与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。另外，在测试 Dubbo SPI 时，需要在 Robot 接口上标注 @SPI 注解。下面来演示 Dubbo SPI 的用法：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DubboSPITest</span> </span>{\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        ExtensionLoader&lt;Robot&gt; extensionLoader = \n            ExtensionLoader.getExtensionLoader(Robot.class);\n        Robot optimusPrime = extensionLoader.getExtension(<span class=\"hljs-string\">\"optimusPrime\"</span>);\n        optimusPrime.sayHello();\n        Robot bumblebee = extensionLoader.getExtension(<span class=\"hljs-string\">\"bumblebee\"</span>);\n        bumblebee.sayHello();\n    }\n}\n</code></pre>\n<p>测试结果如下：</p>\n<p><img src=\"./sources/images/dubbo-spi-result.jpg\" alt=\"\"></p>\n<p>Dubbo SPI 除了支持按需加载接口实现类，还增加了 IOC 和 AOP 等特性，这些特性将会在接下来的源码分析章节中一一进行介绍。</p>\n<h2>3. Dubbo SPI 源码分析</h2>\n<p>上一章简单演示了 Dubbo SPI 的使用方法。我们首先通过 ExtensionLoader 的 getExtensionLoader 方法获取一个 ExtensionLoader 实例，然后再通过 ExtensionLoader 的 getExtension 方法获取拓展类对象。这其中，getExtensionLoader 方法用于从缓存中获取与拓展类对应的 ExtensionLoader，若缓存未命中，则创建一个新的实例。该方法的逻辑比较简单，本章就不进行分析了。下面我们从 ExtensionLoader 的 getExtension 方法作为入口，对拓展类对象的获取过程进行详细的分析。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> T <span class=\"hljs-title\">getExtension</span><span class=\"hljs-params\">(String name)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (name == <span class=\"hljs-keyword\">null</span> || name.length() == <span class=\"hljs-number\">0</span>)\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"Extension name == null\"</span>);\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">\"true\"</span>.equals(name)) {\n        <span class=\"hljs-comment\">// 获取默认的拓展实现类</span>\n        <span class=\"hljs-keyword\">return</span> getDefaultExtension();\n    }\n    <span class=\"hljs-comment\">// Holder，顾名思义，用于持有目标对象</span>\n    Holder&lt;Object&gt; holder = cachedInstances.get(name);\n    <span class=\"hljs-keyword\">if</span> (holder == <span class=\"hljs-keyword\">null</span>) {\n        cachedInstances.putIfAbsent(name, <span class=\"hljs-keyword\">new</span> Holder&lt;Object&gt;());\n        holder = cachedInstances.get(name);\n    }\n    Object instance = holder.get();\n    <span class=\"hljs-comment\">// 双重检查</span>\n    <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-keyword\">synchronized</span> (holder) {\n            instance = holder.get();\n            <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-comment\">// 创建拓展实例</span>\n                instance = createExtension(name);\n                <span class=\"hljs-comment\">// 设置实例到 holder 中</span>\n                holder.set(instance);\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> (T) instance;\n}\n</code></pre>\n<p>上面代码的逻辑比较简单，首先检查缓存，缓存未命中则创建拓展对象。下面我们来看一下创建拓展对象的过程是怎样的。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> T <span class=\"hljs-title\">createExtension</span><span class=\"hljs-params\">(String name)</span> </span>{\n    <span class=\"hljs-comment\">// 从配置文件中加载所有的拓展类，可得到“配置项名称”到“配置类”的映射关系表</span>\n    Class&lt;?&gt; clazz = getExtensionClasses().get(name);\n    <span class=\"hljs-keyword\">if</span> (clazz == <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-keyword\">throw</span> findException(name);\n    }\n    <span class=\"hljs-keyword\">try</span> {\n        T instance = (T) EXTENSION_INSTANCES.get(clazz);\n        <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-comment\">// 通过反射创建实例</span>\n            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());\n            instance = (T) EXTENSION_INSTANCES.get(clazz);\n        }\n        <span class=\"hljs-comment\">// 向实例中注入依赖</span>\n        injectExtension(instance);\n        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;\n        <span class=\"hljs-keyword\">if</span> (wrapperClasses != <span class=\"hljs-keyword\">null</span> &amp;&amp; !wrapperClasses.isEmpty()) {\n            <span class=\"hljs-comment\">// 循环创建 Wrapper 实例</span>\n            <span class=\"hljs-keyword\">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) {\n                <span class=\"hljs-comment\">// 将当前 instance 作为参数传给 Wrapper 的构造方法，并通过反射创建 Wrapper 实例。</span>\n                <span class=\"hljs-comment\">// 然后向 Wrapper 实例中注入依赖，最后将 Wrapper 实例再次赋值给 instance 变量</span>\n                instance = injectExtension(\n                    (T) wrapperClass.getConstructor(type).newInstance(instance));\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> instance;\n    } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"...\"</span>);\n    }\n}\n</code></pre>\n<p>createExtension 方法的逻辑稍复杂一下，包含了如下的步骤：</p>\n<ol>\n<li>通过 getExtensionClasses 获取所有的拓展类</li>\n<li>通过反射创建拓展对象</li>\n<li>向拓展对象中注入依赖</li>\n<li>将拓展对象包裹在相应的 Wrapper 对象中</li>\n</ol>\n<p>以上步骤中，第一个步骤是加载拓展类的关键，第三和第四个步骤是 Dubbo IOC 与 AOP 的具体实现。在接下来的章节中，将会重点分析 getExtensionClasses 方法的逻辑，以及简单介绍 Dubbo IOC 的具体实现。</p>\n<h3>3.1 获取所有的拓展类</h3>\n<p>我们在通过名称获取拓展类之前，首先需要根据配置文件解析出拓展项名称到拓展类的映射关系表（Map&lt;名称, 拓展类&gt;），之后再根据拓展项名称从映射关系表中取出相应的拓展类即可。相关过程的代码分析如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() {\n    <span class=\"hljs-comment\">// 从缓存中获取已加载的拓展类</span>\n    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();\n    <span class=\"hljs-comment\">// 双重检查</span>\n    <span class=\"hljs-keyword\">if</span> (classes == <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-keyword\">synchronized</span> (cachedClasses) {\n            classes = cachedClasses.get();\n            <span class=\"hljs-keyword\">if</span> (classes == <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-comment\">// 加载拓展类</span>\n                classes = loadExtensionClasses();\n                cachedClasses.set(classes);\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> classes;\n}\n</code></pre>\n<p>这里也是先检查缓存，若缓存未命中，则通过 synchronized 加锁。加锁后再次检查缓存，并判空。此时如果 classes 仍为 null，则通过 loadExtensionClasses 加载拓展类。下面分析 loadExtensionClasses 方法的逻辑。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() {\n    <span class=\"hljs-comment\">// 获取 SPI 注解，这里的 type 变量是在调用 getExtensionLoader 方法时传入的</span>\n    <span class=\"hljs-keyword\">final</span> SPI defaultAnnotation = type.getAnnotation(SPI.class);\n    <span class=\"hljs-keyword\">if</span> (defaultAnnotation != <span class=\"hljs-keyword\">null</span>) {\n        String value = defaultAnnotation.value();\n        <span class=\"hljs-keyword\">if</span> ((value = value.trim()).length() &gt; <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-comment\">// 对 SPI 注解内容进行切分</span>\n            String[] names = NAME_SEPARATOR.split(value);\n            <span class=\"hljs-comment\">// 检测 SPI 注解内容是否合法，不合法则抛出异常</span>\n            <span class=\"hljs-keyword\">if</span> (names.length &gt; <span class=\"hljs-number\">1</span>) {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"more than 1 default extension name on extension...\"</span>);\n            }\n\n            <span class=\"hljs-comment\">// 设置默认名称，参考 getDefaultExtension 方法</span>\n            <span class=\"hljs-keyword\">if</span> (names.length == <span class=\"hljs-number\">1</span>) {\n                cachedDefaultName = names[<span class=\"hljs-number\">0</span>];\n            }\n        }\n    }\n\n    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();\n    <span class=\"hljs-comment\">// 加载指定文件夹下的配置文件</span>\n    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);\n    loadDirectory(extensionClasses, DUBBO_DIRECTORY);\n    loadDirectory(extensionClasses, SERVICES_DIRECTORY);\n    <span class=\"hljs-keyword\">return</span> extensionClasses;\n}\n</code></pre>\n<p>loadExtensionClasses 方法总共做了两件事情，一是对 SPI 注解进行解析，二是调用 loadDirectory 方法加载指定文件夹配置文件。SPI 注解解析过程比较简单，无需多说。下面我们来看一下 loadDirectory 做了哪些事情。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">loadDirectory</span><span class=\"hljs-params\">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir)</span> </span>{\n    <span class=\"hljs-comment\">// fileName = 文件夹路径 + type 全限定名 </span>\n    String fileName = dir + type.getName();\n    <span class=\"hljs-keyword\">try</span> {\n        Enumeration&lt;java.net.URL&gt; urls;\n        ClassLoader classLoader = findClassLoader();\n        <span class=\"hljs-comment\">// 根据文件名加载所有的同名文件</span>\n        <span class=\"hljs-keyword\">if</span> (classLoader != <span class=\"hljs-keyword\">null</span>) {\n            urls = classLoader.getResources(fileName);\n        } <span class=\"hljs-keyword\">else</span> {\n            urls = ClassLoader.getSystemResources(fileName);\n        }\n        <span class=\"hljs-keyword\">if</span> (urls != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">while</span> (urls.hasMoreElements()) {\n                java.net.URL resourceURL = urls.nextElement();\n                <span class=\"hljs-comment\">// 加载资源</span>\n                loadResource(extensionClasses, classLoader, resourceURL);\n            }\n        }\n    } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n        logger.error(<span class=\"hljs-string\">\"...\"</span>);\n    }\n}\n</code></pre>\n<p>loadDirectory 方法先通过 classLoader 获取所有资源链接，然后再通过 loadResource 方法加载资源。我们继续跟下去，看一下 loadResource 方法的实现。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">loadResource</span><span class=\"hljs-params\">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, \n\tClassLoader classLoader, java.net.URL resourceURL)</span> </span>{\n    <span class=\"hljs-keyword\">try</span> {\n        BufferedReader reader = <span class=\"hljs-keyword\">new</span> BufferedReader(\n            <span class=\"hljs-keyword\">new</span> InputStreamReader(resourceURL.openStream(), <span class=\"hljs-string\">\"utf-8\"</span>));\n        <span class=\"hljs-keyword\">try</span> {\n            String line;\n            <span class=\"hljs-comment\">// 按行读取配置内容</span>\n            <span class=\"hljs-keyword\">while</span> ((line = reader.readLine()) != <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-comment\">// 定位 # 字符</span>\n                <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> ci = line.indexOf(<span class=\"hljs-string\">'#'</span>);\n                <span class=\"hljs-keyword\">if</span> (ci &gt;= <span class=\"hljs-number\">0</span>) {\n                    <span class=\"hljs-comment\">// 截取 # 之前的字符串，# 之后的内容为注释，需要忽略</span>\n                    line = line.substring(<span class=\"hljs-number\">0</span>, ci);\n                }\n                line = line.trim();\n                <span class=\"hljs-keyword\">if</span> (line.length() &gt; <span class=\"hljs-number\">0</span>) {\n                    <span class=\"hljs-keyword\">try</span> {\n                        String name = <span class=\"hljs-keyword\">null</span>;\n                        <span class=\"hljs-keyword\">int</span> i = line.indexOf(<span class=\"hljs-string\">'='</span>);\n                        <span class=\"hljs-keyword\">if</span> (i &gt; <span class=\"hljs-number\">0</span>) {\n                            <span class=\"hljs-comment\">// 以等于号 = 为界，截取键与值</span>\n                            name = line.substring(<span class=\"hljs-number\">0</span>, i).trim();\n                            line = line.substring(i + <span class=\"hljs-number\">1</span>).trim();\n                        }\n                        <span class=\"hljs-keyword\">if</span> (line.length() &gt; <span class=\"hljs-number\">0</span>) {\n                            <span class=\"hljs-comment\">// 加载类，并通过 loadClass 方法对类进行缓存</span>\n                            loadClass(extensionClasses, resourceURL, \n                                      Class.forName(line, <span class=\"hljs-keyword\">true</span>, classLoader), name);\n                        }\n                    } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n                        IllegalStateException e = <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"Failed to load extension class...\"</span>);\n                    }\n                }\n            }\n        } <span class=\"hljs-keyword\">finally</span> {\n            reader.close();\n        }\n    } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n        logger.error(<span class=\"hljs-string\">\"Exception when load extension class...\"</span>);\n    }\n}\n</code></pre>\n<p>loadResource 方法用于读取和解析配置文件，并通过反射加载类，最后调用 loadClass 方法进行其他操作。loadClass 方法用于主要用于操作缓存，该方法的逻辑如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">loadClass</span><span class=\"hljs-params\">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, \n    Class&lt;?&gt; clazz, String name)</span> <span class=\"hljs-keyword\">throws</span> NoSuchMethodException </span>{\n    \n    <span class=\"hljs-keyword\">if</span> (!type.isAssignableFrom(clazz)) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"...\"</span>);\n    }\n\n    <span class=\"hljs-comment\">// 检测目标类上是否有 Adaptive 注解</span>\n    <span class=\"hljs-keyword\">if</span> (clazz.isAnnotationPresent(Adaptive.class)) {\n        <span class=\"hljs-keyword\">if</span> (cachedAdaptiveClass == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-comment\">// 设置 cachedAdaptiveClass缓存</span>\n            cachedAdaptiveClass = clazz;\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!cachedAdaptiveClass.equals(clazz)) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"...\"</span>);\n        }\n        \n    <span class=\"hljs-comment\">// 检测 clazz 是否是 Wrapper 类型</span>\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isWrapperClass(clazz)) {\n        Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;\n        <span class=\"hljs-keyword\">if</span> (wrappers == <span class=\"hljs-keyword\">null</span>) {\n            cachedWrapperClasses = <span class=\"hljs-keyword\">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();\n            wrappers = cachedWrapperClasses;\n        }\n        <span class=\"hljs-comment\">// 存储 clazz 到 cachedWrapperClasses 缓存中</span>\n        wrappers.add(clazz);\n        \n    <span class=\"hljs-comment\">// 程序进入此分支，表明 clazz 是一个普通的拓展类</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 检测 clazz 是否有默认的构造方法，如果没有，则抛出异常</span>\n        clazz.getConstructor();\n        <span class=\"hljs-keyword\">if</span> (name == <span class=\"hljs-keyword\">null</span> || name.length() == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-comment\">// 如果 name 为空，则尝试从 Extension 注解中获取 name，或使用小写的类名作为 name</span>\n            name = findAnnotationName(clazz);\n            <span class=\"hljs-keyword\">if</span> (name.length() == <span class=\"hljs-number\">0</span>) {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"...\"</span>);\n            }\n        }\n        <span class=\"hljs-comment\">// 切分 name</span>\n        String[] names = NAME_SEPARATOR.split(name);\n        <span class=\"hljs-keyword\">if</span> (names != <span class=\"hljs-keyword\">null</span> &amp;&amp; names.length &gt; <span class=\"hljs-number\">0</span>) {\n            Activate activate = clazz.getAnnotation(Activate.class);\n            <span class=\"hljs-keyword\">if</span> (activate != <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-comment\">// 如果类上有 Activate 注解，则使用 names 数组的第一个元素作为键，</span>\n                <span class=\"hljs-comment\">// 存储 name 到 Activate 注解对象的映射关系</span>\n                cachedActivates.put(names[<span class=\"hljs-number\">0</span>], activate);\n            }\n            <span class=\"hljs-keyword\">for</span> (String n : names) {\n                <span class=\"hljs-keyword\">if</span> (!cachedNames.containsKey(clazz)) {\n                    <span class=\"hljs-comment\">// 存储 Class 到名称的映射关系</span>\n                    cachedNames.put(clazz, n);\n                }\n                Class&lt;?&gt; c = extensionClasses.get(n);\n                <span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-keyword\">null</span>) {\n                    <span class=\"hljs-comment\">// 存储名称到 Class 的映射关系</span>\n                    extensionClasses.put(n, clazz);\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (c != clazz) {\n                    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"...\"</span>);\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p>如上，loadClass 方法操作了不同的缓存，比如 cachedAdaptiveClass、cachedWrapperClasses 和 cachedNames 等等。除此之外，该方法没有其他什么逻辑了。</p>\n<p>到此，关于缓存类加载的过程就分析完了。整个过程没什么特别复杂的地方，大家按部就班的分析即可，不懂的地方可以调试一下。接下来，我们来聊聊 Dubbo IOC 方面的内容。</p>\n<h3>3.2 Dubbo IOC</h3>\n<p>Dubbo IOC 是通过 setter 方法注入依赖。Dubbo 首先会通过反射获取到实例的所有方法，然后再遍历方法列表，检测方法名是否具有 setter 方法特征。若有，则通过 ObjectFactory 获取依赖对象，最后通过反射调用 setter 方法将依赖设置到目标对象中。整个过程对应的代码如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> T <span class=\"hljs-title\">injectExtension</span><span class=\"hljs-params\">(T instance)</span> </span>{\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-keyword\">if</span> (objectFactory != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-comment\">// 遍历目标类的所有方法</span>\n            <span class=\"hljs-keyword\">for</span> (Method method : instance.getClass().getMethods()) {\n                <span class=\"hljs-comment\">// 检测方法是否以 set 开头，且方法仅有一个参数，且方法访问级别为 public</span>\n                <span class=\"hljs-keyword\">if</span> (method.getName().startsWith(<span class=\"hljs-string\">\"set\"</span>)\n                    &amp;&amp; method.getParameterTypes().length == <span class=\"hljs-number\">1</span>\n                    &amp;&amp; Modifier.isPublic(method.getModifiers())) {\n                    <span class=\"hljs-comment\">// 获取 setter 方法参数类型</span>\n                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class=\"hljs-number\">0</span>];\n                    <span class=\"hljs-keyword\">try</span> {\n                        <span class=\"hljs-comment\">// 获取属性名，比如 setName 方法对应属性名 name</span>\n                        String property = method.getName().length() &gt; <span class=\"hljs-number\">3</span> ? \n                            method.getName().substring(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>).toLowerCase() + \n                            \tmethod.getName().substring(<span class=\"hljs-number\">4</span>) : <span class=\"hljs-string\">\"\"</span>;\n                        <span class=\"hljs-comment\">// 从 ObjectFactory 中获取依赖对象</span>\n                        Object object = objectFactory.getExtension(pt, property);\n                        <span class=\"hljs-keyword\">if</span> (object != <span class=\"hljs-keyword\">null</span>) {\n                            <span class=\"hljs-comment\">// 通过反射调用 setter 方法设置依赖</span>\n                            method.invoke(instance, object);\n                        }\n                    } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n                        logger.error(<span class=\"hljs-string\">\"fail to inject via method...\"</span>);\n                    }\n                }\n            }\n        }\n    } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n        logger.error(e.getMessage(), e);\n    }\n    <span class=\"hljs-keyword\">return</span> instance;\n}\n</code></pre>\n<p>在上面代码中，objectFactory 变量的类型为 AdaptiveExtensionFactory，AdaptiveExtensionFactory 内部维护了一个 ExtensionFactory 列表，用于存储其他类型的 ExtensionFactory。Dubbo 目前提供了两种 ExtensionFactory，分别是 SpiExtensionFactory 和 SpringExtensionFactory。前者用于创建自适应的拓展，后者是用于从 Spring 的 IOC 容器中获取所需的拓展。这两个类的类的代码不是很复杂，这里就不一一分析了。</p>\n<p>Dubbo IOC 目前仅支持 setter 方式注入，总的来说，逻辑比较简单易懂。</p>\n<h2>4.总结</h2>\n<p>本篇文章简单分别介绍了 Java SPI 与 Dubbo SPI 用法，并对 Dubbo SPI 的加载拓展类的过程进行了分析。另外，在 Dubbo SPI 中还有一块重要的逻辑这里没有进行分析，即 Dubbo SPI 的扩展点自适应机制。该机制的逻辑较为复杂，我们将会在下一篇文章中进行详细的分析。</p>\n<p>好了，本篇文章就先到这里了。如果文章中有错误不妥之处，欢迎大家提 issue 进行反馈，或者提 pull request 进行修正。让我们携手共建 Dubbo 社区。</p>\n",
  "link": "/zh-cn/docs/source_code_guide/dubbo-spi.html",
  "meta": {
    "title": "Dubbo SPI",
    "keywords": "Dubbo, SPI",
    "description": "本文介绍了 Dubbo SPI 的原理和实现细节"
  }
}