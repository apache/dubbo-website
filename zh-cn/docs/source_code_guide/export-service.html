<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="Dubbo, service, export" />
	<meta name="description" content="本文介绍了 Dubbo 服务导出的过程和实现细节" />
	<!-- 网页标签标题 -->
	<title>服务导出</title>
	<link rel="shortcut icon" href="/img/dubbo.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/dubbo_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/user/quick-start.html">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/docs/developers/developers_dev.html">开发者</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html">博客</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html">社区</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/download.html">下载</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/docs.png" class="front-img"/><span>文档</span><img src="/img/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>用户文档</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>入门<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/background.html" target="_self">背景</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/requirements.html" target="_self">需求</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/architecture.html" target="_self">架构</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/usage.html" target="_self">用法</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/quick-start.html" target="_self">快速启动</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/dependencies.html" target="_self">依赖</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/maturity.html" target="_self">成熟度</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>配置<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/xml.html" target="_self">XML配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/api.html" target="_self">API配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/annotation.html" target="_self">注解配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/config-center.html" target="_self">动态配置中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/configuration-load-process.html" target="_self">配置加载流程</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>示例<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/preflight-check.html" target="_self">启动时检查</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/fault-tolerent-strategy.html" target="_self">集群容错</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/loadbalance.html" target="_self">负载均衡</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/thread-model.html" target="_self">线程模型</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/explicit-target.html" target="_self">直连提供者</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/subscribe-only.html" target="_self">只订阅</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/registry-only.html" target="_self">只注册</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/static-service.html" target="_self">静态服务</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/multi-protocols.html" target="_self">多协议</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/multi-registry.html" target="_self">多注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/service-group.html" target="_self">服务分组</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/multi-versions.html" target="_self">多版本</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/group-merger.html" target="_self">分组聚合</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/parameter-validation.html" target="_self">参数验证</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/result-cache.html" target="_self">结果缓存</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/generic-reference.html" target="_self">泛化引用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/generic-service.html" target="_self">泛化实现</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/echo-service.html" target="_self">回声测试</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/context.html" target="_self">上下文信息</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/attachment.html" target="_self">隐式参数</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/async-call.html" target="_self">Consumer异步调用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/async-execute-on-provider.html" target="_self">Provider异步执行</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/local-call.html" target="_self">本地调用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/callback-parameter.html" target="_self">参数回调</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/events-notify.html" target="_self">事件通知</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/local-stub.html" target="_self">本地存根</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/local-mock.html" target="_self">本地伪装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/delay-publish.html" target="_self">延迟暴露</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/concurrency-control.html" target="_self">并发控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/config-connections.html" target="_self">连接控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/lazy-connect.html" target="_self">延迟连接</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/stickiness.html" target="_self">粘滞连接</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/token-authorization.html" target="_self">令牌验证</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/routing-rule.html" target="_self">路由规则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/config-rule.html" target="_self">配置规则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/service-downgrade.html" target="_self">服务降级</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/graceful-shutdown.html" target="_self">优雅停机</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/hostname-binding.html" target="_self">主机绑定</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/logger-strategy.html" target="_self">日志适配</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/accesslog.html" target="_self">访问日志</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/service-container.html" target="_self">服务容器</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/reference-config-cache.html" target="_self">Reference Config 缓存</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/distributed-transaction.html" target="_self">分布式事务</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/dump.html" target="_self">线程栈自动dump</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/netty4.html" target="_self">Netty4</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/serialization.html" target="_self">Kryo和FST序列化</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/simplify-registry-data.html" target="_self">简化注册中心URL</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/api.html" target="_self">API配置参考手册</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>schema配置参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-service.html" target="_self">dubbo:service</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-reference.html" target="_self">dubbo:reference</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-protocol.html" target="_self">dubbo:protocol</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-registry.html" target="_self">dubbo:registry</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-monitor.html" target="_self">dubbo:monitor</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-application.html" target="_self">dubbo:application</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-module.html" target="_self">dubbo:module</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-provider.html" target="_self">dubbo:provider</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-consumer.html" target="_self">dubbo:consumer</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-method.html" target="_self">dubbo:method</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-argument.html" target="_self">dubbo:argument</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-parameter.html" target="_self">dubbo:parameter</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-config-center.html" target="_self">dubbo:config-center</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>协议参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/dubbo.html" target="_self">dubbo://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/rmi.html" target="_self">rmi://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/hessian.html" target="_self">hessian://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/http.html" target="_self">http://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/webservice.html" target="_self">webservice://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/thrift.html" target="_self">thrift://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/memcached.html" target="_self">memcached://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/redis.html" target="_self">redis://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/rest.html" target="_self">rest://</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>注册中心参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/multicast.html" target="_self">Multicast 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/zookeeper.html" target="_self">Zookeeper 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/redis.html" target="_self">Redis 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/simple.html" target="_self">Simple 注册中心</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>元数据中心参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/metadata/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/metadata/metadata-redis.html" target="_self">Redis</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/metadata/metadata-zookeeper.html" target="_self">Zookeeper</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/telnet.html" target="_self">telnet命令参考手册</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/qos.html" target="_self">在线运维命令-QOS</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/maven.html" target="_self">maven插件参考手册</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/best-practice.html" target="_self">服务化最佳实践</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/recommend.html" target="_self">推荐用法</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/capacity-plan.html" target="_self">容量规划</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/perf-test.html" target="_self">性能测试报告</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/coveragence.html" target="_self">测试覆盖率报告</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>版本与升级<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/versions/version-270.html" target="_self">2.7.x升级步骤及注意事项</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>开发者指南</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/build.html" target="_self">源码构建</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/design.html" target="_self">框架设计</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/SPI.html" target="_self">扩展点加载</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/implementation.html" target="_self">实现细节</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>SPI 扩展实现<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/protocol.html" target="_self">协议扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/filter.html" target="_self">调用拦截扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/invoker-listener.html" target="_self">引用监听扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/exporter-listener.html" target="_self">暴露监听扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/cluster.html" target="_self">集群扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/router.html" target="_self">路由扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/load-balance.html" target="_self">负载均衡扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/merger.html" target="_self">合并结果扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/registry.html" target="_self">注册中心扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/monitor.html" target="_self">监控中心扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/extension-factory.html" target="_self">扩展点加载扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/proxy-factory.html" target="_self">动态代理扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/compiler.html" target="_self">编译器扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/dispatcher.html" target="_self">消息派发扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/threadpool.html" target="_self">线程池扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/serialize.html" target="_self">序列化扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/remoting.html" target="_self">网络传输扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/exchanger.html" target="_self">信息交换扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/networker.html" target="_self">组网扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/telnet-handler.html" target="_self">Telnet 命令扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/status-checker.html" target="_self">状态检查扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/container.html" target="_self">容器扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/page.html" target="_self">页面扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/cache.html" target="_self">缓存扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/validation.html" target="_self">验证扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/logger-adapter.html" target="_self">日志适配扩展</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/contract.html" target="_self">公共契约</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/coding.html" target="_self">编码约定</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>设计原则<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/code-detail.html" target="_self">魔鬼在细节</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/general-knowledge.html" target="_self">一些设计上的基本常识</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/expansibility.html" target="_self">谈谈扩充式扩展与增量式扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/configuration.html" target="_self">配置设计</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/robustness.html" target="_self">设计实现的健壮性</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/dummy.html" target="_self">防痴呆设计</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/extension.html" target="_self">扩展点重构</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/release.html" target="_self">版本管理</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/contribution.html" target="_self">贡献</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/checklist.html" target="_self">检查列表</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/code-smell.html" target="_self">坏味道</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/TCK.html" target="_self">技术兼容性测试</a></li></ul></li><li class="menu-item menu-item-level-1"><span>源码导读</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/dubbo-spi.html" target="_self">Dubbo SPI</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/adaptive-extension.html" target="_self">自适应拓展机制</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/export-service.html" target="_self">服务导出</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/refer-service.html" target="_self">服务引入</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/directory.html" target="_self">服务字典</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/router.html" target="_self">服务路由</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/cluster.html" target="_self">集群</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/loadbalance.html" target="_self">负载均衡</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/service-invoking-process.html" target="_self">服务调用过程</a></li></ul></li><li class="menu-item menu-item-level-1"><span>运维管理</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/admin/introduction.html" target="_self">控制台介绍</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/admin/serviceSearch.html" target="_self">服务搜索</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/admin/serviceGovernance.html" target="_self">服务治理</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/admin/serviceTest.html" target="_self">服务测试</a></li></ul></li></ul></div><div class="doc-content markdown-body"><h2>1.简介</h2>
<p>本篇文章，我们来研究一下 Dubbo 导出服务的过程。Dubbo 服务导出过程始于 Spring 容器发布刷新事件，Dubbo 在接收到事件后，会立即执行服务导出逻辑。整个逻辑大致可分为三个部分，第一部分是前置工作，主要用于检查参数，组装 URL。第二部分是导出服务，包含导出服务到本地 (JVM)，和导出服务到远程两个过程。第三部分是向注册中心注册服务，用于服务发现。本篇文章将会对这三个部分代码进行详细的分析。</p>
<h2>2.源码分析</h2>
<p>服务导出的入口方法是 ServiceBean 的 onApplicationEvent。onApplicationEvent 是一个事件响应方法，该方法会在收到 Spring 上下文刷新事件后执行服务导出操作。方法代码如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> </span>{
    <span class="hljs-comment">// 是否有延迟导出 &amp;&amp; 是否已导出 &amp;&amp; 是不是已被取消导出</span>
    <span class="hljs-keyword">if</span> (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) {
        <span class="hljs-comment">// 导出服务</span>
        export();
    }
}
</code></pre>
<p>这个方法首先会根据条件决定是否导出服务，比如有些服务设置了延时导出，那么此时就不应该在此处导出。还有一些服务已经被导出了，或者当前服务被取消导出了，此时也不能再次导出相关服务。注意这里的 isDelay 方法，这个方法字面意思是“是否延迟导出服务”，返回 true 表示延迟导出，false 表示不延迟导出。但是该方法真实意思却并非如此，当方法返回 true 时，表示无需延迟导出。返回 false 时，表示需要延迟导出。与字面意思恰恰相反，这个需要大家注意一下。下面我们来看一下这个方法的逻辑。</p>
<pre><code class="language-java"><span class="hljs-comment">// -☆- ServiceBean</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDelay</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 获取 delay</span>
    Integer delay = getDelay();
    ProviderConfig provider = getProvider();
    <span class="hljs-keyword">if</span> (delay == <span class="hljs-keyword">null</span> &amp;&amp; provider != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// 如果前面获取的 delay 为空，这里继续获取</span>
        delay = provider.getDelay();
    }
    <span class="hljs-comment">// 判断 delay 是否为空，或者等于 -1</span>
    <span class="hljs-keyword">return</span> supportedApplicationListener &amp;&amp; (delay == <span class="hljs-keyword">null</span> || delay == -<span class="hljs-number">1</span>);
}
</code></pre>
<p>暂时忽略 supportedApplicationListener 这个条件，当 delay 为空，或者等于-1时，该方法返回 true，而不是 false。这个方法的返回值让人有点困惑。该方法目前已被重构，详细请参考 <a href="https://github.com/apache/incubator-dubbo/pull/2686">incubator-dubbo #2686</a>。</p>
<p>现在解释一下 supportedApplicationListener 变量含义，该变量用于表示当前的 Spring 容器是否支持 ApplicationListener，这个值初始为 false。在 Spring 容器将自己设置到 ServiceBean 中时，ServiceBean 的 setApplicationContext 方法会检测 Spring 容器是否支持 ApplicationListener。若支持，则将 supportedApplicationListener 置为 true。ServiceBean 是 Dubbo 与 Spring 框架进行整合的关键，可以看做是两个框架之间的桥梁。具有同样作用的类还有 ReferenceBean。</p>
<p>现在我们知道了 Dubbo 服务导出过程的起点，接下来对服务导出的前置逻辑进行分析。</p>
<h3>2.1 前置工作</h3>
<p>前置工作主要包含两个部分，分别是配置检查，以及 URL 装配。在导出服务之前，Dubbo 需要检查用户的配置是否合理，或者为用户补充缺省配置。配置检查完成后，接下来需要根据这些配置组装 URL。在 Dubbo 中，URL 的作用十分重要。Dubbo 使用 URL 作为配置载体，所有的拓展点都是通过 URL 获取配置。这一点，官方文档中有所说明。</p>
<blockquote>
<p>采用 URL 作为配置信息的统一格式，所有扩展点都通过传递 URL 携带配置信息。</p>
</blockquote>
<p>接下来，我们先来分析配置检查部分的源码，随后再来分析 URL 组装部分的源码。</p>
<h4>2.1.1 检查配置</h4>
<p>本节我们接着前面的源码向下分析，前面说过 onApplicationEvent 方法在经过一些判断后，会决定是否调用 export 方法导出服务。那么下面我们从 export 方法开始进行分析，如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">export</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (provider != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// 获取 export 和 delay 配置</span>
        <span class="hljs-keyword">if</span> (export == <span class="hljs-keyword">null</span>) {
            export = provider.getExport();
        }
        <span class="hljs-keyword">if</span> (delay == <span class="hljs-keyword">null</span>) {
            delay = provider.getDelay();
        }
    }
    <span class="hljs-comment">// 如果 export 为 false，则不导出服务</span>
    <span class="hljs-keyword">if</span> (export != <span class="hljs-keyword">null</span> &amp;&amp; !export) {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// delay &gt; 0，延时导出服务</span>
    <span class="hljs-keyword">if</span> (delay != <span class="hljs-keyword">null</span> &amp;&amp; delay &gt; <span class="hljs-number">0</span>) {
        delayExportExecutor.schedule(<span class="hljs-keyword">new</span> Runnable() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                doExport();
            }
        }, delay, TimeUnit.MILLISECONDS);
        
    <span class="hljs-comment">// 立即导出服务</span>
    } <span class="hljs-keyword">else</span> {
        doExport();
    }
}
</code></pre>
<p>export 方法对两项配置进行了检查，并根据配置执行相应的动作。首先是 export 配置，这个配置决定了是否导出服务。有时候我们只是想本地启动服务进行一些调试工作，我们并不希望把本地启动的服务暴露出去给别人调用。此时，我们可通过配置 export 禁止服务导出，比如：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:provider</span> <span class="hljs-attr">export</span>=<span class="hljs-string">"false"</span> /&gt;</span>
</code></pre>
<p>delay 配置顾名思义，用于延迟导出服务，这个就不分析了。下面，我们继续分析源码，这次要分析的是 doExport 方法。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doExport</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (unexported) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Already unexported!"</span>);
    }
    <span class="hljs-keyword">if</span> (exported) {
        <span class="hljs-keyword">return</span>;
    }
    exported = <span class="hljs-keyword">true</span>;
    <span class="hljs-comment">// 检测 interfaceName 是否合法</span>
    <span class="hljs-keyword">if</span> (interfaceName == <span class="hljs-keyword">null</span> || interfaceName.length() == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"interface not allow null!"</span>);
    }
    <span class="hljs-comment">// 检测 provider 是否为空，为空则新建一个，并通过系统变量为其初始化</span>
    checkDefault();

    <span class="hljs-comment">// 下面几个 if 语句用于检测 provider、application 等核心配置类对象是否为空，</span>
    <span class="hljs-comment">// 若为空，则尝试从其他配置类对象中获取相应的实例。</span>
    <span class="hljs-keyword">if</span> (provider != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (application == <span class="hljs-keyword">null</span>) {
            application = provider.getApplication();
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">module</span> == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">module</span> = provider.getModule();
        }
        <span class="hljs-keyword">if</span> (registries == <span class="hljs-keyword">null</span>) {...}
        <span class="hljs-keyword">if</span> (monitor == <span class="hljs-keyword">null</span>) {...}
        <span class="hljs-keyword">if</span> (protocols == <span class="hljs-keyword">null</span>) {...}
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">module</span> != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (registries == <span class="hljs-keyword">null</span>) {
            registries = <span class="hljs-keyword">module</span>.getRegistries();
        }
        <span class="hljs-keyword">if</span> (monitor == <span class="hljs-keyword">null</span>) {...}
    }
    <span class="hljs-keyword">if</span> (application != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (registries == <span class="hljs-keyword">null</span>) {
            registries = application.getRegistries();
        }
        <span class="hljs-keyword">if</span> (monitor == <span class="hljs-keyword">null</span>) {...}
    }

    <span class="hljs-comment">// 检测 ref 是否为泛化服务类型</span>
    <span class="hljs-keyword">if</span> (ref <span class="hljs-keyword">instanceof</span> GenericService) {
        <span class="hljs-comment">// 设置 interfaceClass 为 GenericService.class</span>
        interfaceClass = GenericService.class;
        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(generic)) {
            <span class="hljs-comment">// 设置 generic = "true"</span>
            generic = Boolean.TRUE.toString();
        }
        
    <span class="hljs-comment">// ref 非 GenericService 类型</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">try</span> {
            interfaceClass = Class.forName(interfaceName, <span class="hljs-keyword">true</span>, Thread.currentThread()
                    .getContextClassLoader());
        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(e.getMessage(), e);
        }
        <span class="hljs-comment">// 对 interfaceClass，以及 &lt;dubbo:method&gt; 标签中的必要字段进行检查</span>
        checkInterfaceAndMethods(interfaceClass, methods);
        <span class="hljs-comment">// 对 ref 合法性进行检测</span>
        checkRef();
        <span class="hljs-comment">// 设置 generic = "false"</span>
        generic = Boolean.FALSE.toString();
    }

    <span class="hljs-comment">// local 和 stub 在功能应该是一致的，用于配置本地存根</span>
    <span class="hljs-keyword">if</span> (local != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"true"</span>.equals(local)) {
            local = interfaceName + <span class="hljs-string">"Local"</span>;
        }
        Class&lt;?&gt; localClass;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 获取本地存根类</span>
            localClass = ClassHelper.forNameWithThreadContextClassLoader(local);
        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(e.getMessage(), e);
        }
        <span class="hljs-comment">// 检测本地存根类是否可赋值给接口类，若不可赋值则会抛出异常，提醒使用者本地存根类类型不合法</span>
        <span class="hljs-keyword">if</span> (!interfaceClass.isAssignableFrom(localClass)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"The local implementation class "</span> + localClass.getName() + <span class="hljs-string">" not implement interface "</span> + interfaceName);
        }
    }

    <span class="hljs-keyword">if</span> (stub != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// 此处的代码和上一个 if 分支的代码基本一致，这里省略</span>
    }

    <span class="hljs-comment">// 检测各种对象是否为空，为空则新建，或者抛出异常</span>
    checkApplication();
    checkRegistry();
    checkProtocol();
    appendProperties(<span class="hljs-keyword">this</span>);
    checkStubAndMock(interfaceClass);
    <span class="hljs-keyword">if</span> (path == <span class="hljs-keyword">null</span> || path.length() == <span class="hljs-number">0</span>) {
        path = interfaceName;
    }

    <span class="hljs-comment">// 导出服务</span>
    doExportUrls();

    <span class="hljs-comment">// ProviderModel 表示服务提供者模型，此对象中存储了与服务提供者相关的信息。</span>
    <span class="hljs-comment">// 比如服务的配置信息，服务实例等。每个被导出的服务对应一个 ProviderModel。</span>
    <span class="hljs-comment">// ApplicationModel 持有所有的 ProviderModel。</span>
    ProviderModel providerModel = <span class="hljs-keyword">new</span> ProviderModel(getUniqueServiceName(), <span class="hljs-keyword">this</span>, ref);
    ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);
}
</code></pre>
<p>以上就是配置检查的相关分析，代码比较多，需要大家耐心看一下。下面对配置检查的逻辑进行简单的总结，如下：</p>
<ol>
<li>检测 &lt;dubbo:service&gt; 标签的 interface 属性合法性，不合法则抛出异常</li>
<li>检测 ProviderConfig、ApplicationConfig 等核心配置类对象是否为空，若为空，则尝试从其他配置类对象中获取相应的实例。</li>
<li>检测并处理泛化服务和普通服务类</li>
<li>检测本地存根配置，并进行相应的处理</li>
<li>对 ApplicationConfig、RegistryConfig 等配置类进行检测，为空则尝试创建，若无法创建则抛出异常</li>
</ol>
<p>配置检查并非本文重点，因此这里不打算对 doExport 方法所调用的方法进行分析（doExportUrls 方法除外）。在这些方法中，除了 appendProperties 方法稍微复杂一些，其他方法逻辑不是很复杂。因此，大家可自行分析。</p>
<h4>2.1.2 多协议多注册中心导出服务</h4>
<p>Dubbo 允许我们使用不同的协议导出服务，也允许我们向多个注册中心注册服务。Dubbo 在 doExportUrls 方法中对多协议，多注册中心进行了支持。相关代码如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doExportUrls</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 加载注册中心链接</span>
    List&lt;URL&gt; registryURLs = loadRegistries(<span class="hljs-keyword">true</span>);
    <span class="hljs-comment">// 遍历 protocols，并在每个协议下导出服务</span>
    <span class="hljs-keyword">for</span> (ProtocolConfig protocolConfig : protocols) {
        doExportUrlsFor1Protocol(protocolConfig, registryURLs);
    }
}
</code></pre>
<p>上面代码首先是通过 loadRegistries 加载注册中心链接，然后再遍历 ProtocolConfig 集合导出每个服务。并在导出服务的过程中，将服务注册到注册中心。下面，我们先来看一下 loadRegistries 方法的逻辑。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;URL&gt; <span class="hljs-title">loadRegistries</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> provider)</span> </span>{
    <span class="hljs-comment">// 检测是否存在注册中心配置类，不存在则抛出异常</span>
    checkRegistry();
    List&lt;URL&gt; registryList = <span class="hljs-keyword">new</span> ArrayList&lt;URL&gt;();
    <span class="hljs-keyword">if</span> (registries != <span class="hljs-keyword">null</span> &amp;&amp; !registries.isEmpty()) {
        <span class="hljs-keyword">for</span> (RegistryConfig config : registries) {
            String address = config.getAddress();
            <span class="hljs-keyword">if</span> (address == <span class="hljs-keyword">null</span> || address.length() == <span class="hljs-number">0</span>) {
                <span class="hljs-comment">// 若 address 为空，则将其设为 0.0.0.0</span>
                address = Constants.ANYHOST_VALUE;
            }

            <span class="hljs-comment">// 从系统属性中加载注册中心地址</span>
            String sysaddress = System.getProperty(<span class="hljs-string">"dubbo.registry.address"</span>);
            <span class="hljs-keyword">if</span> (sysaddress != <span class="hljs-keyword">null</span> &amp;&amp; sysaddress.length() &gt; <span class="hljs-number">0</span>) {
                address = sysaddress;
            }
            <span class="hljs-comment">// 检测 address 是否合法</span>
            <span class="hljs-keyword">if</span> (address.length() &gt; <span class="hljs-number">0</span> &amp;&amp; !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) {
                Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();
                <span class="hljs-comment">// 添加 ApplicationConfig 中的字段信息到 map 中</span>
                appendParameters(map, application);
                <span class="hljs-comment">// 添加 RegistryConfig 字段信息到 map 中</span>
                appendParameters(map, config);
                
                <span class="hljs-comment">// 添加 path、pid，protocol 等信息到 map 中</span>
                map.put(<span class="hljs-string">"path"</span>, RegistryService.class.getName());
                map.put(<span class="hljs-string">"dubbo"</span>, Version.getProtocolVersion());
                map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));
                <span class="hljs-keyword">if</span> (ConfigUtils.getPid() &gt; <span class="hljs-number">0</span>) {
                    map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));
                }
                <span class="hljs-keyword">if</span> (!map.containsKey(<span class="hljs-string">"protocol"</span>)) {
                    <span class="hljs-keyword">if</span> (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension(<span class="hljs-string">"remote"</span>)) {
                        map.put(<span class="hljs-string">"protocol"</span>, <span class="hljs-string">"remote"</span>);
                    } <span class="hljs-keyword">else</span> {
                        map.put(<span class="hljs-string">"protocol"</span>, <span class="hljs-string">"dubbo"</span>);
                    }
                }

                <span class="hljs-comment">// 解析得到 URL 列表，address 可能包含多个注册中心 ip，</span>
                <span class="hljs-comment">// 因此解析得到的是一个 URL 列表</span>
                List&lt;URL&gt; urls = UrlUtils.parseURLs(address, map);
                <span class="hljs-keyword">for</span> (URL url : urls) {
                    url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());
                    <span class="hljs-comment">// 将 URL 协议头设置为 registry</span>
                    url = url.setProtocol(Constants.REGISTRY_PROTOCOL);
                    <span class="hljs-comment">// 通过判断条件，决定是否添加 url 到 registryList 中，条件如下：</span>
                    <span class="hljs-comment">// (服务提供者 &amp;&amp; register = true 或 null) </span>
                    <span class="hljs-comment">//    || (非服务提供者 &amp;&amp; subscribe = true 或 null)</span>
                    <span class="hljs-keyword">if</span> ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, <span class="hljs-keyword">true</span>))
                            || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, <span class="hljs-keyword">true</span>))) {
                        registryList.add(url);
                    }
                }
            }
        }
    }
    <span class="hljs-keyword">return</span> registryList;
}
</code></pre>
<p>loadRegistries 方法主要包含如下的逻辑：</p>
<ol>
<li>检测是否存在注册中心配置类，不存在则抛出异常</li>
<li>构建参数映射集合，也就是 map</li>
<li>构建注册中心链接列表</li>
<li>遍历链接列表，并根据条件决定是否将其添加到 registryList 中</li>
</ol>
<p>关于多协议多注册中心导出服务就先分析到这，代码不是很多，接下来分析 URL 组装过程。</p>
<h4>2.1.3 组装 URL</h4>
<p>配置检查完毕后，紧接着要做的事情是根据配置，以及其他一些信息组装 URL。前面说过，URL 是 Dubbo 配置的载体，通过  URL 可让 Dubbo 的各种配置在各个模块之间传递。URL 之于 Dubbo，犹如水之于鱼，非常重要。大家在阅读 Dubbo 服务导出相关源码的过程中，要注意 URL 内容的变化。既然 URL 如此重要，那么下面我们来了解一下 URL 组装的过程。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doExportUrlsFor1Protocol</span><span class="hljs-params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>{
    String name = protocolConfig.getName();
    <span class="hljs-comment">// 如果协议名为空，或空串，则将协议名变量设置为 dubbo</span>
    <span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span> || name.length() == <span class="hljs-number">0</span>) {
        name = <span class="hljs-string">"dubbo"</span>;
    }

    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();
    <span class="hljs-comment">// 添加 side、版本、时间戳以及进程号等信息到 map 中</span>
    map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);
    map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());
    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));
    <span class="hljs-keyword">if</span> (ConfigUtils.getPid() &gt; <span class="hljs-number">0</span>) {
        map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));
    }

    <span class="hljs-comment">// 通过反射将对象的字段信息添加到 map 中</span>
    appendParameters(map, application);
    appendParameters(map, <span class="hljs-keyword">module</span>);
    appendParameters(map, provider, Constants.DEFAULT_KEY);
    appendParameters(map, protocolConfig);
    appendParameters(map, <span class="hljs-keyword">this</span>);

    <span class="hljs-comment">// methods 为 MethodConfig 集合，MethodConfig 中存储了 &lt;dubbo:method&gt; 标签的配置信息</span>
    <span class="hljs-keyword">if</span> (methods != <span class="hljs-keyword">null</span> &amp;&amp; !methods.isEmpty()) {
        <span class="hljs-comment">// 这段代码用于添加 Callback 配置到 map 中，代码太长，待会单独分析</span>
    }

    <span class="hljs-comment">// 检测 generic 是否为 "true"，并根据检测结果向 map 中添加不同的信息</span>
    <span class="hljs-keyword">if</span> (ProtocolUtils.isGeneric(generic)) {
        map.put(Constants.GENERIC_KEY, generic);
        map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);
    } <span class="hljs-keyword">else</span> {
        String revision = Version.getVersion(interfaceClass, version);
        <span class="hljs-keyword">if</span> (revision != <span class="hljs-keyword">null</span> &amp;&amp; revision.length() &gt; <span class="hljs-number">0</span>) {
            map.put(<span class="hljs-string">"revision"</span>, revision);
        }

        <span class="hljs-comment">// 为接口生成包裹类 Wrapper，Wrapper 中包含了接口的详细信息，比如接口方法名数组，字段信息等</span>
        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();
        <span class="hljs-comment">// 添加方法名到 map 中，如果包含多个方法名，则用逗号隔开，比如 method = init,destroy</span>
        <span class="hljs-keyword">if</span> (methods.length == <span class="hljs-number">0</span>) {
            logger.warn(<span class="hljs-string">"NO method found in service interface ..."</span>);
            map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 将逗号作为分隔符连接方法名，并将连接后的字符串放入 map 中</span>
            map.put(Constants.METHODS_KEY, StringUtils.join(<span class="hljs-keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="hljs-string">","</span>));
        }
    }

    <span class="hljs-comment">// 添加 token 到 map 中</span>
    <span class="hljs-keyword">if</span> (!ConfigUtils.isEmpty(token)) {
        <span class="hljs-keyword">if</span> (ConfigUtils.isDefault(token)) {
            <span class="hljs-comment">// 随机生成 token</span>
            map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());
        } <span class="hljs-keyword">else</span> {
            map.put(Constants.TOKEN_KEY, token);
        }
    }
    <span class="hljs-comment">// 判断协议名是否为 injvm</span>
    <span class="hljs-keyword">if</span> (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) {
        protocolConfig.setRegister(<span class="hljs-keyword">false</span>);
        map.put(<span class="hljs-string">"notify"</span>, <span class="hljs-string">"false"</span>);
    }

    <span class="hljs-comment">// 获取上下文路径</span>
    String contextPath = protocolConfig.getContextpath();
    <span class="hljs-keyword">if</span> ((contextPath == <span class="hljs-keyword">null</span> || contextPath.length() == <span class="hljs-number">0</span>) &amp;&amp; provider != <span class="hljs-keyword">null</span>) {
        contextPath = provider.getContextpath();
    }

    <span class="hljs-comment">// 获取 host 和 port</span>
    String host = <span class="hljs-keyword">this</span>.findConfigedHosts(protocolConfig, registryURLs, map);
    Integer port = <span class="hljs-keyword">this</span>.findConfigedPorts(protocolConfig, name, map);
    <span class="hljs-comment">// 组装 URL</span>
    URL url = <span class="hljs-keyword">new</span> URL(name, host, port, (contextPath == <span class="hljs-keyword">null</span> || contextPath.length() == <span class="hljs-number">0</span> ? <span class="hljs-string">""</span> : contextPath + <span class="hljs-string">"/"</span>) + path, map);
    
    <span class="hljs-comment">// 省略无关代码</span>
}
</code></pre>
<p>上面的代码首先是将一些信息，比如版本、时间戳、方法名以及各种配置对象的字段信息放入到 map 中，map 中的内容将作为 URL 的查询字符串。构建好 map 后，紧接着是获取上下文路径、主机名以及端口号等信息。最后将 map 和主机名等数据传给 URL 构造方法创建 URL 对象。需要注意的是，这里出现的 URL 并非 java.net.URL，而是 com.alibaba.dubbo.common.URL。</p>
<p>上面省略了一段代码，这里简单分析一下。这段代码用于检测 &lt;dubbo:method&gt; 标签中的配置信息，并将相关配置添加到 map 中。代码如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doExportUrlsFor1Protocol</span><span class="hljs-params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>{
    <span class="hljs-comment">// ...</span>

    <span class="hljs-comment">// methods 为 MethodConfig 集合，MethodConfig 中存储了 &lt;dubbo:method&gt; 标签的配置信息</span>
    <span class="hljs-keyword">if</span> (methods != <span class="hljs-keyword">null</span> &amp;&amp; !methods.isEmpty()) {
        <span class="hljs-keyword">for</span> (MethodConfig method : methods) {
            <span class="hljs-comment">// 添加 MethodConfig 对象的字段信息到 map 中，键 = 方法名.属性名。</span>
            <span class="hljs-comment">// 比如存储 &lt;dubbo:method name="sayHello" retries="2"&gt; 对应的 MethodConfig，</span>
            <span class="hljs-comment">// 键 = sayHello.retries，map = {"sayHello.retries": 2, "xxx": "yyy"}</span>
            appendParameters(map, method, method.getName());

            String retryKey = method.getName() + <span class="hljs-string">".retry"</span>;
            <span class="hljs-keyword">if</span> (map.containsKey(retryKey)) {
                String retryValue = map.remove(retryKey);
                <span class="hljs-comment">// 检测 MethodConfig retry 是否为 false，若是，则设置重试次数为0</span>
                <span class="hljs-keyword">if</span> (<span class="hljs-string">"false"</span>.equals(retryValue)) {
                    map.put(method.getName() + <span class="hljs-string">".retries"</span>, <span class="hljs-string">"0"</span>);
                }
            }
            
            <span class="hljs-comment">// 获取 ArgumentConfig 列表</span>
            List&lt;ArgumentConfig&gt; arguments = method.getArguments();
            <span class="hljs-keyword">if</span> (arguments != <span class="hljs-keyword">null</span> &amp;&amp; !arguments.isEmpty()) {
                <span class="hljs-keyword">for</span> (ArgumentConfig argument : arguments) {
                    <span class="hljs-comment">// 检测 type 属性是否为空，或者空串（分支1 ⭐️）</span>
                    <span class="hljs-keyword">if</span> (argument.getType() != <span class="hljs-keyword">null</span> &amp;&amp; argument.getType().length() &gt; <span class="hljs-number">0</span>) {
                        Method[] methods = interfaceClass.getMethods();
                        <span class="hljs-keyword">if</span> (methods != <span class="hljs-keyword">null</span> &amp;&amp; methods.length &gt; <span class="hljs-number">0</span>) {
                            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; methods.length; i++) {
                                String methodName = methods[i].getName();
                                <span class="hljs-comment">// 比对方法名，查找目标方法</span>
                                <span class="hljs-keyword">if</span> (methodName.equals(method.getName())) {
                                    Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes();
                                    <span class="hljs-keyword">if</span> (argument.getIndex() != -<span class="hljs-number">1</span>) {
                                        <span class="hljs-comment">// 检测 ArgumentConfig 中的 type 属性与方法参数列表</span>
                                        <span class="hljs-comment">// 中的参数名称是否一致，不一致则抛出异常(分支2 ⭐️)</span>
                                        <span class="hljs-keyword">if</span> (argtypes[argument.getIndex()].getName().equals(argument.getType())) {
                                            <span class="hljs-comment">// 添加 ArgumentConfig 字段信息到 map 中，</span>
                                            <span class="hljs-comment">// 键前缀 = 方法名.index，比如:</span>
                                            <span class="hljs-comment">// map = {"sayHello.3": true}</span>
                                            appendParameters(map, argument, method.getName() + <span class="hljs-string">"."</span> + argument.getIndex());
                                        } <span class="hljs-keyword">else</span> {
                                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"argument config error: ..."</span>);
                                        }
                                    } <span class="hljs-keyword">else</span> {    <span class="hljs-comment">// 分支3 ⭐️</span>
                                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; argtypes.length; j++) {
                                            Class&lt;?&gt; argclazz = argtypes[j];
                                            <span class="hljs-comment">// 从参数类型列表中查找类型名称为 argument.type 的参数</span>
                                            <span class="hljs-keyword">if</span> (argclazz.getName().equals(argument.getType())) {
                                                appendParameters(map, argument, method.getName() + <span class="hljs-string">"."</span> + j);
                                                <span class="hljs-keyword">if</span> (argument.getIndex() != -<span class="hljs-number">1</span> &amp;&amp; argument.getIndex() != j) {
                                                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"argument config error: ..."</span>);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    <span class="hljs-comment">// 用户未配置 type 属性，但配置了 index 属性，且 index != -1</span>
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argument.getIndex() != -<span class="hljs-number">1</span>) {    <span class="hljs-comment">// 分支4 ⭐️</span>
                        <span class="hljs-comment">// 添加 ArgumentConfig 字段信息到 map 中</span>
                        appendParameters(map, argument, method.getName() + <span class="hljs-string">"."</span> + argument.getIndex());
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"argument config must set index or type"</span>);
                    }
                }
            }
        }
    }

    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>上面这段代码 for 循环和 if else 分支嵌套太多，导致层次太深，不利于阅读，需要耐心看一下。大家在看这段代码时，注意把几个重要的条件分支找出来。只要理解了这几个分支的意图，就可以弄懂这段代码。请注意上面代码中⭐️符号，这几个符号标识出了4个重要的分支，下面用伪代码解释一下这几个分支的含义。</p>
<pre><code class="language-java"><span class="hljs-comment">// 获取 ArgumentConfig 列表</span>
<span class="hljs-keyword">for</span> (遍历 ArgumentConfig 列表) {
    <span class="hljs-keyword">if</span> (type 不为 <span class="hljs-keyword">null</span>，也不为空串) {    <span class="hljs-comment">// 分支1</span>
        <span class="hljs-number">1</span>. 通过反射获取 interfaceClass 的方法列表
        <span class="hljs-keyword">for</span> (遍历方法列表) {
            <span class="hljs-number">1</span>. 比对方法名，查找目标方法
        	<span class="hljs-number">2</span>. 通过反射获取目标方法的参数类型数组 <span class="hljs-function">argtypes
            <span class="hljs-title">if</span> <span class="hljs-params">(index != <span class="hljs-number">-1</span>)</span> </span>{    <span class="hljs-comment">// 分支2</span>
                <span class="hljs-number">1</span>. 从 argtypes 数组中获取下标 index 处的元素 argType
                <span class="hljs-number">2</span>. 检测 argType 的名称与 ArgumentConfig 中的 type 属性是否一致
                <span class="hljs-number">3</span>. 添加 ArgumentConfig 字段信息到 map 中，或抛出异常
            } <span class="hljs-keyword">else</span> {    <span class="hljs-comment">// 分支3</span>
                <span class="hljs-number">1</span>. 遍历参数类型数组 argtypes，查找 argument.type 类型的参数
                <span class="hljs-number">2</span>. 添加 ArgumentConfig 字段信息到 map 中
            }
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index != -<span class="hljs-number">1</span>) {    <span class="hljs-comment">// 分支4</span>
		<span class="hljs-number">1</span>. 添加 ArgumentConfig 字段信息到 map 中
    }
}
</code></pre>
<p>在本节分析的源码中，appendParameters 这个方法出现的次数比较多，该方法用于将对象字段信息添加到 map 中。实现上则是通过反射获取目标对象的 getter 方法，并调用该方法获取属性值。然后再通过 getter 方法名解析出属性名，比如从方法名 getName 中可解析出属性 name。如果用户传入了属性名前缀，此时需要将属性名加入前缀内容。最后将 &lt;属性名，属性值&gt; 键值对存入到 map 中就行了。限于篇幅原因，这里就不分析 appendParameters 方法的源码了，大家请自行分析。</p>
<h3>2.2 导出 Dubbo 服务</h3>
<p>前置工作做完，接下来就可以进行服务导出了。服务导出分为导出到本地 (JVM)，和导出到远程。在深入分析服务导出的源码前，我们先来从宏观层面上看一下服务导出逻辑。如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doExportUrlsFor1Protocol</span><span class="hljs-params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>{
    
    <span class="hljs-comment">// 省略无关代码</span>
    
    <span class="hljs-keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)
            .hasExtension(url.getProtocol())) {
        <span class="hljs-comment">// 加载 ConfiguratorFactory，并生成 Configurator 实例，然后通过实例配置 url</span>
        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)
                .getExtension(url.getProtocol()).getConfigurator(url).configure(url);
    }

    String scope = url.getParameter(Constants.SCOPE_KEY);
    <span class="hljs-comment">// 如果 scope = none，则什么都不做</span>
    <span class="hljs-keyword">if</span> (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) {
        <span class="hljs-comment">// scope != remote，导出到本地</span>
        <span class="hljs-keyword">if</span> (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) {
            exportLocal(url);
        }

        <span class="hljs-comment">// scope != local，导出到远程</span>
        <span class="hljs-keyword">if</span> (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) {
            <span class="hljs-keyword">if</span> (registryURLs != <span class="hljs-keyword">null</span> &amp;&amp; !registryURLs.isEmpty()) {
                <span class="hljs-keyword">for</span> (URL registryURL : registryURLs) {
                    url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));
                    <span class="hljs-comment">// 加载监视器链接</span>
                    URL monitorUrl = loadMonitor(registryURL);
                    <span class="hljs-keyword">if</span> (monitorUrl != <span class="hljs-keyword">null</span>) {
                        <span class="hljs-comment">// 将监视器链接作为参数添加到 url 中</span>
                        url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());
                    }

                    String proxy = url.getParameter(Constants.PROXY_KEY);
                    <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(proxy)) {
                        registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy);
                    }

                    <span class="hljs-comment">// 为服务提供类(ref)生成 Invoker</span>
                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));
                    <span class="hljs-comment">// DelegateProviderMetaDataInvoker 用于持有 Invoker 和 ServiceConfig</span>
                    DelegateProviderMetaDataInvoker wrapperInvoker = <span class="hljs-keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="hljs-keyword">this</span>);

                    <span class="hljs-comment">// 导出服务，并生成 Exporter</span>
                    Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);
                    exporters.add(exporter);
                }
                
            <span class="hljs-comment">// 不存在注册中心，仅导出服务</span>
            } <span class="hljs-keyword">else</span> {
                Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);
                DelegateProviderMetaDataInvoker wrapperInvoker = <span class="hljs-keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="hljs-keyword">this</span>);

                Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);
                exporters.add(exporter);
            }
        }
    }
    <span class="hljs-keyword">this</span>.urls.add(url);
}
</code></pre>
<p>上面代码根据 url 中的 scope 参数决定服务导出方式，分别如下：</p>
<ul>
<li>scope = none，不导出服务</li>
<li>scope != remote，导出到本地</li>
<li>scope != local，导出到远程</li>
</ul>
<p>不管是导出到本地，还是远程。进行服务导出之前，均需要先创建 Invoker，这是一个很重要的步骤。因此下面先来分析 Invoker 的创建过程。</p>
<h3>2.2.1 Invoker 创建过程</h3>
<p>在 Dubbo 中，Invoker 是一个非常重要的模型。在服务提供端，以及服务引用端均会出现 Invoker。Dubbo 官方文档中对 Invoker 进行了说明，这里引用一下。</p>
<blockquote>
<p>Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</p>
</blockquote>
<p>既然 Invoker 如此重要，那么我们很有必要搞清楚 Invoker 的用途。Invoker 是由 ProxyFactory 创建而来，Dubbo 默认的 ProxyFactory 实现类是 JavassistProxyFactory。下面我们到 JavassistProxyFactory 代码中，探索 Invoker 的创建过程。如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">getInvoker</span><span class="hljs-params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>{
	<span class="hljs-comment">// 为目标类创建 Wrapper</span>
    <span class="hljs-keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="hljs-string">'$'</span>) &lt; <span class="hljs-number">0</span> ? proxy.getClass() : type);
    <span class="hljs-comment">// 创建匿名 Invoker 类对象，并实现 doInvoke 方法。</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doInvoke</span><span class="hljs-params">(T proxy, String methodName,
                                  Class&lt;?&gt;[] parameterTypes,
                                  Object[] arguments)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
			<span class="hljs-comment">// 调用 Wrapper 的 invokeMethod 方法，invokeMethod 最终会调用目标方法</span>
            <span class="hljs-keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
        }
    };
}
</code></pre>
<p>如上，JavassistProxyFactory 创建了一个继承自 AbstractProxyInvoker 类的匿名对象，并覆写了抽象方法 doInvoke。覆写后的 doInvoke 逻辑比较简单，仅是将调用请求转发给了 Wrapper 类的 invokeMethod 方法。Wrapper 用于“包裹”目标类，Wrapper 是一个抽象类，仅可通过 getWrapper(Class) 方法创建子类。在创建 Wrapper 子类的过程中，子类代码生成逻辑会对 getWrapper 方法传入的 Class 对象进行解析，拿到诸如类方法，类成员变量等信息。以及生成 invokeMethod 方法代码和其他一些方法代码。代码生成完毕后，通过 Javassist 生成 Class 对象，最后再通过反射创建 Wrapper 实例。相关的代码如下：</p>
<pre><code class="language-java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Wrapper <span class="hljs-title">getWrapper</span><span class="hljs-params">(Class&lt;?&gt; c)</span> </span>{	
    <span class="hljs-keyword">while</span> (ClassGenerator.isDynamicClass(c))
        c = c.getSuperclass();

    <span class="hljs-keyword">if</span> (c == Object.class)
        <span class="hljs-keyword">return</span> OBJECT_WRAPPER;

    <span class="hljs-comment">// 从缓存中获取 Wrapper 实例</span>
    Wrapper ret = WRAPPER_MAP.get(c);
    <span class="hljs-keyword">if</span> (ret == <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// 缓存未命中，创建 Wrapper</span>
        ret = makeWrapper(c);
        <span class="hljs-comment">// 写入缓存</span>
        WRAPPER_MAP.put(c, ret);
    }
    <span class="hljs-keyword">return</span> ret;
}
</code></pre>
<p>getWrapper 方法仅包含一些缓存操作逻辑，不难理解。下面我们看一下 makeWrapper 方法。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Wrapper <span class="hljs-title">makeWrapper</span><span class="hljs-params">(Class&lt;?&gt; c)</span> </span>{
    <span class="hljs-comment">// 检测 c 是否为基本类型，若是则抛出异常</span>
    <span class="hljs-keyword">if</span> (c.isPrimitive())
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Can not create wrapper for primitive type: "</span> + c);

    String name = c.getName();
    ClassLoader cl = ClassHelper.getClassLoader(c);

    <span class="hljs-comment">// c1 用于存储 setPropertyValue 方法代码</span>
    StringBuilder c1 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"public void setPropertyValue(Object o, String n, Object v){ "</span>);
    <span class="hljs-comment">// c2 用于存储 getPropertyValue 方法代码</span>
    StringBuilder c2 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"public Object getPropertyValue(Object o, String n){ "</span>);
    <span class="hljs-comment">// c3 用于存储 invokeMethod 方法代码</span>
    StringBuilder c3 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws "</span> + InvocationTargetException.class.getName() + <span class="hljs-string">"{ "</span>);

    <span class="hljs-comment">// 生成类型转换代码及异常捕捉代码，比如：</span>
    <span class="hljs-comment">//   DemoService w; try { w = ((DemoServcie) $1); }}catch(Throwable e){ throw new IllegalArgumentException(e); }</span>
    c1.append(name).append(<span class="hljs-string">" w; try{ w = (("</span>).append(name).append(<span class="hljs-string">")$1); }catch(Throwable e){ throw new IllegalArgumentException(e); }"</span>);
    c2.append(name).append(<span class="hljs-string">" w; try{ w = (("</span>).append(name).append(<span class="hljs-string">")$1); }catch(Throwable e){ throw new IllegalArgumentException(e); }"</span>);
    c3.append(name).append(<span class="hljs-string">" w; try{ w = (("</span>).append(name).append(<span class="hljs-string">")$1); }catch(Throwable e){ throw new IllegalArgumentException(e); }"</span>);

    <span class="hljs-comment">// pts 用于存储成员变量名和类型</span>
    Map&lt;String, Class&lt;?&gt;&gt; pts = <span class="hljs-keyword">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();
    <span class="hljs-comment">// ms 用于存储方法描述信息（可理解为方法签名）及 Method 实例</span>
    Map&lt;String, Method&gt; ms = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, Method&gt;();
    <span class="hljs-comment">// mns 为方法名列表</span>
    List&lt;String&gt; mns = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();
    <span class="hljs-comment">// dmns 用于存储“定义在当前类中的方法”的名称</span>
    List&lt;String&gt; dmns = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();

    <span class="hljs-comment">// --------------------------------✨ 分割线1 ✨-------------------------------------</span>

    <span class="hljs-comment">// 获取 public 访问级别的字段，并为所有字段生成条件判断语句</span>
    <span class="hljs-keyword">for</span> (Field f : c.getFields()) {
        String fn = f.getName();
        Class&lt;?&gt; ft = f.getType();
        <span class="hljs-keyword">if</span> (Modifier.isStatic(f.getModifiers()) || Modifier.isTransient(f.getModifiers()))
            <span class="hljs-comment">// 忽略关键字 static 或 transient 修饰的变量</span>
            <span class="hljs-keyword">continue</span>;

        <span class="hljs-comment">// 生成条件判断及赋值语句，比如：</span>
        <span class="hljs-comment">// if( $2.equals("name") ) { w.name = (java.lang.String) $3; return;}</span>
        <span class="hljs-comment">// if( $2.equals("age") ) { w.age = ((Number) $3).intValue(); return;}</span>
        c1.append(<span class="hljs-string">" if( $2.equals(\""</span>).append(fn).append(<span class="hljs-string">"\") ){ w."</span>).append(fn).append(<span class="hljs-string">"="</span>).append(arg(ft, <span class="hljs-string">"$3"</span>)).append(<span class="hljs-string">"; return; }"</span>);

        <span class="hljs-comment">// 生成条件判断及返回语句，比如：</span>
        <span class="hljs-comment">// if( $2.equals("name") ) { return ($w)w.name; }</span>
        c2.append(<span class="hljs-string">" if( $2.equals(\""</span>).append(fn).append(<span class="hljs-string">"\") ){ return ($w)w."</span>).append(fn).append(<span class="hljs-string">"; }"</span>);

        <span class="hljs-comment">// 存储 &lt;字段名, 字段类型&gt; 键值对到 pts 中</span>
        pts.put(fn, ft);
    }

    <span class="hljs-comment">// --------------------------------✨ 分割线2 ✨-------------------------------------</span>

    Method[] methods = c.getMethods();
    <span class="hljs-comment">// 检测 c 中是否包含在当前类中声明的方法</span>
    <span class="hljs-keyword">boolean</span> hasMethod = hasMethods(methods);
    <span class="hljs-keyword">if</span> (hasMethod) {
        c3.append(<span class="hljs-string">" try{"</span>);
    }
    <span class="hljs-keyword">for</span> (Method m : methods) {
        <span class="hljs-keyword">if</span> (m.getDeclaringClass() == Object.class)
            <span class="hljs-comment">// 忽略 Object 中定义的方法</span>
            <span class="hljs-keyword">continue</span>;

        String mn = m.getName();
        <span class="hljs-comment">// 生成方法名判断语句，比如：</span>
        <span class="hljs-comment">// if ( "sayHello".equals( $2 )</span>
        c3.append(<span class="hljs-string">" if( \""</span>).append(mn).append(<span class="hljs-string">"\".equals( $2 ) "</span>);
        <span class="hljs-keyword">int</span> len = m.getParameterTypes().length;
        <span class="hljs-comment">// 生成“运行时传入的参数数量与方法参数列表长度”判断语句，比如：</span>
        <span class="hljs-comment">// &amp;&amp; $3.length == 2</span>
        c3.append(<span class="hljs-string">" &amp;&amp; "</span>).append(<span class="hljs-string">" $3.length == "</span>).append(len);

        <span class="hljs-keyword">boolean</span> override = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">for</span> (Method m2 : methods) {
            <span class="hljs-comment">// 检测方法是否存在重载情况，条件为：方法对象不同 &amp;&amp; 方法名相同</span>
            <span class="hljs-keyword">if</span> (m != m2 &amp;&amp; m.getName().equals(m2.getName())) {
                override = <span class="hljs-keyword">true</span>;
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-comment">// 对重载方法进行处理，考虑下面的方法：</span>
        <span class="hljs-comment">//    1. void sayHello(Integer, String)</span>
        <span class="hljs-comment">//    2. void sayHello(Integer, Integer)</span>
        <span class="hljs-comment">// 方法名相同，参数列表长度也相同，因此不能仅通过这两项判断两个方法是否相等。</span>
        <span class="hljs-comment">// 需要进一步判断方法的参数类型</span>
        <span class="hljs-keyword">if</span> (override) {
            <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt; len; l++) {
                    <span class="hljs-comment">// 生成参数类型进行检测代码，比如：</span>
                    <span class="hljs-comment">// &amp;&amp; $3[0].getName().equals("java.lang.Integer") </span>
                    <span class="hljs-comment">//    &amp;&amp; $3[1].getName().equals("java.lang.String")</span>
                    c3.append(<span class="hljs-string">" &amp;&amp; "</span>).append(<span class="hljs-string">" $3["</span>).append(l).append(<span class="hljs-string">"].getName().equals(\""</span>)
                            .append(m.getParameterTypes()[l].getName()).append(<span class="hljs-string">"\")"</span>);
                }
            }
        }

        <span class="hljs-comment">// 添加 ) {，完成方法判断语句，此时生成的代码可能如下（已格式化）：</span>
        <span class="hljs-comment">// if ("sayHello".equals($2) </span>
        <span class="hljs-comment">//     &amp;&amp; $3.length == 2</span>
        <span class="hljs-comment">//     &amp;&amp; $3[0].getName().equals("java.lang.Integer") </span>
        <span class="hljs-comment">//     &amp;&amp; $3[1].getName().equals("java.lang.String")) {</span>
        c3.append(<span class="hljs-string">" ) { "</span>);

        <span class="hljs-comment">// 根据返回值类型生成目标方法调用语句</span>
        <span class="hljs-keyword">if</span> (m.getReturnType() == Void.TYPE)
            <span class="hljs-comment">// w.sayHello((java.lang.Integer)$4[0], (java.lang.String)$4[1]); return null;</span>
            c3.append(<span class="hljs-string">" w."</span>).append(mn).append(<span class="hljs-string">'('</span>).append(args(m.getParameterTypes(), <span class="hljs-string">"$4"</span>)).append(<span class="hljs-string">");"</span>).append(<span class="hljs-string">" return null;"</span>);
        <span class="hljs-keyword">else</span>
            <span class="hljs-comment">// return w.sayHello((java.lang.Integer)$4[0], (java.lang.String)$4[1]);</span>
            c3.append(<span class="hljs-string">" return ($w)w."</span>).append(mn).append(<span class="hljs-string">'('</span>).append(args(m.getParameterTypes(), <span class="hljs-string">"$4"</span>)).append(<span class="hljs-string">");"</span>);

        <span class="hljs-comment">// 添加 }, 生成的代码形如（已格式化）：</span>
        <span class="hljs-comment">// if ("sayHello".equals($2) </span>
        <span class="hljs-comment">//     &amp;&amp; $3.length == 2</span>
        <span class="hljs-comment">//     &amp;&amp; $3[0].getName().equals("java.lang.Integer") </span>
        <span class="hljs-comment">//     &amp;&amp; $3[1].getName().equals("java.lang.String")) {</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">//     w.sayHello((java.lang.Integer)$4[0], (java.lang.String)$4[1]); </span>
        <span class="hljs-comment">//     return null;</span>
        <span class="hljs-comment">// }</span>
        c3.append(<span class="hljs-string">" }"</span>);

        <span class="hljs-comment">// 添加方法名到 mns 集合中</span>
        mns.add(mn);
        <span class="hljs-comment">// 检测当前方法是否在 c 中被声明的</span>
        <span class="hljs-keyword">if</span> (m.getDeclaringClass() == c)
            <span class="hljs-comment">// 若是，则将当前方法名添加到 dmns 中</span>
            dmns.add(mn);
        ms.put(ReflectUtils.getDesc(m), m);
    }
    <span class="hljs-keyword">if</span> (hasMethod) {
        <span class="hljs-comment">// 添加异常捕捉语句</span>
        c3.append(<span class="hljs-string">" } catch(Throwable e) { "</span>);
        c3.append(<span class="hljs-string">"     throw new java.lang.reflect.InvocationTargetException(e); "</span>);
        c3.append(<span class="hljs-string">" }"</span>);
    }

    <span class="hljs-comment">// 添加 NoSuchMethodException 异常抛出代码</span>
    c3.append(<span class="hljs-string">" throw new "</span> + NoSuchMethodException.class.getName() + <span class="hljs-string">"(\"Not found method \\\"\"+$2+\"\\\" in class "</span> + c.getName() + <span class="hljs-string">".\"); }"</span>);

    <span class="hljs-comment">// --------------------------------✨ 分割线3 ✨-------------------------------------</span>

    Matcher matcher;
    <span class="hljs-comment">// 处理 get/set 方法</span>
    <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Method&gt; entry : ms.entrySet()) {
        String md = entry.getKey();
        Method method = (Method) entry.getValue();
        <span class="hljs-comment">// 匹配以 get 开头的方法</span>
        <span class="hljs-keyword">if</span> ((matcher = ReflectUtils.GETTER_METHOD_DESC_PATTERN.matcher(md)).matches()) {
            <span class="hljs-comment">// 获取属性名</span>
            String pn = propertyName(matcher.group(<span class="hljs-number">1</span>));
            <span class="hljs-comment">// 生成属性判断以及返回语句，示例如下：</span>
            <span class="hljs-comment">// if( $2.equals("name") ) { return ($w).w.getName(); }</span>
            c2.append(<span class="hljs-string">" if( $2.equals(\""</span>).append(pn).append(<span class="hljs-string">"\") ){ return ($w)w."</span>).append(method.getName()).append(<span class="hljs-string">"(); }"</span>);
            pts.put(pn, method.getReturnType());

        <span class="hljs-comment">// 匹配以 is/has/can 开头的方法</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((matcher = ReflectUtils.IS_HAS_CAN_METHOD_DESC_PATTERN.matcher(md)).matches()) {
            String pn = propertyName(matcher.group(<span class="hljs-number">1</span>));
            <span class="hljs-comment">// 生成属性判断以及返回语句，示例如下：</span>
            <span class="hljs-comment">// if( $2.equals("dream") ) { return ($w).w.hasDream(); }</span>
            c2.append(<span class="hljs-string">" if( $2.equals(\""</span>).append(pn).append(<span class="hljs-string">"\") ){ return ($w)w."</span>).append(method.getName()).append(<span class="hljs-string">"(); }"</span>);
            pts.put(pn, method.getReturnType());

        <span class="hljs-comment">// 匹配以 set 开头的方法</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((matcher = ReflectUtils.SETTER_METHOD_DESC_PATTERN.matcher(md)).matches()) {
            Class&lt;?&gt; pt = method.getParameterTypes()[<span class="hljs-number">0</span>];
            String pn = propertyName(matcher.group(<span class="hljs-number">1</span>));
            <span class="hljs-comment">// 生成属性判断以及 setter 调用语句，示例如下：</span>
            <span class="hljs-comment">// if( $2.equals("name") ) { w.setName((java.lang.String)$3); return; }</span>
            c1.append(<span class="hljs-string">" if( $2.equals(\""</span>).append(pn).append(<span class="hljs-string">"\") ){ w."</span>).append(method.getName()).append(<span class="hljs-string">"("</span>).append(arg(pt, <span class="hljs-string">"$3"</span>)).append(<span class="hljs-string">"); return; }"</span>);
            pts.put(pn, pt);
        }
    }

    <span class="hljs-comment">// 添加 NoSuchPropertyException 异常抛出代码</span>
    c1.append(<span class="hljs-string">" throw new "</span> + NoSuchPropertyException.class.getName() + <span class="hljs-string">"(\"Not found property \\\"\"+$2+\"\\\" filed or setter method in class "</span> + c.getName() + <span class="hljs-string">".\"); }"</span>);
    c2.append(<span class="hljs-string">" throw new "</span> + NoSuchPropertyException.class.getName() + <span class="hljs-string">"(\"Not found property \\\"\"+$2+\"\\\" filed or setter method in class "</span> + c.getName() + <span class="hljs-string">".\"); }"</span>);

    <span class="hljs-comment">// --------------------------------✨ 分割线4 ✨-------------------------------------</span>

    <span class="hljs-keyword">long</span> id = WRAPPER_CLASS_COUNTER.getAndIncrement();
    <span class="hljs-comment">// 创建类生成器</span>
    ClassGenerator cc = ClassGenerator.newInstance(cl);
    <span class="hljs-comment">// 设置类名及超类</span>
    cc.setClassName((Modifier.isPublic(c.getModifiers()) ? Wrapper.class.getName() : c.getName() + <span class="hljs-string">"$sw"</span>) + id);
    cc.setSuperClass(Wrapper.class);

    <span class="hljs-comment">// 添加默认构造方法</span>
    cc.addDefaultConstructor();

    <span class="hljs-comment">// 添加字段</span>
    cc.addField(<span class="hljs-string">"public static String[] pns;"</span>);
    cc.addField(<span class="hljs-string">"public static "</span> + Map.class.getName() + <span class="hljs-string">" pts;"</span>);
    cc.addField(<span class="hljs-string">"public static String[] mns;"</span>);
    cc.addField(<span class="hljs-string">"public static String[] dmns;"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, len = ms.size(); i &lt; len; i++)
        cc.addField(<span class="hljs-string">"public static Class[] mts"</span> + i + <span class="hljs-string">";"</span>);

    <span class="hljs-comment">// 添加方法代码</span>
    cc.addMethod(<span class="hljs-string">"public String[] getPropertyNames(){ return pns; }"</span>);
    cc.addMethod(<span class="hljs-string">"public boolean hasProperty(String n){ return pts.containsKey($1); }"</span>);
    cc.addMethod(<span class="hljs-string">"public Class getPropertyType(String n){ return (Class)pts.get($1); }"</span>);
    cc.addMethod(<span class="hljs-string">"public String[] getMethodNames(){ return mns; }"</span>);
    cc.addMethod(<span class="hljs-string">"public String[] getDeclaredMethodNames(){ return dmns; }"</span>);
    cc.addMethod(c1.toString());
    cc.addMethod(c2.toString());
    cc.addMethod(c3.toString());

    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 生成类</span>
        Class&lt;?&gt; wc = cc.toClass();
        
        <span class="hljs-comment">// 设置字段值</span>
        wc.getField(<span class="hljs-string">"pts"</span>).set(<span class="hljs-keyword">null</span>, pts);
        wc.getField(<span class="hljs-string">"pns"</span>).set(<span class="hljs-keyword">null</span>, pts.keySet().toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]));
        wc.getField(<span class="hljs-string">"mns"</span>).set(<span class="hljs-keyword">null</span>, mns.toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]));
        wc.getField(<span class="hljs-string">"dmns"</span>).set(<span class="hljs-keyword">null</span>, dmns.toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]));
        <span class="hljs-keyword">int</span> ix = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (Method m : ms.values())
            wc.getField(<span class="hljs-string">"mts"</span> + ix++).set(<span class="hljs-keyword">null</span>, m.getParameterTypes());

        <span class="hljs-comment">// 创建 Wrapper 实例</span>
        <span class="hljs-keyword">return</span> (Wrapper) wc.newInstance();
    } <span class="hljs-keyword">catch</span> (RuntimeException e) {
        <span class="hljs-keyword">throw</span> e;
    } <span class="hljs-keyword">catch</span> (Throwable e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e.getMessage(), e);
    } <span class="hljs-keyword">finally</span> {
        cc.release();
        ms.clear();
        mns.clear();
        dmns.clear();
    }
}
</code></pre>
<p>上面代码很长，大家耐心看一下。我们在上面代码中做了大量的注释，并按功能对代码进行了分块，以帮助大家理解代码逻辑。下面对这段代码进行讲解。首先我们把目光移到分割线1之上的代码，这段代码主要用于进行一些初始化操作。比如创建 c1、c2、c3 以及 pts、ms、mns 等变量，以及向  c1、c2、c3 中添加方法定义和类型转换代码。接下来是分割线1到分割线2之间的代码，这段代码用于为 public 级别的字段生成条件判断取值与赋值代码。这段代码不是很难看懂，就不多说了。继续向下看，分割线2和分隔线3之间的代码用于为定义在当前类中的方法生成判断语句，和方法调用语句。因为需要对方法重载进行校验，因此到这这段代码看起来有点复杂。不过耐心开一下，也不是很难理解。接下来是分割线3和分隔线4之间的代码，这段代码用于处理 getter、setter 以及以 is/has/can 开头的方法。处理方式是通过正则表达式获取方法类型（get/set/is/...），以及属性名。之后为属性名生成判断语句，然后为方法生成调用语句。最后我们再来看一下分隔线4以下的代码，这段代码通过 ClassGenerator 为刚刚生成的代码构建 Class 类，并通过反射创建对象。ClassGenerator 是 Dubbo 自己封装的，该类的核心是 toClass() 的重载方法 toClass(ClassLoader, ProtectionDomain)，该方法通过 javassist 构建 Class。这里就不分析 toClass 方法了，大家请自行分析。</p>
<p>阅读 Wrapper 类代码需要对 javassist 框架有所了解。关于 javassist，大家如果不熟悉，请自行查阅资料，本节不打算介绍 javassist 相关内容。</p>
<p>好了，关于 Wrapper 类生成过程就分析到这。如果大家看的不是很明白，可以单独为 Wrapper 创建单元测试，然后单步调试。并将生成的代码拷贝出来，格式化后再进行观察和理解。</p>
<h3>2.2.2 导出服务到本地</h3>
<p>本节我们来看一下服务导出相关的代码，按照代码执行顺序，本节先来分析导出服务到本地的过程。相关代码如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exportLocal</span><span class="hljs-params">(URL url)</span> </span>{
    <span class="hljs-comment">// 如果 URL 的协议头等于 injvm，说明已经导出到本地了，无需再次导出</span>
    <span class="hljs-keyword">if</span> (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {
        URL local = URL.valueOf(url.toFullString())
            .setProtocol(Constants.LOCAL_PROTOCOL)    <span class="hljs-comment">// 设置协议头为 injvm</span>
            .setHost(LOCALHOST)
            .setPort(<span class="hljs-number">0</span>);
        ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));
        <span class="hljs-comment">// 创建 Invoker，并导出服务，这里的 protocol 会在运行时调用 InjvmProtocol 的 export 方法</span>
        Exporter&lt;?&gt; exporter = protocol.export(
            proxyFactory.getInvoker(ref, (Class) interfaceClass, local));
        exporters.add(exporter);
    }
}
</code></pre>
<p>exportLocal 方法比较简单，首先根据 URL 协议头决定是否导出服务。若需导出，则创建一个新的 URL 并将协议头、主机名以及端口设置成新的值。然后创建 Invoker，并调用 InjvmProtocol 的 export 方法导出服务。下面我们来看一下 InjvmProtocol 的 export 方法都做了哪些事情。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Exporter&lt;T&gt; <span class="hljs-title">export</span><span class="hljs-params">(Invoker&lt;T&gt; invoker)</span> <span class="hljs-keyword">throws</span> RpcException </span>{
    <span class="hljs-comment">// 创建 InjvmExporter</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);
}
</code></pre>
<p>如上，InjvmProtocol 的 export 方法仅创建了一个 InjvmExporter，无其他逻辑。到此导出服务到本地就分析完了，接下来，我们继续分析导出服务到远程的过程。</p>
<h3>2.2.3 导出服务到远程</h3>
<p>与导出服务到本地相比，导出服务到远程的过程要复杂不少，其包含了服务导出与服务注册两个过程。这两个过程涉及到了大量的调用，比较复杂。按照代码执行顺序，本节先来分析服务导出逻辑，服务注册逻辑将在下一节进行分析。下面开始分析，我们把目光移动到 RegistryProtocol 的 export 方法上。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Exporter&lt;T&gt; <span class="hljs-title">export</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="hljs-keyword">throws</span> RpcException </span>{
    <span class="hljs-comment">// 导出服务</span>
    <span class="hljs-keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);

    <span class="hljs-comment">// 获取注册中心 URL，以 zookeeper 注册中心为例，得到的示例 URL 如下：</span>
    <span class="hljs-comment">// zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;dubbo=2.0.2&amp;export=dubbo%3A%2F%2F172.17.48.52%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider</span>
    URL registryUrl = getRegistryUrl(originInvoker);

    <span class="hljs-comment">// 根据 URL 加载 Registry 实现类，比如 ZookeeperRegistry</span>
    <span class="hljs-keyword">final</span> Registry registry = getRegistry(originInvoker);
    
    <span class="hljs-comment">// 获取已注册的服务提供者 URL，比如：</span>
    <span class="hljs-comment">// dubbo://172.17.48.52:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.2&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello</span>
    <span class="hljs-keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(originInvoker);

    <span class="hljs-comment">// 获取 register 参数</span>
    <span class="hljs-keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="hljs-string">"register"</span>, <span class="hljs-keyword">true</span>);

    <span class="hljs-comment">// 向服务提供者与消费者注册表中注册服务提供者</span>
    ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);

    <span class="hljs-comment">// 根据 register 的值决定是否注册服务</span>
    <span class="hljs-keyword">if</span> (register) {
        <span class="hljs-comment">// 向注册中心注册服务</span>
        register(registryUrl, registeredProviderUrl);
        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(<span class="hljs-keyword">true</span>);
    }

    <span class="hljs-comment">// 获取订阅 URL，比如：</span>
    <span class="hljs-comment">// provider://172.17.48.52:20880/com.alibaba.dubbo.demo.DemoService?category=configurators&amp;check=false&amp;anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.2&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello</span>
    <span class="hljs-keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);
    <span class="hljs-comment">// 创建监听器</span>
    <span class="hljs-keyword">final</span> OverrideListener overrideSubscribeListener = <span class="hljs-keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);
    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);
    <span class="hljs-comment">// 向注册中心进行订阅 override 数据</span>
    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);
    <span class="hljs-comment">// 创建并返回 DestroyableExporter</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DestroyableExporter&lt;T&gt;(exporter, originInvoker, overrideSubscribeUrl, registeredProviderUrl);
}
</code></pre>
<p>上面代码看起来比较复杂，主要做如下一些操作：</p>
<ol>
<li>调用 doLocalExport 导出服务</li>
<li>向注册中心注册服务</li>
<li>向注册中心进行订阅 override 数据</li>
<li>创建并返回 DestroyableExporter</li>
</ol>
<p>在以上操作中，除了创建并返回 DestroyableExporter 没什么难度外，其他几步操作都不是很简单。这其中，导出服务和注册服务是本章要重点分析的逻辑。 订阅 override 数据并非本文重点内容，后面会简单介绍一下。下面先来分析 doLocalExport 方法的逻辑，如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">ExporterChangeableWrapper&lt;T&gt; <span class="hljs-title">doLocalExport</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> </span>{
    String key = getCacheKey(originInvoker);
    <span class="hljs-comment">// 访问缓存</span>
    ExporterChangeableWrapper&lt;T&gt; exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);
    <span class="hljs-keyword">if</span> (exporter == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">synchronized</span> (bounds) {
            exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);
            <span class="hljs-keyword">if</span> (exporter == <span class="hljs-keyword">null</span>) {
                <span class="hljs-comment">// 创建 Invoker 为委托类对象</span>
                <span class="hljs-keyword">final</span> Invoker&lt;?&gt; invokerDelegete = <span class="hljs-keyword">new</span> InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));
                <span class="hljs-comment">// 调用 protocol 的 export 方法导出服务</span>
                exporter = <span class="hljs-keyword">new</span> ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegete), originInvoker);
                
                <span class="hljs-comment">// 写缓存</span>
                bounds.put(key, exporter);
            }
        }
    }
    <span class="hljs-keyword">return</span> exporter;
}
</code></pre>
<p>上面的代码是典型的双重检查锁，大家在阅读 Dubbo 的源码中，会多次见到。接下来，我们把重点放在 Protocol 的 export 方法上。假设运行时协议为 dubbo，此处的 protocol 变量会在运行时加载 DubboProtocol，并调用 DubboProtocol 的 export 方法。所以，接下来我们目光转移到 DubboProtocol 的 export 方法上，相关分析如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Exporter&lt;T&gt; <span class="hljs-title">export</span><span class="hljs-params">(Invoker&lt;T&gt; invoker)</span> <span class="hljs-keyword">throws</span> RpcException </span>{
    URL url = invoker.getUrl();

    <span class="hljs-comment">// 获取服务标识，理解成服务坐标也行。由服务组名，服务名，服务版本号以及端口组成。比如：</span>
    <span class="hljs-comment">// demoGroup/com.alibaba.dubbo.demo.DemoService:1.0.1:20880</span>
    String key = serviceKey(url);
    <span class="hljs-comment">// 创建 DubboExporter</span>
    DubboExporter&lt;T&gt; exporter = <span class="hljs-keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);
    <span class="hljs-comment">// 将 &lt;key, exporter&gt; 键值对放入缓存中</span>
    exporterMap.put(key, exporter);

    <span class="hljs-comment">// 本地存根相关代码</span>
    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);
    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) {
        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);
        <span class="hljs-keyword">if</span> (stubServiceMethods == <span class="hljs-keyword">null</span> || stubServiceMethods.length() == <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// 省略日志打印代码</span>
        } <span class="hljs-keyword">else</span> {
            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);
        }
    }

    <span class="hljs-comment">// 启动服务器</span>
    openServer(url);
    <span class="hljs-comment">// 优化序列化</span>
    optimizeSerialization(url);
    <span class="hljs-keyword">return</span> exporter;
}
</code></pre>
<p>如上，我们重点关注 DubboExporter 的创建以及 openServer 方法，其他逻辑看不懂也没关系，不影响理解服务导出过程。另外，DubboExporter 的代码比较简单，就不分析了。下面分析 openServer 方法。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openServer</span><span class="hljs-params">(URL url)</span> </span>{
    <span class="hljs-comment">// 获取 host:port，并将其作为服务器实例的 key，用于标识当前的服务器实例</span>
    String key = url.getAddress();
    <span class="hljs-keyword">boolean</span> isServer = url.getParameter(Constants.IS_SERVER_KEY, <span class="hljs-keyword">true</span>);
    <span class="hljs-keyword">if</span> (isServer) {
        <span class="hljs-comment">// 访问缓存</span>
        ExchangeServer server = serverMap.get(key);
        <span class="hljs-keyword">if</span> (server == <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// 创建服务器实例</span>
            serverMap.put(key, createServer(url));
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 服务器已创建，则根据 url 中的配置重置服务器</span>
            server.reset(url);
        }
    }
}
</code></pre>
<p>如上，在同一台机器上（单网卡），同一个端口上仅允许启动一个服务器实例。若某个端口上已有服务器实例，此时则调用 reset 方法重置服务器的一些配置。考虑到篇幅问题，关于服务器实例重置的代码就不分析了。接下来分析服务器实例的创建过程。如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">private</span> ExchangeServer <span class="hljs-title">createServer</span><span class="hljs-params">(URL url)</span> </span>{
    url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY,
    <span class="hljs-comment">// 添加心跳检测配置到 url 中</span>
    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));
	<span class="hljs-comment">// 获取 server 参数，默认为 netty</span>
    String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);

	<span class="hljs-comment">// 通过 SPI 检测是否存在 server 参数所代表的 Transporter 拓展，不存在则抛出异常</span>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-keyword">null</span> &amp;&amp; str.length() &gt; <span class="hljs-number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str))
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">"Unsupported server type: "</span> + str + <span class="hljs-string">", url: "</span> + url);

    <span class="hljs-comment">// 添加编码解码器参数</span>
    url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);
    ExchangeServer server;
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 创建 ExchangeServer</span>
        server = Exchangers.bind(url, requestHandler);
    } <span class="hljs-keyword">catch</span> (RemotingException e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">"Fail to start server..."</span>);
    }
                                   
	<span class="hljs-comment">// 获取 client 参数，可指定 netty，mina</span>
    str = url.getParameter(Constants.CLIENT_KEY);
    <span class="hljs-keyword">if</span> (str != <span class="hljs-keyword">null</span> &amp;&amp; str.length() &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 获取所有的 Transporter 实现类名称集合，比如 supportedTypes = [netty, mina]</span>
        Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();
        <span class="hljs-comment">// 检测当前 Dubbo 所支持的 Transporter 实现类名称列表中，</span>
        <span class="hljs-comment">// 是否包含 client 所表示的 Transporter，若不包含，则抛出异常</span>
        <span class="hljs-keyword">if</span> (!supportedTypes.contains(str)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">"Unsupported client type..."</span>);
        }
    }
    <span class="hljs-keyword">return</span> server;
}
</code></pre>
<p>如上，createServer 包含三个核心的逻辑。第一是检测是否存在 server 参数所代表的 Transporter 拓展，不存在则抛出异常。第二是创建服务器实例。第三是检测是否支持 client 参数所表示的 Transporter 拓展，不存在也是抛出异常。两次检测操作所对应的代码比较直白了，无需多说。但创建服务器的操作目前还不是很清晰，我们继续往下看。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExchangeServer <span class="hljs-title">bind</span><span class="hljs-params">(URL url, ExchangeHandler handler)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
    <span class="hljs-keyword">if</span> (url == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"url == null"</span>);
    }
    <span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"handler == null"</span>);
    }
    url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="hljs-string">"exchange"</span>);
    <span class="hljs-comment">// 获取 Exchanger，默认为 HeaderExchanger。</span>
    <span class="hljs-comment">// 紧接着调用 HeaderExchanger 的 bind 方法创建 ExchangeServer 实例</span>
    <span class="hljs-keyword">return</span> getExchanger(url).bind(url, handler);
}
</code></pre>
<p>上面代码比较简单，就不多说了。下面看一下 HeaderExchanger 的 bind 方法。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> ExchangeServer <span class="hljs-title">bind</span><span class="hljs-params">(URL url, ExchangeHandler handler)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
	<span class="hljs-comment">// 创建 HeaderExchangeServer 实例，该方法包含了多个逻辑，分别如下：</span>
	<span class="hljs-comment">//   1. new HeaderExchangeHandler(handler)</span>
	<span class="hljs-comment">//	 2. new DecodeHandler(new HeaderExchangeHandler(handler))</span>
	<span class="hljs-comment">//   3. Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler)))</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="hljs-keyword">new</span> DecodeHandler(<span class="hljs-keyword">new</span> HeaderExchangeHandler(handler))));
}
</code></pre>
<p>HeaderExchanger 的 bind 方法包含的逻辑比较多，但目前我们仅需关心 Transporters 的 bind 方法逻辑即可。该方法的代码如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Server <span class="hljs-title">bind</span><span class="hljs-params">(URL url, ChannelHandler... handlers)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
    <span class="hljs-keyword">if</span> (url == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"url == null"</span>);
    }
    <span class="hljs-keyword">if</span> (handlers == <span class="hljs-keyword">null</span> || handlers.length == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"handlers == null"</span>);
    }
    ChannelHandler handler;
    <span class="hljs-keyword">if</span> (handlers.length == <span class="hljs-number">1</span>) {
        handler = handlers[<span class="hljs-number">0</span>];
    } <span class="hljs-keyword">else</span> {
    	<span class="hljs-comment">// 如果 handlers 元素数量大于1，则创建 ChannelHandler 分发器</span>
        handler = <span class="hljs-keyword">new</span> ChannelHandlerDispatcher(handlers);
    }
    <span class="hljs-comment">// 获取自适应 Transporter 实例，并调用实例方法</span>
    <span class="hljs-keyword">return</span> getTransporter().bind(url, handler);
}
</code></pre>
<p>如上，getTransporter() 方法获取的 Transporter 是在运行时动态创建的，类名为 TransporterAdaptive，也就是自适应拓展类。TransporterAdaptive 会在运行时根据传入的 URL 参数决定加载什么类型的 Transporter，默认为 NettyTransporter。下面我们继续跟下去，这次分析的是 NettyTransporter 的 bind 方法。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> Server <span class="hljs-title">bind</span><span class="hljs-params">(URL url, ChannelHandler listener)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
	<span class="hljs-comment">// 创建 NettyServer</span>
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NettyServer(url, listener);
}
</code></pre>
<p>这里仅有一句创建 NettyServer 的代码，无需多说，我们继续向下看。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Server</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NettyServer</span><span class="hljs-params">(URL url, ChannelHandler handler)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        <span class="hljs-comment">// 调用父类构造方法</span>
        <span class="hljs-keyword">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));
    }
}


<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractServer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractEndpoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Server</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractServer</span><span class="hljs-params">(URL url, ChannelHandler handler)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        <span class="hljs-comment">// 调用父类构造方法，这里就不用跟进去了，没什么复杂逻辑</span>
        <span class="hljs-keyword">super</span>(url, handler);
        localAddress = getUrl().toInetSocketAddress();

        <span class="hljs-comment">// 获取 ip 和端口</span>
        String bindIp = getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());
        <span class="hljs-keyword">int</span> bindPort = getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());
        <span class="hljs-keyword">if</span> (url.getParameter(Constants.ANYHOST_KEY, <span class="hljs-keyword">false</span>) || NetUtils.isInvalidLocalHost(bindIp)) {
            <span class="hljs-comment">// 设置 ip 为 0.0.0.0</span>
            bindIp = NetUtils.ANYHOST;
        }
        bindAddress = <span class="hljs-keyword">new</span> InetSocketAddress(bindIp, bindPort);
        <span class="hljs-comment">// 获取最大可接受连接数</span>
        <span class="hljs-keyword">this</span>.accepts = url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS);
        <span class="hljs-keyword">this</span>.idleTimeout = url.getParameter(Constants.IDLE_TIMEOUT_KEY, Constants.DEFAULT_IDLE_TIMEOUT);
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 调用模板方法 doOpen 启动服务器</span>
            doOpen();
        } <span class="hljs-keyword">catch</span> (Throwable t) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RemotingException(<span class="hljs-string">"Failed to bind "</span>);
        }

        DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension();
        executor = (ExecutorService) dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY, Integer.toString(url.getPort()));
    }
    
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doOpen</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable</span>;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doClose</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable</span>;
}
</code></pre>
<p>上面代码多为赋值代码，不需要多讲。我们重点关注 doOpen 抽象方法，该方法需要子类实现。下面回到 NettyServer 中。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doOpen</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    NettyHelper.setNettyLoggerFactory();
    <span class="hljs-comment">// 创建 boss 和 worker 线程池</span>
    ExecutorService boss = Executors.newCachedThreadPool(<span class="hljs-keyword">new</span> NamedThreadFactory(<span class="hljs-string">"NettyServerBoss"</span>, <span class="hljs-keyword">true</span>));
    ExecutorService worker = Executors.newCachedThreadPool(<span class="hljs-keyword">new</span> NamedThreadFactory(<span class="hljs-string">"NettyServerWorker"</span>, <span class="hljs-keyword">true</span>));
    ChannelFactory channelFactory = <span class="hljs-keyword">new</span> NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));
    
    <span class="hljs-comment">// 创建 ServerBootstrap</span>
    bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap(channelFactory);

    <span class="hljs-keyword">final</span> NettyHandler nettyHandler = <span class="hljs-keyword">new</span> NettyHandler(getUrl(), <span class="hljs-keyword">this</span>);
    channels = nettyHandler.getChannels();
    bootstrap.setOption(<span class="hljs-string">"child.tcpNoDelay"</span>, <span class="hljs-keyword">true</span>);
    <span class="hljs-comment">// 设置 PipelineFactory</span>
    bootstrap.setPipelineFactory(<span class="hljs-keyword">new</span> ChannelPipelineFactory() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> ChannelPipeline <span class="hljs-title">getPipeline</span><span class="hljs-params">()</span> </span>{
            NettyCodecAdapter adapter = <span class="hljs-keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="hljs-keyword">this</span>);
            ChannelPipeline pipeline = Channels.pipeline();
            pipeline.addLast(<span class="hljs-string">"decoder"</span>, adapter.getDecoder());
            pipeline.addLast(<span class="hljs-string">"encoder"</span>, adapter.getEncoder());
            pipeline.addLast(<span class="hljs-string">"handler"</span>, nettyHandler);
            <span class="hljs-keyword">return</span> pipeline;
        }
    });
    <span class="hljs-comment">// 绑定到指定的 ip 和端口上</span>
    channel = bootstrap.bind(getBindAddress());
}
</code></pre>
<p>以上就是 NettyServer 创建的过程，dubbo 默认使用的 NettyServer 是基于 netty 3.x 版本实现的，比较老了。因此 Dubbo 另外提供了 netty 4.x 版本的 NettyServer，大家可在使用 Dubbo 的过程中按需进行配置。</p>
<p>到此，关于服务导出的过程就分析完了。整个过程比较复杂，大家在分析的过程中耐心一些。并且多写 Demo 进行进行调试，以便能够更好的理解代码逻辑。</p>
<p>本节内容先到这里，接下来分析服务导出的另一块逻辑 — 服务注册。</p>
<h3>2.2.4 服务注册</h3>
<p>本节我们来分析服务注册过程，服务注册操作对于 Dubbo 来说不是必需的，通过服务直连的方式就可以绕过注册中心。但通常我们不会这么做，直连方式不利于服务治理，仅推荐在测试服务时使用。对于 Dubbo 来说，注册中心虽不是必需，但却是必要的。因此，关于注册中心以及服务注册相关逻辑，我们也需要搞懂。</p>
<p>本节内容以 Zookeeper 注册中心作为分析目标，其他类型注册中心大家可自行分析。下面从服务注册的入口方法开始分析，我们把目光再次移到 RegistryProtocol 的 export 方法上。如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Exporter&lt;T&gt; <span class="hljs-title">export</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="hljs-keyword">throws</span> RpcException </span>{
    
    <span class="hljs-comment">// ${导出服务}</span>
    
    <span class="hljs-comment">// 省略其他代码</span>
    
    <span class="hljs-keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="hljs-string">"register"</span>, <span class="hljs-keyword">true</span>);
    <span class="hljs-keyword">if</span> (register) {
        <span class="hljs-comment">// 注册服务</span>
        register(registryUrl, registeredProviderUrl);
        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(<span class="hljs-keyword">true</span>);
    }
    
    <span class="hljs-keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);
    <span class="hljs-keyword">final</span> OverrideListener overrideSubscribeListener = <span class="hljs-keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);
    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);
    <span class="hljs-comment">// 订阅 override 数据</span>
    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);

    <span class="hljs-comment">// 省略部分代码</span>
}
</code></pre>
<p>RegistryProtocol 的 export 方法包含了服务导出，注册，以及数据订阅等逻辑。其中服务导出逻辑上一节已经分析过了，本节将分析服务注册逻辑，相关代码如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(URL registryUrl, URL registedProviderUrl)</span> </span>{
    <span class="hljs-comment">// 获取 Registry</span>
    Registry registry = registryFactory.getRegistry(registryUrl);
    <span class="hljs-comment">// 注册服务</span>
    registry.register(registedProviderUrl);
}
</code></pre>
<p>register 方法包含两步操作，第一步是获取注册中心实例，第二步是向注册中心注册服务。接下来分两节内容对这两步操作进行分析。</p>
<h4>2.2.4.1 创建注册中心</h4>
<p>本节内容以 Zookeeper 注册中心为例进行分析。下面先来看一下 getRegistry 方法的源码，这个方法由 AbstractRegistryFactory 实现。如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> Registry <span class="hljs-title">getRegistry</span><span class="hljs-params">(URL url)</span> </span>{
    url = url.setPath(RegistryService.class.getName())
            .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())
            .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY);
    String key = url.toServiceString();
    LOCK.lock();
    <span class="hljs-keyword">try</span> {
    	<span class="hljs-comment">// 访问缓存</span>
        Registry registry = REGISTRIES.get(key);
        <span class="hljs-keyword">if</span> (registry != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> registry;
        }
        
        <span class="hljs-comment">// 缓存未命中，创建 Registry 实例</span>
        registry = createRegistry(url);
        <span class="hljs-keyword">if</span> (registry == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Can not create registry..."</span>);
        }
        
        <span class="hljs-comment">// 写入缓存</span>
        REGISTRIES.put(key, registry);
        <span class="hljs-keyword">return</span> registry;
    } <span class="hljs-keyword">finally</span> {
        LOCK.unlock();
    }
}

<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Registry <span class="hljs-title">createRegistry</span><span class="hljs-params">(URL url)</span></span>;
</code></pre>
<p>如上，getRegistry 方法先访问缓存，缓存未命中则调用 createRegistry 创建 Registry，然后写入缓存。这里的 createRegistry 是一个模板方法，由具体的子类实现。因此，下面我们到 ZookeeperRegistryFactory 中探究一番。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZookeeperRegistryFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractRegistryFactory</span> </span>{

    <span class="hljs-comment">// zookeeperTransporter 由 SPI 在运行时注入，类型为 ZookeeperTransporter$Adaptive</span>
    <span class="hljs-keyword">private</span> ZookeeperTransporter zookeeperTransporter;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setZookeeperTransporter</span><span class="hljs-params">(ZookeeperTransporter zookeeperTransporter)</span> </span>{
        <span class="hljs-keyword">this</span>.zookeeperTransporter = zookeeperTransporter;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Registry <span class="hljs-title">createRegistry</span><span class="hljs-params">(URL url)</span> </span>{
        <span class="hljs-comment">// 创建 ZookeeperRegistry</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ZookeeperRegistry(url, zookeeperTransporter);
    }
}
</code></pre>
<p>ZookeeperRegistryFactory 的 createRegistry 方法仅包含一句代码，无需解释，继续跟下去。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ZookeeperRegistry</span><span class="hljs-params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>{
    <span class="hljs-keyword">super</span>(url);
    <span class="hljs-keyword">if</span> (url.isAnyHost()) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"registry address == null"</span>);
    }
    
    <span class="hljs-comment">// 获取组名，默认为 dubbo</span>
    String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);
    <span class="hljs-keyword">if</span> (!group.startsWith(Constants.PATH_SEPARATOR)) {
        <span class="hljs-comment">// group = "/" + group</span>
        group = Constants.PATH_SEPARATOR + group;
    }
    <span class="hljs-keyword">this</span>.root = group;
    <span class="hljs-comment">// 创建 Zookeeper 客户端，默认为 CuratorZookeeperTransporter</span>
    zkClient = zookeeperTransporter.connect(url);
    <span class="hljs-comment">// 添加状态监听器</span>
    zkClient.addStateListener(<span class="hljs-keyword">new</span> StateListener() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateChanged</span><span class="hljs-params">(<span class="hljs-keyword">int</span> state)</span> </span>{
            <span class="hljs-keyword">if</span> (state == RECONNECTED) {
                <span class="hljs-keyword">try</span> {
                    recover();
                } <span class="hljs-keyword">catch</span> (Exception e) {
                    logger.error(e.getMessage(), e);
                }
            }
        }
    });
}
</code></pre>
<p>在上面的代码代码中，我们重点关注 ZookeeperTransporter 的 connect 方法调用，这个方法用于创建 Zookeeper 客户端。创建好 Zookeeper 客户端，意味着注册中心的创建过程就结束了。接下来，再来分析一下 Zookeeper 客户端的创建过程。</p>
<p>前面说过，这里的 zookeeperTransporter 类型为自适应拓展类，因此 connect 方法会在被调用时决定加载什么类型的 ZookeeperTransporter 拓展，默认为 CuratorZookeeperTransporter。下面我们到 CuratorZookeeperTransporter 中看一看。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> ZookeeperClient <span class="hljs-title">connect</span><span class="hljs-params">(URL url)</span> </span>{
    <span class="hljs-comment">// 创建 CuratorZookeeperClient</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CuratorZookeeperClient(url);
}
</code></pre>
<p>继续向下看。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CuratorZookeeperClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractZookeeperClient</span>&lt;<span class="hljs-title">CuratorWatcher</span>&gt; </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CuratorFramework client;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CuratorZookeeperClient</span><span class="hljs-params">(URL url)</span> </span>{
        <span class="hljs-keyword">super</span>(url);
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 创建 CuratorFramework 构造器</span>
            CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()
                    .connectString(url.getBackupAddress())
                    .retryPolicy(<span class="hljs-keyword">new</span> RetryNTimes(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>))
                    .connectionTimeoutMs(<span class="hljs-number">5000</span>);
            String authority = url.getAuthority();
            <span class="hljs-keyword">if</span> (authority != <span class="hljs-keyword">null</span> &amp;&amp; authority.length() &gt; <span class="hljs-number">0</span>) {
                builder = builder.authorization(<span class="hljs-string">"digest"</span>, authority.getBytes());
            }
            <span class="hljs-comment">// 构建 CuratorFramework 实例</span>
            client = builder.build();
            <span class="hljs-comment">// 添加监听器</span>
            client.getConnectionStateListenable().addListener(<span class="hljs-keyword">new</span> ConnectionStateListener() {
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateChanged</span><span class="hljs-params">(CuratorFramework client, ConnectionState state)</span> </span>{
                    <span class="hljs-keyword">if</span> (state == ConnectionState.LOST) {
                        CuratorZookeeperClient.<span class="hljs-keyword">this</span>.stateChanged(StateListener.DISCONNECTED);
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == ConnectionState.CONNECTED) {
                        CuratorZookeeperClient.<span class="hljs-keyword">this</span>.stateChanged(StateListener.CONNECTED);
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == ConnectionState.RECONNECTED) {
                        CuratorZookeeperClient.<span class="hljs-keyword">this</span>.stateChanged(StateListener.RECONNECTED);
                    }
                }
            });
            
            <span class="hljs-comment">// 启动客户端</span>
            client.start();
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(e.getMessage(), e);
        }
    }
}
</code></pre>
<p>CuratorZookeeperClient 构造方法主要用于创建和启动 CuratorFramework 实例。以上基本上都是 Curator 框架的代码，大家如果对 Curator 框架不是很了解，可以参考 Curator 官方文档。</p>
<p>本节分析了 ZookeeperRegistry 实例的创建过程，整个过程并不是很复杂。大家在看完分析后，可以自行调试，以加深理解。现在注册中心实例创建好了，接下来要做的事情是向注册中心注册服务，我们继续往下看。</p>
<h4>2.2.4.2 节点创建</h4>
<p>以 Zookeeper 为例，所谓的服务注册，本质上是将服务配置数据写入到 Zookeeper 的某个路径的节点下。为了让大家有一个直观的了解，下面我们将 Dubbo 的 demo 跑起来，然后通过 Zookeeper 可视化客户端 <a href="https://github.com/apache/zookeeper/tree/b79af153d0f98a4f3f3516910ed47234d7b3d74e/src/contrib/zooinspector">ZooInspector</a> 查看节点数据。如下：</p>
<p><img src="./sources/images/service-registry.png" alt=""></p>
<p>从上图中可以看到 com.alibaba.dubbo.demo.DemoService 这个服务对应的配置信息（存储在 URL 中）最终被注册到了 /dubbo/com.alibaba.dubbo.demo.DemoService/providers/ 节点下。搞懂了服务注册的本质，那么接下来我们就可以去阅读服务注册的代码了。服务注册的接口为 register(URL)，这个方法定义在 FailbackRegistry 抽象类中。代码如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(URL url)</span> </span>{
    <span class="hljs-keyword">super</span>.register(url);
    failedRegistered.remove(url);
    failedUnregistered.remove(url);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 模板方法，由子类实现</span>
        doRegister(url);
    } <span class="hljs-keyword">catch</span> (Exception e) {
        Throwable t = e;

        <span class="hljs-comment">// 获取 check 参数，若 check = true 将会直接抛出异常</span>
        <span class="hljs-keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="hljs-keyword">true</span>)
                &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="hljs-keyword">true</span>)
                &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());
        <span class="hljs-keyword">boolean</span> skipFailback = t <span class="hljs-keyword">instanceof</span> SkipFailbackWrapperException;
        <span class="hljs-keyword">if</span> (check || skipFailback) {
            <span class="hljs-keyword">if</span> (skipFailback) {
                t = t.getCause();
            }
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Failed to register"</span>);
        } <span class="hljs-keyword">else</span> {
            logger.error(<span class="hljs-string">"Failed to register"</span>);
        }

        <span class="hljs-comment">// 记录注册失败的链接</span>
        failedRegistered.add(url);
    }
}

<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">(URL url)</span></span>;
</code></pre>
<p>如上，我们重点关注 doRegister 方法调用即可，其他的代码先忽略。doRegister 方法是一个模板方法，因此我们到 FailbackRegistry 子类 ZookeeperRegistry 中进行分析。如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">(URL url)</span> </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 通过 Zookeeper 客户端创建节点，节点路径由 toUrlPath 方法生成，路径格式如下:</span>
        <span class="hljs-comment">//   /${group}/${serviceInterface}/providers/${url}</span>
        <span class="hljs-comment">// 比如</span>
        <span class="hljs-comment">//   /dubbo/org.apache.dubbo.DemoService/providers/dubbo%3A%2F%2F127.0.0.1......</span>
        zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, <span class="hljs-keyword">true</span>));
    } <span class="hljs-keyword">catch</span> (Throwable e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">"Failed to register..."</span>);
    }
}
</code></pre>
<p>如上，ZookeeperRegistry 在 doRegister 中调用了 Zookeeper 客户端创建服务节点。节点路径由 toUrlPath 方法生成，该方法逻辑不难理解，就不分析了。接下来分析 create 方法，如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(String path, <span class="hljs-keyword">boolean</span> ephemeral)</span> </span>{
    <span class="hljs-keyword">if</span> (!ephemeral) {
        <span class="hljs-comment">// 如果要创建的节点类型非临时节点，那么这里要检测节点是否存在</span>
        <span class="hljs-keyword">if</span> (checkExists(path)) {
            <span class="hljs-keyword">return</span>;
        }
    }
    <span class="hljs-keyword">int</span> i = path.lastIndexOf(<span class="hljs-string">'/'</span>);
    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 递归创建上一级路径</span>
        create(path.substring(<span class="hljs-number">0</span>, i), <span class="hljs-keyword">false</span>);
    }
    
    <span class="hljs-comment">// 根据 ephemeral 的值创建临时或持久节点</span>
    <span class="hljs-keyword">if</span> (ephemeral) {
        createEphemeral(path);
    } <span class="hljs-keyword">else</span> {
        createPersistent(path);
    }
}
</code></pre>
<p>上面方法先是通过递归创建当前节点的上一级路径，然后再根据 ephemeral 的值决定创建临时还是持久节点。createEphemeral 和 createPersistent 这两个方法都比较简单，这里简单分析其中的一个。如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createEphemeral</span><span class="hljs-params">(String path)</span> </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 通过 Curator 框架创建节点</span>
        client.create().withMode(CreateMode.EPHEMERAL).forPath(path);
    } <span class="hljs-keyword">catch</span> (NodeExistsException e) {
    } <span class="hljs-keyword">catch</span> (Exception e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(e.getMessage(), e);
    }
}
</code></pre>
<p>好了，到此关于服务注册的过程就分析完了。整个过程可简单总结为：先创建注册中心实例，之后再通过注册中心实例注册服务。本节先到这，接下来分析数据订阅过程。</p>
<h3>2.2.5 订阅 override 数据</h3>
<p>// 待补充</p>
<h2>3.总结</h2>
<p>本篇文章详细分析了 Dubbo 服务导出过程，包括配置检测，URL 组装，Invoker 创建过程、导出服务以及注册服务等等。篇幅比较大，需要大家耐心阅读。本篇文章先就到这，如果文章有不妥错误之处，希望大家能够进行反馈或修正。</p>
</div></section><footer class="footer-container"><div class="footer-body"><img src="/img/dubbo_gray.png"/><img class="apache" src="/img/apache_logo.png"/><div class="cols-container"><div class="col col-12"><h3>Disclaimer</h3><p>Apache Dubbo is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Incubator. Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.</p></div><div class="col col-4"><dl><dt>ASF</dt><dd><a href="http://www.apache.org" target="_self">基金会</a></dd><dd><a href="http://www.apache.org/licenses/" target="_self">证书</a></dd><dd><a href="http://www.apache.org/events/current-event" target="_self">事件</a></dd><dd><a href="http://www.apache.org/foundation/sponsorship.html" target="_self">赞助</a></dd><dd><a href="http://www.apache.org/foundation/thanks.html" target="_self">致谢</a></dd></dl></div><div class="col col-4"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/user/quick-start.html" target="_self">快速开始</a></dd><dd><a href="/zh-cn/docs/dev/build.html" target="_self">开发者指南</a></dd><dd><a href="/zh-cn/docs/admin/ops/dubbo-ops.html" target="_self">运维管理</a></dd></dl></div><div class="col col-4"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/community/index.html" target="_self">社区</a></dd><dd><a href="https://www.apache.org/security" target="_self">安全</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2018-2019 The Apache Software Foundation. Apache and the Apache feather logo are trademarks of The Apache Software Foundation.</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
  <script src="/build/documentation.js"></script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112489517-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-112489517-1');
	</script>
</body>
</html>