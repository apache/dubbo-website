<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="Dubbo, LoadBalance" />
	<meta name="description" content="本文介绍了集群的原理和实现细节" />
	<!-- 网页标签标题 -->
	<title>负载均衡</title>
	<link rel="shortcut icon" href="/img/dubbo.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/dubbo_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/user/quick-start.html">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/docs/developers/developers_dev.html">开发者</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html">博客</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html">社区</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/download.html">下载</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/docs.png" class="front-img"/><span>文档</span><img src="/img/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>用户文档</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>入门<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/background.html" target="_self">背景</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/requirements.html" target="_self">需求</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/architecture.html" target="_self">架构</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/usage.html" target="_self">用法</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/quick-start.html" target="_self">快速启动</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/dependencies.html" target="_self">依赖</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/maturity.html" target="_self">成熟度</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>配置<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/xml.html" target="_self">XML配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/properties.html" target="_self">属性配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/api.html" target="_self">API配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/annotation.html" target="_self">注解配置</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>示例<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/preflight-check.html" target="_self">启动时检查</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/fault-tolerent-strategy.html" target="_self">集群容错</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/loadbalance.html" target="_self">负载均衡</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/thread-model.html" target="_self">线程模型</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/explicit-target.html" target="_self">直连提供者</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/subscribe-only.html" target="_self">只订阅</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/registry-only.html" target="_self">只注册</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/static-service.html" target="_self">静态服务</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/multi-protocols.html" target="_self">多协议</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/multi-registry.html" target="_self">多注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/service-group.html" target="_self">服务分组</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/multi-versions.html" target="_self">多版本</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/group-merger.html" target="_self">分组聚合</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/parameter-validation.html" target="_self">参数验证</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/result-cache.html" target="_self">结果缓存</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/generic-reference.html" target="_self">泛化引用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/generic-service.html" target="_self">泛化实现</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/echo-service.html" target="_self">回声测试</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/context.html" target="_self">上下文信息</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/attachment.html" target="_self">隐式参数</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/async-call.html" target="_self">异步调用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/local-call.html" target="_self">本地调用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/callback-parameter.html" target="_self">参数回调</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/events-notify.html" target="_self">事件通知</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/local-stub.html" target="_self">本地存根</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/local-mock.html" target="_self">本地伪装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/delay-publish.html" target="_self">延迟暴露</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/concurrency-control.html" target="_self">并发控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/config-connections.html" target="_self">连接控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/lazy-connect.html" target="_self">延迟连接</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/stickiness.html" target="_self">粘滞连接</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/token-authorization.html" target="_self">令牌验证</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/routing-rule.html" target="_self">路由规则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/config-rule.html" target="_self">配置规则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/service-downgrade.html" target="_self">服务降级</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/graceful-shutdown.html" target="_self">优雅停机</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/hostname-binding.html" target="_self">主机绑定</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/logger-strategy.html" target="_self">日志适配</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/accesslog.html" target="_self">访问日志</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/service-container.html" target="_self">服务容器</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/reference-config-cache.html" target="_self">Reference Config 缓存</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/distributed-transaction.html" target="_self">分布式事务</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/dump.html" target="_self">线程栈自动dump</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/netty4.html" target="_self">Netty4</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/serialization.html" target="_self">Kryo和FST序列化</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/api.html" target="_self">API配置参考手册</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>schema配置参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-service.html" target="_self">dubbo:service</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-reference.html" target="_self">dubbo:reference</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-protocol.html" target="_self">dubbo:protocol</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-registry.html" target="_self">dubbo:registry</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-monitor.html" target="_self">dubbo:monitor</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-application.html" target="_self">dubbo:application</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-module.html" target="_self">dubbo:module</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-provider.html" target="_self">dubbo:provider</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-consumer.html" target="_self">dubbo:consumer</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-method.html" target="_self">dubbo:method</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-argument.html" target="_self">dubbo:argument</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-parameter.html" target="_self">dubbo:parameter</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>协议参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/dubbo.html" target="_self">dubbo://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/rmi.html" target="_self">rmi://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/hessian.html" target="_self">hessian://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/http.html" target="_self">http://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/webservice.html" target="_self">webservice://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/thrift.html" target="_self">thrift://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/memcached.html" target="_self">memcached://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/redis.html" target="_self">redis://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/rest.html" target="_self">rest://</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>注册中心参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/multicast.html" target="_self">Multicast 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/zookeeper.html" target="_self">Zookeeper 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/redis.html" target="_self">Redis 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/simple.html" target="_self">Simple 注册中心</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/telnet.html" target="_self">telnet命令参考手册</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/qos.html" target="_self">在线运维命令-QOS</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/maven.html" target="_self">maven插件参考手册</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/best-practice.html" target="_self">服务化最佳实践</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/recommend.html" target="_self">推荐用法</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/capacity-plan.html" target="_self">容量规划</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/perf-test.html" target="_self">性能测试报告</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/coveragence.html" target="_self">测试覆盖率报告</a></li></ul></li><li class="menu-item menu-item-level-1"><span>开发者指南</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/build.html" target="_self">源码构建</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/design.html" target="_self">框架设计</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/SPI.html" target="_self">扩展点加载</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/implementation.html" target="_self">实现细节</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>SPI 扩展实现<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/protocol.html" target="_self">协议扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/filter.html" target="_self">调用拦截扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/invoker-listener.html" target="_self">引用监听扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/exporter-listener.html" target="_self">暴露监听扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/cluster.html" target="_self">集群扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/router.html" target="_self">路由扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/load-balance.html" target="_self">负载均衡扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/merger.html" target="_self">合并结果扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/registry.html" target="_self">注册中心扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/monitor.html" target="_self">监控中心扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/extension-factory.html" target="_self">扩展点加载扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/proxy-factory.html" target="_self">动态代理扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/compiler.html" target="_self">编译器扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/dispatcher.html" target="_self">消息派发扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/threadpool.html" target="_self">线程池扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/serialize.html" target="_self">序列化扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/remoting.html" target="_self">网络传输扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/exchanger.html" target="_self">信息交换扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/networker.html" target="_self">组网扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/telnet-handler.html" target="_self">Telnet 命令扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/status-checker.html" target="_self">状态检查扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/container.html" target="_self">容器扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/page.html" target="_self">页面扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/cache.html" target="_self">缓存扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/validation.html" target="_self">验证扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/logger-adapter.html" target="_self">日志适配扩展</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/contract.html" target="_self">公共契约</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/coding.html" target="_self">编码约定</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>设计原则<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/code-detail.html" target="_self">魔鬼在细节</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/general-knowledge.html" target="_self">一些设计上的基本常识</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/expansibility.html" target="_self">谈谈扩充式扩展与增量式扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/configuration.html" target="_self">配置设计</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/robustness.html" target="_self">设计实现的健壮性</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/dummy.html" target="_self">防痴呆设计</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/extension.html" target="_self">扩展点重构</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/release.html" target="_self">版本管理</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/contribution.html" target="_self">贡献</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/checklist.html" target="_self">检查列表</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/code-smell.html" target="_self">坏味道</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/TCK.html" target="_self">技术兼容性测试</a></li></ul></li><li class="menu-item menu-item-level-1"><span>源码导读</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/dubbo-spi.html" target="_self">Dubbo SPI</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/adaptive-extension.html" target="_self">自适应拓展机制</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/export-service.html" target="_self">服务导出</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/refer-service.html" target="_self">服务引入</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/directory.html" target="_self">服务字典</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/router.html" target="_self">服务路由</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/cluster.html" target="_self">集群</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/loadbalance.html" target="_self">负载均衡</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/service-invoking-process.html" target="_self">服务调用过程</a></li></ul></li><li class="menu-item menu-item-level-1"><span>运维管理</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>安装手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/provider-demo.html" target="_self">示例提供者安装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/consumer-demo.html" target="_self">示例消费者安装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/zookeeper.html" target="_self">Zookeeper 注册中心安装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/redis.html" target="_self">Redis 注册中心安装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/simple-registry-center.html" target="_self">Simple 注册中心安装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/simple-monitor-center.html" target="_self">Simple 监控中心安装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/admin-console.html" target="_self">管理控制台安装</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>运维手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/ops/dubbo-ops.html" target="_self">管理控制台运维</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/ops/pinpoint.html" target="_self">使用Pinpoint做分布式跟踪</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/ops/skywalking.html" target="_self">使用Skywalking做分布式跟踪</a></li></ul></li></ul></li></ul></div><div class="doc-content markdown-body"><h2>1.简介</h2>
<p>LoadBalance 中文意思为负载均衡，它的职责是将网络请求，或者其他形式的负载“均摊”到不同的机器上。避免集群中部分服务器压力过大，而另一些服务器比较空闲的情况。通过负载均衡，可以让每台服务器获取到适合自己处理能力的负载。在为高负载服务器分流的同时，还可以避免资源浪费，一举两得。负载均衡可分为软件负载均衡和硬件负载均衡。在我们日常开发中，一般很难接触到硬件负载均衡。但软件负载均衡还是可以接触到的，比如 Nginx。在 Dubbo 中，也有负载均衡的概念和相应的实现。Dubbo 需要对服务消费者的调用请求进行分配，避免少数服务提供者负载过大。服务提供者负载过大，会导致部分请求超时。因此将负载均衡到每个服务提供者上，是非常必要的。Dubbo 提供了4种负载均衡实现，分别是基于权重随机算法的 RandomLoadBalance、基于最少活跃调用数算法的 LeastActiveLoadBalance、基于 hash 一致性的 ConsistentHashLoadBalance，以及基于加权轮询算法的 RoundRobinLoadBalance。这几个负载均衡算法代码不是很长，但是想看懂也不是很容易，需要大家对这几个算法的原理有一定了解才行。如果不是很了解，也没不用太担心。我们会在分析每个算法的源码之前，对算法原理进行简单的讲解，帮助大家建立初步的印象。</p>
<p>本系列文章在编写之初是基于 Dubbo 2.6.4 的，近期，Dubbo 2.6.5 发布了，其中就有针对对负载均衡部分的优化。因此我们在分析完 2.6.4 版本后的源码后，会另外分析 2.6.5 更新的部分。其他的就不多说了，进入正题吧。</p>
<h2>2.源码分析</h2>
<p>在 Dubbo 中，所有负载均衡实现类均继承自 AbstractLoadBalance，该类实现了 LoadBalance 接口，并封装了一些公共的逻辑。所以在分析负载均衡实现之前，先来看一下 AbstractLoadBalance 的逻辑。首先来看一下负载均衡的入口方法 select，如下：</p>
<pre><code class="language-java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">select</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>{
    <span class="hljs-keyword">if</span> (invokers == <span class="hljs-keyword">null</span> || invokers.isEmpty())
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    <span class="hljs-comment">// 如果 invokers 列表中仅有一个 Invoker，直接返回即可，无需进行负载均衡</span>
    <span class="hljs-keyword">if</span> (invokers.size() == <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> invokers.get(<span class="hljs-number">0</span>);
    
    <span class="hljs-comment">// 调用 doSelect 方法进行负载均衡，该方法为抽象方法，由子类实现</span>
    <span class="hljs-keyword">return</span> doSelect(invokers, url, invocation);
}

<span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doSelect</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span>;
</code></pre>
<p>select 方法的逻辑比较简单，首先会检测 invokers 集合的合法性，然后再检测 invokers 集合元素数量。如果只包含一个 Invoker，直接返回该 Inovker 即可。如果包含多个 Invoker，此时需要通过负载均衡算法选择一个 Invoker。具体的负载均衡算法由子类实现，接下来章节会对这些子类一一进行详细分析。</p>
<p>AbstractLoadBalance 除了实现了 LoadBalance 接口方法，还封装了一些公共逻辑，比如服务提供者权重计算逻辑。具体实现如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWeight</span><span class="hljs-params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>{
    <span class="hljs-comment">// 从 url 中获取权重 weight 配置值</span>
    <span class="hljs-keyword">int</span> weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);
    <span class="hljs-keyword">if</span> (weight &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 获取服务提供者启动时间戳</span>
        <span class="hljs-keyword">long</span> timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, <span class="hljs-number">0L</span>);
        <span class="hljs-keyword">if</span> (timestamp &gt; <span class="hljs-number">0L</span>) {
            <span class="hljs-comment">// 计算服务提供者运行时长</span>
            <span class="hljs-keyword">int</span> uptime = (<span class="hljs-keyword">int</span>) (System.currentTimeMillis() - timestamp);
            <span class="hljs-comment">// 获取服务预热时间，默认为10分钟</span>
            <span class="hljs-keyword">int</span> warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);
            <span class="hljs-comment">// 如果服务运行时间小于预热时间，则重新计算服务权重，即降权</span>
            <span class="hljs-keyword">if</span> (uptime &gt; <span class="hljs-number">0</span> &amp;&amp; uptime &lt; warmup) {
                <span class="hljs-comment">// 重新计算服务权重</span>
                weight = calculateWarmupWeight(uptime, warmup, weight);
            }
        }
    }
    <span class="hljs-keyword">return</span> weight;
}

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateWarmupWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> uptime, <span class="hljs-keyword">int</span> warmup, <span class="hljs-keyword">int</span> weight)</span> </span>{
    <span class="hljs-comment">// 计算权重，下面代码逻辑上形似于 (uptime / warmup) * weight。</span>
    <span class="hljs-comment">// 随着服务运行时间 uptime 增大，权重计算值 ww 会慢慢接近配置值 weight</span>
    <span class="hljs-keyword">int</span> ww = (<span class="hljs-keyword">int</span>) ((<span class="hljs-keyword">float</span>) uptime / ((<span class="hljs-keyword">float</span>) warmup / (<span class="hljs-keyword">float</span>) weight));
    <span class="hljs-keyword">return</span> ww &lt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : (ww &gt; weight ? weight : ww);
}
</code></pre>
<p>上面是权重的计算过程，该过程主要用于保证当服务运行时长小于服务预热时间时，对服务进行降权，避免让服务在启动之初就处于高负载状态。服务预热是一个优化手段，与此类似的还有 JVM 预热。主要目的是让服务启动后“低功率”运行一段时间，使其效率慢慢提升至最佳状态。</p>
<p>关于 AbstractLoadBalance 就先分析到这，接下来分析各个实现类的代码。首先，我们从 Dubbo 缺省的实现类 RandomLoadBalance 看起。</p>
<h3>2.1 RandomLoadBalance</h3>
<p>RandomLoadBalance 是加权随机算法的具体实现，它的算法思想很简单。假设我们有一组服务器 servers = [A, B, C]，他们对应的权重为 weights = [5, 3, 2]，权重总和为10。现在把这些权重值平铺在一维坐标值上，[0, 5) 区间属于服务器 A，[5, 8) 区间属于服务器 B，[8, 10) 区间属于服务器 C。接下来通过随机数生成器生成一个范围在 [0, 10) 之间的随机数，然后计算这个随机数会落到哪个区间上。比如数字3会落到服务器 A 对应的区间上，此时返回服务器 A 即可。权重越大的机器，在坐标轴上对应的区间范围就越大，因此随机数生成器生成的数字就会有更大的概率落到此区间内。只要随机数生成器产生的随机数分布性很好，在经过多次选择后，每个服务器被选中的次数比例接近其权重比例。比如，经过一万次选择后，服务器 A 被选中的次数大约为5000次，服务器 B 被选中的次数约为3000次，服务器 C 被选中的次数约为2000次。</p>
<p>以上就是 RandomLoadBalance 背后的算法思想，比较简单。下面开始分析源码。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomLoadBalance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLoadBalance</span> </span>{

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NAME = <span class="hljs-string">"random"</span>;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Random random = <span class="hljs-keyword">new</span> Random();

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doSelect</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>{
        <span class="hljs-keyword">int</span> length = invokers.size();
        <span class="hljs-keyword">int</span> totalWeight = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">boolean</span> sameWeight = <span class="hljs-keyword">true</span>;
        <span class="hljs-comment">// 下面这个循环有两个作用，第一是计算总权重 totalWeight，</span>
        <span class="hljs-comment">// 第二是检测每个服务提供者的权重是否相同</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
            <span class="hljs-keyword">int</span> weight = getWeight(invokers.get(i), invocation);
            <span class="hljs-comment">// 累加权重</span>
            totalWeight += weight;
            <span class="hljs-comment">// 检测当前服务提供者的权重与上一个服务提供者的权重是否相同，</span>
            <span class="hljs-comment">// 不相同的话，则将 sameWeight 置为 false。</span>
            <span class="hljs-keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="hljs-number">0</span>
                    &amp;&amp; weight != getWeight(invokers.get(i - <span class="hljs-number">1</span>), invocation)) {
                sameWeight = <span class="hljs-keyword">false</span>;
            }
        }
        
        <span class="hljs-comment">// 下面的 if 分支主要用于获取随机数，并计算随机数落在哪个区间上</span>
        <span class="hljs-keyword">if</span> (totalWeight &gt; <span class="hljs-number">0</span> &amp;&amp; !sameWeight) {
            <span class="hljs-comment">// 随机获取一个 [0, totalWeight) 区间内的数字</span>
            <span class="hljs-keyword">int</span> offset = random.nextInt(totalWeight);
            <span class="hljs-comment">// 循环让 offset 数减去服务提供者权重值，当 offset 小于0时，返回相应的 Invoker。</span>
            <span class="hljs-comment">// 举例说明一下，我们有 servers = [A, B, C]，weights = [5, 3, 2]，offset = 7。</span>
            <span class="hljs-comment">// 第一次循环，offset - 5 = 2 &gt; 0，即 offset &gt; 5，</span>
            <span class="hljs-comment">// 表明其不会落在服务器 A 对应的区间上。</span>
            <span class="hljs-comment">// 第二次循环，offset - 3 = -1 &lt; 0，即 5 &lt; offset &lt; 8，</span>
            <span class="hljs-comment">// 表明其会落在服务器 B 对应的区间上</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
                <span class="hljs-comment">// 让随机值 offset 减去权重值</span>
                offset -= getWeight(invokers.get(i), invocation);
                <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) {
                    <span class="hljs-comment">// 返回相应的 Invoker</span>
                    <span class="hljs-keyword">return</span> invokers.get(i);
                }
            }
        }
        
        <span class="hljs-comment">// 如果所有服务提供者权重值相同，此时直接随机返回一个即可</span>
        <span class="hljs-keyword">return</span> invokers.get(random.nextInt(length));
    }
}
</code></pre>
<p>RandomLoadBalance 的算法思想比较简单，在经过多次请求后，能够将调用请求按照权重值进行“均匀”分配。当然 RandomLoadBalance 也存在一定的缺点，当调用次数比较少时，Random 产生的随机数可能会比较集中，此时多数请求会落到同一台服务器上。这个缺点并不是很严重，多数情况下可以忽略。RandomLoadBalance 是一个简单，高效的负载均衡实现，因此 Dubbo 选择它作为缺省实现。</p>
<p>关于 RandomLoadBalance 就先到这了，接下来分析 LeastActiveLoadBalance。</p>
<h3>2.2 LeastActiveLoadBalance</h3>
<p>LeastActiveLoadBalance 翻译过来是最小活跃数负载均衡。活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求。此时应优先将请求分配给该服务提供者。在具体实现中，每个服务提供者对应一个活跃数 active。初始情况下，所有服务提供者活跃数均为0。每收到一个请求，活跃数加1，完成请求后则将活跃数减1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小活跃数负载均衡算法的基本思想。除了最小活跃数，LeastActiveLoadBalance 在实现上还引入了权重值。所以准确的来说，LeastActiveLoadBalance 是基于加权最小活跃数算法实现的。举个例子说明一下，在一个服务提供者集群中，有两个性能优异的服务提供者。某一时刻它们的活跃数相同，此时 Dubbo 会根据它们的权重去分配请求，权重越大，获取到新请求的概率就越大。如果两个服务提供者权重相同，此时随机选择一个即可。关于 LeastActiveLoadBalance 的背景知识就先介绍到这里，下面开始分析源码。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeastActiveLoadBalance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLoadBalance</span> </span>{

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NAME = <span class="hljs-string">"leastactive"</span>;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Random random = <span class="hljs-keyword">new</span> Random();

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doSelect</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>{
        <span class="hljs-keyword">int</span> length = invokers.size();
        <span class="hljs-comment">// 最小的活跃数</span>
        <span class="hljs-keyword">int</span> leastActive = -<span class="hljs-number">1</span>;
        <span class="hljs-comment">// 具有相同“最小活跃数”的服务者提供者（以下用 Invoker 代称）数量</span>
        <span class="hljs-keyword">int</span> leastCount = <span class="hljs-number">0</span>; 
        <span class="hljs-comment">// leastIndexs 用于记录具有相同“最小活跃数”的 Invoker 在 invokers 列表中的下标信息</span>
        <span class="hljs-keyword">int</span>[] leastIndexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];
        <span class="hljs-keyword">int</span> totalWeight = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 第一个最小活跃数的 Invoker 权重值，用于与其他具有相同最小活跃数的 Invoker 的权重进行对比，</span>
        <span class="hljs-comment">// 以检测是否“所有具有相同最小活跃数的 Invoker 的权重”均相等</span>
        <span class="hljs-keyword">int</span> firstWeight = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">boolean</span> sameWeight = <span class="hljs-keyword">true</span>;

        <span class="hljs-comment">// 遍历 invokers 列表</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
            Invoker&lt;T&gt; invoker = invokers.get(i);
            <span class="hljs-comment">// 获取 Invoker 对应的活跃数</span>
            <span class="hljs-keyword">int</span> active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();
            <span class="hljs-comment">// 获取权重 - ⭐️</span>
            <span class="hljs-keyword">int</span> weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);
            <span class="hljs-comment">// 发现更小的活跃数，重新开始</span>
            <span class="hljs-keyword">if</span> (leastActive == -<span class="hljs-number">1</span> || active &lt; leastActive) {
            	<span class="hljs-comment">// 使用当前活跃数 active 更新最小活跃数 leastActive</span>
                leastActive = active;
                <span class="hljs-comment">// 更新 leastCount 为 1</span>
                leastCount = <span class="hljs-number">1</span>;
                <span class="hljs-comment">// 记录当前下标值到 leastIndexs 中</span>
                leastIndexs[<span class="hljs-number">0</span>] = i;
                totalWeight = weight;
                firstWeight = weight;
                sameWeight = <span class="hljs-keyword">true</span>;

            <span class="hljs-comment">// 当前 Invoker 的活跃数 active 与最小活跃数 leastActive 相同 </span>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (active == leastActive) {
            	<span class="hljs-comment">// 在 leastIndexs 中记录下当前 Invoker 在 invokers 集合中的下标</span>
                leastIndexs[leastCount++] = i;
                <span class="hljs-comment">// 累加权重</span>
                totalWeight += weight;
                <span class="hljs-comment">// 检测当前 Invoker 的权重与 firstWeight 是否相等，</span>
                <span class="hljs-comment">// 不相等则将 sameWeight 置为 false</span>
                <span class="hljs-keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="hljs-number">0</span>
                    &amp;&amp; weight != firstWeight) {
                    sameWeight = <span class="hljs-keyword">false</span>;
                }
            }
        }
        
        <span class="hljs-comment">// 当只有一个 Invoker 具有最小活跃数，此时直接返回该 Invoker 即可</span>
        <span class="hljs-keyword">if</span> (leastCount == <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> invokers.get(leastIndexs[<span class="hljs-number">0</span>]);
        }

        <span class="hljs-comment">// 有多个 Invoker 具有相同的最小活跃数，但它们之间的权重不同</span>
        <span class="hljs-keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="hljs-number">0</span>) {
        	<span class="hljs-comment">// 随机生成一个 [0, totalWeight) 之间的数字</span>
            <span class="hljs-keyword">int</span> offsetWeight = random.nextInt(totalWeight);
            <span class="hljs-comment">// 循环让随机数减去具有最小活跃数的 Invoker 的权重值，</span>
            <span class="hljs-comment">// 当 offset 小于等于0时，返回相应的 Invoker</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; leastCount; i++) {
                <span class="hljs-keyword">int</span> leastIndex = leastIndexs[i];
                <span class="hljs-comment">// 获取权重值，并让随机数减去权重值 - ⭐️</span>
                offsetWeight -= getWeight(invokers.get(leastIndex), invocation);
                <span class="hljs-keyword">if</span> (offsetWeight &lt;= <span class="hljs-number">0</span>)
                    <span class="hljs-keyword">return</span> invokers.get(leastIndex);
            }
        }
        <span class="hljs-comment">// 如果权重相同或权重为0时，随机返回一个 Invoker</span>
        <span class="hljs-keyword">return</span> invokers.get(leastIndexs[random.nextInt(leastCount)]);
    }
}
</code></pre>
<p>上面代码的逻辑比较多，我们在代码中写了大量的注释，有帮助大家理解代码逻辑。下面简单总结一下以上代码所做的事情，如下：</p>
<ol>
<li>遍历 invokers 列表，寻找活跃数最小的 Invoker</li>
<li>如果有多个 Invoker 具有相同的最小活跃数，此时记录下这些 Invoker 在 invokers 集合中的下标，并累加它们的权重，比较它们的权重值是否相等</li>
<li>如果只有一个 Invoker 具有最小的活跃数，此时直接返回该 Invoker 即可</li>
<li>如果有多个 Invoker 具有最小活跃数，且它们的权重不相等，此时处理方式和 RandomLoadBalance 一致</li>
<li>如果有多个 Invoker 具有最小活跃数，但它们的权重相等，此时随机返回一个即可</li>
</ol>
<p>以上就是 LeastActiveLoadBalance 大致的实现逻辑，大家在阅读的源码的过程中要注意区分活跃数与权重这两个概念，不要混为一谈。</p>
<p>以上分析是基于 Dubbo 2.6.4 版本进行的，由于近期 Dubbo 2.6.5 发布了，并对 LeastActiveLoadBalance 进行了一些修改，下面简单来介绍一下修改内容。回到上面的源码中，我们在上面的代码中标注了两个黄色的五角星⭐️。两处标记对应的代码分别如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">int</span> weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);
</code></pre>
<pre><code class="language-java">offsetWeight -= getWeight(invokers.get(leastIndex), invocation);
</code></pre>
<p>问题出在服务预热阶段，第一行代码直接从 url 中去权重值，未被降权过。第二行代码获取到的是经过降权后的权重。第一行代码获取到的权重值最终会被累加到权重总和 totalWeight 中，这个时候会导致一个问题。offsetWeight 是一个在 [0, totalWeight) 范围内的随机数，而它所减去的是经过降权的权重。很有可能在经过 leastCount 次运算后，offsetWeight 仍然是大于0的，导致无法选中 Invoker。这个问题对应的 issue 为 <a href="https://github.com/apache/incubator-dubbo/issues/904">#904</a>，并在 pull request <a href="https://github.com/apache/incubator-dubbo/pull/2172">#2172</a> 中被修复。具体的修复逻辑是将标注一处的代码修改为：</p>
<pre><code class="language-java"><span class="hljs-comment">// afterWarmup 等价于上面的 weight 变量，这样命名是为了强调该变量经过了 warmup 降权处理</span>
<span class="hljs-keyword">int</span> afterWarmup = getWeight(invoker, invocation);
</code></pre>
<p>另外，2.6.4 版本中的 LeastActiveLoadBalance 还要一个缺陷，即当一组 Invoker 具有相同的最小活跃数，且其中一个 Invoker 的权重值为1，此时这个 Invoker 无法被选中。缺陷代码如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">int</span> offsetWeight = random.nextInt(totalWeight);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; leastCount; i++) {
    <span class="hljs-keyword">int</span> leastIndex = leastIndexs[i];
    offsetWeight -= getWeight(invokers.get(leastIndex), invocation);
    <span class="hljs-keyword">if</span> (offsetWeight &lt;= <span class="hljs-number">0</span>)    <span class="hljs-comment">// ❌</span>
        <span class="hljs-keyword">return</span> invokers.get(leastIndex);
}
</code></pre>
<p>问题出在了<code>offsetWeight &lt;= 0</code>上，举例说明，假设有一组 Invoker  的权重为 5、2、1，offsetWeight 最大值为 7。假设 offsetWeight = 7，你会发现，当 for 循环进行第二次遍历后 offsetWeight = 7 - 5 - 2 = 0，提前返回了。此时，此时权重为1的 Invoker 就没有机会被选中了。该问题在 Dubbo 2.6.5 中被修复了，修改后的代码如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">int</span> offsetWeight = random.nextInt(totalWeight) + <span class="hljs-number">1</span>;
</code></pre>
<p>以上就是 Dubob 2.6.5 对 LeastActiveLoadBalance 的更新，内容不是很多，先分析到这。接下来分析基于一致性 hash 思想的 ConsistentHashLoadBalance。</p>
<h3>2.3 ConsistentHashLoadBalance</h3>
<p>一致性 hash 算法由麻省理工学院的 Karger 及其合作者于1997年提供出的，算法提出之初是用于大规模缓存系统的负载均衡。它的工作过程是这样的，首先根据 ip 或其他的信息为缓存节点生成一个 hash，并将这个 hash 投射到 [0, 2<sup>32</sup> - 1] 的圆环上。当有查询或写入请求时，则为缓存项的 key 生成一个 hash 值。然后查找第一个大于或等于该 hash 值的缓存节点，并到这个节点中查询或写入缓存项。如果当前节点挂了，则在下一次查询或写入缓存时，为缓存项查找另一个大于其 hash 值的缓存节点即可。大致效果如下图所示，每个缓存节点在圆环上占据一个位置。如果缓存项的 key 的 hash 值小于缓存节点 hash 值，则到该缓存节点中存储或读取缓存项。比如下面绿色点对应的缓存项将会被存储到 cache-2 节点中。由于 cache-3 挂了，原本应该存到该节点中的缓存想最终会存储到 cache-4 节点中。</p>
<p><img src="./sources/images/consistent-hash.jpg" alt=""></p>
<p>下面来看看一致性 hash 在 Dubbo 中的应用。我们把上图的缓存节点替换成 Dubbo 的服务提供者，于是得到了下图：</p>
<p><img src="./sources/images/consistent-hash-invoker.jpg" alt=""></p>
<p>这里相同颜色的节点均属于同一个服务提供者，比如 Invoker1-1，Invoker1-2，……, Invoker1-160。这样做的目的是通过引入虚拟节点，让 Invoker 在圆环上分散开来，避免数据倾斜问题。所谓数据倾斜是指，由于节点不够分散，导致大量请求落到了同一个节点上，而其他节点只会接收到了少量请求的情况。比如：</p>
<p><img src="./sources/images/consistent-hash-data-incline.jpg" alt=""></p>
<p>如上，由于 Invoker-1 和 Invoker-2 在圆环上分布不均，导致系统中75%的请求都会落到 Invoker-1 上，只有 25% 的请求会落到 Invoker-2 上。解决这个问题办法是引入虚拟节点，通过虚拟节点均衡各个节点的请求量。</p>
<p>到这里背景知识就普及完了，接下来开始分析源码。我们先从 ConsistentHashLoadBalance 的 doSelect 方法开始看起，如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsistentHashLoadBalance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLoadBalance</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt; selectors = 
        <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt;();

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doSelect</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>{
        String methodName = RpcUtils.getMethodName(invocation);
        String key = invokers.get(<span class="hljs-number">0</span>).getUrl().getServiceKey() + <span class="hljs-string">"."</span> + methodName;

        <span class="hljs-comment">// 获取 invokers 原始的 hashcode</span>
        <span class="hljs-keyword">int</span> identityHashCode = System.identityHashCode(invokers);
        ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);
        <span class="hljs-comment">// 如果 invokers 是一个新的 List 对象，意味着服务提供者数量发生了变化，可能新增也可能减少了。</span>
        <span class="hljs-comment">// 此时 selector.identityHashCode != identityHashCode 条件成立</span>
        <span class="hljs-keyword">if</span> (selector == <span class="hljs-keyword">null</span> || selector.identityHashCode != identityHashCode) {
            <span class="hljs-comment">// 创建新的 ConsistentHashSelector</span>
            selectors.put(key, <span class="hljs-keyword">new</span> ConsistentHashSelector&lt;T&gt;(invokers, methodName, identityHashCode));
            selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);
        }

        <span class="hljs-comment">// 调用 ConsistentHashSelector 的 select 方法选择 Invoker</span>
        <span class="hljs-keyword">return</span> selector.select(invocation);
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsistentHashSelector</span>&lt;<span class="hljs-title">T</span>&gt; </span>{...}
}
</code></pre>
<p>如上，doSelect 方法主要做了一些前置工作，比如检测 invokers 列表是不是变动过，以及创建 ConsistentHashSelector。这些工作做完后，接下来开始调用 ConsistentHashSelector 的 select 方法执行负载均衡逻辑。在分析 select 方法之前，我们先来看一下一致性 hash 选择器 ConsistentHashSelector 的初始化过程，如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsistentHashSelector</span>&lt;<span class="hljs-title">T</span>&gt; </span>{

    <span class="hljs-comment">// 使用 TreeMap 存储 Invoker 虚拟节点</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> replicaNumber;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> identityHashCode;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] argumentIndex;

    ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, <span class="hljs-keyword">int</span> identityHashCode) {
        <span class="hljs-keyword">this</span>.virtualInvokers = <span class="hljs-keyword">new</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();
        <span class="hljs-keyword">this</span>.identityHashCode = identityHashCode;
        URL url = invokers.get(<span class="hljs-number">0</span>).getUrl();
        <span class="hljs-comment">// 获取虚拟节点数，默认为160</span>
        <span class="hljs-keyword">this</span>.replicaNumber = url.getMethodParameter(methodName, <span class="hljs-string">"hash.nodes"</span>, <span class="hljs-number">160</span>);
        <span class="hljs-comment">// 获取参与 hash 计算的参数下标值，默认对第一个参数进行 hash 运算</span>
        String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, <span class="hljs-string">"hash.arguments"</span>, <span class="hljs-string">"0"</span>));
        argumentIndex = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[index.length];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index.length; i++) {
            argumentIndex[i] = Integer.parseInt(index[i]);
        }
        <span class="hljs-keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) {
            String address = invoker.getUrl().getAddress();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; replicaNumber / <span class="hljs-number">4</span>; i++) {
                <span class="hljs-comment">// 对 address + i 进行 md5 运算，得到一个长度为16的字节数组</span>
                <span class="hljs-keyword">byte</span>[] digest = md5(address + i);
                <span class="hljs-comment">// 对 digest 部分字节进行4次 hash 运算，得到四个不同的 long 型正整数</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>; h &lt; <span class="hljs-number">4</span>; h++) {
                    <span class="hljs-comment">// h = 0 时，取 digest 中下标为 0 ~ 3 的4个字节进行位运算</span>
                    <span class="hljs-comment">// h = 1 时，取 digest 中下标为 4 ~ 7 的4个字节进行位运算</span>
                    <span class="hljs-comment">// h = 2, h = 3 时过程同上</span>
                    <span class="hljs-keyword">long</span> m = hash(digest, h);
                    <span class="hljs-comment">// 将 hash 到 invoker 的映射关系存储到 virtualInvokers 中，</span>
                    <span class="hljs-comment">// virtualInvokers 需要提供高效的查询操作，因此选用 TreeMap 作为存储结构</span>
                    virtualInvokers.put(m, invoker);
                }
            }
        }
    }
}
</code></pre>
<p>ConsistentHashSelector 的构造方法执行了一系列的初始化逻辑，比如从配置中获取虚拟节点数以及参与 hash 计算的参数下标，默认情况下只使用第一个参数进行 hash。需要特别说明的是，ConsistentHashLoadBalance 的负载均衡逻辑只受参数值影响，具有相同参数值的请求将会被分配给同一个服务提供者。ConsistentHashLoadBalance 不 关系权重，因此使用时需要注意一下。</p>
<p>在获取虚拟节点数和参数下标配置后，接下来要做的事情是计算虚拟节点 hash 值，并将虚拟节点存储到 TreeMap 中。到此，ConsistentHashSelector 初始化工作就完成了。接下来，我们来看看 select 方法的逻辑。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> Invoker&lt;T&gt; <span class="hljs-title">select</span><span class="hljs-params">(Invocation invocation)</span> </span>{
    <span class="hljs-comment">// 将参数转为 key</span>
    String key = toKey(invocation.getArguments());
    <span class="hljs-comment">// 对参数 key 进行 md5 运算</span>
    <span class="hljs-keyword">byte</span>[] digest = md5(key);
    <span class="hljs-comment">// 取 digest 数组的前四个字节进行 hash 运算，再将 hash 值传给 selectForKey 方法，</span>
    <span class="hljs-comment">// 寻找合适的 Invoker</span>
    <span class="hljs-keyword">return</span> selectForKey(hash(digest, <span class="hljs-number">0</span>));
}

<span class="hljs-function"><span class="hljs-keyword">private</span> Invoker&lt;T&gt; <span class="hljs-title">selectForKey</span><span class="hljs-params">(<span class="hljs-keyword">long</span> hash)</span> </span>{
    <span class="hljs-comment">// 到 TreeMap 中查找第一个节点值大于或等于当前 hash 的 Invoker</span>
    Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry = virtualInvokers.tailMap(hash, <span class="hljs-keyword">true</span>).firstEntry();
    <span class="hljs-comment">// 如果 hash 大于 Invoker 在圆环上最大的位置，此时 entry = null，</span>
    <span class="hljs-comment">// 需要将 TreeMap 的头结点赋值给 entry</span>
    <span class="hljs-keyword">if</span> (entry == <span class="hljs-keyword">null</span>) {
        entry = virtualInvokers.firstEntry();
    }

    <span class="hljs-comment">// 返回 Invoker</span>
    <span class="hljs-keyword">return</span> entry.getValue();
}
</code></pre>
<p>如上，选择的过程相对比较简单了。首先是对参数进行 md5 以及 hash 运算，得到一个 hash 值。然后再拿这个值到 TreeMap 中查找目标 Invoker 即可。</p>
<p>到此关于 ConsistentHashLoadBalance 就分析完了。在阅读 ConsistentHashLoadBalance 源码之前，大家一定要先补充背景知识，不然很难看懂代码逻辑。</p>
<h3>2.4 RoundRobinLoadBalance</h3>
<p>本节，我们来看一下 Dubbo 中加权轮询负载均衡的实现 RoundRobinLoadBalance。在详细分析源码前，我们先来了解一下什么是加权轮询。这里从最简单的轮询开始讲起，所谓轮询是指将请求轮流分配给每台服务器。举个例子，我们有三台服务器 A、B、C。我们将第一个请求分配给服务器 A，第二个请求分配给服务器 B，第三个请求分配给服务器 C，第四个请求再次分配给服务器 A。这个过程就叫做轮询。轮询是一种无状态负载均衡算法，实现简单，适用于每台服务器性能相近的场景下。但现实情况下，我们并不能保证每台服务器性能均相近。如果我们将等量的请求分配给性能较差的服务器，这显然是不合理的。因此，这个时候我们需要对轮询过程进行加权，以调控每台服务器的负载。经过加权后，每台服务器能够得到的请求数比例，接近或等于他们的权重比。比如服务器 A、B、C 权重比为 5:2:1。那么在8次请求中，服务器 A 将收到其中的5次请求，服务器 B 会收到其中的2次请求，服务器 C 则收到其中的1次请求。</p>
<p>以上就是加权轮询的算法思想，搞懂了这个思想，接下来我们就可以分析源码了。我们先来看一下 2.6.4 版本的 RoundRobinLoadBalance。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoundRobinLoadBalance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLoadBalance</span> </span>{

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NAME = <span class="hljs-string">"roundrobin"</span>;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;String, AtomicPositiveInteger&gt; sequences = 
        <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, AtomicPositiveInteger&gt;();

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doSelect</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>{
        <span class="hljs-comment">// key = 全限定类名 + "." + 方法名，比如 com.xxx.DemoService.sayHello</span>
        String key = invokers.get(<span class="hljs-number">0</span>).getUrl().getServiceKey() + <span class="hljs-string">"."</span> + invocation.getMethodName();
        <span class="hljs-keyword">int</span> length = invokers.size();
        <span class="hljs-comment">// 最大权重</span>
        <span class="hljs-keyword">int</span> maxWeight = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 最小权重</span>
        <span class="hljs-keyword">int</span> minWeight = Integer.MAX_VALUE;
        <span class="hljs-keyword">final</span> LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; invokerToWeightMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt;();
        <span class="hljs-comment">// 权重总和</span>
        <span class="hljs-keyword">int</span> weightSum = <span class="hljs-number">0</span>;

        <span class="hljs-comment">// 下面这个循环主要用于查找最大和最小权重，计算权重总和等</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
            <span class="hljs-keyword">int</span> weight = getWeight(invokers.get(i), invocation);
            <span class="hljs-comment">// 获取最大和最小权重</span>
            maxWeight = Math.max(maxWeight, weight);
            minWeight = Math.min(minWeight, weight);
            <span class="hljs-keyword">if</span> (weight &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-comment">// 将 weight 封装到 IntegerWrapper 中</span>
                invokerToWeightMap.put(invokers.get(i), <span class="hljs-keyword">new</span> IntegerWrapper(weight));
                <span class="hljs-comment">// 累加权重</span>
                weightSum += weight;
            }
        }

        <span class="hljs-comment">// 查找 key 对应的对应 AtomicPositiveInteger 实例，为空则创建。</span>
        <span class="hljs-comment">// 这里可以把 AtomicPositiveInteger 看成一个黑盒，大家只要知道</span>
        <span class="hljs-comment">// AtomicPositiveInteger 用于记录服务的调用编号即可。至于细节，</span>
        <span class="hljs-comment">// 大家如果感兴趣，可以自行分析</span>
        AtomicPositiveInteger sequence = sequences.get(key);
        <span class="hljs-keyword">if</span> (sequence == <span class="hljs-keyword">null</span>) {
            sequences.putIfAbsent(key, <span class="hljs-keyword">new</span> AtomicPositiveInteger());
            sequence = sequences.get(key);
        }

        <span class="hljs-comment">// 获取当前的调用编号</span>
        <span class="hljs-keyword">int</span> currentSequence = sequence.getAndIncrement();
        <span class="hljs-comment">// 如果最小权重小于最大权重，表明服务提供者之间的权重是不相等的</span>
        <span class="hljs-keyword">if</span> (maxWeight &gt; <span class="hljs-number">0</span> &amp;&amp; minWeight &lt; maxWeight) {
            <span class="hljs-comment">// 使用调用编号对权重总和进行取余操作</span>
            <span class="hljs-keyword">int</span> mod = currentSequence % weightSum;
            <span class="hljs-comment">// 进行 maxWeight 次遍历</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxWeight; i++) {
                <span class="hljs-comment">// 遍历 invokerToWeightMap</span>
                <span class="hljs-keyword">for</span> (Map.Entry&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; each : invokerToWeightMap.entrySet()) {
					<span class="hljs-comment">// 获取 Invoker</span>
                    <span class="hljs-keyword">final</span> Invoker&lt;T&gt; k = each.getKey();
                    <span class="hljs-comment">// 获取权重包装类 IntegerWrapper</span>
                    <span class="hljs-keyword">final</span> IntegerWrapper v = each.getValue();
                    
                    <span class="hljs-comment">// 如果 mod = 0，且权重大于0，此时返回相应的 Invoker</span>
                    <span class="hljs-keyword">if</span> (mod == <span class="hljs-number">0</span> &amp;&amp; v.getValue() &gt; <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">return</span> k;
                    }
                    
                    <span class="hljs-comment">// mod != 0，且权重大于0，此时对权重和 mod 分别进行自减操作</span>
                    <span class="hljs-keyword">if</span> (v.getValue() &gt; <span class="hljs-number">0</span>) {
                        v.decrement();
                        mod--;
                    }
                }
            }
        }
        
        <span class="hljs-comment">// 服务提供者之间的权重相等，此时通过轮询选择 Invoker</span>
        <span class="hljs-keyword">return</span> invokers.get(currentSequence % length);
    }

    <span class="hljs-comment">// IntegerWrapper 是一个 int 包装类，主要包含了一个自减方法。</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerWrapper</span> </span>{
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">this</span>.value--;
        }
        
        <span class="hljs-comment">// 省略部分代码</span>
    }
}
</code></pre>
<p>如上，RoundRobinLoadBalance 的每行代码都不是很难理解，但是将它们组合在一起之后，就不是很好理解了。所以下面我们举例进行说明，假设我们有三台服务器 servers = [A, B, C]，对应的权重为 weights = [2, 5, 1]。接下来对上面的逻辑进行简单的模拟。</p>
<p>mod = 0：满足条件，此时直接返回服务器 A</p>
<p>mod = 1：需要进行一次递减操作才能满足条件，此时返回服务器 B</p>
<p>mod = 2：需要进行两次递减操作才能满足条件，此时返回服务器 C</p>
<p>mod = 3：需要进行三次递减操作才能满足条件，经过递减后，服务器权重为 [1, 4, 0]，此时返回服务器 A</p>
<p>mod = 4：需要进行四次递减操作才能满足条件，经过递减后，服务器权重为 [0, 4, 0]，此时返回服务器 B</p>
<p>mod = 5：需要进行五次递减操作才能满足条件，经过递减后，服务器权重为 [0, 3, 0]，此时返回服务器 B</p>
<p>mod = 6：需要进行六次递减操作才能满足条件，经过递减后，服务器权重为 [0, 2, 0]，此时返回服务器 B</p>
<p>mod = 7：需要进行七次递减操作才能满足条件，经过递减后，服务器权重为 [0, 1, 0]，此时返回服务器 B</p>
<p>经过8次调用后，我们得到的负载均衡结果为 [A, B, C, A, B, B, B, B]，次数比 A:B:C = 2:5:1，等于权重比。当 sequence = 8 时，mod = 0，此时重头再来。从上面的模拟过程可以看出，当 mod &gt;= 3 后，服务器 C 就不会被选中了，因为它的权重被减为0了。当 mod &gt;= 4 后，服务器 A 的权重被减为0，此后 A 就不会再被选中。</p>
<p>以上是 2.6.4 版本的 RoundRobinLoadBalance 分析过程，2.6.4 版本的 RoundRobinLoadBalance 在某些情况下存在着比较严重的性能问题，该问题最初是在 <a href="https://github.com/apache/incubator-dubbo/issues/2578">issue #2578</a> 中被反馈出来。问题出在了 Invoker 的返回时机上，RoundRobinLoadBalance 需要在<code>mod == 0 &amp;&amp; v.getValue() &gt; 0</code> 条件成立的情况下才会被返回相应的 Invoker。假如 mod 很大，比如 10000，50000，甚至更大时，doSelect 方法需要进行很多次计算才能将 mod 减为0。由此可知，doSelect 的效率与 mod 有关，时间复杂度为 O(mod)。mod 又受最大权重 maxWeight 的影响，因此当某个服务提供者配置了非常大的权重，此时 RoundRobinLoadBalance 会产生比较严重的性能问题。这个问题被反馈后，社区很快做了回应。并对 RoundRobinLoadBalance 的代码进行了重构，将时间复杂度优化至了常量级别。这个优化可以说很好了，下面我们来学习一下优化后的代码。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoundRobinLoadBalance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLoadBalance</span> </span>{

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NAME = <span class="hljs-string">"roundrobin"</span>;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;String, AtomicPositiveInteger&gt; sequences = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, AtomicPositiveInteger&gt;();

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;String, AtomicPositiveInteger&gt; indexSeqs = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, AtomicPositiveInteger&gt;();

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doSelect</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>{
        String key = invokers.get(<span class="hljs-number">0</span>).getUrl().getServiceKey() + <span class="hljs-string">"."</span> + invocation.getMethodName();
        <span class="hljs-keyword">int</span> length = invokers.size();
        <span class="hljs-keyword">int</span> maxWeight = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> minWeight = Integer.MAX_VALUE;
        <span class="hljs-keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokerToWeightList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        
        <span class="hljs-comment">// 查找最大和最小权重</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
            <span class="hljs-keyword">int</span> weight = getWeight(invokers.get(i), invocation);
            maxWeight = Math.max(maxWeight, weight);
            minWeight = Math.min(minWeight, weight);
            <span class="hljs-keyword">if</span> (weight &gt; <span class="hljs-number">0</span>) {
                invokerToWeightList.add(invokers.get(i));
            }
        }
        
        <span class="hljs-comment">// 获取当前服务对应的调用序列对象 AtomicPositiveInteger</span>
        AtomicPositiveInteger sequence = sequences.get(key);
        <span class="hljs-keyword">if</span> (sequence == <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// 创建 AtomicPositiveInteger，默认值为0</span>
            sequences.putIfAbsent(key, <span class="hljs-keyword">new</span> AtomicPositiveInteger());
            sequence = sequences.get(key);
        }
        
        <span class="hljs-comment">// 获取下标序列对象 AtomicPositiveInteger</span>
        AtomicPositiveInteger indexSeq = indexSeqs.get(key);
        <span class="hljs-keyword">if</span> (indexSeq == <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// 创建 AtomicPositiveInteger，默认值为 -1</span>
            indexSeqs.putIfAbsent(key, <span class="hljs-keyword">new</span> AtomicPositiveInteger(-<span class="hljs-number">1</span>));
            indexSeq = indexSeqs.get(key);
        }

        <span class="hljs-keyword">if</span> (maxWeight &gt; <span class="hljs-number">0</span> &amp;&amp; minWeight &lt; maxWeight) {
            length = invokerToWeightList.size();
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
                <span class="hljs-keyword">int</span> index = indexSeq.incrementAndGet() % length;
                <span class="hljs-keyword">int</span> currentWeight = sequence.get() % maxWeight;

                <span class="hljs-comment">// 每循环一轮（index = 0），重新计算 currentWeight</span>
                <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) {
                    currentWeight = sequence.incrementAndGet() % maxWeight;
                }
                
                <span class="hljs-comment">// 检测 Invoker 的权重是否大于 currentWeight，大于则返回</span>
                <span class="hljs-keyword">if</span> (getWeight(invokerToWeightList.get(index), invocation) &gt; currentWeight) {
                    <span class="hljs-keyword">return</span> invokerToWeightList.get(index);
                }
            }
        }
        
        <span class="hljs-comment">// 所有 Invoker 权重相等，此时进行普通的轮询即可</span>
        <span class="hljs-keyword">return</span> invokers.get(sequence.incrementAndGet() % length);
    }
}
</code></pre>
<p>上面代码的逻辑是这样的，每进行一轮循环，重新计算 currentWeight。如果当前 Invoker 权重大于 currentWeight，则返回该 Invoker。下面举例说明，假设服务器 [A, B, C] 对应权重 [5, 2, 1]。</p>
<p>第一轮循环，currentWeight = 1，可返回 A 和 B</p>
<p>第二轮循环，currentWeight = 2，返回 A</p>
<p>第三轮循环，currentWeight = 3，返回 A</p>
<p>第四轮循环，currentWeight = 4，返回 A</p>
<p>第五轮循环，currentWeight = 0，返回 A, B, C</p>
<p>如上，这里的一轮循环是指 index 再次变为0所经历过的循环，这里可以把 index = 0 看做是一轮循环的开始。每一轮循环的次数与 Invoker 的数量有关，Invoker 数量通常不会太多，所以我们可以认为上面代码的时间复杂度为常数级。</p>
<p>重构后的 RoundRobinLoadBalance 看起来已经很不错了，但是在代码更新不久后，很快又被重构了。这次重构原因是新的 RoundRobinLoadBalance 在某些情况下选出的服务器序列不够均匀。比如，服务器 [A, B, C] 对应权重 [5, 1, 1]。进行7次负载均衡后，选择出来的序列为 [A, A, A, A, A, B, C]。前5个请求全部都落在了服务器 A上，这将会使服务器 A 短时间内接收大量的请求，压力陡增。而 B 和 C 此时无请求，处于空闲状态。而我们期望的结果是这样的 [A, A, B, A, C, A, A]，不同服务器可以穿插获取请求。为了增加负载均衡结果的平滑性，社区再次对 RoundRobinLoadBalance 的实现进行了重构，这次重构参考自 Nginx 的平滑加权轮询负载均衡。每个服务器对应两个权重，分别为 weight 和 currentWeight。其中 weight 是固定的，currentWeight 会动态调整，初始值为0。当有新的请求进来时，遍历服务器列表，让它的 currentWeight 加上自身权重。遍历完成后，找到最大的 currentWeight，并将其减去权重总和，然后返回相应的服务器即可。</p>
<p>上面描述不是很好理解，下面还是举例进行说明。这里仍然使用服务器 [A, B, C] 对应权重 [5, 1, 1] 的例子说明，现在有7个请求依次进入负载均衡逻辑，选择过程如下：</p>
<table>
<thead>
<tr>
<th>请求编号</th>
<th>currentWeight 数组</th>
<th>选择结果</th>
<th>减去权重总和后的 currentWeight 数组</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>[5, 1, 1]</td>
<td>A</td>
<td>[-2, 1, 1]</td>
</tr>
<tr>
<td>2</td>
<td>[3, 2, 2]</td>
<td>A</td>
<td>[-4, 2, 2]</td>
</tr>
<tr>
<td>3</td>
<td>[1, 3, 3]</td>
<td>B</td>
<td>[1, -4, 3]</td>
</tr>
<tr>
<td>4</td>
<td>[6, -3, 4]</td>
<td>A</td>
<td>[-1, -3, 4]</td>
</tr>
<tr>
<td>5</td>
<td>[4, -2, 5]</td>
<td>C</td>
<td>[4, -2, -2]</td>
</tr>
<tr>
<td>6</td>
<td>[9, -1, -1]</td>
<td>A</td>
<td>[2, -1, -1]</td>
</tr>
<tr>
<td>7</td>
<td>[7, 0, 0]</td>
<td>A</td>
<td>[0, 0, 0]</td>
</tr>
</tbody>
</table>
<p>如上，经过平滑性处理后，得到的服务器序列为 [A, A, B, A, C, A, A]，相比之前的序列 [A, A, A, A, A, B, C]，分布性要好一些。初始情况下 currentWeight = [0, 0, 0]，第7个请求处理完后，currentWeight 再次变为 [0, 0, 0]。</p>
<p>以上就是平滑加权轮询的计算过程，接下来，我们来看看 Dubbo-2.6.5 是如何实现上面的计算过程的。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoundRobinLoadBalance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLoadBalance</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NAME = <span class="hljs-string">"roundrobin"</span>;
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> RECYCLE_PERIOD = <span class="hljs-number">60000</span>;
    
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeightedRoundRobin</span> </span>{
        <span class="hljs-comment">// 服务提供者权重</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> weight;
        <span class="hljs-comment">// 当前权重</span>
        <span class="hljs-keyword">private</span> AtomicLong current = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);
        <span class="hljs-comment">// 最后一次更新时间</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> lastUpdate;
        
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> weight)</span> </span>{
            <span class="hljs-keyword">this</span>.weight = weight;
            <span class="hljs-comment">// 初始情况下，current = 0</span>
            current.set(<span class="hljs-number">0</span>);
        }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">increaseCurrent</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-comment">// current = current + weight；</span>
            <span class="hljs-keyword">return</span> current.addAndGet(weight);
        }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> total)</span> </span>{
            <span class="hljs-comment">// current = current - total;</span>
            current.addAndGet(-<span class="hljs-number">1</span> * total);
        }
    }

    <span class="hljs-comment">// 嵌套 Map 结构，存储的数据结构示例如下：</span>
    <span class="hljs-comment">// {</span>
    <span class="hljs-comment">//     "UserService.query": {</span>
    <span class="hljs-comment">//         "url1": WeightedRoundRobin@123, </span>
    <span class="hljs-comment">//         "url2": WeightedRoundRobin@456, </span>
    <span class="hljs-comment">//     },</span>
    <span class="hljs-comment">//     "UserService.update": {</span>
    <span class="hljs-comment">//         "url1": WeightedRoundRobin@123, </span>
    <span class="hljs-comment">//         "url2": WeightedRoundRobin@456,</span>
    <span class="hljs-comment">//     }</span>
    <span class="hljs-comment">// }</span>
    <span class="hljs-comment">// 最外层为服务类名 + 方法名，第二层为 url 到 WeightedRoundRobin 的映射关系。</span>
    <span class="hljs-comment">// 这里我们可以将 url 看成是服务提供者的 id</span>
    <span class="hljs-keyword">private</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt; methodWeightMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt;();
    
    <span class="hljs-comment">// 原子更新锁</span>
    <span class="hljs-keyword">private</span> AtomicBoolean updateLock = <span class="hljs-keyword">new</span> AtomicBoolean();
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doSelect</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>{
        String key = invokers.get(<span class="hljs-number">0</span>).getUrl().getServiceKey() + <span class="hljs-string">"."</span> + invocation.getMethodName();
        <span class="hljs-comment">// 获取 url 到 WeightedRoundRobin 映射表，如果为空，则创建一个新的</span>
        ConcurrentMap&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.get(key);
        <span class="hljs-keyword">if</span> (map == <span class="hljs-keyword">null</span>) {
            methodWeightMap.putIfAbsent(key, <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, WeightedRoundRobin&gt;());
            map = methodWeightMap.get(key);
        }
        <span class="hljs-keyword">int</span> totalWeight = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">long</span> maxCurrent = Long.MIN_VALUE;
        
        <span class="hljs-comment">// 获取当前时间</span>
        <span class="hljs-keyword">long</span> now = System.currentTimeMillis();
        Invoker&lt;T&gt; selectedInvoker = <span class="hljs-keyword">null</span>;
        WeightedRoundRobin selectedWRR = <span class="hljs-keyword">null</span>;

        <span class="hljs-comment">// 下面这个循环主要做了这样几件事情：</span>
        <span class="hljs-comment">//   1. 遍历 Invoker 列表，检测当前 Invoker 是否有</span>
        <span class="hljs-comment">//      相应的 WeightedRoundRobin，没有则创建</span>
        <span class="hljs-comment">//   2. 检测 Invoker 权重是否发生了变化，若变化了，</span>
        <span class="hljs-comment">//      则更新 WeightedRoundRobin 的 weight 字段</span>
        <span class="hljs-comment">//   3. 让 current 字段加上自身权重，等价于 current += weight</span>
        <span class="hljs-comment">//   4. 设置 lastUpdate 字段，即 lastUpdate = now</span>
        <span class="hljs-comment">//   5. 寻找具有最大 current 的 Invoker，以及 Invoker 对应的 WeightedRoundRobin，</span>
        <span class="hljs-comment">//      暂存起来，留作后用</span>
        <span class="hljs-comment">//   6. 计算权重总和</span>
        <span class="hljs-keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) {
            String identifyString = invoker.getUrl().toIdentityString();
            WeightedRoundRobin weightedRoundRobin = map.get(identifyString);
            <span class="hljs-keyword">int</span> weight = getWeight(invoker, invocation);
            <span class="hljs-keyword">if</span> (weight &lt; <span class="hljs-number">0</span>) {
                weight = <span class="hljs-number">0</span>;
            }
            
            <span class="hljs-comment">// 检测当前 Invoker 是否有对应的 WeightedRoundRobin，没有则创建</span>
            <span class="hljs-keyword">if</span> (weightedRoundRobin == <span class="hljs-keyword">null</span>) {
                weightedRoundRobin = <span class="hljs-keyword">new</span> WeightedRoundRobin();
                <span class="hljs-comment">// 设置 Invoker 权重</span>
                weightedRoundRobin.setWeight(weight);
                <span class="hljs-comment">// 存储 url 唯一标识 identifyString 到 weightedRoundRobin 的映射关系</span>
                map.putIfAbsent(identifyString, weightedRoundRobin);
                weightedRoundRobin = map.get(identifyString);
            }
            <span class="hljs-comment">// Invoker 权重不等于 WeightedRoundRobin 中保存的权重，说明权重变化了，此时进行更新</span>
            <span class="hljs-keyword">if</span> (weight != weightedRoundRobin.getWeight()) {
                weightedRoundRobin.setWeight(weight);
            }
            
            <span class="hljs-comment">// 让 current 加上自身权重，等价于 current += weight</span>
            <span class="hljs-keyword">long</span> cur = weightedRoundRobin.increaseCurrent();
            <span class="hljs-comment">// 设置 lastUpdate，表示近期更新过</span>
            weightedRoundRobin.setLastUpdate(now);
            <span class="hljs-comment">// 找出最大的 current </span>
            <span class="hljs-keyword">if</span> (cur &gt; maxCurrent) {
                maxCurrent = cur;
                <span class="hljs-comment">// 将具有最大 current 权重的 Invoker 赋值给 selectedInvoker</span>
                selectedInvoker = invoker;
                <span class="hljs-comment">// 将 Invoker 对应的 weightedRoundRobin 赋值给 selectedWRR，留作后用</span>
                selectedWRR = weightedRoundRobin;
            }
            
            <span class="hljs-comment">// 计算权重总和</span>
            totalWeight += weight;
        }

        <span class="hljs-comment">// 对 &lt;identifyString, WeightedRoundRobin&gt; 进行检查，过滤掉长时间未被更新的节点。</span>
        <span class="hljs-comment">// 该节点可能挂了，invokers 中不包含该节点，所以该节点的 lastUpdate 长时间无法被更新。</span>
        <span class="hljs-comment">// 若未更新时长超过阈值后，就会被移除掉，默认阈值为60秒。</span>
        <span class="hljs-keyword">if</span> (!updateLock.get() &amp;&amp; invokers.size() != map.size()) {
            <span class="hljs-keyword">if</span> (updateLock.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) {
                <span class="hljs-keyword">try</span> {
                    ConcurrentMap&lt;String, WeightedRoundRobin&gt; newMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, WeightedRoundRobin&gt;();
                    <span class="hljs-comment">// 拷贝</span>
                    newMap.putAll(map);
                    
                    <span class="hljs-comment">// 遍历修改，即移除过期记录</span>
                    Iterator&lt;Entry&lt;String, WeightedRoundRobin&gt;&gt; it = newMap.entrySet().iterator();
                    <span class="hljs-keyword">while</span> (it.hasNext()) {
                        Entry&lt;String, WeightedRoundRobin&gt; item = it.next();
                        <span class="hljs-keyword">if</span> (now - item.getValue().getLastUpdate() &gt; RECYCLE_PERIOD) {
                            it.remove();
                        }
                    }
                    
                    <span class="hljs-comment">// 更新引用</span>
                    methodWeightMap.put(key, newMap);
                } <span class="hljs-keyword">finally</span> {
                    updateLock.set(<span class="hljs-keyword">false</span>);
                }
            }
        }

        <span class="hljs-keyword">if</span> (selectedInvoker != <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// 让 current 减去权重总和，等价于 current -= totalWeight</span>
            selectedWRR.sel(totalWeight);
            <span class="hljs-comment">// 返回具有最大 current 的 Invoker</span>
            <span class="hljs-keyword">return</span> selectedInvoker;
        }
        
        <span class="hljs-comment">// should not happen here</span>
        <span class="hljs-keyword">return</span> invokers.get(<span class="hljs-number">0</span>);
    }
}
</code></pre>
<p>以上就是 Dubbo-2.6.5  版本的 RoundRobinLoadBalance，大家如果能够理解平滑加权轮询算法的计算过程，再配合代码中注释，理解上面的代码应该不难。</p>
<h2>3.总结</h2>
<p>本篇文章对 Dubbo 中的几种负载均衡实现进行了详细的分析，内容比较多，大家慢慢消化。理解负载均衡代码逻辑的关键之处在于对背景知识的理解，因此大家在阅读源码前，务必先了解每种负载均衡对应的背景知识。</p>
</div></section><footer class="footer-container"><div class="footer-body"><img src="/img/dubbo_gray.png"/><img class="apache" src="/img/apache_logo.png"/><div class="cols-container"><div class="col col-12"><h3>Disclaimer</h3><p>Apache Dubbo is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Incubator. Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.</p></div><div class="col col-4"><dl><dt>ASF</dt><dd><a href="http://www.apache.org" target="_self">基金会</a></dd><dd><a href="http://www.apache.org/licenses/" target="_self">证书</a></dd><dd><a href="http://www.apache.org/events/current-event" target="_self">事件</a></dd><dd><a href="http://www.apache.org/foundation/sponsorship.html" target="_self">赞助</a></dd><dd><a href="http://www.apache.org/foundation/thanks.html" target="_self">致谢</a></dd></dl></div><div class="col col-4"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/user/quick-start.html" target="_self">快速开始</a></dd><dd><a href="/zh-cn/docs/dev/build.html" target="_self">开发者指南</a></dd><dd><a href="/zh-cn/docs/admin/ops/dubbo-ops.html" target="_self">运维管理</a></dd></dl></div><div class="col col-4"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/community/index.html" target="_self">社区</a></dd><dd><a href="https://www.apache.org/security" target="_self">安全</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2018-2019 The Apache Software Foundation. Apache and the Apache feather logo are trademarks of The Apache Software Foundation.</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
  <script src="/build/documentation.js"></script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112489517-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-112489517-1');
	</script>
</body>
</html>