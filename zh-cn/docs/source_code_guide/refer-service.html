<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="Dubbo, service, refer" />
	<meta name="description" content="本文介绍了 Dubbo 服务引用的过程和实现细节" />
	<!-- 网页标签标题 -->
	<title>服务引用</title>
	<link rel="shortcut icon" href="/img/dubbo.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/dubbo_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/user/quick-start.html">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/docs/developers/developers_dev.html">开发者</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html">博客</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html">社区</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/download.html">下载</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/docs.png" class="front-img"/><span>文档</span><img src="/img/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>用户文档</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>入门<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/background.html" target="_self">背景</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/requirements.html" target="_self">需求</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/architecture.html" target="_self">架构</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/usage.html" target="_self">用法</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/quick-start.html" target="_self">快速启动</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/dependencies.html" target="_self">依赖</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/maturity.html" target="_self">成熟度</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>配置<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/xml.html" target="_self">XML配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/properties.html" target="_self">属性配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/api.html" target="_self">API配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/annotation.html" target="_self">注解配置</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>示例<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/preflight-check.html" target="_self">启动时检查</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/fault-tolerent-strategy.html" target="_self">集群容错</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/loadbalance.html" target="_self">负载均衡</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/thread-model.html" target="_self">线程模型</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/explicit-target.html" target="_self">直连提供者</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/subscribe-only.html" target="_self">只订阅</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/registry-only.html" target="_self">只注册</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/static-service.html" target="_self">静态服务</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/multi-protocols.html" target="_self">多协议</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/multi-registry.html" target="_self">多注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/service-group.html" target="_self">服务分组</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/multi-versions.html" target="_self">多版本</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/group-merger.html" target="_self">分组聚合</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/parameter-validation.html" target="_self">参数验证</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/result-cache.html" target="_self">结果缓存</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/generic-reference.html" target="_self">泛化引用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/generic-service.html" target="_self">泛化实现</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/echo-service.html" target="_self">回声测试</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/context.html" target="_self">上下文信息</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/attachment.html" target="_self">隐式参数</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/async-call.html" target="_self">异步调用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/local-call.html" target="_self">本地调用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/callback-parameter.html" target="_self">参数回调</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/events-notify.html" target="_self">事件通知</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/local-stub.html" target="_self">本地存根</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/local-mock.html" target="_self">本地伪装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/delay-publish.html" target="_self">延迟暴露</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/concurrency-control.html" target="_self">并发控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/config-connections.html" target="_self">连接控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/lazy-connect.html" target="_self">延迟连接</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/stickiness.html" target="_self">粘滞连接</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/token-authorization.html" target="_self">令牌验证</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/routing-rule.html" target="_self">路由规则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/config-rule.html" target="_self">配置规则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/service-downgrade.html" target="_self">服务降级</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/graceful-shutdown.html" target="_self">优雅停机</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/hostname-binding.html" target="_self">主机绑定</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/logger-strategy.html" target="_self">日志适配</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/accesslog.html" target="_self">访问日志</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/service-container.html" target="_self">服务容器</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/reference-config-cache.html" target="_self">Reference Config 缓存</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/distributed-transaction.html" target="_self">分布式事务</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/dump.html" target="_self">线程栈自动dump</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/netty4.html" target="_self">Netty4</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/serialization.html" target="_self">Kryo和FST序列化</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/api.html" target="_self">API配置参考手册</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>schema配置参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-service.html" target="_self">dubbo:service</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-reference.html" target="_self">dubbo:reference</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-protocol.html" target="_self">dubbo:protocol</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-registry.html" target="_self">dubbo:registry</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-monitor.html" target="_self">dubbo:monitor</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-application.html" target="_self">dubbo:application</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-module.html" target="_self">dubbo:module</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-provider.html" target="_self">dubbo:provider</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-consumer.html" target="_self">dubbo:consumer</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-method.html" target="_self">dubbo:method</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-argument.html" target="_self">dubbo:argument</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-parameter.html" target="_self">dubbo:parameter</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>协议参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/dubbo.html" target="_self">dubbo://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/rmi.html" target="_self">rmi://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/hessian.html" target="_self">hessian://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/http.html" target="_self">http://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/webservice.html" target="_self">webservice://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/thrift.html" target="_self">thrift://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/memcached.html" target="_self">memcached://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/redis.html" target="_self">redis://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/rest.html" target="_self">rest://</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>注册中心参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/multicast.html" target="_self">Multicast 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/zookeeper.html" target="_self">Zookeeper 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/redis.html" target="_self">Redis 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/simple.html" target="_self">Simple 注册中心</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/telnet.html" target="_self">telnet命令参考手册</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/qos.html" target="_self">在线运维命令-QOS</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/maven.html" target="_self">maven插件参考手册</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/best-practice.html" target="_self">服务化最佳实践</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/recommend.html" target="_self">推荐用法</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/capacity-plan.html" target="_self">容量规划</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/perf-test.html" target="_self">性能测试报告</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/coveragence.html" target="_self">测试覆盖率报告</a></li></ul></li><li class="menu-item menu-item-level-1"><span>开发者指南</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/build.html" target="_self">源码构建</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/design.html" target="_self">框架设计</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/SPI.html" target="_self">扩展点加载</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/implementation.html" target="_self">实现细节</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>SPI 扩展实现<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/protocol.html" target="_self">协议扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/filter.html" target="_self">调用拦截扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/invoker-listener.html" target="_self">引用监听扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/exporter-listener.html" target="_self">暴露监听扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/cluster.html" target="_self">集群扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/router.html" target="_self">路由扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/load-balance.html" target="_self">负载均衡扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/merger.html" target="_self">合并结果扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/registry.html" target="_self">注册中心扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/monitor.html" target="_self">监控中心扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/extension-factory.html" target="_self">扩展点加载扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/proxy-factory.html" target="_self">动态代理扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/compiler.html" target="_self">编译器扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/dispatcher.html" target="_self">消息派发扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/threadpool.html" target="_self">线程池扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/serialize.html" target="_self">序列化扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/remoting.html" target="_self">网络传输扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/exchanger.html" target="_self">信息交换扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/networker.html" target="_self">组网扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/telnet-handler.html" target="_self">Telnet 命令扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/status-checker.html" target="_self">状态检查扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/container.html" target="_self">容器扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/page.html" target="_self">页面扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/cache.html" target="_self">缓存扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/validation.html" target="_self">验证扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/logger-adapter.html" target="_self">日志适配扩展</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/contract.html" target="_self">公共契约</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/coding.html" target="_self">编码约定</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>设计原则<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/code-detail.html" target="_self">魔鬼在细节</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/general-knowledge.html" target="_self">一些设计上的基本常识</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/expansibility.html" target="_self">谈谈扩充式扩展与增量式扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/configuration.html" target="_self">配置设计</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/robustness.html" target="_self">设计实现的健壮性</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/dummy.html" target="_self">防痴呆设计</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/extension.html" target="_self">扩展点重构</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/release.html" target="_self">版本管理</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/contribution.html" target="_self">贡献</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/checklist.html" target="_self">检查列表</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/code-smell.html" target="_self">坏味道</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/TCK.html" target="_self">技术兼容性测试</a></li></ul></li><li class="menu-item menu-item-level-1"><span>运维管理</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>安装手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/provider-demo.html" target="_self">示例提供者安装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/consumer-demo.html" target="_self">示例消费者安装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/zookeeper.html" target="_self">Zookeeper 注册中心安装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/redis.html" target="_self">Redis 注册中心安装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/simple-registry-center.html" target="_self">Simple 注册中心安装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/simple-monitor-center.html" target="_self">Simple 监控中心安装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/admin-console.html" target="_self">管理控制台安装</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>运维手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/ops/dubbo-ops.html" target="_self">管理控制台运维</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/ops/pinpoint.html" target="_self">使用Pinpoint做分布式跟踪</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/ops/skywalking.html" target="_self">使用Skywalking做分布式跟踪</a></li></ul></li></ul></li></ul></div><div class="doc-content markdown-body"><h2>1. 简介</h2>
<p>上一篇文章详细分析了服务导出的过程，本篇文章我们趁热打铁，继续分析服务引用过程。在 Dubbo 中，我们可以通过两种方式引用远程服务。第一种是使用服务直联的方式引用服务，第二种方式是基于注册中心进行引用。服务直联的方式仅适合在调试或测试服务的场景下使用，不适合在线上环境使用。因此，本文我将重点分析通过注册中心引用服务的过程。从注册中心中获取服务配置只是服务引用过程中的一环，除此之外，服务消费者还需要经历 Invoker 创建、代理类创建等步骤。这些步骤，将在后续章节中一一进行分析。</p>
<h2>2.服务引用原理</h2>
<p>Dubbo 服务引用的时机有两个，第一个是在 Spring 容器调用 ReferenceBean 的 afterPropertiesSet 方法时引用服务，第二个是在 ReferenceBean 对应的服务被注入到其他类中时引用。这两个引用服务的时机区别在于，第一个是饿汉式的，第二个是懒汉式的。默认情况下，Dubbo 使用懒汉式引用服务。如果需要使用饿汉式，可通过配置 &lt;dubbo:reference&gt; 的 init 属性开启。下面我们按照 Dubbo 默认配置进行分析，整个分析过程从 ReferenceBean 的 getObject 方法开始。当我们的服务被注入到其他类中时，Spring 会第一时间调用 getObject 方法，并由该方法执行服务引用逻辑。按照惯例，在进行具体工作之前，需先进行配置检查与收集工作。接着根据收集到的信息决定服务用的方式，有三种，第一种是引用本地 (JVM) 服务，第二是通过直联方式引用远程服务，第三是通过注册中心引用远程服务。不管是哪种引用方式，最后都会得到一个 Invoker 实例。如果有多个注册中心，多个服务提供者，这个时候会得到一组 Invoker 实例，此时需要通过集群管理类 Cluster 将多个 Invoker 合并成一个实例。合并后的 Invoker 实例已经具备调用本地或远程服务的能力了，但并不能将此实例暴露给用户使用，这会对用户业务代码造成侵入。此时框架还需要通过代理工厂类 (ProxyFactory) 为服务接口生成代理类，并让代理类去调用 Invoker 逻辑。避免了 Dubbo 框架代码对业务代码的侵入，同时也让框架更容易使用。</p>
<p>以上就是服务引用的大致原理，下面我们深入到代码中，详细分析服务引用细节。</p>
<h2>3.源码分析</h2>
<p>服务引用的入口方法为 ReferenceBean 的 getObject 方法，该方法定义在 Spring 的 FactoryBean 接口中，ReferenceBean 实现了这个方法。实现代码如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-keyword">return</span> get();
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (destroyed) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Already destroyed!"</span>);
    }
    <span class="hljs-comment">// 检测 ref 是否为空，为空则通过 init 方法创建</span>
    <span class="hljs-keyword">if</span> (ref == <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// init 方法主要用于处理配置，以及调用 createProxy 生成代理类</span>
        init();
    }
    <span class="hljs-keyword">return</span> ref;
}
</code></pre>
<p>以上两个方法的代码比较简短，并不难理解。这里需要特别说明一下，如果你对 2.6.4 及以下版本的 getObject 方法进行调试时，会碰到比较奇怪的的问题。这里假设你使用 IDEA，且保持了 IDEA 的默认配置。当你面调试到 get 方法的<code>if (ref == null)</code>时，你会发现 ref 不为空，导致你无法进入到 init 方法中继续调试。导致这个现象的原因是 Dubbo 框架本身有一些小问题。该问题已经在 pull request <a href="https://github.com/apache/incubator-dubbo/pull/2754">#2754</a> 修复了此问题，并跟随 2.6.5 版本发布了。如果你正在学习 2.6.4 及以下版本，可通过修改 IDEA 配置规避这个问题。首先 IDEA 配置弹窗中搜索 toString，然后取消<code>Enable 'toString' object view</code>勾选。具体如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15417503733794.jpg" alt=""></p>
<h3>3.1 处理配置</h3>
<p>Dubbo 提供了丰富的配置，用于调整和优化框架行为，性能等。Dubbo 在引用或导出服务时，首先会对这些配置进行检查和处理，以保证配置到正确性。配置解析逻辑封装在 ReferenceConfig 的 init 方法中，下面进行分析。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 避免重复初始化</span>
    <span class="hljs-keyword">if</span> (initialized) {
        <span class="hljs-keyword">return</span>;
    }
    initialized = <span class="hljs-keyword">true</span>;
    <span class="hljs-comment">// 检测接口名合法性</span>
    <span class="hljs-keyword">if</span> (interfaceName == <span class="hljs-keyword">null</span> || interfaceName.length() == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"interface not allow null!"</span>);
    }

    <span class="hljs-comment">// 检测 consumer 变量是否为空，为空则创建</span>
    checkDefault();
    appendProperties(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">if</span> (getGeneric() == <span class="hljs-keyword">null</span> &amp;&amp; getConsumer() != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// 设置 generic</span>
        setGeneric(getConsumer().getGeneric());
    }

    <span class="hljs-comment">// 检测是否为泛化接口</span>
    <span class="hljs-keyword">if</span> (ProtocolUtils.isGeneric(getGeneric())) {
        interfaceClass = GenericService.class;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 加载类</span>
            interfaceClass = Class.forName(interfaceName, <span class="hljs-keyword">true</span>, Thread.currentThread()
                    .getContextClassLoader());
        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(e.getMessage(), e);
        }
        checkInterfaceAndMethods(interfaceClass, methods);
    }
    
    <span class="hljs-comment">// -------------------------------✨ 分割线1 ✨------------------------------</span>

    <span class="hljs-comment">// 从系统变量中获取与接口名对应的属性值</span>
    String resolve = System.getProperty(interfaceName);
    String resolveFile = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">if</span> (resolve == <span class="hljs-keyword">null</span> || resolve.length() == <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 从系统属性中获取解析文件路径</span>
        resolveFile = System.getProperty(<span class="hljs-string">"dubbo.resolve.file"</span>);
        <span class="hljs-keyword">if</span> (resolveFile == <span class="hljs-keyword">null</span> || resolveFile.length() == <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// 从指定位置加载配置文件</span>
            File userResolveFile = <span class="hljs-keyword">new</span> File(<span class="hljs-keyword">new</span> File(System.getProperty(<span class="hljs-string">"user.home"</span>)), <span class="hljs-string">"dubbo-resolve.properties"</span>);
            <span class="hljs-keyword">if</span> (userResolveFile.exists()) {
                <span class="hljs-comment">// 获取文件绝对路径</span>
                resolveFile = userResolveFile.getAbsolutePath();
            }
        }
        <span class="hljs-keyword">if</span> (resolveFile != <span class="hljs-keyword">null</span> &amp;&amp; resolveFile.length() &gt; <span class="hljs-number">0</span>) {
            Properties properties = <span class="hljs-keyword">new</span> Properties();
            FileInputStream fis = <span class="hljs-keyword">null</span>;
            <span class="hljs-keyword">try</span> {
                fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(resolveFile));
                <span class="hljs-comment">// 从文件中加载配置</span>
                properties.load(fis);
            } <span class="hljs-keyword">catch</span> (IOException e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Unload ..., cause:..."</span>);
            } <span class="hljs-keyword">finally</span> {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != fis) fis.close();
                } <span class="hljs-keyword">catch</span> (IOException e) {
                    logger.warn(e.getMessage(), e);
                }
            }
            <span class="hljs-comment">// 获取与接口名对应的配置</span>
            resolve = properties.getProperty(interfaceName);
        }
    }
    <span class="hljs-keyword">if</span> (resolve != <span class="hljs-keyword">null</span> &amp;&amp; resolve.length() &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 将 resolve 赋值给 url</span>
        url = resolve;
    }
    
    <span class="hljs-comment">// -------------------------------✨ 分割线2 ✨------------------------------</span>
    <span class="hljs-keyword">if</span> (consumer != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (application == <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// 从 consumer 中获取 Application 实例，下同</span>
            application = consumer.getApplication();
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">module</span> == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">module</span> = consumer.getModule();
        }
        <span class="hljs-keyword">if</span> (registries == <span class="hljs-keyword">null</span>) {
            registries = consumer.getRegistries();
        }
        <span class="hljs-keyword">if</span> (monitor == <span class="hljs-keyword">null</span>) {
            monitor = consumer.getMonitor();
        }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">module</span> != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (registries == <span class="hljs-keyword">null</span>) {
            registries = <span class="hljs-keyword">module</span>.getRegistries();
        }
        <span class="hljs-keyword">if</span> (monitor == <span class="hljs-keyword">null</span>) {
            monitor = <span class="hljs-keyword">module</span>.getMonitor();
        }
    }
    <span class="hljs-keyword">if</span> (application != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (registries == <span class="hljs-keyword">null</span>) {
            registries = application.getRegistries();
        }
        <span class="hljs-keyword">if</span> (monitor == <span class="hljs-keyword">null</span>) {
            monitor = application.getMonitor();
        }
    }
    
    <span class="hljs-comment">// 检测 Application 合法性</span>
    checkApplication();
    <span class="hljs-comment">// 检测本地存根配置合法性</span>
    checkStubAndMock(interfaceClass);
    
	<span class="hljs-comment">// -------------------------------✨ 分割线3 ✨------------------------------</span>
    
    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();
    Map&lt;Object, Object&gt; attributes = <span class="hljs-keyword">new</span> HashMap&lt;Object, Object&gt;();

    <span class="hljs-comment">// 添加 side、协议版本信息、时间戳和进程号等信息到 map 中</span>
    map.put(Constants.SIDE_KEY, Constants.CONSUMER_SIDE);
    map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());
    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));
    <span class="hljs-keyword">if</span> (ConfigUtils.getPid() &gt; <span class="hljs-number">0</span>) {
        map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));
    }

    <span class="hljs-comment">// 非泛化服务</span>
    <span class="hljs-keyword">if</span> (!isGeneric()) {
        <span class="hljs-comment">// 获取版本</span>
        String revision = Version.getVersion(interfaceClass, version);
        <span class="hljs-keyword">if</span> (revision != <span class="hljs-keyword">null</span> &amp;&amp; revision.length() &gt; <span class="hljs-number">0</span>) {
            map.put(<span class="hljs-string">"revision"</span>, revision);
        }

        <span class="hljs-comment">// 获取接口方法列表，并添加到 map 中</span>
        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();
        <span class="hljs-keyword">if</span> (methods.length == <span class="hljs-number">0</span>) {
            map.put(<span class="hljs-string">"methods"</span>, Constants.ANY_VALUE);
        } <span class="hljs-keyword">else</span> {
            map.put(<span class="hljs-string">"methods"</span>, StringUtils.join(<span class="hljs-keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="hljs-string">","</span>));
        }
    }
    map.put(Constants.INTERFACE_KEY, interfaceName);
    <span class="hljs-comment">// 将 ApplicationConfig、ConsumerConfig、ReferenceConfig 等对象的字段信息添加到 map 中</span>
    appendParameters(map, application);
    appendParameters(map, <span class="hljs-keyword">module</span>);
    appendParameters(map, consumer, Constants.DEFAULT_KEY);
    appendParameters(map, <span class="hljs-keyword">this</span>);
    
	<span class="hljs-comment">// -------------------------------✨ 分割线4 ✨------------------------------</span>
    
    String prefix = StringUtils.getServiceKey(map);
    <span class="hljs-keyword">if</span> (methods != <span class="hljs-keyword">null</span> &amp;&amp; !methods.isEmpty()) {
        <span class="hljs-comment">// 遍历 MethodConfig 列表</span>
        <span class="hljs-keyword">for</span> (MethodConfig method : methods) {
            appendParameters(map, method, method.getName());
            String retryKey = method.getName() + <span class="hljs-string">".retry"</span>;
            <span class="hljs-comment">// 检测 map 是否包含 methodName.retry</span>
            <span class="hljs-keyword">if</span> (map.containsKey(retryKey)) {
                String retryValue = map.remove(retryKey);
                <span class="hljs-keyword">if</span> (<span class="hljs-string">"false"</span>.equals(retryValue)) {
                    <span class="hljs-comment">// 添加重试次数配置 methodName.retries</span>
                    map.put(method.getName() + <span class="hljs-string">".retries"</span>, <span class="hljs-string">"0"</span>);
                }
            }
 
            <span class="hljs-comment">// 添加 MethodConfig 中的“属性”字段到 attributes</span>
            <span class="hljs-comment">// 比如 onreturn、onthrow、oninvoke 等</span>
            appendAttributes(attributes, method, prefix + <span class="hljs-string">"."</span> + method.getName());
            checkAndConvertImplicitConfig(method, map, attributes);
        }
    }
    
	<span class="hljs-comment">// -------------------------------✨ 分割线5 ✨------------------------------</span>

    <span class="hljs-comment">// 获取服务消费者 ip 地址</span>
    String hostToRegistry = ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY);
    <span class="hljs-keyword">if</span> (hostToRegistry == <span class="hljs-keyword">null</span> || hostToRegistry.length() == <span class="hljs-number">0</span>) {
        hostToRegistry = NetUtils.getLocalHost();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isInvalidLocalHost(hostToRegistry)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Specified invalid registry ip from property..."</span> );
    }
    map.put(Constants.REGISTER_IP_KEY, hostToRegistry);

    <span class="hljs-comment">// 存储 attributes 到系统上下文中</span>
    StaticContext.getSystemContext().putAll(attributes);

    <span class="hljs-comment">// 创建代理类</span>
    ref = createProxy(map);

    <span class="hljs-comment">// 根据服务名，ReferenceConfig，代理类构建 ConsumerModel，</span>
    <span class="hljs-comment">// 并将 ConsumerModel 存入到 ApplicationModel 中</span>
    ConsumerModel consumerModel = <span class="hljs-keyword">new</span> ConsumerModel(getUniqueServiceName(), <span class="hljs-keyword">this</span>, ref, interfaceClass.getMethods());
    ApplicationModel.initConsumerModel(getUniqueServiceName(), consumerModel);
}
</code></pre>
<p>上面的代码很长，做的事情比较多。这里根据代码逻辑，对代码进行了分块，下面我们一起来看一下。</p>
<p>首先是方法开始到分割线1之间的代码。这段代码主要用于检测 ConsumerConfig 实例是否存在，如不存在则创建一个新的实例，然后通过系统变量或 dubbo.properties 配置文件填充 ConsumerConfig 的字段。接着是检测泛化配置，并根据配置设置 interfaceClass 的值。接着来看分割线1到分割线2之间的逻辑。这段逻辑用于从系统属性或配置文件中加载与接口名相对应的配置，并将解析结果赋值给 url 字段。url 字段的作用一般是用于点对点调用。继续向下看，分割线2和分割线3之间的代码用于检测几个核心配置类是否为空，为空则尝试从其他配置类中获取。分割线3与分割线4之间的代码主要用于收集各种配置，并将配置存储到 map 中。分割线4和分割线5之间的代码用于处理 MethodConfig 实例。该实例包含了事件通知配置，比如 onreturn、onthrow、oninvoke 等。分割线5到方法结尾的代码主要用于解析服务消费者 ip，以及调用 createProxy 创建代理对象。关于该方法的详细分析，将会在接下来的章节中展开。</p>
<h3>3.2 引用服务</h3>
<p>本节我们要从 createProxy 开始看起。从字面意思上来看，createProxy 似乎只是用于创建代理对象的。但实际上并非如此，该方法还会调用其他方法构建以及合并 Invoker 实例。具体细节如下。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">createProxy</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> </span>{
    URL tmpUrl = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">"temp"</span>, <span class="hljs-string">"localhost"</span>, <span class="hljs-number">0</span>, map);
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isJvmRefer;
    <span class="hljs-keyword">if</span> (isInjvm() == <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// url 配置被指定，则不做本地引用</span>
        <span class="hljs-keyword">if</span> (url != <span class="hljs-keyword">null</span> &amp;&amp; url.length() &gt; <span class="hljs-number">0</span>) {
            isJvmRefer = <span class="hljs-keyword">false</span>;
        <span class="hljs-comment">// 根据 url 的协议、scope 以及 injvm 等参数检测是否需要本地引用</span>
        <span class="hljs-comment">// 比如如果用户显式配置了 scope=local，此时 isInjvmRefer 返回 true</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (InjvmProtocol.getInjvmProtocol().isInjvmRefer(tmpUrl)) {
            isJvmRefer = <span class="hljs-keyword">true</span>;
        } <span class="hljs-keyword">else</span> {
            isJvmRefer = <span class="hljs-keyword">false</span>;
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 获取 injvm 配置值</span>
        isJvmRefer = isInjvm().booleanValue();
    }

    <span class="hljs-comment">// 本地引用</span>
    <span class="hljs-keyword">if</span> (isJvmRefer) {
        <span class="hljs-comment">// 生成本地引用 URL，协议为 injvm</span>
        URL url = <span class="hljs-keyword">new</span> URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, <span class="hljs-number">0</span>, interfaceClass.getName()).addParameters(map);
        <span class="hljs-comment">// 调用 refer 方法构建 InjvmInvoker 实例</span>
        invoker = refprotocol.refer(interfaceClass, url);
        
    <span class="hljs-comment">// 远程引用</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// url 不为空，表明用户可能想进行点对点调用</span>
        <span class="hljs-keyword">if</span> (url != <span class="hljs-keyword">null</span> &amp;&amp; url.length() &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// 当需要配置多个 url 时，可用分号进行分割，这里会进行切分</span>
            String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);
            <span class="hljs-keyword">if</span> (us != <span class="hljs-keyword">null</span> &amp;&amp; us.length &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">for</span> (String u : us) {
                    URL url = URL.valueOf(u);
                    <span class="hljs-keyword">if</span> (url.getPath() == <span class="hljs-keyword">null</span> || url.getPath().length() == <span class="hljs-number">0</span>) {
                        <span class="hljs-comment">// 设置接口全限定名为 url 路径</span>
                        url = url.setPath(interfaceName);
                    }
                    
                    <span class="hljs-comment">// 检测 url 协议是否为 registry，若是，表明用户想使用指定的注册中心</span>
                    <span class="hljs-keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {
                        <span class="hljs-comment">// 将 map 转换为查询字符串，并作为 refer 参数的值添加到 url 中</span>
                        urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-comment">// 合并 url，移除服务提供者的一些配置（这些配置来源于用户配置的 url 属性），</span>
                        <span class="hljs-comment">// 比如线程池相关配置。并保留服务提供者的部分配置，比如版本，group，时间戳等</span>
                        <span class="hljs-comment">// 最后将合并后的配置设置为 url 查询字符串中。</span>
                        urls.add(ClusterUtils.mergeUrl(url, map));
                    }
                }
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 加载注册中心 url</span>
            List&lt;URL&gt; us = loadRegistries(<span class="hljs-keyword">false</span>);
            <span class="hljs-keyword">if</span> (us != <span class="hljs-keyword">null</span> &amp;&amp; !us.isEmpty()) {
                <span class="hljs-keyword">for</span> (URL u : us) {
                    URL monitorUrl = loadMonitor(u);
                    <span class="hljs-keyword">if</span> (monitorUrl != <span class="hljs-keyword">null</span>) {
                        map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));
                    }
                    <span class="hljs-comment">// 添加 refer 参数到 url 中，并将 url 添加到 urls 中</span>
                    urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));
                }
            }

            <span class="hljs-comment">// 未配置注册中心，抛出异常</span>
            <span class="hljs-keyword">if</span> (urls.isEmpty()) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No such any registry to reference..."</span>);
            }
        }

        <span class="hljs-comment">// 单个注册中心或服务提供者(服务直联，下同)</span>
        <span class="hljs-keyword">if</span> (urls.size() == <span class="hljs-number">1</span>) {
            <span class="hljs-comment">// 调用 RegistryProtocol 的 refer 构建 Invoker 实例</span>
            invoker = refprotocol.refer(interfaceClass, urls.get(<span class="hljs-number">0</span>));
            
        <span class="hljs-comment">// 多个注册中心或多个服务提供者，或者两者混合</span>
        } <span class="hljs-keyword">else</span> {
            List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="hljs-keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();
            URL registryURL = <span class="hljs-keyword">null</span>;

            <span class="hljs-comment">// 获取所有的 Invoker</span>
            <span class="hljs-keyword">for</span> (URL url : urls) {
                <span class="hljs-comment">// 通过 refprotocol 调用 refer 构建 Invoker，refprotocol 会在运行时</span>
                <span class="hljs-comment">// 根据 url 协议头加载指定的 Protocol 实例，并调用实例的 refer 方法</span>
                invokers.add(refprotocol.refer(interfaceClass, url));
                <span class="hljs-keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {
                    registryURL = url;
                }
            }
            <span class="hljs-keyword">if</span> (registryURL != <span class="hljs-keyword">null</span>) {
                <span class="hljs-comment">// 如果注册中心链接不为空，则将使用 AvailableCluster</span>
                URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);
                <span class="hljs-comment">// 创建 StaticDirectory 实例，并由 Cluster 对多个 Invoker 进行合并</span>
                invoker = cluster.join(<span class="hljs-keyword">new</span> StaticDirectory(u, invokers));
            } <span class="hljs-keyword">else</span> {
                invoker = cluster.join(<span class="hljs-keyword">new</span> StaticDirectory(invokers));
            }
        }
    }

    Boolean c = check;
    <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span> &amp;&amp; consumer != <span class="hljs-keyword">null</span>) {
        c = consumer.isCheck();
    }
    <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) {
        c = <span class="hljs-keyword">true</span>;
    }
    
    <span class="hljs-comment">// invoker 可用性检查</span>
    <span class="hljs-keyword">if</span> (c &amp;&amp; !invoker.isAvailable()) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No provider available for the service..."</span>);
    }

    <span class="hljs-comment">// 生成代理类</span>
    <span class="hljs-keyword">return</span> (T) proxyFactory.getProxy(invoker);
}
</code></pre>
<p>上面代码很多，不过逻辑比较清晰。首先根据配置检查是否为本地调用，若是，则调用 InjvmProtocol 的 refer 方法生成 InjvmInvoker 实例。若不是，则读取直联配置项，或注册中心 url，并将读取到的 url 存储到 urls 中。然后根据 urls 元素数量进行后续操作。若 urls 元素数量为1，则直接通过 Protocol 自适应拓展类构建 Invoker 实例接口。若 urls 元素数量大于1，即存在多个注册中心或服务直联 url，此时先根据 url 构建 Invoker。然后再通过 Cluster 合并多个 Invoker，最后调用 ProxyFactory 生成代理类。Invoker 的构建过程以及代理类的过程比较重要，因此接下来将分两小节对这两个过程进行分析。</p>
<h4>3.2.1 创建 Invoker</h4>
<p>Invoker 是 Dubbo 的核心模型，代表一个可执行体。在服务提供方，Invoker 用于调用服务提供类。在服务消费方，Invoker 用于执行远程调用。Invoker 是由 Protocol 实现类构建而来。Protocol 实现类有很多，本节会分析最常用的两个，分别是 RegistryProtocol 和 DubboProtocol，其他的大家自行分析。下面先来分析 DubboProtocol 的 refer 方法源码。如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">refer</span><span class="hljs-params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="hljs-keyword">throws</span> RpcException </span>{
    optimizeSerialization(url);
    <span class="hljs-comment">// 创建 DubboInvoker</span>
    DubboInvoker&lt;T&gt; invoker = <span class="hljs-keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);
    invokers.add(invoker);
    <span class="hljs-keyword">return</span> invoker;
}
</code></pre>
<p>上面方法看起来比较简单，不过这里有一个调用需要我们注意一下，即  getClients。这个方法用于获取客户端实例，实例类型为 ExchangeClient。ExchangeClient 实际上并不具备通信能力，它需要基于更底层的客户端实例进行通信。比如 NettyClient、MinaClient 等，默认情况下，Dubbo 使用 NettyClient 进行通信。接下来，我们简单看一下 getClients 方法的逻辑。</p>
<pre><code class="language-java"><span class="hljs-keyword">private</span> ExchangeClient[] getClients(URL url) {
    <span class="hljs-comment">// 是否共享连接</span>
    <span class="hljs-keyword">boolean</span> service_share_connect = <span class="hljs-keyword">false</span>;
  	<span class="hljs-comment">// 获取连接数，默认为0，表示未配置</span>
    <span class="hljs-keyword">int</span> connections = url.getParameter(Constants.CONNECTIONS_KEY, <span class="hljs-number">0</span>);
    <span class="hljs-comment">// 如果未配置 connections，则共享连接</span>
    <span class="hljs-keyword">if</span> (connections == <span class="hljs-number">0</span>) {
        service_share_connect = <span class="hljs-keyword">true</span>;
        connections = <span class="hljs-number">1</span>;
    }

    ExchangeClient[] clients = <span class="hljs-keyword">new</span> ExchangeClient[connections];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; clients.length; i++) {
        <span class="hljs-keyword">if</span> (service_share_connect) {
            <span class="hljs-comment">// 获取共享客户端</span>
            clients[i] = getSharedClient(url);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 初始化新的客户端</span>
            clients[i] = initClient(url);
        }
    }
    <span class="hljs-keyword">return</span> clients;
}
</code></pre>
<p>这里根据 connections 数量决定是获取共享客户端还是创建新的客户端实例，默认情况下，使用共享客户端实例。getSharedClient 方法中也会调用 initClient 方法，因此下面我们一起看一下这两个方法。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">private</span> ExchangeClient <span class="hljs-title">getSharedClient</span><span class="hljs-params">(URL url)</span> </span>{
    String key = url.getAddress();
    <span class="hljs-comment">// 获取带有“引用计数”功能的 ExchangeClient</span>
    ReferenceCountExchangeClient client = referenceClientMap.get(key);
    <span class="hljs-keyword">if</span> (client != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (!client.isClosed()) {
            <span class="hljs-comment">// 增加引用计数</span>
            client.incrementAndGetCount();
            <span class="hljs-keyword">return</span> client;
        } <span class="hljs-keyword">else</span> {
            referenceClientMap.remove(key);
        }
    }

    locks.putIfAbsent(key, <span class="hljs-keyword">new</span> Object());
    <span class="hljs-keyword">synchronized</span> (locks.get(key)) {
        <span class="hljs-keyword">if</span> (referenceClientMap.containsKey(key)) {
            <span class="hljs-keyword">return</span> referenceClientMap.get(key);
        }

        <span class="hljs-comment">// 创建 ExchangeClient 客户端</span>
        ExchangeClient exchangeClient = initClient(url);
        <span class="hljs-comment">// 将 ExchangeClient 实例传给 ReferenceCountExchangeClient，这里使用了装饰模式</span>
        client = <span class="hljs-keyword">new</span> ReferenceCountExchangeClient(exchangeClient, ghostClientMap);
        referenceClientMap.put(key, client);
        ghostClientMap.remove(key);
        locks.remove(key);
        <span class="hljs-keyword">return</span> client;
    }
}
</code></pre>
<p>上面方法先访问缓存，若缓存未命中，则通过 initClient 方法创建新的 ExchangeClient 实例，并将该实例传给 ReferenceCountExchangeClient 构造方法创建一个带有引用计数功能的 ExchangeClient 实例。ReferenceCountExchangeClient 内部实现比较简单，就不分析了。下面我们再来看一下 initClient 方法的代码。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">private</span> ExchangeClient <span class="hljs-title">initClient</span><span class="hljs-params">(URL url)</span> </span>{

    <span class="hljs-comment">// 获取客户端类型，默认为 netty</span>
    String str = url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT));

    <span class="hljs-comment">// 添加编解码和心跳包参数到 url 中</span>
    url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);
    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));

    <span class="hljs-comment">// 检测客户端类型是否存在，不存在则抛出异常</span>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-keyword">null</span> &amp;&amp; str.length() &gt; <span class="hljs-number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">"Unsupported client type: ..."</span>);
    }

    ExchangeClient client;
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 获取 lazy 配置，并根据配置值决定创建的客户端类型</span>
        <span class="hljs-keyword">if</span> (url.getParameter(Constants.LAZY_CONNECT_KEY, <span class="hljs-keyword">false</span>)) {
            <span class="hljs-comment">// 创建懒加载 ExchangeClient 实例</span>
            client = <span class="hljs-keyword">new</span> LazyConnectExchangeClient(url, requestHandler);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 创建普通 ExchangeClient 实例</span>
            client = Exchangers.connect(url, requestHandler);
        }
    } <span class="hljs-keyword">catch</span> (RemotingException e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">"Fail to create remoting client for service..."</span>);
    }
    <span class="hljs-keyword">return</span> client;
}
</code></pre>
<p>initClient 方法首先获取用户配置的客户端类型，默认为 netty。然后检测用户配置的客户端类型是否存在，不存在则抛出异常。最后根据 lazy 配置决定创建什么类型的客户端。这里的 LazyConnectExchangeClient 代码并不是很复杂，该类会在 request 方法被调用时通过 Exchangers 的 connect 方法创建 ExchangeClient 客户端，该类的代码本节就不分析了。下面我们分析一下 Exchangers 的 connect 方法。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExchangeClient <span class="hljs-title">connect</span><span class="hljs-params">(URL url, ExchangeHandler handler)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
    <span class="hljs-keyword">if</span> (url == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"url == null"</span>);
    }
    <span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"handler == null"</span>);
    }
    url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="hljs-string">"exchange"</span>);
    <span class="hljs-comment">// 获取 Exchanger 实例，默认为 HeaderExchangeClient</span>
    <span class="hljs-keyword">return</span> getExchanger(url).connect(url, handler);
}
</code></pre>
<p>如上，getExchanger 会通过 SPI 加载 HeaderExchangeClient 实例，这个方法比较简单，大家自己看一下吧。接下来分析 HeaderExchangeClient 的实现。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> ExchangeClient <span class="hljs-title">connect</span><span class="hljs-params">(URL url, ExchangeHandler handler)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
    <span class="hljs-comment">// 这里包含了多个调用，分别如下：</span>
    <span class="hljs-comment">// 1. 创建 HeaderExchangeHandler 对象</span>
    <span class="hljs-comment">// 2. 创建 DecodeHandler 对象</span>
    <span class="hljs-comment">// 3. 通过 Transporters 构建 Client 实例</span>
    <span class="hljs-comment">// 4. 创建 HeaderExchangeClient 对象</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeaderExchangeClient(Transporters.connect(url, <span class="hljs-keyword">new</span> DecodeHandler(<span class="hljs-keyword">new</span> HeaderExchangeHandler(handler))), <span class="hljs-keyword">true</span>);
}
</code></pre>
<p>这里的调用比较多，我们这里重点看一下 Transporters 的 connect 方法。如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Client <span class="hljs-title">connect</span><span class="hljs-params">(URL url, ChannelHandler... handlers)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
    <span class="hljs-keyword">if</span> (url == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"url == null"</span>);
    }
    ChannelHandler handler;
    <span class="hljs-keyword">if</span> (handlers == <span class="hljs-keyword">null</span> || handlers.length == <span class="hljs-number">0</span>) {
        handler = <span class="hljs-keyword">new</span> ChannelHandlerAdapter();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (handlers.length == <span class="hljs-number">1</span>) {
        handler = handlers[<span class="hljs-number">0</span>];
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 如果 handler 数量大于1，则创建一个 ChannelHandler 分发器</span>
        handler = <span class="hljs-keyword">new</span> ChannelHandlerDispatcher(handlers);
    }
    
    <span class="hljs-comment">// 获取 Transporter 自适应拓展类，并调用 connect 方法生成 Client 实例</span>
    <span class="hljs-keyword">return</span> getTransporter().connect(url, handler);
}
</code></pre>
<p>如上，getTransporter 方法返回的是自适应拓展类，该类会在运行时根据客户端类型加载指定的 Transporter 实现类。若用户未配置客户端类型，则默认加载 NettyTransporter，并调用该类的 connect 方法。如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> Client <span class="hljs-title">connect</span><span class="hljs-params">(URL url, ChannelHandler listener)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
    <span class="hljs-comment">// 创建 NettyClient 对象</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NettyClient(url, listener);
}
</code></pre>
<p>到这里就不继续跟下去了，在往下就是通过 Netty 提供的 API 构建 Netty 客户端了，大家有兴趣自己看看。到这里，关于 DubboProtocol 的 refer 方法就分析完了。接下来，继续分析 RegistryProtocol 的 refer 方法逻辑。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">refer</span><span class="hljs-params">(Class&lt;T&gt; type, URL url)</span> <span class="hljs-keyword">throws</span> RpcException </span>{
    <span class="hljs-comment">// 取 registry 参数值，并将其设置为协议头</span>
    url = url.setProtocol(url.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)).removeParameter(Constants.REGISTRY_KEY);
    <span class="hljs-comment">// 获取注册中心实例</span>
    Registry registry = registryFactory.getRegistry(url);
    <span class="hljs-keyword">if</span> (RegistryService.class.equals(type)) {
        <span class="hljs-keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);
    }

    <span class="hljs-comment">// 将 url 查询字符串转为 Map</span>
    Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));
    <span class="hljs-comment">// 获取 group 配置</span>
    String group = qs.get(Constants.GROUP_KEY);
    <span class="hljs-keyword">if</span> (group != <span class="hljs-keyword">null</span> &amp;&amp; group.length() &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> ((Constants.COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="hljs-number">1</span>
                || <span class="hljs-string">"*"</span>.equals(group)) {
            <span class="hljs-comment">// 通过 SPI 加载 MergeableCluster 实例，并调用 doRefer 继续执行服务引用逻辑</span>
            <span class="hljs-keyword">return</span> doRefer(getMergeableCluster(), registry, type, url);
        }
    }
    
    <span class="hljs-comment">// 调用 doRefer 继续执行服务引用逻辑</span>
    <span class="hljs-keyword">return</span> doRefer(cluster, registry, type, url);
}
</code></pre>
<p>上面代码首先为 url 设置协议头，然后根据 url 参数加载注册中心实例。然后获取 group 配置，根据 group 配置决定 doRefer 第一个参数的类型。这里的重点是 doRefer 方法，如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doRefer</span><span class="hljs-params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>{
    <span class="hljs-comment">// 创建 RegistryDirectory 实例</span>
    RegistryDirectory&lt;T&gt; directory = <span class="hljs-keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);
    <span class="hljs-comment">// 设置注册中心和协议</span>
    directory.setRegistry(registry);
    directory.setProtocol(protocol);
    Map&lt;String, String&gt; parameters = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());
    <span class="hljs-comment">// 生成服务消费者链接</span>
    URL subscribeUrl = <span class="hljs-keyword">new</span> URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), <span class="hljs-number">0</span>, type.getName(), parameters);

    <span class="hljs-comment">// 注册服务消费者，在 consumers 目录下新节点</span>
    <span class="hljs-keyword">if</span> (!Constants.ANY_VALUE.equals(url.getServiceInterface())
            &amp;&amp; url.getParameter(Constants.REGISTER_KEY, <span class="hljs-keyword">true</span>)) {
        registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,
                Constants.CHECK_KEY, String.valueOf(<span class="hljs-keyword">false</span>)));
    }

    <span class="hljs-comment">// 订阅 providers、configurators、routers 等节点数据</span>
    directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,
            Constants.PROVIDERS_CATEGORY
                    + <span class="hljs-string">","</span> + Constants.CONFIGURATORS_CATEGORY
                    + <span class="hljs-string">","</span> + Constants.ROUTERS_CATEGORY));

    <span class="hljs-comment">// 一个注册中心可能有多个服务提供者，因此这里需要将多个服务提供者合并为一个</span>
    Invoker invoker = cluster.join(directory);
    ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);
    <span class="hljs-keyword">return</span> invoker;
}
</code></pre>
<p>如上，doRefer 方法创建一个 RegistryDirectory 实例，然后生成服务者消费者链接，并向注册中心进行注册。注册完毕后，紧接着订阅 providers、configurators、routers 等节点下的数据。完成订阅后，RegistryDirectory 会收到这几个节点下的子节点信息。由于一个服务可能部署在多台服务器上，这样就会在  providers 产生多个节点，这个时候就需要 Cluster 将多个服务节点合并为一个，并生成一个 Invoker。关于 RegistryDirectory 和 Cluster，本文不打算进行分析，相关分析将会在随后的文章中展开。</p>
<h4>3.2.2 创建代理</h4>
<p>Invoker 创建完毕后，接下来要做的事情是为服务接口生成代理对象。有了代理对象，即可进行远程调用。代理对象生成的入口方法为 ProxyFactory 的 getProxy，接下来进行分析。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Invoker&lt;T&gt; invoker)</span> <span class="hljs-keyword">throws</span> RpcException </span>{
    <span class="hljs-comment">// 调用重载方法</span>
    <span class="hljs-keyword">return</span> getProxy(invoker, <span class="hljs-keyword">false</span>);
}

<span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Invoker&lt;T&gt; invoker, <span class="hljs-keyword">boolean</span> generic)</span> <span class="hljs-keyword">throws</span> RpcException </span>{
    Class&lt;?&gt;[] interfaces = <span class="hljs-keyword">null</span>;
    <span class="hljs-comment">// 获取接口列表</span>
    String config = invoker.getUrl().getParameter(<span class="hljs-string">"interfaces"</span>);
    <span class="hljs-keyword">if</span> (config != <span class="hljs-keyword">null</span> &amp;&amp; config.length() &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 切分接口列表</span>
        String[] types = Constants.COMMA_SPLIT_PATTERN.split(config);
        <span class="hljs-keyword">if</span> (types != <span class="hljs-keyword">null</span> &amp;&amp; types.length &gt; <span class="hljs-number">0</span>) {
            interfaces = <span class="hljs-keyword">new</span> Class&lt;?&gt;[types.length + <span class="hljs-number">2</span>];
            <span class="hljs-comment">// 设置服务接口类和 EchoService.class 到 interfaces 中</span>
            interfaces[<span class="hljs-number">0</span>] = invoker.getInterface();
            interfaces[<span class="hljs-number">1</span>] = EchoService.class;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; types.length; i++) {
                <span class="hljs-comment">// 加载接口类</span>
                interfaces[i + <span class="hljs-number">1</span>] = ReflectUtils.forName(types[i]);
            }
        }
    }
    <span class="hljs-keyword">if</span> (interfaces == <span class="hljs-keyword">null</span>) {
        interfaces = <span class="hljs-keyword">new</span> Class&lt;?&gt;[]{invoker.getInterface(), EchoService.class};
    }

    <span class="hljs-comment">// 为 http 和 hessian 协议提供泛化调用支持，参考 pull request #1827</span>
    <span class="hljs-keyword">if</span> (!invoker.getInterface().equals(GenericService.class) &amp;&amp; generic) {
        <span class="hljs-keyword">int</span> len = interfaces.length;
        Class&lt;?&gt;[] temp = interfaces;
        <span class="hljs-comment">// 创建新的 interfaces 数组</span>
        interfaces = <span class="hljs-keyword">new</span> Class&lt;?&gt;[len + <span class="hljs-number">1</span>];
        System.arraycopy(temp, <span class="hljs-number">0</span>, interfaces, <span class="hljs-number">0</span>, len);
        <span class="hljs-comment">// 设置 GenericService.class 到数组中</span>
        interfaces[len] = GenericService.class;
    }

    <span class="hljs-comment">// 调用重载方法</span>
    <span class="hljs-keyword">return</span> getProxy(invoker, interfaces);
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] types)</span></span>;
</code></pre>
<p>如上，上面大段代码都是用来获取 interfaces 数组的，我们继续往下看。getProxy(Invoker, Class&lt;?&gt;[]) 这个方法是一个抽象方法，下面我们到 JavassistProxyFactory 类中看一下该方法的实现代码。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>{
    <span class="hljs-comment">// 生成 Proxy 子类（Proxy 是抽象类）。并调用 Proxy 子类的 newInstance 方法创建 Proxy 实例</span>
    <span class="hljs-keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="hljs-keyword">new</span> InvokerInvocationHandler(invoker));
}
</code></pre>
<p>上面代码并不多，首先是通过 Proxy 的 getProxy 方法获取 Proxy 子类，然后创建 InvokerInvocationHandler 对象，并将该对象传给 newInstance 生成 Proxy 实例。InvokerInvocationHandler 实现自 JDK 的 InvocationHandler 接口，具体的用途是拦截接口类调用。该类逻辑比较简单，这里就不分析了。下面我们重点关注一下 Proxy 的 getProxy 方法，如下。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Proxy <span class="hljs-title">getProxy</span><span class="hljs-params">(Class&lt;?&gt;... ics)</span> </span>{
    <span class="hljs-comment">// 调用重载方法</span>
    <span class="hljs-keyword">return</span> getProxy(ClassHelper.getClassLoader(Proxy.class), ics);
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Proxy <span class="hljs-title">getProxy</span><span class="hljs-params">(ClassLoader cl, Class&lt;?&gt;... ics)</span> </span>{
    <span class="hljs-keyword">if</span> (ics.length &gt; <span class="hljs-number">65535</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"interface limit exceeded"</span>);

    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
    <span class="hljs-comment">// 遍历接口列表</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ics.length; i++) {
        String itf = ics[i].getName();
        <span class="hljs-comment">// 检测类型是否为接口</span>
        <span class="hljs-keyword">if</span> (!ics[i].isInterface())
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(itf + <span class="hljs-string">" is not a interface."</span>);

        Class&lt;?&gt; tmp = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 重新加载接口类</span>
            tmp = Class.forName(itf, <span class="hljs-keyword">false</span>, cl);
        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
        }

        <span class="hljs-comment">// 检测接口是否相同，这里 tmp 有可能为空</span>
        <span class="hljs-keyword">if</span> (tmp != ics[i])
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(ics[i] + <span class="hljs-string">" is not visible from class loader"</span>);

        <span class="hljs-comment">// 拼接接口全限定名，分隔符为 ;</span>
        sb.append(itf).append(<span class="hljs-string">';'</span>);
    }

    <span class="hljs-comment">// 使用拼接后的接口名作为 key</span>
    String key = sb.toString();

    Map&lt;String, Object&gt; cache;
    <span class="hljs-keyword">synchronized</span> (ProxyCacheMap) {
        cache = ProxyCacheMap.get(cl);
        <span class="hljs-keyword">if</span> (cache == <span class="hljs-keyword">null</span>) {
            cache = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();
            ProxyCacheMap.put(cl, cache);
        }
    }

    Proxy proxy = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">synchronized</span> (cache) {
        <span class="hljs-keyword">do</span> {
            <span class="hljs-comment">// 从缓存中获取 Reference&lt;Proxy&gt; 实例</span>
            Object value = cache.get(key);
            <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Reference&lt;?&gt;) {
                proxy = (Proxy) ((Reference&lt;?&gt;) value).get();
                <span class="hljs-keyword">if</span> (proxy != <span class="hljs-keyword">null</span>) {
                    <span class="hljs-keyword">return</span> proxy;
                }
            }

            <span class="hljs-comment">// 并发控制，保证只有一个线程可以进行后续操作</span>
            <span class="hljs-keyword">if</span> (value == PendingGenerationMarker) {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// 其他线程在此处进行等待</span>
                    cache.wait();
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 放置标志位到缓存中，并跳出 while 循环进行后续操作</span>
                cache.put(key, PendingGenerationMarker);
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>);
    }

    <span class="hljs-keyword">long</span> id = PROXY_CLASS_COUNTER.getAndIncrement();
    String pkg = <span class="hljs-keyword">null</span>;
    ClassGenerator ccp = <span class="hljs-keyword">null</span>, ccm = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 创建 ClassGenerator 对象</span>
        ccp = ClassGenerator.newInstance(cl);

        Set&lt;String&gt; worked = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();
        List&lt;Method&gt; methods = <span class="hljs-keyword">new</span> ArrayList&lt;Method&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ics.length; i++) {
            <span class="hljs-comment">// 检测接口访问级别是否为 protected 或 privete</span>
            <span class="hljs-keyword">if</span> (!Modifier.isPublic(ics[i].getModifiers())) {
                <span class="hljs-comment">// 获取接口包名</span>
                String npkg = ics[i].getPackage().getName();
                <span class="hljs-keyword">if</span> (pkg == <span class="hljs-keyword">null</span>) {
                    pkg = npkg;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> (!pkg.equals(npkg))
                        <span class="hljs-comment">// 非 public 级别的接口必须在同一个包下，否者抛出异常</span>
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"non-public interfaces from different packages"</span>);
                }
            }
            
            <span class="hljs-comment">// 添加接口到 ClassGenerator 中</span>
            ccp.addInterface(ics[i]);

            <span class="hljs-comment">// 遍历接口方法</span>
            <span class="hljs-keyword">for</span> (Method method : ics[i].getMethods()) {
                <span class="hljs-comment">// 获取方法描述，可理解为方法签名</span>
                String desc = ReflectUtils.getDesc(method);
                <span class="hljs-comment">// 如果方法描述字符串已在 worked 中，则忽略。考虑这种情况，</span>
                <span class="hljs-comment">// A 接口和 B 接口中包含一个完全相同的方法</span>
                <span class="hljs-keyword">if</span> (worked.contains(desc))
                    <span class="hljs-keyword">continue</span>;
                worked.add(desc);

                <span class="hljs-keyword">int</span> ix = methods.size();
                <span class="hljs-comment">// 获取方法返回值类型</span>
                Class&lt;?&gt; rt = method.getReturnType();
                <span class="hljs-comment">// 获取参数列表</span>
                Class&lt;?&gt;[] pts = method.getParameterTypes();

                <span class="hljs-comment">// 生成 Object[] args = new Object[1...N]</span>
                StringBuilder code = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"Object[] args = new Object["</span>).append(pts.length).append(<span class="hljs-string">"];"</span>);
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; pts.length; j++)
                    <span class="hljs-comment">// 生成 args[1...N] = ($w)$1...N;</span>
                    code.append(<span class="hljs-string">" args["</span>).append(j).append(<span class="hljs-string">"] = ($w)$"</span>).append(j + <span class="hljs-number">1</span>).append(<span class="hljs-string">";"</span>);
                <span class="hljs-comment">// 生成 InvokerHandler 接口的 invoker 方法调用语句，如下：</span>
                <span class="hljs-comment">// Object ret = handler.invoke(this, methods[1...N], args);</span>
                code.append(<span class="hljs-string">" Object ret = handler.invoke(this, methods["</span> + ix + <span class="hljs-string">"], args);"</span>);

                <span class="hljs-comment">// 返回值不为 void</span>
                <span class="hljs-keyword">if</span> (!Void.TYPE.equals(rt))
                    <span class="hljs-comment">// 生成返回语句，形如 return (java.lang.String) ret;</span>
                    code.append(<span class="hljs-string">" return "</span>).append(asArgument(rt, <span class="hljs-string">"ret"</span>)).append(<span class="hljs-string">";"</span>);

                methods.add(method);
                <span class="hljs-comment">// 添加方法名、访问控制符、参数列表、方法代码等信息到 ClassGenerator 中 </span>
                ccp.addMethod(method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString());
            }
        }

        <span class="hljs-keyword">if</span> (pkg == <span class="hljs-keyword">null</span>)
            pkg = PACKAGE_NAME;

        <span class="hljs-comment">// 构建接口代理类名称：pkg + ".proxy" + id，比如 org.apache.dubbo.proxy0</span>
        String pcn = pkg + <span class="hljs-string">".proxy"</span> + id;
        ccp.setClassName(pcn);
        ccp.addField(<span class="hljs-string">"public static java.lang.reflect.Method[] methods;"</span>);
        <span class="hljs-comment">// 生成 private java.lang.reflect.InvocationHandler handler;</span>
        ccp.addField(<span class="hljs-string">"private "</span> + InvocationHandler.class.getName() + <span class="hljs-string">" handler;"</span>);

        <span class="hljs-comment">// 为接口代理类添加带有 InvocationHandler 参数的构造方法，比如：</span>
        <span class="hljs-comment">// porxy0(java.lang.reflect.InvocationHandler arg0) {</span>
        <span class="hljs-comment">//     handler=$1;</span>
    	<span class="hljs-comment">// }</span>
        ccp.addConstructor(Modifier.PUBLIC, <span class="hljs-keyword">new</span> Class&lt;?&gt;[]{InvocationHandler.class}, <span class="hljs-keyword">new</span> Class&lt;?&gt;[<span class="hljs-number">0</span>], <span class="hljs-string">"handler=$1;"</span>);
        <span class="hljs-comment">// 为接口代理类添加默认构造方法</span>
        ccp.addDefaultConstructor();
        
        <span class="hljs-comment">// 生成接口代理类</span>
        Class&lt;?&gt; clazz = ccp.toClass();
        clazz.getField(<span class="hljs-string">"methods"</span>).set(<span class="hljs-keyword">null</span>, methods.toArray(<span class="hljs-keyword">new</span> Method[<span class="hljs-number">0</span>]));

        <span class="hljs-comment">// 构建 Proxy 子类名称，比如 Proxy1，Proxy2 等</span>
        String fcn = Proxy.class.getName() + id;
        ccm = ClassGenerator.newInstance(cl);
        ccm.setClassName(fcn);
        ccm.addDefaultConstructor();
        ccm.setSuperClass(Proxy.class);
        <span class="hljs-comment">// 为 Proxy 的抽象方法 newInstance 生成实现代码，形如：</span>
        <span class="hljs-comment">// public Object newInstance(java.lang.reflect.InvocationHandler h) { </span>
        <span class="hljs-comment">//     return new org.apache.dubbo.proxy0($1);</span>
        <span class="hljs-comment">// }</span>
        ccm.addMethod(<span class="hljs-string">"public Object newInstance("</span> + InvocationHandler.class.getName() + <span class="hljs-string">" h){ return new "</span> + pcn + <span class="hljs-string">"($1); }"</span>);
        <span class="hljs-comment">// 生成 Proxy 实现类</span>
        Class&lt;?&gt; pc = ccm.toClass();
        <span class="hljs-comment">// 通过反射创建 Proxy 实例</span>
        proxy = (Proxy) pc.newInstance();
    } <span class="hljs-keyword">catch</span> (RuntimeException e) {
        <span class="hljs-keyword">throw</span> e;
    } <span class="hljs-keyword">catch</span> (Exception e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e.getMessage(), e);
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">if</span> (ccp != <span class="hljs-keyword">null</span>)
            <span class="hljs-comment">// 释放资源</span>
            ccp.release();
        <span class="hljs-keyword">if</span> (ccm != <span class="hljs-keyword">null</span>)
            ccm.release();
        <span class="hljs-keyword">synchronized</span> (cache) {
            <span class="hljs-keyword">if</span> (proxy == <span class="hljs-keyword">null</span>)
                cache.remove(key);
            <span class="hljs-keyword">else</span>
                <span class="hljs-comment">// 写缓存</span>
                cache.put(key, <span class="hljs-keyword">new</span> WeakReference&lt;Proxy&gt;(proxy));
            <span class="hljs-comment">// 唤醒其他等待线程</span>
            cache.notifyAll();
        }
    }
    <span class="hljs-keyword">return</span> proxy;
}
</code></pre>
<p>上面代码比较复杂，我们写了大量的注释。大家在阅读这段代码时，要搞清楚 ccp 和 ccm 的用途，不然会被搞晕。ccp 用于为服务接口生成代理类，比如我们有一个 DemoService 接口，这个接口代理类就是由 ccp 生成的。ccm 则是用于为 org.apache.dubbo.common.bytecode.Proxy 抽象类生成子类，主要是实现 Proxy 类的抽象方法。下面以 org.apache.dubbo.demo.DemoService 这个接口为例，来看一下该接口代理类代码大致是怎样的（忽略 EchoService 接口）。</p>
<pre><code class="language-java"><span class="hljs-keyword">package</span> org.apache.dubbo.common.bytecode;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">proxy0</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">org</span>.<span class="hljs-title">apache</span>.<span class="hljs-title">dubbo</span>.<span class="hljs-title">demo</span>.<span class="hljs-title">DemoService</span> </span>{

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> java.lang.reflect.Method[] methods;

    <span class="hljs-keyword">private</span> java.lang.reflect.InvocationHandler handler;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">proxy0</span><span class="hljs-params">()</span> </span>{
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">proxy0</span><span class="hljs-params">(java.lang.reflect.InvocationHandler arg0)</span> </span>{
        handler = $<span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">public</span> java.lang.<span class="hljs-function">String <span class="hljs-title">sayHello</span><span class="hljs-params">(java.lang.String arg0)</span> </span>{
        Object[] args = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">1</span>];
        args[<span class="hljs-number">0</span>] = ($w) $<span class="hljs-number">1</span>;
        Object ret = handler.invoke(<span class="hljs-keyword">this</span>, methods[<span class="hljs-number">0</span>], args);
        <span class="hljs-keyword">return</span> (java.lang.String) ret;
    }
}
</code></pre>
<p>好了，到这里代理类生成逻辑就分析完了。整个过程比较复杂，大家需要耐心看一下。</p>
<h2>4.总结</h2>
<p>本篇文章对服务引用的过程进行了较为详尽的分析，还有一些逻辑暂时没有分析到，比如  Directory、Cluster。这些接口及实现类功能比较独立，后续会单独成文进行分析。暂时我们可以先把这些类看成黑盒，只要知道这些类的用途即可。关于服务引用过程就分析到这里。</p>
</div></section><footer class="footer-container"><div class="footer-body"><img src="/img/dubbo_gray.png"/><img class="apache" src="/img/apache_logo.png"/><div class="cols-container"><div class="col col-12"><h3>Disclaimer</h3><p>Apache Dubbo is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Incubator. Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.</p></div><div class="col col-4"><dl><dt>ASF</dt><dd><a href="http://www.apache.org" target="_self">基金会</a></dd><dd><a href="http://www.apache.org/licenses/" target="_self">证书</a></dd><dd><a href="http://www.apache.org/events/current-event" target="_self">事件</a></dd><dd><a href="http://www.apache.org/foundation/sponsorship.html" target="_self">赞助</a></dd><dd><a href="http://www.apache.org/foundation/thanks.html" target="_self">致谢</a></dd></dl></div><div class="col col-4"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/user/quick-start.html" target="_self">快速开始</a></dd><dd><a href="/zh-cn/docs/dev/build.html" target="_self">开发者指南</a></dd><dd><a href="/zh-cn/docs/admin/ops/dubbo-ops.html" target="_self">运维管理</a></dd></dl></div><div class="col col-4"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/community/index.html" target="_self">社区</a></dd><dd><a href="https://www.apache.org/security" target="_self">安全</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2018 The Apache Software Foundation. Apache and the Apache feather logo are trademarks of The Apache Software Foundation.</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
  <script src="/build/documentation.js"></script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112489517-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-112489517-1');
	</script>
</body>
</html>