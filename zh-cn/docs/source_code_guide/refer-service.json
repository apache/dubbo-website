{
  "filename": "refer-service.md",
  "__html": "<h2>1. 简介</h2>\n<p>上一篇文章详细分析了服务导出的过程，本篇文章我们趁热打铁，继续分析服务引用过程。在 Dubbo 中，我们可以通过两种方式引用远程服务。第一种是使用服务直连的方式引用服务，第二种方式是基于注册中心进行引用。服务直连的方式仅适合在调试或测试服务的场景下使用，不适合在线上环境使用。因此，本文我将重点分析通过注册中心引用服务的过程。从注册中心中获取服务配置只是服务引用过程中的一环，除此之外，服务消费者还需要经历 Invoker 创建、代理类创建等步骤。这些步骤，将在后续章节中一一进行分析。</p>\n<h2>2.服务引用原理</h2>\n<p>Dubbo 服务引用的时机有两个，第一个是在 Spring 容器调用 ReferenceBean 的 afterPropertiesSet 方法时引用服务，第二个是在 ReferenceBean 对应的服务被注入到其他类中时引用。这两个引用服务的时机区别在于，第一个是饿汉式的，第二个是懒汉式的。默认情况下，Dubbo 使用懒汉式引用服务。如果需要使用饿汉式，可通过配置 &lt;dubbo:reference&gt; 的 init 属性开启。下面我们按照 Dubbo 默认配置进行分析，整个分析过程从 ReferenceBean 的 getObject 方法开始。当我们的服务被注入到其他类中时，Spring 会第一时间调用 getObject 方法，并由该方法执行服务引用逻辑。按照惯例，在进行具体工作之前，需先进行配置检查与收集工作。接着根据收集到的信息决定服务用的方式，有三种，第一种是引用本地 (JVM) 服务，第二是通过直连方式引用远程服务，第三是通过注册中心引用远程服务。不管是哪种引用方式，最后都会得到一个 Invoker 实例。如果有多个注册中心，多个服务提供者，这个时候会得到一组 Invoker 实例，此时需要通过集群管理类 Cluster 将多个 Invoker 合并成一个实例。合并后的 Invoker 实例已经具备调用本地或远程服务的能力了，但并不能将此实例暴露给用户使用，这会对用户业务代码造成侵入。此时框架还需要通过代理工厂类 (ProxyFactory) 为服务接口生成代理类，并让代理类去调用 Invoker 逻辑。避免了 Dubbo 框架代码对业务代码的侵入，同时也让框架更容易使用。</p>\n<p>以上就是服务引用的大致原理，下面我们深入到代码中，详细分析服务引用细节。</p>\n<h2>3.源码分析</h2>\n<p>服务引用的入口方法为 ReferenceBean 的 getObject 方法，该方法定义在 Spring 的 FactoryBean 接口中，ReferenceBean 实现了这个方法。实现代码如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">getObject</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n    <span class=\"hljs-keyword\">return</span> get();\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> T <span class=\"hljs-title\">get</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (destroyed) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"Already destroyed!\"</span>);\n    }\n    <span class=\"hljs-comment\">// 检测 ref 是否为空，为空则通过 init 方法创建</span>\n    <span class=\"hljs-keyword\">if</span> (ref == <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-comment\">// init 方法主要用于处理配置，以及调用 createProxy 生成代理类</span>\n        init();\n    }\n    <span class=\"hljs-keyword\">return</span> ref;\n}\n</code></pre>\n<p>以上两个方法的代码比较简短，并不难理解。这里需要特别说明一下，如果你对 2.6.4 及以下版本的 getObject 方法进行调试时，会碰到比较奇怪的的问题。这里假设你使用 IDEA，且保持了 IDEA 的默认配置。当你面调试到 get 方法的<code>if (ref == null)</code>时，你会发现 ref 不为空，导致你无法进入到 init 方法中继续调试。导致这个现象的原因是 Dubbo 框架本身有一些小问题。该问题已经在 pull request <a href=\"https://github.com/apache/dubbo/pull/2754\">#2754</a> 修复了此问题，并跟随 2.6.5 版本发布了。如果你正在学习 2.6.4 及以下版本，可通过修改 IDEA 配置规避这个问题。首先 IDEA 配置弹窗中搜索 toString，然后取消<code>Enable 'toString' object view</code>勾选。具体如下：</p>\n<p><img src=\"https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15417503733794.jpg\" alt=\"\"></p>\n<h3>3.1 处理配置</h3>\n<p>Dubbo 提供了丰富的配置，用于调整和优化框架行为，性能等。Dubbo 在引用或导出服务时，首先会对这些配置进行检查和处理，以保证配置到正确性。配置解析逻辑封装在 ReferenceConfig 的 init 方法中，下面进行分析。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// 避免重复初始化</span>\n    <span class=\"hljs-keyword\">if</span> (initialized) {\n        <span class=\"hljs-keyword\">return</span>;\n    }\n    initialized = <span class=\"hljs-keyword\">true</span>;\n    <span class=\"hljs-comment\">// 检测接口名合法性</span>\n    <span class=\"hljs-keyword\">if</span> (interfaceName == <span class=\"hljs-keyword\">null</span> || interfaceName.length() == <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"interface not allow null!\"</span>);\n    }\n\n    <span class=\"hljs-comment\">// 检测 consumer 变量是否为空，为空则创建</span>\n    checkDefault();\n    appendProperties(<span class=\"hljs-keyword\">this</span>);\n    <span class=\"hljs-keyword\">if</span> (getGeneric() == <span class=\"hljs-keyword\">null</span> &amp;&amp; getConsumer() != <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-comment\">// 设置 generic</span>\n        setGeneric(getConsumer().getGeneric());\n    }\n\n    <span class=\"hljs-comment\">// 检测是否为泛化接口</span>\n    <span class=\"hljs-keyword\">if</span> (ProtocolUtils.isGeneric(getGeneric())) {\n        interfaceClass = GenericService.class;\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 加载类</span>\n            interfaceClass = Class.forName(interfaceName, <span class=\"hljs-keyword\">true</span>, Thread.currentThread()\n                    .getContextClassLoader());\n        } <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException e) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(e.getMessage(), e);\n        }\n        checkInterfaceAndMethods(interfaceClass, methods);\n    }\n    \n    <span class=\"hljs-comment\">// -------------------------------✨ 分割线1 ✨------------------------------</span>\n\n    <span class=\"hljs-comment\">// 从系统变量中获取与接口名对应的属性值</span>\n    String resolve = System.getProperty(interfaceName);\n    String resolveFile = <span class=\"hljs-keyword\">null</span>;\n    <span class=\"hljs-keyword\">if</span> (resolve == <span class=\"hljs-keyword\">null</span> || resolve.length() == <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-comment\">// 从系统属性中获取解析文件路径</span>\n        resolveFile = System.getProperty(<span class=\"hljs-string\">\"dubbo.resolve.file\"</span>);\n        <span class=\"hljs-keyword\">if</span> (resolveFile == <span class=\"hljs-keyword\">null</span> || resolveFile.length() == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-comment\">// 从指定位置加载配置文件</span>\n            File userResolveFile = <span class=\"hljs-keyword\">new</span> File(<span class=\"hljs-keyword\">new</span> File(System.getProperty(<span class=\"hljs-string\">\"user.home\"</span>)), <span class=\"hljs-string\">\"dubbo-resolve.properties\"</span>);\n            <span class=\"hljs-keyword\">if</span> (userResolveFile.exists()) {\n                <span class=\"hljs-comment\">// 获取文件绝对路径</span>\n                resolveFile = userResolveFile.getAbsolutePath();\n            }\n        }\n        <span class=\"hljs-keyword\">if</span> (resolveFile != <span class=\"hljs-keyword\">null</span> &amp;&amp; resolveFile.length() &gt; <span class=\"hljs-number\">0</span>) {\n            Properties properties = <span class=\"hljs-keyword\">new</span> Properties();\n            FileInputStream fis = <span class=\"hljs-keyword\">null</span>;\n            <span class=\"hljs-keyword\">try</span> {\n                fis = <span class=\"hljs-keyword\">new</span> FileInputStream(<span class=\"hljs-keyword\">new</span> File(resolveFile));\n                <span class=\"hljs-comment\">// 从文件中加载配置</span>\n                properties.load(fis);\n            } <span class=\"hljs-keyword\">catch</span> (IOException e) {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"Unload ..., cause:...\"</span>);\n            } <span class=\"hljs-keyword\">finally</span> {\n                <span class=\"hljs-keyword\">try</span> {\n                    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">null</span> != fis) fis.close();\n                } <span class=\"hljs-keyword\">catch</span> (IOException e) {\n                    logger.warn(e.getMessage(), e);\n                }\n            }\n            <span class=\"hljs-comment\">// 获取与接口名对应的配置</span>\n            resolve = properties.getProperty(interfaceName);\n        }\n    }\n    <span class=\"hljs-keyword\">if</span> (resolve != <span class=\"hljs-keyword\">null</span> &amp;&amp; resolve.length() &gt; <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-comment\">// 将 resolve 赋值给 url</span>\n        url = resolve;\n    }\n    \n    <span class=\"hljs-comment\">// -------------------------------✨ 分割线2 ✨------------------------------</span>\n    <span class=\"hljs-keyword\">if</span> (consumer != <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-keyword\">if</span> (application == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-comment\">// 从 consumer 中获取 Application 实例，下同</span>\n            application = consumer.getApplication();\n        }\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">module</span> == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">module</span> = consumer.getModule();\n        }\n        <span class=\"hljs-keyword\">if</span> (registries == <span class=\"hljs-keyword\">null</span>) {\n            registries = consumer.getRegistries();\n        }\n        <span class=\"hljs-keyword\">if</span> (monitor == <span class=\"hljs-keyword\">null</span>) {\n            monitor = consumer.getMonitor();\n        }\n    }\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">module</span> != <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-keyword\">if</span> (registries == <span class=\"hljs-keyword\">null</span>) {\n            registries = <span class=\"hljs-keyword\">module</span>.getRegistries();\n        }\n        <span class=\"hljs-keyword\">if</span> (monitor == <span class=\"hljs-keyword\">null</span>) {\n            monitor = <span class=\"hljs-keyword\">module</span>.getMonitor();\n        }\n    }\n    <span class=\"hljs-keyword\">if</span> (application != <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-keyword\">if</span> (registries == <span class=\"hljs-keyword\">null</span>) {\n            registries = application.getRegistries();\n        }\n        <span class=\"hljs-keyword\">if</span> (monitor == <span class=\"hljs-keyword\">null</span>) {\n            monitor = application.getMonitor();\n        }\n    }\n    \n    <span class=\"hljs-comment\">// 检测 Application 合法性</span>\n    checkApplication();\n    <span class=\"hljs-comment\">// 检测本地存根配置合法性</span>\n    checkStubAndMock(interfaceClass);\n    \n\t<span class=\"hljs-comment\">// -------------------------------✨ 分割线3 ✨------------------------------</span>\n    \n    Map&lt;String, String&gt; map = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, String&gt;();\n    Map&lt;Object, Object&gt; attributes = <span class=\"hljs-keyword\">new</span> HashMap&lt;Object, Object&gt;();\n\n    <span class=\"hljs-comment\">// 添加 side、协议版本信息、时间戳和进程号等信息到 map 中</span>\n    map.put(Constants.SIDE_KEY, Constants.CONSUMER_SIDE);\n    map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());\n    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n    <span class=\"hljs-keyword\">if</span> (ConfigUtils.getPid() &gt; <span class=\"hljs-number\">0</span>) {\n        map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n    }\n\n    <span class=\"hljs-comment\">// 非泛化服务</span>\n    <span class=\"hljs-keyword\">if</span> (!isGeneric()) {\n        <span class=\"hljs-comment\">// 获取版本</span>\n        String revision = Version.getVersion(interfaceClass, version);\n        <span class=\"hljs-keyword\">if</span> (revision != <span class=\"hljs-keyword\">null</span> &amp;&amp; revision.length() &gt; <span class=\"hljs-number\">0</span>) {\n            map.put(<span class=\"hljs-string\">\"revision\"</span>, revision);\n        }\n\n        <span class=\"hljs-comment\">// 获取接口方法列表，并添加到 map 中</span>\n        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();\n        <span class=\"hljs-keyword\">if</span> (methods.length == <span class=\"hljs-number\">0</span>) {\n            map.put(<span class=\"hljs-string\">\"methods\"</span>, Constants.ANY_VALUE);\n        } <span class=\"hljs-keyword\">else</span> {\n            map.put(<span class=\"hljs-string\">\"methods\"</span>, StringUtils.join(<span class=\"hljs-keyword\">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class=\"hljs-string\">\",\"</span>));\n        }\n    }\n    map.put(Constants.INTERFACE_KEY, interfaceName);\n    <span class=\"hljs-comment\">// 将 ApplicationConfig、ConsumerConfig、ReferenceConfig 等对象的字段信息添加到 map 中</span>\n    appendParameters(map, application);\n    appendParameters(map, <span class=\"hljs-keyword\">module</span>);\n    appendParameters(map, consumer, Constants.DEFAULT_KEY);\n    appendParameters(map, <span class=\"hljs-keyword\">this</span>);\n    \n\t<span class=\"hljs-comment\">// -------------------------------✨ 分割线4 ✨------------------------------</span>\n    \n    String prefix = StringUtils.getServiceKey(map);\n    <span class=\"hljs-keyword\">if</span> (methods != <span class=\"hljs-keyword\">null</span> &amp;&amp; !methods.isEmpty()) {\n        <span class=\"hljs-comment\">// 遍历 MethodConfig 列表</span>\n        <span class=\"hljs-keyword\">for</span> (MethodConfig method : methods) {\n            appendParameters(map, method, method.getName());\n            String retryKey = method.getName() + <span class=\"hljs-string\">\".retry\"</span>;\n            <span class=\"hljs-comment\">// 检测 map 是否包含 methodName.retry</span>\n            <span class=\"hljs-keyword\">if</span> (map.containsKey(retryKey)) {\n                String retryValue = map.remove(retryKey);\n                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">\"false\"</span>.equals(retryValue)) {\n                    <span class=\"hljs-comment\">// 添加重试次数配置 methodName.retries</span>\n                    map.put(method.getName() + <span class=\"hljs-string\">\".retries\"</span>, <span class=\"hljs-string\">\"0\"</span>);\n                }\n            }\n \n            <span class=\"hljs-comment\">// 添加 MethodConfig 中的“属性”字段到 attributes</span>\n            <span class=\"hljs-comment\">// 比如 onreturn、onthrow、oninvoke 等</span>\n            appendAttributes(attributes, method, prefix + <span class=\"hljs-string\">\".\"</span> + method.getName());\n            checkAndConvertImplicitConfig(method, map, attributes);\n        }\n    }\n    \n\t<span class=\"hljs-comment\">// -------------------------------✨ 分割线5 ✨------------------------------</span>\n\n    <span class=\"hljs-comment\">// 获取服务消费者 ip 地址</span>\n    String hostToRegistry = ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY);\n    <span class=\"hljs-keyword\">if</span> (hostToRegistry == <span class=\"hljs-keyword\">null</span> || hostToRegistry.length() == <span class=\"hljs-number\">0</span>) {\n        hostToRegistry = NetUtils.getLocalHost();\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isInvalidLocalHost(hostToRegistry)) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"Specified invalid registry ip from property...\"</span> );\n    }\n    map.put(Constants.REGISTER_IP_KEY, hostToRegistry);\n\n    <span class=\"hljs-comment\">// 存储 attributes 到系统上下文中</span>\n    StaticContext.getSystemContext().putAll(attributes);\n\n    <span class=\"hljs-comment\">// 创建代理类</span>\n    ref = createProxy(map);\n\n    <span class=\"hljs-comment\">// 根据服务名，ReferenceConfig，代理类构建 ConsumerModel，</span>\n    <span class=\"hljs-comment\">// 并将 ConsumerModel 存入到 ApplicationModel 中</span>\n    ConsumerModel consumerModel = <span class=\"hljs-keyword\">new</span> ConsumerModel(getUniqueServiceName(), <span class=\"hljs-keyword\">this</span>, ref, interfaceClass.getMethods());\n    ApplicationModel.initConsumerModel(getUniqueServiceName(), consumerModel);\n}\n</code></pre>\n<p>上面的代码很长，做的事情比较多。这里根据代码逻辑，对代码进行了分块，下面我们一起来看一下。</p>\n<p>首先是方法开始到分割线1之间的代码。这段代码主要用于检测 ConsumerConfig 实例是否存在，如不存在则创建一个新的实例，然后通过系统变量或 dubbo.properties 配置文件填充 ConsumerConfig 的字段。接着是检测泛化配置，并根据配置设置 interfaceClass 的值。接着来看分割线1到分割线2之间的逻辑。这段逻辑用于从系统属性或配置文件中加载与接口名相对应的配置，并将解析结果赋值给 url 字段。url 字段的作用一般是用于点对点调用。继续向下看，分割线2和分割线3之间的代码用于检测几个核心配置类是否为空，为空则尝试从其他配置类中获取。分割线3与分割线4之间的代码主要用于收集各种配置，并将配置存储到 map 中。分割线4和分割线5之间的代码用于处理 MethodConfig 实例。该实例包含了事件通知配置，比如 onreturn、onthrow、oninvoke 等。分割线5到方法结尾的代码主要用于解析服务消费者 ip，以及调用 createProxy 创建代理对象。关于该方法的详细分析，将会在接下来的章节中展开。</p>\n<h3>3.2 引用服务</h3>\n<p>本节我们要从 createProxy 开始看起。从字面意思上来看，createProxy 似乎只是用于创建代理对象的。但实际上并非如此，该方法还会调用其他方法构建以及合并 Invoker 实例。具体细节如下。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> T <span class=\"hljs-title\">createProxy</span><span class=\"hljs-params\">(Map&lt;String, String&gt; map)</span> </span>{\n    URL tmpUrl = <span class=\"hljs-keyword\">new</span> URL(<span class=\"hljs-string\">\"temp\"</span>, <span class=\"hljs-string\">\"localhost\"</span>, <span class=\"hljs-number\">0</span>, map);\n    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">boolean</span> isJvmRefer;\n    <span class=\"hljs-keyword\">if</span> (isInjvm() == <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-comment\">// url 配置被指定，则不做本地引用</span>\n        <span class=\"hljs-keyword\">if</span> (url != <span class=\"hljs-keyword\">null</span> &amp;&amp; url.length() &gt; <span class=\"hljs-number\">0</span>) {\n            isJvmRefer = <span class=\"hljs-keyword\">false</span>;\n        <span class=\"hljs-comment\">// 根据 url 的协议、scope 以及 injvm 等参数检测是否需要本地引用</span>\n        <span class=\"hljs-comment\">// 比如如果用户显式配置了 scope=local，此时 isInjvmRefer 返回 true</span>\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (InjvmProtocol.getInjvmProtocol().isInjvmRefer(tmpUrl)) {\n            isJvmRefer = <span class=\"hljs-keyword\">true</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n            isJvmRefer = <span class=\"hljs-keyword\">false</span>;\n        }\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 获取 injvm 配置值</span>\n        isJvmRefer = isInjvm().booleanValue();\n    }\n\n    <span class=\"hljs-comment\">// 本地引用</span>\n    <span class=\"hljs-keyword\">if</span> (isJvmRefer) {\n        <span class=\"hljs-comment\">// 生成本地引用 URL，协议为 injvm</span>\n        URL url = <span class=\"hljs-keyword\">new</span> URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, <span class=\"hljs-number\">0</span>, interfaceClass.getName()).addParameters(map);\n        <span class=\"hljs-comment\">// 调用 refer 方法构建 InjvmInvoker 实例</span>\n        invoker = refprotocol.refer(interfaceClass, url);\n        \n    <span class=\"hljs-comment\">// 远程引用</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// url 不为空，表明用户可能想进行点对点调用</span>\n        <span class=\"hljs-keyword\">if</span> (url != <span class=\"hljs-keyword\">null</span> &amp;&amp; url.length() &gt; <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-comment\">// 当需要配置多个 url 时，可用分号进行分割，这里会进行切分</span>\n            String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);\n            <span class=\"hljs-keyword\">if</span> (us != <span class=\"hljs-keyword\">null</span> &amp;&amp; us.length &gt; <span class=\"hljs-number\">0</span>) {\n                <span class=\"hljs-keyword\">for</span> (String u : us) {\n                    URL url = URL.valueOf(u);\n                    <span class=\"hljs-keyword\">if</span> (url.getPath() == <span class=\"hljs-keyword\">null</span> || url.getPath().length() == <span class=\"hljs-number\">0</span>) {\n                        <span class=\"hljs-comment\">// 设置接口全限定名为 url 路径</span>\n                        url = url.setPath(interfaceName);\n                    }\n                    \n                    <span class=\"hljs-comment\">// 检测 url 协议是否为 registry，若是，表明用户想使用指定的注册中心</span>\n                    <span class=\"hljs-keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n                        <span class=\"hljs-comment\">// 将 map 转换为查询字符串，并作为 refer 参数的值添加到 url 中</span>\n                        urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n                    } <span class=\"hljs-keyword\">else</span> {\n                        <span class=\"hljs-comment\">// 合并 url，移除服务提供者的一些配置（这些配置来源于用户配置的 url 属性），</span>\n                        <span class=\"hljs-comment\">// 比如线程池相关配置。并保留服务提供者的部分配置，比如版本，group，时间戳等</span>\n                        <span class=\"hljs-comment\">// 最后将合并后的配置设置为 url 查询字符串中。</span>\n                        urls.add(ClusterUtils.mergeUrl(url, map));\n                    }\n                }\n            }\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// 加载注册中心 url</span>\n            List&lt;URL&gt; us = loadRegistries(<span class=\"hljs-keyword\">false</span>);\n            <span class=\"hljs-keyword\">if</span> (us != <span class=\"hljs-keyword\">null</span> &amp;&amp; !us.isEmpty()) {\n                <span class=\"hljs-keyword\">for</span> (URL u : us) {\n                    URL monitorUrl = loadMonitor(u);\n                    <span class=\"hljs-keyword\">if</span> (monitorUrl != <span class=\"hljs-keyword\">null</span>) {\n                        map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));\n                    }\n                    <span class=\"hljs-comment\">// 添加 refer 参数到 url 中，并将 url 添加到 urls 中</span>\n                    urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n                }\n            }\n\n            <span class=\"hljs-comment\">// 未配置注册中心，抛出异常</span>\n            <span class=\"hljs-keyword\">if</span> (urls.isEmpty()) {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"No such any registry to reference...\"</span>);\n            }\n        }\n\n        <span class=\"hljs-comment\">// 单个注册中心或服务提供者(服务直连，下同)</span>\n        <span class=\"hljs-keyword\">if</span> (urls.size() == <span class=\"hljs-number\">1</span>) {\n            <span class=\"hljs-comment\">// 调用 RegistryProtocol 的 refer 构建 Invoker 实例</span>\n            invoker = refprotocol.refer(interfaceClass, urls.get(<span class=\"hljs-number\">0</span>));\n            \n        <span class=\"hljs-comment\">// 多个注册中心或多个服务提供者，或者两者混合</span>\n        } <span class=\"hljs-keyword\">else</span> {\n            List&lt;Invoker&lt;?&gt;&gt; invokers = <span class=\"hljs-keyword\">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();\n            URL registryURL = <span class=\"hljs-keyword\">null</span>;\n\n            <span class=\"hljs-comment\">// 获取所有的 Invoker</span>\n            <span class=\"hljs-keyword\">for</span> (URL url : urls) {\n                <span class=\"hljs-comment\">// 通过 refprotocol 调用 refer 构建 Invoker，refprotocol 会在运行时</span>\n                <span class=\"hljs-comment\">// 根据 url 协议头加载指定的 Protocol 实例，并调用实例的 refer 方法</span>\n                invokers.add(refprotocol.refer(interfaceClass, url));\n                <span class=\"hljs-keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n                    registryURL = url;\n                }\n            }\n            <span class=\"hljs-keyword\">if</span> (registryURL != <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-comment\">// 如果注册中心链接不为空，则将使用 AvailableCluster</span>\n                URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);\n                <span class=\"hljs-comment\">// 创建 StaticDirectory 实例，并由 Cluster 对多个 Invoker 进行合并</span>\n                invoker = cluster.join(<span class=\"hljs-keyword\">new</span> StaticDirectory(u, invokers));\n            } <span class=\"hljs-keyword\">else</span> {\n                invoker = cluster.join(<span class=\"hljs-keyword\">new</span> StaticDirectory(invokers));\n            }\n        }\n    }\n\n    Boolean c = check;\n    <span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-keyword\">null</span> &amp;&amp; consumer != <span class=\"hljs-keyword\">null</span>) {\n        c = consumer.isCheck();\n    }\n    <span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-keyword\">null</span>) {\n        c = <span class=\"hljs-keyword\">true</span>;\n    }\n    \n    <span class=\"hljs-comment\">// invoker 可用性检查</span>\n    <span class=\"hljs-keyword\">if</span> (c &amp;&amp; !invoker.isAvailable()) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"No provider available for the service...\"</span>);\n    }\n\n    <span class=\"hljs-comment\">// 生成代理类</span>\n    <span class=\"hljs-keyword\">return</span> (T) proxyFactory.getProxy(invoker);\n}\n</code></pre>\n<p>上面代码很多，不过逻辑比较清晰。首先根据配置检查是否为本地调用，若是，则调用 InjvmProtocol 的 refer 方法生成 InjvmInvoker 实例。若不是，则读取直连配置项，或注册中心 url，并将读取到的 url 存储到 urls 中。然后根据 urls 元素数量进行后续操作。若 urls 元素数量为1，则直接通过 Protocol 自适应拓展类构建 Invoker 实例接口。若 urls 元素数量大于1，即存在多个注册中心或服务直连 url，此时先根据 url 构建 Invoker。然后再通过 Cluster 合并多个 Invoker，最后调用 ProxyFactory 生成代理类。Invoker 的构建过程以及代理类的过程比较重要，因此接下来将分两小节对这两个过程进行分析。</p>\n<h4>3.2.1 创建 Invoker</h4>\n<p>Invoker 是 Dubbo 的核心模型，代表一个可执行体。在服务提供方，Invoker 用于调用服务提供类。在服务消费方，Invoker 用于执行远程调用。Invoker 是由 Protocol 实现类构建而来。Protocol 实现类有很多，本节会分析最常用的两个，分别是 RegistryProtocol 和 DubboProtocol，其他的大家自行分析。下面先来分析 DubboProtocol 的 refer 方法源码。如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">refer</span><span class=\"hljs-params\">(Class&lt;T&gt; serviceType, URL url)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n    optimizeSerialization(url);\n    <span class=\"hljs-comment\">// 创建 DubboInvoker</span>\n    DubboInvoker&lt;T&gt; invoker = <span class=\"hljs-keyword\">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);\n    invokers.add(invoker);\n    <span class=\"hljs-keyword\">return</span> invoker;\n}\n</code></pre>\n<p>上面方法看起来比较简单，不过这里有一个调用需要我们注意一下，即  getClients。这个方法用于获取客户端实例，实例类型为 ExchangeClient。ExchangeClient 实际上并不具备通信能力，它需要基于更底层的客户端实例进行通信。比如 NettyClient、MinaClient 等，默认情况下，Dubbo 使用 NettyClient 进行通信。接下来，我们简单看一下 getClients 方法的逻辑。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> ExchangeClient[] getClients(URL url) {\n    <span class=\"hljs-comment\">// 是否共享连接</span>\n    <span class=\"hljs-keyword\">boolean</span> service_share_connect = <span class=\"hljs-keyword\">false</span>;\n  \t<span class=\"hljs-comment\">// 获取连接数，默认为0，表示未配置</span>\n    <span class=\"hljs-keyword\">int</span> connections = url.getParameter(Constants.CONNECTIONS_KEY, <span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-comment\">// 如果未配置 connections，则共享连接</span>\n    <span class=\"hljs-keyword\">if</span> (connections == <span class=\"hljs-number\">0</span>) {\n        service_share_connect = <span class=\"hljs-keyword\">true</span>;\n        connections = <span class=\"hljs-number\">1</span>;\n    }\n\n    ExchangeClient[] clients = <span class=\"hljs-keyword\">new</span> ExchangeClient[connections];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; clients.length; i++) {\n        <span class=\"hljs-keyword\">if</span> (service_share_connect) {\n            <span class=\"hljs-comment\">// 获取共享客户端</span>\n            clients[i] = getSharedClient(url);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// 初始化新的客户端</span>\n            clients[i] = initClient(url);\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> clients;\n}\n</code></pre>\n<p>这里根据 connections 数量决定是获取共享客户端还是创建新的客户端实例，默认情况下，使用共享客户端实例。getSharedClient 方法中也会调用 initClient 方法，因此下面我们一起看一下这两个方法。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> ExchangeClient <span class=\"hljs-title\">getSharedClient</span><span class=\"hljs-params\">(URL url)</span> </span>{\n    String key = url.getAddress();\n    <span class=\"hljs-comment\">// 获取带有“引用计数”功能的 ExchangeClient</span>\n    ReferenceCountExchangeClient client = referenceClientMap.get(key);\n    <span class=\"hljs-keyword\">if</span> (client != <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-keyword\">if</span> (!client.isClosed()) {\n            <span class=\"hljs-comment\">// 增加引用计数</span>\n            client.incrementAndGetCount();\n            <span class=\"hljs-keyword\">return</span> client;\n        } <span class=\"hljs-keyword\">else</span> {\n            referenceClientMap.remove(key);\n        }\n    }\n\n    locks.putIfAbsent(key, <span class=\"hljs-keyword\">new</span> Object());\n    <span class=\"hljs-keyword\">synchronized</span> (locks.get(key)) {\n        <span class=\"hljs-keyword\">if</span> (referenceClientMap.containsKey(key)) {\n            <span class=\"hljs-keyword\">return</span> referenceClientMap.get(key);\n        }\n\n        <span class=\"hljs-comment\">// 创建 ExchangeClient 客户端</span>\n        ExchangeClient exchangeClient = initClient(url);\n        <span class=\"hljs-comment\">// 将 ExchangeClient 实例传给 ReferenceCountExchangeClient，这里使用了装饰模式</span>\n        client = <span class=\"hljs-keyword\">new</span> ReferenceCountExchangeClient(exchangeClient, ghostClientMap);\n        referenceClientMap.put(key, client);\n        ghostClientMap.remove(key);\n        locks.remove(key);\n        <span class=\"hljs-keyword\">return</span> client;\n    }\n}\n</code></pre>\n<p>上面方法先访问缓存，若缓存未命中，则通过 initClient 方法创建新的 ExchangeClient 实例，并将该实例传给 ReferenceCountExchangeClient 构造方法创建一个带有引用计数功能的 ExchangeClient 实例。ReferenceCountExchangeClient 内部实现比较简单，就不分析了。下面我们再来看一下 initClient 方法的代码。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> ExchangeClient <span class=\"hljs-title\">initClient</span><span class=\"hljs-params\">(URL url)</span> </span>{\n\n    <span class=\"hljs-comment\">// 获取客户端类型，默认为 netty</span>\n    String str = url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT));\n\n    <span class=\"hljs-comment\">// 添加编解码和心跳包参数到 url 中</span>\n    url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);\n    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));\n\n    <span class=\"hljs-comment\">// 检测客户端类型是否存在，不存在则抛出异常</span>\n    <span class=\"hljs-keyword\">if</span> (str != <span class=\"hljs-keyword\">null</span> &amp;&amp; str.length() &gt; <span class=\"hljs-number\">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RpcException(<span class=\"hljs-string\">\"Unsupported client type: ...\"</span>);\n    }\n\n    ExchangeClient client;\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-comment\">// 获取 lazy 配置，并根据配置值决定创建的客户端类型</span>\n        <span class=\"hljs-keyword\">if</span> (url.getParameter(Constants.LAZY_CONNECT_KEY, <span class=\"hljs-keyword\">false</span>)) {\n            <span class=\"hljs-comment\">// 创建懒加载 ExchangeClient 实例</span>\n            client = <span class=\"hljs-keyword\">new</span> LazyConnectExchangeClient(url, requestHandler);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// 创建普通 ExchangeClient 实例</span>\n            client = Exchangers.connect(url, requestHandler);\n        }\n    } <span class=\"hljs-keyword\">catch</span> (RemotingException e) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RpcException(<span class=\"hljs-string\">\"Fail to create remoting client for service...\"</span>);\n    }\n    <span class=\"hljs-keyword\">return</span> client;\n}\n</code></pre>\n<p>initClient 方法首先获取用户配置的客户端类型，默认为 netty。然后检测用户配置的客户端类型是否存在，不存在则抛出异常。最后根据 lazy 配置决定创建什么类型的客户端。这里的 LazyConnectExchangeClient 代码并不是很复杂，该类会在 request 方法被调用时通过 Exchangers 的 connect 方法创建 ExchangeClient 客户端，该类的代码本节就不分析了。下面我们分析一下 Exchangers 的 connect 方法。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> ExchangeClient <span class=\"hljs-title\">connect</span><span class=\"hljs-params\">(URL url, ExchangeHandler handler)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n    <span class=\"hljs-keyword\">if</span> (url == <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"url == null\"</span>);\n    }\n    <span class=\"hljs-keyword\">if</span> (handler == <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"handler == null\"</span>);\n    }\n    url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class=\"hljs-string\">\"exchange\"</span>);\n    <span class=\"hljs-comment\">// 获取 Exchanger 实例，默认为 HeaderExchangeClient</span>\n    <span class=\"hljs-keyword\">return</span> getExchanger(url).connect(url, handler);\n}\n</code></pre>\n<p>如上，getExchanger 会通过 SPI 加载 HeaderExchangeClient 实例，这个方法比较简单，大家自己看一下吧。接下来分析 HeaderExchangeClient 的实现。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ExchangeClient <span class=\"hljs-title\">connect</span><span class=\"hljs-params\">(URL url, ExchangeHandler handler)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n    <span class=\"hljs-comment\">// 这里包含了多个调用，分别如下：</span>\n    <span class=\"hljs-comment\">// 1. 创建 HeaderExchangeHandler 对象</span>\n    <span class=\"hljs-comment\">// 2. 创建 DecodeHandler 对象</span>\n    <span class=\"hljs-comment\">// 3. 通过 Transporters 构建 Client 实例</span>\n    <span class=\"hljs-comment\">// 4. 创建 HeaderExchangeClient 对象</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> HeaderExchangeClient(Transporters.connect(url, <span class=\"hljs-keyword\">new</span> DecodeHandler(<span class=\"hljs-keyword\">new</span> HeaderExchangeHandler(handler))), <span class=\"hljs-keyword\">true</span>);\n}\n</code></pre>\n<p>这里的调用比较多，我们这里重点看一下 Transporters 的 connect 方法。如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Client <span class=\"hljs-title\">connect</span><span class=\"hljs-params\">(URL url, ChannelHandler... handlers)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n    <span class=\"hljs-keyword\">if</span> (url == <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"url == null\"</span>);\n    }\n    ChannelHandler handler;\n    <span class=\"hljs-keyword\">if</span> (handlers == <span class=\"hljs-keyword\">null</span> || handlers.length == <span class=\"hljs-number\">0</span>) {\n        handler = <span class=\"hljs-keyword\">new</span> ChannelHandlerAdapter();\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (handlers.length == <span class=\"hljs-number\">1</span>) {\n        handler = handlers[<span class=\"hljs-number\">0</span>];\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 如果 handler 数量大于1，则创建一个 ChannelHandler 分发器</span>\n        handler = <span class=\"hljs-keyword\">new</span> ChannelHandlerDispatcher(handlers);\n    }\n    \n    <span class=\"hljs-comment\">// 获取 Transporter 自适应拓展类，并调用 connect 方法生成 Client 实例</span>\n    <span class=\"hljs-keyword\">return</span> getTransporter().connect(url, handler);\n}\n</code></pre>\n<p>如上，getTransporter 方法返回的是自适应拓展类，该类会在运行时根据客户端类型加载指定的 Transporter 实现类。若用户未配置客户端类型，则默认加载 NettyTransporter，并调用该类的 connect 方法。如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Client <span class=\"hljs-title\">connect</span><span class=\"hljs-params\">(URL url, ChannelHandler listener)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n    <span class=\"hljs-comment\">// 创建 NettyClient 对象</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> NettyClient(url, listener);\n}\n</code></pre>\n<p>到这里就不继续跟下去了，在往下就是通过 Netty 提供的 API 构建 Netty 客户端了，大家有兴趣自己看看。到这里，关于 DubboProtocol 的 refer 方法就分析完了。接下来，继续分析 RegistryProtocol 的 refer 方法逻辑。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">refer</span><span class=\"hljs-params\">(Class&lt;T&gt; type, URL url)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n    <span class=\"hljs-comment\">// 取 registry 参数值，并将其设置为协议头</span>\n    url = url.setProtocol(url.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)).removeParameter(Constants.REGISTRY_KEY);\n    <span class=\"hljs-comment\">// 获取注册中心实例</span>\n    Registry registry = registryFactory.getRegistry(url);\n    <span class=\"hljs-keyword\">if</span> (RegistryService.class.equals(type)) {\n        <span class=\"hljs-keyword\">return</span> proxyFactory.getInvoker((T) registry, type, url);\n    }\n\n    <span class=\"hljs-comment\">// 将 url 查询字符串转为 Map</span>\n    Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));\n    <span class=\"hljs-comment\">// 获取 group 配置</span>\n    String group = qs.get(Constants.GROUP_KEY);\n    <span class=\"hljs-keyword\">if</span> (group != <span class=\"hljs-keyword\">null</span> &amp;&amp; group.length() &gt; <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-keyword\">if</span> ((Constants.COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class=\"hljs-number\">1</span>\n                || <span class=\"hljs-string\">\"*\"</span>.equals(group)) {\n            <span class=\"hljs-comment\">// 通过 SPI 加载 MergeableCluster 实例，并调用 doRefer 继续执行服务引用逻辑</span>\n            <span class=\"hljs-keyword\">return</span> doRefer(getMergeableCluster(), registry, type, url);\n        }\n    }\n    \n    <span class=\"hljs-comment\">// 调用 doRefer 继续执行服务引用逻辑</span>\n    <span class=\"hljs-keyword\">return</span> doRefer(cluster, registry, type, url);\n}\n</code></pre>\n<p>上面代码首先为 url 设置协议头，然后根据 url 参数加载注册中心实例。然后获取 group 配置，根据 group 配置决定 doRefer 第一个参数的类型。这里的重点是 doRefer 方法，如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">doRefer</span><span class=\"hljs-params\">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>{\n    <span class=\"hljs-comment\">// 创建 RegistryDirectory 实例</span>\n    RegistryDirectory&lt;T&gt; directory = <span class=\"hljs-keyword\">new</span> RegistryDirectory&lt;T&gt;(type, url);\n    <span class=\"hljs-comment\">// 设置注册中心和协议</span>\n    directory.setRegistry(registry);\n    directory.setProtocol(protocol);\n    Map&lt;String, String&gt; parameters = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());\n    <span class=\"hljs-comment\">// 生成服务消费者链接</span>\n    URL subscribeUrl = <span class=\"hljs-keyword\">new</span> URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), <span class=\"hljs-number\">0</span>, type.getName(), parameters);\n\n    <span class=\"hljs-comment\">// 注册服务消费者，在 consumers 目录下新节点</span>\n    <span class=\"hljs-keyword\">if</span> (!Constants.ANY_VALUE.equals(url.getServiceInterface())\n            &amp;&amp; url.getParameter(Constants.REGISTER_KEY, <span class=\"hljs-keyword\">true</span>)) {\n        registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,\n                Constants.CHECK_KEY, String.valueOf(<span class=\"hljs-keyword\">false</span>)));\n    }\n\n    <span class=\"hljs-comment\">// 订阅 providers、configurators、routers 等节点数据</span>\n    directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,\n            Constants.PROVIDERS_CATEGORY\n                    + <span class=\"hljs-string\">\",\"</span> + Constants.CONFIGURATORS_CATEGORY\n                    + <span class=\"hljs-string\">\",\"</span> + Constants.ROUTERS_CATEGORY));\n\n    <span class=\"hljs-comment\">// 一个注册中心可能有多个服务提供者，因此这里需要将多个服务提供者合并为一个</span>\n    Invoker invoker = cluster.join(directory);\n    ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);\n    <span class=\"hljs-keyword\">return</span> invoker;\n}\n</code></pre>\n<p>如上，doRefer 方法创建一个 RegistryDirectory 实例，然后生成服务者消费者链接，并向注册中心进行注册。注册完毕后，紧接着订阅 providers、configurators、routers 等节点下的数据。完成订阅后，RegistryDirectory 会收到这几个节点下的子节点信息。由于一个服务可能部署在多台服务器上，这样就会在  providers 产生多个节点，这个时候就需要 Cluster 将多个服务节点合并为一个，并生成一个 Invoker。关于 RegistryDirectory 和 Cluster，本文不打算进行分析，相关分析将会在随后的文章中展开。</p>\n<h4>3.2.2 创建代理</h4>\n<p>Invoker 创建完毕后，接下来要做的事情是为服务接口生成代理对象。有了代理对象，即可进行远程调用。代理对象生成的入口方法为 ProxyFactory 的 getProxy，接下来进行分析。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">T <span class=\"hljs-title\">getProxy</span><span class=\"hljs-params\">(Invoker&lt;T&gt; invoker)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n    <span class=\"hljs-comment\">// 调用重载方法</span>\n    <span class=\"hljs-keyword\">return</span> getProxy(invoker, <span class=\"hljs-keyword\">false</span>);\n}\n\n<span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">T <span class=\"hljs-title\">getProxy</span><span class=\"hljs-params\">(Invoker&lt;T&gt; invoker, <span class=\"hljs-keyword\">boolean</span> generic)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n    Class&lt;?&gt;[] interfaces = <span class=\"hljs-keyword\">null</span>;\n    <span class=\"hljs-comment\">// 获取接口列表</span>\n    String config = invoker.getUrl().getParameter(<span class=\"hljs-string\">\"interfaces\"</span>);\n    <span class=\"hljs-keyword\">if</span> (config != <span class=\"hljs-keyword\">null</span> &amp;&amp; config.length() &gt; <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-comment\">// 切分接口列表</span>\n        String[] types = Constants.COMMA_SPLIT_PATTERN.split(config);\n        <span class=\"hljs-keyword\">if</span> (types != <span class=\"hljs-keyword\">null</span> &amp;&amp; types.length &gt; <span class=\"hljs-number\">0</span>) {\n            interfaces = <span class=\"hljs-keyword\">new</span> Class&lt;?&gt;[types.length + <span class=\"hljs-number\">2</span>];\n            <span class=\"hljs-comment\">// 设置服务接口类和 EchoService.class 到 interfaces 中</span>\n            interfaces[<span class=\"hljs-number\">0</span>] = invoker.getInterface();\n            interfaces[<span class=\"hljs-number\">1</span>] = EchoService.class;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; types.length; i++) {\n                <span class=\"hljs-comment\">// 加载接口类</span>\n                interfaces[i + <span class=\"hljs-number\">1</span>] = ReflectUtils.forName(types[i]);\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">if</span> (interfaces == <span class=\"hljs-keyword\">null</span>) {\n        interfaces = <span class=\"hljs-keyword\">new</span> Class&lt;?&gt;[]{invoker.getInterface(), EchoService.class};\n    }\n\n    <span class=\"hljs-comment\">// 为 http 和 hessian 协议提供泛化调用支持，参考 pull request #1827</span>\n    <span class=\"hljs-keyword\">if</span> (!invoker.getInterface().equals(GenericService.class) &amp;&amp; generic) {\n        <span class=\"hljs-keyword\">int</span> len = interfaces.length;\n        Class&lt;?&gt;[] temp = interfaces;\n        <span class=\"hljs-comment\">// 创建新的 interfaces 数组</span>\n        interfaces = <span class=\"hljs-keyword\">new</span> Class&lt;?&gt;[len + <span class=\"hljs-number\">1</span>];\n        System.arraycopy(temp, <span class=\"hljs-number\">0</span>, interfaces, <span class=\"hljs-number\">0</span>, len);\n        <span class=\"hljs-comment\">// 设置 GenericService.class 到数组中</span>\n        interfaces[len] = GenericService.class;\n    }\n\n    <span class=\"hljs-comment\">// 调用重载方法</span>\n    <span class=\"hljs-keyword\">return</span> getProxy(invoker, interfaces);\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> &lt;T&gt; <span class=\"hljs-function\">T <span class=\"hljs-title\">getProxy</span><span class=\"hljs-params\">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] types)</span></span>;\n</code></pre>\n<p>如上，上面大段代码都是用来获取 interfaces 数组的，我们继续往下看。getProxy(Invoker, Class&lt;?&gt;[]) 这个方法是一个抽象方法，下面我们到 JavassistProxyFactory 类中看一下该方法的实现代码。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">T <span class=\"hljs-title\">getProxy</span><span class=\"hljs-params\">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>{\n    <span class=\"hljs-comment\">// 生成 Proxy 子类（Proxy 是抽象类）。并调用 Proxy 子类的 newInstance 方法创建 Proxy 实例</span>\n    <span class=\"hljs-keyword\">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class=\"hljs-keyword\">new</span> InvokerInvocationHandler(invoker));\n}\n</code></pre>\n<p>上面代码并不多，首先是通过 Proxy 的 getProxy 方法获取 Proxy 子类，然后创建 InvokerInvocationHandler 对象，并将该对象传给 newInstance 生成 Proxy 实例。InvokerInvocationHandler 实现自 JDK 的 InvocationHandler 接口，具体的用途是拦截接口类调用。该类逻辑比较简单，这里就不分析了。下面我们重点关注一下 Proxy 的 getProxy 方法，如下。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Proxy <span class=\"hljs-title\">getProxy</span><span class=\"hljs-params\">(Class&lt;?&gt;... ics)</span> </span>{\n    <span class=\"hljs-comment\">// 调用重载方法</span>\n    <span class=\"hljs-keyword\">return</span> getProxy(ClassHelper.getClassLoader(Proxy.class), ics);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Proxy <span class=\"hljs-title\">getProxy</span><span class=\"hljs-params\">(ClassLoader cl, Class&lt;?&gt;... ics)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (ics.length &gt; <span class=\"hljs-number\">65535</span>)\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"interface limit exceeded\"</span>);\n\n    StringBuilder sb = <span class=\"hljs-keyword\">new</span> StringBuilder();\n    <span class=\"hljs-comment\">// 遍历接口列表</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; ics.length; i++) {\n        String itf = ics[i].getName();\n        <span class=\"hljs-comment\">// 检测类型是否为接口</span>\n        <span class=\"hljs-keyword\">if</span> (!ics[i].isInterface())\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(itf + <span class=\"hljs-string\">\" is not a interface.\"</span>);\n\n        Class&lt;?&gt; tmp = <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 重新加载接口类</span>\n            tmp = Class.forName(itf, <span class=\"hljs-keyword\">false</span>, cl);\n        } <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException e) {\n        }\n\n        <span class=\"hljs-comment\">// 检测接口是否相同，这里 tmp 有可能为空</span>\n        <span class=\"hljs-keyword\">if</span> (tmp != ics[i])\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(ics[i] + <span class=\"hljs-string\">\" is not visible from class loader\"</span>);\n\n        <span class=\"hljs-comment\">// 拼接接口全限定名，分隔符为 ;</span>\n        sb.append(itf).append(<span class=\"hljs-string\">';'</span>);\n    }\n\n    <span class=\"hljs-comment\">// 使用拼接后的接口名作为 key</span>\n    String key = sb.toString();\n\n    Map&lt;String, Object&gt; cache;\n    <span class=\"hljs-keyword\">synchronized</span> (ProxyCacheMap) {\n        cache = ProxyCacheMap.get(cl);\n        <span class=\"hljs-keyword\">if</span> (cache == <span class=\"hljs-keyword\">null</span>) {\n            cache = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, Object&gt;();\n            ProxyCacheMap.put(cl, cache);\n        }\n    }\n\n    Proxy proxy = <span class=\"hljs-keyword\">null</span>;\n    <span class=\"hljs-keyword\">synchronized</span> (cache) {\n        <span class=\"hljs-keyword\">do</span> {\n            <span class=\"hljs-comment\">// 从缓存中获取 Reference&lt;Proxy&gt; 实例</span>\n            Object value = cache.get(key);\n            <span class=\"hljs-keyword\">if</span> (value <span class=\"hljs-keyword\">instanceof</span> Reference&lt;?&gt;) {\n                proxy = (Proxy) ((Reference&lt;?&gt;) value).get();\n                <span class=\"hljs-keyword\">if</span> (proxy != <span class=\"hljs-keyword\">null</span>) {\n                    <span class=\"hljs-keyword\">return</span> proxy;\n                }\n            }\n\n            <span class=\"hljs-comment\">// 并发控制，保证只有一个线程可以进行后续操作</span>\n            <span class=\"hljs-keyword\">if</span> (value == PendingGenerationMarker) {\n                <span class=\"hljs-keyword\">try</span> {\n                    <span class=\"hljs-comment\">// 其他线程在此处进行等待</span>\n                    cache.wait();\n                } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {\n                }\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-comment\">// 放置标志位到缓存中，并跳出 while 循环进行后续操作</span>\n                cache.put(key, PendingGenerationMarker);\n                <span class=\"hljs-keyword\">break</span>;\n            }\n        }\n        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">true</span>);\n    }\n\n    <span class=\"hljs-keyword\">long</span> id = PROXY_CLASS_COUNTER.getAndIncrement();\n    String pkg = <span class=\"hljs-keyword\">null</span>;\n    ClassGenerator ccp = <span class=\"hljs-keyword\">null</span>, ccm = <span class=\"hljs-keyword\">null</span>;\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-comment\">// 创建 ClassGenerator 对象</span>\n        ccp = ClassGenerator.newInstance(cl);\n\n        Set&lt;String&gt; worked = <span class=\"hljs-keyword\">new</span> HashSet&lt;String&gt;();\n        List&lt;Method&gt; methods = <span class=\"hljs-keyword\">new</span> ArrayList&lt;Method&gt;();\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; ics.length; i++) {\n            <span class=\"hljs-comment\">// 检测接口访问级别是否为 protected 或 privete</span>\n            <span class=\"hljs-keyword\">if</span> (!Modifier.isPublic(ics[i].getModifiers())) {\n                <span class=\"hljs-comment\">// 获取接口包名</span>\n                String npkg = ics[i].getPackage().getName();\n                <span class=\"hljs-keyword\">if</span> (pkg == <span class=\"hljs-keyword\">null</span>) {\n                    pkg = npkg;\n                } <span class=\"hljs-keyword\">else</span> {\n                    <span class=\"hljs-keyword\">if</span> (!pkg.equals(npkg))\n                        <span class=\"hljs-comment\">// 非 public 级别的接口必须在同一个包下，否者抛出异常</span>\n                        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"non-public interfaces from different packages\"</span>);\n                }\n            }\n            \n            <span class=\"hljs-comment\">// 添加接口到 ClassGenerator 中</span>\n            ccp.addInterface(ics[i]);\n\n            <span class=\"hljs-comment\">// 遍历接口方法</span>\n            <span class=\"hljs-keyword\">for</span> (Method method : ics[i].getMethods()) {\n                <span class=\"hljs-comment\">// 获取方法描述，可理解为方法签名</span>\n                String desc = ReflectUtils.getDesc(method);\n                <span class=\"hljs-comment\">// 如果方法描述字符串已在 worked 中，则忽略。考虑这种情况，</span>\n                <span class=\"hljs-comment\">// A 接口和 B 接口中包含一个完全相同的方法</span>\n                <span class=\"hljs-keyword\">if</span> (worked.contains(desc))\n                    <span class=\"hljs-keyword\">continue</span>;\n                worked.add(desc);\n\n                <span class=\"hljs-keyword\">int</span> ix = methods.size();\n                <span class=\"hljs-comment\">// 获取方法返回值类型</span>\n                Class&lt;?&gt; rt = method.getReturnType();\n                <span class=\"hljs-comment\">// 获取参数列表</span>\n                Class&lt;?&gt;[] pts = method.getParameterTypes();\n\n                <span class=\"hljs-comment\">// 生成 Object[] args = new Object[1...N]</span>\n                StringBuilder code = <span class=\"hljs-keyword\">new</span> StringBuilder(<span class=\"hljs-string\">\"Object[] args = new Object[\"</span>).append(pts.length).append(<span class=\"hljs-string\">\"];\"</span>);\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; pts.length; j++)\n                    <span class=\"hljs-comment\">// 生成 args[1...N] = ($w)$1...N;</span>\n                    code.append(<span class=\"hljs-string\">\" args[\"</span>).append(j).append(<span class=\"hljs-string\">\"] = ($w)$\"</span>).append(j + <span class=\"hljs-number\">1</span>).append(<span class=\"hljs-string\">\";\"</span>);\n                <span class=\"hljs-comment\">// 生成 InvokerHandler 接口的 invoker 方法调用语句，如下：</span>\n                <span class=\"hljs-comment\">// Object ret = handler.invoke(this, methods[1...N], args);</span>\n                code.append(<span class=\"hljs-string\">\" Object ret = handler.invoke(this, methods[\"</span> + ix + <span class=\"hljs-string\">\"], args);\"</span>);\n\n                <span class=\"hljs-comment\">// 返回值不为 void</span>\n                <span class=\"hljs-keyword\">if</span> (!Void.TYPE.equals(rt))\n                    <span class=\"hljs-comment\">// 生成返回语句，形如 return (java.lang.String) ret;</span>\n                    code.append(<span class=\"hljs-string\">\" return \"</span>).append(asArgument(rt, <span class=\"hljs-string\">\"ret\"</span>)).append(<span class=\"hljs-string\">\";\"</span>);\n\n                methods.add(method);\n                <span class=\"hljs-comment\">// 添加方法名、访问控制符、参数列表、方法代码等信息到 ClassGenerator 中 </span>\n                ccp.addMethod(method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString());\n            }\n        }\n\n        <span class=\"hljs-keyword\">if</span> (pkg == <span class=\"hljs-keyword\">null</span>)\n            pkg = PACKAGE_NAME;\n\n        <span class=\"hljs-comment\">// 构建接口代理类名称：pkg + \".proxy\" + id，比如 org.apache.dubbo.proxy0</span>\n        String pcn = pkg + <span class=\"hljs-string\">\".proxy\"</span> + id;\n        ccp.setClassName(pcn);\n        ccp.addField(<span class=\"hljs-string\">\"public static java.lang.reflect.Method[] methods;\"</span>);\n        <span class=\"hljs-comment\">// 生成 private java.lang.reflect.InvocationHandler handler;</span>\n        ccp.addField(<span class=\"hljs-string\">\"private \"</span> + InvocationHandler.class.getName() + <span class=\"hljs-string\">\" handler;\"</span>);\n\n        <span class=\"hljs-comment\">// 为接口代理类添加带有 InvocationHandler 参数的构造方法，比如：</span>\n        <span class=\"hljs-comment\">// porxy0(java.lang.reflect.InvocationHandler arg0) {</span>\n        <span class=\"hljs-comment\">//     handler=$1;</span>\n    \t<span class=\"hljs-comment\">// }</span>\n        ccp.addConstructor(Modifier.PUBLIC, <span class=\"hljs-keyword\">new</span> Class&lt;?&gt;[]{InvocationHandler.class}, <span class=\"hljs-keyword\">new</span> Class&lt;?&gt;[<span class=\"hljs-number\">0</span>], <span class=\"hljs-string\">\"handler=$1;\"</span>);\n        <span class=\"hljs-comment\">// 为接口代理类添加默认构造方法</span>\n        ccp.addDefaultConstructor();\n        \n        <span class=\"hljs-comment\">// 生成接口代理类</span>\n        Class&lt;?&gt; clazz = ccp.toClass();\n        clazz.getField(<span class=\"hljs-string\">\"methods\"</span>).set(<span class=\"hljs-keyword\">null</span>, methods.toArray(<span class=\"hljs-keyword\">new</span> Method[<span class=\"hljs-number\">0</span>]));\n\n        <span class=\"hljs-comment\">// 构建 Proxy 子类名称，比如 Proxy1，Proxy2 等</span>\n        String fcn = Proxy.class.getName() + id;\n        ccm = ClassGenerator.newInstance(cl);\n        ccm.setClassName(fcn);\n        ccm.addDefaultConstructor();\n        ccm.setSuperClass(Proxy.class);\n        <span class=\"hljs-comment\">// 为 Proxy 的抽象方法 newInstance 生成实现代码，形如：</span>\n        <span class=\"hljs-comment\">// public Object newInstance(java.lang.reflect.InvocationHandler h) { </span>\n        <span class=\"hljs-comment\">//     return new org.apache.dubbo.proxy0($1);</span>\n        <span class=\"hljs-comment\">// }</span>\n        ccm.addMethod(<span class=\"hljs-string\">\"public Object newInstance(\"</span> + InvocationHandler.class.getName() + <span class=\"hljs-string\">\" h){ return new \"</span> + pcn + <span class=\"hljs-string\">\"($1); }\"</span>);\n        <span class=\"hljs-comment\">// 生成 Proxy 实现类</span>\n        Class&lt;?&gt; pc = ccm.toClass();\n        <span class=\"hljs-comment\">// 通过反射创建 Proxy 实例</span>\n        proxy = (Proxy) pc.newInstance();\n    } <span class=\"hljs-keyword\">catch</span> (RuntimeException e) {\n        <span class=\"hljs-keyword\">throw</span> e;\n    } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(e.getMessage(), e);\n    } <span class=\"hljs-keyword\">finally</span> {\n        <span class=\"hljs-keyword\">if</span> (ccp != <span class=\"hljs-keyword\">null</span>)\n            <span class=\"hljs-comment\">// 释放资源</span>\n            ccp.release();\n        <span class=\"hljs-keyword\">if</span> (ccm != <span class=\"hljs-keyword\">null</span>)\n            ccm.release();\n        <span class=\"hljs-keyword\">synchronized</span> (cache) {\n            <span class=\"hljs-keyword\">if</span> (proxy == <span class=\"hljs-keyword\">null</span>)\n                cache.remove(key);\n            <span class=\"hljs-keyword\">else</span>\n                <span class=\"hljs-comment\">// 写缓存</span>\n                cache.put(key, <span class=\"hljs-keyword\">new</span> WeakReference&lt;Proxy&gt;(proxy));\n            <span class=\"hljs-comment\">// 唤醒其他等待线程</span>\n            cache.notifyAll();\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> proxy;\n}\n</code></pre>\n<p>上面代码比较复杂，我们写了大量的注释。大家在阅读这段代码时，要搞清楚 ccp 和 ccm 的用途，不然会被搞晕。ccp 用于为服务接口生成代理类，比如我们有一个 DemoService 接口，这个接口代理类就是由 ccp 生成的。ccm 则是用于为 org.apache.dubbo.common.bytecode.Proxy 抽象类生成子类，主要是实现 Proxy 类的抽象方法。下面以 org.apache.dubbo.demo.DemoService 这个接口为例，来看一下该接口代理类代码大致是怎样的（忽略 EchoService 接口）。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> org.apache.dubbo.common.bytecode;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">proxy0</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">org</span>.<span class=\"hljs-title\">apache</span>.<span class=\"hljs-title\">dubbo</span>.<span class=\"hljs-title\">demo</span>.<span class=\"hljs-title\">DemoService</span> </span>{\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> java.lang.reflect.Method[] methods;\n\n    <span class=\"hljs-keyword\">private</span> java.lang.reflect.InvocationHandler handler;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">proxy0</span><span class=\"hljs-params\">()</span> </span>{\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">proxy0</span><span class=\"hljs-params\">(java.lang.reflect.InvocationHandler arg0)</span> </span>{\n        handler = $<span class=\"hljs-number\">1</span>;\n    }\n\n    <span class=\"hljs-keyword\">public</span> java.lang.<span class=\"hljs-function\">String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(java.lang.String arg0)</span> </span>{\n        Object[] args = <span class=\"hljs-keyword\">new</span> Object[<span class=\"hljs-number\">1</span>];\n        args[<span class=\"hljs-number\">0</span>] = ($w) $<span class=\"hljs-number\">1</span>;\n        Object ret = handler.invoke(<span class=\"hljs-keyword\">this</span>, methods[<span class=\"hljs-number\">0</span>], args);\n        <span class=\"hljs-keyword\">return</span> (java.lang.String) ret;\n    }\n}\n</code></pre>\n<p>好了，到这里代理类生成逻辑就分析完了。整个过程比较复杂，大家需要耐心看一下。</p>\n<h2>4.总结</h2>\n<p>本篇文章对服务引用的过程进行了较为详尽的分析，还有一些逻辑暂时没有分析到，比如  Directory、Cluster。这些接口及实现类功能比较独立，后续会单独成文进行分析。暂时我们可以先把这些类看成黑盒，只要知道这些类的用途即可。关于服务引用过程就分析到这里。</p>\n",
  "link": "/zh-cn/docs/source_code_guide/refer-service.html",
  "meta": {
    "title": "服务引用",
    "keywords": "Dubbo, service, refer",
    "description": "本文介绍了 Dubbo 服务引用的过程和实现细节"
  }
}