{
  "filename": "router.md",
  "__html": "<h2>1. 简介</h2>\n<p>上一篇文章分析了集群容错的第一部分 — 服务目录 Directory。服务目录在刷新 Invoker 列表的过程中，会通过 Router 进行服务路由，筛选出符合路由规则的服务提供者。在详细分析服务路由的源码之前，先来介绍一下服务路由是什么。服务路由包含一条路由规则，路由规则决定了服务消费者的调用目标，即规定了服务消费者可调用哪些服务提供者。Dubbo 目前提供了三种服务路由实现，分别为条件路由 ConditionRouter、脚本路由 ScriptRouter 和标签路由 TagRouter。其中条件路由是我们最常使用的，标签路由是一个新的实现，暂时还未发布，该实现预计会在 2.7.x 版本中发布。本篇文章将分析条件路由相关源码，脚本路由和标签路由这里就不分析了。</p>\n<h2>2. 源码分析</h2>\n<p>条件路由规则由两个条件组成，分别用于对服务消费者和提供者进行匹配。比如有这样一条规则：</p>\n<p><code>host = 10.20.153.10 =&gt; host = 10.20.153.11</code></p>\n<p>该条规则表示 IP 为 10.20.153.10 的服务消费者<strong>只可</strong>调用 IP 为 10.20.153.11 机器上的服务，不可调用其他机器上的服务。条件路由规则的格式如下：</p>\n<p><code>[服务消费者匹配条件] =&gt; [服务提供者匹配条件]</code></p>\n<p>如果服务消费者匹配条件为空，表示不对服务消费者进行限制。如果服务提供者匹配条件为空，表示对某些服务消费者禁用服务。官方文档中对条件路由进行了比较详细的介绍，大家可以参考下，这里就不过多说明了。</p>\n<p>条件路由实现类 ConditionRouter 在进行工作前，需要先对用户配置的路由规则进行解析，得到一系列的条件。然后再根据这些条件对服务进行路由。本章将分两节进行说明，2.1节介绍表达式解析过程。2.2 节介绍服务路由的过程。下面，我们先从表达式解析过程看起。</p>\n<h3>2.1 表达式解析</h3>\n<p>条件路由规则是一条字符串，对于 Dubbo 来说，它并不能直接理解字符串的意思，需要将其解析成内部格式才行。条件表达式的解析过程始于 ConditionRouter 的构造方法，下面一起看一下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ConditionRouter</span><span class=\"hljs-params\">(URL url)</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.url = url;\n    <span class=\"hljs-comment\">// 获取 priority 和 force 配置</span>\n    <span class=\"hljs-keyword\">this</span>.priority = url.getParameter(Constants.PRIORITY_KEY, <span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-keyword\">this</span>.force = url.getParameter(Constants.FORCE_KEY, <span class=\"hljs-keyword\">false</span>);\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-comment\">// 获取路由规则</span>\n        String rule = url.getParameterAndDecoded(Constants.RULE_KEY);\n        <span class=\"hljs-keyword\">if</span> (rule == <span class=\"hljs-keyword\">null</span> || rule.trim().length() == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"Illegal route rule!\"</span>);\n        }\n        rule = rule.replace(<span class=\"hljs-string\">\"consumer.\"</span>, <span class=\"hljs-string\">\"\"</span>).replace(<span class=\"hljs-string\">\"provider.\"</span>, <span class=\"hljs-string\">\"\"</span>);\n        <span class=\"hljs-comment\">// 定位 =&gt; 分隔符</span>\n        <span class=\"hljs-keyword\">int</span> i = rule.indexOf(<span class=\"hljs-string\">\"=&gt;\"</span>);\n        <span class=\"hljs-comment\">// 分别获取服务消费者和提供者匹配规则</span>\n        String whenRule = i &lt; <span class=\"hljs-number\">0</span> ? <span class=\"hljs-keyword\">null</span> : rule.substring(<span class=\"hljs-number\">0</span>, i).trim();\n        String thenRule = i &lt; <span class=\"hljs-number\">0</span> ? rule.trim() : rule.substring(i + <span class=\"hljs-number\">2</span>).trim();\n        <span class=\"hljs-comment\">// 解析服务消费者匹配规则</span>\n        Map&lt;String, MatchPair&gt; when = \n            StringUtils.isBlank(whenRule) || <span class=\"hljs-string\">\"true\"</span>.equals(whenRule) \n                ? <span class=\"hljs-keyword\">new</span> HashMap&lt;String, MatchPair&gt;() : parseRule(whenRule);\n        <span class=\"hljs-comment\">// 解析服务提供者匹配规则</span>\n        Map&lt;String, MatchPair&gt; then = \n            StringUtils.isBlank(thenRule) || <span class=\"hljs-string\">\"false\"</span>.equals(thenRule) \n                ? <span class=\"hljs-keyword\">null</span> : parseRule(thenRule);\n        <span class=\"hljs-comment\">// 将解析出的匹配规则分别赋值给 whenCondition 和 thenCondition 成员变量</span>\n        <span class=\"hljs-keyword\">this</span>.whenCondition = when;\n        <span class=\"hljs-keyword\">this</span>.thenCondition = then;\n    } <span class=\"hljs-keyword\">catch</span> (ParseException e) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(e.getMessage(), e);\n    }\n}\n</code></pre>\n<p>如上，ConditionRouter 构造方法先是对路由规则做预处理，然后调用 parseRule 方法分别对服务提供者和消费者规则进行解析，最后将解析结果赋值给 whenCondition 和 thenCondition 成员变量。ConditionRouter 构造方法不是很复杂，这里就不多说了。下面我们把重点放在 parseRule 方法上，在详细介绍这个方法之前，我们先来看一个内部类。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MatchPair</span> </span>{\n    <span class=\"hljs-keyword\">final</span> Set&lt;String&gt; matches = <span class=\"hljs-keyword\">new</span> HashSet&lt;String&gt;();\n    <span class=\"hljs-keyword\">final</span> Set&lt;String&gt; mismatches = <span class=\"hljs-keyword\">new</span> HashSet&lt;String&gt;();\n}\n</code></pre>\n<p>MatchPair 内部包含了两个 Set 类型的成员变量，分别用于存放匹配和不匹配的条件。这个类两个成员变量会在 parseRule 方法中被用到，下面来看一下。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Map&lt;String, MatchPair&gt; <span class=\"hljs-title\">parseRule</span><span class=\"hljs-params\">(String rule)</span>\n        <span class=\"hljs-keyword\">throws</span> ParseException </span>{\n    <span class=\"hljs-comment\">// 定义条件映射集合</span>\n    Map&lt;String, MatchPair&gt; condition = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, MatchPair&gt;();\n    <span class=\"hljs-keyword\">if</span> (StringUtils.isBlank(rule)) {\n        <span class=\"hljs-keyword\">return</span> condition;\n    }\n    MatchPair pair = <span class=\"hljs-keyword\">null</span>;\n    Set&lt;String&gt; values = <span class=\"hljs-keyword\">null</span>;\n    <span class=\"hljs-comment\">// 通过正则表达式匹配路由规则，ROUTE_PATTERN = ([&amp;!=,]*)\\s*([^&amp;!=,\\s]+)</span>\n    <span class=\"hljs-comment\">// 这个表达式看起来不是很好理解，第一个括号内的表达式用于匹配\"&amp;\", \"!\", \"=\" 和 \",\" 等符号。</span>\n    <span class=\"hljs-comment\">// 第二括号内的用于匹配英文字母，数字等字符。举个例子说明一下：</span>\n    <span class=\"hljs-comment\">//    host = 2.2.2.2 &amp; host != 1.1.1.1 &amp; method = hello</span>\n    <span class=\"hljs-comment\">// 匹配结果如下：</span>\n    <span class=\"hljs-comment\">//     括号一      括号二</span>\n    <span class=\"hljs-comment\">// 1.  null       host</span>\n    <span class=\"hljs-comment\">// 2.   =         2.2.2.2</span>\n    <span class=\"hljs-comment\">// 3.   &amp;         host</span>\n    <span class=\"hljs-comment\">// 4.   !=        1.1.1.1 </span>\n    <span class=\"hljs-comment\">// 5.   &amp;         method</span>\n    <span class=\"hljs-comment\">// 6.   =         hello</span>\n    <span class=\"hljs-keyword\">final</span> Matcher matcher = ROUTE_PATTERN.matcher(rule);\n    <span class=\"hljs-keyword\">while</span> (matcher.find()) {\n       \t<span class=\"hljs-comment\">// 获取括号一内的匹配结果</span>\n        String separator = matcher.group(<span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-comment\">// 获取括号二内的匹配结果</span>\n        String content = matcher.group(<span class=\"hljs-number\">2</span>);\n        <span class=\"hljs-comment\">// 分隔符为空，表示匹配的是表达式的开始部分</span>\n        <span class=\"hljs-keyword\">if</span> (separator == <span class=\"hljs-keyword\">null</span> || separator.length() == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-comment\">// 创建 MatchPair 对象</span>\n            pair = <span class=\"hljs-keyword\">new</span> MatchPair();\n            <span class=\"hljs-comment\">// 存储 &lt;匹配项, MatchPair&gt; 键值对，比如 &lt;host, MatchPair&gt;</span>\n            condition.put(content, pair); \n        } \n        \n        <span class=\"hljs-comment\">// 如果分隔符为 &amp;，表明接下来也是一个条件</span>\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">\"&amp;\"</span>.equals(separator)) {\n            <span class=\"hljs-comment\">// 尝试从 condition 获取 MatchPair</span>\n            <span class=\"hljs-keyword\">if</span> (condition.get(content) == <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-comment\">// 未获取到 MatchPair，重新创建一个，并放入 condition 中</span>\n                pair = <span class=\"hljs-keyword\">new</span> MatchPair();\n                condition.put(content, pair);\n            } <span class=\"hljs-keyword\">else</span> {\n                pair = condition.get(content);\n            }\n        } \n        \n        <span class=\"hljs-comment\">// 分隔符为 =</span>\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">\"=\"</span>.equals(separator)) {\n            <span class=\"hljs-keyword\">if</span> (pair == <span class=\"hljs-keyword\">null</span>)\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ParseException(<span class=\"hljs-string\">\"Illegal route rule ...\"</span>);\n\n            values = pair.matches;\n            <span class=\"hljs-comment\">// 将 content 存入到 MatchPair 的 matches 集合中</span>\n            values.add(content);\n        } \n        \n        <span class=\"hljs-comment\">//  分隔符为 != </span>\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">\"!=\"</span>.equals(separator)) {\n            <span class=\"hljs-keyword\">if</span> (pair == <span class=\"hljs-keyword\">null</span>)\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ParseException(<span class=\"hljs-string\">\"Illegal route rule ...\"</span>);\n\n            values = pair.mismatches;\n            <span class=\"hljs-comment\">// 将 content 存入到 MatchPair 的 mismatches 集合中</span>\n            values.add(content);\n        }\n        \n        <span class=\"hljs-comment\">// 分隔符为 ,</span>\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">\",\"</span>.equals(separator)) {\n            <span class=\"hljs-keyword\">if</span> (values == <span class=\"hljs-keyword\">null</span> || values.isEmpty())\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ParseException(<span class=\"hljs-string\">\"Illegal route rule ...\"</span>);\n            <span class=\"hljs-comment\">// 将 content 存入到上一步获取到的 values 中，可能是 matches，也可能是 mismatches</span>\n            values.add(content);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ParseException(<span class=\"hljs-string\">\"Illegal route rule ...\"</span>);\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> condition;\n}\n</code></pre>\n<p>以上就是路由规则的解析逻辑，该逻辑由正则表达式和一个 while 循环以及数个条件分支组成。下面通过一个示例对解析逻辑进行演绎。示例为 <code>host = 2.2.2.2 &amp; host != 1.1.1.1 &amp; method = hello</code>。正则解析结果如下：</p>\n<pre><code>    括号一      括号二\n1.  null       host\n2.   =         2.2.2.2\n3.   &amp;         host\n4.   !=        1.1.1.1\n5.   &amp;         method\n6.   =         hello\n</code></pre>\n<p>现在线程进入 while 循环：</p>\n<p>第一次循环：分隔符 separator = null，content = &quot;host&quot;。此时创建 MatchPair 对象，并存入到 condition 中，condition = {&quot;host&quot;: MatchPair@123}</p>\n<p>第二次循环：分隔符 separator = &quot;=&quot;，content = &quot;2.2.2.2&quot;，pair = MatchPair@123。此时将 2.2.2.2 放入到 MatchPair@123 对象的 matches 集合中。</p>\n<p>第三次循环：分隔符 separator = &quot;&amp;&quot;，content = &quot;host&quot;。host 已存在于 condition 中，因此 pair = MatchPair@123。</p>\n<p>第四次循环：分隔符 separator = &quot;!=&quot;，content = &quot;1.1.1.1&quot;，pair = MatchPair@123。此时将 1.1.1.1 放入到 MatchPair@123 对象的 mismatches 集合中。</p>\n<p>第五次循环：分隔符 separator = &quot;&amp;&quot;，content = &quot;method&quot;。condition.get(&quot;method&quot;) = null，因此新建一个 MatchPair 对象，并放入到 condition 中。此时 condition = {&quot;host&quot;: MatchPair@123, &quot;method&quot;: MatchPair@ 456}</p>\n<p>第六次循环：分隔符 separator = &quot;=&quot;，content = &quot;2.2.2.2&quot;，pair = MatchPair@456。此时将 hello 放入到 MatchPair@456 对象的 matches 集合中。</p>\n<p>循环结束，此时 condition 的内容如下：</p>\n<pre><code class=\"language-json\">{\n    <span class=\"hljs-attr\">\"host\"</span>: {\n        <span class=\"hljs-attr\">\"matches\"</span>: [<span class=\"hljs-string\">\"2.2.2.2\"</span>],\n        <span class=\"hljs-attr\">\"mismatches\"</span>: [<span class=\"hljs-string\">\"1.1.1.1\"</span>]\n    },\n    <span class=\"hljs-attr\">\"method\"</span>: {\n        <span class=\"hljs-attr\">\"matches\"</span>: [<span class=\"hljs-string\">\"hello\"</span>],\n        <span class=\"hljs-attr\">\"mismatches\"</span>: []\n    }\n}\n</code></pre>\n<p>路由规则的解析过程稍微有点复杂，大家可通过 ConditionRouter 的测试类对该逻辑进行测试。并且找一个表达式，对照上面的代码走一遍，加深理解。</p>\n<h3>2.2 服务路由</h3>\n<p>服务路由的入口方法是 ConditionRouter 的 router 方法，该方法定义在 Router 接口中。实现代码如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) <span class=\"hljs-keyword\">throws</span> RpcException {\n    <span class=\"hljs-keyword\">if</span> (invokers == <span class=\"hljs-keyword\">null</span> || invokers.isEmpty()) {\n        <span class=\"hljs-keyword\">return</span> invokers;\n    }\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-comment\">// 先对服务消费者条件进行匹配，如果匹配失败，表明服务消费者 url 不符合匹配规则，</span>\n        <span class=\"hljs-comment\">// 无需进行后续匹配，直接返回 Invoker 列表即可。比如下面的规则：</span>\n        <span class=\"hljs-comment\">//     host = 10.20.153.10 =&gt; host = 10.0.0.10</span>\n        <span class=\"hljs-comment\">// 这条路由规则希望 IP 为 10.20.153.10 的服务消费者调用 IP 为 10.0.0.10 机器上的服务。</span>\n        <span class=\"hljs-comment\">// 当消费者 ip 为 10.20.153.11 时，matchWhen 返回 false，表明当前这条路由规则不适用于</span>\n        <span class=\"hljs-comment\">// 当前的服务消费者，此时无需再进行后续匹配，直接返回即可。</span>\n        <span class=\"hljs-keyword\">if</span> (!matchWhen(url, invocation)) {\n            <span class=\"hljs-keyword\">return</span> invokers;\n        }\n        List&lt;Invoker&lt;T&gt;&gt; result = <span class=\"hljs-keyword\">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();\n        <span class=\"hljs-comment\">// 服务提供者匹配条件未配置，表明对指定的服务消费者禁用服务，也就是服务消费者在黑名单中</span>\n        <span class=\"hljs-keyword\">if</span> (thenCondition == <span class=\"hljs-keyword\">null</span>) {\n            logger.warn(<span class=\"hljs-string\">\"The current consumer in the service blacklist...\"</span>);\n            <span class=\"hljs-keyword\">return</span> result;\n        }\n        <span class=\"hljs-comment\">// 这里可以简单的把 Invoker 理解为服务提供者，现在使用服务提供者匹配规则对 </span>\n        <span class=\"hljs-comment\">// Invoker 列表进行匹配</span>\n        <span class=\"hljs-keyword\">for</span> (Invoker&lt;T&gt; invoker : invokers) {\n            <span class=\"hljs-comment\">// 若匹配成功，表明当前 Invoker 符合服务提供者匹配规则。</span>\n            <span class=\"hljs-comment\">// 此时将 Invoker 添加到 result 列表中</span>\n            <span class=\"hljs-keyword\">if</span> (matchThen(invoker.getUrl(), url)) {\n                result.add(invoker);\n            }\n        }\n        \n        <span class=\"hljs-comment\">// 返回匹配结果，如果 result 为空列表，且 force = true，表示强制返回空列表，</span>\n        <span class=\"hljs-comment\">// 否则路由结果为空的路由规则将自动失效</span>\n        <span class=\"hljs-keyword\">if</span> (!result.isEmpty()) {\n            <span class=\"hljs-keyword\">return</span> result;\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (force) {\n            logger.warn(<span class=\"hljs-string\">\"The route result is empty and force execute ...\"</span>);\n            <span class=\"hljs-keyword\">return</span> result;\n        }\n    } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n        logger.error(<span class=\"hljs-string\">\"Failed to execute condition router rule: ...\"</span>);\n    }\n    \n    <span class=\"hljs-comment\">// 原样返回，此时 force = false，表示该条路由规则失效</span>\n    <span class=\"hljs-keyword\">return</span> invokers;\n}\n</code></pre>\n<p>router 方法先是调用 matchWhen 对服务消费者进行匹配，如果匹配失败，直接返回 Invoker 列表。如果匹配成功，再对服务提供者进行匹配，匹配逻辑封装在了 matchThen 方法中。下面来看一下这两个方法的逻辑：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">matchWhen</span><span class=\"hljs-params\">(URL url, Invocation invocation)</span> </span>{\n    <span class=\"hljs-comment\">// 服务消费者条件为 null 或空，均返回 true，比如：</span>\n    <span class=\"hljs-comment\">//     =&gt; host != 172.22.3.91</span>\n    <span class=\"hljs-comment\">// 表示所有的服务消费者都不得调用 IP 为 172.22.3.91 的机器上的服务</span>\n    <span class=\"hljs-keyword\">return</span> whenCondition == <span class=\"hljs-keyword\">null</span> || whenCondition.isEmpty() \n        || matchCondition(whenCondition, url, <span class=\"hljs-keyword\">null</span>, invocation);  <span class=\"hljs-comment\">// 进行条件匹配</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">matchThen</span><span class=\"hljs-params\">(URL url, URL param)</span> </span>{\n    <span class=\"hljs-comment\">// 服务提供者条件为 null 或空，表示禁用服务</span>\n    <span class=\"hljs-keyword\">return</span> !(thenCondition == <span class=\"hljs-keyword\">null</span> || thenCondition.isEmpty()) \n        &amp;&amp; matchCondition(thenCondition, url, param, <span class=\"hljs-keyword\">null</span>);  <span class=\"hljs-comment\">// 进行条件匹配</span>\n}\n</code></pre>\n<p>这两个方法长的有点像，不过逻辑上还是有差别的，大家注意看。这两个方法均调用了 matchCondition 方法，但它们所传入的参数是不同的。这个需要特别注意一下，不然后面的逻辑不好弄懂。下面我们对这几个参数进行溯源。matchWhen 方法向 matchCondition 方法传入的参数为 [whenCondition, url, null, invocation]，第一个参数 whenCondition 为服务消费者匹配条件，这个前面分析过。第二个参数 url 源自 route 方法的参数列表，该参数由外部类调用 route 方法时传入。比如：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, String method) {\n    Invocation invocation = <span class=\"hljs-keyword\">new</span> RpcInvocation(method, <span class=\"hljs-keyword\">new</span> Class&lt;?&gt;[<span class=\"hljs-number\">0</span>], <span class=\"hljs-keyword\">new</span> Object[<span class=\"hljs-number\">0</span>]);\n    List&lt;Router&gt; routers = getRouters();\n    <span class=\"hljs-keyword\">if</span> (routers != <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-keyword\">for</span> (Router router : routers) {\n            <span class=\"hljs-keyword\">if</span> (router.getUrl() != <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-comment\">// 注意第二个参数</span>\n                invokers = router.route(invokers, getConsumerUrl(), invocation);\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> invokers;\n}\n</code></pre>\n<p>上面这段代码来自 RegistryDirectory，第二个参数表示的是服务消费者 url。matchCondition 的 invocation 参数也是从这里传入的。</p>\n<p>接下来再来看看 matchThen 向 matchCondition 方法传入的参数 [thenCondition, url, param, null]。第一个参数不用解释了。第二个和第三个参数来自 matchThen 方法的参数列表，这两个参数分别为服务提供者 url 和服务消费者 url。搞清楚这些参数来源后，接下来就可以分析 matchCondition 方法了。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">matchCondition</span><span class=\"hljs-params\">(Map&lt;String, MatchPair&gt; condition, URL url, URL param, Invocation invocation)</span> </span>{\n    <span class=\"hljs-comment\">// 将服务提供者或消费者 url 转成 Map</span>\n    Map&lt;String, String&gt; sample = url.toMap();\n    <span class=\"hljs-keyword\">boolean</span> result = <span class=\"hljs-keyword\">false</span>;\n    <span class=\"hljs-comment\">// 遍历 condition 列表</span>\n    <span class=\"hljs-keyword\">for</span> (Map.Entry&lt;String, MatchPair&gt; matchPair : condition.entrySet()) {\n        <span class=\"hljs-comment\">// 获取匹配项名称，比如 host、method 等</span>\n        String key = matchPair.getKey();\n        String sampleValue;\n        <span class=\"hljs-comment\">// 如果 invocation 不为空，且 key 为 mehtod(s)，表示进行方法匹配</span>\n        <span class=\"hljs-keyword\">if</span> (invocation != <span class=\"hljs-keyword\">null</span> &amp;&amp; (Constants.METHOD_KEY.equals(key) || Constants.METHODS_KEY.equals(key))) {\n            <span class=\"hljs-comment\">// 从 invocation 获取被调用方法的名称</span>\n            sampleValue = invocation.getMethodName();\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// 从服务提供者或消费者 url 中获取指定字段值，比如 host、application 等</span>\n            sampleValue = sample.get(key);\n            <span class=\"hljs-keyword\">if</span> (sampleValue == <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-comment\">// 尝试通过 default.xxx 获取相应的值</span>\n                sampleValue = sample.get(Constants.DEFAULT_KEY_PREFIX + key);\n            }\n        }\n        \n        <span class=\"hljs-comment\">// --------------------✨ 分割线 ✨-------------------- //</span>\n        \n        <span class=\"hljs-keyword\">if</span> (sampleValue != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-comment\">// 调用 MatchPair 的 isMatch 方法进行匹配</span>\n            <span class=\"hljs-keyword\">if</span> (!matchPair.getValue().isMatch(sampleValue, param)) {\n                <span class=\"hljs-comment\">// 只要有一个规则匹配失败，立即返回 false 结束方法逻辑</span>\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n            } <span class=\"hljs-keyword\">else</span> {\n                result = <span class=\"hljs-keyword\">true</span>;\n            }\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// sampleValue 为空，表明服务提供者或消费者 url 中不包含相关字段。此时如果 </span>\n            <span class=\"hljs-comment\">// MatchPair 的 matches 不为空，表示匹配失败，返回 false。比如我们有这样</span>\n            <span class=\"hljs-comment\">// 一条匹配条件 loadbalance = random，假设 url 中并不包含 loadbalance 参数，</span>\n            <span class=\"hljs-comment\">// 此时 sampleValue = null。既然路由规则里限制了 loadbalance 必须为 random，</span>\n            <span class=\"hljs-comment\">// 但 sampleValue = null，明显不符合规则，因此返回 false</span>\n            <span class=\"hljs-keyword\">if</span> (!matchPair.getValue().matches.isEmpty()) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n            } <span class=\"hljs-keyword\">else</span> {\n                result = <span class=\"hljs-keyword\">true</span>;\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> result;\n}\n</code></pre>\n<p>如上，matchCondition 方法看起来有点复杂，这里简单说明一下。分割线以上的代码实际上用于获取 sampleValue 的值，分割线以下才是进行条件匹配。条件匹配调用的逻辑封装在 isMatch 中，代码如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isMatch</span><span class=\"hljs-params\">(String value, URL param)</span> </span>{\n    <span class=\"hljs-comment\">// 情况一：matches 非空，mismatches 为空</span>\n    <span class=\"hljs-keyword\">if</span> (!matches.isEmpty() &amp;&amp; mismatches.isEmpty()) {\n        <span class=\"hljs-comment\">// 遍历 matches 集合，检测入参 value 是否能被 matches 集合元素匹配到。</span>\n        <span class=\"hljs-comment\">// 举个例子，如果 value = 10.20.153.11，matches = [10.20.153.*],</span>\n        <span class=\"hljs-comment\">// 此时 isMatchGlobPattern 方法返回 true</span>\n        <span class=\"hljs-keyword\">for</span> (String match : matches) {\n            <span class=\"hljs-keyword\">if</span> (UrlUtils.isMatchGlobPattern(match, value, param)) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n            }\n        }\n        \n        <span class=\"hljs-comment\">// 如果所有匹配项都无法匹配到入参，则返回 false</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n\n    <span class=\"hljs-comment\">// 情况二：matches 为空，mismatches 非空</span>\n    <span class=\"hljs-keyword\">if</span> (!mismatches.isEmpty() &amp;&amp; matches.isEmpty()) {\n        <span class=\"hljs-keyword\">for</span> (String mismatch : mismatches) {\n            <span class=\"hljs-comment\">// 只要入参被 mismatches 集合中的任意一个元素匹配到，就返回 false</span>\n            <span class=\"hljs-keyword\">if</span> (UrlUtils.isMatchGlobPattern(mismatch, value, param)) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n            }\n        }\n        <span class=\"hljs-comment\">// mismatches 集合中所有元素都无法匹配到入参，此时返回 true</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    }\n\n    <span class=\"hljs-comment\">// 情况三：matches 非空，mismatches 非空</span>\n    <span class=\"hljs-keyword\">if</span> (!matches.isEmpty() &amp;&amp; !mismatches.isEmpty()) {\n        <span class=\"hljs-comment\">// matches 和 mismatches 均为非空，此时优先使用 mismatches 集合元素对入参进行匹配。</span>\n        <span class=\"hljs-comment\">// 只要 mismatches 集合中任意一个元素与入参匹配成功，就立即返回 false，结束方法逻辑</span>\n        <span class=\"hljs-keyword\">for</span> (String mismatch : mismatches) {\n            <span class=\"hljs-keyword\">if</span> (UrlUtils.isMatchGlobPattern(mismatch, value, param)) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n            }\n        }\n        <span class=\"hljs-comment\">// mismatches 集合元素无法匹配到入参，此时再使用 matches 继续匹配</span>\n        <span class=\"hljs-keyword\">for</span> (String match : matches) {\n            <span class=\"hljs-comment\">// 只要 matches 集合中任意一个元素与入参匹配成功，就立即返回 true</span>\n            <span class=\"hljs-keyword\">if</span> (UrlUtils.isMatchGlobPattern(match, value, param)) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n            }\n        }\n        \n        <span class=\"hljs-comment\">// 全部失配，则返回 false</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n    \n    <span class=\"hljs-comment\">// 情况四：matches 和 mismatches 均为空，此时返回 false</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n}\n</code></pre>\n<p>isMatch 方法逻辑比较清晰，由三个条件分支组成，用于处理四种情况。这里对四种情况下的匹配逻辑进行简单的总结，如下：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>条件</th>\n<th>过程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>情况一</td>\n<td>matches 非空，mismatches 为空</td>\n<td>遍历 matches 集合元素，并与入参进行匹配。只要有一个元素成功匹配入参，即可返回 true。若全部失配，则返回 false。</td>\n</tr>\n<tr>\n<td>情况二</td>\n<td>matches 为空，mismatches 非空</td>\n<td>遍历 mismatches 集合元素，并与入参进行匹配。只要有一个元素成功匹配入参，立即 false。若全部失配，则返回 true。</td>\n</tr>\n<tr>\n<td>情况三</td>\n<td>matches 非空，mismatches 非空</td>\n<td>优先使用 mismatches 集合元素对入参进行匹配，只要任一元素与入参匹配成功，就立即返回 false，结束方法逻辑。否则再使用 matches 中的集合元素进行匹配，只要有任意一个元素匹配成功，即可返回 true。若全部失配，则返回 false</td>\n</tr>\n<tr>\n<td>情况四</td>\n<td>matches 为空，mismatches 为空</td>\n<td>直接返回 false</td>\n</tr>\n</tbody>\n</table>\n<p>isMatch 方法是通过 UrlUtils 的 isMatchGlobPattern 方法进行匹配，因此下面我们再来看看 isMatchGlobPattern 方法的逻辑。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isMatchGlobPattern</span><span class=\"hljs-params\">(String pattern, String value, URL param)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (param != <span class=\"hljs-keyword\">null</span> &amp;&amp; pattern.startsWith(<span class=\"hljs-string\">\"$\"</span>)) {\n        <span class=\"hljs-comment\">// 引用服务消费者参数，param 参数为服务消费者 url</span>\n        pattern = param.getRawParameter(pattern.substring(<span class=\"hljs-number\">1</span>));\n    }\n    <span class=\"hljs-comment\">// 调用重载方法继续比较</span>\n    <span class=\"hljs-keyword\">return</span> isMatchGlobPattern(pattern, value);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isMatchGlobPattern</span><span class=\"hljs-params\">(String pattern, String value)</span> </span>{\n    <span class=\"hljs-comment\">// 对 * 通配符提供支持</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">\"*\"</span>.equals(pattern))\n        <span class=\"hljs-comment\">// 匹配规则为通配符 *，直接返回 true 即可</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    <span class=\"hljs-keyword\">if</span> ((pattern == <span class=\"hljs-keyword\">null</span> || pattern.length() == <span class=\"hljs-number\">0</span>)\n            &amp;&amp; (value == <span class=\"hljs-keyword\">null</span> || value.length() == <span class=\"hljs-number\">0</span>))\n        <span class=\"hljs-comment\">// pattern 和 value 均为空，此时可认为两者相等，返回 true</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    <span class=\"hljs-keyword\">if</span> ((pattern == <span class=\"hljs-keyword\">null</span> || pattern.length() == <span class=\"hljs-number\">0</span>)\n            || (value == <span class=\"hljs-keyword\">null</span> || value.length() == <span class=\"hljs-number\">0</span>))\n        <span class=\"hljs-comment\">// pattern 和 value 其中有一个为空，表明两者不相等，返回 false</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n\n    <span class=\"hljs-comment\">// 定位 * 通配符位置</span>\n    <span class=\"hljs-keyword\">int</span> i = pattern.lastIndexOf(<span class=\"hljs-string\">'*'</span>);\n    <span class=\"hljs-keyword\">if</span> (i == -<span class=\"hljs-number\">1</span>) {\n        <span class=\"hljs-comment\">// 匹配规则中不包含通配符，此时直接比较 value 和 pattern 是否相等即可，并返回比较结果</span>\n        <span class=\"hljs-keyword\">return</span> value.equals(pattern);\n    }\n    <span class=\"hljs-comment\">// 通配符 \"*\" 在匹配规则尾部，比如 10.0.21.*</span>\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (i == pattern.length() - <span class=\"hljs-number\">1</span>) {\n        <span class=\"hljs-comment\">// 检测 value 是否以“不含通配符的匹配规则”开头，并返回结果。比如:</span>\n        <span class=\"hljs-comment\">// pattern = 10.0.21.*，value = 10.0.21.12，此时返回 true</span>\n        <span class=\"hljs-keyword\">return</span> value.startsWith(pattern.substring(<span class=\"hljs-number\">0</span>, i));\n    }\n    <span class=\"hljs-comment\">// 通配符 \"*\" 在匹配规则头部</span>\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (i == <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-comment\">// 检测 value 是否以“不含通配符的匹配规则”结尾，并返回结果</span>\n        <span class=\"hljs-keyword\">return</span> value.endsWith(pattern.substring(i + <span class=\"hljs-number\">1</span>));\n    }\n    <span class=\"hljs-comment\">// 通配符 \"*\" 在匹配规则中间位置</span>\n    <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 通过通配符将 pattern 分成两半，得到 prefix 和 suffix</span>\n        String prefix = pattern.substring(<span class=\"hljs-number\">0</span>, i);\n        String suffix = pattern.substring(i + <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-comment\">// 检测 value 是否以 prefix 开头，且以 suffix 结尾，并返回结果</span>\n        <span class=\"hljs-keyword\">return</span> value.startsWith(prefix) &amp;&amp; value.endsWith(suffix);\n    }\n}\n</code></pre>\n<p>以上就是 isMatchGlobPattern 两个重载方法的全部逻辑，这两个方法分别对普通的匹配过程，以及”引用消费者参数“和通配符匹配等特性提供了支持。这两个方法的逻辑不是很复杂，且代码中也进行了比较详细的注释，因此就不多说了。</p>\n<h2>3. 总结</h2>\n<p>本篇文章对条件路由的表达式解析和服务路由过程进行了较为细致的分析。总的来说，条件路由的代码还是有一些复杂的，需要静下心来看。在阅读条件路由代码的过程中，要多调试。一般的框架都会有单元测试，Dubbo 也不例外，因此大家可以直接通过 ConditionRouterTest 对条件路由进行调试，无需重头构建测试用例。</p>\n",
  "link": "/zh-cn/docs/source_code_guide/router.html",
  "meta": {
    "title": "服务路由",
    "keywords": "Dubbo, Router",
    "description": "本文介绍了服务\b路由的原理和实现细节"
  }
}