<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="Dubbo, Service" />
	<meta name="description" content="本文介绍了服务调用过程的原理和实现细节" />
	<!-- 网页标签标题 -->
	<title>服务调用过程</title>
	<link rel="shortcut icon" href="/img/dubbo.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/dubbo_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/user/quick-start.html">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/docs/developers/developers_dev.html">开发者</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html">博客</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html">社区</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/download.html">下载</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/docs.png" class="front-img"/><span>文档</span><img src="/img/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>用户文档</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>入门<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/background.html" target="_self">背景</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/requirements.html" target="_self">需求</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/architecture.html" target="_self">架构</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/usage.html" target="_self">用法</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/quick-start.html" target="_self">快速启动</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/dependencies.html" target="_self">依赖</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/maturity.html" target="_self">成熟度</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>配置<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/xml.html" target="_self">XML配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/properties.html" target="_self">属性配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/api.html" target="_self">API配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/annotation.html" target="_self">注解配置</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>示例<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/preflight-check.html" target="_self">启动时检查</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/fault-tolerent-strategy.html" target="_self">集群容错</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/loadbalance.html" target="_self">负载均衡</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/thread-model.html" target="_self">线程模型</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/explicit-target.html" target="_self">直连提供者</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/subscribe-only.html" target="_self">只订阅</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/registry-only.html" target="_self">只注册</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/static-service.html" target="_self">静态服务</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/multi-protocols.html" target="_self">多协议</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/multi-registry.html" target="_self">多注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/service-group.html" target="_self">服务分组</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/multi-versions.html" target="_self">多版本</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/group-merger.html" target="_self">分组聚合</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/parameter-validation.html" target="_self">参数验证</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/result-cache.html" target="_self">结果缓存</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/generic-reference.html" target="_self">泛化引用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/generic-service.html" target="_self">泛化实现</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/echo-service.html" target="_self">回声测试</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/context.html" target="_self">上下文信息</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/attachment.html" target="_self">隐式参数</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/async-call.html" target="_self">异步调用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/local-call.html" target="_self">本地调用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/callback-parameter.html" target="_self">参数回调</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/events-notify.html" target="_self">事件通知</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/local-stub.html" target="_self">本地存根</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/local-mock.html" target="_self">本地伪装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/delay-publish.html" target="_self">延迟暴露</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/concurrency-control.html" target="_self">并发控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/config-connections.html" target="_self">连接控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/lazy-connect.html" target="_self">延迟连接</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/stickiness.html" target="_self">粘滞连接</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/token-authorization.html" target="_self">令牌验证</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/routing-rule.html" target="_self">路由规则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/config-rule.html" target="_self">配置规则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/service-downgrade.html" target="_self">服务降级</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/graceful-shutdown.html" target="_self">优雅停机</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/hostname-binding.html" target="_self">主机绑定</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/logger-strategy.html" target="_self">日志适配</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/accesslog.html" target="_self">访问日志</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/service-container.html" target="_self">服务容器</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/reference-config-cache.html" target="_self">Reference Config 缓存</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/distributed-transaction.html" target="_self">分布式事务</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/dump.html" target="_self">线程栈自动dump</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/netty4.html" target="_self">Netty4</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/serialization.html" target="_self">Kryo和FST序列化</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/api.html" target="_self">API配置参考手册</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>schema配置参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-service.html" target="_self">dubbo:service</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-reference.html" target="_self">dubbo:reference</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-protocol.html" target="_self">dubbo:protocol</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-registry.html" target="_self">dubbo:registry</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-monitor.html" target="_self">dubbo:monitor</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-application.html" target="_self">dubbo:application</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-module.html" target="_self">dubbo:module</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-provider.html" target="_self">dubbo:provider</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-consumer.html" target="_self">dubbo:consumer</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-method.html" target="_self">dubbo:method</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-argument.html" target="_self">dubbo:argument</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-parameter.html" target="_self">dubbo:parameter</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>协议参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/dubbo.html" target="_self">dubbo://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/rmi.html" target="_self">rmi://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/hessian.html" target="_self">hessian://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/http.html" target="_self">http://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/webservice.html" target="_self">webservice://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/thrift.html" target="_self">thrift://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/memcached.html" target="_self">memcached://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/redis.html" target="_self">redis://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/rest.html" target="_self">rest://</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>注册中心参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/multicast.html" target="_self">Multicast 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/zookeeper.html" target="_self">Zookeeper 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/redis.html" target="_self">Redis 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/simple.html" target="_self">Simple 注册中心</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/telnet.html" target="_self">telnet命令参考手册</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/qos.html" target="_self">在线运维命令-QOS</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/maven.html" target="_self">maven插件参考手册</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/best-practice.html" target="_self">服务化最佳实践</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/recommend.html" target="_self">推荐用法</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/capacity-plan.html" target="_self">容量规划</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/perf-test.html" target="_self">性能测试报告</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/coveragence.html" target="_self">测试覆盖率报告</a></li></ul></li><li class="menu-item menu-item-level-1"><span>开发者指南</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/build.html" target="_self">源码构建</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/design.html" target="_self">框架设计</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/SPI.html" target="_self">扩展点加载</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/implementation.html" target="_self">实现细节</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>SPI 扩展实现<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/protocol.html" target="_self">协议扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/filter.html" target="_self">调用拦截扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/invoker-listener.html" target="_self">引用监听扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/exporter-listener.html" target="_self">暴露监听扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/cluster.html" target="_self">集群扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/router.html" target="_self">路由扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/load-balance.html" target="_self">负载均衡扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/merger.html" target="_self">合并结果扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/registry.html" target="_self">注册中心扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/monitor.html" target="_self">监控中心扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/extension-factory.html" target="_self">扩展点加载扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/proxy-factory.html" target="_self">动态代理扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/compiler.html" target="_self">编译器扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/dispatcher.html" target="_self">消息派发扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/threadpool.html" target="_self">线程池扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/serialize.html" target="_self">序列化扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/remoting.html" target="_self">网络传输扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/exchanger.html" target="_self">信息交换扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/networker.html" target="_self">组网扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/telnet-handler.html" target="_self">Telnet 命令扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/status-checker.html" target="_self">状态检查扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/container.html" target="_self">容器扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/page.html" target="_self">页面扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/cache.html" target="_self">缓存扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/validation.html" target="_self">验证扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/logger-adapter.html" target="_self">日志适配扩展</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/contract.html" target="_self">公共契约</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/coding.html" target="_self">编码约定</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>设计原则<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/code-detail.html" target="_self">魔鬼在细节</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/general-knowledge.html" target="_self">一些设计上的基本常识</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/expansibility.html" target="_self">谈谈扩充式扩展与增量式扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/configuration.html" target="_self">配置设计</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/robustness.html" target="_self">设计实现的健壮性</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/dummy.html" target="_self">防痴呆设计</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/extension.html" target="_self">扩展点重构</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/release.html" target="_self">版本管理</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/contribution.html" target="_self">贡献</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/checklist.html" target="_self">检查列表</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/code-smell.html" target="_self">坏味道</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/TCK.html" target="_self">技术兼容性测试</a></li></ul></li><li class="menu-item menu-item-level-1"><span>源码导读</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/dubbo-spi.html" target="_self">Dubbo SPI</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/adaptive-extension.html" target="_self">自适应拓展机制</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/export-service.html" target="_self">服务导出</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/refer-service.html" target="_self">服务引入</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/directory.html" target="_self">服务字典</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/router.html" target="_self">服务路由</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/cluster.html" target="_self">集群</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/loadbalance.html" target="_self">负载均衡</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/service-invoking-process.html" target="_self">服务调用过程</a></li></ul></li><li class="menu-item menu-item-level-1"><span>运维管理</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>安装手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/provider-demo.html" target="_self">示例提供者安装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/consumer-demo.html" target="_self">示例消费者安装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/zookeeper.html" target="_self">Zookeeper 注册中心安装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/redis.html" target="_self">Redis 注册中心安装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/simple-registry-center.html" target="_self">Simple 注册中心安装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/simple-monitor-center.html" target="_self">Simple 监控中心安装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/install/admin-console.html" target="_self">管理控制台安装</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>运维手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/ops/dubbo-ops.html" target="_self">管理控制台运维</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/ops/pinpoint.html" target="_self">使用Pinpoint做分布式跟踪</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/admin/ops/skywalking.html" target="_self">使用Skywalking做分布式跟踪</a></li></ul></li></ul></li></ul></div><div class="doc-content markdown-body"><h2>1. 简介</h2>
<p>在前面的文章中，我们分析了 Dubbo SPI、服务导出与引入、以及集群容错方面的代码。经过前文的铺垫，本篇文章我们终于可以分析服务调用过程了。Dubbo 服务调用过程比较复杂，包含众多步骤，比如发送请求、编解码、服务降级、过滤器链处理、序列化、线程派发以及响应请求等步骤。限于篇幅原因，本篇文章无法对所有的步骤一一进行分析。本篇文章将会重点分析请求的发送与接收、编解码、线程派发以及响应的发送与接收等过程，至于服务降级、过滤器链和序列化大家自行进行分析，也可以将其当成一个黑盒，暂时忽略也没关系。介绍完本篇文章要分析的内容，接下来我们进入正题吧。</p>
<h2>2. 源码分析</h2>
<p>在进行源码分析之前，我们先来通过一张图了解 Dubbo 服务调用过程。</p>
<p><img src="sources/images/send-request-process.jpg" alt=""></p>
<p>首先服务消费者通过代理对象 Proxy 发起远程调用，接着通过网络客户端 Client 将编码后的请求发送给服务提供方的网络层上，也就是 Server。Server 在收到请求后，首先要做的事情是对数据包进行解码。然后将解码后的请求发送至分发器 Dispatcher，再由分发器将请求派发到指定的线程池上，最后由线程池调用具体的服务。这就是一个远程调用请求的发送与接收过程。至于响应的发送与接收过程，这张图中没有表现出来。对于这两个过程，我们也会进行详细分析。</p>
<h3>2.1 服务调用方式</h3>
<p>Dubbo 支持同步和异步两种调用方式，其中异步调用还可细分为“有返回值”的异步调用和“无返回值”的异步调用。所谓“无返回值”异步调用是指服务消费方只管调用，但不关心调用结果，此时 Dubbo 会直接返回一个空的 RpcResult。若要使用异步特性，需要服务消费方手动进行配置。默认情况下，Dubbo 使用同步调用方式。</p>
<p>本节以及其他章节将会使用 Dubbo 官方提供的 Demo 分析整个调用过程，下面我们从 DemoService 接口的代理类开始进行分析。Dubbo 默认使用 Javassist 框架为服务接口生成动态代理类，因此我们需要先将代理类进行反编译才能看到源码。这里使用阿里开源 Java 应用诊断工具 <a href="https://github.com/alibaba/arthas">Arthas</a> 反编译代理类，结果如下：</p>
<pre><code class="language-java"><span class="hljs-comment">/**
 * Arthas 反编译步骤：
 * 1. 启动 Arthas
 *    java -jar arthas-boot.jar
 *
 * 2. 输入编号选择进程
 *    Arthas 启动后，会打印 Java 应用进程列表，如下：
 *    [1]: 11232 org.jetbrains.jps.cmdline.Launcher
 *    [2]: 22370 org.jetbrains.jps.cmdline.Launcher
 *    [3]: 22371 com.alibaba.dubbo.demo.consumer.Consumer
 *    [4]: 22362 com.alibaba.dubbo.demo.provider.Provider
 *    [5]: 2074 org.apache.zookeeper.server.quorum.QuorumPeerMain
 * 这里输入编号 3，让 Arthas 关联到启动类为 com.....Consumer 的 Java 进程上
 *
 * 3. 由于 Demo 项目中只有一个服务接口，因此此接口的代理类类名为 proxy0，此时使用 sc 命令搜索这个类名。
 *    $ sc *.proxy0
 *    com.alibaba.dubbo.common.bytecode.proxy0
 *
 * 4. 使用 jad 命令反编译 com.alibaba.dubbo.common.bytecode.proxy0
 *    $ jad com.alibaba.dubbo.common.bytecode.proxy0
 *
 * 更多使用方法请参考 Arthas 官方文档：
 *   https://alibaba.github.io/arthas/quick-start.html
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">proxy0</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ClassGenerator</span>.<span class="hljs-title">DC</span>, <span class="hljs-title">EchoService</span>, <span class="hljs-title">DemoService</span> </span>{
    <span class="hljs-comment">// 方法数组</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Method[] methods;
    <span class="hljs-keyword">private</span> InvocationHandler handler;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">proxy0</span><span class="hljs-params">(InvocationHandler invocationHandler)</span> </span>{
        <span class="hljs-keyword">this</span>.handler = invocationHandler;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">proxy0</span><span class="hljs-params">()</span> </span>{
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String string)</span> </span>{
        <span class="hljs-comment">// 将参数存储到 Object 数组中</span>
        Object[] arrobject = <span class="hljs-keyword">new</span> Object[]{string};
        <span class="hljs-comment">// 调用 InvocationHandler 实现类的 invoke 方法得到调用结果</span>
        Object object = <span class="hljs-keyword">this</span>.handler.invoke(<span class="hljs-keyword">this</span>, methods[<span class="hljs-number">0</span>], arrobject);
        <span class="hljs-comment">// 返回调用结果</span>
        <span class="hljs-keyword">return</span> (String)object;
    }

    <span class="hljs-comment">/** 回声测试方法 */</span>
    <span class="hljs-keyword">public</span> Object $echo(Object object) {
        Object[] arrobject = <span class="hljs-keyword">new</span> Object[]{object};
        Object object2 = <span class="hljs-keyword">this</span>.handler.invoke(<span class="hljs-keyword">this</span>, methods[<span class="hljs-number">1</span>], arrobject);
        <span class="hljs-keyword">return</span> object2;
    }
}
</code></pre>
<p>如上，代理类的逻辑比较简单。首先将运行时参数存储到数组中，然后调用 InvocationHandler 接口实现类的 invoke 方法，得到调用结果，最后将结果转型并返回给调用方。关于代理类的逻辑就说这么多，继续向下分析。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InvokerInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Invoker&lt;?&gt; invoker;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InvokerInvocationHandler</span><span class="hljs-params">(Invoker&lt;?&gt; handler)</span> </span>{
        <span class="hljs-keyword">this</span>.invoker = handler;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
        String methodName = method.getName();
        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();
        
        <span class="hljs-comment">// 拦截定义在 Object 类中的方法（未被子类重写），比如 wait/notify</span>
        <span class="hljs-keyword">if</span> (method.getDeclaringClass() == Object.class) {
            <span class="hljs-keyword">return</span> method.invoke(invoker, args);
        }
        
        <span class="hljs-comment">// 如果 toString、hashCode 和 equals 等方法被子类重写了，这里也直接调用</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"toString"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> invoker.toString();
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"hashCode"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> invoker.hashCode();
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"equals"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> invoker.equals(args[<span class="hljs-number">0</span>]);
        }
        
        <span class="hljs-comment">// 将 method 和 args 封装到 RpcInvocation 中，并执行后续的调用</span>
        <span class="hljs-keyword">return</span> invoker.invoke(<span class="hljs-keyword">new</span> RpcInvocation(method, args)).recreate();
    }
}
</code></pre>
<p>InvokerInvocationHandler 中的 invoker 成员变量类型为 MockClusterInvoker，MockClusterInvoker 内部封装了服务降级逻辑。下面简单看一下：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockClusterInvoker</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Invoker</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Invoker&lt;T&gt; invoker;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">invoke</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> RpcException </span>{
        Result result = <span class="hljs-keyword">null</span>;

        <span class="hljs-comment">// 获取 mock 配置值</span>
        String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();
        <span class="hljs-keyword">if</span> (value.length() == <span class="hljs-number">0</span> || value.equalsIgnoreCase(<span class="hljs-string">"false"</span>)) {
            <span class="hljs-comment">// 无 mock 逻辑，直接调用其他 Invoker 对象的 invoke 方法，</span>
            <span class="hljs-comment">// 比如 FailoverClusterInvoker</span>
            result = <span class="hljs-keyword">this</span>.invoker.invoke(invocation);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.startsWith(<span class="hljs-string">"force"</span>)) {
            <span class="hljs-comment">// force:xxx 直接执行 mock 逻辑，不发起远程调用</span>
            result = doMockInvoke(invocation, <span class="hljs-keyword">null</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// fail:xxx 表示消费方对调用服务失败后，再执行 mock 逻辑，不抛出异常</span>
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 调用其他 Invoker 对象的 invoke 方法</span>
                result = <span class="hljs-keyword">this</span>.invoker.invoke(invocation);
            } <span class="hljs-keyword">catch</span> (RpcException e) {
                <span class="hljs-keyword">if</span> (e.isBiz()) {
                    <span class="hljs-keyword">throw</span> e;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// 调用失败，执行 mock 逻辑</span>
                    result = doMockInvoke(invocation, e);
                }
            }
        }
        <span class="hljs-keyword">return</span> result;
    }
    
    <span class="hljs-comment">// 省略其他方法</span>
}
</code></pre>
<p>服务降级不是本文重点，因此这里就不分析 doMockInvoke 方法了。考虑到前文已经详细分析过 FailoverClusterInvoker，因此本节略过 FailoverClusterInvoker，直接分析 DubboInvoker。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractInvoker</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Invoker</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">invoke</span><span class="hljs-params">(Invocation inv)</span> <span class="hljs-keyword">throws</span> RpcException </span>{
        <span class="hljs-keyword">if</span> (destroyed.get()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">"Rpc invoker for service ..."</span>);
        }
        RpcInvocation invocation = (RpcInvocation) inv;
        <span class="hljs-comment">// 设置 Invoker</span>
        invocation.setInvoker(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">if</span> (attachment != <span class="hljs-keyword">null</span> &amp;&amp; attachment.size() &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// 设置 attachment</span>
            invocation.addAttachmentsIfAbsent(attachment);
        }
        Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();
        <span class="hljs-keyword">if</span> (contextAttachments != <span class="hljs-keyword">null</span> &amp;&amp; contextAttachments.size() != <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// 添加 contextAttachments 到 RpcInvocation#attachment 变量中</span>
            invocation.addAttachments(contextAttachments);
        }
        <span class="hljs-keyword">if</span> (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, <span class="hljs-keyword">false</span>)) {
            <span class="hljs-comment">// 设置异步信息到 RpcInvocation#attachment 中</span>
            invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());
        }
        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 抽象方法，由子类实现</span>
            <span class="hljs-keyword">return</span> doInvoke(invocation);
        } <span class="hljs-keyword">catch</span> (InvocationTargetException e) {
            <span class="hljs-comment">// ...</span>
        } <span class="hljs-keyword">catch</span> (RpcException e) {
            <span class="hljs-comment">// ...</span>
        } <span class="hljs-keyword">catch</span> (Throwable e) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RpcResult(e);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Result <span class="hljs-title">doInvoke</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable</span>;
    
    <span class="hljs-comment">// 省略其他方法</span>
}
</code></pre>
<p>上面的代码来自 AbstractInvoker 类，其中大部分代码用于添加信息到 RpcInvocation#attachment 变量中，添加完毕后，调用 doInvoke 执行后续的调用。doInvoke 是一个抽象方法，需要由子类实现，下面到 DubboInvoker 中看一下。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DubboInvoker</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractInvoker</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExchangeClient[] clients;
    
    <span class="hljs-function"><span class="hljs-keyword">protected</span> Result <span class="hljs-title">doInvoke</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
        RpcInvocation inv = (RpcInvocation) invocation;
        <span class="hljs-keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);
        <span class="hljs-comment">// 设置 path 和 version 到 attachment 中</span>
        inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());
        inv.setAttachment(Constants.VERSION_KEY, version);

        ExchangeClient currentClient;
        <span class="hljs-keyword">if</span> (clients.length == <span class="hljs-number">1</span>) {
            <span class="hljs-comment">// 从 clients 数组中获取 ExchangeClient</span>
            currentClient = clients[<span class="hljs-number">0</span>];
        } <span class="hljs-keyword">else</span> {
            currentClient = clients[index.getAndIncrement() % clients.length];
        }
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 获取异步配置</span>
            <span class="hljs-keyword">boolean</span> isAsync = RpcUtils.isAsync(getUrl(), invocation);
            <span class="hljs-comment">// isOneway 为 true，表示“单向”通信</span>
            <span class="hljs-keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);
            <span class="hljs-keyword">int</span> timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);

            <span class="hljs-comment">// 异步无返回值</span>
            <span class="hljs-keyword">if</span> (isOneway) {
                <span class="hljs-keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="hljs-keyword">false</span>);
                <span class="hljs-comment">// 发送请求</span>
                currentClient.send(inv, isSent);
                <span class="hljs-comment">// 设置上下文中的 future 字段为 null</span>
                RpcContext.getContext().setFuture(<span class="hljs-keyword">null</span>);
                <span class="hljs-comment">// 返回一个空的 RpcResult</span>
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RpcResult();
            } 

            <span class="hljs-comment">// 异步有返回值</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isAsync) {
                <span class="hljs-comment">// 发送请求，并得到一个 ResponseFuture 实例</span>
                ResponseFuture future = currentClient.request(inv, timeout);
                <span class="hljs-comment">// 设置 future 到上下文中</span>
                RpcContext.getContext().setFuture(<span class="hljs-keyword">new</span> FutureAdapter&lt;Object&gt;(future));
                <span class="hljs-comment">// 暂时返回一个空结果</span>
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RpcResult();
            } 

            <span class="hljs-comment">// 同步调用</span>
            <span class="hljs-keyword">else</span> {
                RpcContext.getContext().setFuture(<span class="hljs-keyword">null</span>);
                <span class="hljs-comment">// 发送请求，得到一个 ResponseFuture 实例，并调用该实例的 get 方法进行等待</span>
                <span class="hljs-keyword">return</span> (Result) currentClient.request(inv, timeout).get();
            }
        } <span class="hljs-keyword">catch</span> (TimeoutException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(..., <span class="hljs-string">"Invoke remote method timeout...."</span>);
        } <span class="hljs-keyword">catch</span> (RemotingException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(..., <span class="hljs-string">"Failed to invoke remote method: ..."</span>);
        }
    }
    
    <span class="hljs-comment">// 省略其他方法</span>
}
</code></pre>
<p>上面的代码包含了 Dubbo 对同步和异步调用的处理逻辑，搞懂了上面的代码，会对 Dubbo 的同步和异步调用方式有更深入的了解。Dubbo 实现同步和异步调用比较关键的一点就在于由谁调用 ResponseFuture 的 get 方法。同步调用模式下，由框架自身调用 ResponseFuture 的 get 方法。异步调用模式下，则由用户调用该方法。ResponseFuture 是一个接口，下面我们来看一下它的默认实现类 DefaultFuture 的源码。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultFuture</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ResponseFuture</span> </span>{
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Long, Channel&gt; CHANNELS = 
        <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;Long, Channel&gt;();

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Long, DefaultFuture&gt; FUTURES = 
        <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;Long, DefaultFuture&gt;();
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> id;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Channel channel;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Request request;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> timeout;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition done = lock.newCondition();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Response response;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DefaultFuture</span><span class="hljs-params">(Channel channel, Request request, <span class="hljs-keyword">int</span> timeout)</span> </span>{
        <span class="hljs-keyword">this</span>.channel = channel;
        <span class="hljs-keyword">this</span>.request = request;
        
        <span class="hljs-comment">// 获取请求 id，这个 id 很重要，后面还会见到</span>
        <span class="hljs-keyword">this</span>.id = request.getId();
        <span class="hljs-keyword">this</span>.timeout = timeout &gt; <span class="hljs-number">0</span> ? timeout : channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
        <span class="hljs-comment">// 存储 &lt;requestId, DefaultFuture&gt; 映射关系到 FUTURES 中</span>
        FUTURES.put(id, <span class="hljs-keyword">this</span>);
        CHANNELS.put(id, channel);
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        <span class="hljs-keyword">return</span> get(timeout);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> timeout)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        <span class="hljs-keyword">if</span> (timeout &lt;= <span class="hljs-number">0</span>) {
            timeout = Constants.DEFAULT_TIMEOUT;
        }
        
        <span class="hljs-comment">// 检测服务提供方是否成功返回了调用结果</span>
        <span class="hljs-keyword">if</span> (!isDone()) {
            <span class="hljs-keyword">long</span> start = System.currentTimeMillis();
            lock.lock();
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 循环检测服务提供方是否成功返回了调用结果</span>
                <span class="hljs-keyword">while</span> (!isDone()) {
                    <span class="hljs-comment">// 如果调用结果尚未返回，这里等待一段时间</span>
                    done.await(timeout, TimeUnit.MILLISECONDS);
                    <span class="hljs-comment">// 如果调用结果成功返回，或等待超时，此时跳出 while 循环，执行后续的逻辑</span>
                    <span class="hljs-keyword">if</span> (isDone() || System.currentTimeMillis() - start &gt; timeout) {
                        <span class="hljs-keyword">break</span>;
                    }
                }
            } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
            } <span class="hljs-keyword">finally</span> {
                lock.unlock();
            }
            
            <span class="hljs-comment">// 如果调用结果仍未返回，则抛出超时异常</span>
            <span class="hljs-keyword">if</span> (!isDone()) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TimeoutException(sent &gt; <span class="hljs-number">0</span>, channel, getTimeoutMessage(<span class="hljs-keyword">false</span>));
            }
        }
        
        <span class="hljs-comment">// 返回调用结果</span>
        <span class="hljs-keyword">return</span> returnFromResponse();
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 通过检测 response 字段为空与否，判断是否收到了调用结果</span>
        <span class="hljs-keyword">return</span> response != <span class="hljs-keyword">null</span>;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">returnFromResponse</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        Response res = response;
        <span class="hljs-keyword">if</span> (res == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"response cannot be null"</span>);
        }
        
        <span class="hljs-comment">// 如果调用结果的状态为 Response.OK，则表示调用过程正常，服务提供方成功返回了调用结果</span>
        <span class="hljs-keyword">if</span> (res.getStatus() == Response.OK) {
            <span class="hljs-keyword">return</span> res.getResult();
        }
        
        <span class="hljs-comment">// 抛出异常</span>
        <span class="hljs-keyword">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage());
        }
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RemotingException(channel, res.getErrorMessage());
    }
    
    <span class="hljs-comment">// 省略其他方法</span>
}
</code></pre>
<p>如上，当服务消费者还未接收到调用结果时，用户线程调用 get 方法会被阻塞住。同步调用模式下，框架获得 DefaultFuture 对象后，会立即调用 get 方法进行等待。而异步模式下则是将该对象封装到 FutureAdapter 实例中，并将 FutureAdapter 实例设置到 RpcContext 中，供用户使用。FutureAdapter 是一个适配器，用于将 Dubbo 中的 ResponseFuture 与 JDK 中的 Future 进行适配。这样当用户线程调用 Future 的 get 方法时，经过 FutureAdapter 适配，最终会调用 ResponseFuture 实现类对象的 get 方法，也就是 DefaultFuture 的 get 方法。</p>
<p>到这里关于 Dubbo 几种调用方式的代码逻辑就分析完了，下面来分析请求数据的发送与接收，以及响应数据的发送与接收过程。</p>
<h3>2.2 服务消费方发送请求</h3>
<h4>2.2.1 发送请求</h4>
<p>本节我们来看一下同步调用模式下，服务消费方是如何发送调用请求的。在深入分析源码前，我们先来看一张图。</p>
<p><img src="sources/images/send-request-thread-stack.jpg" alt=""></p>
<p>这张图展示了服务消费方发送请求过程的部分调用栈，略为复杂。从上图可以看出，经过多次调用后，才将请求数据送至 Netty NioClientSocketChannel。这样做的原因是通过 Exchange 层为框架引入 Request 和 Response 语义，这一点会在接下来的源码分析过程中会看到。其他的就不多说了，下面开始进行分析。首先分析 ReferenceCountExchangeClient 的源码。</p>
<pre><code class="language-java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReferenceCountExchangeClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExchangeClient</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> URL url;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger referenceCount = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReferenceCountExchangeClient</span><span class="hljs-params">(ExchangeClient client, ConcurrentMap&lt;String, LazyConnectExchangeClient&gt; ghostClientMap)</span> </span>{
        <span class="hljs-keyword">this</span>.client = client;
        <span class="hljs-comment">// 引用计数自增</span>
        referenceCount.incrementAndGet();
        <span class="hljs-keyword">this</span>.url = client.getUrl();
        
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseFuture <span class="hljs-title">request</span><span class="hljs-params">(Object request)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        <span class="hljs-comment">// 直接调用被装饰对象的同签名方法</span>
        <span class="hljs-keyword">return</span> client.request(request);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseFuture <span class="hljs-title">request</span><span class="hljs-params">(Object request, <span class="hljs-keyword">int</span> timeout)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        <span class="hljs-comment">// 直接调用被装饰对象的同签名方法</span>
        <span class="hljs-keyword">return</span> client.request(request, timeout);
    }

    <span class="hljs-comment">/** 引用计数自增，该方法由外部调用 */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">incrementAndGetCount</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// referenceCount 自增</span>
        referenceCount.incrementAndGet();
    }
    
        <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> timeout)</span> </span>{
        <span class="hljs-comment">// referenceCount 自减</span>
        <span class="hljs-keyword">if</span> (referenceCount.decrementAndGet() &lt;= <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (timeout == <span class="hljs-number">0</span>) {
                client.close();
            } <span class="hljs-keyword">else</span> {
                client.close(timeout);
            }
            client = replaceWithLazyClient();
        }
    }
    
    <span class="hljs-comment">// 省略部分方法</span>
}
</code></pre>
<p>ReferenceCountExchangeClient 内部定义了一个引用计数变量 referenceCount，每当该对象被引用一次 referenceCount 都会进行自增。每当 close 方法被调用时，referenceCount 进行自减。ReferenceCountExchangeClient 内部仅实现了一个引用计数的功能，其他方法并无复杂逻辑，均是直接调用被装饰对象的相关方法。所以这里就不多说了，继续向下分析，这次是 HeaderExchangeClient。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeaderExchangeClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExchangeClient</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ScheduledThreadPoolExecutor scheduled = <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> NamedThreadFactory(<span class="hljs-string">"dubbo-remoting-client-heartbeat"</span>, <span class="hljs-keyword">true</span>));
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Client client;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExchangeChannel channel;
    <span class="hljs-keyword">private</span> ScheduledFuture&lt;?&gt; heartbeatTimer;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> heartbeat;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> heartbeatTimeout;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HeaderExchangeClient</span><span class="hljs-params">(Client client, <span class="hljs-keyword">boolean</span> needHeartbeat)</span> </span>{
        <span class="hljs-keyword">if</span> (client == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"client == null"</span>);
        }
        <span class="hljs-keyword">this</span>.client = client;
        
        <span class="hljs-comment">// 创建 HeaderExchangeChannel 对象</span>
        <span class="hljs-keyword">this</span>.channel = <span class="hljs-keyword">new</span> HeaderExchangeChannel(client);
        
        <span class="hljs-comment">// 以下代码均与心跳检测逻辑有关</span>
        String dubbo = client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY);
        <span class="hljs-keyword">this</span>.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != <span class="hljs-keyword">null</span> &amp;&amp; dubbo.startsWith(<span class="hljs-string">"1.0."</span>) ? Constants.DEFAULT_HEARTBEAT : <span class="hljs-number">0</span>);
        <span class="hljs-keyword">this</span>.heartbeatTimeout = client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * <span class="hljs-number">3</span>);
        <span class="hljs-keyword">if</span> (heartbeatTimeout &lt; heartbeat * <span class="hljs-number">2</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"heartbeatTimeout &lt; heartbeatInterval * 2"</span>);
        }
        <span class="hljs-keyword">if</span> (needHeartbeat) {
            <span class="hljs-comment">// 开启心跳检测定时器</span>
            startHeartbeatTimer();
        }
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseFuture <span class="hljs-title">request</span><span class="hljs-params">(Object request)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        <span class="hljs-comment">// 直接 HeaderExchangeChannel 对象的同签名方法</span>
        <span class="hljs-keyword">return</span> channel.request(request);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseFuture <span class="hljs-title">request</span><span class="hljs-params">(Object request, <span class="hljs-keyword">int</span> timeout)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        <span class="hljs-comment">// 直接 HeaderExchangeChannel 对象的同签名方法</span>
        <span class="hljs-keyword">return</span> channel.request(request, timeout);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>{
        doClose();
        channel.close();
    }
    
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doClose</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 停止心跳检测定时器</span>
        stopHeartbeatTimer();
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startHeartbeatTimer</span><span class="hljs-params">()</span> </span>{
        stopHeartbeatTimer();
        <span class="hljs-keyword">if</span> (heartbeat &gt; <span class="hljs-number">0</span>) {
            heartbeatTimer = scheduled.scheduleWithFixedDelay(
                    <span class="hljs-keyword">new</span> HeartBeatTask(<span class="hljs-keyword">new</span> HeartBeatTask.ChannelProvider() {
                        <span class="hljs-meta">@Override</span>
                        <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;Channel&gt; <span class="hljs-title">getChannels</span><span class="hljs-params">()</span> </span>{
                            <span class="hljs-keyword">return</span> Collections.&lt;Channel&gt;singletonList(HeaderExchangeClient.<span class="hljs-keyword">this</span>);
                        }
                    }, heartbeat, heartbeatTimeout),
                    heartbeat, heartbeat, TimeUnit.MILLISECONDS);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stopHeartbeatTimer</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (heartbeatTimer != <span class="hljs-keyword">null</span> &amp;&amp; !heartbeatTimer.isCancelled()) {
            <span class="hljs-keyword">try</span> {
                heartbeatTimer.cancel(<span class="hljs-keyword">true</span>);
                scheduled.purge();
            } <span class="hljs-keyword">catch</span> (Throwable e) {
                <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) {
                    logger.warn(e.getMessage(), e);
                }
            }
        }
        heartbeatTimer = <span class="hljs-keyword">null</span>;
    }
    
    <span class="hljs-comment">// 省略部分方法</span>
}
</code></pre>
<p>HeaderExchangeClient 中很多方法只有一行代码，即调用 HeaderExchangeChannel 对象的同签名方法。那 HeaderExchangeClient 有什么用处呢？答案是封装了一些关于心跳检测的逻辑。心跳检测并非本文所关注的点，因此就不多说了，继续向下看。</p>
<pre><code class="language-java">final class HeaderExchangeChannel implements ExchangeChannel {
    
    private final Channel channel;
    
    HeaderExchangeChannel(Channel channel) {
        if (channel == null) {
            throw new IllegalArgumentException("channel == null");
        }
        
        // 这里的 channel 指向的是 NettyClient
        this.channel = channel;
    }
    
    @Override
    public ResponseFuture request(Object request) throws RemotingException {
        return request(request, channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));
    }

    @Override
    public ResponseFuture request(Object request, int timeout) throws RemotingException {
        if (closed) {
            throw new RemotingException(..., "Failed to send request ...);
        }
        // 创建 Request 对象
        Request req = new Request();
        req.setVersion(Version.getProtocolVersion());
        // 设置双向通信标志为 true
        req.setTwoWay(true);
        // 这里的 request 变量类型为 RpcInvocation
        req.setData(request);
                                        
        // 创建 DefaultFuture 对象
        DefaultFuture future = new DefaultFuture(channel, req, timeout);
        try {
            // 调用 NettyClient 的 send 方法发送请求
            channel.send(req);
        } catch (RemotingException e) {
            future.cancel();
            throw e;
        }
        // 返回 DefaultFuture 对象
        return future;
    }
}
</code></pre>
<p>到这里大家终于看到了 Request 语义了，上面的方法首先定义了一个 Request 对象，然后再将该对象传给 NettyClient 的 send 方法，进行后续的调用。需要说明的是，NettyClient 中并未实现 send 方法，该方法继承自父类 AbstractPeer，下面直接分析 AbstractPeer 的代码。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractPeer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Endpoint</span>, <span class="hljs-title">ChannelHandler</span> </span>{
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(Object message)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        <span class="hljs-comment">// 该方法由 AbstractClient 类实现</span>
        send(message, url.getParameter(Constants.SENT_KEY, <span class="hljs-keyword">false</span>));
    }
    
    <span class="hljs-comment">// 省略其他方法</span>
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractEndpoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Client</span> </span>{
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(Object message, <span class="hljs-keyword">boolean</span> sent)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        <span class="hljs-keyword">if</span> (send_reconnect &amp;&amp; !isConnected()) {
            connect();
        }
        
        <span class="hljs-comment">// 获取 Channel，getChannel 是一个抽象方法，具体由子类实现</span>
        Channel channel = getChannel();
        <span class="hljs-keyword">if</span> (channel == <span class="hljs-keyword">null</span> || !channel.isConnected()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RemotingException(<span class="hljs-keyword">this</span>, <span class="hljs-string">"message can not send ..."</span>);
        }
        
        <span class="hljs-comment">// 继续向下调用</span>
        channel.send(message, sent);
    }
    
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Channel <span class="hljs-title">getChannel</span><span class="hljs-params">()</span></span>;
    
    <span class="hljs-comment">// 省略其他方法</span>
}
</code></pre>
<p>默认情况下，Dubbo 使用 Netty 作为底层的通信框架，因此下面我们到 NettyClient 类中看一下 getChannel 方法的实现逻辑。</p>
<pre><code class="language-java">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClient</span> </span>{
    
    <span class="hljs-comment">// 这里的 Channel 全限定名称为 org.jboss.netty.channel.Channel</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Channel channel;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> com.alibaba.dubbo.remoting.<span class="hljs-function">Channel <span class="hljs-title">getChannel</span><span class="hljs-params">()</span> </span>{
        Channel c = channel;
        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span> || !c.isConnected())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        <span class="hljs-comment">// 获取一个 NettyChannel 类型对象</span>
        <span class="hljs-keyword">return</span> NettyChannel.getOrAddChannel(c, getUrl(), <span class="hljs-keyword">this</span>);
    }
}

<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractChannel</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;org.jboss.netty.channel.Channel, NettyChannel&gt; channelMap = 
        <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;org.jboss.netty.channel.Channel, NettyChannel&gt;();

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> org.jboss.netty.channel.Channel channel;
    
    <span class="hljs-comment">/** 私有构造方法 */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">NettyChannel</span><span class="hljs-params">(org.jboss.netty.channel.Channel channel, URL url, ChannelHandler handler)</span> </span>{
        <span class="hljs-keyword">super</span>(url, handler);
        <span class="hljs-keyword">if</span> (channel == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"netty channel == null;"</span>);
        }
        <span class="hljs-keyword">this</span>.channel = channel;
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> NettyChannel <span class="hljs-title">getOrAddChannel</span><span class="hljs-params">(org.jboss.netty.channel.Channel ch, URL url, ChannelHandler handler)</span> </span>{
        <span class="hljs-keyword">if</span> (ch == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
        
        <span class="hljs-comment">// 尝试从集合中获取 NettyChannel 实例</span>
        NettyChannel ret = channelMap.get(ch);
        <span class="hljs-keyword">if</span> (ret == <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// 如果 ret = null，则创建一个新的 NettyChannel 实例</span>
            NettyChannel nc = <span class="hljs-keyword">new</span> NettyChannel(ch, url, handler);
            <span class="hljs-keyword">if</span> (ch.isConnected()) {
                <span class="hljs-comment">// 将 &lt;Channel, NettyChannel&gt; 键值对存入 channelMap 集合中</span>
                ret = channelMap.putIfAbsent(ch, nc);
            }
            <span class="hljs-keyword">if</span> (ret == <span class="hljs-keyword">null</span>) {
                ret = nc;
            }
        }
        <span class="hljs-keyword">return</span> ret;
    }
}
</code></pre>
<p>获取到 NettyChannel 实例后，即可进行后续的调用。下面看一下 NettyChannel 的 send 方法。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(Object message, <span class="hljs-keyword">boolean</span> sent)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
    <span class="hljs-keyword">super</span>.send(message, sent);

    <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">int</span> timeout = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 发送消息(包含请求和响应消息)</span>
        ChannelFuture future = channel.write(message);
        
        <span class="hljs-comment">// sent 的值源于 &lt;dubbo:method sent="true/false" /&gt; 中 sent 的配置值，有两种配置值：</span>
        <span class="hljs-comment">//   1. true: 等待消息发出，消息发送失败将抛出异常</span>
        <span class="hljs-comment">//   2. false: 不等待消息发出，将消息放入 IO 队列，即刻返回</span>
        <span class="hljs-comment">// 默认情况下 sent = false；</span>
        <span class="hljs-keyword">if</span> (sent) {
            timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
            <span class="hljs-comment">// 等待消息发出，若在规定时间没能发出，success 会被置为 false</span>
            success = future.await(timeout);
        }
        Throwable cause = future.getCause();
        <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> cause;
        }
    } <span class="hljs-keyword">catch</span> (Throwable e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RemotingException(<span class="hljs-keyword">this</span>, <span class="hljs-string">"Failed to send message ..."</span>);
    }

    <span class="hljs-comment">// 若 success 为 false，这里抛出异常</span>
    <span class="hljs-keyword">if</span> (!success) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RemotingException(<span class="hljs-keyword">this</span>, <span class="hljs-string">"Failed to send message ..."</span>);
    }
}
</code></pre>
<p>经历多次调用，到这里请求数据的发送过程就结束了，过程漫长。为了便于大家阅读代码，这里以 DemoService 为例，将 sayHello 方法的整个调用路径贴出来。</p>
<pre><code>proxy0#sayHello(String)
  —&gt; InvokerInvocationHandler#invoke(Object, Method, Object[])
    —&gt; MockClusterInvoker#invoke(Invocation)
      —&gt; AbstractClusterInvoker#invoke(Invocation)
        —&gt; FailoverClusterInvoker#doInvoke(Invocation, List&lt;Invoker&lt;T&gt;&gt;, LoadBalance)
          —&gt; Filter#invoke(Invoker, Invocation)  // 包含多个 Filter 调用
            —&gt; ListenerInvokerWrapper#invoke(Invocation) 
              —&gt; AbstractInvoker#invoke(Invocation) 
                —&gt; DubboInvoker#doInvoke(Invocation)
                  —&gt; ReferenceCountExchangeClient#request(Object, int)
                    —&gt; HeaderExchangeClient#request(Object, int)
                      —&gt; HeaderExchangeChannel#request(Object, int)
                        —&gt; AbstractPeer#send(Object)
                          —&gt; AbstractClient#send(Object, boolean)
                            —&gt; NettyChannel#send(Object, boolean)
                              —&gt; NioClientSocketChannel#write(Object)
</code></pre>
<p>在 Netty 中，出站数据在发出之前还需要进行编码操作，接下来我们来分析一下请求数据的编码逻辑。</p>
<h4>2.2.2 请求编码</h4>
<p>在分析请求编码逻辑之前，我们先来看一下 Dubbo 数据包结构。</p>
<p><img src="sources/images/data-format.jpg" alt=""></p>
<p>Dubbo 数据包分为消息头和消息体，消息头用于存储一些元信息，比如魔数（Magic），数据包类型（Request/Response），消息体长度（Data Length）等。消息体中用于存储具体的调用消息，比如方法名称，参数列表等。下面简单列举一下消息头的内容。</p>
<table>
<thead>
<tr>
<th>偏移量(Bit)</th>
<th>字段</th>
<th>取值</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 ~ 7</td>
<td>魔数高位</td>
<td>0xda00</td>
</tr>
<tr>
<td>8 ~ 15</td>
<td>魔数低位</td>
<td>0xbb</td>
</tr>
<tr>
<td>16</td>
<td>数据包类型</td>
<td>0 - Response, 1 - Request</td>
</tr>
<tr>
<td>17</td>
<td>调用方式</td>
<td>仅在第16位被设为1的情况下有效，0 - 单向调用，1 - 双向调用</td>
</tr>
<tr>
<td>18</td>
<td>事件标识</td>
<td>0 - 当前数据包是请求或响应包，1 - 当前数据包是心跳包</td>
</tr>
<tr>
<td>19 ~ 23</td>
<td>序列化器编号</td>
<td>2 - Hessian2Serialization<br>3 - JavaSerialization<br/>4 - CompactedJavaSerialization<br/>6 - FastJsonSerialization<br/>7 - NativeJavaSerialization<br/>8 - KryoSerialization<br/>9 - FstSerialization</td>
</tr>
<tr>
<td>24 ~ 31</td>
<td>状态</td>
<td>20 - OK<br/>30 - CLIENT_TIMEOUT<br/>31 - SERVER_TIMEOUT<br/>40 - BAD_REQUEST<br/>50 - BAD_RESPONSE<br/>......</td>
</tr>
<tr>
<td>32 ~ 95</td>
<td>请求编号</td>
<td>共8字节，运行时生成</td>
</tr>
<tr>
<td>96 ~ 127</td>
<td>消息体长度</td>
<td>运行时计算</td>
</tr>
</tbody>
</table>
<p>了解了 Dubbo 数据包格式，接下来我们就可以探索编码过程了。这次我们开门见山，直接分析编码逻辑所在类。如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExchangeCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TelnetCodec</span> </span>{

    <span class="hljs-comment">// 消息头长度</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HEADER_LENGTH = <span class="hljs-number">16</span>;
    <span class="hljs-comment">// 魔数内容</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">short</span> MAGIC = (<span class="hljs-keyword">short</span>) <span class="hljs-number">0xdabb</span>;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> MAGIC_HIGH = Bytes.short2bytes(MAGIC)[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> MAGIC_LOW = Bytes.short2bytes(MAGIC)[<span class="hljs-number">1</span>];
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> FLAG_REQUEST = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0x80</span>;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> FLAG_TWOWAY = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0x40</span>;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> FLAG_EVENT = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0x20</span>;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SERIALIZATION_MASK = <span class="hljs-number">0x1f</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(ExchangeCodec.class);

    <span class="hljs-function"><span class="hljs-keyword">public</span> Short <span class="hljs-title">getMagicCode</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> MAGIC;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, Object msg)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> Request) {
            <span class="hljs-comment">// 对 Request 对象进行编码</span>
            encodeRequest(channel, buffer, (Request) msg);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> Response) {
            <span class="hljs-comment">// 对 Response 对象进行编码，后面分析</span>
            encodeResponse(channel, buffer, (Response) msg);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">super</span>.encode(channel, buffer, msg);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encodeRequest</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, Request req)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        Serialization serialization = getSerialization(channel);

        <span class="hljs-comment">// 创建消息头字节数组，长度为 16</span>
        <span class="hljs-keyword">byte</span>[] header = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[HEADER_LENGTH];

        <span class="hljs-comment">// 设置魔数</span>
        Bytes.short2bytes(MAGIC, header);

        <span class="hljs-comment">// 设置数据包类型（Request/Response）和序列化器编号</span>
        header[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">byte</span>) (FLAG_REQUEST | serialization.getContentTypeId());

        <span class="hljs-comment">// 设置通信方式(单向/双向)</span>
        <span class="hljs-keyword">if</span> (req.isTwoWay()) {
            header[<span class="hljs-number">2</span>] |= FLAG_TWOWAY;
        }
        
        <span class="hljs-comment">// 设置事件标识</span>
        <span class="hljs-keyword">if</span> (req.isEvent()) {
            header[<span class="hljs-number">2</span>] |= FLAG_EVENT;
        }

        <span class="hljs-comment">// 设置请求编号，8个字节，从第4个字节开始设置</span>
        Bytes.long2bytes(req.getId(), header, <span class="hljs-number">4</span>);

        <span class="hljs-comment">// 获取 buffer 当前的写位置</span>
        <span class="hljs-keyword">int</span> savedWriteIndex = buffer.writerIndex();
        <span class="hljs-comment">// 更新 writerIndex，为消息头预留 16 个字节的空间</span>
        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);
        ChannelBufferOutputStream bos = <span class="hljs-keyword">new</span> ChannelBufferOutputStream(buffer);
        <span class="hljs-comment">// 创建序列化器，比如 Hessian2ObjectOutput</span>
        ObjectOutput out = serialization.serialize(channel.getUrl(), bos);
        <span class="hljs-keyword">if</span> (req.isEvent()) {
            <span class="hljs-comment">// 对事件数据进行序列化操作</span>
            encodeEventData(channel, out, req.getData());
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 对请求数据进行序列化操作</span>
            encodeRequestData(channel, out, req.getData(), req.getVersion());
        }
        out.flushBuffer();
        <span class="hljs-keyword">if</span> (out <span class="hljs-keyword">instanceof</span> Cleanable) {
            ((Cleanable) out).cleanup();
        }
        bos.flush();
        bos.close();
        
        <span class="hljs-comment">// 获取写入的字节数，也就是消息体长度</span>
        <span class="hljs-keyword">int</span> len = bos.writtenBytes();
        checkPayload(channel, len);

        <span class="hljs-comment">// 将消息体长度写入到消息头中</span>
        Bytes.int2bytes(len, header, <span class="hljs-number">12</span>);

        <span class="hljs-comment">// 将 buffer 指针移动到 savedWriteIndex，为写消息头做准备</span>
        buffer.writerIndex(savedWriteIndex);
        <span class="hljs-comment">// 从 savedWriteIndex 下标处写入消息头</span>
        buffer.writeBytes(header);
        <span class="hljs-comment">// 设置新的 writerIndex，writerIndex = 原写下标 + 消息头长度 + 消息体长度</span>
        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);
    }
    
    <span class="hljs-comment">// 省略其他方法</span>
}
</code></pre>
<p>以上就是请求对象的编码过程，该过程首先会通过位运算将消息头写入到 header 数组中。然后对 Request 对象的 data 字段执行序列化操作，序列化后的数据最终会存储到 ChannelBuffer 中。序列化操作执行完后，可得到数据序列化后的长度 len，紧接着将 len 写入到 header 指定位置处。最后再将消息头字节数组 header 写入到 ChannelBuffer 中，整个编码过程就结束了。本节的最后，我们再来看一下 Request 对象的 data 字段序列化过程，也就是 encodeRequestData 方法的逻辑，如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DubboCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ExchangeCodec</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Codec2</span> </span>{
    
	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encodeRequestData</span><span class="hljs-params">(Channel channel, ObjectOutput out, Object data, String version)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        RpcInvocation inv = (RpcInvocation) data;

        <span class="hljs-comment">// 依次序列化 dubbo version、path、version</span>
        out.writeUTF(version);
        out.writeUTF(inv.getAttachment(Constants.PATH_KEY));
        out.writeUTF(inv.getAttachment(Constants.VERSION_KEY));

        <span class="hljs-comment">// 序列化调用方法名</span>
        out.writeUTF(inv.getMethodName());
        <span class="hljs-comment">// 将参数类型转换为字符串，并进行序列化</span>
        out.writeUTF(ReflectUtils.getDesc(inv.getParameterTypes()));
        Object[] args = inv.getArguments();
        <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) {
                <span class="hljs-comment">// 对运行时参数进行序列化</span>
                out.writeObject(encodeInvocationArgument(channel, inv, i));
            }
        
        <span class="hljs-comment">// 序列化 attachments</span>
        out.writeObject(inv.getAttachments());
    }
}
</code></pre>
<p>至此，关于服务消费方发送请求的过程就分析完了，接下来我们来看一下服务提供方是如何接收请求的。</p>
<h3>2.3 服务提供方接收请求</h3>
<p>前面说过，默认情况下 Dubbo 使用 Netty 作为底层的通信框架。Netty 检测到有数据入站后，首先会通过解码器对数据进行解码，并将解码后的数据传递给下一个入站处理器的指定方法。所以在进行后续的分析之前，我们先来看一下数据解码过程。</p>
<h4>2.3.1 请求解码</h4>
<p>这里直接分析请求数据的解码逻辑，忽略中间过程，如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExchangeCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TelnetCodec</span> </span>{
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">decode</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        <span class="hljs-keyword">int</span> readable = buffer.readableBytes();
        <span class="hljs-comment">// 创建消息头字节数组</span>
        <span class="hljs-keyword">byte</span>[] header = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[Math.min(readable, HEADER_LENGTH)];
        <span class="hljs-comment">// 读取消息头数据</span>
        buffer.readBytes(header);
        <span class="hljs-comment">// 调用重载方法进行后续解码工作</span>
        <span class="hljs-keyword">return</span> decode(channel, buffer, readable, header);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">decode</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, <span class="hljs-keyword">int</span> readable, <span class="hljs-keyword">byte</span>[] header)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        <span class="hljs-comment">// 检查魔数是否相等</span>
        <span class="hljs-keyword">if</span> (readable &gt; <span class="hljs-number">0</span> &amp;&amp; header[<span class="hljs-number">0</span>] != MAGIC_HIGH
                || readable &gt; <span class="hljs-number">1</span> &amp;&amp; header[<span class="hljs-number">1</span>] != MAGIC_LOW) {
            <span class="hljs-keyword">int</span> length = header.length;
            <span class="hljs-keyword">if</span> (header.length &lt; readable) {
                header = Bytes.copyOf(header, readable);
                buffer.readBytes(header, length, readable - length);
            }
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; header.length - <span class="hljs-number">1</span>; i++) {
                <span class="hljs-keyword">if</span> (header[i] == MAGIC_HIGH &amp;&amp; header[i + <span class="hljs-number">1</span>] == MAGIC_LOW) {
                    buffer.readerIndex(buffer.readerIndex() - header.length + i);
                    header = Bytes.copyOf(header, i);
                    <span class="hljs-keyword">break</span>;
                }
            }
            <span class="hljs-comment">// 通过 telnet 命令行发送的数据包不包含消息头，所以这里</span>
            <span class="hljs-comment">// 调用 TelnetCodec 的 decode 方法对数据包进行解码</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.decode(channel, buffer, readable, header);
        }
        
        <span class="hljs-comment">// 检测可读数据量是否少于消息头长度，若小于则立即返回 DecodeResult.NEED_MORE_INPUT</span>
        <span class="hljs-keyword">if</span> (readable &lt; HEADER_LENGTH) {
            <span class="hljs-keyword">return</span> DecodeResult.NEED_MORE_INPUT;
        }

        <span class="hljs-comment">// 从消息头中获取消息体长度</span>
        <span class="hljs-keyword">int</span> len = Bytes.bytes2int(header, <span class="hljs-number">12</span>);
        <span class="hljs-comment">// 检测消息体长度是否超出限制，超出则抛出异常</span>
        checkPayload(channel, len);

        <span class="hljs-keyword">int</span> tt = len + HEADER_LENGTH;
        <span class="hljs-comment">// 检测可读的字节数是否小于实际的字节数</span>
        <span class="hljs-keyword">if</span> (readable &lt; tt) {
            <span class="hljs-keyword">return</span> DecodeResult.NEED_MORE_INPUT;
        }
        
        ChannelBufferInputStream is = <span class="hljs-keyword">new</span> ChannelBufferInputStream(buffer, len);

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 继续进行解码工作</span>
            <span class="hljs-keyword">return</span> decodeBody(channel, is, header);
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (is.available() &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">try</span> {
                    StreamUtils.skipUnusedStream(is);
                } <span class="hljs-keyword">catch</span> (IOException e) {
                    logger.warn(e.getMessage(), e);
                }
            }
        }
    }
}
</code></pre>
<p>上面方法通过检测消息头中的魔数是否与规定的魔数相等，提前拦截掉非常规数据包，比如通过 telnet 命令行发出的数据包。接着再对消息体长度，以及可读字节数进行检测。最后调用 decodeBody 方法进行后续的解码工作，ExchangeCodec 中实现了 decodeBody 方法，但因其子类 DubboCodec 覆写了该方法，所以在运行时 DubboCodec 中的 decodeBody 方法会被调用。下面我们来看一下该方法的代码。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DubboCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ExchangeCodec</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Codec2</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">decodeBody</span><span class="hljs-params">(Channel channel, InputStream is, <span class="hljs-keyword">byte</span>[] header)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        <span class="hljs-comment">// 获取消息头中的第三个字节，并通过逻辑与运算得到序列化器编号</span>
        <span class="hljs-keyword">byte</span> flag = header[<span class="hljs-number">2</span>], proto = (<span class="hljs-keyword">byte</span>) (flag &amp; SERIALIZATION_MASK);
        Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);
        <span class="hljs-comment">// 获取调用编号</span>
        <span class="hljs-keyword">long</span> id = Bytes.bytes2long(header, <span class="hljs-number">4</span>);
        <span class="hljs-comment">// 通过逻辑与运算得到调用类型，0 - Response，1 - Request</span>
        <span class="hljs-keyword">if</span> ((flag &amp; FLAG_REQUEST) == <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// 对响应结果进行解码，得到 Response 对象。这个非本节内容，后面再分析</span>
            <span class="hljs-comment">// ...</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 创建 Request 对象</span>
            Request req = <span class="hljs-keyword">new</span> Request(id);
            req.setVersion(Version.getProtocolVersion());
            <span class="hljs-comment">// 通过逻辑与运算得到通信方式，并设置到 Request 对象中</span>
            req.setTwoWay((flag &amp; FLAG_TWOWAY) != <span class="hljs-number">0</span>);
            
            <span class="hljs-comment">// 通过位运算检测数据包是否为事件类型</span>
            <span class="hljs-keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="hljs-number">0</span>) {
                <span class="hljs-comment">// 设置心跳事件到 Request 对象中</span>
                req.setEvent(Request.HEARTBEAT_EVENT);
            }
            <span class="hljs-keyword">try</span> {
                Object data;
                <span class="hljs-keyword">if</span> (req.isHeartbeat()) {
                    <span class="hljs-comment">// 对心跳包进行解码，该方法已被标注为废弃</span>
                    data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (req.isEvent()) {
                    <span class="hljs-comment">// 对事件数据进行解码</span>
                    data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));
                } <span class="hljs-keyword">else</span> {
                    DecodeableRpcInvocation inv;
                    <span class="hljs-comment">// 根据 url 参数判断是否在 IO 线程上对消息体进行解码</span>
                    <span class="hljs-keyword">if</span> (channel.getUrl().getParameter(
                            Constants.DECODE_IN_IO_THREAD_KEY,
                            Constants.DEFAULT_DECODE_IN_IO_THREAD)) {
                        inv = <span class="hljs-keyword">new</span> DecodeableRpcInvocation(channel, req, is, proto);
                        <span class="hljs-comment">// 在当前线程，也就是 IO 线程上进行后续的解码工作。此工作完成后，可将</span>
                        <span class="hljs-comment">// 调用方法名、attachment、以及调用参数解析出来</span>
                        inv.decode();
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-comment">// 仅创建 DecodeableRpcInvocation 对象，但不在当前线程上执行解码逻辑</span>
                        inv = <span class="hljs-keyword">new</span> DecodeableRpcInvocation(channel, req,
                                <span class="hljs-keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)), proto);
                    }
                    data = inv;
                }
                
                <span class="hljs-comment">// 设置 data 到 Request 对象中</span>
                req.setData(data);
            } <span class="hljs-keyword">catch</span> (Throwable t) {
                <span class="hljs-comment">// 若解码过程中出现异常，则将 broken 字段设为 true，</span>
                <span class="hljs-comment">// 并将异常对象设置到 Reqeust 对象中</span>
                req.setBroken(<span class="hljs-keyword">true</span>);
                req.setData(t);
            }
            <span class="hljs-keyword">return</span> req;
        }
    }
}
</code></pre>
<p>如上，decodeBody 对部分字段进行了解码，并将解码得到的字段封装到 Request 中。随后会调用 DecodeableRpcInvocation 的 decode 方法进行后续的解码工作。此工作完成后，可将调用方法名、attachment、以及调用参数解析出来。下面我们来看一下 DecodeableRpcInvocation 的 decode 方法逻辑。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecodeableRpcInvocation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RpcInvocation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Codec</span>, <span class="hljs-title">Decodeable</span> </span>{
    
	<span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">decode</span><span class="hljs-params">(Channel channel, InputStream input)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)
                .deserialize(channel.getUrl(), input);

        <span class="hljs-comment">// 通过反序列化得到 dubbo version，并保存到 attachments 变量中</span>
        String dubboVersion = in.readUTF();
        request.setVersion(dubboVersion);
        setAttachment(Constants.DUBBO_VERSION_KEY, dubboVersion);

        <span class="hljs-comment">// 通过反序列化得到 path，version，并保存到 attachments 变量中</span>
        setAttachment(Constants.PATH_KEY, in.readUTF());
        setAttachment(Constants.VERSION_KEY, in.readUTF());

        <span class="hljs-comment">// 通过反序列化得到调用方法名</span>
        setMethodName(in.readUTF());
        <span class="hljs-keyword">try</span> {
            Object[] args;
            Class&lt;?&gt;[] pts;
            <span class="hljs-comment">// 通过反序列化得到参数类型字符串，比如 Ljava/lang/String;</span>
            String desc = in.readUTF();
            <span class="hljs-keyword">if</span> (desc.length() == <span class="hljs-number">0</span>) {
                pts = DubboCodec.EMPTY_CLASS_ARRAY;
                args = DubboCodec.EMPTY_OBJECT_ARRAY;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 将 desc 解析为参数类型数组</span>
                pts = ReflectUtils.desc2classArray(desc);
                args = <span class="hljs-keyword">new</span> Object[pts.length];
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-comment">// 解析运行时参数</span>
                        args[i] = in.readObject(pts[i]);
                    } <span class="hljs-keyword">catch</span> (Exception e) {
                        <span class="hljs-keyword">if</span> (log.isWarnEnabled()) {
                            log.warn(<span class="hljs-string">"Decode argument failed: "</span> + e.getMessage(), e);
                        }
                    }
                }
            }
            
            <span class="hljs-comment">// 设置参数类型数组</span>
            setParameterTypes(pts);

            <span class="hljs-comment">// 通过反序列化得到原 attachment 的内容</span>
            Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) in.readObject(Map.class);
            <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span> &amp;&amp; map.size() &gt; <span class="hljs-number">0</span>) {
                Map&lt;String, String&gt; attachment = getAttachments();
                <span class="hljs-keyword">if</span> (attachment == <span class="hljs-keyword">null</span>) {
                    attachment = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();
                }
                <span class="hljs-comment">// 将 map 与当前对象中的 attachment 集合进行融合</span>
                attachment.putAll(map);
                setAttachments(attachment);
            }
            
            <span class="hljs-comment">// 对 callback 类型的参数进行处理</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) {
                args[i] = decodeInvocationArgument(channel, <span class="hljs-keyword">this</span>, pts, i, args[i]);
            }

            <span class="hljs-comment">// 设置参数列表</span>
            setArguments(args);

        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(StringUtils.toString(<span class="hljs-string">"Read invocation data failed."</span>, e));
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (in <span class="hljs-keyword">instanceof</span> Cleanable) {
                ((Cleanable) in).cleanup();
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
}
</code></pre>
<p>上面的方法通过反序列化将诸如 path、version、调用方法名、参数列表等信息依次解析出来，并设置到相应的字段中，最终得到一个具有完整调用信息的 DecodeableRpcInvocation 对象。</p>
<p>到这里，请求数据解码的过程就分析完了。此时我们得到了一个 Request 对象，这个对象会被传送到下一个入站处理器中，我们继续往下看。</p>
<h4>2.3.2 调用服务</h4>
<p>解码器将数据包解析成 Request 对象后，NettyHandler 的 messageReceived 方法紧接着会收到这个对象，并将这个对象继续向下传递。这期间该对象会被依次传递给 NettyServer、MultiMessageHandler、HeartbeatHandler 以及 AllChannelHandler。最后由 AllChannelHandler 将该对象封装到 Runnable 实现类对象中，并将 Runnable 放入线程池中执行后续的调用逻辑。整个调用栈如下：</p>
<pre><code>NettyHandler#messageReceived(ChannelHandlerContext, MessageEvent)
  —&gt; AbstractPeer#received(Channel, Object)
    —&gt; MultiMessageHandler#received(Channel, Object)
      —&gt; HeartbeatHandler#received(Channel, Object)
        —&gt; AllChannelHandler#received(Channel, Object)
          —&gt; ExecutorService#execute(Runnable)    // 由线程池执行后续的调用逻辑
</code></pre>
<p>考虑到篇幅，以及很多中间调用的逻辑并非十分重要，所以这里就不对调用栈中的每个方法都进行分析了。这里我们直接分析调用栈中的分析第一个和最后一个调用方法逻辑。如下：</p>
<pre><code class="language-java"><span class="hljs-meta">@Sharable</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelHandler</span> </span>{
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Channel&gt; channels = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, Channel&gt;();

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> URL url;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelHandler handler;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NettyHandler</span><span class="hljs-params">(URL url, ChannelHandler handler)</span> </span>{
        <span class="hljs-keyword">if</span> (url == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"url == null"</span>);
        }
        <span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"handler == null"</span>);
        }
        <span class="hljs-keyword">this</span>.url = url;
        
        <span class="hljs-comment">// 这里的 handler 类型为 NettyServer</span>
        <span class="hljs-keyword">this</span>.handler = handler;
    }
    
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">messageReceived</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageEvent e)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        <span class="hljs-comment">// 获取 NettyChannel</span>
        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.getChannel(), url, handler);
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 继续向下调用</span>
            handler.received(channel, e.getMessage());
        } <span class="hljs-keyword">finally</span> {
            NettyChannel.removeChannelIfDisconnected(ctx.getChannel());
        }
    }
}
</code></pre>
<p>如上，NettyHandler 中的 messageReceived 逻辑比较简单。首先根据一些信息获取 NettyChannel 实例，然后将 NettyChannel 实例以及 Request 对象向下传递。下面再来看看 AllChannelHandler 的逻辑，在详细分析代码之前，我们先来了解一下 Dubbo 中的线程派发模型。</p>
<h5>2.3.2.1 线程派发模型</h5>
<p>Dubbo 将底层通信框架中接收请求的线程称为 IO 线程。如果一些事件处理逻辑可以很快执行完，比如只在内存打一个标记，此时直接在 IO 线程上执行该段逻辑即可。但如果事件的处理逻辑比较耗时，比如该段逻辑会发起数据库查询或者 HTTP 请求。此时我们就不应该让事件处理逻辑在 IO 线程上执行，而是应该派发到线程池中去执行。原因也很简单，IO 线程主要用于接收请求，如果 IO 线程被占满，将导致它不能接收新的请求。</p>
<p>以上就是线程派发的背景，下面我们再来通过 Dubbo 调用图，看一下线程派发器所处的位置。</p>
<p><img src="sources/images/dispatcher-location.jpg" alt=""></p>
<p>如上图，红框中的 Dispatcher 就是线程派发器。需要说明的是，Dispatcher 真实的职责创建具有线程派发能力的 ChannelHandler，比如 AllChannelHandler、MessageOnlyChannelHandler 和 ExecutionChannelHandler 等，其本身并不具备线程派发能力。Dubbo 支持 5 种不同的线程派发策略，下面通过一个表格列举一下。</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>all</td>
<td>所有消息都派发到线程池，包括请求，响应，连接事件，断开事件等</td>
</tr>
<tr>
<td>direct</td>
<td>所有消息都不派发到线程池，全部在 IO 线程上直接执行</td>
</tr>
<tr>
<td>message</td>
<td>只有<strong>请求</strong>和<strong>响应</strong>消息派发到线程池，其它消息均在 IO 线程上执行</td>
</tr>
<tr>
<td>execution</td>
<td>只有<strong>请求</strong>消息派发到线程池，不含响应。其它消息均在 IO 线程上执行</td>
</tr>
<tr>
<td>connection</td>
<td>在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池</td>
</tr>
</tbody>
</table>
<p>默认配置下，Dubbo 使用 <code>all</code> 派发策略，即将所有的消息都派发到线程池中。下面我们来分析一下 AllChannelHandler 的代码。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllChannelHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WrappedChannelHandler</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AllChannelHandler</span><span class="hljs-params">(ChannelHandler handler, URL url)</span> </span>{
        <span class="hljs-keyword">super</span>(handler, url);
    }

    <span class="hljs-comment">/** 处理连接事件 */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connected</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        <span class="hljs-comment">// 获取线程池</span>
        ExecutorService cexecutor = getExecutorService();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 将连接事件派发到线程池中处理</span>
            cexecutor.execute(<span class="hljs-keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.CONNECTED));
        } <span class="hljs-keyword">catch</span> (Throwable t) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExecutionException(..., <span class="hljs-string">" error when process connected event ."</span>, t);
        }
    }

    <span class="hljs-comment">/** 处理断开事件 */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">disconnected</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        ExecutorService cexecutor = getExecutorService();
        <span class="hljs-keyword">try</span> {
            cexecutor.execute(<span class="hljs-keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED));
        } <span class="hljs-keyword">catch</span> (Throwable t) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExecutionException(..., <span class="hljs-string">"error when process disconnected event ."</span>, t);
        }
    }

    <span class="hljs-comment">/** 处理请求和响应消息，这里的 message 变量类型可能是 Request，也可能是 Response */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">received</span><span class="hljs-params">(Channel channel, Object message)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        ExecutorService cexecutor = getExecutorService();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 将请求和响应消息派发到线程池中处理</span>
            cexecutor.execute(<span class="hljs-keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));
        } <span class="hljs-keyword">catch</span> (Throwable t) {
            <span class="hljs-keyword">if</span>(message <span class="hljs-keyword">instanceof</span> Request &amp;&amp; t <span class="hljs-keyword">instanceof</span> RejectedExecutionException){
                Request request = (Request)message;
                <span class="hljs-comment">// 如果通信方式为双向通信，此时将 Server side ... threadpool is exhausted </span>
                <span class="hljs-comment">// 错误信息封装到 Response 中，并返回给服务消费方。</span>
                <span class="hljs-keyword">if</span>(request.isTwoWay()){
                    String msg = <span class="hljs-string">"Server side("</span> + url.getIp() + <span class="hljs-string">","</span> + url.getPort() 
                        + <span class="hljs-string">") threadpool is exhausted ,detail msg:"</span> + t.getMessage();
                    Response response = <span class="hljs-keyword">new</span> Response(request.getId(), request.getVersion());
                    response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR);
                    response.setErrorMessage(msg);
                    <span class="hljs-comment">// 返回包含错误信息的 Response 对象</span>
                    channel.send(response);
                    <span class="hljs-keyword">return</span>;
                }
            }
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExecutionException(..., <span class="hljs-string">" error when process received event ."</span>, t);
        }
    }

    <span class="hljs-comment">/** 处理异常信息 */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">caught</span><span class="hljs-params">(Channel channel, Throwable exception)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        ExecutorService cexecutor = getExecutorService();
        <span class="hljs-keyword">try</span> {
            cexecutor.execute(<span class="hljs-keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.CAUGHT, exception));
        } <span class="hljs-keyword">catch</span> (Throwable t) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExecutionException(..., <span class="hljs-string">"error when process caught event ..."</span>);
        }
    }
}
</code></pre>
<p>如上，请求对象会被封装 ChannelEventRunnable 中，ChannelEventRunnable 将会是服务调用过程的新起点。所以接下来我们以 ChannelEventRunnable 为起点向下探索。</p>
<h5>2.3.2.2 调用服务</h5>
<p>本小节，我们从 ChannelEventRunnable 开始分析，该类的主要代码如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelEventRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelHandler handler;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Channel channel;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelState state;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Throwable exception;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object message;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 检测通道状态，对于请求或响应消息，此时 state = RECEIVED</span>
        <span class="hljs-keyword">if</span> (state == ChannelState.RECEIVED) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 将 channel 和 message 传给 ChannelHandler 对象，进行后续的调用</span>
                handler.received(channel, message);
            } <span class="hljs-keyword">catch</span> (Exception e) {
                logger.warn(<span class="hljs-string">"... operation error, channel is ... message is ..."</span>);
            }
        } 
        
        <span class="hljs-comment">// 其他消息类型通过 switch 进行处理</span>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (state) {
            <span class="hljs-keyword">case</span> CONNECTED:
                <span class="hljs-keyword">try</span> {
                    handler.connected(channel);
                } <span class="hljs-keyword">catch</span> (Exception e) {
                    logger.warn(<span class="hljs-string">"... operation error, channel is ..."</span>);
                }
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> DISCONNECTED:
                <span class="hljs-comment">// ...</span>
            <span class="hljs-keyword">case</span> SENT:
                <span class="hljs-comment">// ...</span>
            <span class="hljs-keyword">case</span> CAUGHT:
                <span class="hljs-comment">// ...</span>
            <span class="hljs-keyword">default</span>:
                logger.warn(<span class="hljs-string">"unknown state: "</span> + state + <span class="hljs-string">", message is "</span> + message);
            }
        }

    }
}
</code></pre>
<p>如上，请求和响应消息出现频率明显比其他类型消息高，所以这里对该类型的消息进行了针对性判断。ChannelEventRunnable 仅是一个中转站，它的 run 方法中并不包含具体的调用逻辑，仅用于将参数传给其他 ChannelHandler 对象进行处理，该对象类型为 DecodeHandler。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecodeHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractChannelHandlerDelegate</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecodeHandler</span><span class="hljs-params">(ChannelHandler handler)</span> </span>{
        <span class="hljs-keyword">super</span>(handler);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">received</span><span class="hljs-params">(Channel channel, Object message)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> Decodeable) {
            <span class="hljs-comment">// 对 Decodeable 接口实现类对象进行解码</span>
            decode(message);
        }

        <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> Request) {
            <span class="hljs-comment">// 对 Request 的 data 字段进行解码</span>
            decode(((Request) message).getData());
        }

        <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> Response) {
            <span class="hljs-comment">// 对 Request 的 result 字段进行解码</span>
            decode(((Response) message).getResult());
        }

        <span class="hljs-comment">// 执行后续逻辑</span>
        handler.received(channel, message);
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(Object message)</span> </span>{
        <span class="hljs-comment">// Decodeable 接口目前有两个实现类，</span>
        <span class="hljs-comment">// 分别为 DecodeableRpcInvocation 和 DecodeableRpcResult</span>
        <span class="hljs-keyword">if</span> (message != <span class="hljs-keyword">null</span> &amp;&amp; message <span class="hljs-keyword">instanceof</span> Decodeable) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 执行解码逻辑</span>
                ((Decodeable) message).decode();
            } <span class="hljs-keyword">catch</span> (Throwable e) {
                <span class="hljs-keyword">if</span> (log.isWarnEnabled()) {
                    log.warn(<span class="hljs-string">"Call Decodeable.decode failed: "</span> + e.getMessage(), e);
                }
            }
        }
    }
}
</code></pre>
<p>DecodeHandler 主要是包含了一些解码逻辑。2.2.1 节分析请求解码时说过，请求解码可在 IO 线程上执行，也可在线程池中执行，这个取决于运行时配置。DecodeHandler 存在的意义就是保证请求或响应对象可在线程池中被解码。解码完毕后，完全解码后的 Request 对象会继续向后传递，下一站是 HeaderExchangeHandler。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeaderExchangeHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ChannelHandlerDelegate</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExchangeHandler handler;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HeaderExchangeHandler</span><span class="hljs-params">(ExchangeHandler handler)</span> </span>{
        <span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"handler == null"</span>);
        }
        <span class="hljs-keyword">this</span>.handler = handler;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">received</span><span class="hljs-params">(Channel channel, Object message)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());
        ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 处理请求对象</span>
            <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> Request) {
                Request request = (Request) message;
                <span class="hljs-keyword">if</span> (request.isEvent()) {
                    <span class="hljs-comment">// 处理事件</span>
                    handlerEvent(channel, request);
                } 
                <span class="hljs-comment">// 处理普通的请求</span>
                <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// 双向通信</span>
                    <span class="hljs-keyword">if</span> (request.isTwoWay()) {
                        <span class="hljs-comment">// 向后调用服务，并得到调用结果</span>
                        Response response = handleRequest(exchangeChannel, request);
                        <span class="hljs-comment">// 将调用结果返回给服务消费端</span>
                        channel.send(response);
                    } 
                    <span class="hljs-comment">// 如果是单向通信，仅向后调用指定服务即可，无需返回调用结果</span>
                    <span class="hljs-keyword">else</span> {
                        handler.received(exchangeChannel, request.getData());
                    }
                }
            }      
            <span class="hljs-comment">// 处理响应对象，服务消费方会执行此处逻辑，后面分析</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> Response) {
                handleResponse(channel, (Response) message);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> String) {
                <span class="hljs-comment">// telnet 相关，忽略</span>
            } <span class="hljs-keyword">else</span> {
                handler.received(exchangeChannel, message);
            }
        } <span class="hljs-keyword">finally</span> {
            HeaderExchangeChannel.removeChannelIfDisconnected(channel);
        }
    }

    <span class="hljs-function">Response <span class="hljs-title">handleRequest</span><span class="hljs-params">(ExchangeChannel channel, Request req)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        Response res = <span class="hljs-keyword">new</span> Response(req.getId(), req.getVersion());
        <span class="hljs-comment">// 检测请求是否合法，不合法则返回状态码为 BAD_REQUEST 的响应</span>
        <span class="hljs-keyword">if</span> (req.isBroken()) {
            Object data = req.getData();

            String msg;
            <span class="hljs-keyword">if</span> (data == <span class="hljs-keyword">null</span>)
                msg = <span class="hljs-keyword">null</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>
                (data <span class="hljs-keyword">instanceof</span> Throwable) msg = StringUtils.toString((Throwable) data);
            <span class="hljs-keyword">else</span>
                msg = data.toString();
            res.setErrorMessage(<span class="hljs-string">"Fail to decode request due to: "</span> + msg);
            <span class="hljs-comment">// 设置 BAD_REQUEST 状态</span>
            res.setStatus(Response.BAD_REQUEST);

            <span class="hljs-keyword">return</span> res;
        }
        
        <span class="hljs-comment">// 获取 data 字段值，也就是 RpcInvocation 对象</span>
        Object msg = req.getData();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 继续向下调用</span>
            Object result = handler.reply(channel, msg);
            <span class="hljs-comment">// 设置 OK 状态码</span>
            res.setStatus(Response.OK);
            <span class="hljs-comment">// 设置调用结果</span>
            res.setResult(result);
        } <span class="hljs-keyword">catch</span> (Throwable e) {
            <span class="hljs-comment">// 若调用过程出现异常，则设置 SERVICE_ERROR，表示服务端异常</span>
            res.setStatus(Response.SERVICE_ERROR);
            res.setErrorMessage(StringUtils.toString(e));
        }
        <span class="hljs-keyword">return</span> res;
    }
}
</code></pre>
<p>到这里，我们看到了比较清晰的请求和响应逻辑。对于双向通信，HeaderExchangeHandler 首先向后进行调用，得到调用结果。然后将调用结果封装到 Response 对象中，最后再将该对象返回给服务消费方。如果请求不合法，或者调用失败，则将错误信息封装到 Response 对象中，并返回给服务消费方。接下来我们继续向后分析，把剩余的调用过程分析完。下面分析定义在 DubboProtocol 类中的匿名类对象逻辑，如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DubboProtocol</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProtocol</span> </span>{

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NAME = <span class="hljs-string">"dubbo"</span>;
    
    <span class="hljs-keyword">private</span> ExchangeHandler requestHandler = <span class="hljs-keyword">new</span> ExchangeHandlerAdapter() {

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">reply</span><span class="hljs-params">(ExchangeChannel channel, Object message)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
            <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> Invocation) {
                Invocation inv = (Invocation) message;
                <span class="hljs-comment">// 获取 Invoker 实例</span>
                Invoker&lt;?&gt; invoker = getInvoker(channel, inv);
                <span class="hljs-keyword">if</span> (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) {
                    <span class="hljs-comment">// 回调相关，忽略</span>
                }
                RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());
                <span class="hljs-comment">// 通过 Invoker 调用具体的服务</span>
                <span class="hljs-keyword">return</span> invoker.invoke(inv);
            }
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RemotingException(channel, <span class="hljs-string">"Unsupported request: ..."</span>);
        }
        
        <span class="hljs-comment">// 忽略其他方法</span>
    }
    
    Invoker&lt;?&gt; getInvoker(Channel channel, Invocation inv) <span class="hljs-keyword">throws</span> RemotingException {
        <span class="hljs-comment">// 忽略回调和本地存根相关逻辑</span>
        <span class="hljs-comment">// ...</span>
        
        <span class="hljs-keyword">int</span> port = channel.getLocalAddress().getPort();
        
        <span class="hljs-comment">// 计算 service key，格式为 groupName/serviceName:serviceVersion:port。比如：</span>
        <span class="hljs-comment">//   dubbo/com.alibaba.dubbo.demo.DemoService:1.0.0:20880</span>
        String serviceKey = serviceKey(port, path, inv.getAttachments().get(Constants.VERSION_KEY), inv.getAttachments().get(Constants.GROUP_KEY));

        <span class="hljs-comment">// 从 exporterMap 查找与 serviceKey 相对应的 DubboExporter 对象，</span>
        <span class="hljs-comment">// 服务导出过程中会将 &lt;serviceKey, DubboExporter&gt; 映射关系存储到 exporterMap 集合中</span>
        DubboExporter&lt;?&gt; exporter = (DubboExporter&lt;?&gt;) exporterMap.get(serviceKey);

        <span class="hljs-keyword">if</span> (exporter == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RemotingException(channel, <span class="hljs-string">"Not found exported service ..."</span>);

        <span class="hljs-comment">// 获取 Invoker 对象，并返回</span>
        <span class="hljs-keyword">return</span> exporter.getInvoker();
    }
    
    <span class="hljs-comment">// 忽略其他方法</span>
}
</code></pre>
<p>以上逻辑用于获取与指定服务对应的 Invoker 实例，并通过 Invoker 的 invoke 方法调用服务逻辑。invoke 方法定义在 AbstractProxyInvoker 中，代码如下。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractProxyInvoker</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Invoker</span>&lt;<span class="hljs-title">T</span>&gt; </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">invoke</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> RpcException </span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 调用 doInvoke 执行后续的调用，并将调用结果封装到 RpcResult 中，并</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()));
        } <span class="hljs-keyword">catch</span> (InvocationTargetException e) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RpcResult(e.getTargetException());
        } <span class="hljs-keyword">catch</span> (Throwable e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">"Failed to invoke remote proxy method ..."</span>);
        }
    }
    
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title">doInvoke</span><span class="hljs-params">(T proxy, String methodName, Class&lt;?&gt;[] parameterTypes, Object[] arguments)</span> <span class="hljs-keyword">throws</span> Throwable</span>;
}
</code></pre>
<p>如上，doInvoke 是一个抽象方法，这个需要由具体的 Invoker 实例实现。Invoker 实例是在运行时通过 JavassistProxyFactory 创建的，创建逻辑如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavassistProxyFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProxyFactory</span> </span>{
    
    <span class="hljs-comment">// 省略其他方法</span>

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">getInvoker</span><span class="hljs-params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>{
        <span class="hljs-keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="hljs-string">'$'</span>) &lt; <span class="hljs-number">0</span> ? proxy.getClass() : type);
        <span class="hljs-comment">// 创建匿名类对象</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doInvoke</span><span class="hljs-params">(T proxy, String methodName,
                                      Class&lt;?&gt;[] parameterTypes,
                                      Object[] arguments)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
                <span class="hljs-comment">// 调用 invokeMethod 方法进行后续的调用</span>
                <span class="hljs-keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
            }
        };
    }
}
</code></pre>
<p>Wrapper 是一个抽象类，其中 invokeMethod 是一个抽象方法。Dubbo 会在运行时通过 Javassist 框架为 Wrapper 生成实现类，并实现 invokeMethod 方法，该方法最终会根据调用信息调用具体的服务。以 DemoServiceImpl 为例，Javassist 为其生成的代理类如下。</p>
<pre><code class="language-java"><span class="hljs-comment">/** Wrapper0 是在运行时生成的，大家可使用 Arthas 进行反编译 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Wrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ClassGenerator</span>.<span class="hljs-title">DC</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] pns;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map pts;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] mns;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] dmns;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class[] mts0;

    <span class="hljs-comment">// 省略其他方法</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invokeMethod</span><span class="hljs-params">(Object object, String string, Class[] arrclass, Object[] arrobject)</span> <span class="hljs-keyword">throws</span> InvocationTargetException </span>{
        DemoService demoService;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 类型转换</span>
            demoService = (DemoService)object;
        }
        <span class="hljs-keyword">catch</span> (Throwable throwable) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(throwable);
        }
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 根据方法名调用指定的方法</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-string">"sayHello"</span>.equals(string) &amp;&amp; arrclass.length == <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">return</span> demoService.sayHello((String)arrobject[<span class="hljs-number">0</span>]);
            }
        }
        <span class="hljs-keyword">catch</span> (Throwable throwable) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvocationTargetException(throwable);
        }
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodException(<span class="hljs-keyword">new</span> StringBuffer().append(<span class="hljs-string">"Not found method \""</span>).append(string).append(<span class="hljs-string">"\" in class com.alibaba.dubbo.demo.DemoService."</span>).toString());
    }
}
</code></pre>
<p>到这里，整个服务调用过程就分析完了。最后把调用过程贴出来，如下：</p>
<pre><code>ChannelEventRunnable#run()
  —&gt; DecodeHandler#received(Channel, Object)
    —&gt; HeaderExchangeHandler#received(Channel, Object)
      —&gt; HeaderExchangeHandler#handleRequest(ExchangeChannel, Request)
        —&gt; DubboProtocol.requestHandler#reply(ExchangeChannel, Object)
          —&gt; Filter#invoke(Invoker, Invocation)
            —&gt; AbstractProxyInvoker#invoke(Invocation)
              —&gt; Wrapper0#invokeMethod(Object, String, Class[], Object[])
                —&gt; DemoServiceImpl#sayHello(String)
</code></pre>
<h3>2.4 服务提供方返回调用结果</h3>
<p>服务提供方调用指定服务后，会将调用结果封装到 Response 对象中，并将该对象返回给服务消费方。服务提供方也是通过 NettyChannel 的 send 方法将 Response 对象返回，这个方法在 2.2.1 节分析过，这里就不在重复分析了。本节我们仅需关注 Response 对象的编码过程即可，这里仍然省略一些中间调用，直接分析具体的编码逻辑。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExchangeCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TelnetCodec</span> </span>{
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, Object msg)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> Request) {
            encodeRequest(channel, buffer, (Request) msg);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> Response) {
            <span class="hljs-comment">// 对响应对象进行编码</span>
            encodeResponse(channel, buffer, (Response) msg);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">super</span>.encode(channel, buffer, msg);
        }
    }
    
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encodeResponse</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, Response res)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        <span class="hljs-keyword">int</span> savedWriteIndex = buffer.writerIndex();
        <span class="hljs-keyword">try</span> {
            Serialization serialization = getSerialization(channel);
            <span class="hljs-comment">// 创建消息头字节数组</span>
            <span class="hljs-keyword">byte</span>[] header = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[HEADER_LENGTH];
            <span class="hljs-comment">// 设置魔数</span>
            Bytes.short2bytes(MAGIC, header);
            <span class="hljs-comment">// 设置序列化器编号</span>
            header[<span class="hljs-number">2</span>] = serialization.getContentTypeId();
            <span class="hljs-keyword">if</span> (res.isHeartbeat()) header[<span class="hljs-number">2</span>] |= FLAG_EVENT;
            <span class="hljs-comment">// 获取响应状态</span>
            <span class="hljs-keyword">byte</span> status = res.getStatus();
            <span class="hljs-comment">// 设置响应状态</span>
            header[<span class="hljs-number">3</span>] = status;
            <span class="hljs-comment">// 设置请求编号</span>
            Bytes.long2bytes(res.getId(), header, <span class="hljs-number">4</span>);

            <span class="hljs-comment">// 更新 writerIndex，为消息头预留 16 个字节的空间</span>
            buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);
            ChannelBufferOutputStream bos = <span class="hljs-keyword">new</span> ChannelBufferOutputStream(buffer);
            ObjectOutput out = serialization.serialize(channel.getUrl(), bos);
           
            <span class="hljs-keyword">if</span> (status == Response.OK) {
                <span class="hljs-keyword">if</span> (res.isHeartbeat()) {
                    <span class="hljs-comment">// 对心跳响应结果进行序列化，已废弃</span>
                    encodeHeartbeatData(channel, out, res.getResult());
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// 对调用结果进行序列化</span>
                    encodeResponseData(channel, out, res.getResult(), res.getVersion());
                }
            } <span class="hljs-keyword">else</span> { 
                <span class="hljs-comment">// 对错误信息进行序列化</span>
                out.writeUTF(res.getErrorMessage())
            };
            out.flushBuffer();
            <span class="hljs-keyword">if</span> (out <span class="hljs-keyword">instanceof</span> Cleanable) {
                ((Cleanable) out).cleanup();
            }
            bos.flush();
            bos.close();

            <span class="hljs-comment">// 获取写入的字节数，也就是消息体长度</span>
            <span class="hljs-keyword">int</span> len = bos.writtenBytes();
            checkPayload(channel, len);
            
            <span class="hljs-comment">// 将消息体长度写入到消息头中</span>
            Bytes.int2bytes(len, header, <span class="hljs-number">12</span>);
            <span class="hljs-comment">// 将 buffer 指针移动到 savedWriteIndex，为写消息头做准备</span>
            buffer.writerIndex(savedWriteIndex);
            <span class="hljs-comment">// 从 savedWriteIndex 下标处写入消息头</span>
            buffer.writeBytes(header); 
            <span class="hljs-comment">// 设置新的 writerIndex，writerIndex = 原写下标 + 消息头长度 + 消息体长度</span>
            buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);
        } <span class="hljs-keyword">catch</span> (Throwable t) {
            <span class="hljs-comment">// 异常处理逻辑不是很难理解，但是代码略多，这里忽略了</span>
        }
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DubboCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ExchangeCodec</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Codec2</span> </span>{
    
	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encodeResponseData</span><span class="hljs-params">(Channel channel, ObjectOutput out, Object data, String version)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        Result result = (Result) data;
        <span class="hljs-comment">// 检测当前协议版本是否支持带有 attachment 集合的 Response 对象</span>
        <span class="hljs-keyword">boolean</span> attach = Version.isSupportResponseAttachment(version);
        Throwable th = result.getException();
        
        <span class="hljs-comment">// 异常信息为空</span>
        <span class="hljs-keyword">if</span> (th == <span class="hljs-keyword">null</span>) {
            Object ret = result.getValue();
            <span class="hljs-comment">// 调用结果为空</span>
            <span class="hljs-keyword">if</span> (ret == <span class="hljs-keyword">null</span>) {
                <span class="hljs-comment">// 序列化响应类型</span>
                out.writeByte(attach ? RESPONSE_NULL_VALUE_WITH_ATTACHMENTS : RESPONSE_NULL_VALUE);
            } 
            <span class="hljs-comment">// 调用结果非空</span>
            <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 序列化响应类型</span>
                out.writeByte(attach ? RESPONSE_VALUE_WITH_ATTACHMENTS : RESPONSE_VALUE);
                <span class="hljs-comment">// 序列化调用结果</span>
                out.writeObject(ret);
            }
        } 
        <span class="hljs-comment">// 异常信息非空</span>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 序列化响应类型</span>
            out.writeByte(attach ? RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS : RESPONSE_WITH_EXCEPTION);
            <span class="hljs-comment">// 序列化异常对象</span>
            out.writeObject(th);
        }

        <span class="hljs-keyword">if</span> (attach) {
            <span class="hljs-comment">// 记录 Dubbo 协议版本</span>
            result.getAttachments().put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());
            <span class="hljs-comment">// 序列化 attachments 集合</span>
            out.writeObject(result.getAttachments());
        }
    }
}
</code></pre>
<p>以上就是 Response 对象编码的过程，和前面分析的 Request 对象编码过程很相似。如果大家能看 Request 对象的编码逻辑，那么这里的 Response 对象的编码逻辑也不难理解，就不多说了。接下来我们再来分析双向通信的最后一环 —— 服务消费方接收调用结果。</p>
<h3>2.5 服务消费方接收调用结果</h3>
<p>服务消费方在收到响应数据后，首先要做的事情是对响应数据进行解码，得到 Response 对象。然后再将该对象传递给下一个入站处理器，这个入站处理器就是 NettyHandler。接下来 NettyHandler 会将这个对象继续向下传递，最后 AllChannelHandler 的 received 方法会收到这个对象，并将这个对象派发到线程池中。这个过程和服务提供方接收请求的过程是一样的，因此这里就不重复分析了。本节我们重点分析两个方面的内容，一是响应数据的解码过程，二是 Dubbo 如何将调用结果传递给用户线程的。下面先来分析响应数据的解码过程。</p>
<h4>2.5.1 响应数据解码</h4>
<p>响应数据解码逻辑主要的逻辑封装在 DubboCodec 中，我们直接分析这个类的代码。如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DubboCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ExchangeCodec</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Codec2</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">decodeBody</span><span class="hljs-params">(Channel channel, InputStream is, <span class="hljs-keyword">byte</span>[] header)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        <span class="hljs-keyword">byte</span> flag = header[<span class="hljs-number">2</span>], proto = (<span class="hljs-keyword">byte</span>) (flag &amp; SERIALIZATION_MASK);
        Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);
        <span class="hljs-comment">// 获取请求编号</span>
        <span class="hljs-keyword">long</span> id = Bytes.bytes2long(header, <span class="hljs-number">4</span>);
        <span class="hljs-comment">// 检测消息类型，若下面的条件成立，表明消息类型为 Response</span>
        <span class="hljs-keyword">if</span> ((flag &amp; FLAG_REQUEST) == <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// 创建 Response 对象</span>
            Response res = <span class="hljs-keyword">new</span> Response(id);
            <span class="hljs-comment">// 检测事件标志位</span>
            <span class="hljs-keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="hljs-number">0</span>) {
                <span class="hljs-comment">// 设置心跳事件</span>
                res.setEvent(Response.HEARTBEAT_EVENT);
            }
            <span class="hljs-comment">// 获取响应状态</span>
            <span class="hljs-keyword">byte</span> status = header[<span class="hljs-number">3</span>];
            <span class="hljs-comment">// 设置响应状态</span>
            res.setStatus(status);
            
            <span class="hljs-comment">// 如果响应状态为 OK，表明调用过程正常</span>
            <span class="hljs-keyword">if</span> (status == Response.OK) {
                <span class="hljs-keyword">try</span> {
                    Object data;
                    <span class="hljs-keyword">if</span> (res.isHeartbeat()) {
                        <span class="hljs-comment">// 反序列化心跳数据，已废弃</span>
                        data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.isEvent()) {
                        <span class="hljs-comment">// 反序列化事件数据</span>
                        data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));
                    } <span class="hljs-keyword">else</span> {
                        DecodeableRpcResult result;
                        <span class="hljs-comment">// 根据 url 参数决定是否在 IO 线程上执行解码逻辑</span>
                        <span class="hljs-keyword">if</span> (channel.getUrl().getParameter(
                                Constants.DECODE_IN_IO_THREAD_KEY,
                                Constants.DEFAULT_DECODE_IN_IO_THREAD)) {
                            <span class="hljs-comment">// 创建 DecodeableRpcResult 对象</span>
                            result = <span class="hljs-keyword">new</span> DecodeableRpcResult(channel, res, is,
                                    (Invocation) getRequestData(id), proto);
                            <span class="hljs-comment">// 进行后续的解码工作</span>
                            result.decode();
                        } <span class="hljs-keyword">else</span> {
                            <span class="hljs-comment">// 创建 DecodeableRpcResult 对象</span>
                            result = <span class="hljs-keyword">new</span> DecodeableRpcResult(channel, res,
                                    <span class="hljs-keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)),
                                    (Invocation) getRequestData(id), proto);
                        }
                        data = result;
                    }
                    
                    <span class="hljs-comment">// 设置 DecodeableRpcResult 对象到 Response 对象中</span>
                    res.setResult(data);
                } <span class="hljs-keyword">catch</span> (Throwable t) {
                    <span class="hljs-comment">// 解码过程中出现了错误，此时设置 CLIENT_ERROR 状态码到 Response 对象中</span>
                    res.setStatus(Response.CLIENT_ERROR);
                    res.setErrorMessage(StringUtils.toString(t));
                }
            } 
            <span class="hljs-comment">// 响应状态非 OK，表明调用过程出现了异常</span>
            <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 反序列化异常信息，并设置到 Response 对象中</span>
                res.setErrorMessage(deserialize(s, channel.getUrl(), is).readUTF());
            }
            <span class="hljs-keyword">return</span> res;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 对请求数据进行解码，前面已分析过，此处忽略</span>
        }
    }
}
</code></pre>
<p>以上就是响应数据的解码过程，上面逻辑看起来是不是似曾相识。对的，我们在前面章节分析过 DubboCodec 的 decodeBody 方法中关于请求数据的解码过程，该过程和响应数据的解码过程很相似。下面，我们继续分析调用结果的反序列化过程，如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecodeableRpcResult</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RpcResult</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Codec</span>, <span class="hljs-title">Decodeable</span> </span>{
    
    <span class="hljs-keyword">private</span> Invocation invocation;
	
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
        <span class="hljs-keyword">if</span> (!hasDecoded &amp;&amp; channel != <span class="hljs-keyword">null</span> &amp;&amp; inputStream != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 执行反序列化操作</span>
                decode(channel, inputStream);
            } <span class="hljs-keyword">catch</span> (Throwable e) {
                <span class="hljs-comment">// 反序列化失败，设置 CLIENT_ERROR 状态到 Response 对象中</span>
                response.setStatus(Response.CLIENT_ERROR);
                <span class="hljs-comment">// 设置异常信息</span>
                response.setErrorMessage(StringUtils.toString(e));
            } <span class="hljs-keyword">finally</span> {
                hasDecoded = <span class="hljs-keyword">true</span>;
            }
        }
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">decode</span><span class="hljs-params">(Channel channel, InputStream input)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)
                .deserialize(channel.getUrl(), input);
        
        <span class="hljs-comment">// 反序列化响应类型</span>
        <span class="hljs-keyword">byte</span> flag = in.readByte();
        <span class="hljs-keyword">switch</span> (flag) {
            <span class="hljs-keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE:
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> DubboCodec.RESPONSE_VALUE:
                <span class="hljs-comment">// ...</span>
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION:
                <span class="hljs-comment">// ...</span>
                <span class="hljs-keyword">break</span>;
                
            <span class="hljs-comment">// 返回值为空，且携带了 attachments 集合</span>
            <span class="hljs-keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS:
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// 反序列化 attachments 集合，并存储起来 </span>
                    setAttachments((Map&lt;String, String&gt;) in.readObject(Map.class));
                } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(StringUtils.toString(<span class="hljs-string">"Read response data failed."</span>, e));
                }
                <span class="hljs-keyword">break</span>;
                
            <span class="hljs-comment">// 返回值不为空，且携带了 attachments 集合</span>
            <span class="hljs-keyword">case</span> DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// 获取返回值类型</span>
                    Type[] returnType = RpcUtils.getReturnTypes(invocation);
                    <span class="hljs-comment">// 反序列化调用结果，并保存起来</span>
                    setValue(returnType == <span class="hljs-keyword">null</span> || returnType.length == <span class="hljs-number">0</span> ? in.readObject() :
                            (returnType.length == <span class="hljs-number">1</span> ? in.readObject((Class&lt;?&gt;) returnType[<span class="hljs-number">0</span>])
                                    : in.readObject((Class&lt;?&gt;) returnType[<span class="hljs-number">0</span>], returnType[<span class="hljs-number">1</span>])));
                    <span class="hljs-comment">// 反序列化 attachments 集合，并存储起来</span>
                    setAttachments((Map&lt;String, String&gt;) in.readObject(Map.class));
                } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(StringUtils.toString(<span class="hljs-string">"Read response data failed."</span>, e));
                }
                <span class="hljs-keyword">break</span>;
                
            <span class="hljs-comment">// 异常对象不为空，且携带了 attachments 集合</span>
            <span class="hljs-keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS:
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// 反序列化异常对象</span>
                    Object obj = in.readObject();
                    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Throwable == <span class="hljs-keyword">false</span>)
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Response data error, expect Throwable, but get "</span> + obj);
                    <span class="hljs-comment">// 设置异常对象</span>
                    setException((Throwable) obj);
                    <span class="hljs-comment">// 反序列化 attachments 集合，并存储起来</span>
                    setAttachments((Map&lt;String, String&gt;) in.readObject(Map.class));
                } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(StringUtils.toString(<span class="hljs-string">"Read response data failed."</span>, e));
                }
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Unknown result flag, expect '0' '1' '2', get "</span> + flag);
        }
        <span class="hljs-keyword">if</span> (in <span class="hljs-keyword">instanceof</span> Cleanable) {
            ((Cleanable) in).cleanup();
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
}
</code></pre>
<p>本篇文章所分析的源码版本为 2.6.4，该版本下的 Response 支持 attachments 集合，所以上面仅对部分 case 分支进行了注释。其他 case 分支的逻辑比被注释分支的逻辑更为简单，这里就忽略了。我们所使用的测试服务接口 DemoService 包含了一个具有返回值的方法，正常调用下，线程会进入 RESPONSE_VALUE_WITH_ATTACHMENTS 分支中。然后线程会从 invocation 变量（大家探索一下 invocation 变量的由来）中获取返回值类型，接着对调用结果进行反序列化，并将序列化后的结果存储起来。最后对  attachments 集合进行反序列化，并存到指定字段中。到此，关于响应数据的解码过程就分析完了。接下来，我们再来探索一下响应对象 Response 的去向。</p>
<h4>2.5.2 向用户线程传递调用结果</h4>
<p>响应数据解码完成后，Dubbo 会将响应对象派发到线程池上。要注意的是，线程池中的线程并非用户的调用线程，所以要想办法将响应对象从线程池线程传递到用户线程上。我们在 2.1 节分析过用户线程在发送完请求后的动作，即调用 DefaultFuture 的 get 方法等待响应对象的到来。当响应对象到来后，用户线程会被唤醒，并通过<strong>调用编号</strong>获取属于自己的响应对象。下面我们来看一下整个过程对应的代码。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeaderExchangeHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ChannelHandlerDelegate</span> </span>{
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">received</span><span class="hljs-params">(Channel channel, Object message)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());
        ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> Request) {
                <span class="hljs-comment">// 处理请求，前面已分析过，省略</span>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> Response) {
                <span class="hljs-comment">// 处理响应</span>
                handleResponse(channel, (Response) message);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> String) {
                <span class="hljs-comment">// telnet 相关，忽略</span>
            } <span class="hljs-keyword">else</span> {
                handler.received(exchangeChannel, message);
            }
        } <span class="hljs-keyword">finally</span> {
            HeaderExchangeChannel.removeChannelIfDisconnected(channel);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleResponse</span><span class="hljs-params">(Channel channel, Response response)</span> <span class="hljs-keyword">throws</span> RemotingException </span>{
        <span class="hljs-keyword">if</span> (response != <span class="hljs-keyword">null</span> &amp;&amp; !response.isHeartbeat()) {
            <span class="hljs-comment">// 继续向下调用</span>
            DefaultFuture.received(channel, response);
        }
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultFuture</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ResponseFuture</span> </span>{  
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition done = lock.newCondition();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Response response;
    
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">received</span><span class="hljs-params">(Channel channel, Response response)</span> </span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 根据调用编号从 FUTURES 集合中查找指定的 DefaultFuture 对象</span>
            DefaultFuture future = FUTURES.remove(response.getId());
            <span class="hljs-keyword">if</span> (future != <span class="hljs-keyword">null</span>) {
                <span class="hljs-comment">// 继续向下调用</span>
                future.doReceived(response);
            } <span class="hljs-keyword">else</span> {
                logger.warn(<span class="hljs-string">"The timeout response finally returned at ..."</span>);
            }
        } <span class="hljs-keyword">finally</span> {
            CHANNELS.remove(response.getId());
        }
    }

	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReceived</span><span class="hljs-params">(Response res)</span> </span>{
        lock.lock();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 保存响应对象</span>
            response = res;
            <span class="hljs-keyword">if</span> (done != <span class="hljs-keyword">null</span>) {
                <span class="hljs-comment">// 唤醒用户线程</span>
                done.signal();
            }
        } <span class="hljs-keyword">finally</span> {
            lock.unlock();
        }
        <span class="hljs-keyword">if</span> (callback != <span class="hljs-keyword">null</span>) {
            invokeCallback(callback);
        }
    }
}
</code></pre>
<p>以上逻辑是将响应对象保存到相应的 DefaultFuture 实例中，然后再唤醒用户线程，随后用户线程即可从 DefaultFuture 实例中获取到相应结果。</p>
<p>本篇文章在多个地方都强调过调用编号很重要，但一直没有解释原因，这里简单说明一下。一般情况下，服务消费方会并发调用多个服务，每个用户线程发送请求后，会调用不同 DefaultFuture 对象的 get 方法进行等待。 一段时间后，服务消费方的线程池会收到多个响应对象。这个时候要考虑一个问题，如何将每个响应对象传递给相应的 DefaultFuture 对象，且不出错。答案是通过调用编号。DefaultFuture 被创建时，会要求传入一个 Request 对象。此时 DefaultFuture 可从 Request 对象中获取调用编号，并将 &lt;调用编号, DefaultFuture 对象&gt; 映射关系存入到静态 Map 中，即 FUTURES。线程池中的线程在收到 Response 对象后，会根据 Response 对象中的调用编号到 FUTURES 集合中取出相应的 DefaultFuture 对象，然后再将 Response 对象设置到 DefaultFuture 对象中。最后再唤醒用户线程，这样用户线程即可从 DefaultFuture 对象中获取调用结果了。整个过程大致如下图：</p>
<p><img src="sources/images/request-id-application.jpg" alt=""></p>
<h2>3. 总结</h2>
<p>本篇文章主要对 Dubbo 中的几种服务调用方式，以及从双向通信的角度对整个通信过程进行了详细的分析。按照通信顺序，通信过程包括服务消费方发送请求，服务提供方接收请求，服务提供方返回响应数据，服务消费方接收响应数据等过程。理解这些过程需要大家对网络编程，尤其是 Netty 有一定的了解。限于篇幅原因，本篇文章无法将服务调用的所有内容都一一进行分析。对于本篇文章未讲到或未详细分析的内容，比如服务降级、过滤器链、以及序列化等。大家若感兴趣，可自行进行分析。并将分析整理成文，分享给社区。</p>
<p>本篇文章就到这里了，感谢阅读。</p>
</div></section><footer class="footer-container"><div class="footer-body"><img src="/img/dubbo_gray.png"/><img class="apache" src="/img/apache_logo.png"/><div class="cols-container"><div class="col col-12"><h3>Disclaimer</h3><p>Apache Dubbo is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Incubator. Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.</p></div><div class="col col-4"><dl><dt>ASF</dt><dd><a href="http://www.apache.org" target="_self">基金会</a></dd><dd><a href="http://www.apache.org/licenses/" target="_self">证书</a></dd><dd><a href="http://www.apache.org/events/current-event" target="_self">事件</a></dd><dd><a href="http://www.apache.org/foundation/sponsorship.html" target="_self">赞助</a></dd><dd><a href="http://www.apache.org/foundation/thanks.html" target="_self">致谢</a></dd></dl></div><div class="col col-4"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/user/quick-start.html" target="_self">快速开始</a></dd><dd><a href="/zh-cn/docs/dev/build.html" target="_self">开发者指南</a></dd><dd><a href="/zh-cn/docs/admin/ops/dubbo-ops.html" target="_self">运维管理</a></dd></dl></div><div class="col col-4"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/community/index.html" target="_self">社区</a></dd><dd><a href="https://www.apache.org/security" target="_self">安全</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2018-2019 The Apache Software Foundation. Apache and the Apache feather logo are trademarks of The Apache Software Foundation.</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
  <script src="/build/documentation.js"></script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112489517-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-112489517-1');
	</script>
</body>
</html>