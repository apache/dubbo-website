{
  "filename": "service-invoking-process.md",
  "__html": "<h2>1. 简介</h2>\n<p>在前面的文章中，我们分析了 Dubbo SPI、服务导出与引入、以及集群容错方面的代码。经过前文的铺垫，本篇文章我们终于可以分析服务调用过程了。Dubbo 服务调用过程比较复杂，包含众多步骤，比如发送请求、编解码、服务降级、过滤器链处理、序列化、线程派发以及响应请求等步骤。限于篇幅原因，本篇文章无法对所有的步骤一一进行分析。本篇文章将会重点分析请求的发送与接收、编解码、线程派发以及响应的发送与接收等过程，至于服务降级、过滤器链和序列化大家自行进行分析，也可以将其当成一个黑盒，暂时忽略也没关系。介绍完本篇文章要分析的内容，接下来我们进入正题吧。</p>\n<h2>2. 源码分析</h2>\n<p>在进行源码分析之前，我们先来通过一张图了解 Dubbo 服务调用过程。</p>\n<p><img src=\"sources/images/send-request-process.jpg\" alt=\"\"></p>\n<p>首先服务消费者通过代理对象 Proxy 发起远程调用，接着通过网络客户端 Client 将编码后的请求发送给服务提供方的网络层上，也就是 Server。Server 在收到请求后，首先要做的事情是对数据包进行解码。然后将解码后的请求发送至分发器 Dispatcher，再由分发器将请求派发到指定的线程池上，最后由线程池调用具体的服务。这就是一个远程调用请求的发送与接收过程。至于响应的发送与接收过程，这张图中没有表现出来。对于这两个过程，我们也会进行详细分析。</p>\n<h3>2.1 服务调用方式</h3>\n<p>Dubbo 支持同步和异步两种调用方式，其中异步调用还可细分为“有返回值”的异步调用和“无返回值”的异步调用。所谓“无返回值”异步调用是指服务消费方只管调用，但不关心调用结果，此时 Dubbo 会直接返回一个空的 RpcResult。若要使用异步特性，需要服务消费方手动进行配置。默认情况下，Dubbo 使用同步调用方式。</p>\n<p>本节以及其他章节将会使用 Dubbo 官方提供的 Demo 分析整个调用过程，下面我们从 DemoService 接口的代理类开始进行分析。Dubbo 默认使用 Javassist 框架为服务接口生成动态代理类，因此我们需要先将代理类进行反编译才能看到源码。这里使用阿里开源 Java 应用诊断工具 <a href=\"https://github.com/alibaba/arthas\">Arthas</a> 反编译代理类，结果如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/**\n * Arthas 反编译步骤：\n * 1. 启动 Arthas\n *    java -jar arthas-boot.jar\n *\n * 2. 输入编号选择进程\n *    Arthas 启动后，会打印 Java 应用进程列表，如下：\n *    [1]: 11232 org.jetbrains.jps.cmdline.Launcher\n *    [2]: 22370 org.jetbrains.jps.cmdline.Launcher\n *    [3]: 22371 com.alibaba.dubbo.demo.consumer.Consumer\n *    [4]: 22362 com.alibaba.dubbo.demo.provider.Provider\n *    [5]: 2074 org.apache.zookeeper.server.quorum.QuorumPeerMain\n * 这里输入编号 3，让 Arthas 关联到启动类为 com.....Consumer 的 Java 进程上\n *\n * 3. 由于 Demo 项目中只有一个服务接口，因此此接口的代理类类名为 proxy0，此时使用 sc 命令搜索这个类名。\n *    $ sc *.proxy0\n *    com.alibaba.dubbo.common.bytecode.proxy0\n *\n * 4. 使用 jad 命令反编译 com.alibaba.dubbo.common.bytecode.proxy0\n *    $ jad com.alibaba.dubbo.common.bytecode.proxy0\n *\n * 更多使用方法请参考 Arthas 官方文档：\n *   https://alibaba.github.io/arthas/quick-start.html\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">proxy0</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ClassGenerator</span>.<span class=\"hljs-title\">DC</span>, <span class=\"hljs-title\">EchoService</span>, <span class=\"hljs-title\">DemoService</span> </span>{\n    <span class=\"hljs-comment\">// 方法数组</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Method[] methods;\n    <span class=\"hljs-keyword\">private</span> InvocationHandler handler;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">proxy0</span><span class=\"hljs-params\">(InvocationHandler invocationHandler)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.handler = invocationHandler;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">proxy0</span><span class=\"hljs-params\">()</span> </span>{\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String string)</span> </span>{\n        <span class=\"hljs-comment\">// 将参数存储到 Object 数组中</span>\n        Object[] arrobject = <span class=\"hljs-keyword\">new</span> Object[]{string};\n        <span class=\"hljs-comment\">// 调用 InvocationHandler 实现类的 invoke 方法得到调用结果</span>\n        Object object = <span class=\"hljs-keyword\">this</span>.handler.invoke(<span class=\"hljs-keyword\">this</span>, methods[<span class=\"hljs-number\">0</span>], arrobject);\n        <span class=\"hljs-comment\">// 返回调用结果</span>\n        <span class=\"hljs-keyword\">return</span> (String)object;\n    }\n\n    <span class=\"hljs-comment\">/** 回声测试方法 */</span>\n    <span class=\"hljs-keyword\">public</span> Object $echo(Object object) {\n        Object[] arrobject = <span class=\"hljs-keyword\">new</span> Object[]{object};\n        Object object2 = <span class=\"hljs-keyword\">this</span>.handler.invoke(<span class=\"hljs-keyword\">this</span>, methods[<span class=\"hljs-number\">1</span>], arrobject);\n        <span class=\"hljs-keyword\">return</span> object2;\n    }\n}\n</code></pre>\n<p>如上，代理类的逻辑比较简单。首先将运行时参数存储到数组中，然后调用 InvocationHandler 接口实现类的 invoke 方法，得到调用结果，最后将结果转型并返回给调用方。关于代理类的逻辑就说这么多，继续向下分析。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">InvokerInvocationHandler</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">InvocationHandler</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Invoker&lt;?&gt; invoker;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">InvokerInvocationHandler</span><span class=\"hljs-params\">(Invoker&lt;?&gt; handler)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.invoker = handler;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(Object proxy, Method method, Object[] args)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n        String methodName = method.getName();\n        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();\n        \n        <span class=\"hljs-comment\">// 拦截定义在 Object 类中的方法（未被子类重写），比如 wait/notify</span>\n        <span class=\"hljs-keyword\">if</span> (method.getDeclaringClass() == Object.class) {\n            <span class=\"hljs-keyword\">return</span> method.invoke(invoker, args);\n        }\n        \n        <span class=\"hljs-comment\">// 如果 toString、hashCode 和 equals 等方法被子类重写了，这里也直接调用</span>\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">\"toString\"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">return</span> invoker.toString();\n        }\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">\"hashCode\"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">return</span> invoker.hashCode();\n        }\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">\"equals\"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class=\"hljs-number\">1</span>) {\n            <span class=\"hljs-keyword\">return</span> invoker.equals(args[<span class=\"hljs-number\">0</span>]);\n        }\n        \n        <span class=\"hljs-comment\">// 将 method 和 args 封装到 RpcInvocation 中，并执行后续的调用</span>\n        <span class=\"hljs-keyword\">return</span> invoker.invoke(<span class=\"hljs-keyword\">new</span> RpcInvocation(method, args)).recreate();\n    }\n}\n</code></pre>\n<p>InvokerInvocationHandler 中的 invoker 成员变量类型为 MockClusterInvoker，MockClusterInvoker 内部封装了服务降级逻辑。下面简单看一下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MockClusterInvoker</span>&lt;<span class=\"hljs-title\">T</span>&gt; <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Invoker</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>{\n    \n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Invoker&lt;T&gt; invoker;\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Result <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n        Result result = <span class=\"hljs-keyword\">null</span>;\n\n        <span class=\"hljs-comment\">// 获取 mock 配置值</span>\n        String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();\n        <span class=\"hljs-keyword\">if</span> (value.length() == <span class=\"hljs-number\">0</span> || value.equalsIgnoreCase(<span class=\"hljs-string\">\"false\"</span>)) {\n            <span class=\"hljs-comment\">// 无 mock 逻辑，直接调用其他 Invoker 对象的 invoke 方法，</span>\n            <span class=\"hljs-comment\">// 比如 FailoverClusterInvoker</span>\n            result = <span class=\"hljs-keyword\">this</span>.invoker.invoke(invocation);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (value.startsWith(<span class=\"hljs-string\">\"force\"</span>)) {\n            <span class=\"hljs-comment\">// force:xxx 直接执行 mock 逻辑，不发起远程调用</span>\n            result = doMockInvoke(invocation, <span class=\"hljs-keyword\">null</span>);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// fail:xxx 表示消费方对调用服务失败后，再执行 mock 逻辑，不抛出异常</span>\n            <span class=\"hljs-keyword\">try</span> {\n                <span class=\"hljs-comment\">// 调用其他 Invoker 对象的 invoke 方法</span>\n                result = <span class=\"hljs-keyword\">this</span>.invoker.invoke(invocation);\n            } <span class=\"hljs-keyword\">catch</span> (RpcException e) {\n                <span class=\"hljs-keyword\">if</span> (e.isBiz()) {\n                    <span class=\"hljs-keyword\">throw</span> e;\n                } <span class=\"hljs-keyword\">else</span> {\n                    <span class=\"hljs-comment\">// 调用失败，执行 mock 逻辑</span>\n                    result = doMockInvoke(invocation, e);\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n    \n    <span class=\"hljs-comment\">// 省略其他方法</span>\n}\n</code></pre>\n<p>服务降级不是本文重点，因此这里就不分析 doMockInvoke 方法了。考虑到前文已经详细分析过 FailoverClusterInvoker，因此本节略过 FailoverClusterInvoker，直接分析 DubboInvoker。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AbstractInvoker</span>&lt;<span class=\"hljs-title\">T</span>&gt; <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Invoker</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>{\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Result <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(Invocation inv)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n        <span class=\"hljs-keyword\">if</span> (destroyed.get()) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RpcException(<span class=\"hljs-string\">\"Rpc invoker for service ...\"</span>);\n        }\n        RpcInvocation invocation = (RpcInvocation) inv;\n        <span class=\"hljs-comment\">// 设置 Invoker</span>\n        invocation.setInvoker(<span class=\"hljs-keyword\">this</span>);\n        <span class=\"hljs-keyword\">if</span> (attachment != <span class=\"hljs-keyword\">null</span> &amp;&amp; attachment.size() &gt; <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-comment\">// 设置 attachment</span>\n            invocation.addAttachmentsIfAbsent(attachment);\n        }\n        Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();\n        <span class=\"hljs-keyword\">if</span> (contextAttachments != <span class=\"hljs-keyword\">null</span> &amp;&amp; contextAttachments.size() != <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-comment\">// 添加 contextAttachments 到 RpcInvocation#attachment 变量中</span>\n            invocation.addAttachments(contextAttachments);\n        }\n        <span class=\"hljs-keyword\">if</span> (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, <span class=\"hljs-keyword\">false</span>)) {\n            <span class=\"hljs-comment\">// 设置异步信息到 RpcInvocation#attachment 中</span>\n            invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());\n        }\n        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);\n\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 抽象方法，由子类实现</span>\n            <span class=\"hljs-keyword\">return</span> doInvoke(invocation);\n        } <span class=\"hljs-keyword\">catch</span> (InvocationTargetException e) {\n            <span class=\"hljs-comment\">// ...</span>\n        } <span class=\"hljs-keyword\">catch</span> (RpcException e) {\n            <span class=\"hljs-comment\">// ...</span>\n        } <span class=\"hljs-keyword\">catch</span> (Throwable e) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> RpcResult(e);\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> Result <span class=\"hljs-title\">doInvoke</span><span class=\"hljs-params\">(Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> Throwable</span>;\n    \n    <span class=\"hljs-comment\">// 省略其他方法</span>\n}\n</code></pre>\n<p>上面的代码来自 AbstractInvoker 类，其中大部分代码用于添加信息到 RpcInvocation#attachment 变量中，添加完毕后，调用 doInvoke 执行后续的调用。doInvoke 是一个抽象方法，需要由子类实现，下面到 DubboInvoker 中看一下。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DubboInvoker</span>&lt;<span class=\"hljs-title\">T</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractInvoker</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>{\n    \n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ExchangeClient[] clients;\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Result <span class=\"hljs-title\">doInvoke</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n        RpcInvocation inv = (RpcInvocation) invocation;\n        <span class=\"hljs-keyword\">final</span> String methodName = RpcUtils.getMethodName(invocation);\n        <span class=\"hljs-comment\">// 设置 path 和 version 到 attachment 中</span>\n        inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());\n        inv.setAttachment(Constants.VERSION_KEY, version);\n\n        ExchangeClient currentClient;\n        <span class=\"hljs-keyword\">if</span> (clients.length == <span class=\"hljs-number\">1</span>) {\n            <span class=\"hljs-comment\">// 从 clients 数组中获取 ExchangeClient</span>\n            currentClient = clients[<span class=\"hljs-number\">0</span>];\n        } <span class=\"hljs-keyword\">else</span> {\n            currentClient = clients[index.getAndIncrement() % clients.length];\n        }\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 获取异步配置</span>\n            <span class=\"hljs-keyword\">boolean</span> isAsync = RpcUtils.isAsync(getUrl(), invocation);\n            <span class=\"hljs-comment\">// isOneway 为 true，表示“单向”通信</span>\n            <span class=\"hljs-keyword\">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);\n            <span class=\"hljs-keyword\">int</span> timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n\n            <span class=\"hljs-comment\">// 异步无返回值</span>\n            <span class=\"hljs-keyword\">if</span> (isOneway) {\n                <span class=\"hljs-keyword\">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class=\"hljs-keyword\">false</span>);\n                <span class=\"hljs-comment\">// 发送请求</span>\n                currentClient.send(inv, isSent);\n                <span class=\"hljs-comment\">// 设置上下文中的 future 字段为 null</span>\n                RpcContext.getContext().setFuture(<span class=\"hljs-keyword\">null</span>);\n                <span class=\"hljs-comment\">// 返回一个空的 RpcResult</span>\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> RpcResult();\n            } \n\n            <span class=\"hljs-comment\">// 异步有返回值</span>\n            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isAsync) {\n                <span class=\"hljs-comment\">// 发送请求，并得到一个 ResponseFuture 实例</span>\n                ResponseFuture future = currentClient.request(inv, timeout);\n                <span class=\"hljs-comment\">// 设置 future 到上下文中</span>\n                RpcContext.getContext().setFuture(<span class=\"hljs-keyword\">new</span> FutureAdapter&lt;Object&gt;(future));\n                <span class=\"hljs-comment\">// 暂时返回一个空结果</span>\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> RpcResult();\n            } \n\n            <span class=\"hljs-comment\">// 同步调用</span>\n            <span class=\"hljs-keyword\">else</span> {\n                RpcContext.getContext().setFuture(<span class=\"hljs-keyword\">null</span>);\n                <span class=\"hljs-comment\">// 发送请求，得到一个 ResponseFuture 实例，并调用该实例的 get 方法进行等待</span>\n                <span class=\"hljs-keyword\">return</span> (Result) currentClient.request(inv, timeout).get();\n            }\n        } <span class=\"hljs-keyword\">catch</span> (TimeoutException e) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RpcException(..., <span class=\"hljs-string\">\"Invoke remote method timeout....\"</span>);\n        } <span class=\"hljs-keyword\">catch</span> (RemotingException e) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RpcException(..., <span class=\"hljs-string\">\"Failed to invoke remote method: ...\"</span>);\n        }\n    }\n    \n    <span class=\"hljs-comment\">// 省略其他方法</span>\n}\n</code></pre>\n<p>上面的代码包含了 Dubbo 对同步和异步调用的处理逻辑，搞懂了上面的代码，会对 Dubbo 的同步和异步调用方式有更深入的了解。Dubbo 实现同步和异步调用比较关键的一点就在于由谁调用 ResponseFuture 的 get 方法。同步调用模式下，由框架自身调用 ResponseFuture 的 get 方法。异步调用模式下，则由用户调用该方法。ResponseFuture 是一个接口，下面我们来看一下它的默认实现类 DefaultFuture 的源码。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DefaultFuture</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ResponseFuture</span> </span>{\n    \n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Map&lt;Long, Channel&gt; CHANNELS = \n        <span class=\"hljs-keyword\">new</span> ConcurrentHashMap&lt;Long, Channel&gt;();\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Map&lt;Long, DefaultFuture&gt; FUTURES = \n        <span class=\"hljs-keyword\">new</span> ConcurrentHashMap&lt;Long, DefaultFuture&gt;();\n    \n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">long</span> id;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Channel channel;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Request request;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> timeout;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Lock lock = <span class=\"hljs-keyword\">new</span> ReentrantLock();\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Condition done = lock.newCondition();\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> Response response;\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">DefaultFuture</span><span class=\"hljs-params\">(Channel channel, Request request, <span class=\"hljs-keyword\">int</span> timeout)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.channel = channel;\n        <span class=\"hljs-keyword\">this</span>.request = request;\n        \n        <span class=\"hljs-comment\">// 获取请求 id，这个 id 很重要，后面还会见到</span>\n        <span class=\"hljs-keyword\">this</span>.id = request.getId();\n        <span class=\"hljs-keyword\">this</span>.timeout = timeout &gt; <span class=\"hljs-number\">0</span> ? timeout : channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n        <span class=\"hljs-comment\">// 存储 &lt;requestId, DefaultFuture&gt; 映射关系到 FUTURES 中</span>\n        FUTURES.put(id, <span class=\"hljs-keyword\">this</span>);\n        CHANNELS.put(id, channel);\n    }\n    \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">get</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n        <span class=\"hljs-keyword\">return</span> get(timeout);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> timeout)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n        <span class=\"hljs-keyword\">if</span> (timeout &lt;= <span class=\"hljs-number\">0</span>) {\n            timeout = Constants.DEFAULT_TIMEOUT;\n        }\n        \n        <span class=\"hljs-comment\">// 检测服务提供方是否成功返回了调用结果</span>\n        <span class=\"hljs-keyword\">if</span> (!isDone()) {\n            <span class=\"hljs-keyword\">long</span> start = System.currentTimeMillis();\n            lock.lock();\n            <span class=\"hljs-keyword\">try</span> {\n                <span class=\"hljs-comment\">// 循环检测服务提供方是否成功返回了调用结果</span>\n                <span class=\"hljs-keyword\">while</span> (!isDone()) {\n                    <span class=\"hljs-comment\">// 如果调用结果尚未返回，这里等待一段时间</span>\n                    done.await(timeout, TimeUnit.MILLISECONDS);\n                    <span class=\"hljs-comment\">// 如果调用结果成功返回，或等待超时，此时跳出 while 循环，执行后续的逻辑</span>\n                    <span class=\"hljs-keyword\">if</span> (isDone() || System.currentTimeMillis() - start &gt; timeout) {\n                        <span class=\"hljs-keyword\">break</span>;\n                    }\n                }\n            } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(e);\n            } <span class=\"hljs-keyword\">finally</span> {\n                lock.unlock();\n            }\n            \n            <span class=\"hljs-comment\">// 如果调用结果仍未返回，则抛出超时异常</span>\n            <span class=\"hljs-keyword\">if</span> (!isDone()) {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> TimeoutException(sent &gt; <span class=\"hljs-number\">0</span>, channel, getTimeoutMessage(<span class=\"hljs-keyword\">false</span>));\n            }\n        }\n        \n        <span class=\"hljs-comment\">// 返回调用结果</span>\n        <span class=\"hljs-keyword\">return</span> returnFromResponse();\n    }\n    \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isDone</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// 通过检测 response 字段为空与否，判断是否收到了调用结果</span>\n        <span class=\"hljs-keyword\">return</span> response != <span class=\"hljs-keyword\">null</span>;\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> Object <span class=\"hljs-title\">returnFromResponse</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n        Response res = response;\n        <span class=\"hljs-keyword\">if</span> (res == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"response cannot be null\"</span>);\n        }\n        \n        <span class=\"hljs-comment\">// 如果调用结果的状态为 Response.OK，则表示调用过程正常，服务提供方成功返回了调用结果</span>\n        <span class=\"hljs-keyword\">if</span> (res.getStatus() == Response.OK) {\n            <span class=\"hljs-keyword\">return</span> res.getResult();\n        }\n        \n        <span class=\"hljs-comment\">// 抛出异常</span>\n        <span class=\"hljs-keyword\">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage());\n        }\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RemotingException(channel, res.getErrorMessage());\n    }\n    \n    <span class=\"hljs-comment\">// 省略其他方法</span>\n}\n</code></pre>\n<p>如上，当服务消费者还未接收到调用结果时，用户线程调用 get 方法会被阻塞住。同步调用模式下，框架获得 DefaultFuture 对象后，会立即调用 get 方法进行等待。而异步模式下则是将该对象封装到 FutureAdapter 实例中，并将 FutureAdapter 实例设置到 RpcContext 中，供用户使用。FutureAdapter 是一个适配器，用于将 Dubbo 中的 ResponseFuture 与 JDK 中的 Future 进行适配。这样当用户线程调用 Future 的 get 方法时，经过 FutureAdapter 适配，最终会调用 ResponseFuture 实现类对象的 get 方法，也就是 DefaultFuture 的 get 方法。</p>\n<p>到这里关于 Dubbo 几种调用方式的代码逻辑就分析完了，下面来分析请求数据的发送与接收，以及响应数据的发送与接收过程。</p>\n<h3>2.2 服务消费方发送请求</h3>\n<h4>2.2.1 发送请求</h4>\n<p>本节我们来看一下同步调用模式下，服务消费方是如何发送调用请求的。在深入分析源码前，我们先来看一张图。</p>\n<p><img src=\"sources/images/send-request-thread-stack.jpg\" alt=\"\"></p>\n<p>这张图展示了服务消费方发送请求过程的部分调用栈，略为复杂。从上图可以看出，经过多次调用后，才将请求数据送至 Netty NioClientSocketChannel。这样做的原因是通过 Exchange 层为框架引入 Request 和 Response 语义，这一点会在接下来的源码分析过程中会看到。其他的就不多说了，下面开始进行分析。首先分析 ReferenceCountExchangeClient 的源码。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ReferenceCountExchangeClient</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ExchangeClient</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> URL url;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> AtomicInteger referenceCount = <span class=\"hljs-keyword\">new</span> AtomicInteger(<span class=\"hljs-number\">0</span>);\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ReferenceCountExchangeClient</span><span class=\"hljs-params\">(ExchangeClient client, ConcurrentMap&lt;String, LazyConnectExchangeClient&gt; ghostClientMap)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.client = client;\n        <span class=\"hljs-comment\">// 引用计数自增</span>\n        referenceCount.incrementAndGet();\n        <span class=\"hljs-keyword\">this</span>.url = client.getUrl();\n        \n        <span class=\"hljs-comment\">// ...</span>\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ResponseFuture <span class=\"hljs-title\">request</span><span class=\"hljs-params\">(Object request)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n        <span class=\"hljs-comment\">// 直接调用被装饰对象的同签名方法</span>\n        <span class=\"hljs-keyword\">return</span> client.request(request);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ResponseFuture <span class=\"hljs-title\">request</span><span class=\"hljs-params\">(Object request, <span class=\"hljs-keyword\">int</span> timeout)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n        <span class=\"hljs-comment\">// 直接调用被装饰对象的同签名方法</span>\n        <span class=\"hljs-keyword\">return</span> client.request(request, timeout);\n    }\n\n    <span class=\"hljs-comment\">/** 引用计数自增，该方法由外部调用 */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">incrementAndGetCount</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// referenceCount 自增</span>\n        referenceCount.incrementAndGet();\n    }\n    \n        <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">close</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> timeout)</span> </span>{\n        <span class=\"hljs-comment\">// referenceCount 自减</span>\n        <span class=\"hljs-keyword\">if</span> (referenceCount.decrementAndGet() &lt;= <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">if</span> (timeout == <span class=\"hljs-number\">0</span>) {\n                client.close();\n            } <span class=\"hljs-keyword\">else</span> {\n                client.close(timeout);\n            }\n            client = replaceWithLazyClient();\n        }\n    }\n    \n    <span class=\"hljs-comment\">// 省略部分方法</span>\n}\n</code></pre>\n<p>ReferenceCountExchangeClient 内部定义了一个引用计数变量 referenceCount，每当该对象被引用一次 referenceCount 都会进行自增。每当 close 方法被调用时，referenceCount 进行自减。ReferenceCountExchangeClient 内部仅实现了一个引用计数的功能，其他方法并无复杂逻辑，均是直接调用被装饰对象的相关方法。所以这里就不多说了，继续向下分析，这次是 HeaderExchangeClient。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HeaderExchangeClient</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ExchangeClient</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> ScheduledThreadPoolExecutor scheduled = <span class=\"hljs-keyword\">new</span> ScheduledThreadPoolExecutor(<span class=\"hljs-number\">2</span>, <span class=\"hljs-keyword\">new</span> NamedThreadFactory(<span class=\"hljs-string\">\"dubbo-remoting-client-heartbeat\"</span>, <span class=\"hljs-keyword\">true</span>));\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Client client;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ExchangeChannel channel;\n    <span class=\"hljs-keyword\">private</span> ScheduledFuture&lt;?&gt; heartbeatTimer;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> heartbeat;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> heartbeatTimeout;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">HeaderExchangeClient</span><span class=\"hljs-params\">(Client client, <span class=\"hljs-keyword\">boolean</span> needHeartbeat)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (client == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"client == null\"</span>);\n        }\n        <span class=\"hljs-keyword\">this</span>.client = client;\n        \n        <span class=\"hljs-comment\">// 创建 HeaderExchangeChannel 对象</span>\n        <span class=\"hljs-keyword\">this</span>.channel = <span class=\"hljs-keyword\">new</span> HeaderExchangeChannel(client);\n        \n        <span class=\"hljs-comment\">// 以下代码均与心跳检测逻辑有关</span>\n        String dubbo = client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY);\n        <span class=\"hljs-keyword\">this</span>.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != <span class=\"hljs-keyword\">null</span> &amp;&amp; dubbo.startsWith(<span class=\"hljs-string\">\"1.0.\"</span>) ? Constants.DEFAULT_HEARTBEAT : <span class=\"hljs-number\">0</span>);\n        <span class=\"hljs-keyword\">this</span>.heartbeatTimeout = client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * <span class=\"hljs-number\">3</span>);\n        <span class=\"hljs-keyword\">if</span> (heartbeatTimeout &lt; heartbeat * <span class=\"hljs-number\">2</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"heartbeatTimeout &lt; heartbeatInterval * 2\"</span>);\n        }\n        <span class=\"hljs-keyword\">if</span> (needHeartbeat) {\n            <span class=\"hljs-comment\">// 开启心跳检测定时器</span>\n            startHeartbeatTimer();\n        }\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ResponseFuture <span class=\"hljs-title\">request</span><span class=\"hljs-params\">(Object request)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n        <span class=\"hljs-comment\">// 直接 HeaderExchangeChannel 对象的同签名方法</span>\n        <span class=\"hljs-keyword\">return</span> channel.request(request);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ResponseFuture <span class=\"hljs-title\">request</span><span class=\"hljs-params\">(Object request, <span class=\"hljs-keyword\">int</span> timeout)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n        <span class=\"hljs-comment\">// 直接 HeaderExchangeChannel 对象的同签名方法</span>\n        <span class=\"hljs-keyword\">return</span> channel.request(request, timeout);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">close</span><span class=\"hljs-params\">()</span> </span>{\n        doClose();\n        channel.close();\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doClose</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// 停止心跳检测定时器</span>\n        stopHeartbeatTimer();\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">startHeartbeatTimer</span><span class=\"hljs-params\">()</span> </span>{\n        stopHeartbeatTimer();\n        <span class=\"hljs-keyword\">if</span> (heartbeat &gt; <span class=\"hljs-number\">0</span>) {\n            heartbeatTimer = scheduled.scheduleWithFixedDelay(\n                    <span class=\"hljs-keyword\">new</span> HeartBeatTask(<span class=\"hljs-keyword\">new</span> HeartBeatTask.ChannelProvider() {\n                        <span class=\"hljs-meta\">@Override</span>\n                        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Collection&lt;Channel&gt; <span class=\"hljs-title\">getChannels</span><span class=\"hljs-params\">()</span> </span>{\n                            <span class=\"hljs-keyword\">return</span> Collections.&lt;Channel&gt;singletonList(HeaderExchangeClient.<span class=\"hljs-keyword\">this</span>);\n                        }\n                    }, heartbeat, heartbeatTimeout),\n                    heartbeat, heartbeat, TimeUnit.MILLISECONDS);\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">stopHeartbeatTimer</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (heartbeatTimer != <span class=\"hljs-keyword\">null</span> &amp;&amp; !heartbeatTimer.isCancelled()) {\n            <span class=\"hljs-keyword\">try</span> {\n                heartbeatTimer.cancel(<span class=\"hljs-keyword\">true</span>);\n                scheduled.purge();\n            } <span class=\"hljs-keyword\">catch</span> (Throwable e) {\n                <span class=\"hljs-keyword\">if</span> (logger.isWarnEnabled()) {\n                    logger.warn(e.getMessage(), e);\n                }\n            }\n        }\n        heartbeatTimer = <span class=\"hljs-keyword\">null</span>;\n    }\n    \n    <span class=\"hljs-comment\">// 省略部分方法</span>\n}\n</code></pre>\n<p>HeaderExchangeClient 中很多方法只有一行代码，即调用 HeaderExchangeChannel 对象的同签名方法。那 HeaderExchangeClient 有什么用处呢？答案是封装了一些关于心跳检测的逻辑。心跳检测并非本文所关注的点，因此就不多说了，继续向下看。</p>\n<pre><code class=\"language-java\">final class HeaderExchangeChannel implements ExchangeChannel {\n    \n    private final Channel channel;\n    \n    HeaderExchangeChannel(Channel channel) {\n        if (channel == null) {\n            throw new IllegalArgumentException(\"channel == null\");\n        }\n        \n        // 这里的 channel 指向的是 NettyClient\n        this.channel = channel;\n    }\n    \n    @Override\n    public ResponseFuture request(Object request) throws RemotingException {\n        return request(request, channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));\n    }\n\n    @Override\n    public ResponseFuture request(Object request, int timeout) throws RemotingException {\n        if (closed) {\n            throw new RemotingException(..., \"Failed to send request ...);\n        }\n        // 创建 Request 对象\n        Request req = new Request();\n        req.setVersion(Version.getProtocolVersion());\n        // 设置双向通信标志为 true\n        req.setTwoWay(true);\n        // 这里的 request 变量类型为 RpcInvocation\n        req.setData(request);\n                                        \n        // 创建 DefaultFuture 对象\n        DefaultFuture future = new DefaultFuture(channel, req, timeout);\n        try {\n            // 调用 NettyClient 的 send 方法发送请求\n            channel.send(req);\n        } catch (RemotingException e) {\n            future.cancel();\n            throw e;\n        }\n        // 返回 DefaultFuture 对象\n        return future;\n    }\n}\n</code></pre>\n<p>到这里大家终于看到了 Request 语义了，上面的方法首先定义了一个 Request 对象，然后再将该对象传给 NettyClient 的 send 方法，进行后续的调用。需要说明的是，NettyClient 中并未实现 send 方法，该方法继承自父类 AbstractPeer，下面直接分析 AbstractPeer 的代码。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AbstractPeer</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Endpoint</span>, <span class=\"hljs-title\">ChannelHandler</span> </span>{\n    \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">send</span><span class=\"hljs-params\">(Object message)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n        <span class=\"hljs-comment\">// 该方法由 AbstractClient 类实现</span>\n        send(message, url.getParameter(Constants.SENT_KEY, <span class=\"hljs-keyword\">false</span>));\n    }\n    \n    <span class=\"hljs-comment\">// 省略其他方法</span>\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AbstractClient</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractEndpoint</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Client</span> </span>{\n    \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">send</span><span class=\"hljs-params\">(Object message, <span class=\"hljs-keyword\">boolean</span> sent)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n        <span class=\"hljs-keyword\">if</span> (send_reconnect &amp;&amp; !isConnected()) {\n            connect();\n        }\n        \n        <span class=\"hljs-comment\">// 获取 Channel，getChannel 是一个抽象方法，具体由子类实现</span>\n        Channel channel = getChannel();\n        <span class=\"hljs-keyword\">if</span> (channel == <span class=\"hljs-keyword\">null</span> || !channel.isConnected()) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RemotingException(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-string\">\"message can not send ...\"</span>);\n        }\n        \n        <span class=\"hljs-comment\">// 继续向下调用</span>\n        channel.send(message, sent);\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> Channel <span class=\"hljs-title\">getChannel</span><span class=\"hljs-params\">()</span></span>;\n    \n    <span class=\"hljs-comment\">// 省略其他方法</span>\n}\n</code></pre>\n<p>默认情况下，Dubbo 使用 Netty 作为底层的通信框架，因此下面我们到 NettyClient 类中看一下 getChannel 方法的实现逻辑。</p>\n<pre><code class=\"language-java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NettyClient</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractClient</span> </span>{\n    \n    <span class=\"hljs-comment\">// 这里的 Channel 全限定名称为 org.jboss.netty.channel.Channel</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> Channel channel;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> com.alibaba.dubbo.remoting.<span class=\"hljs-function\">Channel <span class=\"hljs-title\">getChannel</span><span class=\"hljs-params\">()</span> </span>{\n        Channel c = channel;\n        <span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-keyword\">null</span> || !c.isConnected())\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-comment\">// 获取一个 NettyChannel 类型对象</span>\n        <span class=\"hljs-keyword\">return</span> NettyChannel.getOrAddChannel(c, getUrl(), <span class=\"hljs-keyword\">this</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">final</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NettyChannel</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractChannel</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> ConcurrentMap&lt;org.jboss.netty.channel.Channel, NettyChannel&gt; channelMap = \n        <span class=\"hljs-keyword\">new</span> ConcurrentHashMap&lt;org.jboss.netty.channel.Channel, NettyChannel&gt;();\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> org.jboss.netty.channel.Channel channel;\n    \n    <span class=\"hljs-comment\">/** 私有构造方法 */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">NettyChannel</span><span class=\"hljs-params\">(org.jboss.netty.channel.Channel channel, URL url, ChannelHandler handler)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(url, handler);\n        <span class=\"hljs-keyword\">if</span> (channel == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"netty channel == null;\"</span>);\n        }\n        <span class=\"hljs-keyword\">this</span>.channel = channel;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> NettyChannel <span class=\"hljs-title\">getOrAddChannel</span><span class=\"hljs-params\">(org.jboss.netty.channel.Channel ch, URL url, ChannelHandler handler)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (ch == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n        }\n        \n        <span class=\"hljs-comment\">// 尝试从集合中获取 NettyChannel 实例</span>\n        NettyChannel ret = channelMap.get(ch);\n        <span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-comment\">// 如果 ret = null，则创建一个新的 NettyChannel 实例</span>\n            NettyChannel nc = <span class=\"hljs-keyword\">new</span> NettyChannel(ch, url, handler);\n            <span class=\"hljs-keyword\">if</span> (ch.isConnected()) {\n                <span class=\"hljs-comment\">// 将 &lt;Channel, NettyChannel&gt; 键值对存入 channelMap 集合中</span>\n                ret = channelMap.putIfAbsent(ch, nc);\n            }\n            <span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-keyword\">null</span>) {\n                ret = nc;\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> ret;\n    }\n}\n</code></pre>\n<p>获取到 NettyChannel 实例后，即可进行后续的调用。下面看一下 NettyChannel 的 send 方法。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">send</span><span class=\"hljs-params\">(Object message, <span class=\"hljs-keyword\">boolean</span> sent)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n    <span class=\"hljs-keyword\">super</span>.send(message, sent);\n\n    <span class=\"hljs-keyword\">boolean</span> success = <span class=\"hljs-keyword\">true</span>;\n    <span class=\"hljs-keyword\">int</span> timeout = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-comment\">// 发送消息(包含请求和响应消息)</span>\n        ChannelFuture future = channel.write(message);\n        \n        <span class=\"hljs-comment\">// sent 的值源于 &lt;dubbo:method sent=\"true/false\" /&gt; 中 sent 的配置值，有两种配置值：</span>\n        <span class=\"hljs-comment\">//   1. true: 等待消息发出，消息发送失败将抛出异常</span>\n        <span class=\"hljs-comment\">//   2. false: 不等待消息发出，将消息放入 IO 队列，即刻返回</span>\n        <span class=\"hljs-comment\">// 默认情况下 sent = false；</span>\n        <span class=\"hljs-keyword\">if</span> (sent) {\n            timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n            <span class=\"hljs-comment\">// 等待消息发出，若在规定时间没能发出，success 会被置为 false</span>\n            success = future.await(timeout);\n        }\n        Throwable cause = future.getCause();\n        <span class=\"hljs-keyword\">if</span> (cause != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> cause;\n        }\n    } <span class=\"hljs-keyword\">catch</span> (Throwable e) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RemotingException(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-string\">\"Failed to send message ...\"</span>);\n    }\n\n    <span class=\"hljs-comment\">// 若 success 为 false，这里抛出异常</span>\n    <span class=\"hljs-keyword\">if</span> (!success) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RemotingException(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-string\">\"Failed to send message ...\"</span>);\n    }\n}\n</code></pre>\n<p>经历多次调用，到这里请求数据的发送过程就结束了，过程漫长。为了便于大家阅读代码，这里以 DemoService 为例，将 sayHello 方法的整个调用路径贴出来。</p>\n<pre><code>proxy0#sayHello(String)\n  —&gt; InvokerInvocationHandler#invoke(Object, Method, Object[])\n    —&gt; MockClusterInvoker#invoke(Invocation)\n      —&gt; AbstractClusterInvoker#invoke(Invocation)\n        —&gt; FailoverClusterInvoker#doInvoke(Invocation, List&lt;Invoker&lt;T&gt;&gt;, LoadBalance)\n          —&gt; Filter#invoke(Invoker, Invocation)  // 包含多个 Filter 调用\n            —&gt; ListenerInvokerWrapper#invoke(Invocation) \n              —&gt; AbstractInvoker#invoke(Invocation) \n                —&gt; DubboInvoker#doInvoke(Invocation)\n                  —&gt; ReferenceCountExchangeClient#request(Object, int)\n                    —&gt; HeaderExchangeClient#request(Object, int)\n                      —&gt; HeaderExchangeChannel#request(Object, int)\n                        —&gt; AbstractPeer#send(Object)\n                          —&gt; AbstractClient#send(Object, boolean)\n                            —&gt; NettyChannel#send(Object, boolean)\n                              —&gt; NioClientSocketChannel#write(Object)\n</code></pre>\n<p>在 Netty 中，出站数据在发出之前还需要进行编码操作，接下来我们来分析一下请求数据的编码逻辑。</p>\n<h4>2.2.2 请求编码</h4>\n<p>在分析请求编码逻辑之前，我们先来看一下 Dubbo 数据包结构。</p>\n<p><img src=\"sources/images/data-format.jpg\" alt=\"\"></p>\n<p>Dubbo 数据包分为消息头和消息体，消息头用于存储一些元信息，比如魔数（Magic），数据包类型（Request/Response），消息体长度（Data Length）等。消息体中用于存储具体的调用消息，比如方法名称，参数列表等。下面简单列举一下消息头的内容。</p>\n<table>\n<thead>\n<tr>\n<th>偏移量(Bit)</th>\n<th>字段</th>\n<th>取值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0 ~ 7</td>\n<td>魔数高位</td>\n<td>0xda00</td>\n</tr>\n<tr>\n<td>8 ~ 15</td>\n<td>魔数低位</td>\n<td>0xbb</td>\n</tr>\n<tr>\n<td>16</td>\n<td>数据包类型</td>\n<td>0 - Response, 1 - Request</td>\n</tr>\n<tr>\n<td>17</td>\n<td>调用方式</td>\n<td>仅在第16位被设为1的情况下有效，0 - 单向调用，1 - 双向调用</td>\n</tr>\n<tr>\n<td>18</td>\n<td>事件标识</td>\n<td>0 - 当前数据包是请求或响应包，1 - 当前数据包是心跳包</td>\n</tr>\n<tr>\n<td>19 ~ 23</td>\n<td>序列化器编号</td>\n<td>2 - Hessian2Serialization<br>3 - JavaSerialization<br/>4 - CompactedJavaSerialization<br/>6 - FastJsonSerialization<br/>7 - NativeJavaSerialization<br/>8 - KryoSerialization<br/>9 - FstSerialization</td>\n</tr>\n<tr>\n<td>24 ~ 31</td>\n<td>状态</td>\n<td>20 - OK<br/>30 - CLIENT_TIMEOUT<br/>31 - SERVER_TIMEOUT<br/>40 - BAD_REQUEST<br/>50 - BAD_RESPONSE<br/>......</td>\n</tr>\n<tr>\n<td>32 ~ 95</td>\n<td>请求编号</td>\n<td>共8字节，运行时生成</td>\n</tr>\n<tr>\n<td>96 ~ 127</td>\n<td>消息体长度</td>\n<td>运行时计算</td>\n</tr>\n</tbody>\n</table>\n<p>了解了 Dubbo 数据包格式，接下来我们就可以探索编码过程了。这次我们开门见山，直接分析编码逻辑所在类。如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ExchangeCodec</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">TelnetCodec</span> </span>{\n\n    <span class=\"hljs-comment\">// 消息头长度</span>\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> HEADER_LENGTH = <span class=\"hljs-number\">16</span>;\n    <span class=\"hljs-comment\">// 魔数内容</span>\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">short</span> MAGIC = (<span class=\"hljs-keyword\">short</span>) <span class=\"hljs-number\">0xdabb</span>;\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">byte</span> MAGIC_HIGH = Bytes.short2bytes(MAGIC)[<span class=\"hljs-number\">0</span>];\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">byte</span> MAGIC_LOW = Bytes.short2bytes(MAGIC)[<span class=\"hljs-number\">1</span>];\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">byte</span> FLAG_REQUEST = (<span class=\"hljs-keyword\">byte</span>) <span class=\"hljs-number\">0x80</span>;\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">byte</span> FLAG_TWOWAY = (<span class=\"hljs-keyword\">byte</span>) <span class=\"hljs-number\">0x40</span>;\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">byte</span> FLAG_EVENT = (<span class=\"hljs-keyword\">byte</span>) <span class=\"hljs-number\">0x20</span>;\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> SERIALIZATION_MASK = <span class=\"hljs-number\">0x1f</span>;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Logger logger = LoggerFactory.getLogger(ExchangeCodec.class);\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Short <span class=\"hljs-title\">getMagicCode</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> MAGIC;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">encode</span><span class=\"hljs-params\">(Channel channel, ChannelBuffer buffer, Object msg)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        <span class=\"hljs-keyword\">if</span> (msg <span class=\"hljs-keyword\">instanceof</span> Request) {\n            <span class=\"hljs-comment\">// 对 Request 对象进行编码</span>\n            encodeRequest(channel, buffer, (Request) msg);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (msg <span class=\"hljs-keyword\">instanceof</span> Response) {\n            <span class=\"hljs-comment\">// 对 Response 对象进行编码，后面分析</span>\n            encodeResponse(channel, buffer, (Response) msg);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">super</span>.encode(channel, buffer, msg);\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">encodeRequest</span><span class=\"hljs-params\">(Channel channel, ChannelBuffer buffer, Request req)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        Serialization serialization = getSerialization(channel);\n\n        <span class=\"hljs-comment\">// 创建消息头字节数组，长度为 16</span>\n        <span class=\"hljs-keyword\">byte</span>[] header = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">byte</span>[HEADER_LENGTH];\n\n        <span class=\"hljs-comment\">// 设置魔数</span>\n        Bytes.short2bytes(MAGIC, header);\n\n        <span class=\"hljs-comment\">// 设置数据包类型（Request/Response）和序列化器编号</span>\n        header[<span class=\"hljs-number\">2</span>] = (<span class=\"hljs-keyword\">byte</span>) (FLAG_REQUEST | serialization.getContentTypeId());\n\n        <span class=\"hljs-comment\">// 设置通信方式(单向/双向)</span>\n        <span class=\"hljs-keyword\">if</span> (req.isTwoWay()) {\n            header[<span class=\"hljs-number\">2</span>] |= FLAG_TWOWAY;\n        }\n        \n        <span class=\"hljs-comment\">// 设置事件标识</span>\n        <span class=\"hljs-keyword\">if</span> (req.isEvent()) {\n            header[<span class=\"hljs-number\">2</span>] |= FLAG_EVENT;\n        }\n\n        <span class=\"hljs-comment\">// 设置请求编号，8个字节，从第4个字节开始设置</span>\n        Bytes.long2bytes(req.getId(), header, <span class=\"hljs-number\">4</span>);\n\n        <span class=\"hljs-comment\">// 获取 buffer 当前的写位置</span>\n        <span class=\"hljs-keyword\">int</span> savedWriteIndex = buffer.writerIndex();\n        <span class=\"hljs-comment\">// 更新 writerIndex，为消息头预留 16 个字节的空间</span>\n        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);\n        ChannelBufferOutputStream bos = <span class=\"hljs-keyword\">new</span> ChannelBufferOutputStream(buffer);\n        <span class=\"hljs-comment\">// 创建序列化器，比如 Hessian2ObjectOutput</span>\n        ObjectOutput out = serialization.serialize(channel.getUrl(), bos);\n        <span class=\"hljs-keyword\">if</span> (req.isEvent()) {\n            <span class=\"hljs-comment\">// 对事件数据进行序列化操作</span>\n            encodeEventData(channel, out, req.getData());\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// 对请求数据进行序列化操作</span>\n            encodeRequestData(channel, out, req.getData(), req.getVersion());\n        }\n        out.flushBuffer();\n        <span class=\"hljs-keyword\">if</span> (out <span class=\"hljs-keyword\">instanceof</span> Cleanable) {\n            ((Cleanable) out).cleanup();\n        }\n        bos.flush();\n        bos.close();\n        \n        <span class=\"hljs-comment\">// 获取写入的字节数，也就是消息体长度</span>\n        <span class=\"hljs-keyword\">int</span> len = bos.writtenBytes();\n        checkPayload(channel, len);\n\n        <span class=\"hljs-comment\">// 将消息体长度写入到消息头中</span>\n        Bytes.int2bytes(len, header, <span class=\"hljs-number\">12</span>);\n\n        <span class=\"hljs-comment\">// 将 buffer 指针移动到 savedWriteIndex，为写消息头做准备</span>\n        buffer.writerIndex(savedWriteIndex);\n        <span class=\"hljs-comment\">// 从 savedWriteIndex 下标处写入消息头</span>\n        buffer.writeBytes(header);\n        <span class=\"hljs-comment\">// 设置新的 writerIndex，writerIndex = 原写下标 + 消息头长度 + 消息体长度</span>\n        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);\n    }\n    \n    <span class=\"hljs-comment\">// 省略其他方法</span>\n}\n</code></pre>\n<p>以上就是请求对象的编码过程，该过程首先会通过位运算将消息头写入到 header 数组中。然后对 Request 对象的 data 字段执行序列化操作，序列化后的数据最终会存储到 ChannelBuffer 中。序列化操作执行完后，可得到数据序列化后的长度 len，紧接着将 len 写入到 header 指定位置处。最后再将消息头字节数组 header 写入到 ChannelBuffer 中，整个编码过程就结束了。本节的最后，我们再来看一下 Request 对象的 data 字段序列化过程，也就是 encodeRequestData 方法的逻辑，如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DubboCodec</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ExchangeCodec</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Codec2</span> </span>{\n    \n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">encodeRequestData</span><span class=\"hljs-params\">(Channel channel, ObjectOutput out, Object data, String version)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        RpcInvocation inv = (RpcInvocation) data;\n\n        <span class=\"hljs-comment\">// 依次序列化 dubbo version、path、version</span>\n        out.writeUTF(version);\n        out.writeUTF(inv.getAttachment(Constants.PATH_KEY));\n        out.writeUTF(inv.getAttachment(Constants.VERSION_KEY));\n\n        <span class=\"hljs-comment\">// 序列化调用方法名</span>\n        out.writeUTF(inv.getMethodName());\n        <span class=\"hljs-comment\">// 将参数类型转换为字符串，并进行序列化</span>\n        out.writeUTF(ReflectUtils.getDesc(inv.getParameterTypes()));\n        Object[] args = inv.getArguments();\n        <span class=\"hljs-keyword\">if</span> (args != <span class=\"hljs-keyword\">null</span>)\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; args.length; i++) {\n                <span class=\"hljs-comment\">// 对运行时参数进行序列化</span>\n                out.writeObject(encodeInvocationArgument(channel, inv, i));\n            }\n        \n        <span class=\"hljs-comment\">// 序列化 attachments</span>\n        out.writeObject(inv.getAttachments());\n    }\n}\n</code></pre>\n<p>至此，关于服务消费方发送请求的过程就分析完了，接下来我们来看一下服务提供方是如何接收请求的。</p>\n<h3>2.3 服务提供方接收请求</h3>\n<p>前面说过，默认情况下 Dubbo 使用 Netty 作为底层的通信框架。Netty 检测到有数据入站后，首先会通过解码器对数据进行解码，并将解码后的数据传递给下一个入站处理器的指定方法。所以在进行后续的分析之前，我们先来看一下数据解码过程。</p>\n<h4>2.3.1 请求解码</h4>\n<p>这里直接分析请求数据的解码逻辑，忽略中间过程，如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ExchangeCodec</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">TelnetCodec</span> </span>{\n    \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">decode</span><span class=\"hljs-params\">(Channel channel, ChannelBuffer buffer)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        <span class=\"hljs-keyword\">int</span> readable = buffer.readableBytes();\n        <span class=\"hljs-comment\">// 创建消息头字节数组</span>\n        <span class=\"hljs-keyword\">byte</span>[] header = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">byte</span>[Math.min(readable, HEADER_LENGTH)];\n        <span class=\"hljs-comment\">// 读取消息头数据</span>\n        buffer.readBytes(header);\n        <span class=\"hljs-comment\">// 调用重载方法进行后续解码工作</span>\n        <span class=\"hljs-keyword\">return</span> decode(channel, buffer, readable, header);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title\">decode</span><span class=\"hljs-params\">(Channel channel, ChannelBuffer buffer, <span class=\"hljs-keyword\">int</span> readable, <span class=\"hljs-keyword\">byte</span>[] header)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        <span class=\"hljs-comment\">// 检查魔数是否相等</span>\n        <span class=\"hljs-keyword\">if</span> (readable &gt; <span class=\"hljs-number\">0</span> &amp;&amp; header[<span class=\"hljs-number\">0</span>] != MAGIC_HIGH\n                || readable &gt; <span class=\"hljs-number\">1</span> &amp;&amp; header[<span class=\"hljs-number\">1</span>] != MAGIC_LOW) {\n            <span class=\"hljs-keyword\">int</span> length = header.length;\n            <span class=\"hljs-keyword\">if</span> (header.length &lt; readable) {\n                header = Bytes.copyOf(header, readable);\n                buffer.readBytes(header, length, readable - length);\n            }\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; header.length - <span class=\"hljs-number\">1</span>; i++) {\n                <span class=\"hljs-keyword\">if</span> (header[i] == MAGIC_HIGH &amp;&amp; header[i + <span class=\"hljs-number\">1</span>] == MAGIC_LOW) {\n                    buffer.readerIndex(buffer.readerIndex() - header.length + i);\n                    header = Bytes.copyOf(header, i);\n                    <span class=\"hljs-keyword\">break</span>;\n                }\n            }\n            <span class=\"hljs-comment\">// 通过 telnet 命令行发送的数据包不包含消息头，所以这里</span>\n            <span class=\"hljs-comment\">// 调用 TelnetCodec 的 decode 方法对数据包进行解码</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">super</span>.decode(channel, buffer, readable, header);\n        }\n        \n        <span class=\"hljs-comment\">// 检测可读数据量是否少于消息头长度，若小于则立即返回 DecodeResult.NEED_MORE_INPUT</span>\n        <span class=\"hljs-keyword\">if</span> (readable &lt; HEADER_LENGTH) {\n            <span class=\"hljs-keyword\">return</span> DecodeResult.NEED_MORE_INPUT;\n        }\n\n        <span class=\"hljs-comment\">// 从消息头中获取消息体长度</span>\n        <span class=\"hljs-keyword\">int</span> len = Bytes.bytes2int(header, <span class=\"hljs-number\">12</span>);\n        <span class=\"hljs-comment\">// 检测消息体长度是否超出限制，超出则抛出异常</span>\n        checkPayload(channel, len);\n\n        <span class=\"hljs-keyword\">int</span> tt = len + HEADER_LENGTH;\n        <span class=\"hljs-comment\">// 检测可读的字节数是否小于实际的字节数</span>\n        <span class=\"hljs-keyword\">if</span> (readable &lt; tt) {\n            <span class=\"hljs-keyword\">return</span> DecodeResult.NEED_MORE_INPUT;\n        }\n        \n        ChannelBufferInputStream is = <span class=\"hljs-keyword\">new</span> ChannelBufferInputStream(buffer, len);\n\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 继续进行解码工作</span>\n            <span class=\"hljs-keyword\">return</span> decodeBody(channel, is, header);\n        } <span class=\"hljs-keyword\">finally</span> {\n            <span class=\"hljs-keyword\">if</span> (is.available() &gt; <span class=\"hljs-number\">0</span>) {\n                <span class=\"hljs-keyword\">try</span> {\n                    StreamUtils.skipUnusedStream(is);\n                } <span class=\"hljs-keyword\">catch</span> (IOException e) {\n                    logger.warn(e.getMessage(), e);\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p>上面方法通过检测消息头中的魔数是否与规定的魔数相等，提前拦截掉非常规数据包，比如通过 telnet 命令行发出的数据包。接着再对消息体长度，以及可读字节数进行检测。最后调用 decodeBody 方法进行后续的解码工作，ExchangeCodec 中实现了 decodeBody 方法，但因其子类 DubboCodec 覆写了该方法，所以在运行时 DubboCodec 中的 decodeBody 方法会被调用。下面我们来看一下该方法的代码。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DubboCodec</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ExchangeCodec</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Codec2</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title\">decodeBody</span><span class=\"hljs-params\">(Channel channel, InputStream is, <span class=\"hljs-keyword\">byte</span>[] header)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        <span class=\"hljs-comment\">// 获取消息头中的第三个字节，并通过逻辑与运算得到序列化器编号</span>\n        <span class=\"hljs-keyword\">byte</span> flag = header[<span class=\"hljs-number\">2</span>], proto = (<span class=\"hljs-keyword\">byte</span>) (flag &amp; SERIALIZATION_MASK);\n        Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);\n        <span class=\"hljs-comment\">// 获取调用编号</span>\n        <span class=\"hljs-keyword\">long</span> id = Bytes.bytes2long(header, <span class=\"hljs-number\">4</span>);\n        <span class=\"hljs-comment\">// 通过逻辑与运算得到调用类型，0 - Response，1 - Request</span>\n        <span class=\"hljs-keyword\">if</span> ((flag &amp; FLAG_REQUEST) == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-comment\">// 对响应结果进行解码，得到 Response 对象。这个非本节内容，后面再分析</span>\n            <span class=\"hljs-comment\">// ...</span>\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// 创建 Request 对象</span>\n            Request req = <span class=\"hljs-keyword\">new</span> Request(id);\n            req.setVersion(Version.getProtocolVersion());\n            <span class=\"hljs-comment\">// 通过逻辑与运算得到通信方式，并设置到 Request 对象中</span>\n            req.setTwoWay((flag &amp; FLAG_TWOWAY) != <span class=\"hljs-number\">0</span>);\n            \n            <span class=\"hljs-comment\">// 通过位运算检测数据包是否为事件类型</span>\n            <span class=\"hljs-keyword\">if</span> ((flag &amp; FLAG_EVENT) != <span class=\"hljs-number\">0</span>) {\n                <span class=\"hljs-comment\">// 设置心跳事件到 Request 对象中</span>\n                req.setEvent(Request.HEARTBEAT_EVENT);\n            }\n            <span class=\"hljs-keyword\">try</span> {\n                Object data;\n                <span class=\"hljs-keyword\">if</span> (req.isHeartbeat()) {\n                    <span class=\"hljs-comment\">// 对心跳包进行解码，该方法已被标注为废弃</span>\n                    data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (req.isEvent()) {\n                    <span class=\"hljs-comment\">// 对事件数据进行解码</span>\n                    data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));\n                } <span class=\"hljs-keyword\">else</span> {\n                    DecodeableRpcInvocation inv;\n                    <span class=\"hljs-comment\">// 根据 url 参数判断是否在 IO 线程上对消息体进行解码</span>\n                    <span class=\"hljs-keyword\">if</span> (channel.getUrl().getParameter(\n                            Constants.DECODE_IN_IO_THREAD_KEY,\n                            Constants.DEFAULT_DECODE_IN_IO_THREAD)) {\n                        inv = <span class=\"hljs-keyword\">new</span> DecodeableRpcInvocation(channel, req, is, proto);\n                        <span class=\"hljs-comment\">// 在当前线程，也就是 IO 线程上进行后续的解码工作。此工作完成后，可将</span>\n                        <span class=\"hljs-comment\">// 调用方法名、attachment、以及调用参数解析出来</span>\n                        inv.decode();\n                    } <span class=\"hljs-keyword\">else</span> {\n                        <span class=\"hljs-comment\">// 仅创建 DecodeableRpcInvocation 对象，但不在当前线程上执行解码逻辑</span>\n                        inv = <span class=\"hljs-keyword\">new</span> DecodeableRpcInvocation(channel, req,\n                                <span class=\"hljs-keyword\">new</span> UnsafeByteArrayInputStream(readMessageData(is)), proto);\n                    }\n                    data = inv;\n                }\n                \n                <span class=\"hljs-comment\">// 设置 data 到 Request 对象中</span>\n                req.setData(data);\n            } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n                <span class=\"hljs-comment\">// 若解码过程中出现异常，则将 broken 字段设为 true，</span>\n                <span class=\"hljs-comment\">// 并将异常对象设置到 Reqeust 对象中</span>\n                req.setBroken(<span class=\"hljs-keyword\">true</span>);\n                req.setData(t);\n            }\n            <span class=\"hljs-keyword\">return</span> req;\n        }\n    }\n}\n</code></pre>\n<p>如上，decodeBody 对部分字段进行了解码，并将解码得到的字段封装到 Request 中。随后会调用 DecodeableRpcInvocation 的 decode 方法进行后续的解码工作。此工作完成后，可将调用方法名、attachment、以及调用参数解析出来。下面我们来看一下 DecodeableRpcInvocation 的 decode 方法逻辑。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DecodeableRpcInvocation</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">RpcInvocation</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Codec</span>, <span class=\"hljs-title\">Decodeable</span> </span>{\n    \n\t<span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">decode</span><span class=\"hljs-params\">(Channel channel, InputStream input)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)\n                .deserialize(channel.getUrl(), input);\n\n        <span class=\"hljs-comment\">// 通过反序列化得到 dubbo version，并保存到 attachments 变量中</span>\n        String dubboVersion = in.readUTF();\n        request.setVersion(dubboVersion);\n        setAttachment(Constants.DUBBO_VERSION_KEY, dubboVersion);\n\n        <span class=\"hljs-comment\">// 通过反序列化得到 path，version，并保存到 attachments 变量中</span>\n        setAttachment(Constants.PATH_KEY, in.readUTF());\n        setAttachment(Constants.VERSION_KEY, in.readUTF());\n\n        <span class=\"hljs-comment\">// 通过反序列化得到调用方法名</span>\n        setMethodName(in.readUTF());\n        <span class=\"hljs-keyword\">try</span> {\n            Object[] args;\n            Class&lt;?&gt;[] pts;\n            <span class=\"hljs-comment\">// 通过反序列化得到参数类型字符串，比如 Ljava/lang/String;</span>\n            String desc = in.readUTF();\n            <span class=\"hljs-keyword\">if</span> (desc.length() == <span class=\"hljs-number\">0</span>) {\n                pts = DubboCodec.EMPTY_CLASS_ARRAY;\n                args = DubboCodec.EMPTY_OBJECT_ARRAY;\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-comment\">// 将 desc 解析为参数类型数组</span>\n                pts = ReflectUtils.desc2classArray(desc);\n                args = <span class=\"hljs-keyword\">new</span> Object[pts.length];\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; args.length; i++) {\n                    <span class=\"hljs-keyword\">try</span> {\n                        <span class=\"hljs-comment\">// 解析运行时参数</span>\n                        args[i] = in.readObject(pts[i]);\n                    } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n                        <span class=\"hljs-keyword\">if</span> (log.isWarnEnabled()) {\n                            log.warn(<span class=\"hljs-string\">\"Decode argument failed: \"</span> + e.getMessage(), e);\n                        }\n                    }\n                }\n            }\n            \n            <span class=\"hljs-comment\">// 设置参数类型数组</span>\n            setParameterTypes(pts);\n\n            <span class=\"hljs-comment\">// 通过反序列化得到原 attachment 的内容</span>\n            Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) in.readObject(Map.class);\n            <span class=\"hljs-keyword\">if</span> (map != <span class=\"hljs-keyword\">null</span> &amp;&amp; map.size() &gt; <span class=\"hljs-number\">0</span>) {\n                Map&lt;String, String&gt; attachment = getAttachments();\n                <span class=\"hljs-keyword\">if</span> (attachment == <span class=\"hljs-keyword\">null</span>) {\n                    attachment = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, String&gt;();\n                }\n                <span class=\"hljs-comment\">// 将 map 与当前对象中的 attachment 集合进行融合</span>\n                attachment.putAll(map);\n                setAttachments(attachment);\n            }\n            \n            <span class=\"hljs-comment\">// 对 callback 类型的参数进行处理</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; args.length; i++) {\n                args[i] = decodeInvocationArgument(channel, <span class=\"hljs-keyword\">this</span>, pts, i, args[i]);\n            }\n\n            <span class=\"hljs-comment\">// 设置参数列表</span>\n            setArguments(args);\n\n        } <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException e) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IOException(StringUtils.toString(<span class=\"hljs-string\">\"Read invocation data failed.\"</span>, e));\n        } <span class=\"hljs-keyword\">finally</span> {\n            <span class=\"hljs-keyword\">if</span> (in <span class=\"hljs-keyword\">instanceof</span> Cleanable) {\n                ((Cleanable) in).cleanup();\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n    }\n}\n</code></pre>\n<p>上面的方法通过反序列化将诸如 path、version、调用方法名、参数列表等信息依次解析出来，并设置到相应的字段中，最终得到一个具有完整调用信息的 DecodeableRpcInvocation 对象。</p>\n<p>到这里，请求数据解码的过程就分析完了。此时我们得到了一个 Request 对象，这个对象会被传送到下一个入站处理器中，我们继续往下看。</p>\n<h4>2.3.2 调用服务</h4>\n<p>解码器将数据包解析成 Request 对象后，NettyHandler 的 messageReceived 方法紧接着会收到这个对象，并将这个对象继续向下传递。这期间该对象会被依次传递给 NettyServer、MultiMessageHandler、HeartbeatHandler 以及 AllChannelHandler。最后由 AllChannelHandler 将该对象封装到 Runnable 实现类对象中，并将 Runnable 放入线程池中执行后续的调用逻辑。整个调用栈如下：</p>\n<pre><code>NettyHandler#messageReceived(ChannelHandlerContext, MessageEvent)\n  —&gt; AbstractPeer#received(Channel, Object)\n    —&gt; MultiMessageHandler#received(Channel, Object)\n      —&gt; HeartbeatHandler#received(Channel, Object)\n        —&gt; AllChannelHandler#received(Channel, Object)\n          —&gt; ExecutorService#execute(Runnable)    // 由线程池执行后续的调用逻辑\n</code></pre>\n<p>考虑到篇幅，以及很多中间调用的逻辑并非十分重要，所以这里就不对调用栈中的每个方法都进行分析了。这里我们直接分析调用栈中的分析第一个和最后一个调用方法逻辑。如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Sharable</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NettyHandler</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">SimpleChannelHandler</span> </span>{\n    \n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Map&lt;String, Channel&gt; channels = <span class=\"hljs-keyword\">new</span> ConcurrentHashMap&lt;String, Channel&gt;();\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> URL url;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ChannelHandler handler;\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">NettyHandler</span><span class=\"hljs-params\">(URL url, ChannelHandler handler)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (url == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"url == null\"</span>);\n        }\n        <span class=\"hljs-keyword\">if</span> (handler == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"handler == null\"</span>);\n        }\n        <span class=\"hljs-keyword\">this</span>.url = url;\n        \n        <span class=\"hljs-comment\">// 这里的 handler 类型为 NettyServer</span>\n        <span class=\"hljs-keyword\">this</span>.handler = handler;\n    }\n    \n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">messageReceived</span><span class=\"hljs-params\">(ChannelHandlerContext ctx, MessageEvent e)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        <span class=\"hljs-comment\">// 获取 NettyChannel</span>\n        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.getChannel(), url, handler);\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 继续向下调用</span>\n            handler.received(channel, e.getMessage());\n        } <span class=\"hljs-keyword\">finally</span> {\n            NettyChannel.removeChannelIfDisconnected(ctx.getChannel());\n        }\n    }\n}\n</code></pre>\n<p>如上，NettyHandler 中的 messageReceived 逻辑比较简单。首先根据一些信息获取 NettyChannel 实例，然后将 NettyChannel 实例以及 Request 对象向下传递。下面再来看看 AllChannelHandler 的逻辑，在详细分析代码之前，我们先来了解一下 Dubbo 中的线程派发模型。</p>\n<h5>2.3.2.1 线程派发模型</h5>\n<p>Dubbo 将底层通信框架中接收请求的线程称为 IO 线程。如果一些事件处理逻辑可以很快执行完，比如只在内存打一个标记，此时直接在 IO 线程上执行该段逻辑即可。但如果事件的处理逻辑比较耗时，比如该段逻辑会发起数据库查询或者 HTTP 请求。此时我们就不应该让事件处理逻辑在 IO 线程上执行，而是应该派发到线程池中去执行。原因也很简单，IO 线程主要用于接收请求，如果 IO 线程被占满，将导致它不能接收新的请求。</p>\n<p>以上就是线程派发的背景，下面我们再来通过 Dubbo 调用图，看一下线程派发器所处的位置。</p>\n<p><img src=\"sources/images/dispatcher-location.jpg\" alt=\"\"></p>\n<p>如上图，红框中的 Dispatcher 就是线程派发器。需要说明的是，Dispatcher 真实的职责创建具有线程派发能力的 ChannelHandler，比如 AllChannelHandler、MessageOnlyChannelHandler 和 ExecutionChannelHandler 等，其本身并不具备线程派发能力。Dubbo 支持 5 种不同的线程派发策略，下面通过一个表格列举一下。</p>\n<table>\n<thead>\n<tr>\n<th>策略</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>all</td>\n<td>所有消息都派发到线程池，包括请求，响应，连接事件，断开事件等</td>\n</tr>\n<tr>\n<td>direct</td>\n<td>所有消息都不派发到线程池，全部在 IO 线程上直接执行</td>\n</tr>\n<tr>\n<td>message</td>\n<td>只有<strong>请求</strong>和<strong>响应</strong>消息派发到线程池，其它消息均在 IO 线程上执行</td>\n</tr>\n<tr>\n<td>execution</td>\n<td>只有<strong>请求</strong>消息派发到线程池，不含响应。其它消息均在 IO 线程上执行</td>\n</tr>\n<tr>\n<td>connection</td>\n<td>在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池</td>\n</tr>\n</tbody>\n</table>\n<p>默认配置下，Dubbo 使用 <code>all</code> 派发策略，即将所有的消息都派发到线程池中。下面我们来分析一下 AllChannelHandler 的代码。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AllChannelHandler</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">WrappedChannelHandler</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">AllChannelHandler</span><span class=\"hljs-params\">(ChannelHandler handler, URL url)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(handler, url);\n    }\n\n    <span class=\"hljs-comment\">/** 处理连接事件 */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">connected</span><span class=\"hljs-params\">(Channel channel)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n        <span class=\"hljs-comment\">// 获取线程池</span>\n        ExecutorService cexecutor = getExecutorService();\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 将连接事件派发到线程池中处理</span>\n            cexecutor.execute(<span class=\"hljs-keyword\">new</span> ChannelEventRunnable(channel, handler, ChannelState.CONNECTED));\n        } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ExecutionException(..., <span class=\"hljs-string\">\" error when process connected event .\"</span>, t);\n        }\n    }\n\n    <span class=\"hljs-comment\">/** 处理断开事件 */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">disconnected</span><span class=\"hljs-params\">(Channel channel)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n        ExecutorService cexecutor = getExecutorService();\n        <span class=\"hljs-keyword\">try</span> {\n            cexecutor.execute(<span class=\"hljs-keyword\">new</span> ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED));\n        } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ExecutionException(..., <span class=\"hljs-string\">\"error when process disconnected event .\"</span>, t);\n        }\n    }\n\n    <span class=\"hljs-comment\">/** 处理请求和响应消息，这里的 message 变量类型可能是 Request，也可能是 Response */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">received</span><span class=\"hljs-params\">(Channel channel, Object message)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n        ExecutorService cexecutor = getExecutorService();\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 将请求和响应消息派发到线程池中处理</span>\n            cexecutor.execute(<span class=\"hljs-keyword\">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));\n        } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n            <span class=\"hljs-keyword\">if</span>(message <span class=\"hljs-keyword\">instanceof</span> Request &amp;&amp; t <span class=\"hljs-keyword\">instanceof</span> RejectedExecutionException){\n                Request request = (Request)message;\n                <span class=\"hljs-comment\">// 如果通信方式为双向通信，此时将 Server side ... threadpool is exhausted </span>\n                <span class=\"hljs-comment\">// 错误信息封装到 Response 中，并返回给服务消费方。</span>\n                <span class=\"hljs-keyword\">if</span>(request.isTwoWay()){\n                    String msg = <span class=\"hljs-string\">\"Server side(\"</span> + url.getIp() + <span class=\"hljs-string\">\",\"</span> + url.getPort() \n                        + <span class=\"hljs-string\">\") threadpool is exhausted ,detail msg:\"</span> + t.getMessage();\n                    Response response = <span class=\"hljs-keyword\">new</span> Response(request.getId(), request.getVersion());\n                    response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR);\n                    response.setErrorMessage(msg);\n                    <span class=\"hljs-comment\">// 返回包含错误信息的 Response 对象</span>\n                    channel.send(response);\n                    <span class=\"hljs-keyword\">return</span>;\n                }\n            }\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ExecutionException(..., <span class=\"hljs-string\">\" error when process received event .\"</span>, t);\n        }\n    }\n\n    <span class=\"hljs-comment\">/** 处理异常信息 */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">caught</span><span class=\"hljs-params\">(Channel channel, Throwable exception)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n        ExecutorService cexecutor = getExecutorService();\n        <span class=\"hljs-keyword\">try</span> {\n            cexecutor.execute(<span class=\"hljs-keyword\">new</span> ChannelEventRunnable(channel, handler, ChannelState.CAUGHT, exception));\n        } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ExecutionException(..., <span class=\"hljs-string\">\"error when process caught event ...\"</span>);\n        }\n    }\n}\n</code></pre>\n<p>如上，请求对象会被封装 ChannelEventRunnable 中，ChannelEventRunnable 将会是服务调用过程的新起点。所以接下来我们以 ChannelEventRunnable 为起点向下探索。</p>\n<h5>2.3.2.2 调用服务</h5>\n<p>本小节，我们从 ChannelEventRunnable 开始分析，该类的主要代码如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ChannelEventRunnable</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Runnable</span> </span>{\n    \n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ChannelHandler handler;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Channel channel;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ChannelState state;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Throwable exception;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Object message;\n    \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// 检测通道状态，对于请求或响应消息，此时 state = RECEIVED</span>\n        <span class=\"hljs-keyword\">if</span> (state == ChannelState.RECEIVED) {\n            <span class=\"hljs-keyword\">try</span> {\n                <span class=\"hljs-comment\">// 将 channel 和 message 传给 ChannelHandler 对象，进行后续的调用</span>\n                handler.received(channel, message);\n            } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n                logger.warn(<span class=\"hljs-string\">\"... operation error, channel is ... message is ...\"</span>);\n            }\n        } \n        \n        <span class=\"hljs-comment\">// 其他消息类型通过 switch 进行处理</span>\n        <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">switch</span> (state) {\n            <span class=\"hljs-keyword\">case</span> CONNECTED:\n                <span class=\"hljs-keyword\">try</span> {\n                    handler.connected(channel);\n                } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n                    logger.warn(<span class=\"hljs-string\">\"... operation error, channel is ...\"</span>);\n                }\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">case</span> DISCONNECTED:\n                <span class=\"hljs-comment\">// ...</span>\n            <span class=\"hljs-keyword\">case</span> SENT:\n                <span class=\"hljs-comment\">// ...</span>\n            <span class=\"hljs-keyword\">case</span> CAUGHT:\n                <span class=\"hljs-comment\">// ...</span>\n            <span class=\"hljs-keyword\">default</span>:\n                logger.warn(<span class=\"hljs-string\">\"unknown state: \"</span> + state + <span class=\"hljs-string\">\", message is \"</span> + message);\n            }\n        }\n\n    }\n}\n</code></pre>\n<p>如上，请求和响应消息出现频率明显比其他类型消息高，所以这里对该类型的消息进行了针对性判断。ChannelEventRunnable 仅是一个中转站，它的 run 方法中并不包含具体的调用逻辑，仅用于将参数传给其他 ChannelHandler 对象进行处理，该对象类型为 DecodeHandler。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DecodeHandler</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractChannelHandlerDelegate</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">DecodeHandler</span><span class=\"hljs-params\">(ChannelHandler handler)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(handler);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">received</span><span class=\"hljs-params\">(Channel channel, Object message)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n        <span class=\"hljs-keyword\">if</span> (message <span class=\"hljs-keyword\">instanceof</span> Decodeable) {\n            <span class=\"hljs-comment\">// 对 Decodeable 接口实现类对象进行解码</span>\n            decode(message);\n        }\n\n        <span class=\"hljs-keyword\">if</span> (message <span class=\"hljs-keyword\">instanceof</span> Request) {\n            <span class=\"hljs-comment\">// 对 Request 的 data 字段进行解码</span>\n            decode(((Request) message).getData());\n        }\n\n        <span class=\"hljs-keyword\">if</span> (message <span class=\"hljs-keyword\">instanceof</span> Response) {\n            <span class=\"hljs-comment\">// 对 Request 的 result 字段进行解码</span>\n            decode(((Response) message).getResult());\n        }\n\n        <span class=\"hljs-comment\">// 执行后续逻辑</span>\n        handler.received(channel, message);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">decode</span><span class=\"hljs-params\">(Object message)</span> </span>{\n        <span class=\"hljs-comment\">// Decodeable 接口目前有两个实现类，</span>\n        <span class=\"hljs-comment\">// 分别为 DecodeableRpcInvocation 和 DecodeableRpcResult</span>\n        <span class=\"hljs-keyword\">if</span> (message != <span class=\"hljs-keyword\">null</span> &amp;&amp; message <span class=\"hljs-keyword\">instanceof</span> Decodeable) {\n            <span class=\"hljs-keyword\">try</span> {\n                <span class=\"hljs-comment\">// 执行解码逻辑</span>\n                ((Decodeable) message).decode();\n            } <span class=\"hljs-keyword\">catch</span> (Throwable e) {\n                <span class=\"hljs-keyword\">if</span> (log.isWarnEnabled()) {\n                    log.warn(<span class=\"hljs-string\">\"Call Decodeable.decode failed: \"</span> + e.getMessage(), e);\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p>DecodeHandler 主要是包含了一些解码逻辑。2.2.1 节分析请求解码时说过，请求解码可在 IO 线程上执行，也可在线程池中执行，这个取决于运行时配置。DecodeHandler 存在的意义就是保证请求或响应对象可在线程池中被解码。解码完毕后，完全解码后的 Request 对象会继续向后传递，下一站是 HeaderExchangeHandler。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HeaderExchangeHandler</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ChannelHandlerDelegate</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ExchangeHandler handler;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">HeaderExchangeHandler</span><span class=\"hljs-params\">(ExchangeHandler handler)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (handler == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"handler == null\"</span>);\n        }\n        <span class=\"hljs-keyword\">this</span>.handler = handler;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">received</span><span class=\"hljs-params\">(Channel channel, Object message)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n        channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());\n        ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 处理请求对象</span>\n            <span class=\"hljs-keyword\">if</span> (message <span class=\"hljs-keyword\">instanceof</span> Request) {\n                Request request = (Request) message;\n                <span class=\"hljs-keyword\">if</span> (request.isEvent()) {\n                    <span class=\"hljs-comment\">// 处理事件</span>\n                    handlerEvent(channel, request);\n                } \n                <span class=\"hljs-comment\">// 处理普通的请求</span>\n                <span class=\"hljs-keyword\">else</span> {\n                    <span class=\"hljs-comment\">// 双向通信</span>\n                    <span class=\"hljs-keyword\">if</span> (request.isTwoWay()) {\n                        <span class=\"hljs-comment\">// 向后调用服务，并得到调用结果</span>\n                        Response response = handleRequest(exchangeChannel, request);\n                        <span class=\"hljs-comment\">// 将调用结果返回给服务消费端</span>\n                        channel.send(response);\n                    } \n                    <span class=\"hljs-comment\">// 如果是单向通信，仅向后调用指定服务即可，无需返回调用结果</span>\n                    <span class=\"hljs-keyword\">else</span> {\n                        handler.received(exchangeChannel, request.getData());\n                    }\n                }\n            }      \n            <span class=\"hljs-comment\">// 处理响应对象，服务消费方会执行此处逻辑，后面分析</span>\n            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (message <span class=\"hljs-keyword\">instanceof</span> Response) {\n                handleResponse(channel, (Response) message);\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (message <span class=\"hljs-keyword\">instanceof</span> String) {\n                <span class=\"hljs-comment\">// telnet 相关，忽略</span>\n            } <span class=\"hljs-keyword\">else</span> {\n                handler.received(exchangeChannel, message);\n            }\n        } <span class=\"hljs-keyword\">finally</span> {\n            HeaderExchangeChannel.removeChannelIfDisconnected(channel);\n        }\n    }\n\n    <span class=\"hljs-function\">Response <span class=\"hljs-title\">handleRequest</span><span class=\"hljs-params\">(ExchangeChannel channel, Request req)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n        Response res = <span class=\"hljs-keyword\">new</span> Response(req.getId(), req.getVersion());\n        <span class=\"hljs-comment\">// 检测请求是否合法，不合法则返回状态码为 BAD_REQUEST 的响应</span>\n        <span class=\"hljs-keyword\">if</span> (req.isBroken()) {\n            Object data = req.getData();\n\n            String msg;\n            <span class=\"hljs-keyword\">if</span> (data == <span class=\"hljs-keyword\">null</span>)\n                msg = <span class=\"hljs-keyword\">null</span>;\n            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>\n                (data <span class=\"hljs-keyword\">instanceof</span> Throwable) msg = StringUtils.toString((Throwable) data);\n            <span class=\"hljs-keyword\">else</span>\n                msg = data.toString();\n            res.setErrorMessage(<span class=\"hljs-string\">\"Fail to decode request due to: \"</span> + msg);\n            <span class=\"hljs-comment\">// 设置 BAD_REQUEST 状态</span>\n            res.setStatus(Response.BAD_REQUEST);\n\n            <span class=\"hljs-keyword\">return</span> res;\n        }\n        \n        <span class=\"hljs-comment\">// 获取 data 字段值，也就是 RpcInvocation 对象</span>\n        Object msg = req.getData();\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 继续向下调用</span>\n            Object result = handler.reply(channel, msg);\n            <span class=\"hljs-comment\">// 设置 OK 状态码</span>\n            res.setStatus(Response.OK);\n            <span class=\"hljs-comment\">// 设置调用结果</span>\n            res.setResult(result);\n        } <span class=\"hljs-keyword\">catch</span> (Throwable e) {\n            <span class=\"hljs-comment\">// 若调用过程出现异常，则设置 SERVICE_ERROR，表示服务端异常</span>\n            res.setStatus(Response.SERVICE_ERROR);\n            res.setErrorMessage(StringUtils.toString(e));\n        }\n        <span class=\"hljs-keyword\">return</span> res;\n    }\n}\n</code></pre>\n<p>到这里，我们看到了比较清晰的请求和响应逻辑。对于双向通信，HeaderExchangeHandler 首先向后进行调用，得到调用结果。然后将调用结果封装到 Response 对象中，最后再将该对象返回给服务消费方。如果请求不合法，或者调用失败，则将错误信息封装到 Response 对象中，并返回给服务消费方。接下来我们继续向后分析，把剩余的调用过程分析完。下面分析定义在 DubboProtocol 类中的匿名类对象逻辑，如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DubboProtocol</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractProtocol</span> </span>{\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String NAME = <span class=\"hljs-string\">\"dubbo\"</span>;\n    \n    <span class=\"hljs-keyword\">private</span> ExchangeHandler requestHandler = <span class=\"hljs-keyword\">new</span> ExchangeHandlerAdapter() {\n\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">reply</span><span class=\"hljs-params\">(ExchangeChannel channel, Object message)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n            <span class=\"hljs-keyword\">if</span> (message <span class=\"hljs-keyword\">instanceof</span> Invocation) {\n                Invocation inv = (Invocation) message;\n                <span class=\"hljs-comment\">// 获取 Invoker 实例</span>\n                Invoker&lt;?&gt; invoker = getInvoker(channel, inv);\n                <span class=\"hljs-keyword\">if</span> (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) {\n                    <span class=\"hljs-comment\">// 回调相关，忽略</span>\n                }\n                RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());\n                <span class=\"hljs-comment\">// 通过 Invoker 调用具体的服务</span>\n                <span class=\"hljs-keyword\">return</span> invoker.invoke(inv);\n            }\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RemotingException(channel, <span class=\"hljs-string\">\"Unsupported request: ...\"</span>);\n        }\n        \n        <span class=\"hljs-comment\">// 忽略其他方法</span>\n    }\n    \n    Invoker&lt;?&gt; getInvoker(Channel channel, Invocation inv) <span class=\"hljs-keyword\">throws</span> RemotingException {\n        <span class=\"hljs-comment\">// 忽略回调和本地存根相关逻辑</span>\n        <span class=\"hljs-comment\">// ...</span>\n        \n        <span class=\"hljs-keyword\">int</span> port = channel.getLocalAddress().getPort();\n        \n        <span class=\"hljs-comment\">// 计算 service key，格式为 groupName/serviceName:serviceVersion:port。比如：</span>\n        <span class=\"hljs-comment\">//   dubbo/com.alibaba.dubbo.demo.DemoService:1.0.0:20880</span>\n        String serviceKey = serviceKey(port, path, inv.getAttachments().get(Constants.VERSION_KEY), inv.getAttachments().get(Constants.GROUP_KEY));\n\n        <span class=\"hljs-comment\">// 从 exporterMap 查找与 serviceKey 相对应的 DubboExporter 对象，</span>\n        <span class=\"hljs-comment\">// 服务导出过程中会将 &lt;serviceKey, DubboExporter&gt; 映射关系存储到 exporterMap 集合中</span>\n        DubboExporter&lt;?&gt; exporter = (DubboExporter&lt;?&gt;) exporterMap.get(serviceKey);\n\n        <span class=\"hljs-keyword\">if</span> (exporter == <span class=\"hljs-keyword\">null</span>)\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RemotingException(channel, <span class=\"hljs-string\">\"Not found exported service ...\"</span>);\n\n        <span class=\"hljs-comment\">// 获取 Invoker 对象，并返回</span>\n        <span class=\"hljs-keyword\">return</span> exporter.getInvoker();\n    }\n    \n    <span class=\"hljs-comment\">// 忽略其他方法</span>\n}\n</code></pre>\n<p>以上逻辑用于获取与指定服务对应的 Invoker 实例，并通过 Invoker 的 invoke 方法调用服务逻辑。invoke 方法定义在 AbstractProxyInvoker 中，代码如下。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AbstractProxyInvoker</span>&lt;<span class=\"hljs-title\">T</span>&gt; <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Invoker</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Result <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 调用 doInvoke 执行后续的调用，并将调用结果封装到 RpcResult 中，并</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()));\n        } <span class=\"hljs-keyword\">catch</span> (InvocationTargetException e) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> RpcResult(e.getTargetException());\n        } <span class=\"hljs-keyword\">catch</span> (Throwable e) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RpcException(<span class=\"hljs-string\">\"Failed to invoke remote proxy method ...\"</span>);\n        }\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> Object <span class=\"hljs-title\">doInvoke</span><span class=\"hljs-params\">(T proxy, String methodName, Class&lt;?&gt;[] parameterTypes, Object[] arguments)</span> <span class=\"hljs-keyword\">throws</span> Throwable</span>;\n}\n</code></pre>\n<p>如上，doInvoke 是一个抽象方法，这个需要由具体的 Invoker 实例实现。Invoker 实例是在运行时通过 JavassistProxyFactory 创建的，创建逻辑如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">JavassistProxyFactory</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractProxyFactory</span> </span>{\n    \n    <span class=\"hljs-comment\">// 省略其他方法</span>\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">Invoker&lt;T&gt; <span class=\"hljs-title\">getInvoker</span><span class=\"hljs-params\">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>{\n        <span class=\"hljs-keyword\">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class=\"hljs-string\">'$'</span>) &lt; <span class=\"hljs-number\">0</span> ? proxy.getClass() : type);\n        <span class=\"hljs-comment\">// 创建匿名类对象</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) {\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title\">doInvoke</span><span class=\"hljs-params\">(T proxy, String methodName,\n                                      Class&lt;?&gt;[] parameterTypes,\n                                      Object[] arguments)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n                <span class=\"hljs-comment\">// 调用 invokeMethod 方法进行后续的调用</span>\n                <span class=\"hljs-keyword\">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n            }\n        };\n    }\n}\n</code></pre>\n<p>Wrapper 是一个抽象类，其中 invokeMethod 是一个抽象方法。Dubbo 会在运行时通过 Javassist 框架为 Wrapper 生成实现类，并实现 invokeMethod 方法，该方法最终会根据调用信息调用具体的服务。以 DemoServiceImpl 为例，Javassist 为其生成的代理类如下。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/** Wrapper0 是在运行时生成的，大家可使用 Arthas 进行反编译 */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Wrapper0</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Wrapper</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ClassGenerator</span>.<span class=\"hljs-title\">DC</span> </span>{\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String[] pns;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Map pts;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String[] mns;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String[] dmns;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Class[] mts0;\n\n    <span class=\"hljs-comment\">// 省略其他方法</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">invokeMethod</span><span class=\"hljs-params\">(Object object, String string, Class[] arrclass, Object[] arrobject)</span> <span class=\"hljs-keyword\">throws</span> InvocationTargetException </span>{\n        DemoService demoService;\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 类型转换</span>\n            demoService = (DemoService)object;\n        }\n        <span class=\"hljs-keyword\">catch</span> (Throwable throwable) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(throwable);\n        }\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 根据方法名调用指定的方法</span>\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">\"sayHello\"</span>.equals(string) &amp;&amp; arrclass.length == <span class=\"hljs-number\">1</span>) {\n                <span class=\"hljs-keyword\">return</span> demoService.sayHello((String)arrobject[<span class=\"hljs-number\">0</span>]);\n            }\n        }\n        <span class=\"hljs-keyword\">catch</span> (Throwable throwable) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> InvocationTargetException(throwable);\n        }\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> NoSuchMethodException(<span class=\"hljs-keyword\">new</span> StringBuffer().append(<span class=\"hljs-string\">\"Not found method \\\"\"</span>).append(string).append(<span class=\"hljs-string\">\"\\\" in class com.alibaba.dubbo.demo.DemoService.\"</span>).toString());\n    }\n}\n</code></pre>\n<p>到这里，整个服务调用过程就分析完了。最后把调用过程贴出来，如下：</p>\n<pre><code>ChannelEventRunnable#run()\n  —&gt; DecodeHandler#received(Channel, Object)\n    —&gt; HeaderExchangeHandler#received(Channel, Object)\n      —&gt; HeaderExchangeHandler#handleRequest(ExchangeChannel, Request)\n        —&gt; DubboProtocol.requestHandler#reply(ExchangeChannel, Object)\n          —&gt; Filter#invoke(Invoker, Invocation)\n            —&gt; AbstractProxyInvoker#invoke(Invocation)\n              —&gt; Wrapper0#invokeMethod(Object, String, Class[], Object[])\n                —&gt; DemoServiceImpl#sayHello(String)\n</code></pre>\n<h3>2.4 服务提供方返回调用结果</h3>\n<p>服务提供方调用指定服务后，会将调用结果封装到 Response 对象中，并将该对象返回给服务消费方。服务提供方也是通过 NettyChannel 的 send 方法将 Response 对象返回，这个方法在 2.2.1 节分析过，这里就不在重复分析了。本节我们仅需关注 Response 对象的编码过程即可，这里仍然省略一些中间调用，直接分析具体的编码逻辑。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ExchangeCodec</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">TelnetCodec</span> </span>{\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">encode</span><span class=\"hljs-params\">(Channel channel, ChannelBuffer buffer, Object msg)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        <span class=\"hljs-keyword\">if</span> (msg <span class=\"hljs-keyword\">instanceof</span> Request) {\n            encodeRequest(channel, buffer, (Request) msg);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (msg <span class=\"hljs-keyword\">instanceof</span> Response) {\n            <span class=\"hljs-comment\">// 对响应对象进行编码</span>\n            encodeResponse(channel, buffer, (Response) msg);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">super</span>.encode(channel, buffer, msg);\n        }\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">encodeResponse</span><span class=\"hljs-params\">(Channel channel, ChannelBuffer buffer, Response res)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        <span class=\"hljs-keyword\">int</span> savedWriteIndex = buffer.writerIndex();\n        <span class=\"hljs-keyword\">try</span> {\n            Serialization serialization = getSerialization(channel);\n            <span class=\"hljs-comment\">// 创建消息头字节数组</span>\n            <span class=\"hljs-keyword\">byte</span>[] header = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">byte</span>[HEADER_LENGTH];\n            <span class=\"hljs-comment\">// 设置魔数</span>\n            Bytes.short2bytes(MAGIC, header);\n            <span class=\"hljs-comment\">// 设置序列化器编号</span>\n            header[<span class=\"hljs-number\">2</span>] = serialization.getContentTypeId();\n            <span class=\"hljs-keyword\">if</span> (res.isHeartbeat()) header[<span class=\"hljs-number\">2</span>] |= FLAG_EVENT;\n            <span class=\"hljs-comment\">// 获取响应状态</span>\n            <span class=\"hljs-keyword\">byte</span> status = res.getStatus();\n            <span class=\"hljs-comment\">// 设置响应状态</span>\n            header[<span class=\"hljs-number\">3</span>] = status;\n            <span class=\"hljs-comment\">// 设置请求编号</span>\n            Bytes.long2bytes(res.getId(), header, <span class=\"hljs-number\">4</span>);\n\n            <span class=\"hljs-comment\">// 更新 writerIndex，为消息头预留 16 个字节的空间</span>\n            buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);\n            ChannelBufferOutputStream bos = <span class=\"hljs-keyword\">new</span> ChannelBufferOutputStream(buffer);\n            ObjectOutput out = serialization.serialize(channel.getUrl(), bos);\n           \n            <span class=\"hljs-keyword\">if</span> (status == Response.OK) {\n                <span class=\"hljs-keyword\">if</span> (res.isHeartbeat()) {\n                    <span class=\"hljs-comment\">// 对心跳响应结果进行序列化，已废弃</span>\n                    encodeHeartbeatData(channel, out, res.getResult());\n                } <span class=\"hljs-keyword\">else</span> {\n                    <span class=\"hljs-comment\">// 对调用结果进行序列化</span>\n                    encodeResponseData(channel, out, res.getResult(), res.getVersion());\n                }\n            } <span class=\"hljs-keyword\">else</span> { \n                <span class=\"hljs-comment\">// 对错误信息进行序列化</span>\n                out.writeUTF(res.getErrorMessage())\n            };\n            out.flushBuffer();\n            <span class=\"hljs-keyword\">if</span> (out <span class=\"hljs-keyword\">instanceof</span> Cleanable) {\n                ((Cleanable) out).cleanup();\n            }\n            bos.flush();\n            bos.close();\n\n            <span class=\"hljs-comment\">// 获取写入的字节数，也就是消息体长度</span>\n            <span class=\"hljs-keyword\">int</span> len = bos.writtenBytes();\n            checkPayload(channel, len);\n            \n            <span class=\"hljs-comment\">// 将消息体长度写入到消息头中</span>\n            Bytes.int2bytes(len, header, <span class=\"hljs-number\">12</span>);\n            <span class=\"hljs-comment\">// 将 buffer 指针移动到 savedWriteIndex，为写消息头做准备</span>\n            buffer.writerIndex(savedWriteIndex);\n            <span class=\"hljs-comment\">// 从 savedWriteIndex 下标处写入消息头</span>\n            buffer.writeBytes(header); \n            <span class=\"hljs-comment\">// 设置新的 writerIndex，writerIndex = 原写下标 + 消息头长度 + 消息体长度</span>\n            buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);\n        } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n            <span class=\"hljs-comment\">// 异常处理逻辑不是很难理解，但是代码略多，这里忽略了</span>\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DubboCodec</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ExchangeCodec</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Codec2</span> </span>{\n    \n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">encodeResponseData</span><span class=\"hljs-params\">(Channel channel, ObjectOutput out, Object data, String version)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        Result result = (Result) data;\n        <span class=\"hljs-comment\">// 检测当前协议版本是否支持带有 attachment 集合的 Response 对象</span>\n        <span class=\"hljs-keyword\">boolean</span> attach = Version.isSupportResponseAttachment(version);\n        Throwable th = result.getException();\n        \n        <span class=\"hljs-comment\">// 异常信息为空</span>\n        <span class=\"hljs-keyword\">if</span> (th == <span class=\"hljs-keyword\">null</span>) {\n            Object ret = result.getValue();\n            <span class=\"hljs-comment\">// 调用结果为空</span>\n            <span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-comment\">// 序列化响应类型</span>\n                out.writeByte(attach ? RESPONSE_NULL_VALUE_WITH_ATTACHMENTS : RESPONSE_NULL_VALUE);\n            } \n            <span class=\"hljs-comment\">// 调用结果非空</span>\n            <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-comment\">// 序列化响应类型</span>\n                out.writeByte(attach ? RESPONSE_VALUE_WITH_ATTACHMENTS : RESPONSE_VALUE);\n                <span class=\"hljs-comment\">// 序列化调用结果</span>\n                out.writeObject(ret);\n            }\n        } \n        <span class=\"hljs-comment\">// 异常信息非空</span>\n        <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// 序列化响应类型</span>\n            out.writeByte(attach ? RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS : RESPONSE_WITH_EXCEPTION);\n            <span class=\"hljs-comment\">// 序列化异常对象</span>\n            out.writeObject(th);\n        }\n\n        <span class=\"hljs-keyword\">if</span> (attach) {\n            <span class=\"hljs-comment\">// 记录 Dubbo 协议版本</span>\n            result.getAttachments().put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());\n            <span class=\"hljs-comment\">// 序列化 attachments 集合</span>\n            out.writeObject(result.getAttachments());\n        }\n    }\n}\n</code></pre>\n<p>以上就是 Response 对象编码的过程，和前面分析的 Request 对象编码过程很相似。如果大家能看 Request 对象的编码逻辑，那么这里的 Response 对象的编码逻辑也不难理解，就不多说了。接下来我们再来分析双向通信的最后一环 —— 服务消费方接收调用结果。</p>\n<h3>2.5 服务消费方接收调用结果</h3>\n<p>服务消费方在收到响应数据后，首先要做的事情是对响应数据进行解码，得到 Response 对象。然后再将该对象传递给下一个入站处理器，这个入站处理器就是 NettyHandler。接下来 NettyHandler 会将这个对象继续向下传递，最后 AllChannelHandler 的 received 方法会收到这个对象，并将这个对象派发到线程池中。这个过程和服务提供方接收请求的过程是一样的，因此这里就不重复分析了。本节我们重点分析两个方面的内容，一是响应数据的解码过程，二是 Dubbo 如何将调用结果传递给用户线程的。下面先来分析响应数据的解码过程。</p>\n<h4>2.5.1 响应数据解码</h4>\n<p>响应数据解码逻辑主要的逻辑封装在 DubboCodec 中，我们直接分析这个类的代码。如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DubboCodec</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ExchangeCodec</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Codec2</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title\">decodeBody</span><span class=\"hljs-params\">(Channel channel, InputStream is, <span class=\"hljs-keyword\">byte</span>[] header)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        <span class=\"hljs-keyword\">byte</span> flag = header[<span class=\"hljs-number\">2</span>], proto = (<span class=\"hljs-keyword\">byte</span>) (flag &amp; SERIALIZATION_MASK);\n        Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);\n        <span class=\"hljs-comment\">// 获取请求编号</span>\n        <span class=\"hljs-keyword\">long</span> id = Bytes.bytes2long(header, <span class=\"hljs-number\">4</span>);\n        <span class=\"hljs-comment\">// 检测消息类型，若下面的条件成立，表明消息类型为 Response</span>\n        <span class=\"hljs-keyword\">if</span> ((flag &amp; FLAG_REQUEST) == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-comment\">// 创建 Response 对象</span>\n            Response res = <span class=\"hljs-keyword\">new</span> Response(id);\n            <span class=\"hljs-comment\">// 检测事件标志位</span>\n            <span class=\"hljs-keyword\">if</span> ((flag &amp; FLAG_EVENT) != <span class=\"hljs-number\">0</span>) {\n                <span class=\"hljs-comment\">// 设置心跳事件</span>\n                res.setEvent(Response.HEARTBEAT_EVENT);\n            }\n            <span class=\"hljs-comment\">// 获取响应状态</span>\n            <span class=\"hljs-keyword\">byte</span> status = header[<span class=\"hljs-number\">3</span>];\n            <span class=\"hljs-comment\">// 设置响应状态</span>\n            res.setStatus(status);\n            \n            <span class=\"hljs-comment\">// 如果响应状态为 OK，表明调用过程正常</span>\n            <span class=\"hljs-keyword\">if</span> (status == Response.OK) {\n                <span class=\"hljs-keyword\">try</span> {\n                    Object data;\n                    <span class=\"hljs-keyword\">if</span> (res.isHeartbeat()) {\n                        <span class=\"hljs-comment\">// 反序列化心跳数据，已废弃</span>\n                        data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));\n                    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (res.isEvent()) {\n                        <span class=\"hljs-comment\">// 反序列化事件数据</span>\n                        data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));\n                    } <span class=\"hljs-keyword\">else</span> {\n                        DecodeableRpcResult result;\n                        <span class=\"hljs-comment\">// 根据 url 参数决定是否在 IO 线程上执行解码逻辑</span>\n                        <span class=\"hljs-keyword\">if</span> (channel.getUrl().getParameter(\n                                Constants.DECODE_IN_IO_THREAD_KEY,\n                                Constants.DEFAULT_DECODE_IN_IO_THREAD)) {\n                            <span class=\"hljs-comment\">// 创建 DecodeableRpcResult 对象</span>\n                            result = <span class=\"hljs-keyword\">new</span> DecodeableRpcResult(channel, res, is,\n                                    (Invocation) getRequestData(id), proto);\n                            <span class=\"hljs-comment\">// 进行后续的解码工作</span>\n                            result.decode();\n                        } <span class=\"hljs-keyword\">else</span> {\n                            <span class=\"hljs-comment\">// 创建 DecodeableRpcResult 对象</span>\n                            result = <span class=\"hljs-keyword\">new</span> DecodeableRpcResult(channel, res,\n                                    <span class=\"hljs-keyword\">new</span> UnsafeByteArrayInputStream(readMessageData(is)),\n                                    (Invocation) getRequestData(id), proto);\n                        }\n                        data = result;\n                    }\n                    \n                    <span class=\"hljs-comment\">// 设置 DecodeableRpcResult 对象到 Response 对象中</span>\n                    res.setResult(data);\n                } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n                    <span class=\"hljs-comment\">// 解码过程中出现了错误，此时设置 CLIENT_ERROR 状态码到 Response 对象中</span>\n                    res.setStatus(Response.CLIENT_ERROR);\n                    res.setErrorMessage(StringUtils.toString(t));\n                }\n            } \n            <span class=\"hljs-comment\">// 响应状态非 OK，表明调用过程出现了异常</span>\n            <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-comment\">// 反序列化异常信息，并设置到 Response 对象中</span>\n                res.setErrorMessage(deserialize(s, channel.getUrl(), is).readUTF());\n            }\n            <span class=\"hljs-keyword\">return</span> res;\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// 对请求数据进行解码，前面已分析过，此处忽略</span>\n        }\n    }\n}\n</code></pre>\n<p>以上就是响应数据的解码过程，上面逻辑看起来是不是似曾相识。对的，我们在前面章节分析过 DubboCodec 的 decodeBody 方法中关于请求数据的解码过程，该过程和响应数据的解码过程很相似。下面，我们继续分析调用结果的反序列化过程，如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DecodeableRpcResult</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">RpcResult</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Codec</span>, <span class=\"hljs-title\">Decodeable</span> </span>{\n    \n    <span class=\"hljs-keyword\">private</span> Invocation invocation;\n\t\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">decode</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        <span class=\"hljs-keyword\">if</span> (!hasDecoded &amp;&amp; channel != <span class=\"hljs-keyword\">null</span> &amp;&amp; inputStream != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">try</span> {\n                <span class=\"hljs-comment\">// 执行反序列化操作</span>\n                decode(channel, inputStream);\n            } <span class=\"hljs-keyword\">catch</span> (Throwable e) {\n                <span class=\"hljs-comment\">// 反序列化失败，设置 CLIENT_ERROR 状态到 Response 对象中</span>\n                response.setStatus(Response.CLIENT_ERROR);\n                <span class=\"hljs-comment\">// 设置异常信息</span>\n                response.setErrorMessage(StringUtils.toString(e));\n            } <span class=\"hljs-keyword\">finally</span> {\n                hasDecoded = <span class=\"hljs-keyword\">true</span>;\n            }\n        }\n    }\n    \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">decode</span><span class=\"hljs-params\">(Channel channel, InputStream input)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)\n                .deserialize(channel.getUrl(), input);\n        \n        <span class=\"hljs-comment\">// 反序列化响应类型</span>\n        <span class=\"hljs-keyword\">byte</span> flag = in.readByte();\n        <span class=\"hljs-keyword\">switch</span> (flag) {\n            <span class=\"hljs-keyword\">case</span> DubboCodec.RESPONSE_NULL_VALUE:\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">case</span> DubboCodec.RESPONSE_VALUE:\n                <span class=\"hljs-comment\">// ...</span>\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION:\n                <span class=\"hljs-comment\">// ...</span>\n                <span class=\"hljs-keyword\">break</span>;\n                \n            <span class=\"hljs-comment\">// 返回值为空，且携带了 attachments 集合</span>\n            <span class=\"hljs-keyword\">case</span> DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS:\n                <span class=\"hljs-keyword\">try</span> {\n                    <span class=\"hljs-comment\">// 反序列化 attachments 集合，并存储起来 </span>\n                    setAttachments((Map&lt;String, String&gt;) in.readObject(Map.class));\n                } <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException e) {\n                    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IOException(StringUtils.toString(<span class=\"hljs-string\">\"Read response data failed.\"</span>, e));\n                }\n                <span class=\"hljs-keyword\">break</span>;\n                \n            <span class=\"hljs-comment\">// 返回值不为空，且携带了 attachments 集合</span>\n            <span class=\"hljs-keyword\">case</span> DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:\n                <span class=\"hljs-keyword\">try</span> {\n                    <span class=\"hljs-comment\">// 获取返回值类型</span>\n                    Type[] returnType = RpcUtils.getReturnTypes(invocation);\n                    <span class=\"hljs-comment\">// 反序列化调用结果，并保存起来</span>\n                    setValue(returnType == <span class=\"hljs-keyword\">null</span> || returnType.length == <span class=\"hljs-number\">0</span> ? in.readObject() :\n                            (returnType.length == <span class=\"hljs-number\">1</span> ? in.readObject((Class&lt;?&gt;) returnType[<span class=\"hljs-number\">0</span>])\n                                    : in.readObject((Class&lt;?&gt;) returnType[<span class=\"hljs-number\">0</span>], returnType[<span class=\"hljs-number\">1</span>])));\n                    <span class=\"hljs-comment\">// 反序列化 attachments 集合，并存储起来</span>\n                    setAttachments((Map&lt;String, String&gt;) in.readObject(Map.class));\n                } <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException e) {\n                    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IOException(StringUtils.toString(<span class=\"hljs-string\">\"Read response data failed.\"</span>, e));\n                }\n                <span class=\"hljs-keyword\">break</span>;\n                \n            <span class=\"hljs-comment\">// 异常对象不为空，且携带了 attachments 集合</span>\n            <span class=\"hljs-keyword\">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS:\n                <span class=\"hljs-keyword\">try</span> {\n                    <span class=\"hljs-comment\">// 反序列化异常对象</span>\n                    Object obj = in.readObject();\n                    <span class=\"hljs-keyword\">if</span> (obj <span class=\"hljs-keyword\">instanceof</span> Throwable == <span class=\"hljs-keyword\">false</span>)\n                        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IOException(<span class=\"hljs-string\">\"Response data error, expect Throwable, but get \"</span> + obj);\n                    <span class=\"hljs-comment\">// 设置异常对象</span>\n                    setException((Throwable) obj);\n                    <span class=\"hljs-comment\">// 反序列化 attachments 集合，并存储起来</span>\n                    setAttachments((Map&lt;String, String&gt;) in.readObject(Map.class));\n                } <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException e) {\n                    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IOException(StringUtils.toString(<span class=\"hljs-string\">\"Read response data failed.\"</span>, e));\n                }\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">default</span>:\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IOException(<span class=\"hljs-string\">\"Unknown result flag, expect '0' '1' '2', get \"</span> + flag);\n        }\n        <span class=\"hljs-keyword\">if</span> (in <span class=\"hljs-keyword\">instanceof</span> Cleanable) {\n            ((Cleanable) in).cleanup();\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n    }\n}\n</code></pre>\n<p>本篇文章所分析的源码版本为 2.6.4，该版本下的 Response 支持 attachments 集合，所以上面仅对部分 case 分支进行了注释。其他 case 分支的逻辑比被注释分支的逻辑更为简单，这里就忽略了。我们所使用的测试服务接口 DemoService 包含了一个具有返回值的方法，正常调用下，线程会进入 RESPONSE_VALUE_WITH_ATTACHMENTS 分支中。然后线程会从 invocation 变量（大家探索一下 invocation 变量的由来）中获取返回值类型，接着对调用结果进行反序列化，并将序列化后的结果存储起来。最后对  attachments 集合进行反序列化，并存到指定字段中。到此，关于响应数据的解码过程就分析完了。接下来，我们再来探索一下响应对象 Response 的去向。</p>\n<h4>2.5.2 向用户线程传递调用结果</h4>\n<p>响应数据解码完成后，Dubbo 会将响应对象派发到线程池上。要注意的是，线程池中的线程并非用户的调用线程，所以要想办法将响应对象从线程池线程传递到用户线程上。我们在 2.1 节分析过用户线程在发送完请求后的动作，即调用 DefaultFuture 的 get 方法等待响应对象的到来。当响应对象到来后，用户线程会被唤醒，并通过<strong>调用编号</strong>获取属于自己的响应对象。下面我们来看一下整个过程对应的代码。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HeaderExchangeHandler</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ChannelHandlerDelegate</span> </span>{\n    \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">received</span><span class=\"hljs-params\">(Channel channel, Object message)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n        channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());\n        ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">if</span> (message <span class=\"hljs-keyword\">instanceof</span> Request) {\n                <span class=\"hljs-comment\">// 处理请求，前面已分析过，省略</span>\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (message <span class=\"hljs-keyword\">instanceof</span> Response) {\n                <span class=\"hljs-comment\">// 处理响应</span>\n                handleResponse(channel, (Response) message);\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (message <span class=\"hljs-keyword\">instanceof</span> String) {\n                <span class=\"hljs-comment\">// telnet 相关，忽略</span>\n            } <span class=\"hljs-keyword\">else</span> {\n                handler.received(exchangeChannel, message);\n            }\n        } <span class=\"hljs-keyword\">finally</span> {\n            HeaderExchangeChannel.removeChannelIfDisconnected(channel);\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">handleResponse</span><span class=\"hljs-params\">(Channel channel, Response response)</span> <span class=\"hljs-keyword\">throws</span> RemotingException </span>{\n        <span class=\"hljs-keyword\">if</span> (response != <span class=\"hljs-keyword\">null</span> &amp;&amp; !response.isHeartbeat()) {\n            <span class=\"hljs-comment\">// 继续向下调用</span>\n            DefaultFuture.received(channel, response);\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DefaultFuture</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ResponseFuture</span> </span>{  \n    \n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Lock lock = <span class=\"hljs-keyword\">new</span> ReentrantLock();\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Condition done = lock.newCondition();\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> Response response;\n    \n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">received</span><span class=\"hljs-params\">(Channel channel, Response response)</span> </span>{\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 根据调用编号从 FUTURES 集合中查找指定的 DefaultFuture 对象</span>\n            DefaultFuture future = FUTURES.remove(response.getId());\n            <span class=\"hljs-keyword\">if</span> (future != <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-comment\">// 继续向下调用</span>\n                future.doReceived(response);\n            } <span class=\"hljs-keyword\">else</span> {\n                logger.warn(<span class=\"hljs-string\">\"The timeout response finally returned at ...\"</span>);\n            }\n        } <span class=\"hljs-keyword\">finally</span> {\n            CHANNELS.remove(response.getId());\n        }\n    }\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doReceived</span><span class=\"hljs-params\">(Response res)</span> </span>{\n        lock.lock();\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 保存响应对象</span>\n            response = res;\n            <span class=\"hljs-keyword\">if</span> (done != <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-comment\">// 唤醒用户线程</span>\n                done.signal();\n            }\n        } <span class=\"hljs-keyword\">finally</span> {\n            lock.unlock();\n        }\n        <span class=\"hljs-keyword\">if</span> (callback != <span class=\"hljs-keyword\">null</span>) {\n            invokeCallback(callback);\n        }\n    }\n}\n</code></pre>\n<p>以上逻辑是将响应对象保存到相应的 DefaultFuture 实例中，然后再唤醒用户线程，随后用户线程即可从 DefaultFuture 实例中获取到相应结果。</p>\n<p>本篇文章在多个地方都强调过调用编号很重要，但一直没有解释原因，这里简单说明一下。一般情况下，服务消费方会并发调用多个服务，每个用户线程发送请求后，会调用不同 DefaultFuture 对象的 get 方法进行等待。 一段时间后，服务消费方的线程池会收到多个响应对象。这个时候要考虑一个问题，如何将每个响应对象传递给相应的 DefaultFuture 对象，且不出错。答案是通过调用编号。DefaultFuture 被创建时，会要求传入一个 Request 对象。此时 DefaultFuture 可从 Request 对象中获取调用编号，并将 &lt;调用编号, DefaultFuture 对象&gt; 映射关系存入到静态 Map 中，即 FUTURES。线程池中的线程在收到 Response 对象后，会根据 Response 对象中的调用编号到 FUTURES 集合中取出相应的 DefaultFuture 对象，然后再将 Response 对象设置到 DefaultFuture 对象中。最后再唤醒用户线程，这样用户线程即可从 DefaultFuture 对象中获取调用结果了。整个过程大致如下图：</p>\n<p><img src=\"sources/images/request-id-application.jpg\" alt=\"\"></p>\n<h2>3. 总结</h2>\n<p>本篇文章主要对 Dubbo 中的几种服务调用方式，以及从双向通信的角度对整个通信过程进行了详细的分析。按照通信顺序，通信过程包括服务消费方发送请求，服务提供方接收请求，服务提供方返回响应数据，服务消费方接收响应数据等过程。理解这些过程需要大家对网络编程，尤其是 Netty 有一定的了解。限于篇幅原因，本篇文章无法将服务调用的所有内容都一一进行分析。对于本篇文章未讲到或未详细分析的内容，比如服务降级、过滤器链、以及序列化等。大家若感兴趣，可自行进行分析。并将分析整理成文，分享给社区。</p>\n<p>本篇文章就到这里了，感谢阅读。</p>\n",
  "link": "/zh-cn/docs/source_code_guide/service-invoking-process.html",
  "meta": {
    "title": "服务调用过程",
    "keywords": "Dubbo, Service",
    "description": "本文介绍了服务调用过程\b的原理和实现细节"
  }
}