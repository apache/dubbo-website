{
  "filename": "async-call.md",
  "__html": "<h1>异步调用</h1>\n<p>基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小。 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></p>\n<p><img src=\"../sources/images/future.jpg\" alt=\"/user-guide/images/future.jpg\"></p>\n<p>在 consumer.xml 中配置：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"fooService\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.alibaba.foo.FooService\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"findFoo\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"true\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dubbo:reference</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"barService\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.alibaba.bar.BarService\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"findBar\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"true\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dubbo:reference</span>&gt;</span>\n</code></pre>\n<p>调用代码:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// 此调用会立即返回null</span>\nfooService.findFoo(fooId);\n<span class=\"hljs-comment\">// 拿到调用的Future引用，当结果返回后，会被通知和设置到此Future</span>\nFuture&lt;Foo&gt; fooFuture = RpcContext.getContext().getFuture(); \n \n<span class=\"hljs-comment\">// 此调用会立即返回null</span>\nbarService.findBar(barId);\n<span class=\"hljs-comment\">// 拿到调用的Future引用，当结果返回后，会被通知和设置到此Future</span>\nFuture&lt;Bar&gt; barFuture = RpcContext.getContext().getFuture(); \n \n<span class=\"hljs-comment\">// 此时findFoo和findBar的请求同时在执行，客户端不需要启动多线程来支持并行，而是借助NIO的非阻塞完成</span>\n \n<span class=\"hljs-comment\">// 如果foo已返回，直接拿到返回值，否则线程wait住，等待foo返回后，线程会被notify唤醒</span>\nFoo foo = fooFuture.get(); \n<span class=\"hljs-comment\">// 同理等待bar返回</span>\nBar bar = barFuture.get(); \n \n<span class=\"hljs-comment\">// 如果foo需要5秒返回，bar需要6秒返回，实际只需等6秒，即可获取到foo和bar，进行接下来的处理。</span>\n</code></pre>\n<p>你也可以设置是否等待消息发出： <sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></p>\n<ul>\n<li><code>sent=&quot;true&quot;</code> 等待消息发出，消息发送失败将抛出异常。</li>\n<li><code>sent=&quot;false&quot;</code> 不等待消息发出，将消息放入 IO 队列，即刻返回。</li>\n</ul>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"findFoo\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"true\"</span> <span class=\"hljs-attr\">sent</span>=<span class=\"hljs-string\">\"true\"</span> /&gt;</span>\n</code></pre>\n<p>如果你只是想异步，完全忽略返回值，可以配置 <code>return=&quot;false&quot;</code>，以减少 Future 对象的创建和管理成本：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"findFoo\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"true\"</span> <span class=\"hljs-attr\">return</span>=<span class=\"hljs-string\">\"false\"</span> /&gt;</span>\n</code></pre>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><code>2.0.6</code> 及其以上版本支持 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>异步总是不等待返回 <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n"
}