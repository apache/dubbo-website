{
  "filename": "async-call.md",
  "__html": "<h1>异步调用</h1>\n<p>从v2.7.0开始，Dubbo的所有异步编程接口开始以<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html\">CompletableFuture</a>为基础</p>\n<p>基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小。</p>\n<p><img src=\"../sources/images/future.jpg\" alt=\"/user-guide/images/future.jpg\"></p>\n<h2>使用CompletableFuture签名的接口</h2>\n<p>需要服务提供者事先定义CompletableFuture签名的服务，具体参见<a href=\"./async-execute-on-provider.md\">服务端异步执行</a>接口定义：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">AsyncService</span> </span>{\n    <span class=\"hljs-function\">CompletableFuture&lt;String&gt; <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span></span>;\n}\n</code></pre>\n<p>注意接口的返回类型是<code>CompletableFuture&lt;String&gt;</code>。</p>\n<p>XML引用服务：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"asyncService\"</span> <span class=\"hljs-attr\">timeout</span>=<span class=\"hljs-string\">\"10000\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.alibaba.dubbo.samples.async.api.AsyncService\"</span>/&gt;</span>\n</code></pre>\n<p>调用远程服务：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// 调用直接返回CompletableFuture</span>\nCompletableFuture&lt;String&gt; future = asyncService.sayHello(<span class=\"hljs-string\">\"async call request\"</span>);\n<span class=\"hljs-comment\">// 增加回调</span>\nfuture.whenComplete((v, t) -&gt; {\n    <span class=\"hljs-keyword\">if</span> (t != <span class=\"hljs-keyword\">null</span>) {\n        t.printStackTrace();\n    } <span class=\"hljs-keyword\">else</span> {\n        System.out.println(<span class=\"hljs-string\">\"Response: \"</span> + v);\n    }\n});\n<span class=\"hljs-comment\">// 早于结果输出</span>\nSystem.out.println(<span class=\"hljs-string\">\"Executed before response return.\"</span>);\n</code></pre>\n<h2>使用RpcContext</h2>\n<p>在 consumer.xml 中配置：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"asyncService\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.samples.governance.api.AsyncService\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"sayHello\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"true\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dubbo:reference</span>&gt;</span>\n</code></pre>\n<p>调用代码:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// 此调用会立即返回null</span>\nasyncService.sayHello(<span class=\"hljs-string\">\"world\"</span>);\n<span class=\"hljs-comment\">// 拿到调用的Future引用，当结果返回后，会被通知和设置到此Future</span>\nCompletableFuture&lt;String&gt; helloFuture = RpcContext.getContext().getCompletableFuture();\n<span class=\"hljs-comment\">// 为Future添加回调</span>\nhelloFuture.whenComplete((retValue, exception) -&gt; {\n    <span class=\"hljs-keyword\">if</span> (exception == <span class=\"hljs-keyword\">null</span>) {\n        System.out.println(retValue);\n    } <span class=\"hljs-keyword\">else</span> {\n        exception.printStackTrace();\n    }\n});\n</code></pre>\n<p>或者，你也可以这样做异步调用:</p>\n<pre><code class=\"language-java\">CompletableFuture&lt;String&gt; future = RpcContext.getContext().asyncCall(\n    () -&gt; {\n        asyncService.sayHello(<span class=\"hljs-string\">\"oneway call request1\"</span>);\n    }\n);\n\nfuture.get();\n</code></pre>\n<h2>重载服务接口</h2>\n<p>如果你只有这样的同步服务定义，而又不喜欢RpcContext的异步使用方式。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">GreetingsService</span> </span>{\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">sayHi</span><span class=\"hljs-params\">(String name)</span></span>;\n}\n</code></pre>\n<p>那还有一种方式，就是利用Java 8提供的default接口实现，重载一个带有带有CompletableFuture签名的方法。</p>\n<p>有两种方式来实现：</p>\n<ol>\n<li>提供方或消费方自己修改接口签名</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">GreetingsService</span> </span>{\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">sayHi</span><span class=\"hljs-params\">(String name)</span></span>;\n    \n    <span class=\"hljs-comment\">// AsyncSignal is totally optional, you can use any parameter type as long as java allows your to do that.</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">default</span> CompletableFuture&lt;String&gt; <span class=\"hljs-title\">sayHi</span><span class=\"hljs-params\">(String name, AsyncSignal signal)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> CompletableFuture.completedFuture(sayHi(name));\n    }\n}\n</code></pre>\n<ol>\n<li>Dubbo官方提供compiler hacker，编译期自动重写同步方法，请<a href=\"https://github.com/dubbo/dubbo-async-processor#compiler-hacker-processer\">在此</a>讨论和跟进具体进展。</li>\n</ol>\n<p>你也可以设置是否等待消息发出： <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></p>\n<ul>\n<li><code>sent=&quot;true&quot;</code> 等待消息发出，消息发送失败将抛出异常。</li>\n<li><code>sent=&quot;false&quot;</code> 不等待消息发出，将消息放入 IO 队列，即刻返回。</li>\n</ul>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"findFoo\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"true\"</span> <span class=\"hljs-attr\">sent</span>=<span class=\"hljs-string\">\"true\"</span> /&gt;</span>\n</code></pre>\n<p>如果你只是想异步，完全忽略返回值，可以配置 <code>return=&quot;false&quot;</code>，以减少 Future 对象的创建和管理成本：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"findFoo\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"true\"</span> <span class=\"hljs-attr\">return</span>=<span class=\"hljs-string\">\"false\"</span> /&gt;</span>\n</code></pre>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>异步总是不等待返回 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
  "link": "/zh-cn/docs/user/demos/async-call.html",
  "meta": {}
}