{
  "filename": "async-execute-on-provider.md",
  "__html": "<h1>异步执行</h1>\n<p>Provider端异步执行将阻塞的业务从Dubbo内部线程池切换到业务自定义线程，避免Dubbo线程池的过度占用，有助于避免不同服务间的互相影响。异步执行无益于节省资源或提升RPC响应性能，因为如果业务执行需要阻塞，则始终还是要有线程来负责执行。</p>\n<blockquote>\n<p>注意：Provider端异步执行和Consumer端异步调用是相互独立的，你可以任意正交组合两端配置</p>\n<ul>\n<li>Consumer同步 - Provider同步</li>\n<li>Consumer异步 - Provider同步</li>\n<li>Consumer同步 - Provider异步</li>\n<li>Consumer异步 - Provider异步</li>\n</ul>\n</blockquote>\n<h2>定义CompletableFuture签名的接口</h2>\n<p>服务接口定义：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">AsyncService</span> </span>{\n    <span class=\"hljs-function\">CompletableFuture&lt;String&gt; <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span></span>;\n}\n</code></pre>\n<p>服务实现：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AsyncServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">AsyncService</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> CompletableFuture&lt;String&gt; <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        RpcContext savedContext = RpcContext.getContext();\n        <span class=\"hljs-comment\">// 建议为supplyAsync提供自定义线程池，避免使用JDK公用线程池</span>\n        <span class=\"hljs-keyword\">return</span> CompletableFuture.supplyAsync(() -&gt; {\n            System.out.println(savedContext.getAttachment(<span class=\"hljs-string\">\"consumer-key1\"</span>));\n            <span class=\"hljs-keyword\">try</span> {\n                Thread.sleep(<span class=\"hljs-number\">5000</span>);\n            } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {\n                e.printStackTrace();\n            }\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"async response from provider.\"</span>;\n        });\n    }\n}\n</code></pre>\n<p>通过<code>return CompletableFuture.supplyAsync()</code>，业务执行已从Dubbo线程切换到业务线程，避免了对Dubbo线程池的阻塞。</p>\n<h2>使用AsyncContext</h2>\n<p>Dubbo提供了一个类似Serverlet 3.0的异步接口<code>AsyncContext</code>，在没有CompletableFuture签名接口的情况下，也可以实现Provider端的异步执行。</p>\n<p>服务接口定义：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">AsyncService</span> </span>{\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span></span>;\n}\n</code></pre>\n<p>服务暴露，和普通服务完全一致：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"asyncService\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.apache.dubbo.samples.governance.impl.AsyncServiceImpl\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.samples.governance.api.AsyncService\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"asyncService\"</span>/&gt;</span>\n</code></pre>\n<p>服务实现：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AsyncServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">AsyncService</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">final</span> AsyncContext asyncContext = RpcContext.startAsync();\n        <span class=\"hljs-keyword\">new</span> Thread(() -&gt; {\n            <span class=\"hljs-comment\">// 如果要使用上下文，则必须要放在第一句执行</span>\n            asyncContext.signalContextSwitch();\n            <span class=\"hljs-keyword\">try</span> {\n                Thread.sleep(<span class=\"hljs-number\">500</span>);\n            } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {\n                e.printStackTrace();\n            }\n            <span class=\"hljs-comment\">// 写回响应</span>\n            asyncContext.write(<span class=\"hljs-string\">\"Hello \"</span> + name + <span class=\"hljs-string\">\", response from provider.\"</span>);\n        }).start();\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n    }\n}\n</code></pre>\n",
  "link": "/zh-cn/docs/user/demos/async-execute-on-provider.html",
  "meta": {}
}