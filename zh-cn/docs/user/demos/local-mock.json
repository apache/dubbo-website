{
  "filename": "local-mock.md",
  "__html": "<h1>本地伪装</h1>\n<p>本地伪装 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup> 通常用于服务降级，比如某验权服务，当服务提供方全部挂掉后，客户端不抛出异常，而是通过 Mock 数据返回授权失败。</p>\n<p>在 spring 配置文件中按以下方式配置：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.foo.BarService\"</span> <span class=\"hljs-attr\">mock</span>=<span class=\"hljs-string\">\"true\"</span> /&gt;</span>\n</code></pre>\n<p>或</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.foo.BarService\"</span> <span class=\"hljs-attr\">mock</span>=<span class=\"hljs-string\">\"com.foo.BarServiceMock\"</span> /&gt;</span>\n</code></pre>\n<p>在工程中提供 Mock 实现 <sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.foo;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BarServiceMock</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">BarService</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-comment\">// 你可以伪造容错数据，此方法只在出现RpcException时被执行</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"容错数据\"</span>;\n    }\n}\n</code></pre>\n<p>如果服务的消费方经常需要 try-catch 捕获异常，如：</p>\n<pre><code class=\"language-java\">Offer offer = <span class=\"hljs-keyword\">null</span>;\n<span class=\"hljs-keyword\">try</span> {\n    offer = offerService.findOffer(offerId);\n} <span class=\"hljs-keyword\">catch</span> (RpcException e) {\n   logger.error(e);\n}\n</code></pre>\n<p>请考虑改为 Mock 实现，并在 Mock 实现中 return null。如果只是想简单的忽略异常，在 <code>2.0.11</code> 以上版本可用：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.foo.BarService\"</span> <span class=\"hljs-attr\">mock</span>=<span class=\"hljs-string\">\"return null\"</span> /&gt;</span>\n</code></pre>\n<h2>进阶用法</h2>\n<h3>return</h3>\n<p>使用 <code>return</code> 来返回一个字符串表示的对象，作为 Mock 的返回值。合法的字符串可以是：</p>\n<ul>\n<li><em>empty</em>: 代表空，基本类型的默认值，或者集合类的空值</li>\n<li><em>null</em>: <code>null</code></li>\n<li><em>true</em>: <code>true</code></li>\n<li><em>false</em>: <code>false</code></li>\n<li><em>JSON 格式</em>: 反序列化 JSON 所得到的对象</li>\n</ul>\n<h3>throw</h3>\n<p>使用 <code>throw</code> 来返回一个 Exception 对象，作为 Mock 的返回值。</p>\n<p>当调用出错时，抛出一个默认的 RPCException:</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.foo.BarService\"</span> <span class=\"hljs-attr\">mock</span>=<span class=\"hljs-string\">\"throw\"</span> /&gt;</span>\n</code></pre>\n<p>当调用出错时，抛出指定的 Exception：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.foo.BarService\"</span> <span class=\"hljs-attr\">mock</span>=<span class=\"hljs-string\">\"throw com.foo.MockException\"</span> /&gt;</span>\n</code></pre>\n<h3>force 和 fail</h3>\n<p>在 <code>2.6.6</code> 以上的版本，可以开始在 Spring XML 配置文件中使用 <code>fail:</code> 和 <code>force:</code>。<code>force:</code> 代表强制使用 Mock 行为，在这种情况下不会走远程调用。<code>fail:</code> 与默认行为一致，只有当远程调用发生错误时才使用 Mock 行为。<code>force:</code> 和 <code>fail:</code> 都支持与 <code>throw</code> 或者 <code>return</code> 组合使用。</p>\n<p>强制返回指定值：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.foo.BarService\"</span> <span class=\"hljs-attr\">mock</span>=<span class=\"hljs-string\">\"force:return fake\"</span> /&gt;</span>\n</code></pre>\n<p>强制抛出指定异常：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.foo.BarService\"</span> <span class=\"hljs-attr\">mock</span>=<span class=\"hljs-string\">\"force:throw com.foo.MockException\"</span> /&gt;</span>\n</code></pre>\n<h3>在方法级别配置 Mock</h3>\n<p>Mock 可以在方法级别上指定，假定 <code>com.foo.BarService</code> 上有好几个方法，我们可以单独为 <code>sayHello()</code> 方法指定 Mock 行为。具体配置如下所示，在本例中，只要 <code>sayHello()</code> 被调用到时，强制返回 &quot;fake&quot;:</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">check</span>=<span class=\"hljs-string\">\"false\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.foo.BarService\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:parameter</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">\"sayHello.mock\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"force:return fake\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dubbo:reference</span>&gt;</span>\n</code></pre>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>Mock 是 Stub 的一个子集，便于服务提供方在客户端执行容错逻辑，因经常需要在出现 RpcException (比如网络失败，超时等)时进行容错，而在出现业务异常(比如登录用户名密码错误)时不需要容错，如果用 Stub，可能就需要捕获并依赖 RpcException 类，而用 Mock 就可以不依赖 RpcException，因为它的约定就是只有出现 RpcException 时才执行。 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>在 interface 旁放一个 Mock 实现，它实现 BarService 接口，并有一个无参构造函数 <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
  "link": "/zh-cn/docs/user/demos/local-mock.html",
  "meta": {}
}