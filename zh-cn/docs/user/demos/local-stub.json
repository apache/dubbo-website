{
  "filename": "local-stub.md",
  "__html": "<h1>本地存根</h1>\n<p>远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，比如：做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。</p>\n<p><img src=\"../sources/images/stub.jpg\" alt=\"/user-guide/images/stub.jpg\"></p>\n<p>在 spring 配置文件中按以下方式配置：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.foo.BarService\"</span> <span class=\"hljs-attr\">stub</span>=<span class=\"hljs-string\">\"true\"</span> /&gt;</span>\n</code></pre>\n<p>或</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"com.foo.BarService\"</span> <span class=\"hljs-attr\">stub</span>=<span class=\"hljs-string\">\"com.foo.BarServiceStub\"</span> /&gt;</span>\n</code></pre>\n<p>提供 Stub 的实现 <sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> com.foo;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BarServiceStub</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">BarService</span> </span>{ \n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> BarService barService;\n    \n    <span class=\"hljs-comment\">// 构造函数传入真正的远程代理对象</span>\n    <span class=\"hljs-keyword\">public</span> (BarService barService) {\n        <span class=\"hljs-keyword\">this</span>.barService = barService;\n    }\n \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-comment\">// 此代码在客户端执行, 你可以在客户端做ThreadLocal本地缓存，或预先验证参数是否合法，等等</span>\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">return</span> barService.sayHello(name);\n        } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n            <span class=\"hljs-comment\">// 你可以容错，可以做任何AOP拦截事项</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"容错数据\"</span>;\n        }\n    }\n}\n</code></pre>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>Stub 必须有可传入 Proxy 的构造函数。 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>在 interface 旁边放一个 Stub 实现，它实现 BarService 接口，并有一个传入远程 BarService 实例的构造函数 <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n"
}