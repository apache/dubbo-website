{
  "filename": "reference-config-cache.md",
  "__html": "<h1>ReferenceConfig 缓存</h1>\n<p><code>ReferenceConfig</code> 实例很重，封装了与注册中心的连接以及与提供者的连接，需要缓存。否则重复生成 <code>ReferenceConfig</code> 可能造成性能问题并且会有内存和连接泄漏。在 API 方式编程时，容易忽略此问题。</p>\n<p>因此，自 <code>2.4.0</code> 版本开始， dubbo 提供了简单的工具类 <code>ReferenceConfigCache</code>用于缓存 <code>ReferenceConfig</code> 实例。</p>\n<p>使用方式如下：</p>\n<pre><code class=\"language-java\">ReferenceConfig&lt;XxxService&gt; reference = <span class=\"hljs-keyword\">new</span> ReferenceConfig&lt;XxxService&gt;();\nreference.setInterface(XxxService.class);\nreference.setVersion(<span class=\"hljs-string\">\"1.0.0\"</span>);\n......\nReferenceConfigCache cache = ReferenceConfigCache.getCache();\n<span class=\"hljs-comment\">// cache.get方法中会缓存 Reference对象，并且调用ReferenceConfig.get方法启动ReferenceConfig</span>\nXxxService xxxService = cache.get(reference);\n<span class=\"hljs-comment\">// 注意！ Cache会持有ReferenceConfig，不要在外部再调用ReferenceConfig的destroy方法，导致Cache内的ReferenceConfig失效！</span>\n<span class=\"hljs-comment\">// 使用xxxService对象</span>\nxxxService.sayHello();\n</code></pre>\n<p>消除 Cache 中的 <code>ReferenceConfig</code>，将销毁 <code>ReferenceConfig</code> 并释放对应的资源。</p>\n<pre><code class=\"language-java\">ReferenceConfigCache cache = ReferenceConfigCache.getCache();\ncache.destroy(reference);\n</code></pre>\n<p>缺省 <code>ReferenceConfigCache</code> 把相同服务 Group、接口、版本的 <code>ReferenceConfig</code> 认为是相同，缓存一份。即以服务 Group、接口、版本为缓存的 Key。</p>\n<p>可以修改这个策略，在 <code>ReferenceConfigCache.getCache</code> 时，传一个 <code>KeyGenerator</code>。详见 <code>ReferenceConfigCache</code> 类的方法。</p>\n<pre><code class=\"language-java\">KeyGenerator keyGenerator = <span class=\"hljs-keyword\">new</span> ...\nReferenceConfigCache cache = ReferenceConfigCache.getCache(keyGenerator );\n</code></pre>\n"
}