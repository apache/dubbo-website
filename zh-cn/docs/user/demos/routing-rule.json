{
  "filename": "routing-rule.md",
  "__html": "<h1>路由规则</h1>\n<p>路由规则 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup> 决定一次 dubbo 服务调用的目标服务器，分为条件路由规则和脚本路由规则，并且支持可扩展 <sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup>。</p>\n<h2>写入路由规则</h2>\n<p>向注册中心写入路由规则的操作通常由监控中心或治理中心的页面完成</p>\n<pre><code class=\"language-java\">RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();\nRegistry registry = registryFactory.getRegistry(URL.valueOf(<span class=\"hljs-string\">\"zookeeper://10.20.153.10:2181\"</span>));\nregistry.register(URL.valueOf(<span class=\"hljs-string\">\"condition://0.0.0.0/com.foo.BarService?category=routers&amp;dynamic=false&amp;rule=\"</span> + URL.encode(<span class=\"hljs-string\">\"host = 10.20.153.10 =&gt; host = 10.20.153.11\"</span>)));\n</code></pre>\n<p>其中：</p>\n<ul>\n<li><code>condition://</code> 表示路由规则的类型，支持条件路由规则和脚本路由规则，可扩展，<strong>必填</strong>。</li>\n<li><code>0.0.0.0</code> 表示对所有 IP 地址生效，如果只想对某个 IP 的生效，请填入具体 IP，<strong>必填</strong>。</li>\n<li><code>com.foo.BarService</code> 表示只对指定服务生效，<strong>必填</strong>。</li>\n<li><code>group=foo</code> 对指定服务的指定group生效，不填表示对未配置group的指定服务生效</li>\n<li><code>version=1.0</code>对指定服务的指定version生效，不填表示对未配置version的指定服务生效</li>\n<li><code>category=routers</code> 表示该数据为动态配置类型，<strong>必填</strong>。</li>\n<li><code>dynamic=false</code> 表示该数据为持久数据，当注册方退出时，数据依然保存在注册中心，<strong>必填</strong>。</li>\n<li><code>enabled=true</code> 覆盖规则是否生效，可不填，缺省生效。</li>\n<li><code>force=false</code> 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为 <code>false</code>。</li>\n<li><code>runtime=false</code> 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。如果用了参数路由，必须设为 <code>true</code>，需要注意设置会影响调用的性能，可不填，缺省为 <code>false</code>。</li>\n<li><code>priority=1</code> 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为 <code>0</code>。</li>\n<li><code>rule=URL.encode(&quot;host = 10.20.153.10 =&gt; host = 10.20.153.11&quot;)</code> 表示路由规则的内容，<strong>必填</strong>。</li>\n</ul>\n<h2>条件路由规则</h2>\n<p>基于条件表达式的路由规则，如：<code>host = 10.20.153.10 =&gt; host = 10.20.153.11</code></p>\n<h3>规则：</h3>\n<ul>\n<li><code>=&gt;</code> 之前的为消费者匹配条件，所有参数和消费者的 URL 进行对比，当消费者满足匹配条件时，对该消费者执行后面的过滤规则。</li>\n<li><code>=&gt;</code> 之后为提供者地址列表的过滤条件，所有参数和提供者的 URL 进行对比，消费者最终只拿到过滤后的地址列表。</li>\n<li>如果匹配条件为空，表示对所有消费方应用，如：<code>=&gt; host != 10.20.153.11</code></li>\n<li>如果过滤条件为空，表示禁止访问，如：<code>host = 10.20.153.10 =&gt;</code></li>\n</ul>\n<h3>表达式：</h3>\n<p>参数支持：</p>\n<ul>\n<li>服务调用信息，如：method, argument 等，暂不支持参数路由</li>\n<li>URL 本身的字段，如：protocol, host, port 等</li>\n<li>以及 URL 上的所有参数，如：application, organization 等</li>\n</ul>\n<p>条件支持：</p>\n<ul>\n<li>等号 <code>=</code> 表示&quot;匹配&quot;，如：<code>host = 10.20.153.10</code></li>\n<li>不等号 <code>!=</code> 表示&quot;不匹配&quot;，如：<code>host != 10.20.153.10</code></li>\n</ul>\n<p>值支持：</p>\n<ul>\n<li>以逗号 <code>,</code> 分隔多个值，如：<code>host != 10.20.153.10,10.20.153.11</code></li>\n<li>以星号 <code>*</code> 结尾，表示通配，如：<code>host != 10.20.*</code></li>\n<li>以美元符 <code>$</code> 开头，表示引用消费者参数，如：<code>host = $host</code></li>\n</ul>\n<h3>示例：</h3>\n<ol start=\"0\">\n<li>\n<p>排除预发布机：</p>\n<pre><code>=&gt; host != 172.22.3.91\n</code></pre>\n</li>\n<li>\n<p>白名单 <sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>：</p>\n<pre><code>host != 10.20.153.10,10.20.153.11 =&gt;\n</code></pre>\n</li>\n<li>\n<p>黑名单：</p>\n<pre><code>host = 10.20.153.10,10.20.153.11 =&gt;\n</code></pre>\n</li>\n<li>\n<p>服务寄宿在应用上，只暴露一部分的机器，防止整个集群挂掉：</p>\n<pre><code>=&gt; host = 172.22.3.1*,172.22.3.2*\n</code></pre>\n</li>\n<li>\n<p>为重要应用提供额外的机器：</p>\n<pre><code>application != kylin =&gt; host != 172.22.3.95,172.22.3.96\n</code></pre>\n</li>\n<li>\n<p>读写分离：</p>\n<pre><code>method = find*,list*,get*,is* =&gt; host = 172.22.3.94,172.22.3.95,172.22.3.96\nmethod != find*,list*,get*,is* =&gt; host = 172.22.3.97,172.22.3.98\n</code></pre>\n</li>\n<li>\n<p>前后台分离：</p>\n<pre><code>application = bops =&gt; host = 172.22.3.91,172.22.3.92,172.22.3.93\napplication != bops =&gt; host = 172.22.3.94,172.22.3.95,172.22.3.96\n</code></pre>\n</li>\n<li>\n<p>隔离不同机房网段：</p>\n<pre><code>host != 172.22.3.* =&gt; host != 172.22.3.*\n</code></pre>\n</li>\n<li>\n<p>提供者与消费者部署在同集群内，本机只访问本机的服务：</p>\n<pre><code>=&gt; host = $host\n</code></pre>\n</li>\n</ol>\n<h2>脚本路由规则</h2>\n<p>脚本路由规则 <sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup> 支持 JDK 脚本引擎的所有脚本，比如：javascript, jruby, groovy 等，通过 <code>type=javascript</code> 参数设置脚本类型，缺省为 javascript。</p>\n<pre><code>&quot;script://0.0.0.0/com.foo.BarService?category=routers&amp;dynamic=false&amp;rule=&quot; + URL.encode(&quot;（function route(invokers) { ... } (invokers)）&quot;)\n</code></pre>\n<p>基于脚本引擎的路由规则，如：</p>\n<pre><code class=\"language-javascript\">（<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">route</span>(<span class=\"hljs-params\">invokers</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> result = <span class=\"hljs-keyword\">new</span> java.util.ArrayList(invokers.size());\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; invokers.size(); i ++) {\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">\"10.20.153.10\"</span>.equals(invokers.get(i).getUrl().getHost())) {\n            result.add(invokers.get(i));\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> result;\n} (invokers)）; <span class=\"hljs-comment\">// 表示立即执行方法</span>\n</code></pre>\n<h2>标签路由规则</h2>\n<p>标签路由规则 <sup class=\"footnote-ref\"><a href=\"#fn5\" id=\"fnref5\">[5]</a></sup> ，当应用选择装配标签路由(TagRouter)之后，一次 dubbo 调用能够根据请求携带的 tag 标签智能地选择对应 tag 的服务提供者进行调用。</p>\n<h3>服务提供者</h3>\n<ol>\n<li>给应用装配标签路由器：</li>\n</ol>\n<pre><code class=\"language-Java\"><span class=\"hljs-meta\">@Bean</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ApplicationConfig <span class=\"hljs-title\">applicationConfig</span><span class=\"hljs-params\">()</span> </span>{\n    ApplicationConfig applicationConfig = <span class=\"hljs-keyword\">new</span> ApplicationConfig();\n    applicationConfig.setName(<span class=\"hljs-string\">\"provider-book\"</span>);\n    applicationConfig.setQosEnable(<span class=\"hljs-keyword\">false</span>);\n    <span class=\"hljs-comment\">// instruct tag router</span>\n    Map&lt;String,String&gt; parameters = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();\n    parameters.put(Constants.ROUTER_KEY, <span class=\"hljs-string\">\"tag\"</span>);\n    applicationConfig.setParameters(parameters);\n    <span class=\"hljs-keyword\">return</span> applicationConfig;\n}\n</code></pre>\n<ol start=\"2\">\n<li>给应用设置具体的标签：</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Bean</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ProviderConfig <span class=\"hljs-title\">providerConfig</span><span class=\"hljs-params\">()</span></span>{\n\tProviderConfig providerConfig = <span class=\"hljs-keyword\">new</span> ProviderConfig();\n\tproviderConfig.setTag(<span class=\"hljs-string\">\"red\"</span>);\n\t<span class=\"hljs-keyword\">return</span> providerConfig;\n}\n</code></pre>\n<p>应用未装配 tag 属性或服务提供者未设置 tag 属性，都将被认为是默认的应用，这些默认应用将会在调用无法匹配 provider 时当作降级方案。</p>\n<h3>服务消费者</h3>\n<pre><code class=\"language-Java\">RpcContext.getContext().setAttachment(Constants.REQUEST_TAG_KEY,<span class=\"hljs-string\">\"red\"</span>);\n</code></pre>\n<p>请求标签的作用域为每一次 invocation，使用 attachment 来传递请求标签，注意保存在 attachment 中的值将会在一次完整的远程调用中持续传递，得益于这样的特性，我们只需要在起始调用时，通过一行代码的设置，达到标签的持续传递。</p>\n<blockquote>\n<p>目前仅仅支持 hardcoding 的方式设置 requestTag。注意到 RpcContext 是线程绑定的，优雅的使用 TagRouter 特性，建议通过 servlet 过滤器(在 web 环境下)，或者定制的 SPI 过滤器设置 requestTag。</p>\n</blockquote>\n<h3>规则描述</h3>\n<ol>\n<li>\n<p>request.tag=red 时优先选择 tag=red 的 provider。若集群中不存在与请求标记对应的服务，可以降级请求 tag=null 的 provider，即默认 provider。</p>\n</li>\n<li>\n<p>request.tag=null 时，只会匹配 tag=null 的 provider。即使集群中存在可用的服务，若 tag 不匹配就无法调用，这与规则1不同，携带标签的请求可以降级访问到无标签的服务，但不携带标签/携带其他种类标签的请求永远无法访问到其他标签的服务。</p>\n</li>\n</ol>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><code>2.2.0</code> 以上版本支持 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>路由规则扩展点：<a href=\"http://dubbo.apache.org/zh-cn/docs/dev/impls/router.html\">路由扩展</a> <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>注意：一个服务只能有一条白名单规则，否则两条规则交叉，就都被筛选掉了 <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p>注意：脚本没有沙箱约束，可执行任意代码，存在后门风险 <a href=\"#fnref4\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn5\" class=\"footnote-item\"><p>该特性在 <code>2.7.0</code> 以上版本支持 <a href=\"#fnref5\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
  "link": "/zh-cn/docs/user/demos/routing-rule.html",
  "meta": {}
}