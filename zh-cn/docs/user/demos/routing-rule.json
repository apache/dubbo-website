{
  "filename": "routing-rule.md",
  "__html": "<h1>路由规则</h1>\n<p>在此查看<a href=\"./routing-rule-deprecated.md\">老版本路由规则(2.6.x or before)</a></p>\n<p>路由规则在发起一次RPC调用前起到过滤目标服务器地址的作用，过滤后的地址列表，将作为消费端最终发起RPC调用的备选地址。</p>\n<ul>\n<li>条件路由。支持以服务或Consumer应用为粒度配置路由规则。</li>\n<li>标签路由。以Provider应用为粒度配置路由规则。</li>\n</ul>\n<p>后续我们计划在2.6.x版本的基础上继续增强脚本路由功能，老版本脚本路由规则配置方式请参见开篇链接。</p>\n<h2>条件路由</h2>\n<p>您可以随时在服务治理控制台<a href=\"https://github.com/apache/incubator-dubbo-admin\">Dubbo-Admin</a>写入路由规则</p>\n<h3>简介</h3>\n<ul>\n<li>\n<p>应用粒度</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-comment\"># app1的消费者只能消费所有端口为20880的服务实例</span>\n<span class=\"hljs-comment\"># app2的消费者只能消费所有端口为20881的服务实例</span>\n<span class=\"hljs-meta\">---</span>\n<span class=\"hljs-attr\">scope:</span> <span class=\"hljs-string\">application</span>\n<span class=\"hljs-attr\">force:</span> <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-attr\">runtime:</span> <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-attr\">enabled:</span> <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">governance-conditionrouter-consumer</span>\n<span class=\"hljs-attr\">conditions:</span>\n<span class=\"hljs-bullet\">  -</span> <span class=\"hljs-string\">application=app1</span> <span class=\"hljs-string\">=&gt;</span> <span class=\"hljs-string\">address=*:20880</span>\n<span class=\"hljs-bullet\">  -</span> <span class=\"hljs-string\">application=app2</span> <span class=\"hljs-string\">=&gt;</span> <span class=\"hljs-string\">address=*:20881</span>\n<span class=\"hljs-string\">...</span>\n</code></pre>\n</li>\n<li>\n<p>服务粒度</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-comment\"># DemoService的sayHello方法只能消费所有端口为20880的服务实例</span>\n<span class=\"hljs-comment\"># DemoService的sayHi方法只能消费所有端口为20881的服务实例</span>\n<span class=\"hljs-meta\">---</span>\n<span class=\"hljs-attr\">scope:</span> <span class=\"hljs-string\">service</span>\n<span class=\"hljs-attr\">force:</span> <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-attr\">runtime:</span> <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-attr\">enabled:</span> <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">org.apache.dubbo.samples.governance.api.DemoService</span>\n<span class=\"hljs-attr\">conditions:</span>\n<span class=\"hljs-bullet\">  -</span> <span class=\"hljs-string\">method=sayHello</span> <span class=\"hljs-string\">=&gt;</span> <span class=\"hljs-string\">address=*:20880</span>\n<span class=\"hljs-bullet\">  -</span> <span class=\"hljs-string\">method=sayHi</span> <span class=\"hljs-string\">=&gt;</span> <span class=\"hljs-string\">address=*:20881</span>\n<span class=\"hljs-string\">...</span>\n</code></pre>\n</li>\n</ul>\n<h3>规则详解</h3>\n<h4>各字段含义</h4>\n<ul>\n<li><code>scope</code>表示路由规则的作用粒度，scope的取值会决定key的取值。<strong>必填</strong>。\n<ul>\n<li>service 务粒度</li>\n<li>application 应用粒度</li>\n</ul>\n</li>\n<li><code>Key</code>明确规则体作用在哪个服务或应用。<strong>必填</strong>。\n<ul>\n<li>scope=service时，key取值为[{group}:]{service}[:{version}]的组合</li>\n<li>scope=application时，key取值为application名称</li>\n</ul>\n</li>\n<li><code>enabled=true</code> 当前路由规则是否生效，可不填，缺省生效。</li>\n<li><code>force=false</code> 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为 <code>false</code>。</li>\n<li><code>runtime=false</code> 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。如果用了参数路由，必须设为 <code>true</code>，需要注意设置会影响调用的性能，可不填，缺省为 <code>false</code>。</li>\n<li><code>priority=1</code> 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为 <code>0</code>。</li>\n<li><code>conditions</code> 定义具体的路由规则内容。<strong>必填</strong>。</li>\n</ul>\n<h4>Conditions规则体</h4>\n<pre><code>`conditions`部分是规则的主体，由1到任意多条规则组成，下面我们就每个规则的配置语法做详细说明：\n</code></pre>\n<ol>\n<li><strong>格式</strong></li>\n</ol>\n<ul>\n<li><code>=&gt;</code> 之前的为消费者匹配条件，所有参数和消费者的 URL 进行对比，当消费者满足匹配条件时，对该消费者执行后面的过滤规则。</li>\n<li><code>=&gt;</code> 之后为提供者地址列表的过滤条件，所有参数和提供者的 URL 进行对比，消费者最终只拿到过滤后的地址列表。</li>\n<li>如果匹配条件为空，表示对所有消费方应用，如：<code>=&gt; host != 10.20.153.11</code></li>\n<li>如果过滤条件为空，表示禁止访问，如：<code>host = 10.20.153.10 =&gt;</code></li>\n</ul>\n<ol start=\"2\">\n<li><strong>表达式</strong></li>\n</ol>\n<p>参数支持：</p>\n<ul>\n<li>服务调用信息，如：method, argument 等，暂不支持参数路由</li>\n<li>URL 本身的字段，如：protocol, host, port 等</li>\n<li>以及 URL 上的所有参数，如：application, organization 等</li>\n</ul>\n<p>条件支持：</p>\n<ul>\n<li>等号 <code>=</code> 表示&quot;匹配&quot;，如：<code>host = 10.20.153.10</code></li>\n<li>不等号 <code>!=</code> 表示&quot;不匹配&quot;，如：<code>host != 10.20.153.10</code></li>\n</ul>\n<p>值支持：</p>\n<ul>\n<li>以逗号 <code>,</code> 分隔多个值，如：<code>host != 10.20.153.10,10.20.153.11</code></li>\n<li>以星号 <code>*</code> 结尾，表示通配，如：<code>host != 10.20.*</code></li>\n<li>以美元符 <code>$</code> 开头，表示引用消费者参数，如：<code>host = $host</code></li>\n</ul>\n<ol start=\"3\">\n<li><strong>Condition示例</strong></li>\n</ol>\n<ul>\n<li>排除预发布机：</li>\n</ul>\n<pre><code>=&gt; host != 172.22.3.91\n</code></pre>\n<ul>\n<li>白名单 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>：</li>\n</ul>\n<pre><code>host != 10.20.153.10,10.20.153.11 =&gt;\n</code></pre>\n<ul>\n<li>黑名单：</li>\n</ul>\n<pre><code>host = 10.20.153.10,10.20.153.11 =&gt;\n</code></pre>\n<ul>\n<li>服务寄宿在应用上，只暴露一部分的机器，防止整个集群挂掉：</li>\n</ul>\n<pre><code>=&gt; host = 172.22.3.1*,172.22.3.2*\n</code></pre>\n<ul>\n<li>为重要应用提供额外的机器：</li>\n</ul>\n<pre><code>application != kylin =&gt; host != 172.22.3.95,172.22.3.96\n</code></pre>\n<ul>\n<li>读写分离：</li>\n</ul>\n<pre><code>method = find*,list*,get*,is* =&gt; host = 172.22.3.94,172.22.3.95,172.22.3.96\nmethod != find*,list*,get*,is* =&gt; host = 172.22.3.97,172.22.3.98\n</code></pre>\n<ul>\n<li>前后台分离：</li>\n</ul>\n<pre><code>application = bops =&gt; host = 172.22.3.91,172.22.3.92,172.22.3.93\napplication != bops =&gt; host = 172.22.3.94,172.22.3.95,172.22.3.96\n</code></pre>\n<ul>\n<li>隔离不同机房网段：</li>\n</ul>\n<pre><code>host != 172.22.3.* =&gt; host != 172.22.3.*\n</code></pre>\n<ul>\n<li>提供者与消费者部署在同集群内，本机只访问本机的服务：</li>\n</ul>\n<pre><code>=&gt; host = $host\n</code></pre>\n<h2>标签路由规则</h2>\n<h3>简介</h3>\n<p>标签路由通过将某一个或多个服务的提供者划分到同一个分组，约束流量只在指定分组中流转，从而实现流量隔离的目的，可以作为蓝绿发布、灰度发布等场景的能力基础。</p>\n<h4>Provider</h4>\n<p>标签主要是指对Provider端应用实例的分组，目前有两种方式可以完成实例分组，分别是<code>动态规则打标</code>和<code>静态规则打标</code>，其中动态规则相较于静态规则优先级更高，而当两种规则同时存在且出现冲突时，将以动态规则为准。</p>\n<ul>\n<li>\n<p>动态规则打标，可随时在<a href=\"\">服务治理控制台</a>下发标签归组规则</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-comment\"># governance-tagrouter-provider应用增加了两个标签分组tag1和tag2</span>\n<span class=\"hljs-comment\"># tag1包含一个实例 127.0.0.1:20880</span>\n<span class=\"hljs-comment\"># tag2包含一个实例 127.0.0.1:20881</span>\n<span class=\"hljs-meta\">---</span>\n<span class=\"hljs-attr\">  force:</span> <span class=\"hljs-literal\">false</span>\n<span class=\"hljs-attr\">  runtime:</span> <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-attr\">  enabled:</span> <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-attr\">  key:</span> <span class=\"hljs-string\">governance-tagrouter-provider</span>\n<span class=\"hljs-attr\">  tags:</span>\n<span class=\"hljs-attr\">    - name:</span> <span class=\"hljs-string\">tag1</span>\n<span class=\"hljs-attr\">      addresses:</span> <span class=\"hljs-string\">[\"127.0.0.1:20880\"]</span>\n<span class=\"hljs-attr\">    - name:</span> <span class=\"hljs-string\">tag2</span>\n<span class=\"hljs-attr\">      addresses:</span> <span class=\"hljs-string\">[\"127.0.0.1:20881\"]</span>\n <span class=\"hljs-string\">...</span>\n</code></pre>\n</li>\n<li>\n<p>静态打标</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:provider</span> <span class=\"hljs-attr\">tag</span>=<span class=\"hljs-string\">\"tag1\"</span>/&gt;</span>\n</code></pre>\n<p>or</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">tag</span>=<span class=\"hljs-string\">\"tag1\"</span>/&gt;</span>\n</code></pre>\n<p>or</p>\n<pre><code class=\"language-properties\"><span class=\"hljs-attr\">java</span> <span class=\"hljs-string\">-jar xxx-provider.jar -Ddubbo.provider.tag={the tag you want, may come from OS ENV}</span>\n</code></pre>\n</li>\n</ul>\n<h4>Consumer</h4>\n<pre><code class=\"language-java\">RpcContext.getContext().setAttachment(Constants.REQUEST_TAG_KEY,<span class=\"hljs-string\">\"tag1\"</span>);\n</code></pre>\n<p>请求标签的作用域为每一次 invocation，使用 attachment 来传递请求标签，注意保存在 attachment 中的值将会在一次完整的远程调用中持续传递，得益于这样的特性，我们只需要在起始调用时，通过一行代码的设置，达到标签的持续传递。</p>\n<blockquote>\n<p>目前仅仅支持 hardcoding 的方式设置 requestTag。注意到 RpcContext 是线程绑定的，优雅的使用 TagRouter 特性，建议通过 servlet 过滤器(在 web 环境下)，或者定制的 SPI 过滤器设置 requestTag。</p>\n</blockquote>\n<h3>规则详解</h3>\n<h4>格式</h4>\n<ul>\n<li><code>Key</code>明确规则体作用到哪个应用。<strong>必填</strong>。</li>\n<li><code>enabled=true</code> 当前路由规则是否生效，可不填，缺省生效。</li>\n<li><code>force=false</code> 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为 <code>false</code>。</li>\n<li><code>runtime=false</code> 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。如果用了参数路由，必须设为 <code>true</code>，需要注意设置会影响调用的性能，可不填，缺省为 <code>false</code>。</li>\n<li><code>priority=1</code> 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为 <code>0</code>。</li>\n<li><code>tags</code> 定义具体的标签分组内容，可定义任意n（n&gt;=1）个标签并为每个标签指定实例列表。<strong>必填</strong>。\n<ul>\n<li>name， 标签名称</li>\n</ul>\n</li>\n<li>addresses， 当前标签包含的实例列表</li>\n</ul>\n<h4>降级约定</h4>\n<ol>\n<li>\n<p><code>request.tag=tag1</code> 时优先选择 标记了<code>tag=tag1</code> 的 provider。若集群中不存在与请求标记对应的服务，默认将降级请求 tag为空的provider；如果要该表这种默认行为，即找不到匹配tag1的provider返回异常，需设置<code>request.tag.force=true</code>。</p>\n</li>\n<li>\n<p><code>request.tag</code>未设置时，只会匹配tag为空的provider。即使集群中存在可用的服务，若 tag 不匹配也就无法调用，这与约定1不同，携带标签的请求可以降级访问到无标签的服务，但不携带标签/携带其他种类标签的请求永远无法访问到其他标签的服务。</p>\n</li>\n</ol>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>注意：一个服务只能有一条白名单规则，否则两条规则交叉，就都被筛选掉了 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
  "link": "/zh-cn/docs/user/demos/routing-rule.html",
  "meta": {}
}