{
  "filename": "thread-model.md",
  "__html": "<h1>线程模型</h1>\n<p>如果事件处理的逻辑能迅速完成，并且不会发起新的 IO 请求，比如只是在内存中记个标识，则直接在 IO 线程上处理更快，因为减少了线程池调度。</p>\n<p>但如果事件处理逻辑较慢，或者需要发起新的 IO 请求，比如需要查询数据库，则必须派发到线程池，否则 IO 线程阻塞，将导致不能接收其它请求。</p>\n<p>如果用 IO 线程处理事件，又在事件处理过程中发起新的 IO 请求，比如在连接事件中发起登录请求，会报“可能引发死锁”异常，但不会真死锁。</p>\n<p><img src=\"../sources/images/dubbo-protocol.jpg\" alt=\"dubbo-protocol\"></p>\n<p>因此，需要通过不同的派发策略和不同的线程池配置的组合来应对不同的场景:</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"dubbo\"</span> <span class=\"hljs-attr\">dispatcher</span>=<span class=\"hljs-string\">\"all\"</span> <span class=\"hljs-attr\">threadpool</span>=<span class=\"hljs-string\">\"fixed\"</span> <span class=\"hljs-attr\">threads</span>=<span class=\"hljs-string\">\"100\"</span> /&gt;</span>\n</code></pre>\n<p>Dispatcher</p>\n<ul>\n<li><code>all</code> 所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等。</li>\n<li><code>direct</code> 所有消息都不派发到线程池，全部在 IO 线程上直接执行。</li>\n<li><code>message</code> 只有请求响应消息派发到线程池，其它连接断开事件，心跳等消息，直接在 IO 线程上执行。</li>\n<li><code>execution</code> 只请求消息派发到线程池，不含响应，响应和其它连接断开事件，心跳等消息，直接在 IO 线程上执行。</li>\n<li><code>connection</code> 在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池。</li>\n</ul>\n<p>ThreadPool</p>\n<ul>\n<li><code>fixed</code> 固定大小线程池，启动时建立线程，不关闭，一直持有。(缺省)</li>\n<li><code>cached</code> 缓存线程池，空闲一分钟自动删除，需要时重建。</li>\n<li><code>limited</code> 可伸缩线程池，但池中的线程数只会增长不会收缩。只增长不收缩的目的是为了避免收缩时突然来了大流量引起的性能问题。</li>\n<li><code>eager</code> 优先创建<code>Worker</code>线程池。在任务数量大于<code>corePoolSize</code>但是小于<code>maximumPoolSize</code>时，优先创建<code>Worker</code>来处理任务。当任务数量大于<code>maximumPoolSize</code>时，将任务放入阻塞队列中。阻塞队列充满时抛出<code>RejectedExecutionException</code>。(相比于<code>cached</code>:<code>cached</code>在任务数量超过<code>maximumPoolSize</code>时直接抛出异常而不是将任务放入阻塞队列)</li>\n</ul>\n"
}