<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="rest" />
	<meta name="description" content="rest" />
	<!-- 网页标签标题 -->
	<title>rest</title>
	<link rel="shortcut icon" href="/img/dubbo.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/dubbo_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/user/quick-start.html">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/docs/developers/developers_dev.html">开发者</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html">博客</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html">社区</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/download.html">下载</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/docs.png" class="front-img"/><span>文档</span><img src="/img/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>用户文档</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>入门<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/background.html" target="_self">背景</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/requirements.html" target="_self">需求</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/architecture.html" target="_self">架构</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/usage.html" target="_self">用法</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/quick-start.html" target="_self">快速启动</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/dependencies.html" target="_self">依赖</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/maturity.html" target="_self">成熟度</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>配置<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/xml.html" target="_self">XML配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/api.html" target="_self">API配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/annotation.html" target="_self">注解配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/config-center.html" target="_self">动态配置中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/configuration-load-process.html" target="_self">配置加载流程</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>示例<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/preflight-check.html" target="_self">启动时检查</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/fault-tolerent-strategy.html" target="_self">集群容错</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/loadbalance.html" target="_self">负载均衡</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/thread-model.html" target="_self">线程模型</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/explicit-target.html" target="_self">直连提供者</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/subscribe-only.html" target="_self">只订阅</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/registry-only.html" target="_self">只注册</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/static-service.html" target="_self">静态服务</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/multi-protocols.html" target="_self">多协议</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/multi-registry.html" target="_self">多注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/service-group.html" target="_self">服务分组</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/multi-versions.html" target="_self">多版本</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/group-merger.html" target="_self">分组聚合</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/parameter-validation.html" target="_self">参数验证</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/result-cache.html" target="_self">结果缓存</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/generic-reference.html" target="_self">泛化引用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/generic-service.html" target="_self">泛化实现</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/echo-service.html" target="_self">回声测试</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/context.html" target="_self">上下文信息</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/attachment.html" target="_self">隐式参数</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/async-call.html" target="_self">Consumer异步调用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/async-execute-on-provider.html" target="_self">Provider异步执行</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/local-call.html" target="_self">本地调用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/callback-parameter.html" target="_self">参数回调</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/events-notify.html" target="_self">事件通知</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/local-stub.html" target="_self">本地存根</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/local-mock.html" target="_self">本地伪装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/delay-publish.html" target="_self">延迟暴露</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/concurrency-control.html" target="_self">并发控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/config-connections.html" target="_self">连接控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/lazy-connect.html" target="_self">延迟连接</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/stickiness.html" target="_self">粘滞连接</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/token-authorization.html" target="_self">令牌验证</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/routing-rule.html" target="_self">路由规则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/config-rule.html" target="_self">配置规则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/service-downgrade.html" target="_self">服务降级</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/graceful-shutdown.html" target="_self">优雅停机</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/hostname-binding.html" target="_self">主机绑定</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/logger-strategy.html" target="_self">日志适配</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/accesslog.html" target="_self">访问日志</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/service-container.html" target="_self">服务容器</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/reference-config-cache.html" target="_self">Reference Config 缓存</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/distributed-transaction.html" target="_self">分布式事务</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/dump.html" target="_self">线程栈自动dump</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/netty4.html" target="_self">Netty4</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/serialization.html" target="_self">Kryo和FST序列化</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/simplify-registry-data.html" target="_self">简化注册中心URL</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/api.html" target="_self">API配置参考手册</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>schema配置参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-service.html" target="_self">dubbo:service</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-reference.html" target="_self">dubbo:reference</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-protocol.html" target="_self">dubbo:protocol</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-registry.html" target="_self">dubbo:registry</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-monitor.html" target="_self">dubbo:monitor</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-application.html" target="_self">dubbo:application</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-module.html" target="_self">dubbo:module</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-provider.html" target="_self">dubbo:provider</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-consumer.html" target="_self">dubbo:consumer</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-method.html" target="_self">dubbo:method</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-argument.html" target="_self">dubbo:argument</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-parameter.html" target="_self">dubbo:parameter</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-config-center.html" target="_self">dubbo:config-center</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>协议参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/dubbo.html" target="_self">dubbo://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/rmi.html" target="_self">rmi://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/hessian.html" target="_self">hessian://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/http.html" target="_self">http://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/webservice.html" target="_self">webservice://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/thrift.html" target="_self">thrift://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/memcached.html" target="_self">memcached://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/redis.html" target="_self">redis://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/rest.html" target="_self">rest://</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>注册中心参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/multicast.html" target="_self">Multicast 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/zookeeper.html" target="_self">Zookeeper 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/nacos.html" target="_self">Nacos 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/redis.html" target="_self">Redis 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/simple.html" target="_self">Simple 注册中心</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>元数据中心参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/metadata/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/metadata/metadata-redis.html" target="_self">Redis</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/metadata/metadata-zookeeper.html" target="_self">Zookeeper</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/telnet.html" target="_self">telnet命令参考手册</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/qos.html" target="_self">在线运维命令-QOS</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/maven.html" target="_self">maven插件参考手册</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/best-practice.html" target="_self">服务化最佳实践</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/recommend.html" target="_self">推荐用法</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/capacity-plan.html" target="_self">容量规划</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/perf-test.html" target="_self">性能测试报告</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/coveragence.html" target="_self">测试覆盖率报告</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>版本与升级<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/versions/version-270.html" target="_self">2.7.x升级步骤及注意事项</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>开发者指南</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/build.html" target="_self">源码构建</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/design.html" target="_self">框架设计</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/SPI.html" target="_self">扩展点加载</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/implementation.html" target="_self">实现细节</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>SPI 扩展实现<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/protocol.html" target="_self">协议扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/filter.html" target="_self">调用拦截扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/invoker-listener.html" target="_self">引用监听扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/exporter-listener.html" target="_self">暴露监听扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/cluster.html" target="_self">集群扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/router.html" target="_self">路由扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/load-balance.html" target="_self">负载均衡扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/merger.html" target="_self">合并结果扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/registry.html" target="_self">注册中心扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/monitor.html" target="_self">监控中心扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/extension-factory.html" target="_self">扩展点加载扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/proxy-factory.html" target="_self">动态代理扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/compiler.html" target="_self">编译器扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/dispatcher.html" target="_self">消息派发扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/threadpool.html" target="_self">线程池扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/serialize.html" target="_self">序列化扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/remoting.html" target="_self">网络传输扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/exchanger.html" target="_self">信息交换扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/networker.html" target="_self">组网扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/telnet-handler.html" target="_self">Telnet 命令扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/status-checker.html" target="_self">状态检查扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/container.html" target="_self">容器扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/page.html" target="_self">页面扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/cache.html" target="_self">缓存扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/validation.html" target="_self">验证扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/logger-adapter.html" target="_self">日志适配扩展</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/contract.html" target="_self">公共契约</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/coding.html" target="_self">编码约定</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>设计原则<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/code-detail.html" target="_self">魔鬼在细节</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/general-knowledge.html" target="_self">一些设计上的基本常识</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/expansibility.html" target="_self">谈谈扩充式扩展与增量式扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/configuration.html" target="_self">配置设计</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/robustness.html" target="_self">设计实现的健壮性</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/dummy.html" target="_self">防痴呆设计</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/extension.html" target="_self">扩展点重构</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/release.html" target="_self">版本管理</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/contribution.html" target="_self">贡献</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/checklist.html" target="_self">检查列表</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/code-smell.html" target="_self">坏味道</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/TCK.html" target="_self">技术兼容性测试</a></li></ul></li><li class="menu-item menu-item-level-1"><span>源码导读</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/dubbo-spi.html" target="_self">Dubbo SPI</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/adaptive-extension.html" target="_self">自适应拓展机制</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/export-service.html" target="_self">服务导出</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/refer-service.html" target="_self">服务引入</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/directory.html" target="_self">服务字典</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/router.html" target="_self">服务路由</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/cluster.html" target="_self">集群</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/loadbalance.html" target="_self">负载均衡</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/service-invoking-process.html" target="_self">服务调用过程</a></li></ul></li><li class="menu-item menu-item-level-1"><span>运维管理</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/admin/introduction.html" target="_self">控制台介绍</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/admin/serviceSearch.html" target="_self">服务搜索</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/admin/serviceGovernance.html" target="_self">服务治理</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/admin/serviceTest.html" target="_self">服务测试</a></li></ul></li></ul></div><div class="doc-content markdown-body"><h1>rest://</h1>
<p>基于标准的Java REST API——JAX-RS 2.0（Java API for RESTful Web Services的简写）实现的REST调用支持</p>
<h2>快速入门</h2>
<p>在dubbo中开发一个REST风格的服务会比较简单，下面以一个注册用户的简单服务为例说明。</p>
<p>这个服务要实现的功能是提供如下URL（注：这个URL不是完全符合REST的风格，但是更简单实用）：</p>
<pre><code>http://localhost:8080/users/register
</code></pre>
<p>而任何客户端都可以将包含用户信息的JSON字符串POST到以上URL来完成用户注册。</p>
<p>首先，开发服务的接口：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>{    
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerUser</span><span class="hljs-params">(User user)</span></span>;
}
</code></pre>
<p>然后，开发服务的实现：</p>
<pre><code class="language-java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>{
       
    <span class="hljs-meta">@POST</span>
    <span class="hljs-meta">@Path</span>(<span class="hljs-string">"register"</span>)
    <span class="hljs-meta">@Consumes</span>({MediaType.APPLICATION_JSON})
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerUser</span><span class="hljs-params">(User user)</span> </span>{
        <span class="hljs-comment">// save the user...</span>
    }
}
</code></pre>
<p>上面的实现非常简单，但是由于该 REST 服务是要发布到指定 URL 上，供任意语言的客户端甚至浏览器来访问，所以这里额外添加了几个 JAX-RS 的标准 annotation 来做相关的配置。</p>
<p>@Path(&quot;users&quot;)：指定访问UserService的URL相对路径是/users，即http://localhost:8080/users</p>
<p>@Path(&quot;register&quot;)：指定访问registerUser()方法的URL相对路径是/register，再结合上一个@Path为UserService指定的路径，则调用UserService.register()的完整路径为http://localhost:8080/users/register</p>
<p>@POST：指定访问registerUser()用HTTP POST方法</p>
<p>@Consumes({MediaType.APPLICATION_JSON})：指定registerUser()接收JSON格式的数据。REST框架会自动将JSON数据反序列化为User对象</p>
<p>最后，在spring配置文件中添加此服务，即完成所有服务开发工作：</p>
<pre><code class="language-xml"><span class="hljs-comment">&lt;!-- 用rest协议在8080端口暴露服务 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span>/&gt;</span>

<span class="hljs-comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"xxx.UserService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"userService"</span>/&gt;</span>

<span class="hljs-comment">&lt;!-- 和本地bean一样实现服务 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"xxx.UserServiceImpl"</span> /&gt;</span>
</code></pre>
<h2>REST服务提供端详解</h2>
<p>下面我们扩充“快速入门”中的UserService，进一步展示在dubbo中REST服务提供端的开发要点。</p>
<h3>HTTP POST/GET的实现</h3>
<p>REST服务中虽然建议使用HTTP协议中四种标准方法POST、DELETE、PUT、GET来分别实现常见的“增删改查”，但实际中，我们一般情况直接用POST来实现“增改”，GET来实现“删查”即可（DELETE和PUT甚至会被一些防火墙阻挡）。</p>
<p>前面已经简单演示了POST的实现，在此，我们为UserService添加一个获取注册用户资料的功能，来演示GET的实现。</p>
<p>这个功能就是要实现客户端通过访问如下不同URL来获取不同ID的用户资料：</p>
<pre><code>http://localhost:8080/users/1001
http://localhost:8080/users/1002
http://localhost:8080/users/1003
</code></pre>
<p>当然，也可以通过其他形式的URL来访问不同ID的用户资料，例如：</p>
<pre><code>http://localhost:8080/users/load?id=1001
</code></pre>
<p>JAX-RS本身可以支持所有这些形式。但是上面那种在URL路径中包含查询参数的形式（<a href="http://localhost:8080/users/1001%EF%BC%89">http://localhost:8080/users/1001）</a> 更符合REST的一般习惯，所以更推荐大家来使用。下面我们就为UserService添加一个getUser()方法来实现这种形式的URL访问：</p>
<pre><code class="language-java"><span class="hljs-meta">@GET</span>
<span class="hljs-meta">@Path</span>(<span class="hljs-string">"{id : \\d+}"</span>)
<span class="hljs-meta">@Produces</span>({MediaType.APPLICATION_JSON})
<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id) </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>@GET：指定用HTTP GET方法访问</p>
<p>@Path(&quot;{id : \d+}&quot;)：根据上面的功能需求，访问getUser()的URL应当是“<a href="http://localhost:8080/users/">http://localhost:8080/users/</a> + 任意数字&quot;，并且这个数字要被做为参数传入getUser()方法。 这里的annotation配置中，@Path中间的{id: xxx}指定URL相对路径中包含了名为id参数，而它的值也将被自动传递给下面用@PathParam(&quot;id&quot;)修饰的方法参数id。{id:后面紧跟的\d+是一个正则表达式，指定了id参数必须是数字。</p>
<p>@Produces({MediaType.APPLICATION_JSON})：指定getUser()输出JSON格式的数据。框架会自动将User对象序列化为JSON数据。</p>
<h3>Annotation放在接口类还是实现类</h3>
<p>在Dubbo中开发REST服务主要都是通过JAX-RS的annotation来完成配置的，在上面的示例中，我们都是将annotation放在服务的实现类中。但其实，我们完全也可以将annotation放到服务的接口上，这两种方式是完全等价的，例如：</p>
<pre><code class="language-java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>{
    
    <span class="hljs-meta">@GET</span>
    <span class="hljs-meta">@Path</span>(<span class="hljs-string">"{id : \\d+}"</span>)
    <span class="hljs-meta">@Produces</span>({MediaType.APPLICATION_JSON})
    <span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
}
</code></pre>
<p>在一般应用中，我们建议将annotation放到服务实现类，这样annotation和java实现代码位置更接近，更便于开发和维护。另外更重要的是，我们一般倾向于避免对接口的污染，保持接口的纯净性和广泛适用性。</p>
<p>但是，如后文所述，如果我们要用dubbo直接开发的消费端来访问此服务，则annotation必须放到接口上。</p>
<p>如果接口和实现类都同时添加了annotation，则实现类的annotation配置会生效，接口上的annotation被直接忽略。</p>
<h3>JSON、XML等多数据格式的支持</h3>
<p>在dubbo中开发的REST服务可以同时支持传输多种格式的数据，以给客户端提供最大的灵活性。其中我们目前对最常用的JSON和XML格式特别添加了额外的功能。</p>
<p>比如，我们要让上例中的getUser()方法支持分别返回JSON和XML格式的数据，只需要在annotation中同时包含两种格式即可：</p>
<pre><code class="language-java"><span class="hljs-meta">@Produces</span>({MediaType.APPLICATION_JSON, MediaType.TEXT_XML})
<span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
</code></pre>
<p>或者也可以直接用字符串（还支持通配符）表示MediaType：</p>
<pre><code class="language-java"><span class="hljs-meta">@Produces</span>({<span class="hljs-string">"application/json"</span>, <span class="hljs-string">"text/xml"</span>})
<span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
</code></pre>
<p>如果所有方法都支持同样类型的输入输出数据格式，则我们无需在每个方法上做配置，只需要在服务类上添加annotation即可：</p>
<pre><code class="language-java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-meta">@Consumes</span>({MediaType.APPLICATION_JSON, MediaType.TEXT_XML})
<span class="hljs-meta">@Produces</span>({MediaType.APPLICATION_JSON, MediaType.TEXT_XML})
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>{
    <span class="hljs-comment">// ...</span>
}

</code></pre>
<p>在一个REST服务同时对多种数据格式支持的情况下，根据JAX-RS标准，一般是通过HTTP中的MIME header（content-type和accept）来指定当前想用的是哪种格式的数据。</p>
<p>但是在dubbo中，我们还自动支持目前业界普遍使用的方式，即用一个URL后缀（.json和.xml）来指定想用的数据格式。例如，在添加上述annotation后，直接访问http://localhost:8888/users/1001.json则表示用json格式，直接访问http://localhost:8888/users/1002.xml则表示用xml格式，比用HTTP Header更简单直观。Twitter、微博等的REST API都是采用这种方式。</p>
<p>如果你既不加HTTP header，也不加后缀，则dubbo的REST会优先启用在以上annotation定义中排位最靠前的那种数据格式。</p>
<blockquote>
<p>注意：这里要支持XML格式数据，在annotation中既可以用MediaType.TEXT_XML，也可以用MediaType.APPLICATION_XML，但是TEXT_XML是更常用的，并且如果要利用上述的URL后缀方式来指定数据格式，只能配置为TEXT_XML才能生效。</p>
</blockquote>
<h3>中文字符支持</h3>
<p>为了在dubbo REST中正常输出中文字符，和通常的Java web应用一样，我们需要将HTTP响应的contentType设置为UTF-8编码。</p>
<p>基于JAX-RS的标准用法，我们只需要做如下annotation配置即可：</p>
<pre><code class="language-java"><span class="hljs-meta">@Produces</span>({<span class="hljs-string">"application/json; charset=UTF-8"</span>, <span class="hljs-string">"text/xml; charset=UTF-8"</span>})
<span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
</code></pre>
<p>为了方便用户，我们在dubbo REST中直接添加了一个支持类，来定义以上的常量，可以直接使用，减少出错的可能性。</p>
<pre><code class="language-java"><span class="hljs-meta">@Produces</span>({ContentType.APPLICATION_JSON_UTF_8, ContentType.TEXT_XML_UTF_8})
<span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
</code></pre>
<h3>XML数据格式的额外要求</h3>
<p>由于JAX-RS的实现一般都用标准的JAXB（Java API for XML Binding）来序列化和反序列化XML格式数据，所以我们需要为每一个要用XML传输的对象添加一个类级别的JAXB annotation，否则序列化将报错。例如为getUser()中返回的User添加如下：</p>
<pre><code class="language-java"><span class="hljs-meta">@XmlRootElement</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>此外，如果service方法中的返回值是Java的 primitive类型（如int，long，float，double等），最好为它们添加一层wrapper对象，因为JAXB不能直接序列化primitive类型。</p>
<p>例如，我们想让前述的registerUser()方法返回服务器端为用户生成的ID号：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">registerUser</span><span class="hljs-params">(User user)</span></span>;
</code></pre>
<p>由于primitive类型不被JAXB序列化支持，所以添加一个wrapper对象：</p>
<pre><code class="language-java"><span class="hljs-meta">@XmlRootElement</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegistrationResult</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{
    
    <span class="hljs-keyword">private</span> Long id;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RegistrationResult</span><span class="hljs-params">()</span> </span>{
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RegistrationResult</span><span class="hljs-params">(Long id)</span> </span>{
        <span class="hljs-keyword">this</span>.id = id;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> id;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Long id)</span> </span>{
        <span class="hljs-keyword">this</span>.id = id;
    }
}
</code></pre>
<p>并修改service方法：</p>
<pre><code class="language-java"><span class="hljs-function">RegistrationResult <span class="hljs-title">registerUser</span><span class="hljs-params">(User user)</span></span>;
</code></pre>
<p>这样不但能够解决XML序列化的问题，而且使得返回的数据都符合XML和JSON的规范。例如，在JSON中，返回的将是如下形式：</p>
<pre><code class="language-javascript">{<span class="hljs-string">"id"</span>: <span class="hljs-number">1001</span>}
</code></pre>
<p>如果不加wrapper，JSON返回值将直接是</p>
<pre><code>1001 	
</code></pre>
<p>而在XML中，加wrapper后返回值将是：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">registrationResult</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>1002<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">registrationResult</span>&gt;</span>
</code></pre>
<p>这种wrapper对象其实利用所谓Data Transfer Object（DTO）模式，采用DTO还能对传输数据做更多有用的定制。</p>
<h3>定制序列化</h3>
<p>如上所述，REST的底层实现会在service的对象和JSON/XML数据格式之间自动做序列化/反序列化。但有些场景下，如果觉得这种自动转换不满足要求，可以对其做定制。</p>
<p>Dubbo中的REST实现是用JAXB做XML序列化，用Jackson做JSON序列化，所以在对象上添加JAXB或Jackson的annotation即可以定制映射。</p>
<p>例如，定制对象属性映射到XML元素的名字：</p>
<pre><code class="language-java"><span class="hljs-meta">@XmlRootElement</span>
<span class="hljs-meta">@XmlAccessorType</span>(XmlAccessType.FIELD)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{
    
    <span class="hljs-meta">@XmlElement</span>(name=<span class="hljs-string">"username"</span>) 
    <span class="hljs-keyword">private</span> String name;  
}
</code></pre>
<p>定制对象属性映射到JSON字段的名字：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{
    
    <span class="hljs-meta">@JsonProperty</span>(<span class="hljs-string">"username"</span>)
    <span class="hljs-keyword">private</span> String name;
}
</code></pre>
<p>更多资料请参考JAXB和Jackson的官方文档，或自行google。</p>
<h3>配置REST Server的实现</h3>
<p>目前在dubbo中，我们支持5种嵌入式rest server的实现，并同时支持采用外部应用服务器来做rest server的实现。rest server可以通过如下配置实现：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"jetty"</span>/&gt;</span>
</code></pre>
<p>以上配置选用了嵌入式的jetty来做rest server，同时，如果不配置server属性，rest协议默认也是选用jetty。jetty是非常成熟的java servlet容器，并和dubbo已经有较好的集成（目前5种嵌入式server中只有jetty和后面所述的tomcat、tjws，与dubbo监控系统等完成了无缝的集成），所以，如果你的dubbo系统是单独启动的进程，你可以直接默认采用jetty即可。</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"tomcat"</span>/&gt;</span>
</code></pre>
<p>以上配置选用了嵌入式的tomcat来做rest server。在嵌入式tomcat上，REST的性能比jetty上要好得多（参见后面的基准测试），建议在需要高性能的场景下采用tomcat。</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"netty"</span>/&gt;</span>
</code></pre>
<p>以上配置选用嵌入式的netty来做rest server。（TODO more contents to add）</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"tjws"</span>/&gt;</span> (tjws is now deprecated)
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"sunhttp"</span>/&gt;</span>
</code></pre>
<p>以上配置选用嵌入式的tjws或Sun HTTP server来做rest server。这两个server实现非常轻量级，非常方便在集成测试中快速启动使用，当然也可以在负荷不高的生产环境中使用。	注：tjws目前已经被deprecated掉了，因为它不能很好的和servlet 3.1 API工作。</p>
<p>如果你的dubbo系统不是单独启动的进程，而是部署到了Java应用服务器中，则建议你采用以下配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"servlet"</span>/&gt;</span>
</code></pre>
<p>通过将server设置为servlet，dubbo将采用外部应用服务器的servlet容器来做rest server。同时，还要在dubbo系统的web.xml中添加如下配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>/WEB-INF/classes/META-INF/spring/dubbo-demo-provider.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.apache.dubbo.remoting.http.servlet.BootstrapListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.apache.dubbo.remoting.http.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span>
</code></pre>
<p>即必须将dubbo的BootstrapListener和DispatherServlet添加到web.xml，以完成dubbo的REST功能与外部servlet容器的集成。</p>
<blockquote>
<p>注意：如果你是用spring的ContextLoaderListener来加载spring，则必须保证BootstrapListener配置在ContextLoaderListener之前，否则dubbo初始化会出错。</p>
</blockquote>
<p>其实，这种场景下你依然可以坚持用嵌入式server，但外部应用服务器的servlet容器往往比嵌入式server更加强大（特别是如果你是部署到更健壮更可伸缩的WebLogic，WebSphere等），另外有时也便于在应用服务器做统一管理、监控等等。</p>
<h3>获取上下文（Context）信息</h3>
<p>在远程调用中，值得获取的上下文信息可能有很多种，这里特别以获取客户端IP为例。</p>
<p>在dubbo的REST中，我们有两种方式获取客户端IP。</p>
<p>第一种方式，用JAX-RS标准的@Context annotation：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id, @Context HttpServletRequest request) </span>{
    System.out.println(<span class="hljs-string">"Client address is "</span> + request.getRemoteAddr());
} 
</code></pre>
<p>用Context修饰getUser()的一个方法参数后，就可以将当前的HttpServletRequest注入进来，然后直接调用servlet api获取IP。</p>
<blockquote>
<p>注意：这种方式只能在将server设置为 tjws、tomcat、jetty 或者 servlet 的时候才能工作，因为只有这几种 server 的实现才提供了 servlet 容器。另外，标准的JAX-RS还支持用@Context修饰service类的一个实例字段来获取HttpServletRequest，但在dubbo中我们没有对此作出支持。</p>
</blockquote>
<p>第二种方式，用dubbo中常用的RpcContext：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id) </span>{
    System.out.println(<span class="hljs-string">"Client address is "</span> + RpcContext.getContext().getRemoteAddressString());
} 
</code></pre>
<blockquote>
<p>注意：这种方式只能在设置server=&quot;jetty&quot;或者server=&quot;tomcat&quot;或者server=&quot;servlet&quot;或者server=&quot;tjws&quot;的时候才能工作。另外，目前dubbo的RpcContext是一种比较有侵入性的用法，未来我们很可能会做出重构。</p>
</blockquote>
<p>如果你想保持你的项目对JAX-RS的兼容性，未来脱离dubbo也可以运行，请选择第一种方式。如果你想要更优雅的服务接口定义，请选用第二种方式。</p>
<p>此外，在最新的dubbo rest中，还支持通过RpcContext来获取HttpServletRequest和HttpServletResponse，以提供更大的灵活性来方便用户实现某些复杂功能，比如在dubbo标准的filter中访问HTTP Header。用法示例如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">if</span> (RpcContext.getContext().getRequest() != <span class="hljs-keyword">null</span> &amp;&amp; RpcContext.getContext().getRequest() <span class="hljs-keyword">instanceof</span> HttpServletRequest) {
    System.out.println(<span class="hljs-string">"Client address is "</span> + ((HttpServletRequest) RpcContext.getContext().getRequest()).getRemoteAddr());
}

<span class="hljs-keyword">if</span> (RpcContext.getContext().getResponse() != <span class="hljs-keyword">null</span> &amp;&amp; RpcContext.getContext().getResponse() <span class="hljs-keyword">instanceof</span> HttpServletResponse) {
    System.out.println(<span class="hljs-string">"Response object from RpcContext: "</span> + RpcContext.getContext().getResponse());
}
</code></pre>
<blockquote>
<p>注意：为了保持协议的中立性，RpcContext.getRequest()和RpcContext.getResponse()返回的仅仅是一个Object类，而且可能为null。所以，你必须自己做null和类型的检查。</p>
</blockquote>
<blockquote>
<p>注意：只有在设置server=&quot;jetty&quot;或者server=&quot;tomcat&quot;或者server=&quot;servlet&quot;的时候，你才能通过以上方法正确的得到HttpServletRequest和HttpServletResponse，因为只有这几种server实现了servlet容器。</p>
</blockquote>
<p>为了简化编程，在此你也可以用泛型的方式来直接获取特定类型的request/response：</p>
<pre><code class="language-java"><span class="hljs-keyword">if</span> (RpcContext.getContext().getRequest(HttpServletRequest.class) != <span class="hljs-keyword">null</span>) {
    System.out.println(<span class="hljs-string">"Client address is "</span> + RpcContext.getContext().getRequest(HttpServletRequest.class).getRemoteAddr());
}

<span class="hljs-keyword">if</span> (RpcContext.getContext().getResponse(HttpServletResponse.class) != <span class="hljs-keyword">null</span>) {
    System.out.println(<span class="hljs-string">"Response object from RpcContext: "</span> + RpcContext.getContext().getResponse(HttpServletResponse.class));
}
</code></pre>
<p>如果request/response不符合指定的类型，这里也会返回null。</p>
<h3>配置端口号和Context Path</h3>
<p>dubbo中的rest协议默认将采用80端口，如果想修改端口，直接配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span>/&gt;</span>
</code></pre>
<p>另外，如前所述，我们可以用@Path来配置单个rest服务的URL相对路径。但其实，我们还可以设置一个所有rest服务都适用的基础相对路径，即java web应用中常说的context path。</p>
<p>只需要添加如下contextpath属性即可：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">contextpath</span>=<span class="hljs-string">"services"</span>/&gt;</span>
</code></pre>
<p>以前面代码为例：</p>
<pre><code class="language-java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>{
       
    <span class="hljs-meta">@POST</span>
    <span class="hljs-meta">@Path</span>(<span class="hljs-string">"register"</span>)
    <span class="hljs-meta">@Consumes</span>({MediaType.APPLICATION_JSON})
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerUser</span><span class="hljs-params">(User user)</span> </span>{
        <span class="hljs-comment">// save the user...</span>
    }	
}
</code></pre>
<p>现在registerUser()的完整访问路径为：</p>
<pre><code>http://localhost:8888/services/users/register
</code></pre>
<p>注意：如果你是选用外部应用服务器做rest server，即配置:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">contextpath</span>=<span class="hljs-string">"services"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"servlet"</span>/&gt;</span>
</code></pre>
<p>则必须保证这里设置的port、contextpath，与外部应用服务器的端口、DispatcherServlet的上下文路径（即webapp path加上servlet url pattern）保持一致。例如，对于部署为tomcat ROOT路径的应用，这里的contextpath必须与web.xml中DispacherServlet的<code>&lt;url-pattern/&gt;</code>完全一致：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/services/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>
</code></pre>
<h3>配置线程数和IO线程数</h3>
<p>可以为rest服务配置线程池大小：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">threads</span>=<span class="hljs-string">"500"</span>/&gt;</span>
</code></pre>
<blockquote>
<p>注意：目前线程池的设置只有当server=&quot;netty&quot;或者server=&quot;jetty&quot;或者server=&quot;tomcat&quot;的时候才能生效。另外，如果server=&quot;servlet&quot;，由于这时候启用的是外部应用服务器做rest server，不受dubbo控制，所以这里的线程池设置也无效。</p>
</blockquote>
<p>如果是选用netty server，还可以配置Netty的IO worker线程数：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">iothreads</span>=<span class="hljs-string">"5"</span> <span class="hljs-attr">threads</span>=<span class="hljs-string">"100"</span>/&gt;</span>
</code></pre>
<h3>配置长连接</h3>
<p>Dubbo中的rest服务默认都是采用http长连接来访问，如果想切换为短连接，直接配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">keepalive</span>=<span class="hljs-string">"false"</span>/&gt;</span>
</code></pre>
<blockquote>
<p>注意：这个配置目前只对server=&quot;netty&quot;和server=&quot;tomcat&quot;才能生效。</p>
</blockquote>
<h3>配置最大的HTTP连接数</h3>
<p>可以配置服务器提供端所能同时接收的最大HTTP连接数，防止REST server被过多连接撑爆，以作为一种最基本的自我保护机制：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">accepts</span>=<span class="hljs-string">"500"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"tomcat/&gt;
</span></span></code></pre>
<blockquote>
<p>注意：这个配置目前只对server=&quot;tomcat&quot;才能生效。</p>
</blockquote>
<h3>配置每个消费端的超时时间和HTTP连接数</h3>
<p>如果rest服务的消费端也是dubbo系统，可以像其他dubbo RPC机制一样，配置消费端调用此rest服务的最大超时时间以及每个消费端所能启动的最大HTTP连接数。</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"2000"</span> <span class="hljs-attr">connections</span>=<span class="hljs-string">"10"</span>/&gt;</span>
</code></pre>
<p>当然，由于这个配置针对消费端生效的，所以也可以在消费端配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"2000"</span> <span class="hljs-attr">connections</span>=<span class="hljs-string">"10"</span>/&gt;</span>
</code></pre>
<p>但是，通常我们建议配置在服务提供端提供此类配置。按照dubbo官方文档的说法：“Provider上尽量多配置Consumer端的属性，让Provider实现者一开始就思考Provider服务特点、服务质量的问题。”</p>
<blockquote>
<p>注意：如果dubbo的REST服务是发布给非dubbo的客户端使用，则这里<code>&lt;dubbo:service/&gt;</code>上的配置完全无效，因为这种客户端不受dubbo控制。</p>
</blockquote>
<h3>用Annotation取代部分Spring XML配置</h3>
<p>以上所有的讨论都是基于dubbo在spring中的xml配置。但是，dubbo/spring本身也支持用annotation来作配置，所以我们也可以按dubbo官方文档中的步骤，把相关annotation加到REST服务的实现中，取代一些xml配置，例如：</p>
<pre><code class="language-java"><span class="hljs-meta">@Service</span>(protocol = <span class="hljs-string">"rest"</span>)
<span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserRepository userRepository;
       
    <span class="hljs-meta">@POST</span>
    <span class="hljs-meta">@Path</span>(<span class="hljs-string">"register"</span>)
    <span class="hljs-meta">@Consumes</span>({MediaType.APPLICATION_JSON})
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerUser</span><span class="hljs-params">(User user)</span> </span>{
        <span class="hljs-comment">// save the user</span>
        userRepository.save(user);
    }	
}
</code></pre>
<p>annotation的配置更简单更精确，通常也更便于维护（当然现代IDE都可以在xml中支持比如类名重构，所以就这里的特定用例而言，xml的维护性也很好）。而xml对代码的侵入性更小一些，尤其有利于动态修改配置，特别是比如你要针对单个服务配置连接超时时间、每客户端最大连接数、集群策略、权重等等。另外，特别对复杂应用或者模块来说，xml提供了一个中心点来涵盖的所有组件和配置，更一目了然，一般更便于项目长时期的维护。</p>
<p>当然，选择哪种配置方式没有绝对的优劣，和个人的偏好也不无关系。</p>
<h3>添加自定义的Filter、Interceptor等</h3>
<p>Dubbo的REST也支持JAX-RS标准的Filter和Interceptor，以方便对REST的请求与响应过程做定制化的拦截处理。</p>
<p>其中，Filter主要用于访问和设置HTTP请求和响应的参数、URI等等。例如，设置HTTP响应的cache header：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheControlFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ContainerResponseFilter</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filter</span><span class="hljs-params">(ContainerRequestContext req, ContainerResponseContext res)</span> </span>{
        <span class="hljs-keyword">if</span> (req.getMethod().equals(<span class="hljs-string">"GET"</span>)) {
            res.getHeaders().add(<span class="hljs-string">"Cache-Control"</span>, <span class="hljs-string">"someValue"</span>);
        }
    }
}
</code></pre>
<p>Interceptor主要用于访问和修改输入与输出字节流，例如，手动添加GZIP压缩：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GZIPWriterInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WriterInterceptor</span> </span>{
 
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">aroundWriteTo</span><span class="hljs-params">(WriterInterceptorContext context)</span>
                    <span class="hljs-keyword">throws</span> IOException, WebApplicationException </span>{
        OutputStream outputStream = context.getOutputStream();
        context.setOutputStream(<span class="hljs-keyword">new</span> GZIPOutputStream(outputStream));
        context.proceed();
    }
}
</code></pre>
<p>在标准JAX-RS应用中，我们一般是为Filter和Interceptor添加@Provider annotation，然后JAX-RS runtime会自动发现并启用它们。而在dubbo中，我们是通过添加XML配置的方式来注册Filter和Interceptor：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">extension</span>=<span class="hljs-string">"xxx.TraceInterceptor, xxx.TraceFilter"</span>/&gt;</span>
</code></pre>
<p>在此，我们可以将Filter、Interceptor和DynamicFeature这三种类型的对象都添加到<code>extension</code>属性上，多个之间用逗号分隔。（DynamicFeature是另一个接口，可以方便我们更动态的启用Filter和Interceptor，感兴趣请自行google。）</p>
<p>当然，dubbo自身也支持Filter的概念，但我们这里讨论的Filter和Interceptor更加接近协议实现的底层，相比dubbo的filter，可以做更底层的定制化。</p>
<blockquote>
<p>注：这里的XML属性叫extension，而不是叫interceptor或者filter，是因为除了Interceptor和Filter，未来我们还会添加更多的扩展类型。</p>
</blockquote>
<p>如果REST的消费端也是dubbo系统（参见下文的讨论），则也可以用类似方式为消费端配置Interceptor和Filter。但注意，JAX-RS中消费端的Filter和提供端的Filter是两种不同的接口。例如前面例子中服务端是ContainerResponseFilter接口，而消费端对应的是ClientResponseFilter:</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoggingFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ClientResponseFilter</span> </span>{
 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filter</span><span class="hljs-params">(ClientRequestContext reqCtx, ClientResponseContext resCtx)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        System.out.println(<span class="hljs-string">"status: "</span> + resCtx.getStatus());
	    System.out.println(<span class="hljs-string">"date: "</span> + resCtx.getDate());
	    System.out.println(<span class="hljs-string">"last-modified: "</span> + resCtx.getLastModified());
	    System.out.println(<span class="hljs-string">"location: "</span> + resCtx.getLocation());
	    System.out.println(<span class="hljs-string">"headers:"</span>);
	    <span class="hljs-keyword">for</span> (Entry&lt;String, List&lt;String&gt;&gt; header : resCtx.getHeaders().entrySet()) {
     	    System.out.print(<span class="hljs-string">"\t"</span> + header.getKey() + <span class="hljs-string">" :"</span>);
	        <span class="hljs-keyword">for</span> (String value : header.getValue()) {
	            System.out.print(value + <span class="hljs-string">", "</span>);
	        }
	        System.out.print(<span class="hljs-string">"\n"</span>);
	    }
	    System.out.println(<span class="hljs-string">"media-type: "</span> + resCtx.getMediaType().getType());
    } 
}
</code></pre>
<h3>添加自定义的Exception处理</h3>
<p>Dubbo的REST也支持JAX-RS标准的ExceptionMapper，可以用来定制特定exception发生后应该返回的HTTP响应。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomExceptionMapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExceptionMapper</span>&lt;<span class="hljs-title">NotFoundException</span>&gt; </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">toResponse</span><span class="hljs-params">(NotFoundException e)</span> </span>{     
        <span class="hljs-keyword">return</span> Response.status(Response.Status.NOT_FOUND).entity(<span class="hljs-string">"Oops! the requested resource is not found!"</span>).type(<span class="hljs-string">"text/plain"</span>).build();
    }
}
</code></pre>
<p>和Interceptor、Filter类似，将其添加到XML配置文件中即可启用：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">extension</span>=<span class="hljs-string">"xxx.CustomExceptionMapper"</span>/&gt;</span>
</code></pre>
<h3>配置HTTP日志输出</h3>
<p>Dubbo rest支持输出所有HTTP请求/响应中的header字段和body消息体。</p>
<p>在XML配置中添加如下自带的REST filter：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">extension</span>=<span class="hljs-string">"org.apache.dubbo.rpc.protocol.rest.support.LoggingFilter"</span>/&gt;</span>
</code></pre>
<p>然后配置在logging配置中至少为org.apache.dubbo.rpc.protocol.rest.support打开INFO级别日志输出，例如，在log4j.xml中配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"org.apache.dubbo.rpc.protocol.rest.support"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"INFO"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"CONSOLE"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span>
</code></pre>
<p>当然，你也可以直接在ROOT logger打开INFO级别日志输出：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"INFO"</span> /&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"CONSOLE"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
</code></pre>
<p>然后在日志中会有类似如下的内容输出：</p>
<pre><code>The HTTP headers are: 
accept: application/json;charset=UTF-8
accept-encoding: gzip, deflate
connection: Keep-Alive
content-length: 22
content-type: application/json
host: 192.168.1.100:8888
user-agent: Apache-HttpClient/4.2.1 (java 1.5)
</code></pre>
<pre><code>The contents of request body is: 
{&quot;id&quot;:1,&quot;name&quot;:&quot;dang&quot;}
</code></pre>
<p>打开HTTP日志输出后，除了正常日志输出的性能开销外，也会在比如HTTP请求解析时产生额外的开销，因为需要建立额外的内存缓冲区来为日志的输出做数据准备。</p>
<h3>输入参数的校验</h3>
<p>dubbo的rest支持采用Java标准的bean validation annotation（JSR 303)来做输入校验http://beanvalidation.org/</p>
<p>为了和其他dubbo远程调用协议保持一致，在rest中作校验的annotation必须放在服务的接口上，例如：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>{
   
    <span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@Min(value=<span class="hljs-number">1</span>L, message=<span class="hljs-string">"User ID must be greater than 1"</span>)</span> Long id)</span>;
}

</code></pre>
<p>当然，在很多其他的bean validation的应用场景都是将annotation放到实现类而不是接口上。把annotation放在接口上至少有一个好处是，dubbo的客户端可以共享这个接口的信息，dubbo甚至不需要做远程调用，在本地就可以完成输入校验。</p>
<p>然后按照dubbo的标准方式在XML配置中打开验证：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">xxx.UserService</span>" <span class="hljs-attr">ref</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">validation</span>=<span class="hljs-string">"true"</span>/&gt;</span>
</code></pre>
<p>在dubbo的其他很多远程调用协议中，如果输入验证出错，是直接将<code>RpcException</code>抛向客户端，而在rest中由于客户端经常是非dubbo，甚至非java的系统，所以不便直接抛出Java异常。因此，目前我们将校验错误以XML的格式返回：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">violationReport</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">constraintViolations</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>getUserArgument0<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span>User ID must be greater than 1<span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">constraintViolations</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">violationReport</span>&gt;</span>
</code></pre>
<p>稍后也会支持其他数据格式的返回值。至于如何对验证错误消息作国际化处理，直接参考bean validation的相关文档即可。</p>
<p>如果你认为默认的校验错误返回格式不符合你的要求，可以如上面章节所述，添加自定义的ExceptionMapper来自由的定制错误返回格式。需要注意的是，这个ExceptionMapper必须用泛型声明来捕获dubbo的RpcException，才能成功覆盖dubbo rest默认的异常处理策略。为了简化操作，其实这里最简单的方式是直接继承dubbo rest的RpcExceptionMapper，并覆盖其中处理校验异常的方法即可：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyValidationExceptionMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RpcExceptionMapper</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">protected</span> Response <span class="hljs-title">handleConstraintViolationException</span><span class="hljs-params">(ConstraintViolationException cve)</span> </span>{
        ViolationReport report = <span class="hljs-keyword">new</span> ViolationReport();
        <span class="hljs-keyword">for</span> (ConstraintViolation cv : cve.getConstraintViolations()) {
            report.addConstraintViolation(<span class="hljs-keyword">new</span> RestConstraintViolation(
                    cv.getPropertyPath().toString(),
                    cv.getMessage(),
                    cv.getInvalidValue() == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"null"</span> : cv.getInvalidValue().toString()));
        }
        <span class="hljs-comment">// 采用json输出代替xml输出</span>
        <span class="hljs-keyword">return</span> Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(report).type(ContentType.APPLICATION_JSON_UTF_8).build();
    }
}
</code></pre>
<p>然后将这个ExceptionMapper添加到XML配置中即可：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">extension</span>=<span class="hljs-string">"xxx.MyValidationExceptionMapper"</span>/&gt;</span>
</code></pre>
</div></section><footer class="footer-container"><div class="footer-body"><img src="/img/dubbo_gray.png"/><img class="apache" src="/img/apache_logo.png"/><div class="cols-container"><div class="col col-12"><h3></h3><p></p></div><div class="col col-4"><dl><dt>ASF</dt><dd><a href="http://www.apache.org" target="_self">基金会</a></dd><dd><a href="http://www.apache.org/licenses/" target="_self">证书</a></dd><dd><a href="http://www.apache.org/events/current-event" target="_self">事件</a></dd><dd><a href="http://www.apache.org/foundation/sponsorship.html" target="_self">赞助</a></dd><dd><a href="http://www.apache.org/foundation/thanks.html" target="_self">致谢</a></dd></dl></div><div class="col col-4"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/user/quick-start.html" target="_self">快速开始</a></dd><dd><a href="/zh-cn/docs/dev/build.html" target="_self">开发者指南</a></dd><dd><a href="/zh-cn/docs/admin/ops/dubbo-ops.html" target="_self">运维管理</a></dd><dd><a href="https://github.com/apache/dubbo-website/issues/new" target="_self">报告文档问题</a></dd><dd><a href="https://github.com/apache/dubbo-website" target="_self">编辑此文档</a></dd></dl></div><div class="col col-4"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/community/index.html" target="_self">社区</a></dd><dd><a href="https://www.apache.org/security" target="_self">安全</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2018-2019 The Apache Software Foundation. Apache and the Apache feather logo are trademarks of The Apache Software Foundation.</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
  <script src="/build/documentation.js"></script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112489517-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-112489517-1');
	</script>
</body>
</html>