{
  "filename": "rest.md",
  "__html": "<h1>rest://</h1>\n<p>基于标准的Java REST API——JAX-RS 2.0（Java API for RESTful Web Services的简写）实现的REST调用支持</p>\n<h2>快速入门</h2>\n<p>在dubbo中开发一个REST风格的服务会比较简单，下面以一个注册用户的简单服务为例说明。</p>\n<p>这个服务要实现的功能是提供如下URL（注：这个URL不是完全符合REST的风格，但是更简单实用）：</p>\n<pre><code>http://localhost:8080/users/register\n</code></pre>\n<p>而任何客户端都可以将包含用户信息的JSON字符串POST到以上URL来完成用户注册。</p>\n<p>首先，开发服务的接口：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">UserService</span> </span>{    \n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerUser</span><span class=\"hljs-params\">(User user)</span></span>;\n}\n</code></pre>\n<p>然后，开发服务的实现：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Path</span>(<span class=\"hljs-string\">\"/users\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">UserService</span> </span>{\n       \n    <span class=\"hljs-meta\">@POST</span>\n    <span class=\"hljs-meta\">@Path</span>(<span class=\"hljs-string\">\"/register\"</span>)\n    <span class=\"hljs-meta\">@Consumes</span>({MediaType.APPLICATION_JSON})\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerUser</span><span class=\"hljs-params\">(User user)</span> </span>{\n        <span class=\"hljs-comment\">// save the user...</span>\n    }\n}\n</code></pre>\n<p>上面的实现非常简单，但是由于该 REST 服务是要发布到指定 URL 上，供任意语言的客户端甚至浏览器来访问，所以这里额外添加了几个 JAX-RS 的标准 annotation 来做相关的配置。</p>\n<p>@Path(&quot;/users&quot;)：指定访问UserService的URL相对路径是/users，即http://localhost:8080/users</p>\n<p>@Path(&quot;/register&quot;)：指定访问registerUser()方法的URL相对路径是/register，再结合上一个@Path为UserService指定的路径，则调用UserService.register()的完整路径为http://localhost:8080/users/register</p>\n<p>@POST：指定访问registerUser()用HTTP POST方法</p>\n<p>@Consumes({MediaType.APPLICATION_JSON})：指定registerUser()接收JSON格式的数据。REST框架会自动将JSON数据反序列化为User对象</p>\n<p>最后，在spring配置文件中添加此服务，即完成所有服务开发工作：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-comment\">&lt;!-- 用rest协议在8080端口暴露服务 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">port</span>=<span class=\"hljs-string\">\"8080\"</span>/&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 声明需要暴露的服务接口 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"xxx.UserService\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"userService\"</span>/&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 和本地bean一样实现服务 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"userService\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"xxx.UserServiceImpl\"</span> /&gt;</span>\n</code></pre>\n<h2>REST服务提供端详解</h2>\n<p>下面我们扩充“快速入门”中的UserService，进一步展示在dubbo中REST服务提供端的开发要点。</p>\n<h3>HTTP POST/GET的实现</h3>\n<p>REST服务中虽然建议使用HTTP协议中四种标准方法POST、DELETE、PUT、GET来分别实现常见的“增删改查”，但实际中，我们一般情况直接用POST来实现“增改”，GET来实现“删查”即可（DELETE和PUT甚至会被一些防火墙阻挡）。</p>\n<p>前面已经简单演示了POST的实现，在此，我们为UserService添加一个获取注册用户资料的功能，来演示GET的实现。</p>\n<p>这个功能就是要实现客户端通过访问如下不同URL来获取不同ID的用户资料：</p>\n<pre><code>http://localhost:8080/users/1001\nhttp://localhost:8080/users/1002\nhttp://localhost:8080/users/1003\n</code></pre>\n<p>当然，也可以通过其他形式的URL来访问不同ID的用户资料，例如：</p>\n<pre><code>http://localhost:8080/users/load?id=1001\n</code></pre>\n<p>JAX-RS本身可以支持所有这些形式。但是上面那种在URL路径中包含查询参数的形式（<a href=\"http://localhost:8080/users/1001%EF%BC%89\">http://localhost:8080/users/1001）</a> 更符合REST的一般习惯，所以更推荐大家来使用。下面我们就为UserService添加一个getUser()方法来实现这种形式的URL访问：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@GET</span>\n<span class=\"hljs-meta\">@Path</span>(<span class=\"hljs-string\">\"/{id : \\\\d+}\"</span>)\n<span class=\"hljs-meta\">@Produces</span>({MediaType.APPLICATION_JSON})\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> User <span class=\"hljs-title\">getUser</span><span class=\"hljs-params\">(@PathParam(<span class=\"hljs-string\">\"id\"</span>)</span> Long id) </span>{\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>@GET：指定用HTTP GET方法访问</p>\n<p>@Path(&quot;/{id : \\d+}&quot;)：根据上面的功能需求，访问getUser()的URL应当是“<a href=\"http://localhost:8080/users/\">http://localhost:8080/users/</a> + 任意数字&quot;，并且这个数字要被做为参数传入getUser()方法。 这里的annotation配置中，@Path中间的{id: xxx}指定URL相对路径中包含了名为id参数，而它的值也将被自动传递给下面用@PathParam(&quot;id&quot;)修饰的方法参数id。{id:后面紧跟的\\d+是一个正则表达式，指定了id参数必须是数字。</p>\n<p>@Produces({MediaType.APPLICATION_JSON})：指定getUser()输出JSON格式的数据。框架会自动将User对象序列化为JSON数据。</p>\n<h3>Annotation放在接口类还是实现类</h3>\n<p>在Dubbo中开发REST服务主要都是通过JAX-RS的annotation来完成配置的，在上面的示例中，我们都是将annotation放在服务的实现类中。但其实，我们完全也可以将annotation放到服务的接口上，这两种方式是完全等价的，例如：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Path</span>(<span class=\"hljs-string\">\"/users\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">UserService</span> </span>{\n    \n    <span class=\"hljs-meta\">@GET</span>\n    <span class=\"hljs-meta\">@Path</span>(<span class=\"hljs-string\">\"/{id : \\\\d+}\"</span>)\n    <span class=\"hljs-meta\">@Produces</span>({MediaType.APPLICATION_JSON})\n    <span class=\"hljs-function\">User <span class=\"hljs-title\">getUser</span><span class=\"hljs-params\">(@PathParam(<span class=\"hljs-string\">\"id\"</span>)</span> Long id)</span>;\n}\n</code></pre>\n<p>在一般应用中，我们建议将annotation放到服务实现类，这样annotation和java实现代码位置更接近，更便于开发和维护。另外更重要的是，我们一般倾向于避免对接口的污染，保持接口的纯净性和广泛适用性。</p>\n<p>但是，如后文所述，如果我们要用dubbo直接开发的消费端来访问此服务，则annotation必须放到接口上。</p>\n<p>如果接口和实现类都同时添加了annotation，则实现类的annotation配置会生效，接口上的annotation被直接忽略。</p>\n<h3>JSON、XML等多数据格式的支持</h3>\n<p>在dubbo中开发的REST服务可以同时支持传输多种格式的数据，以给客户端提供最大的灵活性。其中我们目前对最常用的JSON和XML格式特别添加了额外的功能。</p>\n<p>比如，我们要让上例中的getUser()方法支持分别返回JSON和XML格式的数据，只需要在annotation中同时包含两种格式即可：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Produces</span>({MediaType.APPLICATION_JSON, MediaType.TEXT_XML})\n<span class=\"hljs-function\">User <span class=\"hljs-title\">getUser</span><span class=\"hljs-params\">(@PathParam(<span class=\"hljs-string\">\"id\"</span>)</span> Long id)</span>;\n</code></pre>\n<p>或者也可以直接用字符串（还支持通配符）表示MediaType：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Produces</span>({<span class=\"hljs-string\">\"application/json\"</span>, <span class=\"hljs-string\">\"text/xml\"</span>})\n<span class=\"hljs-function\">User <span class=\"hljs-title\">getUser</span><span class=\"hljs-params\">(@PathParam(<span class=\"hljs-string\">\"id\"</span>)</span> Long id)</span>;\n</code></pre>\n<p>如果所有方法都支持同样类型的输入输出数据格式，则我们无需在每个方法上做配置，只需要在服务类上添加annotation即可：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Path</span>(<span class=\"hljs-string\">\"/users\"</span>)\n<span class=\"hljs-meta\">@Consumes</span>({MediaType.APPLICATION_JSON, MediaType.TEXT_XML})\n<span class=\"hljs-meta\">@Produces</span>({MediaType.APPLICATION_JSON, MediaType.TEXT_XML})\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">UserService</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n}\n\n</code></pre>\n<p>在一个REST服务同时对多种数据格式支持的情况下，根据JAX-RS标准，一般是通过HTTP中的MIME header（content-type和accept）来指定当前想用的是哪种格式的数据。</p>\n<p>但是在dubbo中，我们还自动支持目前业界普遍使用的方式，即用一个URL后缀（.json和.xml）来指定想用的数据格式。例如，在添加上述annotation后，直接访问http://localhost:8888/users/1001.json则表示用json格式，直接访问http://localhost:8888/users/1002.xml则表示用xml格式，比用HTTP Header更简单直观。Twitter、微博等的REST API都是采用这种方式。</p>\n<p>如果你既不加HTTP header，也不加后缀，则dubbo的REST会优先启用在以上annotation定义中排位最靠前的那种数据格式。</p>\n<blockquote>\n<p>注意：这里要支持XML格式数据，在annotation中既可以用MediaType.TEXT_XML，也可以用MediaType.APPLICATION_XML，但是TEXT_XML是更常用的，并且如果要利用上述的URL后缀方式来指定数据格式，只能配置为TEXT_XML才能生效。</p>\n</blockquote>\n<h3>中文字符支持</h3>\n<p>为了在dubbo REST中正常输出中文字符，和通常的Java web应用一样，我们需要将HTTP响应的contentType设置为UTF-8编码。</p>\n<p>基于JAX-RS的标准用法，我们只需要做如下annotation配置即可：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Produces</span>({<span class=\"hljs-string\">\"application/json; charset=UTF-8\"</span>, <span class=\"hljs-string\">\"text/xml; charset=UTF-8\"</span>})\n<span class=\"hljs-function\">User <span class=\"hljs-title\">getUser</span><span class=\"hljs-params\">(@PathParam(<span class=\"hljs-string\">\"id\"</span>)</span> Long id)</span>;\n</code></pre>\n<p>为了方便用户，我们在dubbo REST中直接添加了一个支持类，来定义以上的常量，可以直接使用，减少出错的可能性。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Produces</span>({ContentType.APPLICATION_JSON_UTF_8, ContentType.TEXT_XML_UTF_8})\n<span class=\"hljs-function\">User <span class=\"hljs-title\">getUser</span><span class=\"hljs-params\">(@PathParam(<span class=\"hljs-string\">\"id\"</span>)</span> Long id)</span>;\n</code></pre>\n<h3>XML数据格式的额外要求</h3>\n<p>由于JAX-RS的实现一般都用标准的JAXB（Java API for XML Binding）来序列化和反序列化XML格式数据，所以我们需要为每一个要用XML传输的对象添加一个类级别的JAXB annotation，否则序列化将报错。例如为getUser()中返回的User添加如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@XmlRootElement</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">User</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Serializable</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>此外，如果service方法中的返回值是Java的 primitive类型（如int，long，float，double等），最好为它们添加一层wrapper对象，因为JAXB不能直接序列化primitive类型。</p>\n<p>例如，我们想让前述的registerUser()方法返回服务器端为用户生成的ID号：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">long</span> <span class=\"hljs-title\">registerUser</span><span class=\"hljs-params\">(User user)</span></span>;\n</code></pre>\n<p>由于primitive类型不被JAXB序列化支持，所以添加一个wrapper对象：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@XmlRootElement</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RegistrationResult</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Serializable</span> </span>{\n    \n    <span class=\"hljs-keyword\">private</span> Long id;\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">RegistrationResult</span><span class=\"hljs-params\">()</span> </span>{\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">RegistrationResult</span><span class=\"hljs-params\">(Long id)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.id = id;\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Long <span class=\"hljs-title\">getId</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> id;\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setId</span><span class=\"hljs-params\">(Long id)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.id = id;\n    }\n}\n</code></pre>\n<p>并修改service方法：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\">RegistrationResult <span class=\"hljs-title\">registerUser</span><span class=\"hljs-params\">(User user)</span></span>;\n</code></pre>\n<p>这样不但能够解决XML序列化的问题，而且使得返回的数据都符合XML和JSON的规范。例如，在JSON中，返回的将是如下形式：</p>\n<pre><code class=\"language-javascript\">{<span class=\"hljs-string\">\"id\"</span>: <span class=\"hljs-number\">1001</span>}\n</code></pre>\n<p>如果不加wrapper，JSON返回值将直接是</p>\n<pre><code>1001 \t\n</code></pre>\n<p>而在XML中，加wrapper后返回值将是：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">registrationResult</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>1002<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">registrationResult</span>&gt;</span>\n</code></pre>\n<p>这种wrapper对象其实利用所谓Data Transfer Object（DTO）模式，采用DTO还能对传输数据做更多有用的定制。</p>\n<h3>定制序列化</h3>\n<p>如上所述，REST的底层实现会在service的对象和JSON/XML数据格式之间自动做序列化/反序列化。但有些场景下，如果觉得这种自动转换不满足要求，可以对其做定制。</p>\n<p>Dubbo中的REST实现是用JAXB做XML序列化，用Jackson做JSON序列化，所以在对象上添加JAXB或Jackson的annotation即可以定制映射。</p>\n<p>例如，定制对象属性映射到XML元素的名字：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@XmlRootElement</span>\n<span class=\"hljs-meta\">@XmlAccessorType</span>(XmlAccessType.FIELD)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">User</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Serializable</span> </span>{\n    \n    <span class=\"hljs-meta\">@XmlElement</span>(name=<span class=\"hljs-string\">\"username\"</span>) \n    <span class=\"hljs-keyword\">private</span> String name;  \n}\n</code></pre>\n<p>定制对象属性映射到JSON字段的名字：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">User</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Serializable</span> </span>{\n    \n    <span class=\"hljs-meta\">@JsonProperty</span>(<span class=\"hljs-string\">\"username\"</span>)\n    <span class=\"hljs-keyword\">private</span> String name;\n}\n</code></pre>\n<p>更多资料请参考JAXB和Jackson的官方文档，或自行google。</p>\n<h3>配置REST Server的实现</h3>\n<p>目前在dubbo中，我们支持5种嵌入式rest server的实现，并同时支持采用外部应用服务器来做rest server的实现。rest server可以通过如下配置实现：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">server</span>=<span class=\"hljs-string\">\"jetty\"</span>/&gt;</span>\n</code></pre>\n<p>以上配置选用了嵌入式的jetty来做rest server，同时，如果不配置server属性，rest协议默认也是选用jetty。jetty是非常成熟的java servlet容器，并和dubbo已经有较好的集成（目前5种嵌入式server中只有jetty和后面所述的tomcat、tjws，与dubbo监控系统等完成了无缝的集成），所以，如果你的dubbo系统是单独启动的进程，你可以直接默认采用jetty即可。</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">server</span>=<span class=\"hljs-string\">\"tomcat\"</span>/&gt;</span>\n</code></pre>\n<p>以上配置选用了嵌入式的tomcat来做rest server。在嵌入式tomcat上，REST的性能比jetty上要好得多（参见后面的基准测试），建议在需要高性能的场景下采用tomcat。</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">server</span>=<span class=\"hljs-string\">\"netty\"</span>/&gt;</span>\n</code></pre>\n<p>以上配置选用嵌入式的netty来做rest server。（TODO more contents to add）</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">server</span>=<span class=\"hljs-string\">\"tjws\"</span>/&gt;</span> (tjws is now deprecated)\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">server</span>=<span class=\"hljs-string\">\"sunhttp\"</span>/&gt;</span>\n</code></pre>\n<p>以上配置选用嵌入式的tjws或Sun HTTP server来做rest server。这两个server实现非常轻量级，非常方便在集成测试中快速启动使用，当然也可以在负荷不高的生产环境中使用。\t注：tjws目前已经被deprecated掉了，因为它不能很好的和servlet 3.1 API工作。</p>\n<p>如果你的dubbo系统不是单独启动的进程，而是部署到了Java应用服务器中，则建议你采用以下配置：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">server</span>=<span class=\"hljs-string\">\"servlet\"</span>/&gt;</span>\n</code></pre>\n<p>通过将server设置为servlet，dubbo将采用外部应用服务器的servlet容器来做rest server。同时，还要在dubbo系统的web.xml中添加如下配置：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">web-app</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">context-param</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param-name</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">param-value</span>&gt;</span>/WEB-INF/classes/META-INF/spring/dubbo-demo-provider.xml<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">param-value</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">context-param</span>&gt;</span>\n    \n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">listener</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">listener-class</span>&gt;</span>org.apache.dubbo.remoting.http.servlet.BootstrapListener<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">listener-class</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">listener</span>&gt;</span>\n    \n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">listener</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">listener-class</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">listener</span>&gt;</span>\n    \n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">servlet</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">servlet-name</span>&gt;</span>dispatcher<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">servlet-name</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">servlet-class</span>&gt;</span>org.apache.dubbo.remoting.http.servlet.DispatcherServlet<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">servlet-class</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">load-on-startup</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">load-on-startup</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">servlet</span>&gt;</span>\n    \n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">servlet-mapping</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">servlet-name</span>&gt;</span>dispatcher<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">servlet-name</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">url-pattern</span>&gt;</span>/*<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">url-pattern</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">servlet-mapping</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">web-app</span>&gt;</span>\n</code></pre>\n<p>即必须将dubbo的BootstrapListener和DispatherServlet添加到web.xml，以完成dubbo的REST功能与外部servlet容器的集成。</p>\n<blockquote>\n<p>注意：如果你是用spring的ContextLoaderListener来加载spring，则必须保证BootstrapListener配置在ContextLoaderListener之前，否则dubbo初始化会出错。</p>\n</blockquote>\n<p>其实，这种场景下你依然可以坚持用嵌入式server，但外部应用服务器的servlet容器往往比嵌入式server更加强大（特别是如果你是部署到更健壮更可伸缩的WebLogic，WebSphere等），另外有时也便于在应用服务器做统一管理、监控等等。</p>\n<h3>获取上下文（Context）信息</h3>\n<p>在远程调用中，值得获取的上下文信息可能有很多种，这里特别以获取客户端IP为例。</p>\n<p>在dubbo的REST中，我们有两种方式获取客户端IP。</p>\n<p>第一种方式，用JAX-RS标准的@Context annotation：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> User <span class=\"hljs-title\">getUser</span><span class=\"hljs-params\">(@PathParam(<span class=\"hljs-string\">\"id\"</span>)</span> Long id, @Context HttpServletRequest request) </span>{\n    System.out.println(<span class=\"hljs-string\">\"Client address is \"</span> + request.getRemoteAddr());\n} \n</code></pre>\n<p>用Context修饰getUser()的一个方法参数后，就可以将当前的HttpServletRequest注入进来，然后直接调用servlet api获取IP。</p>\n<blockquote>\n<p>注意：这种方式只能在将server设置为 tjws、tomcat、jetty 或者 servlet 的时候才能工作，因为只有这几种 server 的实现才提供了 servlet 容器。另外，标准的JAX-RS还支持用@Context修饰service类的一个实例字段来获取HttpServletRequest，但在dubbo中我们没有对此作出支持。</p>\n</blockquote>\n<p>第二种方式，用dubbo中常用的RpcContext：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> User <span class=\"hljs-title\">getUser</span><span class=\"hljs-params\">(@PathParam(<span class=\"hljs-string\">\"id\"</span>)</span> Long id) </span>{\n    System.out.println(<span class=\"hljs-string\">\"Client address is \"</span> + RpcContext.getContext().getRemoteAddressString());\n} \n</code></pre>\n<blockquote>\n<p>注意：这种方式只能在设置server=&quot;jetty&quot;或者server=&quot;tomcat&quot;或者server=&quot;servlet&quot;或者server=&quot;tjws&quot;的时候才能工作。另外，目前dubbo的RpcContext是一种比较有侵入性的用法，未来我们很可能会做出重构。</p>\n</blockquote>\n<p>如果你想保持你的项目对JAX-RS的兼容性，未来脱离dubbo也可以运行，请选择第一种方式。如果你想要更优雅的服务接口定义，请选用第二种方式。</p>\n<p>此外，在最新的dubbo rest中，还支持通过RpcContext来获取HttpServletRequest和HttpServletResponse，以提供更大的灵活性来方便用户实现某些复杂功能，比如在dubbo标准的filter中访问HTTP Header。用法示例如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">if</span> (RpcContext.getContext().getRequest() != <span class=\"hljs-keyword\">null</span> &amp;&amp; RpcContext.getContext().getRequest() <span class=\"hljs-keyword\">instanceof</span> HttpServletRequest) {\n    System.out.println(<span class=\"hljs-string\">\"Client address is \"</span> + ((HttpServletRequest) RpcContext.getContext().getRequest()).getRemoteAddr());\n}\n\n<span class=\"hljs-keyword\">if</span> (RpcContext.getContext().getResponse() != <span class=\"hljs-keyword\">null</span> &amp;&amp; RpcContext.getContext().getResponse() <span class=\"hljs-keyword\">instanceof</span> HttpServletResponse) {\n    System.out.println(<span class=\"hljs-string\">\"Response object from RpcContext: \"</span> + RpcContext.getContext().getResponse());\n}\n</code></pre>\n<blockquote>\n<p>注意：为了保持协议的中立性，RpcContext.getRequest()和RpcContext.getResponse()返回的仅仅是一个Object类，而且可能为null。所以，你必须自己做null和类型的检查。</p>\n</blockquote>\n<blockquote>\n<p>注意：只有在设置server=&quot;jetty&quot;或者server=&quot;tomcat&quot;或者server=&quot;servlet&quot;的时候，你才能通过以上方法正确的得到HttpServletRequest和HttpServletResponse，因为只有这几种server实现了servlet容器。</p>\n</blockquote>\n<p>为了简化编程，在此你也可以用泛型的方式来直接获取特定类型的request/response：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">if</span> (RpcContext.getContext().getRequest(HttpServletRequest.class) != <span class=\"hljs-keyword\">null</span>) {\n    System.out.println(<span class=\"hljs-string\">\"Client address is \"</span> + RpcContext.getContext().getRequest(HttpServletRequest.class).getRemoteAddr());\n}\n\n<span class=\"hljs-keyword\">if</span> (RpcContext.getContext().getResponse(HttpServletResponse.class) != <span class=\"hljs-keyword\">null</span>) {\n    System.out.println(<span class=\"hljs-string\">\"Response object from RpcContext: \"</span> + RpcContext.getContext().getResponse(HttpServletResponse.class));\n}\n</code></pre>\n<p>如果request/response不符合指定的类型，这里也会返回null。</p>\n<h3>配置端口号和Context Path</h3>\n<p>dubbo中的rest协议默认将采用80端口，如果想修改端口，直接配置：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">port</span>=<span class=\"hljs-string\">\"8888\"</span>/&gt;</span>\n</code></pre>\n<p>另外，如前所述，我们可以用@Path来配置单个rest服务的URL相对路径。但其实，我们还可以设置一个所有rest服务都适用的基础相对路径，即java web应用中常说的context path。</p>\n<p>只需要添加如下contextpath属性即可：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">port</span>=<span class=\"hljs-string\">\"8888\"</span> <span class=\"hljs-attr\">contextpath</span>=<span class=\"hljs-string\">\"services\"</span>/&gt;</span>\n</code></pre>\n<p>以前面代码为例：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Path</span>(<span class=\"hljs-string\">\"/users\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">UserService</span> </span>{\n       \n    <span class=\"hljs-meta\">@POST</span>\n    <span class=\"hljs-meta\">@Path</span>(<span class=\"hljs-string\">\"/register\"</span>)\n    <span class=\"hljs-meta\">@Consumes</span>({MediaType.APPLICATION_JSON})\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerUser</span><span class=\"hljs-params\">(User user)</span> </span>{\n        <span class=\"hljs-comment\">// save the user...</span>\n    }\t\n}\n</code></pre>\n<p>现在registerUser()的完整访问路径为：</p>\n<pre><code>http://localhost:8888/services/users/register\n</code></pre>\n<p>注意：如果你是选用外部应用服务器做rest server，即配置:</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">port</span>=<span class=\"hljs-string\">\"8888\"</span> <span class=\"hljs-attr\">contextpath</span>=<span class=\"hljs-string\">\"services\"</span> <span class=\"hljs-attr\">server</span>=<span class=\"hljs-string\">\"servlet\"</span>/&gt;</span>\n</code></pre>\n<p>则必须保证这里设置的port、contextpath，与外部应用服务器的端口、DispatcherServlet的上下文路径（即webapp path加上servlet url pattern）保持一致。例如，对于部署为tomcat ROOT路径的应用，这里的contextpath必须与web.xml中DispacherServlet的<code>&lt;url-pattern/&gt;</code>完全一致：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">servlet-mapping</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">servlet-name</span>&gt;</span>dispatcher<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">servlet-name</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">url-pattern</span>&gt;</span>/services/*<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">url-pattern</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">servlet-mapping</span>&gt;</span>\n</code></pre>\n<h3>配置线程数和IO线程数</h3>\n<p>可以为rest服务配置线程池大小：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">threads</span>=<span class=\"hljs-string\">\"500\"</span>/&gt;</span>\n</code></pre>\n<blockquote>\n<p>注意：目前线程池的设置只有当server=&quot;netty&quot;或者server=&quot;jetty&quot;或者server=&quot;tomcat&quot;的时候才能生效。另外，如果server=&quot;servlet&quot;，由于这时候启用的是外部应用服务器做rest server，不受dubbo控制，所以这里的线程池设置也无效。</p>\n</blockquote>\n<p>如果是选用netty server，还可以配置Netty的IO worker线程数：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">iothreads</span>=<span class=\"hljs-string\">\"5\"</span> <span class=\"hljs-attr\">threads</span>=<span class=\"hljs-string\">\"100\"</span>/&gt;</span>\n</code></pre>\n<h3>配置长连接</h3>\n<p>Dubbo中的rest服务默认都是采用http长连接来访问，如果想切换为短连接，直接配置：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">keepalive</span>=<span class=\"hljs-string\">\"false\"</span>/&gt;</span>\n</code></pre>\n<blockquote>\n<p>注意：这个配置目前只对server=&quot;netty&quot;和server=&quot;tomcat&quot;才能生效。</p>\n</blockquote>\n<h3>配置最大的HTTP连接数</h3>\n<p>可以配置服务器提供端所能同时接收的最大HTTP连接数，防止REST server被过多连接撑爆，以作为一种最基本的自我保护机制：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">accepts</span>=<span class=\"hljs-string\">\"500\"</span> <span class=\"hljs-attr\">server</span>=<span class=\"hljs-string\">\"tomcat/&gt;\n</span></span></code></pre>\n<blockquote>\n<p>注意：这个配置目前只对server=&quot;tomcat&quot;才能生效。</p>\n</blockquote>\n<h3>配置每个消费端的超时时间和HTTP连接数</h3>\n<p>如果rest服务的消费端也是dubbo系统，可以像其他dubbo RPC机制一样，配置消费端调用此rest服务的最大超时时间以及每个消费端所能启动的最大HTTP连接数。</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"xxx\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"xxx\"</span> <span class=\"hljs-attr\">protocol</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">timeout</span>=<span class=\"hljs-string\">\"2000\"</span> <span class=\"hljs-attr\">connections</span>=<span class=\"hljs-string\">\"10\"</span>/&gt;</span>\n</code></pre>\n<p>当然，由于这个配置针对消费端生效的，所以也可以在消费端配置：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"xxx\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"xxx\"</span> <span class=\"hljs-attr\">timeout</span>=<span class=\"hljs-string\">\"2000\"</span> <span class=\"hljs-attr\">connections</span>=<span class=\"hljs-string\">\"10\"</span>/&gt;</span>\n</code></pre>\n<p>但是，通常我们建议配置在服务提供端提供此类配置。按照dubbo官方文档的说法：“Provider上尽量多配置Consumer端的属性，让Provider实现者一开始就思考Provider服务特点、服务质量的问题。”</p>\n<blockquote>\n<p>注意：如果dubbo的REST服务是发布给非dubbo的客户端使用，则这里<code>&lt;dubbo:service/&gt;</code>上的配置完全无效，因为这种客户端不受dubbo控制。</p>\n</blockquote>\n<h3>用Annotation取代部分Spring XML配置</h3>\n<p>以上所有的讨论都是基于dubbo在spring中的xml配置。但是，dubbo/spring本身也支持用annotation来作配置，所以我们也可以按dubbo官方文档中的步骤，把相关annotation加到REST服务的实现中，取代一些xml配置，例如：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Service</span>(protocol = <span class=\"hljs-string\">\"rest\"</span>)\n<span class=\"hljs-meta\">@Path</span>(<span class=\"hljs-string\">\"/users\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">UserService</span> </span>{\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> UserRepository userRepository;\n       \n    <span class=\"hljs-meta\">@POST</span>\n    <span class=\"hljs-meta\">@Path</span>(<span class=\"hljs-string\">\"/register\"</span>)\n    <span class=\"hljs-meta\">@Consumes</span>({MediaType.APPLICATION_JSON})\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerUser</span><span class=\"hljs-params\">(User user)</span> </span>{\n        <span class=\"hljs-comment\">// save the user</span>\n        userRepository.save(user);\n    }\t\n}\n</code></pre>\n<p>annotation的配置更简单更精确，通常也更便于维护（当然现代IDE都可以在xml中支持比如类名重构，所以就这里的特定用例而言，xml的维护性也很好）。而xml对代码的侵入性更小一些，尤其有利于动态修改配置，特别是比如你要针对单个服务配置连接超时时间、每客户端最大连接数、集群策略、权重等等。另外，特别对复杂应用或者模块来说，xml提供了一个中心点来涵盖的所有组件和配置，更一目了然，一般更便于项目长时期的维护。</p>\n<p>当然，选择哪种配置方式没有绝对的优劣，和个人的偏好也不无关系。</p>\n<h3>添加自定义的Filter、Interceptor等</h3>\n<p>Dubbo的REST也支持JAX-RS标准的Filter和Interceptor，以方便对REST的请求与响应过程做定制化的拦截处理。</p>\n<p>其中，Filter主要用于访问和设置HTTP请求和响应的参数、URI等等。例如，设置HTTP响应的cache header：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CacheControlFilter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ContainerResponseFilter</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">filter</span><span class=\"hljs-params\">(ContainerRequestContext req, ContainerResponseContext res)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (req.getMethod().equals(<span class=\"hljs-string\">\"GET\"</span>)) {\n            res.getHeaders().add(<span class=\"hljs-string\">\"Cache-Control\"</span>, <span class=\"hljs-string\">\"someValue\"</span>);\n        }\n    }\n}\n</code></pre>\n<p>Interceptor主要用于访问和修改输入与输出字节流，例如，手动添加GZIP压缩：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GZIPWriterInterceptor</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">WriterInterceptor</span> </span>{\n \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">aroundWriteTo</span><span class=\"hljs-params\">(WriterInterceptorContext context)</span>\n                    <span class=\"hljs-keyword\">throws</span> IOException, WebApplicationException </span>{\n        OutputStream outputStream = context.getOutputStream();\n        context.setOutputStream(<span class=\"hljs-keyword\">new</span> GZIPOutputStream(outputStream));\n        context.proceed();\n    }\n}\n</code></pre>\n<p>在标准JAX-RS应用中，我们一般是为Filter和Interceptor添加@Provider annotation，然后JAX-RS runtime会自动发现并启用它们。而在dubbo中，我们是通过添加XML配置的方式来注册Filter和Interceptor：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">port</span>=<span class=\"hljs-string\">\"8888\"</span> <span class=\"hljs-attr\">extension</span>=<span class=\"hljs-string\">\"xxx.TraceInterceptor, xxx.TraceFilter\"</span>/&gt;</span>\n</code></pre>\n<p>在此，我们可以将Filter、Interceptor和DynamicFeature这三种类型的对象都添加到<code>extension</code>属性上，多个之间用逗号分隔。（DynamicFeature是另一个接口，可以方便我们更动态的启用Filter和Interceptor，感兴趣请自行google。）</p>\n<p>当然，dubbo自身也支持Filter的概念，但我们这里讨论的Filter和Interceptor更加接近协议实现的底层，相比dubbo的filter，可以做更底层的定制化。</p>\n<blockquote>\n<p>注：这里的XML属性叫extension，而不是叫interceptor或者filter，是因为除了Interceptor和Filter，未来我们还会添加更多的扩展类型。</p>\n</blockquote>\n<p>如果REST的消费端也是dubbo系统（参见下文的讨论），则也可以用类似方式为消费端配置Interceptor和Filter。但注意，JAX-RS中消费端的Filter和提供端的Filter是两种不同的接口。例如前面例子中服务端是ContainerResponseFilter接口，而消费端对应的是ClientResponseFilter:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LoggingFilter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ClientResponseFilter</span> </span>{\n \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">filter</span><span class=\"hljs-params\">(ClientRequestContext reqCtx, ClientResponseContext resCtx)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        System.out.println(<span class=\"hljs-string\">\"status: \"</span> + resCtx.getStatus());\n\t    System.out.println(<span class=\"hljs-string\">\"date: \"</span> + resCtx.getDate());\n\t    System.out.println(<span class=\"hljs-string\">\"last-modified: \"</span> + resCtx.getLastModified());\n\t    System.out.println(<span class=\"hljs-string\">\"location: \"</span> + resCtx.getLocation());\n\t    System.out.println(<span class=\"hljs-string\">\"headers:\"</span>);\n\t    <span class=\"hljs-keyword\">for</span> (Entry&lt;String, List&lt;String&gt;&gt; header : resCtx.getHeaders().entrySet()) {\n     \t    System.out.print(<span class=\"hljs-string\">\"\\t\"</span> + header.getKey() + <span class=\"hljs-string\">\" :\"</span>);\n\t        <span class=\"hljs-keyword\">for</span> (String value : header.getValue()) {\n\t            System.out.print(value + <span class=\"hljs-string\">\", \"</span>);\n\t        }\n\t        System.out.print(<span class=\"hljs-string\">\"\\n\"</span>);\n\t    }\n\t    System.out.println(<span class=\"hljs-string\">\"media-type: \"</span> + resCtx.getMediaType().getType());\n    } \n}\n</code></pre>\n<h3>添加自定义的Exception处理</h3>\n<p>Dubbo的REST也支持JAX-RS标准的ExceptionMapper，可以用来定制特定exception发生后应该返回的HTTP响应。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomExceptionMapper</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ExceptionMapper</span>&lt;<span class=\"hljs-title\">NotFoundException</span>&gt; </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Response <span class=\"hljs-title\">toResponse</span><span class=\"hljs-params\">(NotFoundException e)</span> </span>{     \n        <span class=\"hljs-keyword\">return</span> Response.status(Response.Status.NOT_FOUND).entity(<span class=\"hljs-string\">\"Oops! the requested resource is not found!\"</span>).type(<span class=\"hljs-string\">\"text/plain\"</span>).build();\n    }\n}\n</code></pre>\n<p>和Interceptor、Filter类似，将其添加到XML配置文件中即可启用：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">port</span>=<span class=\"hljs-string\">\"8888\"</span> <span class=\"hljs-attr\">extension</span>=<span class=\"hljs-string\">\"xxx.CustomExceptionMapper\"</span>/&gt;</span>\n</code></pre>\n<h3>配置HTTP日志输出</h3>\n<p>Dubbo rest支持输出所有HTTP请求/响应中的header字段和body消息体。</p>\n<p>在XML配置中添加如下自带的REST filter：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">port</span>=<span class=\"hljs-string\">\"8888\"</span> <span class=\"hljs-attr\">extension</span>=<span class=\"hljs-string\">\"org.apache.dubbo.rpc.protocol.rest.support.LoggingFilter\"</span>/&gt;</span>\n</code></pre>\n<p>然后配置在logging配置中至少为org.apache.dubbo.rpc.protocol.rest.support打开INFO级别日志输出，例如，在log4j.xml中配置：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">logger</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"org.apache.dubbo.rpc.protocol.rest.support\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">level</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"INFO\"</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">appender-ref</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"CONSOLE\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">logger</span>&gt;</span>\n</code></pre>\n<p>当然，你也可以直接在ROOT logger打开INFO级别日志输出：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">root</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">level</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"INFO\"</span> /&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">appender-ref</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"CONSOLE\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">root</span>&gt;</span>\n</code></pre>\n<p>然后在日志中会有类似如下的内容输出：</p>\n<pre><code>The HTTP headers are: \naccept: application/json;charset=UTF-8\naccept-encoding: gzip, deflate\nconnection: Keep-Alive\ncontent-length: 22\ncontent-type: application/json\nhost: 192.168.1.100:8888\nuser-agent: Apache-HttpClient/4.2.1 (java 1.5)\n</code></pre>\n<pre><code>The contents of request body is: \n{&quot;id&quot;:1,&quot;name&quot;:&quot;dang&quot;}\n</code></pre>\n<p>打开HTTP日志输出后，除了正常日志输出的性能开销外，也会在比如HTTP请求解析时产生额外的开销，因为需要建立额外的内存缓冲区来为日志的输出做数据准备。</p>\n<h3>输入参数的校验</h3>\n<p>dubbo的rest支持采用Java标准的bean validation annotation（JSR 303)来做输入校验http://beanvalidation.org/</p>\n<p>为了和其他dubbo远程调用协议保持一致，在rest中作校验的annotation必须放在服务的接口上，例如：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">UserService</span> </span>{\n   \n    <span class=\"hljs-function\">User <span class=\"hljs-title\">getUser</span><span class=\"hljs-params\">(@Min(value=<span class=\"hljs-number\">1</span>L, message=<span class=\"hljs-string\">\"User ID must be greater than 1\"</span>)</span> Long id)</span>;\n}\n\n</code></pre>\n<p>当然，在很多其他的bean validation的应用场景都是将annotation放到实现类而不是接口上。把annotation放在接口上至少有一个好处是，dubbo的客户端可以共享这个接口的信息，dubbo甚至不需要做远程调用，在本地就可以完成输入校验。</p>\n<p>然后按照dubbo的标准方式在XML配置中打开验证：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">xxx.UserService</span>\" <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"userService\"</span> <span class=\"hljs-attr\">protocol</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">validation</span>=<span class=\"hljs-string\">\"true\"</span>/&gt;</span>\n</code></pre>\n<p>在dubbo的其他很多远程调用协议中，如果输入验证出错，是直接将<code>RpcException</code>抛向客户端，而在rest中由于客户端经常是非dubbo，甚至非java的系统，所以不便直接抛出Java异常。因此，目前我们将校验错误以XML的格式返回：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">violationReport</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">constraintViolations</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span>&gt;</span>getUserArgument0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">message</span>&gt;</span>User ID must be greater than 1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">message</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">value</span>&gt;</span>0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">value</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">constraintViolations</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">violationReport</span>&gt;</span>\n</code></pre>\n<p>稍后也会支持其他数据格式的返回值。至于如何对验证错误消息作国际化处理，直接参考bean validation的相关文档即可。</p>\n<p>如果你认为默认的校验错误返回格式不符合你的要求，可以如上面章节所述，添加自定义的ExceptionMapper来自由的定制错误返回格式。需要注意的是，这个ExceptionMapper必须用泛型声明来捕获dubbo的RpcException，才能成功覆盖dubbo rest默认的异常处理策略。为了简化操作，其实这里最简单的方式是直接继承dubbo rest的RpcExceptionMapper，并覆盖其中处理校验异常的方法即可：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyValidationExceptionMapper</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">RpcExceptionMapper</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Response <span class=\"hljs-title\">handleConstraintViolationException</span><span class=\"hljs-params\">(ConstraintViolationException cve)</span> </span>{\n        ViolationReport report = <span class=\"hljs-keyword\">new</span> ViolationReport();\n        <span class=\"hljs-keyword\">for</span> (ConstraintViolation cv : cve.getConstraintViolations()) {\n            report.addConstraintViolation(<span class=\"hljs-keyword\">new</span> RestConstraintViolation(\n                    cv.getPropertyPath().toString(),\n                    cv.getMessage(),\n                    cv.getInvalidValue() == <span class=\"hljs-keyword\">null</span> ? <span class=\"hljs-string\">\"null\"</span> : cv.getInvalidValue().toString()));\n        }\n        <span class=\"hljs-comment\">// 采用json输出代替xml输出</span>\n        <span class=\"hljs-keyword\">return</span> Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(report).type(ContentType.APPLICATION_JSON_UTF_8).build();\n    }\n}\n</code></pre>\n<p>然后将这个ExceptionMapper添加到XML配置中即可：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"rest\"</span> <span class=\"hljs-attr\">port</span>=<span class=\"hljs-string\">\"8888\"</span> <span class=\"hljs-attr\">extension</span>=<span class=\"hljs-string\">\"xxx.MyValidationExceptionMapper\"</span>/&gt;</span>\n</code></pre>\n",
  "link": "/zh-cn/docs/user/references/protocol/rest.html",
  "meta": {}
}