<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="RESTful Remoting, REST" />
	<meta name="description" content="在 Dubbo 中开发 REST 风格的远程调用" />
	<!-- 网页标签标题 -->
	<title>在 Dubbo 中开发 REST 风格的远程调用（RESTful Remoting）</title>
	<link rel="shortcut icon" href="/img/dubbo.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/dubbo_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/user/quick-start.html">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/docs/developers/developers_dev.html">开发者</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html">博客</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html">社区</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/download.html">下载</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/docs.png" class="front-img"/><span>文档</span><img src="/img/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>用户文档</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>入门<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/background.html" target="_self">背景</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/requirements.html" target="_self">需求</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/architecture.html" target="_self">架构</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/preface/usage.html" target="_self">用法</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/quick-start.html" target="_self">快速启动</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/dependencies.html" target="_self">依赖</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/maturity.html" target="_self">成熟度</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>配置<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/xml.html" target="_self">XML配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/api.html" target="_self">API配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/annotation.html" target="_self">注解配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/config-center.html" target="_self">动态配置中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/configuration/configuration-load-process.html" target="_self">配置加载流程</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>示例<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/preflight-check.html" target="_self">启动时检查</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/fault-tolerent-strategy.html" target="_self">集群容错</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/loadbalance.html" target="_self">负载均衡</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/thread-model.html" target="_self">线程模型</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/explicit-target.html" target="_self">直连提供者</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/subscribe-only.html" target="_self">只订阅</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/registry-only.html" target="_self">只注册</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/static-service.html" target="_self">静态服务</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/multi-protocols.html" target="_self">多协议</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/multi-registry.html" target="_self">多注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/service-group.html" target="_self">服务分组</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/multi-versions.html" target="_self">多版本</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/group-merger.html" target="_self">分组聚合</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/parameter-validation.html" target="_self">参数验证</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/result-cache.html" target="_self">结果缓存</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/generic-reference.html" target="_self">泛化引用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/generic-service.html" target="_self">泛化实现</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/echo-service.html" target="_self">回声测试</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/context.html" target="_self">上下文信息</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/attachment.html" target="_self">隐式参数</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/async-call.html" target="_self">Consumer异步调用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/async-execute-on-provider.html" target="_self">Provider异步执行</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/local-call.html" target="_self">本地调用</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/callback-parameter.html" target="_self">参数回调</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/events-notify.html" target="_self">事件通知</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/local-stub.html" target="_self">本地存根</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/local-mock.html" target="_self">本地伪装</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/delay-publish.html" target="_self">延迟暴露</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/concurrency-control.html" target="_self">并发控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/config-connections.html" target="_self">连接控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/lazy-connect.html" target="_self">延迟连接</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/stickiness.html" target="_self">粘滞连接</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/token-authorization.html" target="_self">令牌验证</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/routing-rule.html" target="_self">路由规则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/config-rule.html" target="_self">配置规则</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/service-downgrade.html" target="_self">服务降级</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/graceful-shutdown.html" target="_self">优雅停机</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/hostname-binding.html" target="_self">主机绑定</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/logger-strategy.html" target="_self">日志适配</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/accesslog.html" target="_self">访问日志</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/service-container.html" target="_self">服务容器</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/reference-config-cache.html" target="_self">Reference Config 缓存</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/distributed-transaction.html" target="_self">分布式事务</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/dump.html" target="_self">线程栈自动dump</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/netty4.html" target="_self">Netty4</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/serialization.html" target="_self">Kryo和FST序列化</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/demos/simplify-registry-data.html" target="_self">简化注册中心URL</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/api.html" target="_self">API配置参考手册</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>schema配置参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-service.html" target="_self">dubbo:service</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-reference.html" target="_self">dubbo:reference</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-protocol.html" target="_self">dubbo:protocol</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-registry.html" target="_self">dubbo:registry</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-monitor.html" target="_self">dubbo:monitor</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-application.html" target="_self">dubbo:application</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-module.html" target="_self">dubbo:module</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-provider.html" target="_self">dubbo:provider</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-consumer.html" target="_self">dubbo:consumer</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-method.html" target="_self">dubbo:method</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-argument.html" target="_self">dubbo:argument</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-parameter.html" target="_self">dubbo:parameter</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/xml/dubbo-config-center.html" target="_self">dubbo:config-center</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>协议参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/dubbo.html" target="_self">dubbo://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/rmi.html" target="_self">rmi://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/hessian.html" target="_self">hessian://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/http.html" target="_self">http://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/webservice.html" target="_self">webservice://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/thrift.html" target="_self">thrift://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/memcached.html" target="_self">memcached://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/redis.html" target="_self">redis://</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/protocol/rest.html" target="_self">rest://</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>注册中心参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/multicast.html" target="_self">Multicast 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/zookeeper.html" target="_self">Zookeeper 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/nacos.html" target="_self">Nacos 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/redis.html" target="_self">Redis 注册中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/registry/simple.html" target="_self">Simple 注册中心</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>元数据中心参考手册<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/metadata/introduction.html" target="_self">介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/metadata/metadata-redis.html" target="_self">Redis</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/references/metadata/metadata-zookeeper.html" target="_self">Zookeeper</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/telnet.html" target="_self">telnet命令参考手册</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/qos.html" target="_self">在线运维命令-QOS</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/references/maven.html" target="_self">maven插件参考手册</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/best-practice.html" target="_self">服务化最佳实践</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/recommend.html" target="_self">推荐用法</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/capacity-plan.html" target="_self">容量规划</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/perf-test.html" target="_self">性能测试报告</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/user/coveragence.html" target="_self">测试覆盖率报告</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>版本与升级<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/user/versions/version-270.html" target="_self">2.7.x升级步骤及注意事项</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>开发者指南</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/build.html" target="_self">源码构建</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/design.html" target="_self">框架设计</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/SPI.html" target="_self">扩展点加载</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/implementation.html" target="_self">实现细节</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>SPI 扩展实现<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/protocol.html" target="_self">协议扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/filter.html" target="_self">调用拦截扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/invoker-listener.html" target="_self">引用监听扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/exporter-listener.html" target="_self">暴露监听扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/cluster.html" target="_self">集群扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/router.html" target="_self">路由扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/load-balance.html" target="_self">负载均衡扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/merger.html" target="_self">合并结果扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/registry.html" target="_self">注册中心扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/monitor.html" target="_self">监控中心扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/extension-factory.html" target="_self">扩展点加载扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/proxy-factory.html" target="_self">动态代理扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/compiler.html" target="_self">编译器扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/dispatcher.html" target="_self">消息派发扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/threadpool.html" target="_self">线程池扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/serialize.html" target="_self">序列化扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/remoting.html" target="_self">网络传输扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/exchanger.html" target="_self">信息交换扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/networker.html" target="_self">组网扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/telnet-handler.html" target="_self">Telnet 命令扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/status-checker.html" target="_self">状态检查扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/container.html" target="_self">容器扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/page.html" target="_self">页面扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/cache.html" target="_self">缓存扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/validation.html" target="_self">验证扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/impls/logger-adapter.html" target="_self">日志适配扩展</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/contract.html" target="_self">公共契约</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/coding.html" target="_self">编码约定</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>设计原则<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/code-detail.html" target="_self">魔鬼在细节</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/general-knowledge.html" target="_self">一些设计上的基本常识</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/expansibility.html" target="_self">谈谈扩充式扩展与增量式扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/configuration.html" target="_self">配置设计</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/robustness.html" target="_self">设计实现的健壮性</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/dummy.html" target="_self">防痴呆设计</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dev/principals/extension.html" target="_self">扩展点重构</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/release.html" target="_self">版本管理</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/contribution.html" target="_self">贡献</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/checklist.html" target="_self">检查列表</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/code-smell.html" target="_self">坏味道</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dev/TCK.html" target="_self">技术兼容性测试</a></li></ul></li><li class="menu-item menu-item-level-1"><span>源码导读</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/dubbo-spi.html" target="_self">Dubbo SPI</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/adaptive-extension.html" target="_self">自适应拓展机制</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/export-service.html" target="_self">服务导出</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/refer-service.html" target="_self">服务引入</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/directory.html" target="_self">服务字典</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/router.html" target="_self">服务路由</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/cluster.html" target="_self">集群</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/loadbalance.html" target="_self">负载均衡</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/source_code_guide/service-invoking-process.html" target="_self">服务调用过程</a></li></ul></li><li class="menu-item menu-item-level-1"><span>运维管理</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/admin/introduction.html" target="_self">控制台介绍</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/admin/serviceSearch.html" target="_self">服务搜索</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/admin/serviceGovernance.html" target="_self">服务治理</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/admin/serviceTest.html" target="_self">服务测试</a></li></ul></li></ul></div><div class="doc-content markdown-body"><h1>在 Dubbo 中开发 REST 风格的远程调用（RESTful Remoting）</h1>
<p><strong>作者：沈理</strong></p>
<p><strong>文档版权：<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0许可证 署名-禁止演绎</a></strong></p>
<p>完善中……</p>
<blockquote>
<p>本文篇幅较长，因为REST本身涉及面较多。另外，本文参照Spring等的文档风格，不仅仅局限于框架用法的阐述，同时也努力呈现框架的设计理念和优良应用的架构思想。</p>
</blockquote>
<blockquote>
<p>对于想粗略了解dubbo和REST的人，只需浏览 <code>概述</code> 至 <code>标准Java REST API：JAX-RS简介</code> 几节即可。</p>
</blockquote>
<p>TODO 生成可点击的目录</p>
<h2>目录</h2>
<ul>
<li>概述</li>
<li>REST的优点</li>
<li>应用场景</li>
<li>快速入门</li>
<li>标准Java REST API：JAX-RS简介</li>
<li>REST服务提供端详解
<ul>
<li>HTTP POST/GET的实现</li>
<li>Annotation放在接口类还是实现类</li>
<li>JSON、XML等多数据格式的支持</li>
<li>中文字符支持</li>
<li>XML数据格式的额外要求</li>
<li>定制序列化</li>
<li>配置REST Server的实现</li>
<li>获取上下文（Context）信息</li>
<li>配置端口号和Context Path</li>
<li>配置线程数和IO线程数</li>
<li>配置长连接</li>
<li>配置最大的HTTP连接数</li>
<li>配置每个消费端的超时时间和HTTP连接数</li>
<li>GZIP数据压缩</li>
<li>用Annotation取代部分Spring XML配置</li>
<li>添加自定义的Filter、Interceptor等</li>
<li>添加自定义的Exception处理</li>
<li>配置HTTP日志输出</li>
<li>输入参数的校验</li>
<li>是否应该透明发布REST服务</li>
</ul>
</li>
<li>REST服务消费端详解
<ul>
<li>场景1：非dubbo的消费端调用dubbo的REST服务</li>
<li>场景2：dubbo消费端调用dubbo的REST服务</li>
<li>场景3：dubbo的消费端调用非dubbo的REST服务</li>
</ul>
</li>
<li>Dubbo中JAX-RS的限制</li>
<li>REST常见问题解答（REST FAQ）
<ul>
<li>Dubbo REST的服务能和Dubbo注册中心、监控中心集成吗？</li>
<li>Dubbo REST中如何实现负载均衡和容错（failover）？</li>
<li>JAX-RS中重载的方法能够映射到同一URL地址吗？</li>
<li>JAX-RS中作POST的方法能够接收多个参数吗？</li>
</ul>
</li>
<li>Dubbo当前体系可能的不足之处（与REST相关的）
<ul>
<li>RpcContext的侵入性</li>
<li>Protocol配置的局限性</li>
<li>XML命名不符合spring规范</li>
</ul>
</li>
<li>REST最佳实践</li>
<li>性能基准测试
<ul>
<li>测试环境</li>
<li>测试脚本</li>
<li>测试结果</li>
</ul>
</li>
<li>扩展讨论
<ul>
<li>REST与Thrift、Protobuf等的对比</li>
<li>REST与传统WebServices的对比</li>
<li>JAX-RS与Spring MVC的对比</li>
</ul>
</li>
<li>未来</li>
</ul>
<h2>概述</h2>
<p>dubbo支持多种远程调用方式，例如dubbo RPC（二进制序列化 + tcp协议）、http invoker（二进制序列化 + http协议，至少在开源版本没发现对文本序列化的支持）、hessian（二进制序列化 + http协议）、WebServices （文本序列化 + http协议）等等，但缺乏对当今特别流行的REST风格远程调用（文本序列化 + http协议）的支持。</p>
<p>有鉴于此，我们基于标准的Java REST API——JAX-RS 2.0（Java API for RESTful Web Services的简写），为dubbo提供了接近透明的REST调用支持。由于完全兼容Java标准API，所以为dubbo开发的所有REST服务，未来脱离dubbo或者任何特定的REST底层实现一般也可以正常运行。</p>
<p>特别值得指出的是，我们并不需要完全严格遵守REST的原始定义和架构风格。即使著名的Twitter REST API也会根据情况做适度调整，而不是机械的遵守原始的REST风格。</p>
<blockquote>
<p>附注：我们将这个功能称之为REST风格的远程调用，即RESTful Remoting（抽象的远程处理或者调用），而不是叫RESTful RPC（具体的远程“过程”调用），是因为REST和RPC本身可以被认为是两种不同的风格。在dubbo的REST实现中，可以说有两个面向，其一是提供或消费正常的REST服务，其二是将REST作为dubbo RPC体系中一种协议实现，而RESTful Remoting同时涵盖了这两个面向。</p>
</blockquote>
<h2>REST的优点</h2>
<p>以下摘自维基百科：</p>
<ul>
<li>可更高效利用缓存来提高响应速度</li>
<li>通讯本身的无状态性可以让不同的服务器的处理一系列请求中的不同请求，提高服务器的扩展性</li>
<li>浏览器即可作为客户端，简化软件需求</li>
<li>相对于其他叠加在HTTP协议之上的机制，REST的软件依赖性更小</li>
<li>不需要额外的资源发现机制</li>
<li>在软件技术演进中的长期的兼容性更好</li>
</ul>
<p>这里我还想特别补充REST的显著优点：基于简单的文本格式消息和通用的HTTP协议，使它具备极广的适用性，几乎所有语言和平台都对它提供支持，同时其学习和使用的门槛也较低。</p>
<h2>应用场景</h2>
<p>正是由于REST在适用性方面的优点，所以在dubbo中支持REST，可以为当今多数主流的远程调用场景都带来（显著）好处：</p>
<ol>
<li>
<p>显著简化企业内部的异构系统之间的（跨语言）调用。此处主要针对这种场景：dubbo的系统做服务提供端，其他语言的系统（也包括某些不基于dubbo的java系统）做服务消费端，两者通过HTTP和文本消息进行通信。即使相比Thrift、ProtoBuf等二进制跨语言调用方案，REST也有自己独特的优势（详见后面讨论）</p>
</li>
<li>
<p>显著简化对外Open API（开放平台）的开发。既可以用dubbo来开发专门的Open API应用，也可以将原内部使用的dubbo service直接“透明”发布为对外的Open REST API（当然dubbo本身未来最好可以较透明的提供诸如权限控制、频次控制、计费等诸多功能）</p>
</li>
<li>
<p>显著简化手机（平板）APP或者PC桌面客户端开发。类似于2，既可以用dubbo来开发专门针对无线或者桌面的服务器端，也可以将原内部使用的dubbo service直接”透明“的暴露给手机APP或桌面程序。当然在有些项目中，手机或桌面程序也可以直接访问以上场景2中所述的Open API。</p>
</li>
<li>
<p>显著简化浏览器AJAX应用的开发。类似于2，既可以用dubbo来开发专门的AJAX服务器端，也可以将原内部使用的dubbo service直接”透明“的暴露给浏览器中JavaScript。当然，很多AJAX应用更适合与web框架协同工作，所以直接访问dubbo service在很多web项目中未必是一种非常优雅的架构。</p>
</li>
<li>
<p>为企业内部的dubbo系统之间（即服务提供端和消费端都是基于dubbo的系统）提供一种基于文本的、易读的远程调用方式。</p>
</li>
<li>
<p>一定程度简化dubbo系统对其它异构系统的调用。可以用类似dubbo的简便方式“透明”的调用非dubbo系统提供的REST服务（不管服务提供端是在企业内部还是外部）</p>
</li>
</ol>
<p>需要指出的是，我认为1～3是dubbo的REST调用最有价值的三种应用场景，并且我们为dubbo添加REST调用，其最主要到目的也是面向服务的提供端，即开发REST服务来提供给非dubbo的（异构）消费端。</p>
<p>归纳起来，所有应用场景如下图所示：
<img src="sources/images/rest.jpg" alt="no image found"></p>
<p>借用Java过去最流行的宣传语，为dubbo添加REST调用后，可以实现服务的”一次编写，到处访问“，理论上可以面向全世界开放，从而真正实现比较理想化的面向服务架构（SOA）。</p>
<p>当然，传统的WebServices（WSDL/SOAP）也基本同样能满足以上场景（除了场景4）的要求（甚至还能满足那些需要企业级特性的场景），但由于其复杂性等问题，现在已经越来越少被实际采用了。</p>
<h2>快速入门</h2>
<p>在dubbo中开发一个REST风格的服务会比较简单，下面以一个注册用户的简单服务为例说明。</p>
<p>这个服务要实现的功能是提供如下URL（注：这个URL不是完全符合REST的风格，但是更简单实用）：</p>
<pre><code>http://localhost:8080/users/register
</code></pre>
<p>而任何客户端都可以将包含用户信息的JSON字符串POST到以上URL来完成用户注册。</p>
<p>首先，开发服务的接口：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>{    
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerUser</span><span class="hljs-params">(User user)</span></span>;
}
</code></pre>
<p>然后，开发服务的实现：</p>
<pre><code class="language-java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>{
       
    <span class="hljs-meta">@POST</span>
    <span class="hljs-meta">@Path</span>(<span class="hljs-string">"register"</span>)
    <span class="hljs-meta">@Consumes</span>({MediaType.APPLICATION_JSON})
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerUser</span><span class="hljs-params">(User user)</span> </span>{
        <span class="hljs-comment">// save the user...</span>
    }
}
</code></pre>
<p>上面的服务实现代码非常简单，但是由于REST服务是要被发布到特定HTTP URL，供任意语言客户端甚至浏览器来访问，所以这里要额外添加了几个JAX-RS的标准annotation来做相关的配置：</p>
<p>@Path(&quot;users&quot;)：指定访问UserService的URL相对路径是/users，即http://localhost:8080/users</p>
<p>@Path(&quot;register&quot;)：指定访问registerUser()方法的URL相对路径是/register，再结合上一个@Path为UserService指定的路径，则调用UserService.register()的完整路径为http://localhost:8080/users/register</p>
<p>@POST：指定访问registerUser()用HTTP POST方法</p>
<p>@Consumes({MediaType.APPLICATION_JSON})：指定registerUser()接收JSON格式的数据。REST框架会自动将JSON数据反序列化为User对象</p>
<p>最后，在spring配置文件中添加此服务，即完成所有服务开发工作：</p>
<pre><code class="language-xml"><span class="hljs-comment">&lt;!-- 用rest协议在8080端口暴露服务 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span>/&gt;</span>

<span class="hljs-comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"xxx.UserService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"userService"</span>/&gt;</span>

<span class="hljs-comment">&lt;!-- 和本地bean一样实现服务 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"xxx.UserServiceImpl"</span> /&gt;</span>
</code></pre>
<h2>标准Java REST API：JAX-RS简介</h2>
<p>JAX-RS是标准的Java REST API，得到了业界的广泛支持和应用，其著名的开源实现就有很多，包括Oracle的Jersey，RedHat的RestEasy，Apache的CXF和Wink，以及restlet等等。另外，所有支持JavaEE 6.0以上规范的商用JavaEE应用服务器都对JAX-RS提供了支持。因此，JAX-RS是一种已经非常成熟的解决方案，并且采用它没有任何所谓vendor lock-in的问题。</p>
<p>JAX-RS在网上的资料非常丰富，例如下面的入门教程：</p>
<ul>
<li>Oracle官方的tutorial：<a href="http://docs.oracle.com/javaee/7/tutorial/doc/jaxrs.htm">http://docs.oracle.com/javaee/7/tutorial/doc/jaxrs.htm</a></li>
<li>IBM developerWorks中国站文章：<a href="http://www.ibm.com/developerworks/cn/java/j-lo-jaxrs/">http://www.ibm.com/developerworks/cn/java/j-lo-jaxrs/</a></li>
</ul>
<p>更多的资料请自行google或者百度一下。就学习JAX-RS来说，一般主要掌握其各种annotation的用法即可。</p>
<blockquote>
<p>注意：dubbo是基于JAX-RS 2.0版本的，有时候需要注意一下资料或REST实现所涉及的版本。</p>
</blockquote>
<h2>REST服务提供端详解</h2>
<p>下面我们扩充“快速入门”中的UserService，进一步展示在dubbo中REST服务提供端的开发要点。</p>
<h3>HTTP POST/GET的实现</h3>
<p>REST服务中虽然建议使用HTTP协议中四种标准方法POST、DELETE、PUT、GET来分别实现常见的“增删改查”，但实际中，我们一般情况直接用POST来实现“增改”，GET来实现“删查”即可（DELETE和PUT甚至会被一些防火墙阻挡）。</p>
<p>前面已经简单演示了POST的实现，在此，我们为UserService添加一个获取注册用户资料的功能，来演示GET的实现。</p>
<p>这个功能就是要实现客户端通过访问如下不同URL来获取不同ID的用户资料：</p>
<pre><code>http://localhost:8080/users/1001
http://localhost:8080/users/1002
http://localhost:8080/users/1003
</code></pre>
<p>当然，也可以通过其他形式的URL来访问不同ID的用户资料，例如：</p>
<pre><code>http://localhost:8080/users/load?id=1001
</code></pre>
<p>JAX-RS本身可以支持所有这些形式。但是上面那种在URL路径中包含查询参数的形式（<a href="http://localhost:8080/users/1001%EF%BC%89">http://localhost:8080/users/1001）</a> 更符合REST的一般习惯，所以更推荐大家来使用。下面我们就为UserService添加一个getUser()方法来实现这种形式的URL访问：</p>
<pre><code class="language-java"><span class="hljs-meta">@GET</span>
<span class="hljs-meta">@Path</span>(<span class="hljs-string">"{id : \\d+}"</span>)
<span class="hljs-meta">@Produces</span>({MediaType.APPLICATION_JSON})
<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id) </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>@GET：指定用HTTP GET方法访问</p>
<p>@Path(&quot;{id : \d+}&quot;)：根据上面的功能需求，访问getUser()的URL应当是“<a href="http://localhost:8080/users/">http://localhost:8080/users/</a> + 任意数字&quot;，并且这个数字要被做为参数传入getUser()方法。 这里的annotation配置中，@Path中间的{id: xxx}指定URL相对路径中包含了名为id参数，而它的值也将被自动传递给下面用@PathParam(&quot;id&quot;)修饰的方法参数id。{id:后面紧跟的\d+是一个正则表达式，指定了id参数必须是数字。</p>
<p>@Produces({MediaType.APPLICATION_JSON})：指定getUser()输出JSON格式的数据。框架会自动将User对象序列化为JSON数据。</p>
<h3>Annotation放在接口类还是实现类</h3>
<p>在Dubbo中开发REST服务主要都是通过JAX-RS的annotation来完成配置的，在上面的示例中，我们都是将annotation放在服务的实现类中。但其实，我们完全也可以将annotation放到服务的接口上，这两种方式是完全等价的，例如：</p>
<pre><code class="language-java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>{
    
    <span class="hljs-meta">@GET</span>
    <span class="hljs-meta">@Path</span>(<span class="hljs-string">"{id : \\d+}"</span>)
    <span class="hljs-meta">@Produces</span>({MediaType.APPLICATION_JSON})
    <span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
}
</code></pre>
<p>在一般应用中，我们建议将annotation放到服务实现类，这样annotation和java实现代码位置更接近，更便于开发和维护。另外更重要的是，我们一般倾向于避免对接口的污染，保持接口的纯净性和广泛适用性。</p>
<p>但是，如后文所述，如果我们要用dubbo直接开发的消费端来访问此服务，则annotation必须放到接口上。</p>
<p>如果接口和实现类都同时添加了annotation，则实现类的annotation配置会生效，接口上的annotation被直接忽略。</p>
<h3>JSON、XML等多数据格式的支持</h3>
<p>在dubbo中开发的REST服务可以同时支持传输多种格式的数据，以给客户端提供最大的灵活性。其中我们目前对最常用的JSON和XML格式特别添加了额外的功能。</p>
<p>比如，我们要让上例中的getUser()方法支持分别返回JSON和XML格式的数据，只需要在annotation中同时包含两种格式即可：</p>
<pre><code class="language-java"><span class="hljs-meta">@Produces</span>({MediaType.APPLICATION_JSON, MediaType.TEXT_XML})
<span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
</code></pre>
<p>或者也可以直接用字符串（还支持通配符）表示MediaType：</p>
<pre><code class="language-java"><span class="hljs-meta">@Produces</span>({<span class="hljs-string">"application/json"</span>, <span class="hljs-string">"text/xml"</span>})
<span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
</code></pre>
<p>如果所有方法都支持同样类型的输入输出数据格式，则我们无需在每个方法上做配置，只需要在服务类上添加annotation即可：</p>
<pre><code class="language-java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-meta">@Consumes</span>({MediaType.APPLICATION_JSON, MediaType.TEXT_XML})
<span class="hljs-meta">@Produces</span>({MediaType.APPLICATION_JSON, MediaType.TEXT_XML})
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>{
    <span class="hljs-comment">// ...</span>
}

</code></pre>
<p>在一个REST服务同时对多种数据格式支持的情况下，根据JAX-RS标准，一般是通过HTTP中的MIME header（content-type和accept）来指定当前想用的是哪种格式的数据。</p>
<p>但是在dubbo中，我们还自动支持目前业界普遍使用的方式，即用一个URL后缀（.json和.xml）来指定想用的数据格式。例如，在添加上述annotation后，直接访问http://localhost:8888/users/1001.json则表示用json格式，直接访问http://localhost:8888/users/1002.xml则表示用xml格式，比用HTTP Header更简单直观。Twitter、微博等的REST API都是采用这种方式。</p>
<p>如果你既不加HTTP header，也不加后缀，则dubbo的REST会优先启用在以上annotation定义中排位最靠前的那种数据格式。</p>
<blockquote>
<p>注意：这里要支持XML格式数据，在annotation中既可以用MediaType.TEXT_XML，也可以用MediaType.APPLICATION_XML，但是TEXT_XML是更常用的，并且如果要利用上述的URL后缀方式来指定数据格式，只能配置为TEXT_XML才能生效。</p>
</blockquote>
<h3>中文字符支持</h3>
<p>为了在dubbo REST中正常输出中文字符，和通常的Java web应用一样，我们需要将HTTP响应的contentType设置为UTF-8编码。</p>
<p>基于JAX-RS的标准用法，我们只需要做如下annotation配置即可：</p>
<pre><code class="language-java"><span class="hljs-meta">@Produces</span>({<span class="hljs-string">"application/json; charset=UTF-8"</span>, <span class="hljs-string">"text/xml; charset=UTF-8"</span>})
<span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
</code></pre>
<p>为了方便用户，我们在dubbo REST中直接添加了一个支持类，来定义以上的常量，可以直接使用，减少出错的可能性。</p>
<pre><code class="language-java"><span class="hljs-meta">@Produces</span>({ContentType.APPLICATION_JSON_UTF_8, ContentType.TEXT_XML_UTF_8})
<span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
</code></pre>
<h3>XML数据格式的额外要求</h3>
<p>由于JAX-RS的实现一般都用标准的JAXB（Java API for XML Binding）来序列化和反序列化XML格式数据，所以我们需要为每一个要用XML传输的对象添加一个类级别的JAXB annotation，否则序列化将报错。例如为getUser()中返回的User添加如下：</p>
<pre><code class="language-java"><span class="hljs-meta">@XmlRootElement</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>此外，如果service方法中的返回值是Java的 primitive类型（如int，long，float，double等），最好为它们添加一层wrapper对象，因为JAXB不能直接序列化primitive类型。</p>
<p>例如，我们想让前述的registerUser()方法返回服务器端为用户生成的ID号：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">registerUser</span><span class="hljs-params">(User user)</span></span>;
</code></pre>
<p>由于primitive类型不被JAXB序列化支持，所以添加一个wrapper对象：</p>
<pre><code class="language-java"><span class="hljs-meta">@XmlRootElement</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegistrationResult</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{
    
    <span class="hljs-keyword">private</span> Long id;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RegistrationResult</span><span class="hljs-params">()</span> </span>{
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RegistrationResult</span><span class="hljs-params">(Long id)</span> </span>{
        <span class="hljs-keyword">this</span>.id = id;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> id;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Long id)</span> </span>{
        <span class="hljs-keyword">this</span>.id = id;
    }
}
</code></pre>
<p>并修改service方法：</p>
<pre><code class="language-java"><span class="hljs-function">RegistrationResult <span class="hljs-title">registerUser</span><span class="hljs-params">(User user)</span></span>;
</code></pre>
<p>这样不但能够解决XML序列化的问题，而且使得返回的数据都符合XML和JSON的规范。例如，在JSON中，返回的将是如下形式：</p>
<pre><code class="language-javascript">{<span class="hljs-string">"id"</span>: <span class="hljs-number">1001</span>}
</code></pre>
<p>如果不加wrapper，JSON返回值将直接是</p>
<pre><code>1001 	
</code></pre>
<p>而在XML中，加wrapper后返回值将是：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">registrationResult</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>1002<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">registrationResult</span>&gt;</span>
</code></pre>
<p>这种wrapper对象其实利用所谓Data Transfer Object（DTO）模式，采用DTO还能对传输数据做更多有用的定制。</p>
<h3>定制序列化</h3>
<p>如上所述，REST的底层实现会在service的对象和JSON/XML数据格式之间自动做序列化/反序列化。但有些场景下，如果觉得这种自动转换不满足要求，可以对其做定制。</p>
<p>Dubbo中的REST实现是用JAXB做XML序列化，用Jackson做JSON序列化，所以在对象上添加JAXB或Jackson的annotation即可以定制映射。</p>
<p>例如，定制对象属性映射到XML元素的名字：</p>
<pre><code class="language-java"><span class="hljs-meta">@XmlRootElement</span>
<span class="hljs-meta">@XmlAccessorType</span>(XmlAccessType.FIELD)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{
    
    <span class="hljs-meta">@XmlElement</span>(name=<span class="hljs-string">"username"</span>) 
    <span class="hljs-keyword">private</span> String name;  
}
</code></pre>
<p>定制对象属性映射到JSON字段的名字：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{
    
    <span class="hljs-meta">@JsonProperty</span>(<span class="hljs-string">"username"</span>)
    <span class="hljs-keyword">private</span> String name;
}
</code></pre>
<p>更多资料请参考JAXB和Jackson的官方文档，或自行google。</p>
<h3>配置REST Server的实现</h3>
<p>目前在dubbo中，我们支持5种嵌入式rest server的实现，并同时支持采用外部应用服务器来做rest server的实现。rest server的实现是通过如下server这个XML属性来选择的：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"jetty"</span>/&gt;</span>
</code></pre>
<p>以上配置选用了嵌入式的jetty来做rest server，同时，如果不配置server属性，rest协议默认也是选用jetty。jetty是非常成熟的java servlet容器，并和dubbo已经有较好的集成（目前5种嵌入式server中只有jetty和后面所述的tomcat、tjws，与dubbo监控系统等完成了无缝的集成），所以，如果你的dubbo系统是单独启动的进程，你可以直接默认采用jetty即可。</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"tomcat"</span>/&gt;</span>
</code></pre>
<p>以上配置选用了嵌入式的tomcat来做rest server。在嵌入式tomcat上，REST的性能比jetty上要好得多（参见后面的基准测试），建议在需要高性能的场景下采用tomcat。</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"netty"</span>/&gt;</span>
</code></pre>
<p>以上配置选用嵌入式的netty来做rest server。（TODO more contents to add）</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"tjws"</span>/&gt;</span> (tjws is now deprecated)
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"sunhttp"</span>/&gt;</span>
</code></pre>
<p>以上配置选用嵌入式的tjws或Sun HTTP server来做rest server。这两个server实现非常轻量级，非常方便在集成测试中快速启动使用，当然也可以在负荷不高的生产环境中使用。	注：tjws目前已经被deprecated掉了，因为它不能很好的和servlet 3.1 API工作。</p>
<p>如果你的dubbo系统不是单独启动的进程，而是部署到了Java应用服务器中，则建议你采用以下配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"servlet"</span>/&gt;</span>
</code></pre>
<p>通过将server设置为servlet，dubbo将采用外部应用服务器的servlet容器来做rest server。同时，还要在dubbo系统的web.xml中添加如下配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>/WEB-INF/classes/META-INF/spring/dubbo-demo-provider.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.apache.dubbo.remoting.http.servlet.BootstrapListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.apache.dubbo.remoting.http.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span>
</code></pre>
<p>即必须将dubbo的BootstrapListener和DispatherServlet添加到web.xml，以完成dubbo的REST功能与外部servlet容器的集成。</p>
<blockquote>
<p>注意：如果你是用spring的ContextLoaderListener来加载spring，则必须保证BootstrapListener配置在ContextLoaderListener之前，否则dubbo初始化会出错。</p>
</blockquote>
<p>其实，这种场景下你依然可以坚持用嵌入式server，但外部应用服务器的servlet容器往往比嵌入式server更加强大（特别是如果你是部署到更健壮更可伸缩的WebLogic，WebSphere等），另外有时也便于在应用服务器做统一管理、监控等等。</p>
<h3>获取上下文（Context）信息</h3>
<p>在远程调用中，值得获取的上下文信息可能有很多种，这里特别以获取客户端IP为例。</p>
<p>在dubbo的REST中，我们有两种方式获取客户端IP。</p>
<p>第一种方式，用JAX-RS标准的@Context annotation：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id, @Context HttpServletRequest request) </span>{
    System.out.println(<span class="hljs-string">"Client address is "</span> + request.getRemoteAddr());
} 
</code></pre>
<p>用Context修饰getUser()的一个方法参数后，就可以将当前的HttpServletRequest注入进来，然后直接调用servlet api获取IP。</p>
<blockquote>
<p>注意：这种方式只能在设置server=&quot;tjws&quot;或者server=&quot;tomcat&quot;或者server=&quot;jetty&quot;或者server=&quot;servlet&quot;的时候才能工作，因为只有这几种REST server的实现才提供了servlet容器。另外，标准的JAX-RS还支持用@Context修饰service类的一个实例字段来获取HttpServletRequest，但在dubbo中我们没有对此作出支持。</p>
</blockquote>
<p>第二种方式，用dubbo中常用的RpcContext：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id) </span>{
    System.out.println(<span class="hljs-string">"Client address is "</span> + RpcContext.getContext().getRemoteAddressString());
} 
</code></pre>
<blockquote>
<p>注意：这种方式只能在设置server=&quot;jetty&quot;或者server=&quot;tomcat&quot;或者server=&quot;servlet&quot;或者server=&quot;tjws&quot;的时候才能工作。另外，目前dubbo的RpcContext是一种比较有侵入性的用法，未来我们很可能会做出重构。</p>
</blockquote>
<p>如果你想保持你的项目对JAX-RS的兼容性，未来脱离dubbo也可以运行，请选择第一种方式。如果你想要更优雅的服务接口定义，请选用第二种方式。</p>
<p>此外，在最新的dubbo rest中，还支持通过RpcContext来获取HttpServletRequest和HttpServletResponse，以提供更大的灵活性来方便用户实现某些复杂功能，比如在dubbo标准的filter中访问HTTP Header。用法示例如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">if</span> (RpcContext.getContext().getRequest() != <span class="hljs-keyword">null</span> &amp;&amp; RpcContext.getContext().getRequest() <span class="hljs-keyword">instanceof</span> HttpServletRequest) {
    System.out.println(<span class="hljs-string">"Client address is "</span> + ((HttpServletRequest) RpcContext.getContext().getRequest()).getRemoteAddr());
}

<span class="hljs-keyword">if</span> (RpcContext.getContext().getResponse() != <span class="hljs-keyword">null</span> &amp;&amp; RpcContext.getContext().getResponse() <span class="hljs-keyword">instanceof</span> HttpServletResponse) {
    System.out.println(<span class="hljs-string">"Response object from RpcContext: "</span> + RpcContext.getContext().getResponse());
}
</code></pre>
<blockquote>
<p>注意：为了保持协议的中立性，RpcContext.getRequest()和RpcContext.getResponse()返回的仅仅是一个Object类，而且可能为null。所以，你必须自己做null和类型的检查。</p>
</blockquote>
<blockquote>
<p>注意：只有在设置server=&quot;jetty&quot;或者server=&quot;tomcat&quot;或者server=&quot;servlet&quot;的时候，你才能通过以上方法正确的得到HttpServletRequest和HttpServletResponse，因为只有这几种server实现了servlet容器。</p>
</blockquote>
<p>为了简化编程，在此你也可以用泛型的方式来直接获取特定类型的request/response：</p>
<pre><code class="language-java"><span class="hljs-keyword">if</span> (RpcContext.getContext().getRequest(HttpServletRequest.class) != <span class="hljs-keyword">null</span>) {
    System.out.println(<span class="hljs-string">"Client address is "</span> + RpcContext.getContext().getRequest(HttpServletRequest.class).getRemoteAddr());
}

<span class="hljs-keyword">if</span> (RpcContext.getContext().getResponse(HttpServletResponse.class) != <span class="hljs-keyword">null</span>) {
    System.out.println(<span class="hljs-string">"Response object from RpcContext: "</span> + RpcContext.getContext().getResponse(HttpServletResponse.class));
}
</code></pre>
<p>如果request/response不符合指定的类型，这里也会返回null。</p>
<h3>配置端口号和Context Path</h3>
<p>dubbo中的rest协议默认将采用80端口，如果想修改端口，直接配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span>/&gt;</span>
</code></pre>
<p>另外，如前所述，我们可以用@Path来配置单个rest服务的URL相对路径。但其实，我们还可以设置一个所有rest服务都适用的基础相对路径，即java web应用中常说的context path。</p>
<p>只需要添加如下contextpath属性即可：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">contextpath</span>=<span class="hljs-string">"services"</span>/&gt;</span>
</code></pre>
<p>以前面代码为例：</p>
<pre><code class="language-java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>{
       
    <span class="hljs-meta">@POST</span>
    <span class="hljs-meta">@Path</span>(<span class="hljs-string">"register"</span>)
    <span class="hljs-meta">@Consumes</span>({MediaType.APPLICATION_JSON})
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerUser</span><span class="hljs-params">(User user)</span> </span>{
        <span class="hljs-comment">// save the user...</span>
    }	
}
</code></pre>
<p>现在registerUser()的完整访问路径为：</p>
<pre><code>http://localhost:8888/services/users/register
</code></pre>
<p>注意：如果你是选用外部应用服务器做rest server，即配置:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">contextpath</span>=<span class="hljs-string">"services"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"servlet"</span>/&gt;</span>
</code></pre>
<p>则必须保证这里设置的port、contextpath，与外部应用服务器的端口、DispatcherServlet的上下文路径（即webapp path加上servlet url pattern）保持一致。例如，对于部署为tomcat ROOT路径的应用，这里的contextpath必须与web.xml中DispacherServlet的<code>&lt;url-pattern/&gt;</code>完全一致：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/services/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>
</code></pre>
<h3>配置线程数和IO线程数</h3>
<p>可以为rest服务配置线程池大小：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">threads</span>=<span class="hljs-string">"500"</span>/&gt;</span>
</code></pre>
<blockquote>
<p>注意：目前线程池的设置只有当server=&quot;netty&quot;或者server=&quot;jetty&quot;或者server=&quot;tomcat&quot;的时候才能生效。另外，如果server=&quot;servlet&quot;，由于这时候启用的是外部应用服务器做rest server，不受dubbo控制，所以这里的线程池设置也无效。</p>
</blockquote>
<p>如果是选用netty server，还可以配置Netty的IO worker线程数：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">iothreads</span>=<span class="hljs-string">"5"</span> <span class="hljs-attr">threads</span>=<span class="hljs-string">"100"</span>/&gt;</span>
</code></pre>
<h3>配置长连接</h3>
<p>Dubbo中的rest服务默认都是采用http长连接来访问，如果想切换为短连接，直接配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">keepalive</span>=<span class="hljs-string">"false"</span>/&gt;</span>
</code></pre>
<blockquote>
<p>注意：这个配置目前只对server=&quot;netty&quot;和server=&quot;tomcat&quot;才能生效。</p>
</blockquote>
<h3>配置最大的HTTP连接数</h3>
<p>可以配置服务器提供端所能同时接收的最大HTTP连接数，防止REST server被过多连接撑爆，以作为一种最基本的自我保护机制：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">accepts</span>=<span class="hljs-string">"500"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"tomcat/&gt;
</span></span></code></pre>
<blockquote>
<p>注意：这个配置目前只对server=&quot;tomcat&quot;才能生效。</p>
</blockquote>
<h3>配置每个消费端的超时时间和HTTP连接数</h3>
<p>如果rest服务的消费端也是dubbo系统，可以像其他dubbo RPC机制一样，配置消费端调用此rest服务的最大超时时间以及每个消费端所能启动的最大HTTP连接数。</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"2000"</span> <span class="hljs-attr">connections</span>=<span class="hljs-string">"10"</span>/&gt;</span>
</code></pre>
<p>当然，由于这个配置针对消费端生效的，所以也可以在消费端配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"2000"</span> <span class="hljs-attr">connections</span>=<span class="hljs-string">"10"</span>/&gt;</span>
</code></pre>
<p>但是，通常我们建议配置在服务提供端提供此类配置。按照dubbo官方文档的说法：“Provider上尽量多配置Consumer端的属性，让Provider实现者一开始就思考Provider服务特点、服务质量的问题。”</p>
<blockquote>
<p>注意：如果dubbo的REST服务是发布给非dubbo的客户端使用，则这里<code>&lt;dubbo:service/&gt;</code>上的配置完全无效，因为这种客户端不受dubbo控制。</p>
</blockquote>
<h3>GZIP数据压缩</h3>
<p>Dubbo的REST支持用GZIP压缩请求和响应的数据，以减少网络传输时间和带宽占用，但这种方式会也增加CPU开销。</p>
<p>TODO more contents to add</p>
<h3>用Annotation取代部分Spring XML配置</h3>
<p>以上所有的讨论都是基于dubbo在spring中的xml配置。但是，dubbo/spring本身也支持用annotation来作配置，所以我们也可以按dubbo官方文档中的步骤，把相关annotation加到REST服务的实现中，取代一些xml配置，例如：</p>
<pre><code class="language-java"><span class="hljs-meta">@Service</span>(protocol = <span class="hljs-string">"rest"</span>)
<span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserRepository userRepository;
       
    <span class="hljs-meta">@POST</span>
    <span class="hljs-meta">@Path</span>(<span class="hljs-string">"register"</span>)
    <span class="hljs-meta">@Consumes</span>({MediaType.APPLICATION_JSON})
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerUser</span><span class="hljs-params">(User user)</span> </span>{
        <span class="hljs-comment">// save the user</span>
        userRepository.save(user);
    }	
}
</code></pre>
<p>annotation的配置更简单更精确，经常也更便于维护（当然现代IDE都可以在xml中支持比如类名重构，所以就这里的特定用例而言，xml的维护性也很好）。而xml对代码的侵入性更小一些，尤其有利于动态修改配置，特别是比如你要针对单个服务配置连接超时时间、每客户端最大连接数、集群策略、权重等等。另外，特别对复杂应用或者模块来说，xml提供了一个中心点来涵盖的所有组件和配置，更一目了然，一般更便于项目长时期的维护。</p>
<p>当然，选择哪种配置方式没有绝对的优劣，和个人的偏好也不无关系。</p>
<h3>添加自定义的Filter、Interceptor等</h3>
<p>Dubbo的REST也支持JAX-RS标准的Filter和Interceptor，以方便对REST的请求与响应过程做定制化的拦截处理。</p>
<p>其中，Filter主要用于访问和设置HTTP请求和响应的参数、URI等等。例如，设置HTTP响应的cache header：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheControlFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ContainerResponseFilter</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filter</span><span class="hljs-params">(ContainerRequestContext req, ContainerResponseContext res)</span> </span>{
        <span class="hljs-keyword">if</span> (req.getMethod().equals(<span class="hljs-string">"GET"</span>)) {
            res.getHeaders().add(<span class="hljs-string">"Cache-Control"</span>, <span class="hljs-string">"someValue"</span>);
        }
    }
}
</code></pre>
<p>Interceptor主要用于访问和修改输入与输出字节流，例如，手动添加GZIP压缩：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GZIPWriterInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WriterInterceptor</span> </span>{
 
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">aroundWriteTo</span><span class="hljs-params">(WriterInterceptorContext context)</span>
                    <span class="hljs-keyword">throws</span> IOException, WebApplicationException </span>{
        OutputStream outputStream = context.getOutputStream();
        context.setOutputStream(<span class="hljs-keyword">new</span> GZIPOutputStream(outputStream));
        context.proceed();
    }
}
</code></pre>
<p>在标准JAX-RS应用中，我们一般是为Filter和Interceptor添加@Provider annotation，然后JAX-RS runtime会自动发现并启用它们。而在dubbo中，我们是通过添加XML配置的方式来注册Filter和Interceptor：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">extension</span>=<span class="hljs-string">"xxx.TraceInterceptor, xxx.TraceFilter"</span>/&gt;</span>
</code></pre>
<p>在此，我们可以将Filter、Interceptor和DynamicFeature这三种类型的对象都添加到<code>extension</code>属性上，多个之间用逗号分隔。（DynamicFeature是另一个接口，可以方便我们更动态的启用Filter和Interceptor，感兴趣请自行google。）</p>
<p>当然，dubbo自身也支持Filter的概念，但我们这里讨论的Filter和Interceptor更加接近协议实现的底层，相比dubbo的filter，可以做更底层的定制化。</p>
<blockquote>
<p>注：这里的XML属性叫extension，而不是叫interceptor或者filter，是因为除了Interceptor和Filter，未来我们还会添加更多的扩展类型。</p>
</blockquote>
<p>如果REST的消费端也是dubbo系统（参见下文的讨论），则也可以用类似方式为消费端配置Interceptor和Filter。但注意，JAX-RS中消费端的Filter和提供端的Filter是两种不同的接口。例如前面例子中服务端是ContainerResponseFilter接口，而消费端对应的是ClientResponseFilter:</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoggingFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ClientResponseFilter</span> </span>{
 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filter</span><span class="hljs-params">(ClientRequestContext reqCtx, ClientResponseContext resCtx)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        System.out.println(<span class="hljs-string">"status: "</span> + resCtx.getStatus());
	    System.out.println(<span class="hljs-string">"date: "</span> + resCtx.getDate());
	    System.out.println(<span class="hljs-string">"last-modified: "</span> + resCtx.getLastModified());
	    System.out.println(<span class="hljs-string">"location: "</span> + resCtx.getLocation());
	    System.out.println(<span class="hljs-string">"headers:"</span>);
	    <span class="hljs-keyword">for</span> (Entry&lt;String, List&lt;String&gt;&gt; header : resCtx.getHeaders().entrySet()) {
     	    System.out.print(<span class="hljs-string">"\t"</span> + header.getKey() + <span class="hljs-string">" :"</span>);
	        <span class="hljs-keyword">for</span> (String value : header.getValue()) {
	            System.out.print(value + <span class="hljs-string">", "</span>);
	        }
	        System.out.print(<span class="hljs-string">"\n"</span>);
	    }
	    System.out.println(<span class="hljs-string">"media-type: "</span> + resCtx.getMediaType().getType());
    } 
}
</code></pre>
<h3>添加自定义的Exception处理</h3>
<p>Dubbo的REST也支持JAX-RS标准的ExceptionMapper，可以用来定制特定exception发生后应该返回的HTTP响应。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomExceptionMapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExceptionMapper</span>&lt;<span class="hljs-title">NotFoundException</span>&gt; </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">toResponse</span><span class="hljs-params">(NotFoundException e)</span> </span>{     
        <span class="hljs-keyword">return</span> Response.status(Response.Status.NOT_FOUND).entity(<span class="hljs-string">"Oops! the requested resource is not found!"</span>).type(<span class="hljs-string">"text/plain"</span>).build();
    }
}
</code></pre>
<p>和Interceptor、Filter类似，将其添加到XML配置文件中即可启用：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">extension</span>=<span class="hljs-string">"xxx.CustomExceptionMapper"</span>/&gt;</span>
</code></pre>
<h3>配置HTTP日志输出</h3>
<p>Dubbo rest支持输出所有HTTP请求/响应中的header字段和body消息体。</p>
<p>在XML配置中添加如下自带的REST filter：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">extension</span>=<span class="hljs-string">"org.apache.dubbo.rpc.protocol.rest.support.LoggingFilter"</span>/&gt;</span>
</code></pre>
<p><strong>然后在logging配置中至少为org.apache.dubbo.rpc.protocol.rest.support打开INFO级别日志输出</strong>，例如，在log4j.xml中配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"org.apache.dubbo.rpc.protocol.rest.support"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"INFO"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"CONSOLE"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span>
</code></pre>
<p>当然，你也可以直接在ROOT logger打开INFO级别日志输出：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"INFO"</span> /&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"CONSOLE"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
</code></pre>
<p>然后在日志中会有类似如下的内容输出：</p>
<pre><code>The HTTP headers are: 
accept: application/json;charset=UTF-8
accept-encoding: gzip, deflate
connection: Keep-Alive
content-length: 22
content-type: application/json
host: 192.168.1.100:8888
user-agent: Apache-HttpClient/4.2.1 (java 1.5)
</code></pre>
<pre><code>The contents of request body is: 
{&quot;id&quot;:1,&quot;name&quot;:&quot;dang&quot;}
</code></pre>
<p>打开HTTP日志输出后，除了正常日志输出的性能开销外，也会在比如HTTP请求解析时产生额外的开销，因为需要建立额外的内存缓冲区来为日志的输出做数据准备。</p>
<h3>输入参数的校验</h3>
<p>dubbo的rest支持采用Java标准的bean validation annotation（JSR 303)来做输入校验http://beanvalidation.org/</p>
<p>为了和其他dubbo远程调用协议保持一致，在rest中作校验的annotation必须放在服务的接口上，例如：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>{
   
    <span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@Min(value=<span class="hljs-number">1</span>L, message=<span class="hljs-string">"User ID must be greater than 1"</span>)</span> Long id)</span>;
}

</code></pre>
<p>当然，在很多其他的bean validation的应用场景都是将annotation放到实现类而不是接口上。把annotation放在接口上至少有一个好处是，dubbo的客户端可以共享这个接口的信息，dubbo甚至不需要做远程调用，在本地就可以完成输入校验。</p>
<p>然后按照dubbo的标准方式在XML配置中打开验证：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">xxx.UserService</span>" <span class="hljs-attr">ref</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">validation</span>=<span class="hljs-string">"true"</span>/&gt;</span>
</code></pre>
<p>在dubbo的其他很多远程调用协议中，如果输入验证出错，是直接将<code>RpcException</code>抛向客户端，而在rest中由于客户端经常是非dubbo，甚至非java的系统，所以不便直接抛出Java异常。因此，目前我们将校验错误以XML的格式返回：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">violationReport</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">constraintViolations</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>getUserArgument0<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span>User ID must be greater than 1<span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">constraintViolations</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">violationReport</span>&gt;</span>
</code></pre>
<p>稍后也会支持其他数据格式的返回值。至于如何对验证错误消息作国际化处理，直接参考bean validation的相关文档即可。</p>
<p>如果你认为默认的校验错误返回格式不符合你的要求，可以如上面章节所述，添加自定义的ExceptionMapper来自由的定制错误返回格式。需要注意的是，这个ExceptionMapper必须用泛型声明来捕获dubbo的RpcException，才能成功覆盖dubbo rest默认的异常处理策略。为了简化操作，其实这里最简单的方式是直接继承dubbo rest的RpcExceptionMapper，并覆盖其中处理校验异常的方法即可：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyValidationExceptionMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RpcExceptionMapper</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">protected</span> Response <span class="hljs-title">handleConstraintViolationException</span><span class="hljs-params">(ConstraintViolationException cve)</span> </span>{
        ViolationReport report = <span class="hljs-keyword">new</span> ViolationReport();
        <span class="hljs-keyword">for</span> (ConstraintViolation cv : cve.getConstraintViolations()) {
            report.addConstraintViolation(<span class="hljs-keyword">new</span> RestConstraintViolation(
                    cv.getPropertyPath().toString(),
                    cv.getMessage(),
                    cv.getInvalidValue() == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"null"</span> : cv.getInvalidValue().toString()));
        }
        <span class="hljs-comment">// 采用json输出代替xml输出</span>
        <span class="hljs-keyword">return</span> Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(report).type(ContentType.APPLICATION_JSON_UTF_8).build();
    }
}
</code></pre>
<p>然后将这个ExceptionMapper添加到XML配置中即可：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">extension</span>=<span class="hljs-string">"xxx.MyValidationExceptionMapper"</span>/&gt;</span>
</code></pre>
<h3>是否应该透明发布REST服务</h3>
<p>Dubbo的REST调用和dubbo中其它某些RPC不同的是，需要在服务代码中添加JAX-RS的annotation（以及JAXB、Jackson的annotation），如果你觉得这些annotation一定程度“污染”了你的服务代码，你可以考虑编写额外的Facade和DTO类，在Facade和DTO上添加annotation，而Facade将调用转发给真正的服务实现类。当然事实上，直接在服务代码中添加annotation基本没有任何负面作用，而且这本身是Java EE的标准用法，另外JAX-RS和JAXB的annotation是属于java标准，比我们经常使用的spring、dubbo等等annotation更没有vendor lock-in的问题，所以一般没有必要因此而引入额外对象。</p>
<p>另外，如果你想用前述的@Context annotation，通过方法参数注入HttpServletRequest（如<code>public User getUser(@PathParam(&quot;id&quot;) Long id, @Context HttpServletRequest request)</code>），这时候由于改变了服务的方法签名，并且HttpServletRequest是REST特有的参数，<strong>所以如果你的服务要支持多种RPC机制的话</strong>，则引入额外的Facade类是比较适当的。</p>
<p>当然，在没有添加REST调用之前，你的服务代码可能本身已经就充当了Facade和DTO的角色（至于为什么有些场景需要这些角色，有兴趣可参考<a href="http://www.infoq.com/cn/articles/micro-soa-1">微观SOA：服务设计原则及其实践方式</a>）。这种情况下，在添加REST之后，如果你再额外添加与REST相关的Facade和DTO，就相当于对原有代码对再一次包装，即形成如下调用链：</p>
<p><code>RestFacade/RestDTO -&gt; Facade/DTO -&gt; Service</code></p>
<p>这种体系比较繁琐，数据转换之类的工作量也不小，所以一般应尽量避免如此。</p>
<h2>REST服务消费端详解</h2>
<p>这里我们用三种场景来分别讨论：</p>
<ol>
<li>非dubbo的消费端调用dubbo的REST服务（non-dubbo --&gt; dubbo）</li>
<li>dubbo消费端调用dubbo的REST服务 （dubbo --&gt; dubbo）</li>
<li>dubbo的消费端调用非dubbo的REST服务 （dubbo --&gt; non-dubbo）</li>
</ol>
<h3>场景1：非dubbo的消费端调用dubbo的REST服务</h3>
<p>这种场景的客户端与dubbo本身无关，直接选用相应语言和框架中合适的方式即可。</p>
<p>如果是还是java的客户端（但没用dubbo），可以考虑直接使用标准的JAX-RS Client API或者特定REST实现的Client API来调用REST服务。下面是用JAX-RS Client API来访问上述的UserService的registerUser()：</p>
<pre><code class="language-java">User user = <span class="hljs-keyword">new</span> User();
user.setName(<span class="hljs-string">"Larry"</span>);

Client client = ClientBuilder.newClient();
WebTarget target = client.target(<span class="hljs-string">"http://localhost:8080/services/users/register.json"</span>);
Response response = target.request().post(Entity.entity(user, MediaType.APPLICATION_JSON_TYPE));

<span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">if</span> (response.getStatus() != <span class="hljs-number">200</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Failed with HTTP error code : "</span> + response.getStatus());
    }
    System.out.println(<span class="hljs-string">"The generated id is "</span> + response.readEntity(RegistrationResult.class).getId());
} <span class="hljs-keyword">finally</span> {
    response.close();
    client.close(); <span class="hljs-comment">// 在真正开发中不要每次关闭client，比如HTTP长连接是由client持有的</span>
}
</code></pre>
<p>上面代码片段中的User和RegistrationResult类都是消费端自己编写的，JAX-RS Client API会自动对它们做序列化/反序列化。</p>
<p>当然，在java中也可以直接用自己熟悉的比如HttpClient，FastJson，XStream等等各种不同技术来实现REST客户端，在此不再详述。</p>
<h3>场景2：dubbo消费端调用dubbo的REST服务</h3>
<p>这种场景下，和使用其他dubbo的远程调用方式一样，直接在服务提供端和服务消费端共享Java服务接口，并添加spring xml配置（当然也可以用spring/dubbo的annotation配置），即可透明的调用远程REST服务：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"xxx.UserService"</span>/&gt;</span>
</code></pre>
<p>如前所述，这种场景下必须把JAX-RS的annotation添加到服务接口上，这样在dubbo在消费端才能共享相应的REST配置信息，并据之做远程调用:</p>
<pre><code class="language-java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>{
    
    <span class="hljs-meta">@GET</span>
    <span class="hljs-meta">@Path</span>(<span class="hljs-string">"{id : \\d+}"</span>)
    <span class="hljs-meta">@Produces</span>({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    <span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
}
</code></pre>
<p>如果服务接口的annotation中配置了多种数据格式，这里由于两端都是dubbo系统，REST的大量细节被屏蔽了，所以不存在用前述URL后缀之类选择数据格式的可能。目前在这种情况下，排名最靠前的数据格式将直接被使用。</p>
<p>因此，我们建议你在定义annotation的时候最好把最合适的数据格式放到前面，比如以上我们是把json放在xml前面，因为json的传输性能优于xml。</p>
<h3>场景3：dubbo的消费端调用非dubbo的REST服务</h3>
<p>这种场景下，可以直接用场景1中描述的Java的方式来调用REST服务。但其实也可以采用场景2中描述的方式，即更透明的调用REST服务，即使这个服务并不是dubbo提供的。</p>
<p>如果用场景2的方式，由于这里REST服务并非dubbo提供，一般也就没有前述的共享的Java服务接口，所以在此我们需要根据外部REST服务的情况，自己来编写Java接口以及相应参数类，并添加JAX-RS、JAXB、Jackson等的annotation，dubbo的REST底层实现会据此去自动生成请求消息，自动解析响应消息等等，从而透明的做远程调用。或者这种方式也可以理解为，我们尝试用JAX-RS的方式去仿造实现一遍外部的REST服务提供端，然后把写成服务接口放到客户端来直接使用，dubbo的REST底层实现就能像调用dubbo的REST服务一样调用其他REST服务。</p>
<p>例如，我们要调用如下的外部服务</p>
<pre><code>http://api.foo.com/services/users/1001
http://api.foo.com/services/users/1002
</code></pre>
<p>获取不同ID的用户资料，返回格式是JSON</p>
<pre><code class="language-javascript">{
    <span class="hljs-string">"id"</span>: <span class="hljs-number">1001</span>,
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"Larry"</span>
}
</code></pre>
<p>我们可根据这些信息，编写服务接口和参数类即可：</p>
<pre><code class="language-java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>{
    
    <span class="hljs-meta">@GET</span>
    <span class="hljs-meta">@Path</span>(<span class="hljs-string">"{id : \\d+}"</span>)
    <span class="hljs-meta">@Produces</span>({MediaType.APPLICATION_JSON})
    <span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(@PathParam(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
}
</code></pre>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{

    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-comment">// …</span>
}
</code></pre>
<p>对于spring中的配置，因为这里的REST服务不是dubbo提供的，所以无法使用dubbo的注册中心，直接配置外部REST服务的url地址即可（如多个地址用逗号分隔）：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"xxx.UserService"</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"rest://api.foo.com/services/"</span>/&gt;</span>
</code></pre>
<blockquote>
<p>注意：这里协议必须用rest://而不是http://之类。如果外部的REST服务有context path，则在url中也必须添加上（除非你在每个服务接口的@Path annotation中都带上context path），例如上面的/services/。同时这里的services后面必须带上/，这样才能使dubbo正常工作。</p>
</blockquote>
<p>另外，这里依然可以配置客户端可启动的最大连接数和超时时间：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"xxx.UserService"</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"rest://api.foo.com/services/"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"2000"</span> <span class="hljs-attr">connections</span>=<span class="hljs-string">"10"</span>/&gt;</span>
</code></pre>
<h2>Dubbo中JAX-RS的限制</h2>
<p>Dubbo中的REST开发是完全兼容标准JAX-RS的，但其支持的功能目前是完整JAX-RS的一个子集，部分因为它要受限于dubbo和spring的特定体系。</p>
<p>在dubbo中使用的JAX-RS的局限包括但不限于：</p>
<ol>
<li>服务实现只能是singleton的，不能支持per-request scope和per-lookup scope</li>
<li>不支持用@Context annotation对服务的实例字段注入 ServletConfig、ServletContext、HttpServletRequest、HttpServletResponse等等，但可以支持对服务方法参数的注入。但对某些特定REST server实现，（祥见前面的叙述），也不支持对服务方法参数的注入。</li>
</ol>
<h2>REST常见问题解答（REST FAQ）</h2>
<h3>Dubbo REST的服务能和Dubbo注册中心、监控中心集成吗？</h3>
<p>可以的，而且是自动集成的，也就是你在dubbo中开发的所有REST服务都会自动注册到注册中心和监控中心，可以通过它们做管理。</p>
<p>但是，只有当REST的消费端也是基于dubbo的时候，注册中心中的许多服务治理操作才能完全起作用。而如果消费端是非dubbo的，自然不受注册中心管理，所以其中很多操作是不会对消费端起作用的。</p>
<h3>Dubbo REST中如何实现负载均衡和容错（failover）？</h3>
<p>如果dubbo REST的消费端也是dubbo的，则Dubbo REST和其他dubbo远程调用协议基本完全一样，由dubbo框架透明的在消费端做load balance、failover等等。</p>
<p>如果dubbo REST的消费端是非dubbo的，甚至是非java的，则最好配置服务提供端的软负载均衡机制，目前可考虑用LVS、HAProxy、 Nginx等等对HTTP请求做负载均衡。</p>
<h3>JAX-RS中重载的方法能够映射到同一URL地址吗？</h3>
<p><a href="http://stackoverflow.com/questions/17196766/can-resteasy-choose-method-based-on-query-params">http://stackoverflow.com/questions/17196766/can-resteasy-choose-method-based-on-query-params</a></p>
<h3>JAX-RS中作POST的方法能够接收多个参数吗？</h3>
<p><a href="http://stackoverflow.com/questions/5553218/jax-rs-post-multiple-objects">http://stackoverflow.com/questions/5553218/jax-rs-post-multiple-objects</a></p>
<h2>Dubbo当前体系的不足之处（与REST相关的）</h2>
<p>我认为dubbo当前体系中显然也有不少不足之处，这里列出几个与REST有关的、并影响用户使用的问题（不包括内部实现的问题），供参考评论，为下一步重构作准备。</p>
<h3>RpcContext的侵入性</h3>
<p>在前文，前面我们已经提到过RpcContext用法的侵入性，由于它是用单例的方式来访问上下文信息，这完全不符合spring应用的一般风格，不利于应用扩展和单元测试。未来我们可能用依赖注入方式注入一个接口，再用它去访问ThreadLocal中的上下文信息。</p>
<h3>Protocol配置的局限性</h3>
<p>dubbo支持多种远程调用方式，但所有调用方式都是用<code>&lt;dubbo:protocol/&gt;</code>来配置的，例如：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dubbo"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"9090"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"netty"</span> <span class="hljs-attr">client</span>=<span class="hljs-string">"netty"</span> <span class="hljs-attr">codec</span>=<span class="hljs-string">"dubbo"</span> <span class="hljs-attr">serialization</span>=<span class="hljs-string">"hessian2"</span> 
    <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> <span class="hljs-attr">threadpool</span>=<span class="hljs-string">"fixed"</span> <span class="hljs-attr">threads</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">queues</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">iothreads</span>=<span class="hljs-string">"9"</span> <span class="hljs-attr">buffer</span>=<span class="hljs-string">"8192"</span> <span class="hljs-attr">accepts</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attr">payload</span>=<span class="hljs-string">"8388608"</span>/&gt;</span>
</code></pre>
<p>其实，上面很多属性实际上dubbo RPC远程调用方式特有的，很多dubbo中的其它远程调用方式根本就不支持例如server, client, codec, iothreads, accepts, payload等等（当然，有的是条件所限不支持，有的是根本没有必要支持）。这给用户的使用徒增很多困惑，用户也并不知道有些属性（比如做性能调优）添加了实际上是不起作用的。</p>
<p>另一方面，各种远程调用方式往往有大量自己独特的配置需要，特别是我们逐步为每种远程调用方式都添加更丰富、更高级的功能，这就不可避免的扩展<code>&lt;protocol/&gt;</code>中的属性（例如目前我们在REST中已经添加了keepalive和extension两个属性），到最后会导致<code>&lt;protocol/&gt;</code>臃肿不堪，用户的使用也更加困惑。</p>
<p>当然，dubbo中有一种扩展<code>&lt;protocol/&gt;</code>的方式是用<code>&lt;dubbo:parameter/&gt;</code>，但这种方式显然很有局限性，而且用法复杂，缺乏schema校验。</p>
<p>所以，最好的方式是为每种远程调用方式设置自己的protocol元素，比如<code>&lt;protocol-dubbo/&gt;</code>，<code>&lt;protocol-rest/&gt;</code>等等，每种元素用XML schema规定自己的属性（当然属性在各种远程调用方式之间能通用是最好的）。</p>
<p>如此一来，例如前面提到过的extension配置也可以用更自由的方式，从而更清楚更可扩展（以下只是举例，当然也许有更好的方式）:</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol-rest</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:extension</span>&gt;</span>someInterceptor<span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:extension</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:extension</span>&gt;</span>someFilter<span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:extension</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:extension</span>&gt;</span>someDynamicFeature<span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:extension</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:extension</span>&gt;</span>someEntityProvider<span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:extension</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:protocol-rest</span>&gt;</span>
</code></pre>
<h3>XML命名不符合spring规范</h3>
<p>dubbo的XML配置中大量命名都不符合spring规范，比如：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dubbo"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"9090"</span> <span class="hljs-attr">server</span>=<span class="hljs-string">"netty"</span> <span class="hljs-attr">client</span>=<span class="hljs-string">"netty"</span> <span class="hljs-attr">codec</span>=<span class="hljs-string">"dubbo"</span> <span class="hljs-attr">serialization</span>=<span class="hljs-string">"hessian2"</span> 
    <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> <span class="hljs-attr">threadpool</span>=<span class="hljs-string">"fixed"</span> <span class="hljs-attr">threads</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">queues</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">iothreads</span>=<span class="hljs-string">"9"</span> <span class="hljs-attr">buffer</span>=<span class="hljs-string">"8192"</span> <span class="hljs-attr">accepts</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attr">payload</span>=<span class="hljs-string">"8388608"</span>/&gt;</span>
</code></pre>
<p>上面threadpool应该改为thread-pool，iothreads应该改为io-threads，单词之间应该用&quot;-&quot;分隔。这虽然看起来是个小问题，但也涉及到了可读性，特别是可扩展性，因为有时候我们不可避免要用更多单词来描述XML元素和属性。</p>
<p>其实dubbo本身也是建议遵守spring到XML的命名规范。</p>
<h2>REST最佳实践</h2>
<p>TODO</p>
<h2>性能基准测试</h2>
<h3>测试环境</h3>
<p>粗略如下：</p>
<ul>
<li>两台独立服务器</li>
<li>4核Intel(R) Xeon(R) CPU E5-2603 0 @ 1.80GHz</li>
<li>8G内存</li>
<li>服务器之间网络通过百兆交换机</li>
<li>CentOS 5</li>
<li>JDK 7</li>
<li>Tomcat 7</li>
<li>JVM参数-server -Xms1g -Xmx1g -XX:PermSize=64M -XX:+UseConcMarkSweepGC</li>
</ul>
<h3>测试脚本</h3>
<p>和dubbo自身的基准测试保持接近：</p>
<p>10个并发客户端持续不断发出请求：</p>
<ul>
<li>传入嵌套复杂对象（但单个数据量很小），不做任何处理，原样返回</li>
<li>传入50K字符串，不做任何处理，原样返回（TODO：结果尚未列出）</li>
</ul>
<p>进行5分钟性能测试。（引用dubbo自身测试的考虑：“主要考察序列化和网络IO的性能，因此服务端无任何业务逻辑。取10并发是考虑到http协议在高并发下对CPU的使用率较高可能会先打到瓶颈。”）</p>
<h3>测试结果</h3>
<p>下面的结果主要对比的是REST和dubbo RPC两种远程调用方式，并对它们作不同的配置，例如：</p>
<ul>
<li>“REST: Jetty + XML + GZIP”的意思是：测试REST，并采用jetty server，XML数据格式，启用GZIP压缩。</li>
<li>“Dubbo: hessian2”的意思是：测试dubbo RPC，并采用hessian2序列化方式。</li>
</ul>
<p>针对复杂对象的结果如下（响应时间越小越好，TPS越大越好）：</p>
<table>
<thead>
<tr>
<th>远程调用方式</th>
<th>平均响应时间</th>
<th>平均TPS（每秒事务数）</th>
</tr>
</thead>
<tbody>
<tr>
<td>REST: Jetty + JSON</td>
<td>7.806</td>
<td>1280</td>
</tr>
<tr>
<td>REST: Jetty + JSON + GZIP</td>
<td>TODO</td>
<td>TODO</td>
</tr>
<tr>
<td>REST: Jetty + XML</td>
<td>TODO</td>
<td>TODO</td>
</tr>
<tr>
<td>REST: Jetty + XML + GZIP</td>
<td>TODO</td>
<td>TODO</td>
</tr>
<tr>
<td>REST: Tomcat + JSON</td>
<td>2.082</td>
<td>4796</td>
</tr>
<tr>
<td>REST: Netty + JSON</td>
<td>2.182</td>
<td>4576</td>
</tr>
<tr>
<td>Dubbo: FST</td>
<td>1.211</td>
<td>8244</td>
</tr>
<tr>
<td>Dubbo: kyro</td>
<td>1.182</td>
<td>8444</td>
</tr>
<tr>
<td>Dubbo: dubbo serialization</td>
<td>1.43</td>
<td>6982</td>
</tr>
<tr>
<td>Dubbo: hessian2</td>
<td>1.49</td>
<td>6701</td>
</tr>
<tr>
<td>Dubbo: fastjson</td>
<td>1.572</td>
<td>6352</td>
</tr>
</tbody>
</table>
<p><img src="sources/images/rt.png" alt="no image found"></p>
<p><img src="sources/images/tps.png" alt="no image found"></p>
<p>仅就目前的结果，一点简单总结：</p>
<ul>
<li>dubbo RPC（特别是基于高效java序列化方式如kryo，fst）比REST的响应时间和吞吐量都有较显著优势，内网的dubbo系统之间优先选择dubbo RPC。</li>
<li>在REST的实现选择上，仅就性能而言，目前tomcat7和netty最优（当然目前使用的jetty和netty版本都较低）。tjws和sun http server在性能测试中表现极差，平均响应时间超过200ms，平均tps只有50左右（为了避免影响图片效果，没在上面列出）。</li>
<li>在REST中JSON数据格式性能优于XML（数据暂未在以上列出）。</li>
<li>在REST中启用GZIP对企业内网中的小数据量复杂对象帮助不大，性能反而有下降（数据暂未在以上列出）。</li>
</ul>
<h2>性能优化建议</h2>
<p>如果将dubbo REST部署到外部Tomcat上，并配置server=&quot;servlet&quot;，即启用外部的tomcat来做为rest server的底层实现，则最好在tomcat上添加如下配置：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"org.apache.coyote.http11.Http11NioProtocol"</span>
               <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span>
               <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span>
               <span class="hljs-attr">minSpareThreads</span>=<span class="hljs-string">"20"</span>
               <span class="hljs-attr">enableLookups</span>=<span class="hljs-string">"false"</span>
               <span class="hljs-attr">maxThreads</span>=<span class="hljs-string">"100"</span>
               <span class="hljs-attr">maxKeepAliveRequests</span>=<span class="hljs-string">"-1"</span>
               <span class="hljs-attr">keepAliveTimeout</span>=<span class="hljs-string">"60000"</span>/&gt;</span>
</code></pre>
<p>特别是maxKeepAliveRequests=&quot;-1&quot;，这个配置主要是保证tomcat一直启用http长连接，以提高REST调用性能。但是请注意，如果REST消费端不是持续的调用REST服务，则一直启用长连接未必是最好的做法。另外，一直启用长连接的方式一般不适合针对普通webapp，更适合这种类似rpc的场景。所以为了高性能，在tomcat中，dubbo REST应用和普通web应用最好不要混合部署，而应该用单独的实例。</p>
<p>TODO more contents to add</p>
<h2>扩展讨论</h2>
<h3>REST与Thrift、Protobuf等的对比</h3>
<p>TODO</p>
<h3>REST与传统WebServices的对比</h3>
<p>TODO</p>
<h3>JAX-RS与Spring MVC的对比</h3>
<p>初步看法，摘自http://www.infoq.com/cn/news/2014/10/dubbox-open-source?utm_source=infoq&amp;utm_medium=popular_links_homepage#theCommentsSection</p>
<blockquote>
<p>谢谢，对于jax-rs和spring mvc，其实我对spring mvc的rest支持还没有太深入的看过，说点初步想法，请大家指正：</p>
<p>spring mvc也支持annotation的配置，其实和jax-rs看起来是非常非常类似的。</p>
<p>我个人认为spring mvc相对更适合于面向web应用的restful服务，比如被AJAX调用，也可能输出HTML之类的，应用中还有页面跳转流程之类，spring mvc既可以做好正常的web页面请求也可以同时处理rest请求。但总的来说这个restful服务是在展现层或者叫web层之类实现的</p>
<p>而jax-rs相对更适合纯粹的服务化应用，也就是传统Java EE中所说的中间层服务，比如它可以把传统的EJB发布成restful服务。在spring应用中，也就把spring中充当service之类的bean直接发布成restful服务。总的来说这个restful服务是在业务、应用层或者facade层。而MVC层次和概念在这种做比如（后台）服务化的应用中通常是没有多大价值的。</p>
<p>当然jax-rs的有些实现比如jersey，也试图提供mvc支持，以更好的适应上面所说的web应用，但应该是不如spring mvc。</p>
<p>在dubbo应用中，我想很多人都比较喜欢直接将一个本地的spring service bean（或者叫manager之类的）完全透明的发布成远程服务，则这里用JAX-RS是更自然更直接的，不必额外的引入MVC概念。当然，先不讨论透明发布远程服务是不是最佳实践，要不要添加facade之类。</p>
<p>当然，我知道在dubbo不支持rest的情况下，很多朋友采用的架构是spring mvc restful调用dubbo (spring) service来发布restful服务的。这种方式我觉得也非常好，只是如果不修改spring mvc并将其与dubbo深度集成，restful服务不能像dubbo中的其他远程调用协议比如webservices、dubbo rpc、hessian等等那样，享受诸多高级的服务治理的功能，比如：注册到dubbo的服务注册中心，通过dubbo监控中心监控其调用次数、TPS、响应时间之类，通过dubbo的统一的配置方式控制其比如线程池大小、最大连接数等等，通过dubbo统一方式做服务流量控制、权限控制、频次控制。另外spring mvc仅仅负责服务端，而在消费端，通常是用spring restTemplate，如果restTemplate不和dubbo集成，有可能像dubbo服务客户端那样自动或者人工干预做服务降级。如果服务端消费端都是dubbo系统，通过spring的rest交互，如果spring rest不深度整合dubbo，则不能用dubbo统一的路由分流等功能。</p>
<p>当然，其实我个人认为这些东西不必要非此即彼的。我听说spring创始人rod johnson总是爱说一句话，the customer is always right，其实与其非要探讨哪种方式更好，不如同时支持两种方式就是了，所以原来在文档中也写过计划支持spring rest annoation，只是不知道具体可行性有多高。</p>
</blockquote>
<h2>未来</h2>
<p>稍后可能要实现的功能：</p>
<ul>
<li>spring mvc的rest annotation支持</li>
<li>安全</li>
<li>OAuth</li>
<li>异步调用</li>
<li>完善gzip</li>
<li>最大payload限制</li>
</ul>
</div></section><footer class="footer-container"><div class="footer-body"><img src="/img/dubbo_gray.png"/><img class="apache" src="/img/apache_logo.png"/><div class="cols-container"><div class="col col-12"><h3></h3><p></p></div><div class="col col-4"><dl><dt>ASF</dt><dd><a href="http://www.apache.org" target="_self">基金会</a></dd><dd><a href="http://www.apache.org/licenses/" target="_self">证书</a></dd><dd><a href="http://www.apache.org/events/current-event" target="_self">事件</a></dd><dd><a href="http://www.apache.org/foundation/sponsorship.html" target="_self">赞助</a></dd><dd><a href="http://www.apache.org/foundation/thanks.html" target="_self">致谢</a></dd></dl></div><div class="col col-4"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/user/quick-start.html" target="_self">快速开始</a></dd><dd><a href="/zh-cn/docs/dev/build.html" target="_self">开发者指南</a></dd><dd><a href="/zh-cn/docs/admin/ops/dubbo-ops.html" target="_self">运维管理</a></dd><dd><a href="https://github.com/apache/dubbo-website/issues/new" target="_self">报告文档问题</a></dd><dd><a href="https://github.com/apache/dubbo-website" target="_self">编辑此文档</a></dd></dl></div><div class="col col-4"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/community/index.html" target="_self">社区</a></dd><dd><a href="https://www.apache.org/security" target="_self">安全</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2018-2019 The Apache Software Foundation. Apache and the Apache feather logo are trademarks of The Apache Software Foundation.</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
  <script src="/build/documentation.js"></script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112489517-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-112489517-1');
	</script>
</body>
</html>