<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Apache Dubbo – 开发指南</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/</link><description>Recent content in 开发指南 on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://dubbo.apache.org/zh-cn/docsv2.7/dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Docsv2.7: 源码构建</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/build/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/build/</guid><description>
&lt;h2 id="代码签出">代码签出&lt;/h2>
&lt;p>通过以下的这个命令签出最新的项目源码 &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>git clone https://github.com/apache/dubbo.git
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="分支">分支&lt;/h2>
&lt;p>我们使用 master 作为主干版本的开发，使用分支作为维护版本。可以通过 &lt;a href="https://github.com/apache/dubbo/tags">https://github.com/apache/dubbo/tags&lt;/a> 来查看所有版本的标签。&lt;/p>
&lt;h2 id="构建">构建&lt;/h2>
&lt;p>Dubbo 使用 &lt;a href="http://maven.apache.org">maven&lt;/a> 作为构建工具。&lt;/p>
&lt;p>要求&lt;/p>
&lt;ul>
&lt;li>Java 1.8 以上的版本&lt;/li>
&lt;li>Maven 2.2.1 或者以上的版本&lt;/li>
&lt;/ul>
&lt;p>构建之前需要配置以下的 &lt;code>MAVEN_OPTS&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b58900">export&lt;/span> &lt;span style="color:#268bd2">MAVEN_OPTS&lt;/span>&lt;span style="color:#719e07">=&lt;/span>-Xmx1024m -XX:MaxPermSize&lt;span style="color:#719e07">=&lt;/span>512m
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用以下命令做一次构建&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>mvn clean install
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以通过以下的构建命令来跳过单元测试&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>mvn install -Dmaven.test.skip
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="构建源代码-jar-包">构建源代码 jar 包&lt;/h2>
&lt;p>通过以下命令以构建 Dubbo 的源代码 jar 包&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>mvn clean source:jar install -Dmaven.test.skip
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>并且修改你的样例项目中的 dubbo 依赖为本地仓库的 SANPSHOT 版本，然后使用远程 debug 来调试 dubbo。&lt;/p>
&lt;h2 id="ide-支持">IDE 支持&lt;/h2>
&lt;p>使用以下命令来生成 IDE 的工程&lt;/p>
&lt;h3 id="intellij-idea">Intellij Idea&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>mvn idea:idea
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="eclipse">eclipse&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>mvn eclipse:eclipse
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 eclipse 中导入&lt;/p>
&lt;p>首先，需要在 eclipse 中配置 maven 仓库。通过 Preferences -&amp;gt; Java -&amp;gt; Build Path -&amp;gt; Classpath 定义 &lt;code>M2_REPO&lt;/code> 的 classpath 变量指向本地的 maven 仓库。 &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/p>
&lt;p>也可以通过以下的 maven 命令配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>mvn eclipse:configure-workspace -Declipse.workspace&lt;span style="color:#719e07">=&lt;/span>/path/to/the/workspace/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>也可以直接在 &lt;a href="https://github.com/apache/dubbo">https://github.com/apache/dubbo&lt;/a> 上浏览源代码&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>UNIX 下的路径是 ${HOME}/.m2/repository, Windows 下的路径是 C:\Documents and Settings&amp;lt;user&amp;gt;.m2\repository&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Docsv2.7: 框架设计</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/design/</guid><description>
&lt;h2 id="整体设计">整体设计&lt;/h2>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/dev/dubbo-framework.jpg" alt="/dev-guide/images/dubbo-framework.jpg">&lt;/p>
&lt;p>图例说明：&lt;/p>
&lt;ul>
&lt;li>图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。&lt;/li>
&lt;li>图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。&lt;/li>
&lt;li>图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。&lt;/li>
&lt;li>图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。&lt;/li>
&lt;/ul>
&lt;h2 id="各层说明">各层说明&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>config 配置层&lt;/strong>：对外配置接口，以 &lt;code>ServiceConfig&lt;/code>, &lt;code>ReferenceConfig&lt;/code> 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类&lt;/li>
&lt;li>&lt;strong>proxy 服务代理层&lt;/strong>：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 &lt;code>ServiceProxy&lt;/code> 为中心，扩展接口为 &lt;code>ProxyFactory&lt;/code>&lt;/li>
&lt;li>&lt;strong>registry 注册中心层&lt;/strong>：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 &lt;code>RegistryFactory&lt;/code>, &lt;code>Registry&lt;/code>, &lt;code>RegistryService&lt;/code>&lt;/li>
&lt;li>&lt;strong>cluster 路由层&lt;/strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 &lt;code>Invoker&lt;/code> 为中心，扩展接口为 &lt;code>Cluster&lt;/code>, &lt;code>Directory&lt;/code>, &lt;code>Router&lt;/code>, &lt;code>LoadBalance&lt;/code>&lt;/li>
&lt;li>&lt;strong>monitor 监控层&lt;/strong>：RPC 调用次数和调用时间监控，以 &lt;code>Statistics&lt;/code> 为中心，扩展接口为 &lt;code>MonitorFactory&lt;/code>, &lt;code>Monitor&lt;/code>, &lt;code>MonitorService&lt;/code>&lt;/li>
&lt;li>&lt;strong>protocol 远程调用层&lt;/strong>：封装 RPC 调用，以 &lt;code>Invocation&lt;/code>, &lt;code>Result&lt;/code> 为中心，扩展接口为 &lt;code>Protocol&lt;/code>, &lt;code>Invoker&lt;/code>, &lt;code>Exporter&lt;/code>&lt;/li>
&lt;li>&lt;strong>exchange 信息交换层&lt;/strong>：封装请求响应模式，同步转异步，以 &lt;code>Request&lt;/code>, &lt;code>Response&lt;/code> 为中心，扩展接口为 &lt;code>Exchanger&lt;/code>, &lt;code>ExchangeChannel&lt;/code>, &lt;code>ExchangeClient&lt;/code>, &lt;code>ExchangeServer&lt;/code>&lt;/li>
&lt;li>&lt;strong>transport 网络传输层&lt;/strong>：抽象 mina 和 netty 为统一接口，以 &lt;code>Message&lt;/code> 为中心，扩展接口为 &lt;code>Channel&lt;/code>, &lt;code>Transporter&lt;/code>, &lt;code>Client&lt;/code>, &lt;code>Server&lt;/code>, &lt;code>Codec&lt;/code>&lt;/li>
&lt;li>&lt;strong>serialize 数据序列化层&lt;/strong>：可复用的一些工具，扩展接口为 &lt;code>Serialization&lt;/code>, &lt;code>ObjectInput&lt;/code>, &lt;code>ObjectOutput&lt;/code>, &lt;code>ThreadPool&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="关系说明">关系说明&lt;/h2>
&lt;ul>
&lt;li>在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。&lt;/li>
&lt;li>图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓扑节点，保持统一概念。&lt;/li>
&lt;li>而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。&lt;/li>
&lt;li>Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。&lt;/li>
&lt;li>而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。&lt;/li>
&lt;li>Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。&lt;/li>
&lt;/ul>
&lt;h2 id="模块分包">模块分包&lt;/h2>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/dev/dubbo-modules.jpg" alt="/dev-guide/images/dubbo-modules.jpg">&lt;/p>
&lt;p>模块说明：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>dubbo-common 公共逻辑模块&lt;/strong>：包括 Util 类和通用模型。&lt;/li>
&lt;li>&lt;strong>dubbo-remoting 远程通讯模块&lt;/strong>：相当于 Dubbo 协议的实现，如果 RPC 用 RMI协议则不需要使用此包。&lt;/li>
&lt;li>&lt;strong>dubbo-rpc 远程调用模块&lt;/strong>：抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。&lt;/li>
&lt;li>&lt;strong>dubbo-cluster 集群模块&lt;/strong>：将多个服务提供方伪装为一个提供方，包括：负载均衡, 容错，路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。&lt;/li>
&lt;li>&lt;strong>dubbo-registry 注册中心模块&lt;/strong>：基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。&lt;/li>
&lt;li>&lt;strong>dubbo-monitor 监控模块&lt;/strong>：统计服务调用次数，调用时间的，调用链跟踪的服务。&lt;/li>
&lt;li>&lt;strong>dubbo-config 配置模块&lt;/strong>：是 Dubbo 对外的 API，用户通过 Config 使用Dubbo，隐藏 Dubbo 所有细节。&lt;/li>
&lt;li>&lt;strong>dubbo-container 容器模块&lt;/strong>：是一个 Standlone 的容器，以简单的 Main 加载 Spring 启动，因为服务通常不需要 Tomcat/JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。&lt;/li>
&lt;/ul>
&lt;p>整体上按照分层结构进行分包，与分层的不同点在于：&lt;/p>
&lt;ul>
&lt;li>container 为服务容器，用于部署运行服务，没有在层中画出。&lt;/li>
&lt;li>protocol 层和 proxy 层都放在 rpc 模块中，这两层是 rpc 的核心，在不需要集群也就是只有一个提供者时，可以只使用这两层完成 rpc 调用。&lt;/li>
&lt;li>transport 层和 exchange 层都放在 remoting 模块中，为 rpc 调用的通讯基础。&lt;/li>
&lt;li>serialize 层放在 common 模块中，以便更大程度复用。&lt;/li>
&lt;/ul>
&lt;h2 id="依赖关系">依赖关系&lt;/h2>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/dev/dubbo-relation.jpg" alt="/dev-guide/images/dubbo-relation.jpg">&lt;/p>
&lt;p>图例说明：&lt;/p>
&lt;ul>
&lt;li>图中小方块 Protocol, Cluster, Proxy, Service, Container, Registry, Monitor 代表层或模块，蓝色的表示与业务有交互，绿色的表示只对 Dubbo 内部交互。&lt;/li>
&lt;li>图中背景方块 Consumer, Provider, Registry, Monitor 代表部署逻辑拓扑节点。&lt;/li>
&lt;li>图中蓝色虚线为初始化时调用，红色虚线为运行时异步调用，红色实线为运行时同步调用。&lt;/li>
&lt;li>图中只包含 RPC 的层，不包含 Remoting 的层，Remoting 整体都隐含在 Protocol 中。&lt;/li>
&lt;/ul>
&lt;h2 id="调用链">调用链&lt;/h2>
&lt;p>展开总设计图的红色调用链，如下：&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/dev/dubbo-extension.jpg" alt="/dev-guide/images/dubbo-extension.jpg">&lt;/p>
&lt;h2 id="暴露服务时序">暴露服务时序&lt;/h2>
&lt;p>展开总设计图右边服务提供方暴露服务的蓝色初始化链，时序图如下：&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/dev/dubbo-export.jpg" alt="/dev-guide/images/dubbo-export.jpg">&lt;/p>
&lt;h2 id="引用服务时序">引用服务时序&lt;/h2>
&lt;p>展开总设计图左边服务消费方引用服务的绿色初始化链，时序图如下：&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/dev/dubbo-refer.jpg" alt="/dev-guide/images/dubbo-refer.jpg">&lt;/p>
&lt;h2 id="领域模型">领域模型&lt;/h2>
&lt;p>在 Dubbo 的核心领域模型中：&lt;/p>
&lt;ul>
&lt;li>Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。&lt;/li>
&lt;li>Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。&lt;/li>
&lt;li>Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数等。&lt;/li>
&lt;/ul>
&lt;h2 id="基本设计原则">基本设计原则&lt;/h2>
&lt;ul>
&lt;li>采用 Microkernel + Plugin 模式，Microkernel 只负责组装 Plugin，Dubbo 自身的功能也是通过扩展点实现的，也就是 Dubbo 的所有功能点都可被用户自定义扩展所替换。&lt;/li>
&lt;li>采用 URL 作为配置信息的统一格式，所有扩展点都通过传递 URL 携带配置信息。&lt;/li>
&lt;/ul>
&lt;p>更多设计原则参见：&lt;a href="../principals/">框架设计原则&lt;/a>&lt;/p></description></item><item><title>Docsv2.7: 扩展点加载</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/spi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/spi/</guid><description>
&lt;h2 id="扩展点配置">扩展点配置&lt;/h2>
&lt;h3 id="来源">来源：&lt;/h3>
&lt;p>Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。&lt;/p>
&lt;p>Dubbo 改进了 JDK 标准的 SPI 的以下问题：&lt;/p>
&lt;ul>
&lt;li>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。&lt;/li>
&lt;li>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK 标准的 ScriptEngine，通过 &lt;code>getName()&lt;/code> 获取脚本类型的名称，但如果 RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby 脚本时，会报不支持 ruby，而不是真正失败的原因。&lt;/li>
&lt;li>增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。&lt;/li>
&lt;/ul>
&lt;h3 id="约定">约定：&lt;/h3>
&lt;p>在扩展类的 jar 包内 &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>，放置扩展点配置文件 &lt;code>META-INF/dubbo/接口全限定名&lt;/code>，内容为：&lt;code>配置名=扩展实现类全限定名&lt;/code>，多个实现类用换行符分隔。&lt;/p>
&lt;h3 id="示例">示例：&lt;/h3>
&lt;p>以扩展 Dubbo 的协议为例，在协议的实现 jar 包内放置文本文件：&lt;code>META-INF/dubbo/org.apache.dubbo.rpc.Protocol&lt;/code>，内容为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>xxx&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">com.alibaba.xxx.XxxProtocol&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>实现类内容 &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">package&lt;/span> com.alibaba.xxx;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.Protocol;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">XxxProtocol&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> Protocol {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置模块中的配置">配置模块中的配置&lt;/h3>
&lt;p>Dubbo 配置模块中，扩展点均有对应配置属性或标签，通过配置指定使用哪个扩展实现。比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;dubbo:protocol&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;xxx&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="扩展点特性">扩展点特性&lt;/h2>
&lt;h3 id="扩展点自动包装">扩展点自动包装&lt;/h3>
&lt;p>自动包装扩展点的 Wrapper 类。&lt;code>ExtensionLoader&lt;/code> 在加载扩展点时，如果加载到的扩展点有拷贝构造函数，则判定为扩展点 Wrapper 类。&lt;/p>
&lt;p>Wrapper类内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">package&lt;/span> com.alibaba.xxx;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.Protocol;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">XxxProtocolWrapper&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> Protocol {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Protocol impl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">XxxProtocolWrapper&lt;/span>(Protocol protocol) { impl &lt;span style="color:#719e07">=&lt;/span> protocol; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 接口方法做一个操作后，再调用extension的方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">refer&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//... 一些操作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> impl.refer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ... 一些操作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Wrapper 类同样实现了扩展点接口，但是 Wrapper 不是扩展点的真正实现。它的用途主要是用于从 &lt;code>ExtensionLoader&lt;/code> 返回扩展点时，包装在真正的扩展点实现外。即从 &lt;code>ExtensionLoader&lt;/code> 中返回的实际上是 Wrapper 类的实例，Wrapper 持有了实际的扩展点实现类。&lt;/p>
&lt;p>扩展点的 Wrapper 类可以有多个，也可以根据需要新增。&lt;/p>
&lt;p>通过 Wrapper 类可以把所有扩展点公共逻辑移至 Wrapper 中。新加的 Wrapper 在所有的扩展点上添加了逻辑，有些类似 AOP，即 Wrapper 代理了扩展点。&lt;/p>
&lt;h3 id="扩展点自动装配">扩展点自动装配&lt;/h3>
&lt;p>加载扩展点时，自动注入依赖的扩展点。加载扩展点时，扩展点实现类的成员如果为其它扩展点类型，&lt;code>ExtensionLoader&lt;/code> 在会自动注入依赖的扩展点。&lt;code>ExtensionLoader&lt;/code> 通过扫描扩展点实现类的所有 setter 方法来判定其成员。即 &lt;code>ExtensionLoader&lt;/code> 会执行扩展点的拼装操作。&lt;/p>
&lt;p>示例：有两个为扩展点 &lt;code>CarMaker&lt;/code>（造车者）、&lt;code>WheelMaker&lt;/code> (造轮者)&lt;/p>
&lt;p>接口类如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">CarMaker&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Car &lt;span style="color:#268bd2">makeCar&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">WheelMaker&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Wheel &lt;span style="color:#268bd2">makeWheel&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>CarMaker&lt;/code> 的一个实现类：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">RaceCarMaker&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> CarMaker {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WheelMaker wheelMaker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">setWheelMaker&lt;/span>(WheelMaker wheelMaker) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.wheelMaker &lt;span style="color:#719e07">=&lt;/span> wheelMaker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> Car &lt;span style="color:#268bd2">makeCar&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Wheel wheel &lt;span style="color:#719e07">=&lt;/span> wheelMaker.makeWheel();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> RaceCar(wheel, ...);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>ExtensionLoader&lt;/code> 加载 &lt;code>CarMaker&lt;/code> 的扩展点实现 &lt;code>RaceCarMaker&lt;/code> 时，&lt;code>setWheelMaker&lt;/code> 方法的 &lt;code>WheelMaker&lt;/code> 也是扩展点则会注入 &lt;code>WheelMaker&lt;/code> 的实现。&lt;/p>
&lt;p>这里带来另一个问题，&lt;code>ExtensionLoader&lt;/code> 要注入依赖扩展点时，如何决定要注入依赖扩展点的哪个实现。在这个示例中，即是在多个&lt;code>WheelMaker&lt;/code> 的实现中要注入哪个。&lt;/p>
&lt;p>这个问题在下面一点 &lt;a href="#%E6%89%A9%E5%B1%95%E7%82%B9%E8%87%AA%E9%80%82%E5%BA%94">扩展点自适应&lt;/a> 中说明。&lt;/p>
&lt;h3 id="扩展点自适应">扩展点自适应&lt;/h3>
&lt;p>&lt;code>ExtensionLoader&lt;/code> 注入的依赖扩展点是一个 &lt;code>Adaptive&lt;/code> 实例，直到扩展点方法执行时才决定调用是哪一个扩展点实现。&lt;/p>
&lt;p>Dubbo 使用 URL 对象（包含了Key-Value）传递配置信息。&lt;/p>
&lt;p>扩展点方法调用会有URL参数（或是参数有URL成员）&lt;/p>
&lt;p>这样依赖的扩展点也可以从URL拿到配置信息，所有的扩展点自己定好配置的Key后，配置信息从URL上从最外层传入。URL在配置传递上即是一条总线。&lt;/p>
&lt;p>示例：有两个为扩展点 &lt;code>CarMaker&lt;/code>、&lt;code>WheelMaker&lt;/code>&lt;/p>
&lt;p>接口类如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">CarMaker&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Car &lt;span style="color:#268bd2">makeCar&lt;/span>(URL url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">WheelMaker&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Wheel &lt;span style="color:#268bd2">makeWheel&lt;/span>(URL url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>CarMaker&lt;/code> 的一个实现类：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">RaceCarMaker&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> CarMaker {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WheelMaker wheelMaker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">setWheelMaker&lt;/span>(WheelMaker wheelMaker) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.wheelMaker &lt;span style="color:#719e07">=&lt;/span> wheelMaker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> Car &lt;span style="color:#268bd2">makeCar&lt;/span>(URL url) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Wheel wheel &lt;span style="color:#719e07">=&lt;/span> wheelMaker.makeWheel(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">new&lt;/span> RaceCar(wheel, ...);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当上面执行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wheel wheel &lt;span style="color:#719e07">=&lt;/span> wheelMaker.makeWheel(url);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>时，注入的 &lt;code>Adaptive&lt;/code> 实例可以提取事先定义好的 Key 来决定使用哪个 &lt;code>WheelMaker&lt;/code> 实现来调用对应实现的真正的 &lt;code>makeWheel&lt;/code> 方法。如提取 &lt;code>wheel.type&lt;/code> Key，即 &lt;code>url.get(&amp;quot;wheel.type&amp;quot;)&lt;/code> 来决定 &lt;code>WheelMaker&lt;/code> 实现。&lt;code>Adaptive&lt;/code> 实例的逻辑是固定的，从 URL 中提取事先定义好的 Key，动态生成真正的实现并执行它。&lt;/p>
&lt;p>&lt;code>ExtensionLoader&lt;/code> 里面的扩展点注入的 &lt;code>Adaptive&lt;/code> 实现是在dubbo加载扩展点时动态生成的。Key是从URL中获取的，而URL中Key的值是在扩展点接口的方法定义上通过@Adaptive注解提供的。&lt;/p>
&lt;p>下面是 Dubbo 的 Transporter 扩展点的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">Transporter&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Adaptive&lt;/span>({&lt;span style="color:#2aa198">&amp;#34;server&amp;#34;&lt;/span>, &lt;span style="color:#2aa198">&amp;#34;transport&amp;#34;&lt;/span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Server &lt;span style="color:#268bd2">bind&lt;/span>(URL url, ChannelHandler handler) &lt;span style="color:#268bd2">throws&lt;/span> RemotingException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Adaptive&lt;/span>({&lt;span style="color:#2aa198">&amp;#34;client&amp;#34;&lt;/span>, &lt;span style="color:#2aa198">&amp;#34;transport&amp;#34;&lt;/span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Client &lt;span style="color:#268bd2">connect&lt;/span>(URL url, ChannelHandler handler) &lt;span style="color:#268bd2">throws&lt;/span> RemotingException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于 bind() 方法，Adaptive 实现先查找 &lt;code>server&lt;/code> key，如果该 Key 没有值则找 &lt;code>transport&lt;/code> key 值，来决定代理到哪个实际扩展点。&lt;/p>
&lt;h3 id="扩展点自动激活">扩展点自动激活&lt;/h3>
&lt;p>对于集合类扩展点，比如：&lt;code>Filter&lt;/code>, &lt;code>InvokerListener&lt;/code>, &lt;code>ExportListener&lt;/code>, &lt;code>TelnetHandler&lt;/code>, &lt;code>StatusChecker&lt;/code> 等，可以同时加载多个实现，此时，可以用自动激活来简化配置，如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.common.extension.Activate;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.Filter;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Activate&lt;/span> &lt;span style="color:#586e75">// 无条件自动激活&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">XxxFilter&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> Filter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.common.extension.Activate;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.Filter;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Activate&lt;/span>(&lt;span style="color:#2aa198">&amp;#34;xxx&amp;#34;&lt;/span>) &lt;span style="color:#586e75">// 当配置了xxx参数，并且参数为有效值时激活，比如配了cache=&amp;#34;lru&amp;#34;，自动激活CacheFilter。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">XxxFilter&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> Filter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.common.extension.Activate;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">import&lt;/span> org.apache.dubbo.rpc.Filter;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Activate&lt;/span>(group &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;provider&amp;#34;&lt;/span>, value &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#2aa198">&amp;#34;xxx&amp;#34;&lt;/span>) &lt;span style="color:#586e75">// 只对提供方激活，group可选&amp;#34;provider&amp;#34;或&amp;#34;consumer&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">XxxFilter&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> Filter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>注意：这里的配置文件是放在你自己的 jar 包内，不是 dubbo 本身的 jar 包内，Dubbo 会全 ClassPath 扫描所有 jar 包内同名的这个文件，然后进行合并&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>注意：扩展点使用单一实例加载（请确保扩展实现的线程安全性），缓存在 &lt;code>ExtensionLoader&lt;/code> 中&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Docsv2.7: 实现细节</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/implementation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/implementation/</guid><description>
&lt;h2 id="初始化过程细节">初始化过程细节&lt;/h2>
&lt;h3 id="解析服务">解析服务&lt;/h3>
&lt;p>基于 dubbo.jar 内的 &lt;code>META-INF/spring.handlers&lt;/code> 配置，Spring 在遇到 dubbo 名称空间时，会回调 &lt;code>DubboNamespaceHandler&lt;/code>。&lt;/p>
&lt;p>所有 dubbo 的标签，都统一用 &lt;code>DubboBeanDefinitionParser&lt;/code> 进行解析，基于一对一属性映射，将 XML 标签解析为 Bean 对象。&lt;/p>
&lt;p>在 &lt;code>ServiceConfig.export()&lt;/code> 或 &lt;code>ReferenceConfig.get()&lt;/code> 初始化时，将 Bean 对象转换 URL 格式，所有 Bean 属性转成 URL 的参数。&lt;/p>
&lt;p>然后将 URL 传给 &lt;a href="../impls/protocol">协议扩展点&lt;/a>，基于扩展点的 &lt;a href="../spi">扩展点自适应机制&lt;/a>，根据 URL 的协议头，进行不同协议的服务暴露或引用。&lt;/p>
&lt;h3 id="暴露服务">暴露服务&lt;/h3>
&lt;h4 id="1-只暴露服务端口">1. 只暴露服务端口：&lt;/h4>
&lt;p>在没有注册中心，直接暴露提供者的情况下 &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>，&lt;code>ServiceConfig&lt;/code> 解析出的 URL 的格式为：
&lt;code>dubbo://service-host/com.foo.FooService?version=1.0.0&lt;/code>。&lt;/p>
&lt;p>基于扩展点自适应机制，通过 URL 的 &lt;code>dubbo://&lt;/code> 协议头识别，直接调用 &lt;code>DubboProtocol&lt;/code>的 &lt;code>export()&lt;/code> 方法，打开服务端口。&lt;/p>
&lt;h4 id="2-向注册中心暴露服务">2. 向注册中心暴露服务：&lt;/h4>
&lt;p>在有注册中心，需要注册提供者地址的情况下 &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>，&lt;code>ServiceConfig&lt;/code> 解析出的 URL 的格式为: &lt;code>registry://registry-host/org.apache.dubbo.registry.RegistryService?export=URL.encode(&amp;quot;dubbo://service-host/com.foo.FooService?version=1.0.0&amp;quot;)&lt;/code>，&lt;/p>
&lt;p>基于扩展点自适应机制，通过 URL 的 &lt;code>registry://&lt;/code> 协议头识别，就会调用 &lt;code>RegistryProtocol&lt;/code> 的 &lt;code>export()&lt;/code> 方法，将 &lt;code>export&lt;/code> 参数中的提供者 URL，先注册到注册中心。&lt;/p>
&lt;p>再重新传给 &lt;code>Protocol&lt;/code> 扩展点进行暴露： &lt;code>dubbo://service-host/com.foo.FooService?version=1.0.0&lt;/code>，然后基于扩展点自适应机制，通过提供者 URL 的 &lt;code>dubbo://&lt;/code> 协议头识别，就会调用 &lt;code>DubboProtocol&lt;/code> 的 &lt;code>export()&lt;/code> 方法，打开服务端口。&lt;/p>
&lt;h3 id="引用服务">引用服务&lt;/h3>
&lt;h4 id="1-直连引用服务">1. 直连引用服务：&lt;/h4>
&lt;p>在没有注册中心，直连提供者的情况下 &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>，&lt;code>ReferenceConfig&lt;/code> 解析出的 URL 的格式为：&lt;code>dubbo://service-host/com.foo.FooService?version=1.0.0&lt;/code>。&lt;/p>
&lt;p>基于扩展点自适应机制，通过 URL 的 &lt;code>dubbo://&lt;/code> 协议头识别，直接调用 &lt;code>DubboProtocol&lt;/code> 的 &lt;code>refer()&lt;/code> 方法，返回提供者引用。&lt;/p>
&lt;h4 id="2-从注册中心发现引用服务">2. 从注册中心发现引用服务：&lt;/h4>
&lt;p>在有注册中心，通过注册中心发现提供者地址的情况下 &lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>，&lt;code>ReferenceConfig&lt;/code> 解析出的 URL 的格式为：
&lt;code>registry://registry-host/org.apache.dubbo.registry.RegistryService?refer=URL.encode(&amp;quot;consumer://consumer-host/com.foo.FooService?version=1.0.0&amp;quot;)&lt;/code>。&lt;/p>
&lt;p>基于扩展点自适应机制，通过 URL 的 &lt;code>registry://&lt;/code> 协议头识别，就会调用 &lt;code>RegistryProtocol&lt;/code> 的 &lt;code>refer()&lt;/code> 方法，基于 &lt;code>refer&lt;/code> 参数中的条件，查询提供者 URL，如：
&lt;code>dubbo://service-host/com.foo.FooService?version=1.0.0&lt;/code>。&lt;/p>
&lt;p>基于扩展点自适应机制，通过提供者 URL 的 &lt;code>dubbo://&lt;/code> 协议头识别，就会调用 &lt;code>DubboProtocol&lt;/code> 的 &lt;code>refer()&lt;/code> 方法，得到提供者引用。&lt;/p>
&lt;p>然后 &lt;code>RegistryProtocol&lt;/code> 将多个提供者引用，通过 &lt;code>Cluster&lt;/code> 扩展点，伪装成单个提供者引用返回。&lt;/p>
&lt;h3 id="拦截服务">拦截服务&lt;/h3>
&lt;p>基于扩展点自适应机制，所有的 &lt;code>Protocol&lt;/code> 扩展点都会自动套上 &lt;code>Wrapper&lt;/code> 类。&lt;/p>
&lt;p>基于 &lt;code>ProtocolFilterWrapper&lt;/code> 类，将所有 &lt;code>Filter&lt;/code> 组装成链，在链的最后一节调用真实的引用。&lt;/p>
&lt;p>基于 &lt;code>ProtocolListenerWrapper&lt;/code> 类，将所有 &lt;code>InvokerListener&lt;/code> 和 &lt;code>ExporterListener&lt;/code> 组装集合，在暴露和引用前后，进行回调。&lt;/p>
&lt;p>包括监控在内，所有附加功能，全部通过 &lt;code>Filter&lt;/code> 拦截实现。&lt;/p>
&lt;h2 id="远程调用细节">远程调用细节&lt;/h2>
&lt;h3 id="服务提供者暴露一个服务的详细过程">服务提供者暴露一个服务的详细过程&lt;/h3>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/dev/dubbo_rpc_export.jpg" alt="/dev-guide/images/dubbo_rpc_export.jpg">&lt;/p>
&lt;p>上图是服务提供者暴露服务的主过程：&lt;/p>
&lt;p>首先 &lt;code>ServiceConfig&lt;/code> 类拿到对外提供服务的实际类 ref（如：HelloWorldImpl），然后通过 &lt;code>ProxyFactory&lt;/code> 类的 &lt;code>getInvoker&lt;/code> 方法使用 ref 生成一个 &lt;code>AbstractProxyInvoker&lt;/code> 实例，到这一步就完成具体服务到 &lt;code>Invoker&lt;/code> 的转化。接下来就是 &lt;code>Invoker&lt;/code> 转换到 &lt;code>Exporter&lt;/code> 的过程。&lt;/p>
&lt;p>Dubbo 处理服务暴露的关键就在 &lt;code>Invoker&lt;/code> 转换到 &lt;code>Exporter&lt;/code> 的过程，上图中的红色部分。下面我们以 Dubbo 和 RMI 这两种典型协议的实现来进行说明：&lt;/p>
&lt;h4 id="dubbo-的实现">Dubbo 的实现&lt;/h4>
&lt;p>Dubbo 协议的 &lt;code>Invoker&lt;/code> 转为 &lt;code>Exporter&lt;/code> 发生在 &lt;code>DubboProtocol&lt;/code> 类的 &lt;code>export&lt;/code> 方法，它主要是打开 socket 侦听服务，并接收客户端发来的各种请求，通讯细节由 Dubbo 自己实现。&lt;/p>
&lt;h4 id="rmi-的实现">RMI 的实现&lt;/h4>
&lt;p>RMI 协议的 &lt;code>Invoker&lt;/code> 转为 &lt;code>Exporter&lt;/code> 发生在 &lt;code>RmiProtocol&lt;/code>类的 &lt;code>export&lt;/code> 方法，它通过 Spring 或 Dubbo 或 JDK 来实现 RMI 服务，通讯细节这一块由 JDK 底层来实现，这就省了不少工作量。&lt;/p>
&lt;h3 id="服务消费者消费一个服务的详细过程">服务消费者消费一个服务的详细过程&lt;/h3>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/dev/dubbo_rpc_refer.jpg" alt="/dev-guide/images/dubbo_rpc_refer.jpg">&lt;/p>
&lt;p>上图是服务消费的主过程：&lt;/p>
&lt;p>首先 &lt;code>ReferenceConfig&lt;/code> 类的 &lt;code>init&lt;/code> 方法调用 &lt;code>Protocol&lt;/code> 的 &lt;code>refer&lt;/code> 方法生成 &lt;code>Invoker&lt;/code> 实例（如上图中的红色部分），这是服务消费的关键。接下来把 &lt;code>Invoker&lt;/code> 转换为客户端需要的接口（如：HelloWorld）。&lt;/p>
&lt;p>关于每种协议如 RMI/Dubbo/Web service 等它们在调用 &lt;code>refer&lt;/code> 方法生成 &lt;code>Invoker&lt;/code> 实例的细节和上一章节所描述的类似。&lt;/p>
&lt;h3 id="满眼都是-invoker">满眼都是 Invoker&lt;/h3>
&lt;p>由于 &lt;code>Invoker&lt;/code> 是 Dubbo 领域模型中非常重要的一个概念，很多设计思路都是向它靠拢。这就使得 &lt;code>Invoker&lt;/code> 渗透在整个实现代码里，对于刚开始接触 Dubbo 的人，确实容易给搞混了。
下面我们用一个精简的图来说明最重要的两种 &lt;code>Invoker&lt;/code>——服务提供 &lt;code>Invoker&lt;/code> 和服务消费 &lt;code>Invoker&lt;/code>：&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/dev/dubbo_rpc_invoke.jpg" alt="/dev-guide/images/dubbo_rpc_invoke.jpg">&lt;/p>
&lt;p>为了更好的解释上面这张图，我们结合服务消费和提供者的代码示例来进行说明：&lt;/p>
&lt;p>服务消费者代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">DemoClientAction&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> DemoService demoService;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">setDemoService&lt;/span>(DemoService demoService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.demoService &lt;span style="color:#719e07">=&lt;/span> demoService;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">start&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String hello &lt;span style="color:#719e07">=&lt;/span> demoService.sayHello(&lt;span style="color:#2aa198">&amp;#34;world&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码中的 &lt;code>DemoService&lt;/code> 就是上图中服务消费端的 proxy，用户代码通过这个 proxy 调用其对应的 &lt;code>Invoker&lt;/code> &lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>，而该 &lt;code>Invoker&lt;/code> 实现了真正的远程服务调用。&lt;/p>
&lt;p>服务提供者代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">DemoServiceImpl&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> DemoService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> String &lt;span style="color:#268bd2">sayHello&lt;/span>(String name) &lt;span style="color:#268bd2">throws&lt;/span> RemoteException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#2aa198">&amp;#34;Hello &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面这个类会被封装成为一个 &lt;code>AbstractProxyInvoker&lt;/code> 实例，并新生成一个 &lt;code>Exporter&lt;/code> 实例。这样当网络通讯层收到一个请求后，会找到对应的 &lt;code>Exporter&lt;/code> 实例，并调用它所对应的 &lt;code>AbstractProxyInvoker&lt;/code> 实例，从而真正调用了服务提供者的代码。Dubbo 里还有一些其他的 &lt;code>Invoker&lt;/code> 类，但上面两种是最重要的。&lt;/p>
&lt;h2 id="远程通讯细节">远程通讯细节&lt;/h2>
&lt;h3 id="协议头约定">协议头约定&lt;/h3>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/dev/dubbo_protocol_header.png" alt="/dev-guide/images/dubbo_protocol_header.jpg">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Magic - Magic High &amp;amp; Magic Low (16 bits)&lt;/p>
&lt;p>标识协议版本号，Dubbo 协议：0xdabb&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Req/Res (1 bit)&lt;/p>
&lt;p>标识是请求或响应。请求： 1; 响应： 0。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2 Way (1 bit)&lt;/p>
&lt;p>仅在 Req/Res 为1（请求）时才有用，标记是否期望从服务器返回值。如果需要来自服务器的返回值，则设置为1。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Event (1 bit)&lt;/p>
&lt;p>标识是否是事件消息，例如，心跳事件。如果这是一个事件，则设置为1。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Serialization ID (5 bit)&lt;/p>
&lt;p>标识序列化类型：比如 fastjson 的值为6。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Status (8 bits)&lt;/p>
&lt;p>仅在 Req/Res 为0（响应）时有用，用于标识响应的状态。&lt;/p>
&lt;ul>
&lt;li>20 - OK&lt;/li>
&lt;li>30 - CLIENT_TIMEOUT&lt;/li>
&lt;li>31 - SERVER_TIMEOUT&lt;/li>
&lt;li>40 - BAD_REQUEST&lt;/li>
&lt;li>50 - BAD_RESPONSE&lt;/li>
&lt;li>60 - SERVICE_NOT_FOUND&lt;/li>
&lt;li>70 - SERVICE_ERROR&lt;/li>
&lt;li>80 - SERVER_ERROR&lt;/li>
&lt;li>90 - CLIENT_ERROR&lt;/li>
&lt;li>100 - SERVER_THREADPOOL_EXHAUSTED_ERROR&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Request ID (64 bits)&lt;/p>
&lt;p>标识唯一请求。类型为long。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Data Length (32 bits)&lt;/p>
&lt;p>序列化后的内容长度（可变部分），按字节计数。int类型。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Variable Part&lt;/p>
&lt;p>被特定的序列化类型（由序列化 ID 标识）序列化后，每个部分都是一个 byte [] 或者 byte&lt;/p>
&lt;ul>
&lt;li>如果是请求包 ( Req/Res = 1)，则每个部分依次为：
&lt;ul>
&lt;li>Dubbo version&lt;/li>
&lt;li>Service name&lt;/li>
&lt;li>Service version&lt;/li>
&lt;li>Method name&lt;/li>
&lt;li>Method parameter types&lt;/li>
&lt;li>Method arguments&lt;/li>
&lt;li>Attachments&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果是响应包（Req/Res = 0），则每个部分依次为：
&lt;ul>
&lt;li>返回值类型(byte)，标识从服务器端返回的值类型：
&lt;ul>
&lt;li>返回空值：RESPONSE_NULL_VALUE 2&lt;/li>
&lt;li>正常响应值： RESPONSE_VALUE 1&lt;/li>
&lt;li>异常：RESPONSE_WITH_EXCEPTION 0&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>返回值：从服务端返回的响应bytes&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>注意：&lt;/strong> 对于(Variable Part)变长部分，当前版本的Dubbo 框架使用json序列化时，在每部分内容间额外增加了换行符作为分隔，请在Variable Part的每个part后额外增加换行符， 如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Dubbo version bytes (换行符)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Service name bytes (换行符)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="线程派发模型">线程派发模型&lt;/h3>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/dev/dubbo-protocol.jpg" alt="/dev-guide/images/dubbo-protocol.jpg">&lt;/p>
&lt;ul>
&lt;li>Dispather: &lt;code>all&lt;/code>, &lt;code>direct&lt;/code>, &lt;code>message&lt;/code>, &lt;code>execution&lt;/code>, &lt;code>connection&lt;/code>&lt;/li>
&lt;li>ThreadPool: &lt;code>fixed&lt;/code>, &lt;code>cached&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>即：&lt;code>&amp;lt;dubbo:service regisrty=&amp;quot;N/A&amp;quot; /&amp;gt;&lt;/code> 或者 &lt;code>&amp;lt;dubbo:registry address=&amp;quot;N/A&amp;quot; /&amp;gt;&lt;/code>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>即: &lt;code>&amp;lt;dubbo:registry address=&amp;quot;zookeeper://10.20.153.10:2181&amp;quot; /&amp;gt;&lt;/code>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>即：&lt;code>&amp;lt;dubbo:reference url=&amp;quot;dubbo://service-host/com.foo.FooService?version=1.0.0&amp;quot; /&amp;gt;&lt;/code>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>即：&lt;code>&amp;lt;dubbo:registry address=&amp;quot;zookeeper://10.20.153.10:2181&amp;quot; /&amp;gt;&lt;/code>&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5">
&lt;p>&lt;code>DubboInvoker&lt;/code>、 &lt;code>HessianRpcInvoker&lt;/code>、 &lt;code>InjvmInvoker&lt;/code>、 &lt;code>RmiInvoker&lt;/code>、 &lt;code>WebServiceInvoker&lt;/code> 中的任何一个&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Docsv2.7: SPI 扩展实现</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/</guid><description>
&lt;p>SPI 扩展接口仅用于系统集成，或 Contributor 扩展功能插件。&lt;/p></description></item><item><title>Docsv2.7: 设计原则</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/principals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/principals/</guid><description>
&lt;p>本章节的设计原则摘录自梁飞在 javaeye 上发表的系列文章。&lt;/p></description></item><item><title>Docsv2.7: 公共契约</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/contract/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/contract/</guid><description>
&lt;h2 id="url">URL&lt;/h2>
&lt;ul>
&lt;li>所有扩展点参数都包含 URL 参数，URL 作为上下文信息贯穿整个扩展点设计体系。&lt;/li>
&lt;li>URL 采用标准格式：&lt;code>protocol://username:password@host:port/path?key=value&amp;amp;key=value&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="日志">日志&lt;/h2>
&lt;ul>
&lt;li>如果不可恢复或需要报警，打印 ERROR 日志。&lt;/li>
&lt;li>如果可恢复异常，或瞬时的状态不一致，打印 WARN 日志。&lt;/li>
&lt;li>正常运行时的中间状态提示，打印 INFO 日志。&lt;/li>
&lt;/ul></description></item><item><title>Docsv2.7: Dubbo 源代码分析</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/</guid><description>
&lt;p>这篇文档的目标读者是对 dubbo 源码、设计有兴趣的，或者有意愿加入 dubbo 开发的人群。主要通过源代码的分析让读者对 Dubbo 有更深入的理解。&lt;/p></description></item><item><title>Docsv2.7: 版本管理</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/release/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/release/</guid><description>
&lt;p>&lt;strong>新功能的开发&lt;/strong> 和 &lt;strong>稳定性的提高&lt;/strong> 对产品都很重要。但是添加新功能会影响稳定性，Dubbo 使用如下的版本开发模式来保障两者。&lt;/p>
&lt;h2 id="2-个版本并行开发">2 个版本并行开发&lt;/h2>
&lt;ul>
&lt;li>BugFix 版本：低版本，比如 &lt;code>2.4.x&lt;/code>。是 GA 版本，线上使用的版本，只会 BugFix，升级第三位版本号。&lt;/li>
&lt;li>新功能版本：高版本，比如 &lt;code>2.5.x&lt;/code>。加新功能的版本，会给对新功能有需求的应用试用。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>2.5.x&lt;/code> 的新功能基本稳定后，进入 &lt;code>2.5.x&lt;/code> 试用阶段。找足够多的应用试用 &lt;code>2.5.x&lt;/code> 版本。&lt;/p>
&lt;p>在 &lt;code>2.5.x&lt;/code> 够稳定后：&lt;/p>
&lt;ul>
&lt;li>&lt;code>2.5.x&lt;/code> 成为 GA 版本，只 BugFix，推广使用此版本。如果版本可用，可以推进应用在期望的时间点内升级到 GA 版本。&lt;/li>
&lt;li>&lt;code>2.4.x&lt;/code> 不再开发，应用碰到 Bug 让直接升级。（这个称为“夕阳条款”）&lt;/li>
&lt;li>从 &lt;code>2.5.x&lt;/code> 拉成分支 &lt;code>2.6.0&lt;/code>，作为新功能开发版本。&lt;/li>
&lt;/ul>
&lt;h2 id="优势">优势&lt;/h2>
&lt;ul>
&lt;li>保证 GA 版本是稳定的！因为：
&lt;ul>
&lt;li>只会作 BugFix&lt;/li>
&lt;li>成为 GA 版本前有试用阶段&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>新功能可以在高版本中快速响应，并让应用能试用新功能。&lt;/li>
&lt;li>不会版本过多，导致开发和维护成本剧增&lt;/li>
&lt;/ul>
&lt;h2 id="用户要配合的职责">用户要配合的职责&lt;/h2>
&lt;p>由于开发只会 BugFix GA 版本，所以用户需要积极跟进升级到 GA 版本，以 Fix 发现的问题。&lt;/p>
&lt;p>定期升级版本给用户带来了不安。这是一个假命题，说明如下：&lt;/p>
&lt;ul>
&lt;li>GA 经过一个试用阶段保持稳定。&lt;/li>
&lt;li>GA 版本有 Bug 会火速 Fix&lt;/li>
&lt;li>相对出问题才升级到 GA 版本（可能跨了多个版本）定期升级平摊风险（类似小步快跑）。经历过周期长的大项目的同学会有这样的经历，三方库版本长时间不升级，结果出了问题不得不升级到新版本（跨了多个版本）风险巨大。&lt;/li>
&lt;/ul></description></item><item><title>Docsv2.7: 检查列表</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/checklist/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/checklist/</guid><description>
&lt;h2 id="发布前-checklist">发布前 checklist&lt;/h2>
&lt;ul>
&lt;li>jira ticket 过一遍&lt;/li>
&lt;li>svn change list&lt;/li>
&lt;li>ticket 关联 code&lt;/li>
&lt;li>test code&lt;/li>
&lt;li>find bugs&lt;/li>
&lt;/ul>
&lt;h2 id="修复时-checklist">修复时 checklist&lt;/h2>
&lt;ul>
&lt;li>修复代码前先建 ticket&lt;/li>
&lt;li>修复代码前先写测试用例&lt;/li>
&lt;li>需要伙伴检查&lt;/li>
&lt;li>test code(正常流程/异常流程)&lt;/li>
&lt;li>讲一遍逻辑&lt;/li>
&lt;li>契约文档化&lt;/li>
&lt;li>以上内容都写到ticket的评论上&lt;/li>
&lt;li>代码注释写清楚，用中文无妨&lt;/li>
&lt;li>每个版本要有 owner，确保 scope 和 check&lt;/li>
&lt;/ul>
&lt;h2 id="partner-check">Partner Check&lt;/h2>
&lt;ul>
&lt;li>Partner 以用户的方式运行一下功能&lt;/li>
&lt;li>Partner 发现问题、添加测试（集成测试）直到不再复现；Owner 完成实现。（保证两方在Partner Check上的时间投入）&lt;/li>
&lt;li>Owner 向 Partner 讲述一遍实现。&lt;/li>
&lt;/ul></description></item><item><title>Docsv2.7: 编码约定</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/coding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/coding/</guid><description>
&lt;h2 id="代码风格">代码风格&lt;/h2>
&lt;p>Dubbo 的源代码和 JavaDoc 遵循以下的规范：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.oracle.com/technetwork/java/codeconvtoc-136057.html">Code Conventions for the Java Programming Language&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.oracle.com/technetwork/java/javase/documentation/index-137868.html">How to Write Doc Comments for the Javadoc Tool&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="异常和日志">异常和日志&lt;/h2>
&lt;ul>
&lt;li>尽可能携带完整的上下文信息，比如出错原因，出错的机器地址，调用对方的地址，连的注册中心地址，使用 Dubbo 的版本等。&lt;/li>
&lt;li>尽量将直接原因写在最前面，所有上下文信息，在原因后用键值对显示。&lt;/li>
&lt;li>抛出异常的地方不用打印日志，由最终处理异常者决定打印日志的级别，吃掉异常必需打印日志。&lt;/li>
&lt;li>打印 &lt;code>ERROR&lt;/code> 日志表示需要报警，打印 &lt;code>WARN&lt;/code> 日志表示可以自动恢复，打印 &lt;code>INFO&lt;/code> 表示正常信息或完全不影响运行。&lt;/li>
&lt;li>建议应用方在监控中心配置 &lt;code>ERROR&lt;/code> 日志实时报警，&lt;code>WARN&lt;/code> 日志每周汇总发送通知。&lt;/li>
&lt;li>&lt;code>RpcException&lt;/code> 是 Dubbo 对外的唯一异常类型，所有内部异常，如果要抛出给用户，必须转为 &lt;code>RpcException&lt;/code>。&lt;/li>
&lt;li>&lt;code>RpcException&lt;/code> 不能有子类型，所有类型信息用 ErrorCode 标识，以便保持兼容。&lt;/li>
&lt;/ul>
&lt;h2 id="配置和-url">配置和 URL&lt;/h2>
&lt;ul>
&lt;li>配置对象属性首字母小写，多个单词用驼峰命名 &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。&lt;/li>
&lt;li>配置属性全部用小写，多个单词用&amp;quot;-&amp;ldquo;号分隔 &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>。&lt;/li>
&lt;li>URL参数全部用小写，多个单词用&amp;rdquo;.&amp;ldquo;号分隔 &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>。&lt;/li>
&lt;li>尽可能用 URL 传参，不要自定义 Map 或其它上下文格式，配置信息也转成 URL 格式使用。&lt;/li>
&lt;li>尽量减少 URL 嵌套，保持 URL 的简洁性。&lt;/li>
&lt;/ul>
&lt;h2 id="单元和集成测试">单元和集成测试&lt;/h2>
&lt;ul>
&lt;li>单元测试统一用 JUnit 和 EasyMock，集成测试用 TestNG，数据库测试用 DBUnit。&lt;/li>
&lt;li>保持单元测试用例的运行速度，不要将性能和大的集成用例放在单元测试中。&lt;/li>
&lt;li>保持单元测试的每个用例都用 &lt;code>try...finally&lt;/code> 或 &lt;code>tearDown&lt;/code> 释放资源。&lt;/li>
&lt;li>减少 while 循环等待结果的测试用例，对定时器和网络的测试，用以将定时器中的逻辑抽为方法测试。&lt;/li>
&lt;li>对于容错行为的测试，比如 failsafe 的测试，统一用 &lt;code>LogUtil&lt;/code> 断言日志输出。&lt;/li>
&lt;/ul>
&lt;h2 id="扩展点基类与-aop">扩展点基类与 AOP&lt;/h2>
&lt;ul>
&lt;li>AOP 类都命名为 &lt;code>XxxWrapper&lt;/code>，基类都命名为 &lt;code>AbstractXxx&lt;/code>。&lt;/li>
&lt;li>扩展点之间的组合将关系由 AOP 完成，&lt;code>ExtensionLoader&lt;/code> 只负载加载扩展点，包括 AOP 扩展。&lt;/li>
&lt;li>尽量采用 IoC 注入扩展点之间的依赖，不要直接依赖 &lt;code>ExtensionLoader&lt;/code> 的工厂方法。&lt;/li>
&lt;li>尽量采用 AOP 实现扩展点的通用行为，而不要用基类，比如负载均衡之前的 &lt;code>isAvailable&lt;/code> 检查，它是独立于负载均衡之外的，不需要检查的是URL参数关闭。&lt;/li>
&lt;li>对多种相似类型的抽象，用基类实现，比如 RMI, Hessian 等第三方协议都已生成了接口代理，只需将将接口代理转成 &lt;code>Invoker&lt;/code> 即可完成桥接，它们可以用公共基类实现此逻辑。&lt;/li>
&lt;li>基类也是 SPI 的一部分，每个扩展点都应该有方便使用的基类支持。&lt;/li>
&lt;/ul>
&lt;h2 id="模块与分包">模块与分包&lt;/h2>
&lt;ul>
&lt;li>基于复用度分包，总是一起使用的放在同一包下，将接口和基类分成独立模块，大的实现也使用独立模块。&lt;/li>
&lt;li>所有接口都放在模块的根包下，基类放在 support 子包下，不同实现用放在以扩展点名字命名的子包下。&lt;/li>
&lt;li>尽量保持子包依赖父包，而不要反向。&lt;/li>
&lt;/ul>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Java 约定&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Spring 约定&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>Dubbo 约定&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Docsv2.7: 坏味道</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/code-smell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/code-smell/</guid><description>
&lt;h2 id="url-转换">URL 转换&lt;/h2>
&lt;h3 id="1-点对点暴露和引用服务">1. 点对点暴露和引用服务&lt;/h3>
&lt;p>直接暴露服务：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>EXPORT(dubbo://provider-address/com.xxx.XxxService?version=1.0.0&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>点对点直连服务：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>REFER(dubbo://provider-address/com.xxx.XxxService?version=1.0.0)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2-通过注册中心暴露服务">2. 通过注册中心暴露服务&lt;/h3>
&lt;p>向注册中心暴露服务：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>EXPORT(registry:&lt;span style="color:#719e07">//&lt;/span>registry&lt;span style="color:#719e07">-&lt;/span>address&lt;span style="color:#719e07">/&lt;/span>org&lt;span style="color:#719e07">.&lt;/span>apache&lt;span style="color:#719e07">.&lt;/span>dubbo&lt;span style="color:#719e07">.&lt;/span>registry&lt;span style="color:#719e07">.&lt;/span>RegistrySerevice?registry&lt;span style="color:#719e07">=&lt;/span>dubbo&lt;span style="color:#719e07">&amp;amp;&lt;/span>&lt;span style="color:#719e07">export&lt;/span>&lt;span style="color:#719e07">=&lt;/span>ENCODE(dubbo:&lt;span style="color:#719e07">//&lt;/span>provider&lt;span style="color:#719e07">-&lt;/span>address&lt;span style="color:#719e07">/&lt;/span>com&lt;span style="color:#719e07">.&lt;/span>xxx&lt;span style="color:#719e07">.&lt;/span>XxxService?version&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">1.0&lt;/span>&lt;span style="color:#719e07">.&lt;/span>&lt;span style="color:#2aa198">0&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>获取注册中心：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>url.setProtocol(url.getParameter(&amp;#34;registry&amp;#34;, &amp;#34;dubbo&amp;#34;))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GETREGISTRY(dubbo://registry-address/org.apache.dubbo.registry.RegistrySerevice)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注册服务地址：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>url&lt;span style="color:#719e07">.&lt;/span>getParameterAndDecoded(&lt;span style="color:#2aa198">&amp;#34;export&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>REGISTER(dubbo:&lt;span style="color:#719e07">//&lt;/span>provider&lt;span style="color:#719e07">-&lt;/span>address&lt;span style="color:#719e07">/&lt;/span>com&lt;span style="color:#719e07">.&lt;/span>xxx&lt;span style="color:#719e07">.&lt;/span>XxxService?version&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">1.0&lt;/span>&lt;span style="color:#719e07">.&lt;/span>&lt;span style="color:#2aa198">0&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="3-通过注册中心引用服务">3. 通过注册中心引用服务&lt;/h3>
&lt;p>从注册中心订阅服务：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>REFER(registry://registry-address/org.apache.dubbo.registry.RegistrySerevice?registry=dubbo&amp;amp;refer=ENCODE(version=1.0.0))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>获取注册中心：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>url.setProtocol(url.getParameter(&amp;#34;registry&amp;#34;, &amp;#34;dubbo&amp;#34;))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GETREGISTRY(dubbo://registry-address/org.apache.dubbo.registry.RegistrySerevice)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>订阅服务地址：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>url.addParameters(url.getParameterAndDecoded(&amp;#34;refer&amp;#34;))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SUBSCRIBE(dubbo://registry-address/com.xxx.XxxService?version=1.0.0)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通知服务地址：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>url.addParameters(url.getParameterAndDecoded(&amp;#34;refer&amp;#34;))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NOTIFY(dubbo://provider-address/com.xxx.XxxService?version=1.0.0)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="4-注册中心推送路由规则">4. 注册中心推送路由规则&lt;/h3>
&lt;p>注册中心路由规则推送：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>NOTIFY(route://registry-address/com.xxx.XxxService?router=script&amp;amp;type=js&amp;amp;rule=ENCODE(function{...}))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>获取路由器：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>url.setProtocol(url.getParameter(&amp;#34;router&amp;#34;, &amp;#34;script&amp;#34;))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GETROUTE(script://registry-address/com.xxx.XxxService?type=js&amp;amp;rule=ENCODE(function{...}))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="5-从文件加载路由规则">5. 从文件加载路由规则&lt;/h3>
&lt;p>从文件加载路由规则：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>GETROUTE(file://path/file.js?router=script)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>获取路由器：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>url.setProtocol(url.getParameter(&amp;#34;router&amp;#34;, &amp;#34;script&amp;#34;)).addParameter(&amp;#34;type&amp;#34;, SUFFIX(file)).addParameter(&amp;#34;rule&amp;#34;, READ(file))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GETROUTE(script://path/file.js?type=js&amp;amp;rule=ENCODE(function{...}))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="调用参数">调用参数&lt;/h2>
&lt;ul>
&lt;li>path 服务路径&lt;/li>
&lt;li>group 服务分组&lt;/li>
&lt;li>version 服务版本&lt;/li>
&lt;li>dubbo 使用的 dubbo 版本&lt;/li>
&lt;li>token 验证令牌&lt;/li>
&lt;li>timeout 调用超时&lt;/li>
&lt;/ul>
&lt;h2 id="扩展点的加载">扩展点的加载&lt;/h2>
&lt;h3 id="1-自适应扩展点">1. 自适应扩展点&lt;/h3>
&lt;p>ExtensionLoader 加载扩展点时，会检查扩展点的属性（通过set方法判断），如该属性是扩展点类型，则会注入扩展点对象。因为注入时不能确定使用哪个扩展点（在使用时确定），所以注入的是一个自适应扩展（一个代理）。自适应扩展点调用时，选取一个真正的扩展点，并代理到其上完成调用。Dubbo 是根据调用方法参数（上面有调用哪个扩展点的信息）来选取一个真正的扩展点。&lt;/p>
&lt;p>在 Dubbo 给定所有的扩展点上调用都有 URL 参数（整个扩展点网的上下文信息）。自适应扩展即是从 URL 确定要调用哪个扩展点实现。URL 哪个 Key 的 Value 用来确定使用哪个扩展点，这个信息通过的 &lt;code>@Adaptive&lt;/code> 注解在方法上说明。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Extension&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">Car&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Adaptive&lt;/span>({&lt;span style="color:#2aa198">&amp;#34;http://10.20.160.198/wiki/display/dubbo/car.type&amp;#34;&lt;/span>, &lt;span style="color:#2aa198">&amp;#34;http://10.20.160.198/wiki/display/dubbo/transport.type&amp;#34;&lt;/span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">run&lt;/span>(URL url, Type1 arg1, Type2 arg2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于自适应扩展点的上面的约定，ExtensionLoader 会为扩展点自动生成自适应扩展点类(通过字节码)，并将其实例注入。&lt;/p>
&lt;p>ExtensionLoader 生成的自适应扩展点类如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">package&lt;/span> &amp;lt;扩展点接口所在包&lt;span style="color:#719e07">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &amp;lt;&lt;span style="color:#268bd2">扩展点接口名&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>$Adpative &lt;span style="color:#268bd2">implements&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>扩展点接口&lt;span style="color:#719e07">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>有&lt;span style="color:#268bd2">@Adaptive注解的接口方法&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>(&lt;span style="color:#719e07">&amp;lt;&lt;/span>方法参数&lt;span style="color:#719e07">&amp;gt;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span>(是否有URL类型方法参数&lt;span style="color:#719e07">?&lt;/span>) 使用该URL参数
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">else&lt;/span> &lt;span style="color:#268bd2">if&lt;/span>(是否有方法类型上有URL属性) 使用该URL属性
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> # &lt;span style="color:#719e07">&amp;lt;&lt;/span>&lt;span style="color:#719e07">else&lt;/span> 在加载扩展点生成自适应扩展点类时抛异常，即加载扩展点失败！&lt;span style="color:#719e07">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span>(获取的URL &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#cb4b16">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalArgumentException(&lt;span style="color:#2aa198">&amp;#34;url == null&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 根据&lt;span style="color:#268bd2">@Adaptive注解上声明的Key的顺序&lt;/span>，从URL获致Value，作为实际扩展点名。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 如URL没有Value，则使用缺省扩展点实现。如没有扩展点， &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> IllegalStateException(&lt;span style="color:#2aa198">&amp;#34;Fail to get extension&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 在扩展点实现调用该方法，并返回结果。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#719e07">&amp;lt;&lt;/span>有&lt;span style="color:#268bd2">@Adaptive注解的接口方法&lt;/span>&lt;span style="color:#719e07">&amp;gt;&lt;/span>(&lt;span style="color:#719e07">&amp;lt;&lt;/span>方法参数&lt;span style="color:#719e07">&amp;gt;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">throw&lt;/span> &lt;span style="color:#719e07">new&lt;/span> UnsupportedOperationException(&lt;span style="color:#2aa198">&amp;#34;is not adaptive method!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>@Adaptive&lt;/code> 注解使用如下：&lt;/p>
&lt;p>如果 URL 这些 Key 都没有 Value，使用缺省的扩展（在接口的 Default 中设定的值）。比如，String[] {&amp;ldquo;key1&amp;rdquo;, &amp;ldquo;key2&amp;rdquo;}，表示先在 URL 上找 key1 的 Value 作为要 Adapt 成的 Extension 名；key1 没有 Value，则使用 key2 的 Value 作为要 Adapt 成的 Extension 名。 key2 没有 Value，使用缺省的扩展。如果没有设定缺省扩展，则方法调用会抛出 IllegalStateException。如果不设置则缺省使用 Extension 接口类名的点分隔小写字串。即对于 Extension 接口 &lt;code>org.apache.dubbo.xxx.YyyInvokerWrapper&lt;/code> 的缺省值为 &lt;code>new String[] {&amp;quot;yyy.invoker.wrapper&amp;quot;}&lt;/code>&lt;/p>
&lt;h2 id="callback-功能">Callback 功能&lt;/h2>
&lt;h3 id="1-参数回调">1. 参数回调&lt;/h3>
&lt;p>主要原理: 在一个 consumer-&amp;gt;provider 的长连接上，自动在 Consumer 端暴露一个服务（实现方法参数上声明的接口A），provider 端便可反向调用到 consumer 端的接口实例。&lt;/p>
&lt;p>实现细节：&lt;/p>
&lt;ul>
&lt;li>为了在传输时能够对回调接口实例进行转换，自动暴露与自动引用目前在 DubboCodec 中实现。此处需要考虑将此逻辑与 codec 逻辑分离。&lt;/li>
&lt;li>在根据 invocation 信息获取 exporter 时，需要判断是否是回调，如果是回调，会从 attachments 中取得回调服务实例的 id，在获取 exporter，此处用于 consumer 端可以对同一个 callback 接口做不同的实现。&lt;/li>
&lt;/ul>
&lt;h3 id="2-事件通知">2. 事件通知&lt;/h3>
&lt;p>主要原理：Consumer 在 invoke 方法时，判断如果有配置 onreturn/onerror&amp;hellip; 则将 onreturn 对应的参数值(实例方法)加入到异步调用的回调列表中。&lt;/p>
&lt;p>实现细节：参数的传递采用 URL，但 URL 中没有支持 string-object，所以将实例方法存储在 staticMap 中，此处实现需要进行改造。&lt;/p>
&lt;h2 id="lazy连接">Lazy连接&lt;/h2>
&lt;p>DubboProtocol 特有功能，默认关闭。&lt;/p>
&lt;p>当客户端与服务端创建代理时，暂不建立 tcp 长连接，当有数据请求时再做连接初始化。&lt;/p>
&lt;p>此项功能自动关闭连接重试功能，开启发送重试功能（即发送数据时如果连接已断开，尝试重新建立连接）&lt;/p>
&lt;h2 id="共享连接">共享连接&lt;/h2>
&lt;p>DubboProtocol 特有功能，默认开启。&lt;/p>
&lt;p>JVM A 暴露了多个服务，JVM B 引用了 A 中的多个服务，共享连接是说 A 与 B 多个服务调用是通过同一个 TCP 长连接进行数据传输，已达到减少服务端连接数的目的.&lt;/p>
&lt;p>实现细节：对于同一个地址由于使用了共享连接，那 invoker 的 destroy 就需要特别注意，一方面要满足对同一个地址 refer 的 invoker 全部 destroy 后，连接需要关闭，另一方面还需要注意如何避免部分 invoker destroy 时不能关闭连接。在实现中采用了引用计数的方案，但为了防范，在连接关闭时，重新建立了一个 Lazy connection (称为幽灵连接), 用于当出现异常场景时，避免影响业务逻辑的正常调用.&lt;/p>
&lt;h2 id="sticky-策略">sticky 策略&lt;/h2>
&lt;p>有多个服务提供者的情况下，配置了 sticky 后，在提供者可用的情况下，调用会继续发送到上一次的服务提供者。sticky 策略默认开启了连接的 lazy 选项, 用于避免开启无用的连接.&lt;/p>
&lt;h2 id="服务提供者选择逻辑">服务提供者选择逻辑&lt;/h2>
&lt;ol start="0">
&lt;li>存在多个服务提供者的情况下，首先根据 Loadbalance 进行选择，如果选择的 provider 处于可用状态，则进行后续调用&lt;/li>
&lt;li>如果第一步选择的服务提供者不可用，则从剩余服务提供者列表中继续选择，如果可用，进行后续调用&lt;/li>
&lt;li>如果所有的服务提供者都不可用，重新遍历整个列表（优先从没有选过的列表中选择），判断是否有可用的服务提供者（选择过程中，不可用的服务提供者可能会恢复到可用状态），如果有，则进行后续调用&lt;/li>
&lt;li>如果第三步没有选择出可用的服务提供者，会选第一步选出的 invoker 中的下一个（如果不是最后一个），避免碰撞。&lt;/li>
&lt;/ol></description></item><item><title>Docsv2.7: 技术兼容性测试</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/tck/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/tck/</guid><description>
&lt;p>Dubbo 的协议，通讯，序列化，注册中心，负载均策等扩展点，都有多种可选策略，以应对不同应用场景，而我们的测试用例很分散，当用户自己需要加一种新的实现时，总是不确定能否满足扩展点的完整契约。&lt;/p>
&lt;p>所以，我们需要对核心扩展点写 &lt;a href="http://en.wikipedia.org/wiki/Technology_Compatibility_Kit">TCK&lt;/a> (Technology Compatibility Kit)，用户增加一种扩展实现，只需通过 TCK，即可确保与框架的其它部分兼容运行，可以有效提高整体健壮性，也方便第三方扩展者接入，加速开源社区的成熟。&lt;/p>
&lt;p>开源社区的行知同学已着手研究这一块，他的初步想法是借鉴 JBoss 的 CDI-TCK，做一个 Dubbo 的 TCK 基础框架，在此之上实现 Dubbo 的扩展点 TCK 用例。&lt;/p>
&lt;p>参见：http://docs.jboss.org/cdi/tck/reference/1.0.1-Final/html/introduction.html&lt;/p>
&lt;p>如果大家有兴趣，也可以一起研究，和行知一块讨论。&lt;/p>
&lt;h4 id="protocol-tck">Protocol TCK&lt;/h4>
&lt;blockquote>
&lt;p>TODO&lt;/p>
&lt;/blockquote>
&lt;h4 id="registry-tck">Registry TCK&lt;/h4>
&lt;blockquote>
&lt;p>TODO&lt;/p>
&lt;/blockquote></description></item></channel></rss>