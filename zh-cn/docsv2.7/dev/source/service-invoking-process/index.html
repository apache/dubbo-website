<!doctype html><html lang=zh-cn class=no-js><head><meta name=ROBOTS content="INDEX, FOLLOW"><link rel=canonical href=https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/service-invoking-process/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.122.0"><link rel="shortcut icon" type=image/png href=/imgs/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><title>服务调用过程 | Apache Dubbo</title><meta property="og:title" content="服务调用过程">
<meta property="og:description" content="本文介绍了服务调用过程的原理和实现细节"><meta property="og:type" content="article"><meta property="og:url" content="https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/service-invoking-process/"><meta property="article:section" content="docsv2.7"><meta property="article:modified_time" content="2023-03-01T09:48:32+08:00"><meta itemprop=name content="服务调用过程"><meta itemprop=description content="本文介绍了服务调用过程的原理和实现细节"><meta itemprop=dateModified content="2023-03-01T09:48:32+08:00"><meta itemprop=wordCount content="5730"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="服务调用过程"><meta name=twitter:description content="本文介绍了服务调用过程的原理和实现细节"><script async src="https://www.googletagmanager.com/gtag/js?id=G-1TFHM5YBH0"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-1TFHM5YBH0",{anonymize_ip:!1})}</script><link rel=preload href=/scss/main.min.9e6561cc0361d4774cd6dea1f797b4d79df2a97001c1d51e86b490fa04cfc749.css as=style><link href=/scss/main.min.9e6561cc0361d4774cd6dea1f797b4d79df2a97001c1d51e86b490fa04cfc749.css rel=stylesheet integrity><script src=/js/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@docsearch/css@3><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="本文介绍了服务调用过程的原理和实现细节"><meta property="og:description" content="本文介绍了服务调用过程的原理和实现细节"><meta name=twitter:description content="本文介绍了服务调用过程的原理和实现细节"><meta property="og:url" content="https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/service-invoking-process/"><meta property="og:title" content="服务调用过程"><meta name=twitter:title content="服务调用过程"><meta name=twitter:image:alt content="Apache Dubbo"><meta property="og:type" content="article"><meta name=viewport content="width=device-width"><script async defer src=/js/github-buttons.js></script><link href=/css/community.css rel=stylesheet><link href=/css/contactus.css rel=stylesheet><link href=/css/language.css rel=stylesheet><script src=/js/script.js></script></head><body class="td-page td-documentation"><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/zh-cn/><span class=navbar-logo></span><span class="text-uppercase font-weight-bold">Apache Dubbo</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/zh-cn/overview/home/><span>文档</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/zh-cn/blog/><span>博客</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/zh-cn/download/><span>版本发布</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/zh-cn/contact/><span>联系社区</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=https://start.dubbo.apache.org/bootstrap.html target=_blank><span>Initializer</span><i class='fas fa-external-link-alt'></i></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/zh-cn/github/><span>Github</span><i class='fa-brands fa-github'></i></a></li><li class="nav-item dropdown d-lg-block"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/en/>English</a></div></li><li class="nav-item dropdown d-lg-block"><div class="nav-item d-none d-lg-block"><div id=docsearch></div></div></li></ul></div></nav><section class="header-hero text-white pb-0 light-text"></section></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-md-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"><script>$(function(){$("#td-section-nav a").removeClass("active"),$("#td-section-nav #m-zh-cndocsv27devsourceservice-invoking-process").addClass("active"),$("#td-section-nav #m-zh-cndocsv27devsourceservice-invoking-process-li span").addClass("td-sidebar-nav-active-item"),$("#td-section-nav #m-zh-cndocsv27devsourceservice-invoking-process").parents("li").addClass("active-path"),$("#td-section-nav li.active-path").addClass("show"),$("#td-section-nav li.active-path").children("input").prop("checked",!0),$("#td-section-nav #m-zh-cndocsv27devsourceservice-invoking-process-li").siblings("li").addClass("show"),$("#td-section-nav #m-zh-cndocsv27devsourceservice-invoking-process-li").children("ul").children("li").addClass("show"),$("#td-sidebar-menu").toggleClass("d-none")})</script><div id=td-sidebar-menu class="td-sidebar__inner d-none"><div id=content-mobile><form class="td-sidebar__search d-flex align-items-center"><div id=docsearch></div><button class="btn btn-link td-sidebar__toggle d-md-none p-0 ml-3 fas fa-bars" type=button data-toggle=collapse data-target=#td-section-nav aria-controls=td-docs-nav aria-expanded=false aria-label="Toggle section navigation"></button></form></div><div id=content-desktop></div><nav class="collapse td-sidebar-nav foldable-nav" id=td-section-nav><ul class="td-sidebar-nav__section pr-md-3 ul-0"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27-li><ul class=ul-1><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27user-li><input type=checkbox id=m-zh-cndocsv27user-check>
<label for=m-zh-cndocsv27user-check><a href=/zh-cn/docsv2.7/user/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27user><span>用户文档</span></a></label><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userpreface-li><input type=checkbox id=m-zh-cndocsv27userpreface-check>
<label for=m-zh-cndocsv27userpreface-check><a href=/zh-cn/docsv2.7/user/preface/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userpreface><span>入门介绍</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userprefacebackground-li><input type=checkbox id=m-zh-cndocsv27userprefacebackground-check>
<label for=m-zh-cndocsv27userprefacebackground-check><a href=/zh-cn/docsv2.7/user/preface/background/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userprefacebackground><span>背景</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userprefacerequirements-li><input type=checkbox id=m-zh-cndocsv27userprefacerequirements-check>
<label for=m-zh-cndocsv27userprefacerequirements-check><a href=/zh-cn/docsv2.7/user/preface/requirements/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userprefacerequirements><span>需求</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userprefacearchitecture-li><input type=checkbox id=m-zh-cndocsv27userprefacearchitecture-check>
<label for=m-zh-cndocsv27userprefacearchitecture-check><a href=/zh-cn/docsv2.7/user/preface/architecture/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userprefacearchitecture><span>架构</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userprefaceusage-li><input type=checkbox id=m-zh-cndocsv27userprefaceusage-check>
<label for=m-zh-cndocsv27userprefaceusage-check><a href=/zh-cn/docsv2.7/user/preface/usage/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userprefaceusage><span>用法</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userquick-start-li><input type=checkbox id=m-zh-cndocsv27userquick-start-check>
<label for=m-zh-cndocsv27userquick-start-check><a href=/zh-cn/docsv2.7/user/quick-start/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userquick-start><span>快速开始</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userdependencies-li><input type=checkbox id=m-zh-cndocsv27userdependencies-check>
<label for=m-zh-cndocsv27userdependencies-check><a href=/zh-cn/docsv2.7/user/dependencies/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userdependencies><span>基本依赖</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27usermaturity-li><input type=checkbox id=m-zh-cndocsv27usermaturity-check>
<label for=m-zh-cndocsv27usermaturity-check><a href=/zh-cn/docsv2.7/user/maturity/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27usermaturity><span>成熟度</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userconfiguration-li><input type=checkbox id=m-zh-cndocsv27userconfiguration-check>
<label for=m-zh-cndocsv27userconfiguration-check><a href=/zh-cn/docsv2.7/user/configuration/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userconfiguration><span>配置手册</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userconfigurationxml-li><input type=checkbox id=m-zh-cndocsv27userconfigurationxml-check>
<label for=m-zh-cndocsv27userconfigurationxml-check><a href=/zh-cn/docsv2.7/user/configuration/xml/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userconfigurationxml><span>XML 配置</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userconfigurationconfig-center-li><input type=checkbox id=m-zh-cndocsv27userconfigurationconfig-center-check>
<label for=m-zh-cndocsv27userconfigurationconfig-center-check><a href=/zh-cn/docsv2.7/user/configuration/config-center/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userconfigurationconfig-center><span>动态配置中心</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userconfigurationproperties-li><input type=checkbox id=m-zh-cndocsv27userconfigurationproperties-check>
<label for=m-zh-cndocsv27userconfigurationproperties-check><a href=/zh-cn/docsv2.7/user/configuration/properties/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userconfigurationproperties><span>属性配置</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userconfigurationenvironment-variables-li><input type=checkbox id=m-zh-cndocsv27userconfigurationenvironment-variables-check>
<label for=m-zh-cndocsv27userconfigurationenvironment-variables-check><a href=/zh-cn/docsv2.7/user/configuration/environment-variables/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userconfigurationenvironment-variables><span>自动加载环境变量</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userconfigurationapi-li><input type=checkbox id=m-zh-cndocsv27userconfigurationapi-check>
<label for=m-zh-cndocsv27userconfigurationapi-check><a href=/zh-cn/docsv2.7/user/configuration/api/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userconfigurationapi><span>API 配置</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userconfigurationannotation-li><input type=checkbox id=m-zh-cndocsv27userconfigurationannotation-check>
<label for=m-zh-cndocsv27userconfigurationannotation-check><a href=/zh-cn/docsv2.7/user/configuration/annotation/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userconfigurationannotation><span>注解配置</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userconfigurationconfiguration-load-process-li><input type=checkbox id=m-zh-cndocsv27userconfigurationconfiguration-load-process-check>
<label for=m-zh-cndocsv27userconfigurationconfiguration-load-process-check><a href=/zh-cn/docsv2.7/user/configuration/configuration-load-process/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userconfigurationconfiguration-load-process><span>配置加载流程</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userexamples-li><input type=checkbox id=m-zh-cndocsv27userexamples-check>
<label for=m-zh-cndocsv27userexamples-check><a href=/zh-cn/docsv2.7/user/examples/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userexamples><span>用法示例</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplese9878de8af95e6aca1e695b0e9858de7bdae-li><input type=checkbox id=m-zh-cndocsv27userexamplese9878de8af95e6aca1e695b0e9858de7bdae-check>
<label for=m-zh-cndocsv27userexamplese9878de8af95e6aca1e695b0e9858de7bdae-check><a href=/zh-cn/docsv2.7/user/examples/%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0%E9%85%8D%E7%BD%AE/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplese9878de8af95e6aca1e695b0e9858de7bdae><span>服务重试</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplespreflight-check-li><input type=checkbox id=m-zh-cndocsv27userexamplespreflight-check-check>
<label for=m-zh-cndocsv27userexamplespreflight-check-check><a href=/zh-cn/docsv2.7/user/examples/preflight-check/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplespreflight-check><span>启动时检查</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesfault-tolerent-strategy-li><input type=checkbox id=m-zh-cndocsv27userexamplesfault-tolerent-strategy-check>
<label for=m-zh-cndocsv27userexamplesfault-tolerent-strategy-check><a href=/zh-cn/docsv2.7/user/examples/fault-tolerent-strategy/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesfault-tolerent-strategy><span>集群容错</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesloadbalance-li><input type=checkbox id=m-zh-cndocsv27userexamplesloadbalance-check>
<label for=m-zh-cndocsv27userexamplesloadbalance-check><a href=/zh-cn/docsv2.7/user/examples/loadbalance/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesloadbalance><span>负载均衡</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesthread-model-li><input type=checkbox id=m-zh-cndocsv27userexamplesthread-model-check>
<label for=m-zh-cndocsv27userexamplesthread-model-check><a href=/zh-cn/docsv2.7/user/examples/thread-model/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesthread-model><span>线程模型</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesexplicit-target-li><input type=checkbox id=m-zh-cndocsv27userexamplesexplicit-target-check>
<label for=m-zh-cndocsv27userexamplesexplicit-target-check><a href=/zh-cn/docsv2.7/user/examples/explicit-target/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesexplicit-target><span>直连提供者</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplessubscribe-only-li><input type=checkbox id=m-zh-cndocsv27userexamplessubscribe-only-check>
<label for=m-zh-cndocsv27userexamplessubscribe-only-check><a href=/zh-cn/docsv2.7/user/examples/subscribe-only/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplessubscribe-only><span>只订阅</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesmulti-protocols-li><input type=checkbox id=m-zh-cndocsv27userexamplesmulti-protocols-check>
<label for=m-zh-cndocsv27userexamplesmulti-protocols-check><a href=/zh-cn/docsv2.7/user/examples/multi-protocols/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesmulti-protocols><span>多协议</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesmulti-registry-li><input type=checkbox id=m-zh-cndocsv27userexamplesmulti-registry-check>
<label for=m-zh-cndocsv27userexamplesmulti-registry-check><a href=/zh-cn/docsv2.7/user/examples/multi-registry/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesmulti-registry><span>多注册中心</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesservice-group-li><input type=checkbox id=m-zh-cndocsv27userexamplesservice-group-check>
<label for=m-zh-cndocsv27userexamplesservice-group-check><a href=/zh-cn/docsv2.7/user/examples/service-group/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesservice-group><span>服务分组</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesstatic-service-li><input type=checkbox id=m-zh-cndocsv27userexamplesstatic-service-check>
<label for=m-zh-cndocsv27userexamplesstatic-service-check><a href=/zh-cn/docsv2.7/user/examples/static-service/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesstatic-service><span>静态服务</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesmulti-versions-li><input type=checkbox id=m-zh-cndocsv27userexamplesmulti-versions-check>
<label for=m-zh-cndocsv27userexamplesmulti-versions-check><a href=/zh-cn/docsv2.7/user/examples/multi-versions/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesmulti-versions><span>多版本</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesgroup-merger-li><input type=checkbox id=m-zh-cndocsv27userexamplesgroup-merger-check>
<label for=m-zh-cndocsv27userexamplesgroup-merger-check><a href=/zh-cn/docsv2.7/user/examples/group-merger/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesgroup-merger><span>分组聚合</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesparameter-validation-li><input type=checkbox id=m-zh-cndocsv27userexamplesparameter-validation-check>
<label for=m-zh-cndocsv27userexamplesparameter-validation-check><a href=/zh-cn/docsv2.7/user/examples/parameter-validation/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesparameter-validation><span>参数验证</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesgeneric-invoke-with-json-li><input type=checkbox id=m-zh-cndocsv27userexamplesgeneric-invoke-with-json-check>
<label for=m-zh-cndocsv27userexamplesgeneric-invoke-with-json-check><a href=/zh-cn/docsv2.7/user/examples/generic-invoke-with-json/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesgeneric-invoke-with-json><span>JSON泛化调用</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesmsgpack-serialization-li><input type=checkbox id=m-zh-cndocsv27userexamplesmsgpack-serialization-check>
<label for=m-zh-cndocsv27userexamplesmsgpack-serialization-check><a href=/zh-cn/docsv2.7/user/examples/msgpack-serialization/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesmsgpack-serialization><span>msgpack序列化</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesprovider-timeout-release-li><input type=checkbox id=m-zh-cndocsv27userexamplesprovider-timeout-release-check>
<label for=m-zh-cndocsv27userexamplesprovider-timeout-release-check><a href=/zh-cn/docsv2.7/user/examples/provider-timeout-release/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesprovider-timeout-release><span>provider超时打断</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesresult-cache-li><input type=checkbox id=m-zh-cndocsv27userexamplesresult-cache-check>
<label for=m-zh-cndocsv27userexamplesresult-cache-check><a href=/zh-cn/docsv2.7/user/examples/result-cache/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesresult-cache><span>结果缓存</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesbroadcast-resp-collect-li><input type=checkbox id=m-zh-cndocsv27userexamplesbroadcast-resp-collect-check>
<label for=m-zh-cndocsv27userexamplesbroadcast-resp-collect-check><a href=/zh-cn/docsv2.7/user/examples/broadcast-resp-collect/ title=收集Dubbo广播响应 class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesbroadcast-resp-collect><span>收集广播响应</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesinvoke-with-specified-ip-li><input type=checkbox id=m-zh-cndocsv27userexamplesinvoke-with-specified-ip-check>
<label for=m-zh-cndocsv27userexamplesinvoke-with-specified-ip-check><a href=/zh-cn/docsv2.7/user/examples/invoke-with-specified-ip/ title="指定Ip Port调用Provider" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesinvoke-with-specified-ip><span>指定IP</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesgeneric-reference-li><input type=checkbox id=m-zh-cndocsv27userexamplesgeneric-reference-check>
<label for=m-zh-cndocsv27userexamplesgeneric-reference-check><a href=/zh-cn/docsv2.7/user/examples/generic-reference/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesgeneric-reference><span>使用泛化调用</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesprotobuf-idl-li><input type=checkbox id=m-zh-cndocsv27userexamplesprotobuf-idl-check>
<label for=m-zh-cndocsv27userexamplesprotobuf-idl-check><a href=/zh-cn/docsv2.7/user/examples/protobuf-idl/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesprotobuf-idl><span>Protobuf</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplespb-generic-reference-li><input type=checkbox id=m-zh-cndocsv27userexamplespb-generic-reference-check>
<label for=m-zh-cndocsv27userexamplespb-generic-reference-check><a href=/zh-cn/docsv2.7/user/examples/pb-generic-reference/ title="GoogleProtobuf 对象泛化调用" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplespb-generic-reference><span>Protobuf 泛化调用</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesgeneric-service-li><input type=checkbox id=m-zh-cndocsv27userexamplesgeneric-service-check>
<label for=m-zh-cndocsv27userexamplesgeneric-service-check><a href=/zh-cn/docsv2.7/user/examples/generic-service/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesgeneric-service><span>实现泛化调用</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesecho-service-li><input type=checkbox id=m-zh-cndocsv27userexamplesecho-service-check>
<label for=m-zh-cndocsv27userexamplesecho-service-check><a href=/zh-cn/docsv2.7/user/examples/echo-service/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesecho-service><span>回声测试</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplescontext-li><input type=checkbox id=m-zh-cndocsv27userexamplescontext-check>
<label for=m-zh-cndocsv27userexamplescontext-check><a href=/zh-cn/docsv2.7/user/examples/context/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplescontext><span>上下文信息</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesattachment-li><input type=checkbox id=m-zh-cndocsv27userexamplesattachment-check>
<label for=m-zh-cndocsv27userexamplesattachment-check><a href=/zh-cn/docsv2.7/user/examples/attachment/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesattachment><span>隐式参数</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesasync-call-li><input type=checkbox id=m-zh-cndocsv27userexamplesasync-call-check>
<label for=m-zh-cndocsv27userexamplesasync-call-check><a href=/zh-cn/docsv2.7/user/examples/async-call/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesasync-call><span>异步调用</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesasync-execute-on-provider-li><input type=checkbox id=m-zh-cndocsv27userexamplesasync-execute-on-provider-check>
<label for=m-zh-cndocsv27userexamplesasync-execute-on-provider-check><a href=/zh-cn/docsv2.7/user/examples/async-execute-on-provider/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesasync-execute-on-provider><span>异步执行</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexampleslocal-call-li><input type=checkbox id=m-zh-cndocsv27userexampleslocal-call-check>
<label for=m-zh-cndocsv27userexampleslocal-call-check><a href=/zh-cn/docsv2.7/user/examples/local-call/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexampleslocal-call><span>本地调用</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplescallback-parameter-li><input type=checkbox id=m-zh-cndocsv27userexamplescallback-parameter-check>
<label for=m-zh-cndocsv27userexamplescallback-parameter-check><a href=/zh-cn/docsv2.7/user/examples/callback-parameter/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplescallback-parameter><span>参数回调</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesevents-notify-li><input type=checkbox id=m-zh-cndocsv27userexamplesevents-notify-check>
<label for=m-zh-cndocsv27userexamplesevents-notify-check><a href=/zh-cn/docsv2.7/user/examples/events-notify/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesevents-notify><span>事件通知</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexampleslocal-stub-li><input type=checkbox id=m-zh-cndocsv27userexampleslocal-stub-check>
<label for=m-zh-cndocsv27userexampleslocal-stub-check><a href=/zh-cn/docsv2.7/user/examples/local-stub/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexampleslocal-stub><span>本地存根</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexampleslocal-mock-li><input type=checkbox id=m-zh-cndocsv27userexampleslocal-mock-check>
<label for=m-zh-cndocsv27userexampleslocal-mock-check><a href=/zh-cn/docsv2.7/user/examples/local-mock/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexampleslocal-mock><span>本地伪装</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesdelay-publish-li><input type=checkbox id=m-zh-cndocsv27userexamplesdelay-publish-check>
<label for=m-zh-cndocsv27userexamplesdelay-publish-check><a href=/zh-cn/docsv2.7/user/examples/delay-publish/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesdelay-publish><span>延迟暴露</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesconcurrency-control-li><input type=checkbox id=m-zh-cndocsv27userexamplesconcurrency-control-check>
<label for=m-zh-cndocsv27userexamplesconcurrency-control-check><a href=/zh-cn/docsv2.7/user/examples/concurrency-control/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesconcurrency-control><span>并发控制</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesconfig-connections-li><input type=checkbox id=m-zh-cndocsv27userexamplesconfig-connections-check>
<label for=m-zh-cndocsv27userexamplesconfig-connections-check><a href=/zh-cn/docsv2.7/user/examples/config-connections/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesconfig-connections><span>连接控制</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexampleslazy-connect-li><input type=checkbox id=m-zh-cndocsv27userexampleslazy-connect-check>
<label for=m-zh-cndocsv27userexampleslazy-connect-check><a href=/zh-cn/docsv2.7/user/examples/lazy-connect/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexampleslazy-connect><span>延迟连接</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesstickiness-li><input type=checkbox id=m-zh-cndocsv27userexamplesstickiness-check>
<label for=m-zh-cndocsv27userexamplesstickiness-check><a href=/zh-cn/docsv2.7/user/examples/stickiness/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesstickiness><span>粘滞连接</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplestls-li><input type=checkbox id=m-zh-cndocsv27userexamplestls-check>
<label for=m-zh-cndocsv27userexamplestls-check><a href=/zh-cn/docsv2.7/user/examples/tls/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplestls><span>TLS</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplestoken-authorization-li><input type=checkbox id=m-zh-cndocsv27userexamplestoken-authorization-check>
<label for=m-zh-cndocsv27userexamplestoken-authorization-check><a href=/zh-cn/docsv2.7/user/examples/token-authorization/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplestoken-authorization><span>令牌验证</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesrouting-rule-li><input type=checkbox id=m-zh-cndocsv27userexamplesrouting-rule-check>
<label for=m-zh-cndocsv27userexamplesrouting-rule-check><a href=/zh-cn/docsv2.7/user/examples/routing-rule/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesrouting-rule><span>路由规则</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesrouting-rule-deprecated-li><input type=checkbox id=m-zh-cndocsv27userexamplesrouting-rule-deprecated-check>
<label for=m-zh-cndocsv27userexamplesrouting-rule-deprecated-check><a href=/zh-cn/docsv2.7/user/examples/routing-rule-deprecated/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesrouting-rule-deprecated><span>旧路由规则</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesconfig-rule-li><input type=checkbox id=m-zh-cndocsv27userexamplesconfig-rule-check>
<label for=m-zh-cndocsv27userexamplesconfig-rule-check><a href=/zh-cn/docsv2.7/user/examples/config-rule/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesconfig-rule><span>配置规则</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesservice-downgrade-li><input type=checkbox id=m-zh-cndocsv27userexamplesservice-downgrade-check>
<label for=m-zh-cndocsv27userexamplesservice-downgrade-check><a href=/zh-cn/docsv2.7/user/examples/service-downgrade/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesservice-downgrade><span>服务降级</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesconfig-rule-deprecated-li><input type=checkbox id=m-zh-cndocsv27userexamplesconfig-rule-deprecated-check>
<label for=m-zh-cndocsv27userexamplesconfig-rule-deprecated-check><a href=/zh-cn/docsv2.7/user/examples/config-rule-deprecated/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesconfig-rule-deprecated><span>旧配置规则</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesconsumer-threadpool-li><input type=checkbox id=m-zh-cndocsv27userexamplesconsumer-threadpool-check>
<label for=m-zh-cndocsv27userexamplesconsumer-threadpool-check><a href=/zh-cn/docsv2.7/user/examples/consumer-threadpool/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesconsumer-threadpool><span>消费端线程池模型</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesgraceful-shutdown-li><input type=checkbox id=m-zh-cndocsv27userexamplesgraceful-shutdown-check>
<label for=m-zh-cndocsv27userexamplesgraceful-shutdown-check><a href=/zh-cn/docsv2.7/user/examples/graceful-shutdown/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesgraceful-shutdown><span>优雅停机</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexampleshostname-binding-li><input type=checkbox id=m-zh-cndocsv27userexampleshostname-binding-check>
<label for=m-zh-cndocsv27userexampleshostname-binding-check><a href=/zh-cn/docsv2.7/user/examples/hostname-binding/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexampleshostname-binding><span>主机绑定</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesset-host-li><input type=checkbox id=m-zh-cndocsv27userexamplesset-host-check>
<label for=m-zh-cndocsv27userexamplesset-host-check><a href=/zh-cn/docsv2.7/user/examples/set-host/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesset-host><span>主机配置</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userreferences-li><input type=checkbox id=m-zh-cndocsv27userreferences-check>
<label for=m-zh-cndocsv27userreferences-check><a href=/zh-cn/docsv2.7/user/references/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userreferences><span>参考手册</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userreferencesxml-li><input type=checkbox id=m-zh-cndocsv27userreferencesxml-check>
<label for=m-zh-cndocsv27userreferencesxml-check><a href=/zh-cn/docsv2.7/user/references/xml/ title="Schema 配置参考手册" class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userreferencesxml><span>XML 配置</span></a></label><ul class="ul-4 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-application-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-application-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-application-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-application/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-application><span>dubbo:application</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-argument-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-argument-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-argument-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-argument/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-argument><span>dubbo:argument</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-config-center-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-config-center-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-config-center-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-config-center/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-config-center><span>dubbo:config-center</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-consumer-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-consumer-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-consumer-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-consumer/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-consumer><span>dubbo:consumer</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-method-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-method-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-method-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-method/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-method><span>dubbo:method</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-module-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-module-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-module-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-module/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-module><span>dubbo:module</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-monitor-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-monitor-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-monitor-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-monitor/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-monitor><span>dubbo:monitor</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-parameter-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-parameter-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-parameter-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-parameter/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-parameter><span>dubbo:parameter</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-protocol-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-protocol-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-protocol-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-protocol/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-protocol><span>dubbo:protocol</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-provider-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-provider-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-provider-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-provider/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-provider><span>dubbo:provider</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-reference-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-reference-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-reference-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-reference/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-reference><span>dubbo:reference</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-registry-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-registry-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-registry-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-registry/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-registry><span>dubbo:registry</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-service-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-service-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-service-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-service/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-service><span>dubbo:service</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userreferencesprotocol-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocol-check>
<label for=m-zh-cndocsv27userreferencesprotocol-check><a href=/zh-cn/docsv2.7/user/references/protocol/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userreferencesprotocol><span>协议参考手册</span></a></label><ul class="ul-4 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocoldubbo-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocoldubbo-check>
<label for=m-zh-cndocsv27userreferencesprotocoldubbo-check><a href=/zh-cn/docsv2.7/user/references/protocol/dubbo/ title="dubbo 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocoldubbo><span>dubbo://</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocolrest-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocolrest-check>
<label for=m-zh-cndocsv27userreferencesprotocolrest-check><a href=/zh-cn/docsv2.7/user/references/protocol/rest/ title="rest 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocolrest><span>rest://</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocolhttp-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocolhttp-check>
<label for=m-zh-cndocsv27userreferencesprotocolhttp-check><a href=/zh-cn/docsv2.7/user/references/protocol/http/ title="http 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocolhttp><span>http://</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocolhessian-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocolhessian-check>
<label for=m-zh-cndocsv27userreferencesprotocolhessian-check><a href=/zh-cn/docsv2.7/user/references/protocol/hessian/ title="hessian 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocolhessian><span>hessian://</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocolredis-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocolredis-check>
<label for=m-zh-cndocsv27userreferencesprotocolredis-check><a href=/zh-cn/docsv2.7/user/references/protocol/redis/ title="redis 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocolredis><span>redis://</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocolthrift-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocolthrift-check>
<label for=m-zh-cndocsv27userreferencesprotocolthrift-check><a href=/zh-cn/docsv2.7/user/references/protocol/thrift/ title="thrift 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocolthrift><span>thrift://</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocolgrpc-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocolgrpc-check>
<label for=m-zh-cndocsv27userreferencesprotocolgrpc-check><a href=/zh-cn/docsv2.7/user/references/protocol/grpc/ title="gRPC 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocolgrpc><span>grpc://</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocolmemcached-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocolmemcached-check>
<label for=m-zh-cndocsv27userreferencesprotocolmemcached-check><a href=/zh-cn/docsv2.7/user/references/protocol/memcached/ title="memcached 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocolmemcached><span>memcached://</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocolrmi-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocolrmi-check>
<label for=m-zh-cndocsv27userreferencesprotocolrmi-check><a href=/zh-cn/docsv2.7/user/references/protocol/rmi/ title="rmi 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocolrmi><span>rmi://</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocolwebservice-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocolwebservice-check>
<label for=m-zh-cndocsv27userreferencesprotocolwebservice-check><a href=/zh-cn/docsv2.7/user/references/protocol/webservice/ title="webservice 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocolwebservice><span>webservice://</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userreferencesregistry-li><input type=checkbox id=m-zh-cndocsv27userreferencesregistry-check>
<label for=m-zh-cndocsv27userreferencesregistry-check><a href=/zh-cn/docsv2.7/user/references/registry/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userreferencesregistry><span>注册中心参考手册</span></a></label><ul class="ul-4 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesregistrynacos-li><input type=checkbox id=m-zh-cndocsv27userreferencesregistrynacos-check>
<label for=m-zh-cndocsv27userreferencesregistrynacos-check><a href=/zh-cn/docsv2.7/user/references/registry/nacos/ title="Nacos 注册中心" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesregistrynacos><span>Nacos</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesregistryzookeeper-li><input type=checkbox id=m-zh-cndocsv27userreferencesregistryzookeeper-check>
<label for=m-zh-cndocsv27userreferencesregistryzookeeper-check><a href=/zh-cn/docsv2.7/user/references/registry/zookeeper/ title="Zookeeper 注册中心" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesregistryzookeeper><span>Zookeeper</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesregistrymulticast-li><input type=checkbox id=m-zh-cndocsv27userreferencesregistrymulticast-check>
<label for=m-zh-cndocsv27userreferencesregistrymulticast-check><a href=/zh-cn/docsv2.7/user/references/registry/multicast/ title="Multicast 注册中心" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesregistrymulticast><span>Multicast</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesregistryredis-li><input type=checkbox id=m-zh-cndocsv27userreferencesregistryredis-check>
<label for=m-zh-cndocsv27userreferencesregistryredis-check><a href=/zh-cn/docsv2.7/user/references/registry/redis/ title="Redis 注册中心" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesregistryredis><span>Redis</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesregistrysimple-li><input type=checkbox id=m-zh-cndocsv27userreferencesregistrysimple-check>
<label for=m-zh-cndocsv27userreferencesregistrysimple-check><a href=/zh-cn/docsv2.7/user/references/registry/simple/ title="Simple 注册中心" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesregistrysimple><span>Simple</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesmetadata-li><input type=checkbox id=m-zh-cndocsv27userreferencesmetadata-check>
<label for=m-zh-cndocsv27userreferencesmetadata-check><a href=/zh-cn/docsv2.7/user/references/metadata/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesmetadata><span>元数据参考手册</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesapi-li><input type=checkbox id=m-zh-cndocsv27userreferencesapi-check>
<label for=m-zh-cndocsv27userreferencesapi-check><a href=/zh-cn/docsv2.7/user/references/api/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesapi><span>API 参考手册</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesqos-li><input type=checkbox id=m-zh-cndocsv27userreferencesqos-check>
<label for=m-zh-cndocsv27userreferencesqos-check><a href=/zh-cn/docsv2.7/user/references/qos/ title=在线运维命令参考手册 class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesqos><span>QOS 手册</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencestelnet-li><input type=checkbox id=m-zh-cndocsv27userreferencestelnet-check>
<label for=m-zh-cndocsv27userreferencestelnet-check><a href=/zh-cn/docsv2.7/user/references/telnet/ title="Telnet 命令参考手册" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencestelnet><span>Telnet 手册</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesmaven-li><input type=checkbox id=m-zh-cndocsv27userreferencesmaven-check>
<label for=m-zh-cndocsv27userreferencesmaven-check><a href=/zh-cn/docsv2.7/user/references/maven/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesmaven><span>Maven 插件参考手册</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userversions-li><input type=checkbox id=m-zh-cndocsv27userversions-check>
<label for=m-zh-cndocsv27userversions-check><a href=/zh-cn/docsv2.7/user/versions/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userversions><span>版本升级</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userversionsversion-270-li><input type=checkbox id=m-zh-cndocsv27userversionsversion-270-check>
<label for=m-zh-cndocsv27userversionsversion-270-check><a href=/zh-cn/docsv2.7/user/versions/version-270/ title=升级与可能的兼容性问题总结 class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userversionsversion-270><span>2.7.0</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userbest-practice-li><input type=checkbox id=m-zh-cndocsv27userbest-practice-check>
<label for=m-zh-cndocsv27userbest-practice-check><a href=/zh-cn/docsv2.7/user/best-practice/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userbest-practice><span>服务化最佳实践</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userrecommend-li><input type=checkbox id=m-zh-cndocsv27userrecommend-check>
<label for=m-zh-cndocsv27userrecommend-check><a href=/zh-cn/docsv2.7/user/recommend/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userrecommend><span>推荐用法</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27usercapacity-plan-li><input type=checkbox id=m-zh-cndocsv27usercapacity-plan-check>
<label for=m-zh-cndocsv27usercapacity-plan-check><a href=/zh-cn/docsv2.7/user/capacity-plan/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27usercapacity-plan><span>容量规划</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userperf-test-li><input type=checkbox id=m-zh-cndocsv27userperf-test-check>
<label for=m-zh-cndocsv27userperf-test-check><a href=/zh-cn/docsv2.7/user/perf-test/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userperf-test><span>性能测试报告</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27usercoveragence-li><input type=checkbox id=m-zh-cndocsv27usercoveragence-check>
<label for=m-zh-cndocsv27usercoveragence-check><a href=/zh-cn/docsv2.7/user/coveragence/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27usercoveragence><span>测试覆盖率报告</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userbenchmark-tool-li><input type=checkbox id=m-zh-cndocsv27userbenchmark-tool-check>
<label for=m-zh-cndocsv27userbenchmark-tool-check><a href=/zh-cn/docsv2.7/user/benchmark-tool/ title=基准测试工具包 class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userbenchmark-tool><span>基准测试</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userrest-li><input type=checkbox id=m-zh-cndocsv27userrest-check>
<label for=m-zh-cndocsv27userrest-check><a href=/zh-cn/docsv2.7/user/rest/ title="开发 REST 应用" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userrest><span>REST 支持</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27usersimple-monitor-li><input type=checkbox id=m-zh-cndocsv27usersimple-monitor-check>
<label for=m-zh-cndocsv27usersimple-monitor-check><a href=/zh-cn/docsv2.7/user/simple-monitor/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27usersimple-monitor><span>简单监控</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userserialization-li><input type=checkbox id=m-zh-cndocsv27userserialization-check>
<label for=m-zh-cndocsv27userserialization-check><a href=/zh-cn/docsv2.7/user/serialization/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userserialization><span>Kryo 和 FST 序列化</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userlanguages-li><input type=checkbox id=m-zh-cndocsv27userlanguages-check>
<label for=m-zh-cndocsv27userlanguages-check><a href=/zh-cn/docsv2.7/user/languages/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userlanguages><span>其他语言支持</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userlanguageserlang-li><input type=checkbox id=m-zh-cndocsv27userlanguageserlang-check>
<label for=m-zh-cndocsv27userlanguageserlang-check><a href=/zh-cn/docsv2.7/user/languages/erlang/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userlanguageserlang><span>Erlang</span></a></label><ul class="ul-4 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userlanguageserlangquick-start-li><input type=checkbox id=m-zh-cndocsv27userlanguageserlangquick-start-check>
<label for=m-zh-cndocsv27userlanguageserlangquick-start-check><a href=/zh-cn/docsv2.7/user/languages/erlang/quick-start/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userlanguageserlangquick-start><span>快速开始</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userlanguageserlangreference-li><input type=checkbox id=m-zh-cndocsv27userlanguageserlangreference-check>
<label for=m-zh-cndocsv27userlanguageserlangreference-check><a href=/zh-cn/docsv2.7/user/languages/erlang/reference/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userlanguageserlangreference><span>消费者配置</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userlanguageserlangservice-li><input type=checkbox id=m-zh-cndocsv27userlanguageserlangservice-check>
<label for=m-zh-cndocsv27userlanguageserlangservice-check><a href=/zh-cn/docsv2.7/user/languages/erlang/service/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userlanguageserlangservice><span>提供者配置</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userlanguageserlangserialization-li><input type=checkbox id=m-zh-cndocsv27userlanguageserlangserialization-check>
<label for=m-zh-cndocsv27userlanguageserlangserialization-check><a href=/zh-cn/docsv2.7/user/languages/erlang/serialization/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userlanguageserlangserialization><span>序列化配置项</span></a></label></li></ul></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27usernew-features-in-a-glance-li><input type=checkbox id=m-zh-cndocsv27usernew-features-in-a-glance-check>
<label for=m-zh-cndocsv27usernew-features-in-a-glance-check><a href=/zh-cn/docsv2.7/user/new-features-in-a-glance/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27usernew-features-in-a-glance><span></span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27dev-li><input type=checkbox id=m-zh-cndocsv27dev-check>
<label for=m-zh-cndocsv27dev-check><a href=/zh-cn/docsv2.7/dev/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27dev><span>开发指南</span></a></label><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devbuild-li><input type=checkbox id=m-zh-cndocsv27devbuild-check>
<label for=m-zh-cndocsv27devbuild-check><a href=/zh-cn/docsv2.7/dev/build/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devbuild><span>源码构建</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devdesign-li><input type=checkbox id=m-zh-cndocsv27devdesign-check>
<label for=m-zh-cndocsv27devdesign-check><a href=/zh-cn/docsv2.7/dev/design/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devdesign><span>框架设计</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devspi-li><input type=checkbox id=m-zh-cndocsv27devspi-check>
<label for=m-zh-cndocsv27devspi-check><a href=/zh-cn/docsv2.7/dev/spi/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devspi><span>扩展点加载</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplementation-li><input type=checkbox id=m-zh-cndocsv27devimplementation-check>
<label for=m-zh-cndocsv27devimplementation-check><a href=/zh-cn/docsv2.7/dev/implementation/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplementation><span>实现细节</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27devimpls-li><input type=checkbox id=m-zh-cndocsv27devimpls-check>
<label for=m-zh-cndocsv27devimpls-check><a href=/zh-cn/docsv2.7/dev/impls/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27devimpls><span>SPI 扩展实现</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsprotocol-li><input type=checkbox id=m-zh-cndocsv27devimplsprotocol-check>
<label for=m-zh-cndocsv27devimplsprotocol-check><a href=/zh-cn/docsv2.7/dev/impls/protocol/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsprotocol><span>协议扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsfilter-li><input type=checkbox id=m-zh-cndocsv27devimplsfilter-check>
<label for=m-zh-cndocsv27devimplsfilter-check><a href=/zh-cn/docsv2.7/dev/impls/filter/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsfilter><span>调用拦截扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsinvoker-listener-li><input type=checkbox id=m-zh-cndocsv27devimplsinvoker-listener-check>
<label for=m-zh-cndocsv27devimplsinvoker-listener-check><a href=/zh-cn/docsv2.7/dev/impls/invoker-listener/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsinvoker-listener><span>引用监听扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsexporter-listener-li><input type=checkbox id=m-zh-cndocsv27devimplsexporter-listener-check>
<label for=m-zh-cndocsv27devimplsexporter-listener-check><a href=/zh-cn/docsv2.7/dev/impls/exporter-listener/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsexporter-listener><span>暴露监听扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplscluster-li><input type=checkbox id=m-zh-cndocsv27devimplscluster-check>
<label for=m-zh-cndocsv27devimplscluster-check><a href=/zh-cn/docsv2.7/dev/impls/cluster/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplscluster><span>集群扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsrouter-li><input type=checkbox id=m-zh-cndocsv27devimplsrouter-check>
<label for=m-zh-cndocsv27devimplsrouter-check><a href=/zh-cn/docsv2.7/dev/impls/router/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsrouter><span>路由扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsload-balance-li><input type=checkbox id=m-zh-cndocsv27devimplsload-balance-check>
<label for=m-zh-cndocsv27devimplsload-balance-check><a href=/zh-cn/docsv2.7/dev/impls/load-balance/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsload-balance><span>负载均衡扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsmerger-li><input type=checkbox id=m-zh-cndocsv27devimplsmerger-check>
<label for=m-zh-cndocsv27devimplsmerger-check><a href=/zh-cn/docsv2.7/dev/impls/merger/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsmerger><span>合并结果扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsregistry-li><input type=checkbox id=m-zh-cndocsv27devimplsregistry-check>
<label for=m-zh-cndocsv27devimplsregistry-check><a href=/zh-cn/docsv2.7/dev/impls/registry/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsregistry><span>注册中心扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsmonitor-li><input type=checkbox id=m-zh-cndocsv27devimplsmonitor-check>
<label for=m-zh-cndocsv27devimplsmonitor-check><a href=/zh-cn/docsv2.7/dev/impls/monitor/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsmonitor><span>监控中心扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsextension-factory-li><input type=checkbox id=m-zh-cndocsv27devimplsextension-factory-check>
<label for=m-zh-cndocsv27devimplsextension-factory-check><a href=/zh-cn/docsv2.7/dev/impls/extension-factory/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsextension-factory><span>扩展点加载扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsproxy-factory-li><input type=checkbox id=m-zh-cndocsv27devimplsproxy-factory-check>
<label for=m-zh-cndocsv27devimplsproxy-factory-check><a href=/zh-cn/docsv2.7/dev/impls/proxy-factory/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsproxy-factory><span>动态代理扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplscompiler-li><input type=checkbox id=m-zh-cndocsv27devimplscompiler-check>
<label for=m-zh-cndocsv27devimplscompiler-check><a href=/zh-cn/docsv2.7/dev/impls/compiler/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplscompiler><span>编译器扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsconfig-center-li><input type=checkbox id=m-zh-cndocsv27devimplsconfig-center-check>
<label for=m-zh-cndocsv27devimplsconfig-center-check><a href=/zh-cn/docsv2.7/dev/impls/config-center/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsconfig-center><span>配置中心扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsdispatcher-li><input type=checkbox id=m-zh-cndocsv27devimplsdispatcher-check>
<label for=m-zh-cndocsv27devimplsdispatcher-check><a href=/zh-cn/docsv2.7/dev/impls/dispatcher/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsdispatcher><span>消息派发扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsthreadpool-li><input type=checkbox id=m-zh-cndocsv27devimplsthreadpool-check>
<label for=m-zh-cndocsv27devimplsthreadpool-check><a href=/zh-cn/docsv2.7/dev/impls/threadpool/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsthreadpool><span>线程池扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsserialize-li><input type=checkbox id=m-zh-cndocsv27devimplsserialize-check>
<label for=m-zh-cndocsv27devimplsserialize-check><a href=/zh-cn/docsv2.7/dev/impls/serialize/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsserialize><span>序列化扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsremoting-li><input type=checkbox id=m-zh-cndocsv27devimplsremoting-check>
<label for=m-zh-cndocsv27devimplsremoting-check><a href=/zh-cn/docsv2.7/dev/impls/remoting/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsremoting><span>网络传输扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsexchanger-li><input type=checkbox id=m-zh-cndocsv27devimplsexchanger-check>
<label for=m-zh-cndocsv27devimplsexchanger-check><a href=/zh-cn/docsv2.7/dev/impls/exchanger/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsexchanger><span>信息交换扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsnetworker-li><input type=checkbox id=m-zh-cndocsv27devimplsnetworker-check>
<label for=m-zh-cndocsv27devimplsnetworker-check><a href=/zh-cn/docsv2.7/dev/impls/networker/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsnetworker><span>组网扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplstelnet-handler-li><input type=checkbox id=m-zh-cndocsv27devimplstelnet-handler-check>
<label for=m-zh-cndocsv27devimplstelnet-handler-check><a href=/zh-cn/docsv2.7/dev/impls/telnet-handler/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplstelnet-handler><span>Telnet 命令扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsstatus-checker-li><input type=checkbox id=m-zh-cndocsv27devimplsstatus-checker-check>
<label for=m-zh-cndocsv27devimplsstatus-checker-check><a href=/zh-cn/docsv2.7/dev/impls/status-checker/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsstatus-checker><span>状态检查扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplscontainer-li><input type=checkbox id=m-zh-cndocsv27devimplscontainer-check>
<label for=m-zh-cndocsv27devimplscontainer-check><a href=/zh-cn/docsv2.7/dev/impls/container/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplscontainer><span>容器扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplscache-li><input type=checkbox id=m-zh-cndocsv27devimplscache-check>
<label for=m-zh-cndocsv27devimplscache-check><a href=/zh-cn/docsv2.7/dev/impls/cache/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplscache><span>缓存扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsvalidation-li><input type=checkbox id=m-zh-cndocsv27devimplsvalidation-check>
<label for=m-zh-cndocsv27devimplsvalidation-check><a href=/zh-cn/docsv2.7/dev/impls/validation/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsvalidation><span>验证扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplslogger-adapter-li><input type=checkbox id=m-zh-cndocsv27devimplslogger-adapter-check>
<label for=m-zh-cndocsv27devimplslogger-adapter-check><a href=/zh-cn/docsv2.7/dev/impls/logger-adapter/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplslogger-adapter><span>日志适配扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplspage-li><input type=checkbox id=m-zh-cndocsv27devimplspage-check>
<label for=m-zh-cndocsv27devimplspage-check><a href=/zh-cn/docsv2.7/dev/impls/page/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplspage><span></span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27devprincipals-li><input type=checkbox id=m-zh-cndocsv27devprincipals-check>
<label for=m-zh-cndocsv27devprincipals-check><a href=/zh-cn/docsv2.7/dev/principals/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27devprincipals><span>设计原则</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devprincipalscode-detail-li><input type=checkbox id=m-zh-cndocsv27devprincipalscode-detail-check>
<label for=m-zh-cndocsv27devprincipalscode-detail-check><a href=/zh-cn/docsv2.7/dev/principals/code-detail/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devprincipalscode-detail><span>魔鬼在细节</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devprincipalsconfiguration-li><input type=checkbox id=m-zh-cndocsv27devprincipalsconfiguration-check>
<label for=m-zh-cndocsv27devprincipalsconfiguration-check><a href=/zh-cn/docsv2.7/dev/principals/configuration/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devprincipalsconfiguration><span>配置设计</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devprincipalsdummy-li><input type=checkbox id=m-zh-cndocsv27devprincipalsdummy-check>
<label for=m-zh-cndocsv27devprincipalsdummy-check><a href=/zh-cn/docsv2.7/dev/principals/dummy/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devprincipalsdummy><span>防痴呆设计</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devprincipalsexpansibility-li><input type=checkbox id=m-zh-cndocsv27devprincipalsexpansibility-check>
<label for=m-zh-cndocsv27devprincipalsexpansibility-check><a href=/zh-cn/docsv2.7/dev/principals/expansibility/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devprincipalsexpansibility><span>谈谈扩充式扩展与增量式扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devprincipalsextension-li><input type=checkbox id=m-zh-cndocsv27devprincipalsextension-check>
<label for=m-zh-cndocsv27devprincipalsextension-check><a href=/zh-cn/docsv2.7/dev/principals/extension/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devprincipalsextension><span>扩展点重构</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devprincipalsgeneral-knowledge-li><input type=checkbox id=m-zh-cndocsv27devprincipalsgeneral-knowledge-check>
<label for=m-zh-cndocsv27devprincipalsgeneral-knowledge-check><a href=/zh-cn/docsv2.7/dev/principals/general-knowledge/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devprincipalsgeneral-knowledge><span>一些设计上的基本常识</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devprincipalsrobustness-li><input type=checkbox id=m-zh-cndocsv27devprincipalsrobustness-check>
<label for=m-zh-cndocsv27devprincipalsrobustness-check><a href=/zh-cn/docsv2.7/dev/principals/robustness/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devprincipalsrobustness><span>设计实现的健壮性</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devprincipalsintroduction-li><input type=checkbox id=m-zh-cndocsv27devprincipalsintroduction-check>
<label for=m-zh-cndocsv27devprincipalsintroduction-check><a href=/zh-cn/docsv2.7/dev/principals/introduction/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devprincipalsintroduction><span></span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devcontract-li><input type=checkbox id=m-zh-cndocsv27devcontract-check>
<label for=m-zh-cndocsv27devcontract-check><a href=/zh-cn/docsv2.7/dev/contract/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devcontract><span>公共契约</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27devsource-li><input type=checkbox id=m-zh-cndocsv27devsource-check>
<label for=m-zh-cndocsv27devsource-check><a href=/zh-cn/docsv2.7/dev/source/ title="Dubbo 源代码分析" class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27devsource><span>源代码</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devsourcedubbo-spi-li><input type=checkbox id=m-zh-cndocsv27devsourcedubbo-spi-check>
<label for=m-zh-cndocsv27devsourcedubbo-spi-check><a href=/zh-cn/docsv2.7/dev/source/dubbo-spi/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devsourcedubbo-spi><span>Dubbo SPI</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devsourcerouter-li><input type=checkbox id=m-zh-cndocsv27devsourcerouter-check>
<label for=m-zh-cndocsv27devsourcerouter-check><a href=/zh-cn/docsv2.7/dev/source/router/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devsourcerouter><span>服务路由</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devsourceadaptive-extension-li><input type=checkbox id=m-zh-cndocsv27devsourceadaptive-extension-check>
<label for=m-zh-cndocsv27devsourceadaptive-extension-check><a href=/zh-cn/docsv2.7/dev/source/adaptive-extension/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devsourceadaptive-extension><span>SPI 自适应拓展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devsourceexport-service-li><input type=checkbox id=m-zh-cndocsv27devsourceexport-service-check>
<label for=m-zh-cndocsv27devsourceexport-service-check><a href=/zh-cn/docsv2.7/dev/source/export-service/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devsourceexport-service><span>服务导出</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devsourcerefer-service-li><input type=checkbox id=m-zh-cndocsv27devsourcerefer-service-check>
<label for=m-zh-cndocsv27devsourcerefer-service-check><a href=/zh-cn/docsv2.7/dev/source/refer-service/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devsourcerefer-service><span>服务引用</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devsourceservice-invoking-process-li><input type=checkbox id=m-zh-cndocsv27devsourceservice-invoking-process-check>
<label for=m-zh-cndocsv27devsourceservice-invoking-process-check><a href=/zh-cn/docsv2.7/dev/source/service-invoking-process/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devsourceservice-invoking-process><span>服务调用过程</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devsourcedirectory-li><input type=checkbox id=m-zh-cndocsv27devsourcedirectory-check>
<label for=m-zh-cndocsv27devsourcedirectory-check><a href=/zh-cn/docsv2.7/dev/source/directory/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devsourcedirectory><span>服务目录</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devsourcecluster-li><input type=checkbox id=m-zh-cndocsv27devsourcecluster-check>
<label for=m-zh-cndocsv27devsourcecluster-check><a href=/zh-cn/docsv2.7/dev/source/cluster/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devsourcecluster><span>集群</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devsourceloadbalance-li><input type=checkbox id=m-zh-cndocsv27devsourceloadbalance-check>
<label for=m-zh-cndocsv27devsourceloadbalance-check><a href=/zh-cn/docsv2.7/dev/source/loadbalance/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devsourceloadbalance><span>负载均衡</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devrelease-li><input type=checkbox id=m-zh-cndocsv27devrelease-check>
<label for=m-zh-cndocsv27devrelease-check><a href=/zh-cn/docsv2.7/dev/release/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devrelease><span>版本管理</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devchecklist-li><input type=checkbox id=m-zh-cndocsv27devchecklist-check>
<label for=m-zh-cndocsv27devchecklist-check><a href=/zh-cn/docsv2.7/dev/checklist/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devchecklist><span>检查列表</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devcoding-li><input type=checkbox id=m-zh-cndocsv27devcoding-check>
<label for=m-zh-cndocsv27devcoding-check><a href=/zh-cn/docsv2.7/dev/coding/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devcoding><span>编码约定</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devcode-smell-li><input type=checkbox id=m-zh-cndocsv27devcode-smell-check>
<label for=m-zh-cndocsv27devcode-smell-check><a href=/zh-cn/docsv2.7/dev/code-smell/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devcode-smell><span>坏味道</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devtck-li><input type=checkbox id=m-zh-cndocsv27devtck-check>
<label for=m-zh-cndocsv27devtck-check><a href=/zh-cn/docsv2.7/dev/tck/ title=技术兼容性测试 class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devtck><span>TCK</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27admin-li><input type=checkbox id=m-zh-cndocsv27admin-check>
<label for=m-zh-cndocsv27admin-check><a href=/zh-cn/docsv2.7/admin/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27admin><span>运维指南</span></a></label><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27adminops-li><input type=checkbox id=m-zh-cndocsv27adminops-check>
<label for=m-zh-cndocsv27adminops-check><a href=/zh-cn/docsv2.7/admin/ops/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27adminops><span>Dubbo Admin 运维指南</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27adminopsfunctions-li><input type=checkbox id=m-zh-cndocsv27adminopsfunctions-check>
<label for=m-zh-cndocsv27adminopsfunctions-check><a href=/zh-cn/docsv2.7/admin/ops/functions/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27adminopsfunctions><span>管理控制台运维</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27adminopsintroduction-li><input type=checkbox id=m-zh-cndocsv27adminopsintroduction-check>
<label for=m-zh-cndocsv27adminopsintroduction-check><a href=/zh-cn/docsv2.7/admin/ops/introduction/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27adminopsintroduction><span>Dubbo 管理控制台介绍</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27adminopstest-li><input type=checkbox id=m-zh-cndocsv27adminopstest-check>
<label for=m-zh-cndocsv27adminopstest-check><a href=/zh-cn/docsv2.7/admin/ops/test/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27adminopstest><span>服务测试</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27adminopssearch-li><input type=checkbox id=m-zh-cndocsv27adminopssearch-check>
<label for=m-zh-cndocsv27adminopssearch-check><a href=/zh-cn/docsv2.7/admin/ops/search/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27adminopssearch><span>服务查询和详情展示</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27adminopsapidocs-li><input type=checkbox id=m-zh-cndocsv27adminopsapidocs-check>
<label for=m-zh-cndocsv27adminopsapidocs-check><a href=/zh-cn/docsv2.7/admin/ops/apidocs/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27adminopsapidocs><span>API文档&测试</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27adminopsgovernance-li><input type=checkbox id=m-zh-cndocsv27adminopsgovernance-check>
<label for=m-zh-cndocsv27adminopsgovernance-check><a href=/zh-cn/docsv2.7/admin/ops/governance/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27adminopsgovernance><span>服务治理和配置管理</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27adminopsskywalking-li><input type=checkbox id=m-zh-cndocsv27adminopsskywalking-check>
<label for=m-zh-cndocsv27adminopsskywalking-check><a href=/zh-cn/docsv2.7/admin/ops/skywalking/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27adminopsskywalking><span>使用 Apache Skywalking 做分布式跟踪</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27adminopspinpoint-li><input type=checkbox id=m-zh-cndocsv27adminopspinpoint-check>
<label for=m-zh-cndocsv27adminopspinpoint-check><a href=/zh-cn/docsv2.7/admin/ops/pinpoint/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27adminopspinpoint><span>使用 Pinpoint 做分布式跟踪</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27admininstall-li><input type=checkbox id=m-zh-cndocsv27admininstall-check>
<label for=m-zh-cndocsv27admininstall-check><a href=/zh-cn/docsv2.7/admin/install/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27admininstall><span>安装手册</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27admininstalladmin-console-li><input type=checkbox id=m-zh-cndocsv27admininstalladmin-console-check>
<label for=m-zh-cndocsv27admininstalladmin-console-check><a href=/zh-cn/docsv2.7/admin/install/admin-console/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27admininstalladmin-console><span>管理控制台安装</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27admininstallprovider-demo-li><input type=checkbox id=m-zh-cndocsv27admininstallprovider-demo-check>
<label for=m-zh-cndocsv27admininstallprovider-demo-check><a href=/zh-cn/docsv2.7/admin/install/provider-demo/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27admininstallprovider-demo><span>示例提供者安装</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27admininstallconsumer-demo-li><input type=checkbox id=m-zh-cndocsv27admininstallconsumer-demo-check>
<label for=m-zh-cndocsv27admininstallconsumer-demo-check><a href=/zh-cn/docsv2.7/admin/install/consumer-demo/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27admininstallconsumer-demo><span>示例消费者安装</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27admininstallredis-li><input type=checkbox id=m-zh-cndocsv27admininstallredis-check>
<label for=m-zh-cndocsv27admininstallredis-check><a href=/zh-cn/docsv2.7/admin/install/redis/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27admininstallredis><span>Redis 注册中心安装</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27admininstallzookeeper-li><input type=checkbox id=m-zh-cndocsv27admininstallzookeeper-check>
<label for=m-zh-cndocsv27admininstallzookeeper-check><a href=/zh-cn/docsv2.7/admin/install/zookeeper/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27admininstallzookeeper><span>Zookeeper 注册中心安装</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27admininstallmonitor-center-li><input type=checkbox id=m-zh-cndocsv27admininstallmonitor-center-check>
<label for=m-zh-cndocsv27admininstallmonitor-center-check><a href=/zh-cn/docsv2.7/admin/install/monitor-center/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27admininstallmonitor-center><span>Simple 监控中心安装</span></a></label></li></ul></li></ul></li></ul></li></ul></nav></div></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><nav aria-label=breadcrumb class=td-breadcrumbs><ol class=breadcrumb><li class=breadcrumb-item><a href=https://dubbo.apache.org/zh-cn/docsv2.7/>文档 2.x</a></li><li class=breadcrumb-item><a href=https://dubbo.apache.org/zh-cn/docsv2.7/dev/>开发指南</a></li><li class=breadcrumb-item><a href=https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/>源代码</a></li><li class="breadcrumb-item active" aria-current=page><a href=https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/service-invoking-process/ aria-disabled=true class="btn-link disabled">服务调用过程</a></li></ol></nav><div class=td-content><h1>服务调用过程</h1><div class=lead>本文介绍了服务调用过程的原理和实现细节</div><header class=article-meta></header><h2 id=1-简介>1. 简介</h2><p>在前面的文章中，我们分析了 Dubbo SPI、服务导出与引入、以及集群容错方面的代码。经过前文的铺垫，本篇文章我们终于可以分析服务调用过程了。Dubbo 服务调用过程比较复杂，包含众多步骤，比如发送请求、编解码、服务降级、过滤器链处理、序列化、线程派发以及响应请求等步骤。限于篇幅原因，本篇文章无法对所有的步骤一一进行分析。本篇文章将会重点分析请求的发送与接收、编解码、线程派发以及响应的发送与接收等过程，至于服务降级、过滤器链和序列化大家自行进行分析，也可以将其当成一个黑盒，暂时忽略也没关系。介绍完本篇文章要分析的内容，接下来我们进入正题吧。</p><h2 id=2-源码分析>2. 源码分析</h2><p>在进行源码分析之前，我们先来通过一张图了解 Dubbo 服务调用过程。</p><p><img src=/imgs/dev/send-request-process.jpg alt=img></p><p>首先服务消费者通过代理对象 Proxy 发起远程调用，接着通过网络客户端 Client 将编码后的请求发送给服务提供方的网络层上，也就是 Server。Server 在收到请求后，首先要做的事情是对数据包进行解码。然后将解码后的请求发送至分发器 Dispatcher，再由分发器将请求派发到指定的线程池上，最后由线程池调用具体的服务。这就是一个远程调用请求的发送与接收过程。至于响应的发送与接收过程，这张图中没有表现出来。对于这两个过程，我们也会进行详细分析。</p><h3 id=21-服务调用方式>2.1 服务调用方式</h3><p>Dubbo 支持同步和异步两种调用方式，其中异步调用还可细分为“有返回值”的异步调用和“无返回值”的异步调用。所谓“无返回值”异步调用是指服务消费方只管调用，但不关心调用结果，此时 Dubbo 会直接返回一个空的 RpcResult。若要使用异步特性，需要服务消费方手动进行配置。默认情况下，Dubbo 使用同步调用方式。</p><p>本节以及其他章节将会使用 Dubbo 官方提供的 Demo 分析整个调用过程，下面我们从 DemoService 接口的代理类开始进行分析。Dubbo 默认使用 Javassist 框架为服务接口生成动态代理类，因此我们需要先将代理类进行反编译才能看到源码。这里使用阿里开源 Java 应用诊断工具 <a href=https://github.com/alibaba/arthas>Arthas</a> 反编译代理类，结果如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#586e75>/**
</span></span></span><span style=display:flex><span><span style=color:#586e75> * Arthas 反编译步骤：
</span></span></span><span style=display:flex><span><span style=color:#586e75> * 1. 启动 Arthas
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    java -jar arthas-boot.jar
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * 2. 输入编号选择进程
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    Arthas 启动后，会打印 Java 应用进程列表，如下：
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    [1]: 11232 org.jetbrains.jps.cmdline.Launcher
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    [2]: 22370 org.jetbrains.jps.cmdline.Launcher
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    [3]: 22371 com.alibaba.dubbo.demo.consumer.Consumer
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    [4]: 22362 com.alibaba.dubbo.demo.provider.Provider
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    [5]: 2074 org.apache.zookeeper.server.quorum.QuorumPeerMain
</span></span></span><span style=display:flex><span><span style=color:#586e75> * 这里输入编号 3，让 Arthas 关联到启动类为 com.....Consumer 的 Java 进程上
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * 3. 由于 Demo 项目中只有一个服务接口，因此此接口的代理类类名为 proxy0，此时使用 sc 命令搜索这个类名。
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    $ sc *.proxy0
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    com.alibaba.dubbo.common.bytecode.proxy0
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * 4. 使用 jad 命令反编译 com.alibaba.dubbo.common.bytecode.proxy0
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    $ jad com.alibaba.dubbo.common.bytecode.proxy0
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * 更多使用方法请参考 Arthas 官方文档：
</span></span></span><span style=display:flex><span><span style=color:#586e75> *   https://arthas.aliyun.com/doc/quick-start.html
</span></span></span><span style=display:flex><span><span style=color:#586e75> */</span>
</span></span><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>proxy0</span> <span style=color:#268bd2>implements</span> ClassGenerator.DC, EchoService, DemoService {
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 方法数组</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>static</span> Method<span style=color:#719e07>[]</span> methods;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> InvocationHandler handler;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>proxy0</span>(InvocationHandler invocationHandler) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.handler <span style=color:#719e07>=</span> invocationHandler;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>proxy0</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> String <span style=color:#268bd2>sayHello</span>(String string) {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 将参数存储到 Object 数组中</span>
</span></span><span style=display:flex><span>        Object<span style=color:#719e07>[]</span> arrobject <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> Object<span style=color:#719e07>[]</span>{string};
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 调用 InvocationHandler 实现类的 invoke 方法得到调用结果</span>
</span></span><span style=display:flex><span>        Object object <span style=color:#719e07>=</span> <span style=color:#719e07>this</span>.handler.invoke(<span style=color:#719e07>this</span>, methods<span style=color:#719e07>[</span>0<span style=color:#719e07>]</span>, arrobject);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 返回调用结果</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> (String)object;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>/** 回声测试方法 */</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Object <span style=color:#268bd2>$echo</span>(Object object) {
</span></span><span style=display:flex><span>        Object<span style=color:#719e07>[]</span> arrobject <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> Object<span style=color:#719e07>[]</span>{object};
</span></span><span style=display:flex><span>        Object object2 <span style=color:#719e07>=</span> <span style=color:#719e07>this</span>.handler.invoke(<span style=color:#719e07>this</span>, methods<span style=color:#719e07>[</span>1<span style=color:#719e07>]</span>, arrobject);
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> object2;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上，代理类的逻辑比较简单。首先将运行时参数存储到数组中，然后调用 InvocationHandler 接口实现类的 invoke 方法，得到调用结果，最后将结果转型并返回给调用方。关于代理类的逻辑就说这么多，继续向下分析。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>InvokerInvocationHandler</span> <span style=color:#268bd2>implements</span> InvocationHandler {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Invoker<span style=color:#719e07>&lt;?&gt;</span> invoker;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>InvokerInvocationHandler</span>(Invoker<span style=color:#719e07>&lt;?&gt;</span> handler) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.invoker <span style=color:#719e07>=</span> handler;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Object <span style=color:#268bd2>invoke</span>(Object proxy, Method method, Object<span style=color:#719e07>[]</span> args) <span style=color:#268bd2>throws</span> Throwable {
</span></span><span style=display:flex><span>        String methodName <span style=color:#719e07>=</span> method.getName();
</span></span><span style=display:flex><span>        Class<span style=color:#719e07>&lt;?&gt;[]</span> parameterTypes <span style=color:#719e07>=</span> method.getParameterTypes();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 拦截定义在 Object 类中的方法（未被子类重写），比如 wait/notify</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (method.getDeclaringClass() <span style=color:#719e07>==</span> Object.class) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> method.invoke(invoker, args);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 如果 toString、hashCode 和 equals 等方法被子类重写了，这里也直接调用</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (<span style=color:#2aa198>&#34;toString&#34;</span>.equals(methodName) <span style=color:#719e07>&amp;&amp;</span> parameterTypes.length <span style=color:#719e07>==</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> invoker.toString();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (<span style=color:#2aa198>&#34;hashCode&#34;</span>.equals(methodName) <span style=color:#719e07>&amp;&amp;</span> parameterTypes.length <span style=color:#719e07>==</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> invoker.hashCode();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (<span style=color:#2aa198>&#34;equals&#34;</span>.equals(methodName) <span style=color:#719e07>&amp;&amp;</span> parameterTypes.length <span style=color:#719e07>==</span> 1) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> invoker.equals(args<span style=color:#719e07>[</span>0<span style=color:#719e07>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 将 method 和 args 封装到 RpcInvocation 中，并执行后续的调用</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> invoker.invoke(<span style=color:#719e07>new</span> RpcInvocation(method, args)).recreate();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>InvokerInvocationHandler 中的 invoker 成员变量类型为 MockClusterInvoker，MockClusterInvoker 内部封装了服务降级逻辑。下面简单看一下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>MockClusterInvoker</span><span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> <span style=color:#268bd2>implements</span> Invoker<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Invoker<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> invoker;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Result <span style=color:#268bd2>invoke</span>(Invocation invocation) <span style=color:#268bd2>throws</span> RpcException {
</span></span><span style=display:flex><span>        Result result <span style=color:#719e07>=</span> <span style=color:#cb4b16>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取 mock 配置值</span>
</span></span><span style=display:flex><span>        String value <span style=color:#719e07>=</span> directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (value.length() <span style=color:#719e07>==</span> 0 <span style=color:#719e07>||</span> value.equalsIgnoreCase(<span style=color:#2aa198>&#34;false&#34;</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 无 mock 逻辑，直接调用其他 Invoker 对象的 invoke 方法，</span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 比如 FailoverClusterInvoker</span>
</span></span><span style=display:flex><span>            result <span style=color:#719e07>=</span> <span style=color:#719e07>this</span>.invoker.invoke(invocation);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (value.startsWith(<span style=color:#2aa198>&#34;force&#34;</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// force:xxx 直接执行 mock 逻辑，不发起远程调用</span>
</span></span><span style=display:flex><span>            result <span style=color:#719e07>=</span> doMockInvoke(invocation, <span style=color:#cb4b16>null</span>);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// fail:xxx 表示消费方对调用服务失败后，再执行 mock 逻辑，不抛出异常</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 调用其他 Invoker 对象的 invoke 方法</span>
</span></span><span style=display:flex><span>                result <span style=color:#719e07>=</span> <span style=color:#719e07>this</span>.invoker.invoke(invocation);
</span></span><span style=display:flex><span>            } <span style=color:#719e07>catch</span> (RpcException e) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span> (e.isBiz()) {
</span></span><span style=display:flex><span>                    <span style=color:#719e07>throw</span> e;
</span></span><span style=display:flex><span>                } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 调用失败，执行 mock 逻辑</span>
</span></span><span style=display:flex><span>                    result <span style=color:#719e07>=</span> doMockInvoke(invocation, e);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> result;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略其他方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>服务降级不是本文重点，因此这里就不分析 doMockInvoke 方法了。考虑到前文已经详细分析过 FailoverClusterInvoker，因此本节略过 FailoverClusterInvoker，直接分析 DubboInvoker。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>abstract</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>AbstractInvoker</span><span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> <span style=color:#268bd2>implements</span> Invoker<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Result <span style=color:#268bd2>invoke</span>(Invocation inv) <span style=color:#268bd2>throws</span> RpcException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (destroyed.get()) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RpcException(<span style=color:#2aa198>&#34;Rpc invoker for service ...&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        RpcInvocation invocation <span style=color:#719e07>=</span> (RpcInvocation) inv;
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 设置 Invoker</span>
</span></span><span style=display:flex><span>        invocation.setInvoker(<span style=color:#719e07>this</span>);
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (attachment <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>&amp;&amp;</span> attachment.size() <span style=color:#719e07>&gt;</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置 attachment</span>
</span></span><span style=display:flex><span>            invocation.addAttachmentsIfAbsent(attachment);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Map<span style=color:#719e07>&lt;</span>String, String<span style=color:#719e07>&gt;</span> contextAttachments <span style=color:#719e07>=</span> RpcContext.getContext().getAttachments();
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (contextAttachments <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>&amp;&amp;</span> contextAttachments.size() <span style=color:#719e07>!=</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 添加 contextAttachments 到 RpcInvocation#attachment 变量中</span>
</span></span><span style=display:flex><span>            invocation.addAttachments(contextAttachments);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, <span style=color:#cb4b16>false</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置异步信息到 RpcInvocation#attachment 中</span>
</span></span><span style=display:flex><span>            invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 抽象方法，由子类实现</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> doInvoke(invocation);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (InvocationTargetException e) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (RpcException e) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> <span style=color:#719e07>new</span> RpcResult(e);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>abstract</span> Result <span style=color:#268bd2>doInvoke</span>(Invocation invocation) <span style=color:#268bd2>throws</span> Throwable;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略其他方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的代码来自 AbstractInvoker 类，其中大部分代码用于添加信息到 RpcInvocation#attachment 变量中，添加完毕后，调用 doInvoke 执行后续的调用。doInvoke 是一个抽象方法，需要由子类实现，下面到 DubboInvoker 中看一下。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DubboInvoker</span><span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> <span style=color:#268bd2>extends</span> AbstractInvoker<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> ExchangeClient<span style=color:#719e07>[]</span> clients;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> Result <span style=color:#268bd2>doInvoke</span>(<span style=color:#268bd2>final</span> Invocation invocation) <span style=color:#268bd2>throws</span> Throwable {
</span></span><span style=display:flex><span>        RpcInvocation inv <span style=color:#719e07>=</span> (RpcInvocation) invocation;
</span></span><span style=display:flex><span>        <span style=color:#268bd2>final</span> String methodName <span style=color:#719e07>=</span> RpcUtils.getMethodName(invocation);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 设置 path 和 version 到 attachment 中</span>
</span></span><span style=display:flex><span>        inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());
</span></span><span style=display:flex><span>        inv.setAttachment(Constants.VERSION_KEY, version);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ExchangeClient currentClient;
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (clients.length <span style=color:#719e07>==</span> 1) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 从 clients 数组中获取 ExchangeClient</span>
</span></span><span style=display:flex><span>            currentClient <span style=color:#719e07>=</span> clients<span style=color:#719e07>[</span>0<span style=color:#719e07>]</span>;
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>            currentClient <span style=color:#719e07>=</span> clients<span style=color:#719e07>[</span>index.getAndIncrement() <span style=color:#719e07>%</span> clients.length<span style=color:#719e07>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 获取异步配置</span>
</span></span><span style=display:flex><span>            <span style=color:#dc322f>boolean</span> isAsync <span style=color:#719e07>=</span> RpcUtils.isAsync(getUrl(), invocation);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// isOneway 为 true，表示“单向”通信</span>
</span></span><span style=display:flex><span>            <span style=color:#dc322f>boolean</span> isOneway <span style=color:#719e07>=</span> RpcUtils.isOneway(getUrl(), invocation);
</span></span><span style=display:flex><span>            <span style=color:#dc322f>int</span> timeout <span style=color:#719e07>=</span> getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 异步无返回值</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (isOneway) {
</span></span><span style=display:flex><span>                <span style=color:#dc322f>boolean</span> isSent <span style=color:#719e07>=</span> getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span style=color:#cb4b16>false</span>);
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 发送请求</span>
</span></span><span style=display:flex><span>                currentClient.send(inv, isSent);
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 设置上下文中的 future 字段为 null</span>
</span></span><span style=display:flex><span>                RpcContext.getContext().setFuture(<span style=color:#cb4b16>null</span>);
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 返回一个空的 RpcResult</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>return</span> <span style=color:#719e07>new</span> RpcResult();
</span></span><span style=display:flex><span>            } 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 异步有返回值</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (isAsync) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 发送请求，并得到一个 ResponseFuture 实例</span>
</span></span><span style=display:flex><span>                ResponseFuture future <span style=color:#719e07>=</span> currentClient.request(inv, timeout);
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 设置 future 到上下文中</span>
</span></span><span style=display:flex><span>                RpcContext.getContext().setFuture(<span style=color:#719e07>new</span> FutureAdapter<span style=color:#719e07>&lt;</span>Object<span style=color:#719e07>&gt;</span>(future));
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 暂时返回一个空结果</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>return</span> <span style=color:#719e07>new</span> RpcResult();
</span></span><span style=display:flex><span>            } 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 同步调用</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                RpcContext.getContext().setFuture(<span style=color:#cb4b16>null</span>);
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 发送请求，得到一个 ResponseFuture 实例，并调用该实例的 get 方法进行等待</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>return</span> (Result) currentClient.request(inv, timeout).get();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (TimeoutException e) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RpcException(..., <span style=color:#2aa198>&#34;Invoke remote method timeout....&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (RemotingException e) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RpcException(..., <span style=color:#2aa198>&#34;Failed to invoke remote method: ...&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略其他方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的代码包含了 Dubbo 对同步和异步调用的处理逻辑，搞懂了上面的代码，会对 Dubbo 的同步和异步调用方式有更深入的了解。Dubbo 实现同步和异步调用比较关键的一点就在于由谁调用 ResponseFuture 的 get 方法。同步调用模式下，由框架自身调用 ResponseFuture 的 get 方法。异步调用模式下，则由用户调用该方法。ResponseFuture 是一个接口，下面我们来看一下它的默认实现类 DefaultFuture 的源码。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DefaultFuture</span> <span style=color:#268bd2>implements</span> ResponseFuture {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> Map<span style=color:#719e07>&lt;</span>Long, Channel<span style=color:#719e07>&gt;</span> CHANNELS <span style=color:#719e07>=</span> 
</span></span><span style=display:flex><span>        <span style=color:#719e07>new</span> ConcurrentHashMap<span style=color:#719e07>&lt;</span>Long, Channel<span style=color:#719e07>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> Map<span style=color:#719e07>&lt;</span>Long, DefaultFuture<span style=color:#719e07>&gt;</span> FUTURES <span style=color:#719e07>=</span> 
</span></span><span style=display:flex><span>        <span style=color:#719e07>new</span> ConcurrentHashMap<span style=color:#719e07>&lt;</span>Long, DefaultFuture<span style=color:#719e07>&gt;</span>();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>long</span> id;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Channel channel;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Request request;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>int</span> timeout;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Lock lock <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> ReentrantLock();
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Condition done <span style=color:#719e07>=</span> lock.newCondition();
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>volatile</span> Response response;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>DefaultFuture</span>(Channel channel, Request request, <span style=color:#dc322f>int</span> timeout) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.channel <span style=color:#719e07>=</span> channel;
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.request <span style=color:#719e07>=</span> request;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取请求 id，这个 id 很重要，后面还会见到</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.id <span style=color:#719e07>=</span> request.getId();
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.timeout <span style=color:#719e07>=</span> timeout <span style=color:#719e07>&gt;</span> 0 <span style=color:#719e07>?</span> timeout : channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 存储 &lt;requestId, DefaultFuture&gt; 映射关系到 FUTURES 中</span>
</span></span><span style=display:flex><span>        FUTURES.put(id, <span style=color:#719e07>this</span>);
</span></span><span style=display:flex><span>        CHANNELS.put(id, channel);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Object <span style=color:#268bd2>get</span>() <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> get(timeout);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Object <span style=color:#268bd2>get</span>(<span style=color:#dc322f>int</span> timeout) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (timeout <span style=color:#719e07>&lt;=</span> 0) {
</span></span><span style=display:flex><span>            timeout <span style=color:#719e07>=</span> Constants.DEFAULT_TIMEOUT;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 检测服务提供方是否成功返回了调用结果</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>isDone()) {
</span></span><span style=display:flex><span>            <span style=color:#dc322f>long</span> start <span style=color:#719e07>=</span> System.currentTimeMillis();
</span></span><span style=display:flex><span>            lock.lock();
</span></span><span style=display:flex><span>            <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 循环检测服务提供方是否成功返回了调用结果</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>while</span> (<span style=color:#719e07>!</span>isDone()) {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 如果调用结果尚未返回，这里等待一段时间</span>
</span></span><span style=display:flex><span>                    done.await(timeout, TimeUnit.MILLISECONDS);
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 如果调用结果成功返回，或等待超时，此时跳出 while 循环，执行后续的逻辑</span>
</span></span><span style=display:flex><span>                    <span style=color:#719e07>if</span> (isDone() <span style=color:#719e07>||</span> System.currentTimeMillis() <span style=color:#719e07>-</span> start <span style=color:#719e07>&gt;</span> timeout) {
</span></span><span style=display:flex><span>                        <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#719e07>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RuntimeException(e);
</span></span><span style=display:flex><span>            } <span style=color:#719e07>finally</span> {
</span></span><span style=display:flex><span>                lock.unlock();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 如果调用结果仍未返回，则抛出超时异常</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>isDone()) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> TimeoutException(sent <span style=color:#719e07>&gt;</span> 0, channel, getTimeoutMessage(<span style=color:#cb4b16>false</span>));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 返回调用结果</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> returnFromResponse();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>boolean</span> <span style=color:#268bd2>isDone</span>() {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 通过检测 response 字段为空与否，判断是否收到了调用结果</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> response <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> Object <span style=color:#268bd2>returnFromResponse</span>() <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        Response res <span style=color:#719e07>=</span> response;
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (res <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IllegalStateException(<span style=color:#2aa198>&#34;response cannot be null&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 如果调用结果的状态为 Response.OK，则表示调用过程正常，服务提供方成功返回了调用结果</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (res.getStatus() <span style=color:#719e07>==</span> Response.OK) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> res.getResult();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 抛出异常</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (res.getStatus() <span style=color:#719e07>==</span> Response.CLIENT_TIMEOUT <span style=color:#719e07>||</span> res.getStatus() <span style=color:#719e07>==</span> Response.SERVER_TIMEOUT) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> TimeoutException(res.getStatus() <span style=color:#719e07>==</span> Response.SERVER_TIMEOUT, channel, res.getErrorMessage());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RemotingException(channel, res.getErrorMessage());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略其他方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上，当服务消费者还未接收到调用结果时，用户线程调用 get 方法会被阻塞住。同步调用模式下，框架获得 DefaultFuture 对象后，会立即调用 get 方法进行等待。而异步模式下则是将该对象封装到 FutureAdapter 实例中，并将 FutureAdapter 实例设置到 RpcContext 中，供用户使用。FutureAdapter 是一个适配器，用于将 Dubbo 中的 ResponseFuture 与 JDK 中的 Future 进行适配。这样当用户线程调用 Future 的 get 方法时，经过 FutureAdapter 适配，最终会调用 ResponseFuture 实现类对象的 get 方法，也就是 DefaultFuture 的 get 方法。</p><p>到这里关于 Dubbo 几种调用方式的代码逻辑就分析完了，下面来分析请求数据的发送与接收，以及响应数据的发送与接收过程。</p><h3 id=22-服务消费方发送请求>2.2 服务消费方发送请求</h3><h4 id=221-发送请求>2.2.1 发送请求</h4><p>本节我们来看一下同步调用模式下，服务消费方是如何发送调用请求的。在深入分析源码前，我们先来看一张图。</p><p><img src=/imgs/dev/send-request-thread-stack.jpg alt=img></p><p>这张图展示了服务消费方发送请求过程的部分调用栈，略为复杂。从上图可以看出，经过多次调用后，才将请求数据送至 Netty NioClientSocketChannel。这样做的原因是通过 Exchange 层为框架引入 Request 和 Response 语义，这一点会在接下来的源码分析过程中会看到。其他的就不多说了，下面开始进行分析。首先分析 ReferenceCountExchangeClient 的源码。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>final</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>ReferenceCountExchangeClient</span> <span style=color:#268bd2>implements</span> ExchangeClient {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> URL url;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> AtomicInteger referenceCount <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> AtomicInteger(0);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>ReferenceCountExchangeClient</span>(ExchangeClient client, ConcurrentMap<span style=color:#719e07>&lt;</span>String, LazyConnectExchangeClient<span style=color:#719e07>&gt;</span> ghostClientMap) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.client <span style=color:#719e07>=</span> client;
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 引用计数自增</span>
</span></span><span style=display:flex><span>        referenceCount.incrementAndGet();
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.url <span style=color:#719e07>=</span> client.getUrl();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> ResponseFuture <span style=color:#268bd2>request</span>(Object request) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 直接调用被装饰对象的同签名方法</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> client.request(request);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> ResponseFuture <span style=color:#268bd2>request</span>(Object request, <span style=color:#dc322f>int</span> timeout) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 直接调用被装饰对象的同签名方法</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> client.request(request, timeout);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>/** 引用计数自增，该方法由外部调用 */</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>incrementAndGetCount</span>() {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// referenceCount 自增</span>
</span></span><span style=display:flex><span>        referenceCount.incrementAndGet();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>close</span>(<span style=color:#dc322f>int</span> timeout) {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// referenceCount 自减</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (referenceCount.decrementAndGet() <span style=color:#719e07>&lt;=</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (timeout <span style=color:#719e07>==</span> 0) {
</span></span><span style=display:flex><span>                client.close();
</span></span><span style=display:flex><span>            } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                client.close(timeout);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            client <span style=color:#719e07>=</span> replaceWithLazyClient();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略部分方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ReferenceCountExchangeClient 内部定义了一个引用计数变量 referenceCount，每当该对象被引用一次 referenceCount 都会进行自增。每当 close 方法被调用时，referenceCount 进行自减。ReferenceCountExchangeClient 内部仅实现了一个引用计数的功能，其他方法并无复杂逻辑，均是直接调用被装饰对象的相关方法。所以这里就不多说了，继续向下分析，这次是 HeaderExchangeClient。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>HeaderExchangeClient</span> <span style=color:#268bd2>implements</span> ExchangeClient {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> ScheduledThreadPoolExecutor scheduled <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> ScheduledThreadPoolExecutor(2, <span style=color:#719e07>new</span> NamedThreadFactory(<span style=color:#2aa198>&#34;dubbo-remoting-client-heartbeat&#34;</span>, <span style=color:#cb4b16>true</span>));
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Client client;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> ExchangeChannel channel;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> ScheduledFuture<span style=color:#719e07>&lt;?&gt;</span> heartbeatTimer;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#dc322f>int</span> heartbeat;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#dc322f>int</span> heartbeatTimeout;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>HeaderExchangeClient</span>(Client client, <span style=color:#dc322f>boolean</span> needHeartbeat) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (client <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IllegalArgumentException(<span style=color:#2aa198>&#34;client == null&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.client <span style=color:#719e07>=</span> client;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 创建 HeaderExchangeChannel 对象</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.channel <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> HeaderExchangeChannel(client);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 以下代码均与心跳检测逻辑有关</span>
</span></span><span style=display:flex><span>        String dubbo <span style=color:#719e07>=</span> client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY);
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.heartbeat <span style=color:#719e07>=</span> client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>&amp;&amp;</span> dubbo.startsWith(<span style=color:#2aa198>&#34;1.0.&#34;</span>) <span style=color:#719e07>?</span> Constants.DEFAULT_HEARTBEAT : 0);
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.heartbeatTimeout <span style=color:#719e07>=</span> client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat <span style=color:#719e07>*</span> 3);
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (heartbeatTimeout <span style=color:#719e07>&lt;</span> heartbeat <span style=color:#719e07>*</span> 2) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IllegalStateException(<span style=color:#2aa198>&#34;heartbeatTimeout &lt; heartbeatInterval * 2&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (needHeartbeat) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 开启心跳检测定时器</span>
</span></span><span style=display:flex><span>            startHeartbeatTimer();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> ResponseFuture <span style=color:#268bd2>request</span>(Object request) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 直接 HeaderExchangeChannel 对象的同签名方法</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> channel.request(request);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> ResponseFuture <span style=color:#268bd2>request</span>(Object request, <span style=color:#dc322f>int</span> timeout) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 直接 HeaderExchangeChannel 对象的同签名方法</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> channel.request(request, timeout);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>close</span>() {
</span></span><span style=display:flex><span>        doClose();
</span></span><span style=display:flex><span>        channel.close();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>doClose</span>() {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 停止心跳检测定时器</span>
</span></span><span style=display:flex><span>        stopHeartbeatTimer();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>startHeartbeatTimer</span>() {
</span></span><span style=display:flex><span>        stopHeartbeatTimer();
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (heartbeat <span style=color:#719e07>&gt;</span> 0) {
</span></span><span style=display:flex><span>            heartbeatTimer <span style=color:#719e07>=</span> scheduled.scheduleWithFixedDelay(
</span></span><span style=display:flex><span>                    <span style=color:#719e07>new</span> HeartBeatTask(<span style=color:#719e07>new</span> HeartBeatTask.ChannelProvider() {
</span></span><span style=display:flex><span>                        <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>                        <span style=color:#268bd2>public</span> Collection<span style=color:#719e07>&lt;</span>Channel<span style=color:#719e07>&gt;</span> <span style=color:#268bd2>getChannels</span>() {
</span></span><span style=display:flex><span>                            <span style=color:#719e07>return</span> Collections.<span style=color:#719e07>&lt;</span>Channel<span style=color:#719e07>&gt;</span>singletonList(HeaderExchangeClient.this);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }, heartbeat, heartbeatTimeout),
</span></span><span style=display:flex><span>                    heartbeat, heartbeat, TimeUnit.MILLISECONDS);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>stopHeartbeatTimer</span>() {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (heartbeatTimer <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>&amp;&amp;</span> <span style=color:#719e07>!</span>heartbeatTimer.isCancelled()) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                heartbeatTimer.cancel(<span style=color:#cb4b16>true</span>);
</span></span><span style=display:flex><span>                scheduled.purge();
</span></span><span style=display:flex><span>            } <span style=color:#719e07>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span> (logger.isWarnEnabled()) {
</span></span><span style=display:flex><span>                    logger.warn(e.getMessage(), e);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        heartbeatTimer <span style=color:#719e07>=</span> <span style=color:#cb4b16>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略部分方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>HeaderExchangeClient 中很多方法只有一行代码，即调用 HeaderExchangeChannel 对象的同签名方法。那 HeaderExchangeClient 有什么用处呢？答案是封装了一些关于心跳检测的逻辑。心跳检测并非本文所关注的点，因此就不多说了，继续向下看。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>final</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>HeaderExchangeChannel</span> <span style=color:#268bd2>implements</span> ExchangeChannel {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Channel channel;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    HeaderExchangeChannel(Channel channel) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (channel <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IllegalArgumentException(<span style=color:#2aa198>&#34;channel == null&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 这里的 channel 指向的是 NettyClient</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.channel <span style=color:#719e07>=</span> channel;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> ResponseFuture <span style=color:#268bd2>request</span>(Object request) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> request(request, channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> ResponseFuture <span style=color:#268bd2>request</span>(Object request, <span style=color:#dc322f>int</span> timeout) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (closed) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RemotingException(..., <span style=color:#2aa198>&#34;Failed to send request ...);
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        // 创建 Request 对象
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        Request req = new Request();
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        req.setVersion(Version.getProtocolVersion());
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        // 设置双向通信标志为 true
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        req.setTwoWay(true);
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        // 这里的 request 变量类型为 RpcInvocation
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        req.setData(request);
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                                        
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        // 创建 DefaultFuture 对象
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        DefaultFuture future = new DefaultFuture(channel, req, timeout);
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        try {
</span></span></span><span style=display:flex><span><span style=color:#2aa198>            // 调用 NettyClient 的 send 方法发送请求
</span></span></span><span style=display:flex><span><span style=color:#2aa198>            channel.send(req);
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        } catch (RemotingException e) {
</span></span></span><span style=display:flex><span><span style=color:#2aa198>            future.cancel();
</span></span></span><span style=display:flex><span><span style=color:#2aa198>            throw e;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        // 返回 DefaultFuture 对象
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        return future;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>    }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>}
</span></span></span></code></pre></div><p>到这里大家终于看到了 Request 语义了，上面的方法首先定义了一个 Request 对象，然后再将该对象传给 NettyClient 的 send 方法，进行后续的调用。需要说明的是，NettyClient 中并未实现 send 方法，该方法继承自父类 AbstractPeer，下面直接分析 AbstractPeer 的代码。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>abstract</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>AbstractPeer</span> <span style=color:#268bd2>implements</span> Endpoint, ChannelHandler {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>send</span>(Object message) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 该方法由 AbstractClient 类实现</span>
</span></span><span style=display:flex><span>        send(message, url.getParameter(Constants.SENT_KEY, <span style=color:#cb4b16>false</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略其他方法</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>abstract</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>AbstractClient</span> <span style=color:#268bd2>extends</span> AbstractEndpoint <span style=color:#268bd2>implements</span> Client {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>send</span>(Object message, <span style=color:#dc322f>boolean</span> sent) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (send_reconnect <span style=color:#719e07>&amp;&amp;</span> <span style=color:#719e07>!</span>isConnected()) {
</span></span><span style=display:flex><span>            connect();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取 Channel，getChannel 是一个抽象方法，具体由子类实现</span>
</span></span><span style=display:flex><span>        Channel channel <span style=color:#719e07>=</span> getChannel();
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (channel <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>||</span> <span style=color:#719e07>!</span>channel.isConnected()) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RemotingException(<span style=color:#719e07>this</span>, <span style=color:#2aa198>&#34;message can not send ...&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 继续向下调用</span>
</span></span><span style=display:flex><span>        channel.send(message, sent);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>abstract</span> Channel <span style=color:#268bd2>getChannel</span>();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略其他方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>默认情况下，Dubbo 使用 Netty 作为底层的通信框架，因此下面我们到 NettyClient 类中看一下 getChannel 方法的实现逻辑。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>NettyClient</span> <span style=color:#268bd2>extends</span> AbstractClient {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 这里的 Channel 全限定名称为 org.jboss.netty.channel.Channel</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>volatile</span> Channel channel;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> com.alibaba.dubbo.remoting.Channel <span style=color:#268bd2>getChannel</span>() {
</span></span><span style=display:flex><span>        Channel c <span style=color:#719e07>=</span> channel;
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (c <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>||</span> <span style=color:#719e07>!</span>c.isConnected())
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> <span style=color:#cb4b16>null</span>;
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取一个 NettyChannel 类型对象</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> NettyChannel.getOrAddChannel(c, getUrl(), <span style=color:#719e07>this</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>final</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>NettyChannel</span> <span style=color:#268bd2>extends</span> AbstractChannel {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> ConcurrentMap<span style=color:#719e07>&lt;</span>org.jboss.netty.channel.Channel, NettyChannel<span style=color:#719e07>&gt;</span> channelMap <span style=color:#719e07>=</span> 
</span></span><span style=display:flex><span>        <span style=color:#719e07>new</span> ConcurrentHashMap<span style=color:#719e07>&lt;</span>org.jboss.netty.channel.Channel, NettyChannel<span style=color:#719e07>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> org.jboss.netty.channel.Channel channel;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>/** 私有构造方法 */</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>NettyChannel</span>(org.jboss.netty.channel.Channel channel, URL url, ChannelHandler handler) {
</span></span><span style=display:flex><span>        <span style=color:#268bd2>super</span>(url, handler);
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (channel <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IllegalArgumentException(<span style=color:#2aa198>&#34;netty channel == null;&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.channel <span style=color:#719e07>=</span> channel;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>static</span> NettyChannel <span style=color:#268bd2>getOrAddChannel</span>(org.jboss.netty.channel.Channel ch, URL url, ChannelHandler handler) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (ch <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> <span style=color:#cb4b16>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 尝试从集合中获取 NettyChannel 实例</span>
</span></span><span style=display:flex><span>        NettyChannel ret <span style=color:#719e07>=</span> channelMap.get(ch);
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (ret <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 如果 ret = null，则创建一个新的 NettyChannel 实例</span>
</span></span><span style=display:flex><span>            NettyChannel nc <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> NettyChannel(ch, url, handler);
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (ch.isConnected()) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 将 &lt;Channel, NettyChannel&gt; 键值对存入 channelMap 集合中</span>
</span></span><span style=display:flex><span>                ret <span style=color:#719e07>=</span> channelMap.putIfAbsent(ch, nc);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (ret <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>                ret <span style=color:#719e07>=</span> nc;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> ret;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>获取到 NettyChannel 实例后，即可进行后续的调用。下面看一下 NettyChannel 的 send 方法。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>send</span>(Object message, <span style=color:#dc322f>boolean</span> sent) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>    <span style=color:#268bd2>super</span>.send(message, sent);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#dc322f>boolean</span> success <span style=color:#719e07>=</span> <span style=color:#cb4b16>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#dc322f>int</span> timeout <span style=color:#719e07>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 发送消息(包含请求和响应消息)</span>
</span></span><span style=display:flex><span>        ChannelFuture future <span style=color:#719e07>=</span> channel.write(message);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// sent 的值源于 &lt;dubbo:method sent=&#34;true/false&#34; /&gt; 中 sent 的配置值，有两种配置值：</span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>//   1. true: 等待消息发出，消息发送失败将抛出异常</span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>//   2. false: 不等待消息发出，将消息放入 IO 队列，即刻返回</span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 默认情况下 sent = false；</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (sent) {
</span></span><span style=display:flex><span>            timeout <span style=color:#719e07>=</span> getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 等待消息发出，若在规定时间没能发出，success 会被置为 false</span>
</span></span><span style=display:flex><span>            success <span style=color:#719e07>=</span> future.await(timeout);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Throwable cause <span style=color:#719e07>=</span> future.getCause();
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (cause <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> cause;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#719e07>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RemotingException(<span style=color:#719e07>this</span>, <span style=color:#2aa198>&#34;Failed to send message ...&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 若 success 为 false，这里抛出异常</span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>success) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RemotingException(<span style=color:#719e07>this</span>, <span style=color:#2aa198>&#34;Failed to send message ...&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>经历多次调用，到这里请求数据的发送过程就结束了，过程漫长。为了便于大家阅读代码，这里以 DemoService 为例，将 sayHello 方法的整个调用路径贴出来。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy0#sayHello(String)
</span></span><span style=display:flex><span>  —&gt; InvokerInvocationHandler#invoke(Object, Method, Object[])
</span></span><span style=display:flex><span>    —&gt; MockClusterInvoker#invoke(Invocation)
</span></span><span style=display:flex><span>      —&gt; AbstractClusterInvoker#invoke(Invocation)
</span></span><span style=display:flex><span>        —&gt; FailoverClusterInvoker#doInvoke(Invocation, List&lt;Invoker&lt;T&gt;&gt;, LoadBalance)
</span></span><span style=display:flex><span>          —&gt; Filter#invoke(Invoker, Invocation)  // 包含多个 Filter 调用
</span></span><span style=display:flex><span>            —&gt; ListenerInvokerWrapper#invoke(Invocation) 
</span></span><span style=display:flex><span>              —&gt; AbstractInvoker#invoke(Invocation) 
</span></span><span style=display:flex><span>                —&gt; DubboInvoker#doInvoke(Invocation)
</span></span><span style=display:flex><span>                  —&gt; ReferenceCountExchangeClient#request(Object, int)
</span></span><span style=display:flex><span>                    —&gt; HeaderExchangeClient#request(Object, int)
</span></span><span style=display:flex><span>                      —&gt; HeaderExchangeChannel#request(Object, int)
</span></span><span style=display:flex><span>                        —&gt; AbstractPeer#send(Object)
</span></span><span style=display:flex><span>                          —&gt; AbstractClient#send(Object, boolean)
</span></span><span style=display:flex><span>                            —&gt; NettyChannel#send(Object, boolean)
</span></span><span style=display:flex><span>                              —&gt; NioClientSocketChannel#write(Object)
</span></span></code></pre></div><p>在 Netty 中，出站数据在发出之前还需要进行编码操作，接下来我们来分析一下请求数据的编码逻辑。</p><h4 id=222-请求编码>2.2.2 请求编码</h4><p>在分析请求编码逻辑之前，我们先来看一下 Dubbo 数据包结构。</p><p><img src=/imgs/dev/data-format.jpg alt=img></p><p>Dubbo 数据包分为消息头和消息体，消息头用于存储一些元信息，比如魔数（Magic），数据包类型（Request/Response），消息体长度（Data Length）等。消息体中用于存储具体的调用消息，比如方法名称，参数列表等。下面简单列举一下消息头的内容。</p><table><thead><tr><th>偏移量(Bit)</th><th>字段</th><th>取值</th></tr></thead><tbody><tr><td>0 ~ 7</td><td>魔数高位</td><td>0xda00</td></tr><tr><td>8 ~ 15</td><td>魔数低位</td><td>0xbb</td></tr><tr><td>16</td><td>数据包类型</td><td>0 - Response, 1 - Request</td></tr><tr><td>17</td><td>调用方式</td><td>仅在第16位被设为1的情况下有效，0 - 单向调用，1 - 双向调用</td></tr><tr><td>18</td><td>事件标识</td><td>0 - 当前数据包是请求或响应包，1 - 当前数据包是心跳包</td></tr><tr><td>19 ~ 23</td><td>序列化器编号</td><td>2 - Hessian2Serialization<br>3 - JavaSerialization<br>4 - CompactedJavaSerialization<br>6 - FastJsonSerialization<br>7 - NativeJavaSerialization<br>8 - KryoSerialization<br>9 - FstSerialization</td></tr><tr><td>24 ~ 31</td><td>状态</td><td>20 - OK<br>30 - CLIENT_TIMEOUT<br>31 - SERVER_TIMEOUT<br>40 - BAD_REQUEST<br>50 - BAD_RESPONSE<br>&mldr;&mldr;</td></tr><tr><td>32 ~ 95</td><td>请求编号</td><td>共8字节，运行时生成</td></tr><tr><td>96 ~ 127</td><td>消息体长度</td><td>运行时计算</td></tr></tbody></table><p>了解了 Dubbo 数据包格式，接下来我们就可以探索编码过程了。这次我们开门见山，直接分析编码逻辑所在类。如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>ExchangeCodec</span> <span style=color:#268bd2>extends</span> TelnetCodec {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 消息头长度</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>int</span> HEADER_LENGTH <span style=color:#719e07>=</span> 16;
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 魔数内容</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>short</span> MAGIC <span style=color:#719e07>=</span> (<span style=color:#dc322f>short</span>) 0xdabb;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>byte</span> MAGIC_HIGH <span style=color:#719e07>=</span> Bytes.short2bytes(MAGIC)<span style=color:#719e07>[</span>0<span style=color:#719e07>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>byte</span> MAGIC_LOW <span style=color:#719e07>=</span> Bytes.short2bytes(MAGIC)<span style=color:#719e07>[</span>1<span style=color:#719e07>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>byte</span> FLAG_REQUEST <span style=color:#719e07>=</span> (<span style=color:#dc322f>byte</span>) 0x80;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>byte</span> FLAG_TWOWAY <span style=color:#719e07>=</span> (<span style=color:#dc322f>byte</span>) 0x40;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>byte</span> FLAG_EVENT <span style=color:#719e07>=</span> (<span style=color:#dc322f>byte</span>) 0x20;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>int</span> SERIALIZATION_MASK <span style=color:#719e07>=</span> 0x1f;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> Logger logger <span style=color:#719e07>=</span> LoggerFactory.getLogger(ExchangeCodec.class);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Short <span style=color:#268bd2>getMagicCode</span>() {
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> MAGIC;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>encode</span>(Channel channel, ChannelBuffer buffer, Object msg) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (msg <span style=color:#719e07>instanceof</span> Request) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对 Request 对象进行编码</span>
</span></span><span style=display:flex><span>            encodeRequest(channel, buffer, (Request) msg);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (msg <span style=color:#719e07>instanceof</span> Response) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对 Response 对象进行编码，后面分析</span>
</span></span><span style=display:flex><span>            encodeResponse(channel, buffer, (Response) msg);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#268bd2>super</span>.encode(channel, buffer, msg);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>encodeRequest</span>(Channel channel, ChannelBuffer buffer, Request req) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        Serialization serialization <span style=color:#719e07>=</span> getSerialization(channel);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 创建消息头字节数组，长度为 16</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>byte</span><span style=color:#719e07>[]</span> header <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> <span style=color:#dc322f>byte</span><span style=color:#719e07>[</span>HEADER_LENGTH<span style=color:#719e07>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 设置魔数</span>
</span></span><span style=display:flex><span>        Bytes.short2bytes(MAGIC, header);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 设置数据包类型（Request/Response）和序列化器编号</span>
</span></span><span style=display:flex><span>        header<span style=color:#719e07>[</span>2<span style=color:#719e07>]</span> <span style=color:#719e07>=</span> (<span style=color:#dc322f>byte</span>) (FLAG_REQUEST <span style=color:#719e07>|</span> serialization.getContentTypeId());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 设置通信方式(单向/双向)</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (req.isTwoWay()) {
</span></span><span style=display:flex><span>            header<span style=color:#719e07>[</span>2<span style=color:#719e07>]</span> <span style=color:#719e07>|=</span> FLAG_TWOWAY;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 设置事件标识</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (req.isEvent()) {
</span></span><span style=display:flex><span>            header<span style=color:#719e07>[</span>2<span style=color:#719e07>]</span> <span style=color:#719e07>|=</span> FLAG_EVENT;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 设置请求编号，8个字节，从第4个字节开始设置</span>
</span></span><span style=display:flex><span>        Bytes.long2bytes(req.getId(), header, 4);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取 buffer 当前的写位置</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>int</span> savedWriteIndex <span style=color:#719e07>=</span> buffer.writerIndex();
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 更新 writerIndex，为消息头预留 16 个字节的空间</span>
</span></span><span style=display:flex><span>        buffer.writerIndex(savedWriteIndex <span style=color:#719e07>+</span> HEADER_LENGTH);
</span></span><span style=display:flex><span>        ChannelBufferOutputStream bos <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> ChannelBufferOutputStream(buffer);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 创建序列化器，比如 Hessian2ObjectOutput</span>
</span></span><span style=display:flex><span>        ObjectOutput out <span style=color:#719e07>=</span> serialization.serialize(channel.getUrl(), bos);
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (req.isEvent()) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对事件数据进行序列化操作</span>
</span></span><span style=display:flex><span>            encodeEventData(channel, out, req.getData());
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对请求数据进行序列化操作</span>
</span></span><span style=display:flex><span>            encodeRequestData(channel, out, req.getData(), req.getVersion());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        out.flushBuffer();
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (out <span style=color:#719e07>instanceof</span> Cleanable) {
</span></span><span style=display:flex><span>            ((Cleanable) out).cleanup();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        bos.flush();
</span></span><span style=display:flex><span>        bos.close();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取写入的字节数，也就是消息体长度</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>int</span> len <span style=color:#719e07>=</span> bos.writtenBytes();
</span></span><span style=display:flex><span>        checkPayload(channel, len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 将消息体长度写入到消息头中</span>
</span></span><span style=display:flex><span>        Bytes.int2bytes(len, header, 12);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 将 buffer 指针移动到 savedWriteIndex，为写消息头做准备</span>
</span></span><span style=display:flex><span>        buffer.writerIndex(savedWriteIndex);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 从 savedWriteIndex 下标处写入消息头</span>
</span></span><span style=display:flex><span>        buffer.writeBytes(header);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 设置新的 writerIndex，writerIndex = 原写下标 + 消息头长度 + 消息体长度</span>
</span></span><span style=display:flex><span>        buffer.writerIndex(savedWriteIndex <span style=color:#719e07>+</span> HEADER_LENGTH <span style=color:#719e07>+</span> len);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略其他方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上就是请求对象的编码过程，该过程首先会通过位运算将消息头写入到 header 数组中。然后对 Request 对象的 data 字段执行序列化操作，序列化后的数据最终会存储到 ChannelBuffer 中。序列化操作执行完后，可得到数据序列化后的长度 len，紧接着将 len 写入到 header 指定位置处。最后再将消息头字节数组 header 写入到 ChannelBuffer 中，整个编码过程就结束了。本节的最后，我们再来看一下 Request 对象的 data 字段序列化过程，也就是 encodeRequestData 方法的逻辑，如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DubboCodec</span> <span style=color:#268bd2>extends</span> ExchangeCodec <span style=color:#268bd2>implements</span> Codec2 {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	<span style=color:#268bd2>protected</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>encodeRequestData</span>(Channel channel, ObjectOutput out, Object data, String version) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        RpcInvocation inv <span style=color:#719e07>=</span> (RpcInvocation) data;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 依次序列化 dubbo version、path、version</span>
</span></span><span style=display:flex><span>        out.writeUTF(version);
</span></span><span style=display:flex><span>        out.writeUTF(inv.getAttachment(Constants.PATH_KEY));
</span></span><span style=display:flex><span>        out.writeUTF(inv.getAttachment(Constants.VERSION_KEY));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 序列化调用方法名</span>
</span></span><span style=display:flex><span>        out.writeUTF(inv.getMethodName());
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 将参数类型转换为字符串，并进行序列化</span>
</span></span><span style=display:flex><span>        out.writeUTF(ReflectUtils.getDesc(inv.getParameterTypes()));
</span></span><span style=display:flex><span>        Object<span style=color:#719e07>[]</span> args <span style=color:#719e07>=</span> inv.getArguments();
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (args <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span>)
</span></span><span style=display:flex><span>            <span style=color:#719e07>for</span> (<span style=color:#dc322f>int</span> i <span style=color:#719e07>=</span> 0; i <span style=color:#719e07>&lt;</span> args.length; i<span style=color:#719e07>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 对运行时参数进行序列化</span>
</span></span><span style=display:flex><span>                out.writeObject(encodeInvocationArgument(channel, inv, i));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 序列化 attachments</span>
</span></span><span style=display:flex><span>        out.writeObject(inv.getAttachments());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>至此，关于服务消费方发送请求的过程就分析完了，接下来我们来看一下服务提供方是如何接收请求的。</p><h3 id=23-服务提供方接收请求>2.3 服务提供方接收请求</h3><p>前面说过，默认情况下 Dubbo 使用 Netty 作为底层的通信框架。Netty 检测到有数据入站后，首先会通过解码器对数据进行解码，并将解码后的数据传递给下一个入站处理器的指定方法。所以在进行后续的分析之前，我们先来看一下数据解码过程。</p><h4 id=231-请求解码>2.3.1 请求解码</h4><p>这里直接分析请求数据的解码逻辑，忽略中间过程，如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>ExchangeCodec</span> <span style=color:#268bd2>extends</span> TelnetCodec {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Object <span style=color:#268bd2>decode</span>(Channel channel, ChannelBuffer buffer) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#dc322f>int</span> readable <span style=color:#719e07>=</span> buffer.readableBytes();
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 创建消息头字节数组</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>byte</span><span style=color:#719e07>[]</span> header <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> <span style=color:#dc322f>byte</span><span style=color:#719e07>[</span>Math.min(readable, HEADER_LENGTH)<span style=color:#719e07>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 读取消息头数据</span>
</span></span><span style=display:flex><span>        buffer.readBytes(header);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 调用重载方法进行后续解码工作</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> decode(channel, buffer, readable, header);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> Object <span style=color:#268bd2>decode</span>(Channel channel, ChannelBuffer buffer, <span style=color:#dc322f>int</span> readable, <span style=color:#dc322f>byte</span><span style=color:#719e07>[]</span> header) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 检查魔数是否相等</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (readable <span style=color:#719e07>&gt;</span> 0 <span style=color:#719e07>&amp;&amp;</span> header<span style=color:#719e07>[</span>0<span style=color:#719e07>]</span> <span style=color:#719e07>!=</span> MAGIC_HIGH
</span></span><span style=display:flex><span>                <span style=color:#719e07>||</span> readable <span style=color:#719e07>&gt;</span> 1 <span style=color:#719e07>&amp;&amp;</span> header<span style=color:#719e07>[</span>1<span style=color:#719e07>]</span> <span style=color:#719e07>!=</span> MAGIC_LOW) {
</span></span><span style=display:flex><span>            <span style=color:#dc322f>int</span> length <span style=color:#719e07>=</span> header.length;
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (header.length <span style=color:#719e07>&lt;</span> readable) {
</span></span><span style=display:flex><span>                header <span style=color:#719e07>=</span> Bytes.copyOf(header, readable);
</span></span><span style=display:flex><span>                buffer.readBytes(header, length, readable <span style=color:#719e07>-</span> length);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#719e07>for</span> (<span style=color:#dc322f>int</span> i <span style=color:#719e07>=</span> 1; i <span style=color:#719e07>&lt;</span> header.length <span style=color:#719e07>-</span> 1; i<span style=color:#719e07>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span> (header<span style=color:#719e07>[</span>i<span style=color:#719e07>]</span> <span style=color:#719e07>==</span> MAGIC_HIGH <span style=color:#719e07>&amp;&amp;</span> header<span style=color:#719e07>[</span>i <span style=color:#719e07>+</span> 1<span style=color:#719e07>]</span> <span style=color:#719e07>==</span> MAGIC_LOW) {
</span></span><span style=display:flex><span>                    buffer.readerIndex(buffer.readerIndex() <span style=color:#719e07>-</span> header.length <span style=color:#719e07>+</span> i);
</span></span><span style=display:flex><span>                    header <span style=color:#719e07>=</span> Bytes.copyOf(header, i);
</span></span><span style=display:flex><span>                    <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 通过 telnet 命令行发送的数据包不包含消息头，所以这里</span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 调用 TelnetCodec 的 decode 方法对数据包进行解码</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> <span style=color:#268bd2>super</span>.decode(channel, buffer, readable, header);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 检测可读数据量是否少于消息头长度，若小于则立即返回 DecodeResult.NEED_MORE_INPUT</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (readable <span style=color:#719e07>&lt;</span> HEADER_LENGTH) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> DecodeResult.NEED_MORE_INPUT;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 从消息头中获取消息体长度</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>int</span> len <span style=color:#719e07>=</span> Bytes.bytes2int(header, 12);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 检测消息体长度是否超出限制，超出则抛出异常</span>
</span></span><span style=display:flex><span>        checkPayload(channel, len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>int</span> tt <span style=color:#719e07>=</span> len <span style=color:#719e07>+</span> HEADER_LENGTH;
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 检测可读的字节数是否小于实际的字节数</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (readable <span style=color:#719e07>&lt;</span> tt) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> DecodeResult.NEED_MORE_INPUT;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        ChannelBufferInputStream is <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> ChannelBufferInputStream(buffer, len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 继续进行解码工作</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> decodeBody(channel, is, header);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>finally</span> {
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (is.available() <span style=color:#719e07>&gt;</span> 0) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                    StreamUtils.skipUnusedStream(is);
</span></span><span style=display:flex><span>                } <span style=color:#719e07>catch</span> (IOException e) {
</span></span><span style=display:flex><span>                    logger.warn(e.getMessage(), e);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面方法通过检测消息头中的魔数是否与规定的魔数相等，提前拦截掉非常规数据包，比如通过 telnet 命令行发出的数据包。接着再对消息体长度，以及可读字节数进行检测。最后调用 decodeBody 方法进行后续的解码工作，ExchangeCodec 中实现了 decodeBody 方法，但因其子类 DubboCodec 覆写了该方法，所以在运行时 DubboCodec 中的 decodeBody 方法会被调用。下面我们来看一下该方法的代码。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DubboCodec</span> <span style=color:#268bd2>extends</span> ExchangeCodec <span style=color:#268bd2>implements</span> Codec2 {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> Object <span style=color:#268bd2>decodeBody</span>(Channel channel, InputStream is, <span style=color:#dc322f>byte</span><span style=color:#719e07>[]</span> header) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取消息头中的第三个字节，并通过逻辑与运算得到序列化器编号</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>byte</span> flag <span style=color:#719e07>=</span> header<span style=color:#719e07>[</span>2<span style=color:#719e07>]</span>, proto <span style=color:#719e07>=</span> (<span style=color:#dc322f>byte</span>) (flag <span style=color:#719e07>&amp;</span> SERIALIZATION_MASK);
</span></span><span style=display:flex><span>        Serialization s <span style=color:#719e07>=</span> CodecSupport.getSerialization(channel.getUrl(), proto);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取调用编号</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>long</span> id <span style=color:#719e07>=</span> Bytes.bytes2long(header, 4);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 通过逻辑与运算得到调用类型，0 - Response，1 - Request</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> ((flag <span style=color:#719e07>&amp;</span> FLAG_REQUEST) <span style=color:#719e07>==</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对响应结果进行解码，得到 Response 对象。这个非本节内容，后面再分析</span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 创建 Request 对象</span>
</span></span><span style=display:flex><span>            Request req <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> Request(id);
</span></span><span style=display:flex><span>            req.setVersion(Version.getProtocolVersion());
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 通过逻辑与运算得到通信方式，并设置到 Request 对象中</span>
</span></span><span style=display:flex><span>            req.setTwoWay((flag <span style=color:#719e07>&amp;</span> FLAG_TWOWAY) <span style=color:#719e07>!=</span> 0);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 通过位运算检测数据包是否为事件类型</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> ((flag <span style=color:#719e07>&amp;</span> FLAG_EVENT) <span style=color:#719e07>!=</span> 0) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 设置心跳事件到 Request 对象中</span>
</span></span><span style=display:flex><span>                req.setEvent(Request.HEARTBEAT_EVENT);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                Object data;
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span> (req.isHeartbeat()) {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 对心跳包进行解码，该方法已被标注为废弃</span>
</span></span><span style=display:flex><span>                    data <span style=color:#719e07>=</span> decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));
</span></span><span style=display:flex><span>                } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (req.isEvent()) {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 对事件数据进行解码</span>
</span></span><span style=display:flex><span>                    data <span style=color:#719e07>=</span> decodeEventData(channel, deserialize(s, channel.getUrl(), is));
</span></span><span style=display:flex><span>                } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                    DecodeableRpcInvocation inv;
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 根据 url 参数判断是否在 IO 线程上对消息体进行解码</span>
</span></span><span style=display:flex><span>                    <span style=color:#719e07>if</span> (channel.getUrl().getParameter(
</span></span><span style=display:flex><span>                            Constants.DECODE_IN_IO_THREAD_KEY,
</span></span><span style=display:flex><span>                            Constants.DEFAULT_DECODE_IN_IO_THREAD)) {
</span></span><span style=display:flex><span>                        inv <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> DecodeableRpcInvocation(channel, req, is, proto);
</span></span><span style=display:flex><span>                        <span style=color:#586e75>// 在当前线程，也就是 IO 线程上进行后续的解码工作。此工作完成后，可将</span>
</span></span><span style=display:flex><span>                        <span style=color:#586e75>// 调用方法名、attachment、以及调用参数解析出来</span>
</span></span><span style=display:flex><span>                        inv.decode();
</span></span><span style=display:flex><span>                    } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#586e75>// 仅创建 DecodeableRpcInvocation 对象，但不在当前线程上执行解码逻辑</span>
</span></span><span style=display:flex><span>                        inv <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> DecodeableRpcInvocation(channel, req,
</span></span><span style=display:flex><span>                                <span style=color:#719e07>new</span> UnsafeByteArrayInputStream(readMessageData(is)), proto);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    data <span style=color:#719e07>=</span> inv;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 设置 data 到 Request 对象中</span>
</span></span><span style=display:flex><span>                req.setData(data);
</span></span><span style=display:flex><span>            } <span style=color:#719e07>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 若解码过程中出现异常，则将 broken 字段设为 true，</span>
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 并将异常对象设置到 Reqeust 对象中</span>
</span></span><span style=display:flex><span>                req.setBroken(<span style=color:#cb4b16>true</span>);
</span></span><span style=display:flex><span>                req.setData(t);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> req;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上，decodeBody 对部分字段进行了解码，并将解码得到的字段封装到 Request 中。随后会调用 DecodeableRpcInvocation 的 decode 方法进行后续的解码工作。此工作完成后，可将调用方法名、attachment、以及调用参数解析出来。下面我们来看一下 DecodeableRpcInvocation 的 decode 方法逻辑。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DecodeableRpcInvocation</span> <span style=color:#268bd2>extends</span> RpcInvocation <span style=color:#268bd2>implements</span> Codec, Decodeable {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	<span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Object <span style=color:#268bd2>decode</span>(Channel channel, InputStream input) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        ObjectInput in <span style=color:#719e07>=</span> CodecSupport.getSerialization(channel.getUrl(), serializationType)
</span></span><span style=display:flex><span>                .deserialize(channel.getUrl(), input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 通过反序列化得到 dubbo version，并保存到 attachments 变量中</span>
</span></span><span style=display:flex><span>        String dubboVersion <span style=color:#719e07>=</span> in.readUTF();
</span></span><span style=display:flex><span>        request.setVersion(dubboVersion);
</span></span><span style=display:flex><span>        setAttachment(Constants.DUBBO_VERSION_KEY, dubboVersion);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 通过反序列化得到 path，version，并保存到 attachments 变量中</span>
</span></span><span style=display:flex><span>        setAttachment(Constants.PATH_KEY, in.readUTF());
</span></span><span style=display:flex><span>        setAttachment(Constants.VERSION_KEY, in.readUTF());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 通过反序列化得到调用方法名</span>
</span></span><span style=display:flex><span>        setMethodName(in.readUTF());
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            Object<span style=color:#719e07>[]</span> args;
</span></span><span style=display:flex><span>            Class<span style=color:#719e07>&lt;?&gt;[]</span> pts;
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 通过反序列化得到参数类型字符串，比如 Ljava/lang/String;</span>
</span></span><span style=display:flex><span>            String desc <span style=color:#719e07>=</span> in.readUTF();
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (desc.length() <span style=color:#719e07>==</span> 0) {
</span></span><span style=display:flex><span>                pts <span style=color:#719e07>=</span> DubboCodec.EMPTY_CLASS_ARRAY;
</span></span><span style=display:flex><span>                args <span style=color:#719e07>=</span> DubboCodec.EMPTY_OBJECT_ARRAY;
</span></span><span style=display:flex><span>            } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 将 desc 解析为参数类型数组</span>
</span></span><span style=display:flex><span>                pts <span style=color:#719e07>=</span> ReflectUtils.desc2classArray(desc);
</span></span><span style=display:flex><span>                args <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> Object<span style=color:#719e07>[</span>pts.length<span style=color:#719e07>]</span>;
</span></span><span style=display:flex><span>                <span style=color:#719e07>for</span> (<span style=color:#dc322f>int</span> i <span style=color:#719e07>=</span> 0; i <span style=color:#719e07>&lt;</span> args.length; i<span style=color:#719e07>++</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                        <span style=color:#586e75>// 解析运行时参数</span>
</span></span><span style=display:flex><span>                        args<span style=color:#719e07>[</span>i<span style=color:#719e07>]</span> <span style=color:#719e07>=</span> in.readObject(pts<span style=color:#719e07>[</span>i<span style=color:#719e07>]</span>);
</span></span><span style=display:flex><span>                    } <span style=color:#719e07>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                        <span style=color:#719e07>if</span> (log.isWarnEnabled()) {
</span></span><span style=display:flex><span>                            log.warn(<span style=color:#2aa198>&#34;Decode argument failed: &#34;</span> <span style=color:#719e07>+</span> e.getMessage(), e);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置参数类型数组</span>
</span></span><span style=display:flex><span>            setParameterTypes(pts);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 通过反序列化得到原 attachment 的内容</span>
</span></span><span style=display:flex><span>            Map<span style=color:#719e07>&lt;</span>String, String<span style=color:#719e07>&gt;</span> map <span style=color:#719e07>=</span> (Map<span style=color:#719e07>&lt;</span>String, String<span style=color:#719e07>&gt;</span>) in.readObject(Map.class);
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (map <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>&amp;&amp;</span> map.size() <span style=color:#719e07>&gt;</span> 0) {
</span></span><span style=display:flex><span>                Map<span style=color:#719e07>&lt;</span>String, String<span style=color:#719e07>&gt;</span> attachment <span style=color:#719e07>=</span> getAttachments();
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span> (attachment <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>                    attachment <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> HashMap<span style=color:#719e07>&lt;</span>String, String<span style=color:#719e07>&gt;</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 将 map 与当前对象中的 attachment 集合进行融合</span>
</span></span><span style=display:flex><span>                attachment.putAll(map);
</span></span><span style=display:flex><span>                setAttachments(attachment);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对 callback 类型的参数进行处理</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>for</span> (<span style=color:#dc322f>int</span> i <span style=color:#719e07>=</span> 0; i <span style=color:#719e07>&lt;</span> args.length; i<span style=color:#719e07>++</span>) {
</span></span><span style=display:flex><span>                args<span style=color:#719e07>[</span>i<span style=color:#719e07>]</span> <span style=color:#719e07>=</span> decodeInvocationArgument(channel, <span style=color:#719e07>this</span>, pts, i, args<span style=color:#719e07>[</span>i<span style=color:#719e07>]</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置参数列表</span>
</span></span><span style=display:flex><span>            setArguments(args);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (ClassNotFoundException e) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IOException(StringUtils.toString(<span style=color:#2aa198>&#34;Read invocation data failed.&#34;</span>, e));
</span></span><span style=display:flex><span>        } <span style=color:#719e07>finally</span> {
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (in <span style=color:#719e07>instanceof</span> Cleanable) {
</span></span><span style=display:flex><span>                ((Cleanable) in).cleanup();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> <span style=color:#719e07>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的方法通过反序列化将诸如 path、version、调用方法名、参数列表等信息依次解析出来，并设置到相应的字段中，最终得到一个具有完整调用信息的 DecodeableRpcInvocation 对象。</p><p>到这里，请求数据解码的过程就分析完了。此时我们得到了一个 Request 对象，这个对象会被传送到下一个入站处理器中，我们继续往下看。</p><h4 id=232-调用服务>2.3.2 调用服务</h4><p>解码器将数据包解析成 Request 对象后，NettyHandler 的 messageReceived 方法紧接着会收到这个对象，并将这个对象继续向下传递。这期间该对象会被依次传递给 NettyServer、MultiMessageHandler、HeartbeatHandler 以及 AllChannelHandler。最后由 AllChannelHandler 将该对象封装到 Runnable 实现类对象中，并将 Runnable 放入线程池中执行后续的调用逻辑。整个调用栈如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>NettyHandler#messageReceived(ChannelHandlerContext, MessageEvent)
</span></span><span style=display:flex><span>  —&gt; AbstractPeer#received(Channel, Object)
</span></span><span style=display:flex><span>    —&gt; MultiMessageHandler#received(Channel, Object)
</span></span><span style=display:flex><span>      —&gt; HeartbeatHandler#received(Channel, Object)
</span></span><span style=display:flex><span>        —&gt; AllChannelHandler#received(Channel, Object)
</span></span><span style=display:flex><span>          —&gt; ExecutorService#execute(Runnable)    // 由线程池执行后续的调用逻辑
</span></span></code></pre></div><p>考虑到篇幅，以及很多中间调用的逻辑并非十分重要，所以这里就不对调用栈中的每个方法都进行分析了。这里我们直接分析调用栈中的分析第一个和最后一个调用方法逻辑。如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>@Sharable</span>
</span></span><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>NettyHandler</span> <span style=color:#268bd2>extends</span> SimpleChannelHandler {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Map<span style=color:#719e07>&lt;</span>String, Channel<span style=color:#719e07>&gt;</span> channels <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> ConcurrentHashMap<span style=color:#719e07>&lt;</span>String, Channel<span style=color:#719e07>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> URL url;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> ChannelHandler handler;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>NettyHandler</span>(URL url, ChannelHandler handler) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (url <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IllegalArgumentException(<span style=color:#2aa198>&#34;url == null&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (handler <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IllegalArgumentException(<span style=color:#2aa198>&#34;handler == null&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.url <span style=color:#719e07>=</span> url;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 这里的 handler 类型为 NettyServer</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.handler <span style=color:#719e07>=</span> handler;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	<span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>messageReceived</span>(ChannelHandlerContext ctx, MessageEvent e) <span style=color:#268bd2>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取 NettyChannel</span>
</span></span><span style=display:flex><span>        NettyChannel channel <span style=color:#719e07>=</span> NettyChannel.getOrAddChannel(ctx.getChannel(), url, handler);
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 继续向下调用</span>
</span></span><span style=display:flex><span>            handler.received(channel, e.getMessage());
</span></span><span style=display:flex><span>        } <span style=color:#719e07>finally</span> {
</span></span><span style=display:flex><span>            NettyChannel.removeChannelIfDisconnected(ctx.getChannel());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上，NettyHandler 中的 messageReceived 逻辑比较简单。首先根据一些信息获取 NettyChannel 实例，然后将 NettyChannel 实例以及 Request 对象向下传递。下面再来看看 AllChannelHandler 的逻辑，在详细分析代码之前，我们先来了解一下 Dubbo 中的线程派发模型。</p><h5 id=2321-线程派发模型>2.3.2.1 线程派发模型</h5><p>Dubbo 将底层通信框架中接收请求的线程称为 IO 线程。如果一些事件处理逻辑可以很快执行完，比如只在内存打一个标记，此时直接在 IO 线程上执行该段逻辑即可。但如果事件的处理逻辑比较耗时，比如该段逻辑会发起数据库查询或者 HTTP 请求。此时我们就不应该让事件处理逻辑在 IO 线程上执行，而是应该派发到线程池中去执行。原因也很简单，IO 线程主要用于接收请求，如果 IO 线程被占满，将导致它不能接收新的请求。</p><p>以上就是线程派发的背景，下面我们再来通过 Dubbo 调用图，看一下线程派发器所处的位置。</p><p><img src=/imgs/dev/dispatcher-location.jpg alt=img></p><p>如上图，红框中的 Dispatcher 就是线程派发器。需要说明的是，Dispatcher 真实的职责创建具有线程派发能力的 ChannelHandler，比如 AllChannelHandler、MessageOnlyChannelHandler 和 ExecutionChannelHandler 等，其本身并不具备线程派发能力。Dubbo 支持 5 种不同的线程派发策略，下面通过一个表格列举一下。</p><table><thead><tr><th>策略</th><th>用途</th></tr></thead><tbody><tr><td>all</td><td>所有消息都派发到线程池，包括请求，响应，连接事件，断开事件等</td></tr><tr><td>direct</td><td>所有消息都不派发到线程池，全部在 IO 线程上直接执行</td></tr><tr><td>message</td><td>只有<strong>请求</strong>和<strong>响应</strong>消息派发到线程池，其它消息均在 IO 线程上执行</td></tr><tr><td>execution</td><td>只有<strong>请求</strong>消息派发到线程池，不含响应。其它消息均在 IO 线程上执行</td></tr><tr><td>connection</td><td>在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池</td></tr></tbody></table><p>默认配置下，Dubbo 使用 <code>all</code> 派发策略，即将所有的消息都派发到线程池中。下面我们来分析一下 AllChannelHandler 的代码。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>AllChannelHandler</span> <span style=color:#268bd2>extends</span> WrappedChannelHandler {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>AllChannelHandler</span>(ChannelHandler handler, URL url) {
</span></span><span style=display:flex><span>        <span style=color:#268bd2>super</span>(handler, url);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>/** 处理连接事件 */</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>connected</span>(Channel channel) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取线程池</span>
</span></span><span style=display:flex><span>        ExecutorService cexecutor <span style=color:#719e07>=</span> getExecutorService();
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 将连接事件派发到线程池中处理</span>
</span></span><span style=display:flex><span>            cexecutor.execute(<span style=color:#719e07>new</span> ChannelEventRunnable(channel, handler, ChannelState.CONNECTED));
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> ExecutionException(..., <span style=color:#2aa198>&#34; error when process connected event .&#34;</span>, t);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>/** 处理断开事件 */</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>disconnected</span>(Channel channel) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        ExecutorService cexecutor <span style=color:#719e07>=</span> getExecutorService();
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            cexecutor.execute(<span style=color:#719e07>new</span> ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED));
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> ExecutionException(..., <span style=color:#2aa198>&#34;error when process disconnected event .&#34;</span>, t);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>/** 处理请求和响应消息，这里的 message 变量类型可能是 Request，也可能是 Response */</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>received</span>(Channel channel, Object message) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        ExecutorService cexecutor <span style=color:#719e07>=</span> getExecutorService();
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 将请求和响应消息派发到线程池中处理</span>
</span></span><span style=display:flex><span>            cexecutor.execute(<span style=color:#719e07>new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span>(message <span style=color:#719e07>instanceof</span> Request <span style=color:#719e07>&amp;&amp;</span> t <span style=color:#719e07>instanceof</span> RejectedExecutionException){
</span></span><span style=display:flex><span>                Request request <span style=color:#719e07>=</span> (Request)message;
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 如果通信方式为双向通信，此时将 Server side ... threadpool is exhausted </span>
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 错误信息封装到 Response 中，并返回给服务消费方。</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span>(request.isTwoWay()){
</span></span><span style=display:flex><span>                    String msg <span style=color:#719e07>=</span> <span style=color:#2aa198>&#34;Server side(&#34;</span> <span style=color:#719e07>+</span> url.getIp() <span style=color:#719e07>+</span> <span style=color:#2aa198>&#34;,&#34;</span> <span style=color:#719e07>+</span> url.getPort() 
</span></span><span style=display:flex><span>                        <span style=color:#719e07>+</span> <span style=color:#2aa198>&#34;) threadpool is exhausted ,detail msg:&#34;</span> <span style=color:#719e07>+</span> t.getMessage();
</span></span><span style=display:flex><span>                    Response response <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> Response(request.getId(), request.getVersion());
</span></span><span style=display:flex><span>                    response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR);
</span></span><span style=display:flex><span>                    response.setErrorMessage(msg);
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 返回包含错误信息的 Response 对象</span>
</span></span><span style=display:flex><span>                    channel.send(response);
</span></span><span style=display:flex><span>                    <span style=color:#719e07>return</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> ExecutionException(..., <span style=color:#2aa198>&#34; error when process received event .&#34;</span>, t);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>/** 处理异常信息 */</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>caught</span>(Channel channel, Throwable exception) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        ExecutorService cexecutor <span style=color:#719e07>=</span> getExecutorService();
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            cexecutor.execute(<span style=color:#719e07>new</span> ChannelEventRunnable(channel, handler, ChannelState.CAUGHT, exception));
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> ExecutionException(..., <span style=color:#2aa198>&#34;error when process caught event ...&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上，请求对象会被封装 ChannelEventRunnable 中，ChannelEventRunnable 将会是服务调用过程的新起点。所以接下来我们以 ChannelEventRunnable 为起点向下探索。</p><h5 id=2322-调用服务>2.3.2.2 调用服务</h5><p>本小节，我们从 ChannelEventRunnable 开始分析，该类的主要代码如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>ChannelEventRunnable</span> <span style=color:#268bd2>implements</span> Runnable {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> ChannelHandler handler;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Channel channel;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> ChannelState state;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Throwable exception;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Object message;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 检测通道状态，对于请求或响应消息，此时 state = RECEIVED</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (state <span style=color:#719e07>==</span> ChannelState.RECEIVED) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 将 channel 和 message 传给 ChannelHandler 对象，进行后续的调用</span>
</span></span><span style=display:flex><span>                handler.received(channel, message);
</span></span><span style=display:flex><span>            } <span style=color:#719e07>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                logger.warn(<span style=color:#2aa198>&#34;... operation error, channel is ... message is ...&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } 
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 其他消息类型通过 switch 进行处理</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#719e07>switch</span> (state) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> CONNECTED:
</span></span><span style=display:flex><span>                <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                    handler.connected(channel);
</span></span><span style=display:flex><span>                } <span style=color:#719e07>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                    logger.warn(<span style=color:#2aa198>&#34;... operation error, channel is ...&#34;</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> DISCONNECTED:
</span></span><span style=display:flex><span>                <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> SENT:
</span></span><span style=display:flex><span>                <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> CAUGHT:
</span></span><span style=display:flex><span>                <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>default</span>:
</span></span><span style=display:flex><span>                logger.warn(<span style=color:#2aa198>&#34;unknown state: &#34;</span> <span style=color:#719e07>+</span> state <span style=color:#719e07>+</span> <span style=color:#2aa198>&#34;, message is &#34;</span> <span style=color:#719e07>+</span> message);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上，请求和响应消息出现频率明显比其他类型消息高，所以这里对该类型的消息进行了针对性判断。ChannelEventRunnable 仅是一个中转站，它的 run 方法中并不包含具体的调用逻辑，仅用于将参数传给其他 ChannelHandler 对象进行处理，该对象类型为 DecodeHandler。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DecodeHandler</span> <span style=color:#268bd2>extends</span> AbstractChannelHandlerDelegate {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>DecodeHandler</span>(ChannelHandler handler) {
</span></span><span style=display:flex><span>        <span style=color:#268bd2>super</span>(handler);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>received</span>(Channel channel, Object message) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> Decodeable) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对 Decodeable 接口实现类对象进行解码</span>
</span></span><span style=display:flex><span>            decode(message);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> Request) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对 Request 的 data 字段进行解码</span>
</span></span><span style=display:flex><span>            decode(((Request) message).getData());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> Response) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对 Request 的 result 字段进行解码</span>
</span></span><span style=display:flex><span>            decode(((Response) message).getResult());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 执行后续逻辑</span>
</span></span><span style=display:flex><span>        handler.received(channel, message);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>decode</span>(Object message) {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// Decodeable 接口目前有两个实现类，</span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 分别为 DecodeableRpcInvocation 和 DecodeableRpcResult</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (message <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>&amp;&amp;</span> message <span style=color:#719e07>instanceof</span> Decodeable) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 执行解码逻辑</span>
</span></span><span style=display:flex><span>                ((Decodeable) message).decode();
</span></span><span style=display:flex><span>            } <span style=color:#719e07>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span> (log.isWarnEnabled()) {
</span></span><span style=display:flex><span>                    log.warn(<span style=color:#2aa198>&#34;Call Decodeable.decode failed: &#34;</span> <span style=color:#719e07>+</span> e.getMessage(), e);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>DecodeHandler 主要是包含了一些解码逻辑。2.2.1 节分析请求解码时说过，请求解码可在 IO 线程上执行，也可在线程池中执行，这个取决于运行时配置。DecodeHandler 存在的意义就是保证请求或响应对象可在线程池中被解码。解码完毕后，完全解码后的 Request 对象会继续向后传递，下一站是 HeaderExchangeHandler。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>HeaderExchangeHandler</span> <span style=color:#268bd2>implements</span> ChannelHandlerDelegate {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> ExchangeHandler handler;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>HeaderExchangeHandler</span>(ExchangeHandler handler) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (handler <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IllegalArgumentException(<span style=color:#2aa198>&#34;handler == null&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.handler <span style=color:#719e07>=</span> handler;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>received</span>(Channel channel, Object message) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());
</span></span><span style=display:flex><span>        ExchangeChannel exchangeChannel <span style=color:#719e07>=</span> HeaderExchangeChannel.getOrAddChannel(channel);
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 处理请求对象</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> Request) {
</span></span><span style=display:flex><span>                Request request <span style=color:#719e07>=</span> (Request) message;
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span> (request.isEvent()) {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 处理事件</span>
</span></span><span style=display:flex><span>                    handlerEvent(channel, request);
</span></span><span style=display:flex><span>                } 
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 处理普通的请求</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 双向通信</span>
</span></span><span style=display:flex><span>                    <span style=color:#719e07>if</span> (request.isTwoWay()) {
</span></span><span style=display:flex><span>                        <span style=color:#586e75>// 向后调用服务，并得到调用结果</span>
</span></span><span style=display:flex><span>                        Response response <span style=color:#719e07>=</span> handleRequest(exchangeChannel, request);
</span></span><span style=display:flex><span>                        <span style=color:#586e75>// 将调用结果返回给服务消费端</span>
</span></span><span style=display:flex><span>                        channel.send(response);
</span></span><span style=display:flex><span>                    } 
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 如果是单向通信，仅向后调用指定服务即可，无需返回调用结果</span>
</span></span><span style=display:flex><span>                    <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                        handler.received(exchangeChannel, request.getData());
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }      
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 处理响应对象，服务消费方会执行此处逻辑，后面分析</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> Response) {
</span></span><span style=display:flex><span>                handleResponse(channel, (Response) message);
</span></span><span style=display:flex><span>            } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> String) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// telnet 相关，忽略</span>
</span></span><span style=display:flex><span>            } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                handler.received(exchangeChannel, message);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#719e07>finally</span> {
</span></span><span style=display:flex><span>            HeaderExchangeChannel.removeChannelIfDisconnected(channel);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Response <span style=color:#268bd2>handleRequest</span>(ExchangeChannel channel, Request req) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        Response res <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> Response(req.getId(), req.getVersion());
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 检测请求是否合法，不合法则返回状态码为 BAD_REQUEST 的响应</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (req.isBroken()) {
</span></span><span style=display:flex><span>            Object data <span style=color:#719e07>=</span> req.getData();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            String msg;
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (data <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>)
</span></span><span style=display:flex><span>                msg <span style=color:#719e07>=</span> <span style=color:#cb4b16>null</span>;
</span></span><span style=display:flex><span>            <span style=color:#719e07>else</span> <span style=color:#719e07>if</span>
</span></span><span style=display:flex><span>                (data <span style=color:#719e07>instanceof</span> Throwable) msg <span style=color:#719e07>=</span> StringUtils.toString((Throwable) data);
</span></span><span style=display:flex><span>            <span style=color:#719e07>else</span>
</span></span><span style=display:flex><span>                msg <span style=color:#719e07>=</span> data.toString();
</span></span><span style=display:flex><span>            res.setErrorMessage(<span style=color:#2aa198>&#34;Fail to decode request due to: &#34;</span> <span style=color:#719e07>+</span> msg);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置 BAD_REQUEST 状态</span>
</span></span><span style=display:flex><span>            res.setStatus(Response.BAD_REQUEST);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> res;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取 data 字段值，也就是 RpcInvocation 对象</span>
</span></span><span style=display:flex><span>        Object msg <span style=color:#719e07>=</span> req.getData();
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 继续向下调用</span>
</span></span><span style=display:flex><span>            Object result <span style=color:#719e07>=</span> handler.reply(channel, msg);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置 OK 状态码</span>
</span></span><span style=display:flex><span>            res.setStatus(Response.OK);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置调用结果</span>
</span></span><span style=display:flex><span>            res.setResult(result);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 若调用过程出现异常，则设置 SERVICE_ERROR，表示服务端异常</span>
</span></span><span style=display:flex><span>            res.setStatus(Response.SERVICE_ERROR);
</span></span><span style=display:flex><span>            res.setErrorMessage(StringUtils.toString(e));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>到这里，我们看到了比较清晰的请求和响应逻辑。对于双向通信，HeaderExchangeHandler 首先向后进行调用，得到调用结果。然后将调用结果封装到 Response 对象中，最后再将该对象返回给服务消费方。如果请求不合法，或者调用失败，则将错误信息封装到 Response 对象中，并返回给服务消费方。接下来我们继续向后分析，把剩余的调用过程分析完。下面分析定义在 DubboProtocol 类中的匿名类对象逻辑，如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DubboProtocol</span> <span style=color:#268bd2>extends</span> AbstractProtocol {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> String NAME <span style=color:#719e07>=</span> <span style=color:#2aa198>&#34;dubbo&#34;</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> ExchangeHandler requestHandler <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> ExchangeHandlerAdapter() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>public</span> Object <span style=color:#268bd2>reply</span>(ExchangeChannel channel, Object message) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> Invocation) {
</span></span><span style=display:flex><span>                Invocation inv <span style=color:#719e07>=</span> (Invocation) message;
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 获取 Invoker 实例</span>
</span></span><span style=display:flex><span>                Invoker<span style=color:#719e07>&lt;?&gt;</span> invoker <span style=color:#719e07>=</span> getInvoker(channel, inv);
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span> (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 回调相关，忽略</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 通过 Invoker 调用具体的服务</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>return</span> invoker.invoke(inv);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RemotingException(channel, <span style=color:#2aa198>&#34;Unsupported request: ...&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 忽略其他方法</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Invoker<span style=color:#719e07>&lt;?&gt;</span> getInvoker(Channel channel, Invocation inv) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 忽略回调和本地存根相关逻辑</span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#dc322f>int</span> port <span style=color:#719e07>=</span> channel.getLocalAddress().getPort();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 计算 service key，格式为 groupName/serviceName:serviceVersion:port。比如：</span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>//   dubbo/com.alibaba.dubbo.demo.DemoService:1.0.0:20880</span>
</span></span><span style=display:flex><span>        String serviceKey <span style=color:#719e07>=</span> serviceKey(port, path, inv.getAttachments().get(Constants.VERSION_KEY), inv.getAttachments().get(Constants.GROUP_KEY));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 从 exporterMap 查找与 serviceKey 相对应的 DubboExporter 对象，</span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 服务导出过程中会将 &lt;serviceKey, DubboExporter&gt; 映射关系存储到 exporterMap 集合中</span>
</span></span><span style=display:flex><span>        DubboExporter<span style=color:#719e07>&lt;?&gt;</span> exporter <span style=color:#719e07>=</span> (DubboExporter<span style=color:#719e07>&lt;?&gt;</span>) exporterMap.get(serviceKey);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (exporter <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>)
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RemotingException(channel, <span style=color:#2aa198>&#34;Not found exported service ...&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取 Invoker 对象，并返回</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> exporter.getInvoker();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 忽略其他方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上逻辑用于获取与指定服务对应的 Invoker 实例，并通过 Invoker 的 invoke 方法调用服务逻辑。invoke 方法定义在 AbstractProxyInvoker 中，代码如下。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>abstract</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>AbstractProxyInvoker</span><span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> <span style=color:#268bd2>implements</span> Invoker<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Result <span style=color:#268bd2>invoke</span>(Invocation invocation) <span style=color:#268bd2>throws</span> RpcException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 调用 doInvoke 执行后续的调用，并将调用结果封装到 RpcResult 中，并</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> <span style=color:#719e07>new</span> RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()));
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (InvocationTargetException e) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> <span style=color:#719e07>new</span> RpcResult(e.getTargetException());
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RpcException(<span style=color:#2aa198>&#34;Failed to invoke remote proxy method ...&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>abstract</span> Object <span style=color:#268bd2>doInvoke</span>(T proxy, String methodName, Class<span style=color:#719e07>&lt;?&gt;[]</span> parameterTypes, Object<span style=color:#719e07>[]</span> arguments) <span style=color:#268bd2>throws</span> Throwable;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上，doInvoke 是一个抽象方法，这个需要由具体的 Invoker 实例实现。Invoker 实例是在运行时通过 JavassistProxyFactory 创建的，创建逻辑如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>JavassistProxyFactory</span> <span style=color:#268bd2>extends</span> AbstractProxyFactory {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略其他方法</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> Invoker<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> <span style=color:#268bd2>getInvoker</span>(T proxy, Class<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> type, URL url) {
</span></span><span style=display:flex><span>        <span style=color:#268bd2>final</span> Wrapper wrapper <span style=color:#719e07>=</span> Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span style=color:#2aa198>&#39;$&#39;</span>) <span style=color:#719e07>&lt;</span> 0 <span style=color:#719e07>?</span> proxy.getClass() : type);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 创建匿名类对象</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> <span style=color:#719e07>new</span> AbstractProxyInvoker<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span>(proxy, type, url) {
</span></span><span style=display:flex><span>            <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#268bd2>protected</span> Object <span style=color:#268bd2>doInvoke</span>(T proxy, String methodName,
</span></span><span style=display:flex><span>                                      Class<span style=color:#719e07>&lt;?&gt;[]</span> parameterTypes,
</span></span><span style=display:flex><span>                                      Object<span style=color:#719e07>[]</span> arguments) <span style=color:#268bd2>throws</span> Throwable {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 调用 invokeMethod 方法进行后续的调用</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Wrapper 是一个抽象类，其中 invokeMethod 是一个抽象方法。Dubbo 会在运行时通过 Javassist 框架为 Wrapper 生成实现类，并实现 invokeMethod 方法，该方法最终会根据调用信息调用具体的服务。以 DemoServiceImpl 为例，Javassist 为其生成的代理类如下。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#586e75>/** Wrapper0 是在运行时生成的，大家可使用 Arthas 进行反编译 */</span>
</span></span><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>Wrapper0</span> <span style=color:#268bd2>extends</span> Wrapper <span style=color:#268bd2>implements</span> ClassGenerator.DC {
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>static</span> String<span style=color:#719e07>[]</span> pns;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>static</span> Map pts;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>static</span> String<span style=color:#719e07>[]</span> mns;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>static</span> String<span style=color:#719e07>[]</span> dmns;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>static</span> Class<span style=color:#719e07>[]</span> mts0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略其他方法</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Object <span style=color:#268bd2>invokeMethod</span>(Object object, String string, Class<span style=color:#719e07>[]</span> arrclass, Object<span style=color:#719e07>[]</span> arrobject) <span style=color:#268bd2>throws</span> InvocationTargetException {
</span></span><span style=display:flex><span>        DemoService demoService;
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 类型转换</span>
</span></span><span style=display:flex><span>            demoService <span style=color:#719e07>=</span> (DemoService)object;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>catch</span> (Throwable throwable) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IllegalArgumentException(throwable);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 根据方法名调用指定的方法</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (<span style=color:#2aa198>&#34;sayHello&#34;</span>.equals(string) <span style=color:#719e07>&amp;&amp;</span> arrclass.length <span style=color:#719e07>==</span> 1) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>return</span> demoService.sayHello((String)arrobject<span style=color:#719e07>[</span>0<span style=color:#719e07>]</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>catch</span> (Throwable throwable) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> InvocationTargetException(throwable);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> NoSuchMethodException(<span style=color:#719e07>new</span> StringBuffer().append(<span style=color:#2aa198>&#34;Not found method \&#34;&#34;</span>).append(string).append(<span style=color:#2aa198>&#34;\&#34; in class com.alibaba.dubbo.demo.DemoService.&#34;</span>).toString());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>到这里，整个服务调用过程就分析完了。最后把调用过程贴出来，如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>ChannelEventRunnable#run()
</span></span><span style=display:flex><span>  —&gt; DecodeHandler#received(Channel, Object)
</span></span><span style=display:flex><span>    —&gt; HeaderExchangeHandler#received(Channel, Object)
</span></span><span style=display:flex><span>      —&gt; HeaderExchangeHandler#handleRequest(ExchangeChannel, Request)
</span></span><span style=display:flex><span>        —&gt; DubboProtocol.requestHandler#reply(ExchangeChannel, Object)
</span></span><span style=display:flex><span>          —&gt; Filter#invoke(Invoker, Invocation)
</span></span><span style=display:flex><span>            —&gt; AbstractProxyInvoker#invoke(Invocation)
</span></span><span style=display:flex><span>              —&gt; Wrapper0#invokeMethod(Object, String, Class[], Object[])
</span></span><span style=display:flex><span>                —&gt; DemoServiceImpl#sayHello(String)
</span></span></code></pre></div><h3 id=24-服务提供方返回调用结果>2.4 服务提供方返回调用结果</h3><p>服务提供方调用指定服务后，会将调用结果封装到 Response 对象中，并将该对象返回给服务消费方。服务提供方也是通过 NettyChannel 的 send 方法将 Response 对象返回，这个方法在 2.2.1 节分析过，这里就不在重复分析了。本节我们仅需关注 Response 对象的编码过程即可，这里仍然省略一些中间调用，直接分析具体的编码逻辑。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>ExchangeCodec</span> <span style=color:#268bd2>extends</span> TelnetCodec {
</span></span><span style=display:flex><span>	<span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>encode</span>(Channel channel, ChannelBuffer buffer, Object msg) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (msg <span style=color:#719e07>instanceof</span> Request) {
</span></span><span style=display:flex><span>            encodeRequest(channel, buffer, (Request) msg);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (msg <span style=color:#719e07>instanceof</span> Response) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对响应对象进行编码</span>
</span></span><span style=display:flex><span>            encodeResponse(channel, buffer, (Response) msg);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#268bd2>super</span>.encode(channel, buffer, msg);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>encodeResponse</span>(Channel channel, ChannelBuffer buffer, Response res) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#dc322f>int</span> savedWriteIndex <span style=color:#719e07>=</span> buffer.writerIndex();
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            Serialization serialization <span style=color:#719e07>=</span> getSerialization(channel);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 创建消息头字节数组</span>
</span></span><span style=display:flex><span>            <span style=color:#dc322f>byte</span><span style=color:#719e07>[]</span> header <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> <span style=color:#dc322f>byte</span><span style=color:#719e07>[</span>HEADER_LENGTH<span style=color:#719e07>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置魔数</span>
</span></span><span style=display:flex><span>            Bytes.short2bytes(MAGIC, header);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置序列化器编号</span>
</span></span><span style=display:flex><span>            header<span style=color:#719e07>[</span>2<span style=color:#719e07>]</span> <span style=color:#719e07>=</span> serialization.getContentTypeId();
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (res.isHeartbeat()) header<span style=color:#719e07>[</span>2<span style=color:#719e07>]</span> <span style=color:#719e07>|=</span> FLAG_EVENT;
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 获取响应状态</span>
</span></span><span style=display:flex><span>            <span style=color:#dc322f>byte</span> status <span style=color:#719e07>=</span> res.getStatus();
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置响应状态</span>
</span></span><span style=display:flex><span>            header<span style=color:#719e07>[</span>3<span style=color:#719e07>]</span> <span style=color:#719e07>=</span> status;
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置请求编号</span>
</span></span><span style=display:flex><span>            Bytes.long2bytes(res.getId(), header, 4);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 更新 writerIndex，为消息头预留 16 个字节的空间</span>
</span></span><span style=display:flex><span>            buffer.writerIndex(savedWriteIndex <span style=color:#719e07>+</span> HEADER_LENGTH);
</span></span><span style=display:flex><span>            ChannelBufferOutputStream bos <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> ChannelBufferOutputStream(buffer);
</span></span><span style=display:flex><span>            ObjectOutput out <span style=color:#719e07>=</span> serialization.serialize(channel.getUrl(), bos);
</span></span><span style=display:flex><span>           
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (status <span style=color:#719e07>==</span> Response.OK) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span> (res.isHeartbeat()) {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 对心跳响应结果进行序列化，已废弃</span>
</span></span><span style=display:flex><span>                    encodeHeartbeatData(channel, out, res.getResult());
</span></span><span style=display:flex><span>                } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 对调用结果进行序列化</span>
</span></span><span style=display:flex><span>                    encodeResponseData(channel, out, res.getResult(), res.getVersion());
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#719e07>else</span> { 
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 对错误信息进行序列化</span>
</span></span><span style=display:flex><span>                out.writeUTF(res.getErrorMessage())
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            out.flushBuffer();
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (out <span style=color:#719e07>instanceof</span> Cleanable) {
</span></span><span style=display:flex><span>                ((Cleanable) out).cleanup();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            bos.flush();
</span></span><span style=display:flex><span>            bos.close();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 获取写入的字节数，也就是消息体长度</span>
</span></span><span style=display:flex><span>            <span style=color:#dc322f>int</span> len <span style=color:#719e07>=</span> bos.writtenBytes();
</span></span><span style=display:flex><span>            checkPayload(channel, len);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 将消息体长度写入到消息头中</span>
</span></span><span style=display:flex><span>            Bytes.int2bytes(len, header, 12);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 将 buffer 指针移动到 savedWriteIndex，为写消息头做准备</span>
</span></span><span style=display:flex><span>            buffer.writerIndex(savedWriteIndex);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 从 savedWriteIndex 下标处写入消息头</span>
</span></span><span style=display:flex><span>            buffer.writeBytes(header); 
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置新的 writerIndex，writerIndex = 原写下标 + 消息头长度 + 消息体长度</span>
</span></span><span style=display:flex><span>            buffer.writerIndex(savedWriteIndex <span style=color:#719e07>+</span> HEADER_LENGTH <span style=color:#719e07>+</span> len);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 异常处理逻辑不是很难理解，但是代码略多，这里忽略了</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DubboCodec</span> <span style=color:#268bd2>extends</span> ExchangeCodec <span style=color:#268bd2>implements</span> Codec2 {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	<span style=color:#268bd2>protected</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>encodeResponseData</span>(Channel channel, ObjectOutput out, Object data, String version) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        Result result <span style=color:#719e07>=</span> (Result) data;
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 检测当前协议版本是否支持带有 attachment 集合的 Response 对象</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>boolean</span> attach <span style=color:#719e07>=</span> Version.isSupportResponseAttachment(version);
</span></span><span style=display:flex><span>        Throwable th <span style=color:#719e07>=</span> result.getException();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 异常信息为空</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (th <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            Object ret <span style=color:#719e07>=</span> result.getValue();
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 调用结果为空</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (ret <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 序列化响应类型</span>
</span></span><span style=display:flex><span>                out.writeByte(attach <span style=color:#719e07>?</span> RESPONSE_NULL_VALUE_WITH_ATTACHMENTS : RESPONSE_NULL_VALUE);
</span></span><span style=display:flex><span>            } 
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 调用结果非空</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 序列化响应类型</span>
</span></span><span style=display:flex><span>                out.writeByte(attach <span style=color:#719e07>?</span> RESPONSE_VALUE_WITH_ATTACHMENTS : RESPONSE_VALUE);
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 序列化调用结果</span>
</span></span><span style=display:flex><span>                out.writeObject(ret);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } 
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 异常信息非空</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 序列化响应类型</span>
</span></span><span style=display:flex><span>            out.writeByte(attach <span style=color:#719e07>?</span> RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS : RESPONSE_WITH_EXCEPTION);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 序列化异常对象</span>
</span></span><span style=display:flex><span>            out.writeObject(th);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (attach) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 记录 Dubbo 协议版本</span>
</span></span><span style=display:flex><span>            result.getAttachments().put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 序列化 attachments 集合</span>
</span></span><span style=display:flex><span>            out.writeObject(result.getAttachments());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上就是 Response 对象编码的过程，和前面分析的 Request 对象编码过程很相似。如果大家能看 Request 对象的编码逻辑，那么这里的 Response 对象的编码逻辑也不难理解，就不多说了。接下来我们再来分析双向通信的最后一环 —— 服务消费方接收调用结果。</p><h3 id=25-服务消费方接收调用结果>2.5 服务消费方接收调用结果</h3><p>服务消费方在收到响应数据后，首先要做的事情是对响应数据进行解码，得到 Response 对象。然后再将该对象传递给下一个入站处理器，这个入站处理器就是 NettyHandler。接下来 NettyHandler 会将这个对象继续向下传递，最后 AllChannelHandler 的 received 方法会收到这个对象，并将这个对象派发到线程池中。这个过程和服务提供方接收请求的过程是一样的，因此这里就不重复分析了。本节我们重点分析两个方面的内容，一是响应数据的解码过程，二是 Dubbo 如何将调用结果传递给用户线程的。下面先来分析响应数据的解码过程。</p><h4 id=251-响应数据解码>2.5.1 响应数据解码</h4><p>响应数据解码逻辑主要的逻辑封装在 DubboCodec 中，我们直接分析这个类的代码。如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DubboCodec</span> <span style=color:#268bd2>extends</span> ExchangeCodec <span style=color:#268bd2>implements</span> Codec2 {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> Object <span style=color:#268bd2>decodeBody</span>(Channel channel, InputStream is, <span style=color:#dc322f>byte</span><span style=color:#719e07>[]</span> header) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#dc322f>byte</span> flag <span style=color:#719e07>=</span> header<span style=color:#719e07>[</span>2<span style=color:#719e07>]</span>, proto <span style=color:#719e07>=</span> (<span style=color:#dc322f>byte</span>) (flag <span style=color:#719e07>&amp;</span> SERIALIZATION_MASK);
</span></span><span style=display:flex><span>        Serialization s <span style=color:#719e07>=</span> CodecSupport.getSerialization(channel.getUrl(), proto);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取请求编号</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>long</span> id <span style=color:#719e07>=</span> Bytes.bytes2long(header, 4);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 检测消息类型，若下面的条件成立，表明消息类型为 Response</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> ((flag <span style=color:#719e07>&amp;</span> FLAG_REQUEST) <span style=color:#719e07>==</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 创建 Response 对象</span>
</span></span><span style=display:flex><span>            Response res <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> Response(id);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 检测事件标志位</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> ((flag <span style=color:#719e07>&amp;</span> FLAG_EVENT) <span style=color:#719e07>!=</span> 0) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 设置心跳事件</span>
</span></span><span style=display:flex><span>                res.setEvent(Response.HEARTBEAT_EVENT);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 获取响应状态</span>
</span></span><span style=display:flex><span>            <span style=color:#dc322f>byte</span> status <span style=color:#719e07>=</span> header<span style=color:#719e07>[</span>3<span style=color:#719e07>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置响应状态</span>
</span></span><span style=display:flex><span>            res.setStatus(status);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 如果响应状态为 OK，表明调用过程正常</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (status <span style=color:#719e07>==</span> Response.OK) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                    Object data;
</span></span><span style=display:flex><span>                    <span style=color:#719e07>if</span> (res.isHeartbeat()) {
</span></span><span style=display:flex><span>                        <span style=color:#586e75>// 反序列化心跳数据，已废弃</span>
</span></span><span style=display:flex><span>                        data <span style=color:#719e07>=</span> decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));
</span></span><span style=display:flex><span>                    } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (res.isEvent()) {
</span></span><span style=display:flex><span>                        <span style=color:#586e75>// 反序列化事件数据</span>
</span></span><span style=display:flex><span>                        data <span style=color:#719e07>=</span> decodeEventData(channel, deserialize(s, channel.getUrl(), is));
</span></span><span style=display:flex><span>                    } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                        DecodeableRpcResult result;
</span></span><span style=display:flex><span>                        <span style=color:#586e75>// 根据 url 参数决定是否在 IO 线程上执行解码逻辑</span>
</span></span><span style=display:flex><span>                        <span style=color:#719e07>if</span> (channel.getUrl().getParameter(
</span></span><span style=display:flex><span>                                Constants.DECODE_IN_IO_THREAD_KEY,
</span></span><span style=display:flex><span>                                Constants.DEFAULT_DECODE_IN_IO_THREAD)) {
</span></span><span style=display:flex><span>                            <span style=color:#586e75>// 创建 DecodeableRpcResult 对象</span>
</span></span><span style=display:flex><span>                            result <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> DecodeableRpcResult(channel, res, is,
</span></span><span style=display:flex><span>                                    (Invocation) getRequestData(id), proto);
</span></span><span style=display:flex><span>                            <span style=color:#586e75>// 进行后续的解码工作</span>
</span></span><span style=display:flex><span>                            result.decode();
</span></span><span style=display:flex><span>                        } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                            <span style=color:#586e75>// 创建 DecodeableRpcResult 对象</span>
</span></span><span style=display:flex><span>                            result <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> DecodeableRpcResult(channel, res,
</span></span><span style=display:flex><span>                                    <span style=color:#719e07>new</span> UnsafeByteArrayInputStream(readMessageData(is)),
</span></span><span style=display:flex><span>                                    (Invocation) getRequestData(id), proto);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        data <span style=color:#719e07>=</span> result;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 设置 DecodeableRpcResult 对象到 Response 对象中</span>
</span></span><span style=display:flex><span>                    res.setResult(data);
</span></span><span style=display:flex><span>                } <span style=color:#719e07>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 解码过程中出现了错误，此时设置 CLIENT_ERROR 状态码到 Response 对象中</span>
</span></span><span style=display:flex><span>                    res.setStatus(Response.CLIENT_ERROR);
</span></span><span style=display:flex><span>                    res.setErrorMessage(StringUtils.toString(t));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } 
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 响应状态非 OK，表明调用过程出现了异常</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 反序列化异常信息，并设置到 Response 对象中</span>
</span></span><span style=display:flex><span>                res.setErrorMessage(deserialize(s, channel.getUrl(), is).readUTF());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> res;
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对请求数据进行解码，前面已分析过，此处忽略</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上就是响应数据的解码过程，上面逻辑看起来是不是似曾相识。对的，我们在前面章节分析过 DubboCodec 的 decodeBody 方法中关于请求数据的解码过程，该过程和响应数据的解码过程很相似。下面，我们继续分析调用结果的反序列化过程，如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DecodeableRpcResult</span> <span style=color:#268bd2>extends</span> RpcResult <span style=color:#268bd2>implements</span> Codec, Decodeable {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> Invocation invocation;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>decode</span>() <span style=color:#268bd2>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>hasDecoded <span style=color:#719e07>&amp;&amp;</span> channel <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>&amp;&amp;</span> inputStream <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 执行反序列化操作</span>
</span></span><span style=display:flex><span>                decode(channel, inputStream);
</span></span><span style=display:flex><span>            } <span style=color:#719e07>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 反序列化失败，设置 CLIENT_ERROR 状态到 Response 对象中</span>
</span></span><span style=display:flex><span>                response.setStatus(Response.CLIENT_ERROR);
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 设置异常信息</span>
</span></span><span style=display:flex><span>                response.setErrorMessage(StringUtils.toString(e));
</span></span><span style=display:flex><span>            } <span style=color:#719e07>finally</span> {
</span></span><span style=display:flex><span>                hasDecoded <span style=color:#719e07>=</span> <span style=color:#cb4b16>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Object <span style=color:#268bd2>decode</span>(Channel channel, InputStream input) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        ObjectInput in <span style=color:#719e07>=</span> CodecSupport.getSerialization(channel.getUrl(), serializationType)
</span></span><span style=display:flex><span>                .deserialize(channel.getUrl(), input);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 反序列化响应类型</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>byte</span> flag <span style=color:#719e07>=</span> in.readByte();
</span></span><span style=display:flex><span>        <span style=color:#719e07>switch</span> (flag) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> DubboCodec.RESPONSE_NULL_VALUE:
</span></span><span style=display:flex><span>                <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> DubboCodec.RESPONSE_VALUE:
</span></span><span style=display:flex><span>                <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> DubboCodec.RESPONSE_WITH_EXCEPTION:
</span></span><span style=display:flex><span>                <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 返回值为空，且携带了 attachments 集合</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS:
</span></span><span style=display:flex><span>                <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 反序列化 attachments 集合，并存储起来 </span>
</span></span><span style=display:flex><span>                    setAttachments((Map<span style=color:#719e07>&lt;</span>String, String<span style=color:#719e07>&gt;</span>) in.readObject(Map.class));
</span></span><span style=display:flex><span>                } <span style=color:#719e07>catch</span> (ClassNotFoundException e) {
</span></span><span style=display:flex><span>                    <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IOException(StringUtils.toString(<span style=color:#2aa198>&#34;Read response data failed.&#34;</span>, e));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 返回值不为空，且携带了 attachments 集合</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:
</span></span><span style=display:flex><span>                <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 获取返回值类型</span>
</span></span><span style=display:flex><span>                    Type<span style=color:#719e07>[]</span> returnType <span style=color:#719e07>=</span> RpcUtils.getReturnTypes(invocation);
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 反序列化调用结果，并保存起来</span>
</span></span><span style=display:flex><span>                    setValue(returnType <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>||</span> returnType.length <span style=color:#719e07>==</span> 0 <span style=color:#719e07>?</span> in.readObject() :
</span></span><span style=display:flex><span>                            (returnType.length <span style=color:#719e07>==</span> 1 <span style=color:#719e07>?</span> in.readObject((Class<span style=color:#719e07>&lt;?&gt;</span>) returnType<span style=color:#719e07>[</span>0<span style=color:#719e07>]</span>)
</span></span><span style=display:flex><span>                                    : in.readObject((Class<span style=color:#719e07>&lt;?&gt;</span>) returnType<span style=color:#719e07>[</span>0<span style=color:#719e07>]</span>, returnType<span style=color:#719e07>[</span>1<span style=color:#719e07>]</span>)));
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 反序列化 attachments 集合，并存储起来</span>
</span></span><span style=display:flex><span>                    setAttachments((Map<span style=color:#719e07>&lt;</span>String, String<span style=color:#719e07>&gt;</span>) in.readObject(Map.class));
</span></span><span style=display:flex><span>                } <span style=color:#719e07>catch</span> (ClassNotFoundException e) {
</span></span><span style=display:flex><span>                    <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IOException(StringUtils.toString(<span style=color:#2aa198>&#34;Read response data failed.&#34;</span>, e));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 异常对象不为空，且携带了 attachments 集合</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS:
</span></span><span style=display:flex><span>                <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 反序列化异常对象</span>
</span></span><span style=display:flex><span>                    Object obj <span style=color:#719e07>=</span> in.readObject();
</span></span><span style=display:flex><span>                    <span style=color:#719e07>if</span> (obj <span style=color:#719e07>instanceof</span> Throwable <span style=color:#719e07>==</span> <span style=color:#cb4b16>false</span>)
</span></span><span style=display:flex><span>                        <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IOException(<span style=color:#2aa198>&#34;Response data error, expect Throwable, but get &#34;</span> <span style=color:#719e07>+</span> obj);
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 设置异常对象</span>
</span></span><span style=display:flex><span>                    setException((Throwable) obj);
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 反序列化 attachments 集合，并存储起来</span>
</span></span><span style=display:flex><span>                    setAttachments((Map<span style=color:#719e07>&lt;</span>String, String<span style=color:#719e07>&gt;</span>) in.readObject(Map.class));
</span></span><span style=display:flex><span>                } <span style=color:#719e07>catch</span> (ClassNotFoundException e) {
</span></span><span style=display:flex><span>                    <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IOException(StringUtils.toString(<span style=color:#2aa198>&#34;Read response data failed.&#34;</span>, e));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>            <span style=color:#719e07>default</span>:
</span></span><span style=display:flex><span>                <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IOException(<span style=color:#2aa198>&#34;Unknown result flag, expect &#39;0&#39; &#39;1&#39; &#39;2&#39;, get &#34;</span> <span style=color:#719e07>+</span> flag);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (in <span style=color:#719e07>instanceof</span> Cleanable) {
</span></span><span style=display:flex><span>            ((Cleanable) in).cleanup();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> <span style=color:#719e07>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>本篇文章所分析的源码版本为 2.6.4，该版本下的 Response 支持 attachments 集合，所以上面仅对部分 case 分支进行了注释。其他 case 分支的逻辑比被注释分支的逻辑更为简单，这里就忽略了。我们所使用的测试服务接口 DemoService 包含了一个具有返回值的方法，正常调用下，线程会进入 RESPONSE_VALUE_WITH_ATTACHMENTS 分支中。然后线程会从 invocation 变量（大家探索一下 invocation 变量的由来）中获取返回值类型，接着对调用结果进行反序列化，并将序列化后的结果存储起来。最后对 attachments 集合进行反序列化，并存到指定字段中。到此，关于响应数据的解码过程就分析完了。接下来，我们再来探索一下响应对象 Response 的去向。</p><h4 id=252-向用户线程传递调用结果>2.5.2 向用户线程传递调用结果</h4><p>响应数据解码完成后，Dubbo 会将响应对象派发到线程池上。要注意的是，线程池中的线程并非用户的调用线程，所以要想办法将响应对象从线程池线程传递到用户线程上。我们在 2.1 节分析过用户线程在发送完请求后的动作，即调用 DefaultFuture 的 get 方法等待响应对象的到来。当响应对象到来后，用户线程会被唤醒，并通过<strong>调用编号</strong>获取属于自己的响应对象。下面我们来看一下整个过程对应的代码。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>HeaderExchangeHandler</span> <span style=color:#268bd2>implements</span> ChannelHandlerDelegate {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>received</span>(Channel channel, Object message) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());
</span></span><span style=display:flex><span>        ExchangeChannel exchangeChannel <span style=color:#719e07>=</span> HeaderExchangeChannel.getOrAddChannel(channel);
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> Request) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 处理请求，前面已分析过，省略</span>
</span></span><span style=display:flex><span>            } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> Response) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 处理响应</span>
</span></span><span style=display:flex><span>                handleResponse(channel, (Response) message);
</span></span><span style=display:flex><span>            } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> String) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// telnet 相关，忽略</span>
</span></span><span style=display:flex><span>            } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                handler.received(exchangeChannel, message);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#719e07>finally</span> {
</span></span><span style=display:flex><span>            HeaderExchangeChannel.removeChannelIfDisconnected(channel);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>static</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>handleResponse</span>(Channel channel, Response response) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (response <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>&amp;&amp;</span> <span style=color:#719e07>!</span>response.isHeartbeat()) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 继续向下调用</span>
</span></span><span style=display:flex><span>            DefaultFuture.received(channel, response);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DefaultFuture</span> <span style=color:#268bd2>implements</span> ResponseFuture {  
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Lock lock <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> ReentrantLock();
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Condition done <span style=color:#719e07>=</span> lock.newCondition();
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>volatile</span> Response response;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	<span style=color:#268bd2>public</span> <span style=color:#268bd2>static</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>received</span>(Channel channel, Response response) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 根据调用编号从 FUTURES 集合中查找指定的 DefaultFuture 对象</span>
</span></span><span style=display:flex><span>            DefaultFuture future <span style=color:#719e07>=</span> FUTURES.remove(response.getId());
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (future <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 继续向下调用</span>
</span></span><span style=display:flex><span>                future.doReceived(response);
</span></span><span style=display:flex><span>            } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                logger.warn(<span style=color:#2aa198>&#34;The timeout response finally returned at ...&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#719e07>finally</span> {
</span></span><span style=display:flex><span>            CHANNELS.remove(response.getId());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#268bd2>private</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>doReceived</span>(Response res) {
</span></span><span style=display:flex><span>        lock.lock();
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 保存响应对象</span>
</span></span><span style=display:flex><span>            response <span style=color:#719e07>=</span> res;
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (done <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 唤醒用户线程</span>
</span></span><span style=display:flex><span>                done.signal();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#719e07>finally</span> {
</span></span><span style=display:flex><span>            lock.unlock();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (callback <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            invokeCallback(callback);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上逻辑是将响应对象保存到相应的 DefaultFuture 实例中，然后再唤醒用户线程，随后用户线程即可从 DefaultFuture 实例中获取到相应结果。</p><p>本篇文章在多个地方都强调过调用编号很重要，但一直没有解释原因，这里简单说明一下。一般情况下，服务消费方会并发调用多个服务，每个用户线程发送请求后，会调用不同 DefaultFuture 对象的 get 方法进行等待。 一段时间后，服务消费方的线程池会收到多个响应对象。这个时候要考虑一个问题，如何将每个响应对象传递给相应的 DefaultFuture 对象，且不出错。答案是通过调用编号。DefaultFuture 被创建时，会要求传入一个 Request 对象。此时 DefaultFuture 可从 Request 对象中获取调用编号，并将 &lt;调用编号, DefaultFuture 对象> 映射关系存入到静态 Map 中，即 FUTURES。线程池中的线程在收到 Response 对象后，会根据 Response 对象中的调用编号到 FUTURES 集合中取出相应的 DefaultFuture 对象，然后再将 Response 对象设置到 DefaultFuture 对象中。最后再唤醒用户线程，这样用户线程即可从 DefaultFuture 对象中获取调用结果了。整个过程大致如下图：</p><p><img src=/imgs/dev/request-id-application.jpg alt=img></p><h2 id=3-总结>3. 总结</h2><p>本篇文章主要对 Dubbo 中的几种服务调用方式，以及从双向通信的角度对整个通信过程进行了详细的分析。按照通信顺序，通信过程包括服务消费方发送请求，服务提供方接收请求，服务提供方返回响应数据，服务消费方接收响应数据等过程。理解这些过程需要大家对网络编程，尤其是 Netty 有一定的了解。限于篇幅原因，本篇文章无法将服务调用的所有内容都一一进行分析。对于本篇文章未讲到或未详细分析的内容，比如服务降级、过滤器链、以及序列化等。大家若感兴趣，可自行进行分析。并将分析整理成文，分享给社区。</p><p>本篇文章就到这里了，感谢阅读。</p><div id=pre-footer><h2>反馈</h2><p class=feedback--prompt>此页是否对您有帮助？</p><button class="btn btn-primary mb-4 feedback--yes">是</button>
<button class="btn btn-primary mb-4 feedback--no">否</button></div><script>const yes=document.querySelector(".feedback--yes"),no=document.querySelector(".feedback--no");document.querySelectorAll(".feedback--link").forEach(e=>{e.href=e.href+window.location.pathname});const sendFeedback=e=>{gtag||console.log("!gtag"),gtag("event","click",{event_category:"Helpful",event_label:window.location.pathname,value:e})},disableButtons=()=>{yes.disabled=!0,yes.classList.add("feedback--button__disabled"),no.disabled=!0,no.classList.add("feedback--button__disabled")};yes.addEventListener("click",()=>{sendFeedback(1),disableButtons(),document.querySelector(".feedback--response").classList.remove("feedback--response__hidden")}),no.addEventListener("click",()=>{sendFeedback(0),disableButtons(),document.querySelector(".feedback--response").classList.remove("feedback--response__hidden")})</script><br><div class="text-muted mt-5 pt-3 border-top">最后修改 March 1, 2023: <a href=https://github.com/apache/dubbo-website/commit/f2070b3fdd1b7b200db0f8f2a50fb09d7c398a64>Add /zh/ docs aliases (#2336) (f2070b3fdd1)</a></div></div></main><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"><div class="td-page-meta ml-2 pb-1 pt-2 mb-0"><a href=https://github.com/apache/dubbo-website/edit/master/content/zh-cn/docsv2.7/dev/source/service-invoking-process.md target=_blank><i class="fa fa-edit fa-fw"></i> 编辑此页</a>
<a href="https://github.com/apache/dubbo-website/new/master/content/zh-cn/docsv2.7/dev/source/service-invoking-process.md?filename=change-me.md&amp;value=---%0Atitle%3A+%22Long+Page+Title%22%0AlinkTitle%3A+%22Short+Nav+Title%22%0Aweight%3A+100%0Adescription%3A+%3E-%0A+++++Page+description+for+heading+and+indexes.%0A---%0A%0A%23%23+Heading%0A%0AEdit+this+template+to+create+your+new+page.%0A%0A%2A+Give+it+a+good+name%2C+ending+in+%60.md%60+-+e.g.+%60getting-started.md%60%0A%2A+Edit+the+%22front+matter%22+section+at+the+top+of+the+page+%28weight+controls+how+its+ordered+amongst+other+pages+in+the+same+directory%3B+lowest+number+first%29.%0A%2A+Add+a+good+commit+message+at+the+bottom+of+the+page+%28%3C80+characters%3B+use+the+extended+description+field+for+more+detail%29.%0A%2A+Create+a+new+branch+so+you+can+preview+your+new+file+and+request+a+review+via+Pull+Request.%0A" target=_blank><i class="fa fa-edit fa-fw"></i> 创建子页面</a>
<a href="https://github.com/apache/dubbo-website/issues/new?title=%e6%9c%8d%e5%8a%a1%e8%b0%83%e7%94%a8%e8%bf%87%e7%a8%8b" target=_blank><i class="fab fa-github fa-fw"></i> 登记问题</a>
<a href=https://github.com/apache/dubbo/issues/new target=_blank><i class="fas fa-tasks fa-fw"></i> 提交项目问题</a></div><nav id=TableOfContents><ul><li><a href=#1-简介>1. 简介</a></li><li><a href=#2-源码分析>2. 源码分析</a><ul><li><a href=#21-服务调用方式>2.1 服务调用方式</a></li><li><a href=#22-服务消费方发送请求>2.2 服务消费方发送请求</a></li><li><a href=#23-服务提供方接收请求>2.3 服务提供方接收请求</a></li><li><a href=#24-服务提供方返回调用结果>2.4 服务提供方返回调用结果</a></li><li><a href=#25-服务消费方接收调用结果>2.5 服务消费方接收调用结果</a></li></ul></li><li><a href=#3-总结>3. 总结</a></li></ul></nav></div></div></div></div><footer class="bg-dark py-5 row d-print-none footer-margin-0"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Dubbo mailing list archive" aria-label="Dubbo mailing list archive"><a class=text-white target=_blank rel="noopener noreferrer" href=https://lists.apache.org/list.html?dev@dubbo.apache.org><i class="fa fa-envelope"></i></a></li></ul></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel="noopener noreferrer" href=https://github.com/apache/dubbo><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Subscribe to mailing list" aria-label="Subscribe to mailing list"><a class=text-white target=_blank rel="noopener noreferrer" href=mailto:dev-subscribe@dubbo.apache.org><i class="fa fa-envelope"></i></a></li></ul></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2024 The Apache Software Foundation. Apache Dubbo, Dubbo, Apache, the Apache feather logo, and the Apache Dubbo project logo are either registered trademarks or trademarks of The Apache Software Foundation in the United States and other countries. 保留所有权利</small></div></div></div></footer><div class="row pt-2 pb-2 footer-margin-0"><div class="container-fluid mx-sm-5"><div class=text-center id=my-footer><img alt=apache_logo src=/imgs/apache_logo.png><ul><li><a href=https://www.apache.org>Foundation</a></li><li><a href=https://www.apache.org/licenses/>License</a></li><li><a href=https://dubbo.apache.org/en/overview/notices/>Security</a></li><li><a href=https://www.apache.org/events/current-event>Events</a></li><li><a href=https://www.apache.org/foundation/sponsorship.html>Sponsorship</a></li><li><a href=https://privacy.apache.org/policies/privacy-policy-public.html>Privacy</a></li><li><a href=https://www.apache.org/foundation/thanks.html>Thanks</a></li></ul></div></div></div><script src=/js/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script><script src=/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script><script src=/js/main.min.a4534a01940be8c082c4c0e6777b61df9884f202b61c9519352adb6d1039d5aa.js integrity="sha256-pFNKAZQL6MCCxMDmd3th35iE8gK2HJUZNSrbbRA51ao=" crossorigin=anonymous></script><script>(function(e,t,n,s){e[s]=e[s]||[];var a=t.getElementsByTagName(n)[0],i=t.createElement(n);i.async=!0,i.id="beacon-aplus",i.setAttribute("exparams","userid=&aplus&sidx=aplusSidex&ckx=aplusCkx"),i.src="//g.alicdn.com/alilog/mlog/aplus_v2.js",i.crossorigin="anonymous",a.parentNode.insertBefore(i,a)})(window,document,"script","aplus_queue"),function(e){var t=e.createElement("script");t.type="text/javascript",t.async=!0,t.src="//g.alicdn.com/aes/??tracker/3.3.4/index.js,tracker-plugin-pv/3.0.5/index.js,tracker-plugin-event/3.0.0/index.js,tracker-plugin-autolog/3.0.3/index.js,tracker-plugin-survey/3.0.3/index.js,tracker-plugin-jserror/3.0.3/index.js,tracker-plugin-resourceError/3.0.3/index.js",t.onload=function(){window.AES_CONFIG=window.AES_CONFIG||{env:"prod"},window.aes=new AES({pid:"zN245h",user_type:6}),window.AESPluginAutologConfig={exposure:"auto"},window.AEMPluginInstances=[aes.use(AESPluginPV,window.AESPluginPVConfig||{enableHistory:!0}),aes.use(AESPluginEvent,window.AESPluginEventConfig||{}),aes.use(AESPluginSurvey,window.AESPluginEventConfig||{}),aes.use(AESPluginAutolog,window.AESPluginAutologConfig||{}),aes.use(AESPluginJSError,window.AESPluginJSError||{}),aes.use(AESPluginResourceError,window.AESPluginResourceError||{})]},setTimeout(function(){e.getElementsByTagName("body")[0].appendChild(t)},800)}(document)</script><script src=https://cdn.jsdelivr.net/npm/@docsearch/js@3></script><script>docsearch({appId:"L5F4T9F0I1",apiKey:"364ae307e1da9d02b2335675e9db1eb1",indexName:"apache_dubbo",container:"#docsearch",debug:!1}),docsearch({appId:"L5F4T9F0I1",apiKey:"364ae307e1da9d02b2335675e9db1eb1",indexName:"apache_dubbo",container:"#docsearch_zh_home",debug:!1})</script></body></html>