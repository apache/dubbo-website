<!doctype html><html lang=zh-cn class=no-js><head><meta name=ROBOTS content="INDEX, FOLLOW"><link rel=canonical href=https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/service-invoking-process/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.120.4"><link rel="shortcut icon" type=image/png href=/imgs/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><title>服务调用过程 | Apache Dubbo</title><meta property="og:title" content="服务调用过程">
<meta property="og:description" content="本文介绍了服务调用过程的原理和实现细节"><meta property="og:type" content="article"><meta property="og:url" content="https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/service-invoking-process/"><meta property="article:section" content="docsv2.7"><meta property="article:modified_time" content="2023-03-01T09:48:32+08:00"><meta itemprop=name content="服务调用过程"><meta itemprop=description content="本文介绍了服务调用过程的原理和实现细节"><meta itemprop=dateModified content="2023-03-01T09:48:32+08:00"><meta itemprop=wordCount content="5730"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="服务调用过程"><meta name=twitter:description content="本文介绍了服务调用过程的原理和实现细节"><script async src="https://www.googletagmanager.com/gtag/js?id=G-1TFHM5YBH0"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-1TFHM5YBH0",{anonymize_ip:!1})}</script><link rel=preload href=/scss/main.min.fe7176cbe3102a33d3e8c0c9cec61eb52508abd24a2cc1ae23ccf535a481ffde.css as=style><link href=/scss/main.min.fe7176cbe3102a33d3e8c0c9cec61eb52508abd24a2cc1ae23ccf535a481ffde.css rel=stylesheet integrity><script src=/js/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@docsearch/css@3><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="本文介绍了服务调用过程的原理和实现细节"><meta property="og:description" content="本文介绍了服务调用过程的原理和实现细节"><meta name=twitter:description content="本文介绍了服务调用过程的原理和实现细节"><meta property="og:url" content="https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/service-invoking-process/"><meta property="og:title" content="服务调用过程"><meta name=twitter:title content="服务调用过程"><meta name=twitter:image:alt content="Apache Dubbo"><meta property="og:type" content="article"><meta name=viewport content="width=device-width"><script async defer src=/js/github-buttons.js></script><link href=/css/community.css rel=stylesheet><link href=/css/contactus.css rel=stylesheet><link href=/css/language.css rel=stylesheet><script src=/js/script.js></script></head><body class="td-page td-documentation"><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/zh-cn/><span class=navbar-logo></span><span class="text-uppercase font-weight-bold">Apache Dubbo</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/zh-cn/overview/home/><span>文档</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/zh-cn/blog/><span>博客</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/zh-cn/download/><span>版本发布</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/zh-cn/contact/><span>联系社区</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=https://start.dubbo.apache.org/bootstrap.html target=_blank><span>Initializer</span><i class='fas fa-external-link-alt'></i></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/zh-cn/github/><span>Github</span><i class='fa-brands fa-github'></i></a></li><li class="nav-item dropdown d-lg-block"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/en/>English</a></div></li><li class="nav-item dropdown d-lg-block"><div class="nav-item d-none d-lg-block"><div id=docsearch></div></div></li></ul></div></nav><section class="header-hero text-white pb-0 light-text"></section></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-md-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"><script>$(function(){$("#td-section-nav a").removeClass("active"),$("#td-section-nav #m-zh-cndocsv27devsourceservice-invoking-process").addClass("active"),$("#td-section-nav #m-zh-cndocsv27devsourceservice-invoking-process-li span").addClass("td-sidebar-nav-active-item"),$("#td-section-nav #m-zh-cndocsv27devsourceservice-invoking-process").parents("li").addClass("active-path"),$("#td-section-nav li.active-path").addClass("show"),$("#td-section-nav li.active-path").children("input").prop("checked",!0),$("#td-section-nav #m-zh-cndocsv27devsourceservice-invoking-process-li").siblings("li").addClass("show"),$("#td-section-nav #m-zh-cndocsv27devsourceservice-invoking-process-li").children("ul").children("li").addClass("show"),$("#td-sidebar-menu").toggleClass("d-none")})</script><div id=td-sidebar-menu class="td-sidebar__inner d-none"><div id=content-mobile><form class="td-sidebar__search d-flex align-items-center"><div id=docsearch></div><button class="btn btn-link td-sidebar__toggle d-md-none p-0 ml-3 fas fa-bars" type=button data-toggle=collapse data-target=#td-section-nav aria-controls=td-docs-nav aria-expanded=false aria-label="Toggle section navigation"></button></form></div><div id=content-desktop></div><nav class="collapse td-sidebar-nav foldable-nav" id=td-section-nav><ul class="td-sidebar-nav__section pr-md-3 ul-0"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27-li><ul class=ul-1><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27user-li><input type=checkbox id=m-zh-cndocsv27user-check>
<label for=m-zh-cndocsv27user-check><a href=/zh-cn/docsv2.7/user/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27user><span>用户文档</span></a></label><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userpreface-li><input type=checkbox id=m-zh-cndocsv27userpreface-check>
<label for=m-zh-cndocsv27userpreface-check><a href=/zh-cn/docsv2.7/user/preface/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userpreface><span>入门介绍</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userprefacebackground-li><input type=checkbox id=m-zh-cndocsv27userprefacebackground-check>
<label for=m-zh-cndocsv27userprefacebackground-check><a href=/zh-cn/docsv2.7/user/preface/background/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userprefacebackground><span>背景</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userprefacerequirements-li><input type=checkbox id=m-zh-cndocsv27userprefacerequirements-check>
<label for=m-zh-cndocsv27userprefacerequirements-check><a href=/zh-cn/docsv2.7/user/preface/requirements/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userprefacerequirements><span>需求</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userprefacearchitecture-li><input type=checkbox id=m-zh-cndocsv27userprefacearchitecture-check>
<label for=m-zh-cndocsv27userprefacearchitecture-check><a href=/zh-cn/docsv2.7/user/preface/architecture/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userprefacearchitecture><span>架构</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userprefaceusage-li><input type=checkbox id=m-zh-cndocsv27userprefaceusage-check>
<label for=m-zh-cndocsv27userprefaceusage-check><a href=/zh-cn/docsv2.7/user/preface/usage/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userprefaceusage><span>用法</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userquick-start-li><input type=checkbox id=m-zh-cndocsv27userquick-start-check>
<label for=m-zh-cndocsv27userquick-start-check><a href=/zh-cn/docsv2.7/user/quick-start/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userquick-start><span>快速开始</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userdependencies-li><input type=checkbox id=m-zh-cndocsv27userdependencies-check>
<label for=m-zh-cndocsv27userdependencies-check><a href=/zh-cn/docsv2.7/user/dependencies/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userdependencies><span>基本依赖</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27usermaturity-li><input type=checkbox id=m-zh-cndocsv27usermaturity-check>
<label for=m-zh-cndocsv27usermaturity-check><a href=/zh-cn/docsv2.7/user/maturity/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27usermaturity><span>成熟度</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userconfiguration-li><input type=checkbox id=m-zh-cndocsv27userconfiguration-check>
<label for=m-zh-cndocsv27userconfiguration-check><a href=/zh-cn/docsv2.7/user/configuration/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userconfiguration><span>配置手册</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userconfigurationxml-li><input type=checkbox id=m-zh-cndocsv27userconfigurationxml-check>
<label for=m-zh-cndocsv27userconfigurationxml-check><a href=/zh-cn/docsv2.7/user/configuration/xml/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userconfigurationxml><span>XML 配置</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userconfigurationconfig-center-li><input type=checkbox id=m-zh-cndocsv27userconfigurationconfig-center-check>
<label for=m-zh-cndocsv27userconfigurationconfig-center-check><a href=/zh-cn/docsv2.7/user/configuration/config-center/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userconfigurationconfig-center><span>动态配置中心</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userconfigurationproperties-li><input type=checkbox id=m-zh-cndocsv27userconfigurationproperties-check>
<label for=m-zh-cndocsv27userconfigurationproperties-check><a href=/zh-cn/docsv2.7/user/configuration/properties/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userconfigurationproperties><span>属性配置</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userconfigurationenvironment-variables-li><input type=checkbox id=m-zh-cndocsv27userconfigurationenvironment-variables-check>
<label for=m-zh-cndocsv27userconfigurationenvironment-variables-check><a href=/zh-cn/docsv2.7/user/configuration/environment-variables/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userconfigurationenvironment-variables><span>自动加载环境变量</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userconfigurationapi-li><input type=checkbox id=m-zh-cndocsv27userconfigurationapi-check>
<label for=m-zh-cndocsv27userconfigurationapi-check><a href=/zh-cn/docsv2.7/user/configuration/api/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userconfigurationapi><span>API 配置</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userconfigurationannotation-li><input type=checkbox id=m-zh-cndocsv27userconfigurationannotation-check>
<label for=m-zh-cndocsv27userconfigurationannotation-check><a href=/zh-cn/docsv2.7/user/configuration/annotation/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userconfigurationannotation><span>注解配置</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userconfigurationconfiguration-load-process-li><input type=checkbox id=m-zh-cndocsv27userconfigurationconfiguration-load-process-check>
<label for=m-zh-cndocsv27userconfigurationconfiguration-load-process-check><a href=/zh-cn/docsv2.7/user/configuration/configuration-load-process/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userconfigurationconfiguration-load-process><span>配置加载流程</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userexamples-li><input type=checkbox id=m-zh-cndocsv27userexamples-check>
<label for=m-zh-cndocsv27userexamples-check><a href=/zh-cn/docsv2.7/user/examples/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userexamples><span>用法示例</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplese9878de8af95e6aca1e695b0e9858de7bdae-li><input type=checkbox id=m-zh-cndocsv27userexamplese9878de8af95e6aca1e695b0e9858de7bdae-check>
<label for=m-zh-cndocsv27userexamplese9878de8af95e6aca1e695b0e9858de7bdae-check><a href=/zh-cn/docsv2.7/user/examples/%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0%E9%85%8D%E7%BD%AE/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplese9878de8af95e6aca1e695b0e9858de7bdae><span>服务重试</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplespreflight-check-li><input type=checkbox id=m-zh-cndocsv27userexamplespreflight-check-check>
<label for=m-zh-cndocsv27userexamplespreflight-check-check><a href=/zh-cn/docsv2.7/user/examples/preflight-check/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplespreflight-check><span>启动时检查</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesfault-tolerent-strategy-li><input type=checkbox id=m-zh-cndocsv27userexamplesfault-tolerent-strategy-check>
<label for=m-zh-cndocsv27userexamplesfault-tolerent-strategy-check><a href=/zh-cn/docsv2.7/user/examples/fault-tolerent-strategy/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesfault-tolerent-strategy><span>集群容错</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesloadbalance-li><input type=checkbox id=m-zh-cndocsv27userexamplesloadbalance-check>
<label for=m-zh-cndocsv27userexamplesloadbalance-check><a href=/zh-cn/docsv2.7/user/examples/loadbalance/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesloadbalance><span>负载均衡</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesthread-model-li><input type=checkbox id=m-zh-cndocsv27userexamplesthread-model-check>
<label for=m-zh-cndocsv27userexamplesthread-model-check><a href=/zh-cn/docsv2.7/user/examples/thread-model/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesthread-model><span>线程模型</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesexplicit-target-li><input type=checkbox id=m-zh-cndocsv27userexamplesexplicit-target-check>
<label for=m-zh-cndocsv27userexamplesexplicit-target-check><a href=/zh-cn/docsv2.7/user/examples/explicit-target/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesexplicit-target><span>直连提供者</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplessubscribe-only-li><input type=checkbox id=m-zh-cndocsv27userexamplessubscribe-only-check>
<label for=m-zh-cndocsv27userexamplessubscribe-only-check><a href=/zh-cn/docsv2.7/user/examples/subscribe-only/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplessubscribe-only><span>只订阅</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesmulti-protocols-li><input type=checkbox id=m-zh-cndocsv27userexamplesmulti-protocols-check>
<label for=m-zh-cndocsv27userexamplesmulti-protocols-check><a href=/zh-cn/docsv2.7/user/examples/multi-protocols/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesmulti-protocols><span>多协议</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesmulti-registry-li><input type=checkbox id=m-zh-cndocsv27userexamplesmulti-registry-check>
<label for=m-zh-cndocsv27userexamplesmulti-registry-check><a href=/zh-cn/docsv2.7/user/examples/multi-registry/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesmulti-registry><span>多注册中心</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesservice-group-li><input type=checkbox id=m-zh-cndocsv27userexamplesservice-group-check>
<label for=m-zh-cndocsv27userexamplesservice-group-check><a href=/zh-cn/docsv2.7/user/examples/service-group/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesservice-group><span>服务分组</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesstatic-service-li><input type=checkbox id=m-zh-cndocsv27userexamplesstatic-service-check>
<label for=m-zh-cndocsv27userexamplesstatic-service-check><a href=/zh-cn/docsv2.7/user/examples/static-service/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesstatic-service><span>静态服务</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesmulti-versions-li><input type=checkbox id=m-zh-cndocsv27userexamplesmulti-versions-check>
<label for=m-zh-cndocsv27userexamplesmulti-versions-check><a href=/zh-cn/docsv2.7/user/examples/multi-versions/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesmulti-versions><span>多版本</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesgroup-merger-li><input type=checkbox id=m-zh-cndocsv27userexamplesgroup-merger-check>
<label for=m-zh-cndocsv27userexamplesgroup-merger-check><a href=/zh-cn/docsv2.7/user/examples/group-merger/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesgroup-merger><span>分组聚合</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesparameter-validation-li><input type=checkbox id=m-zh-cndocsv27userexamplesparameter-validation-check>
<label for=m-zh-cndocsv27userexamplesparameter-validation-check><a href=/zh-cn/docsv2.7/user/examples/parameter-validation/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesparameter-validation><span>参数验证</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesgeneric-invoke-with-json-li><input type=checkbox id=m-zh-cndocsv27userexamplesgeneric-invoke-with-json-check>
<label for=m-zh-cndocsv27userexamplesgeneric-invoke-with-json-check><a href=/zh-cn/docsv2.7/user/examples/generic-invoke-with-json/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesgeneric-invoke-with-json><span>JSON泛化调用</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesmsgpack-serialization-li><input type=checkbox id=m-zh-cndocsv27userexamplesmsgpack-serialization-check>
<label for=m-zh-cndocsv27userexamplesmsgpack-serialization-check><a href=/zh-cn/docsv2.7/user/examples/msgpack-serialization/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesmsgpack-serialization><span>msgpack序列化</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesprovider-timeout-release-li><input type=checkbox id=m-zh-cndocsv27userexamplesprovider-timeout-release-check>
<label for=m-zh-cndocsv27userexamplesprovider-timeout-release-check><a href=/zh-cn/docsv2.7/user/examples/provider-timeout-release/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesprovider-timeout-release><span>provider超时打断</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesresult-cache-li><input type=checkbox id=m-zh-cndocsv27userexamplesresult-cache-check>
<label for=m-zh-cndocsv27userexamplesresult-cache-check><a href=/zh-cn/docsv2.7/user/examples/result-cache/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesresult-cache><span>结果缓存</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesbroadcast-resp-collect-li><input type=checkbox id=m-zh-cndocsv27userexamplesbroadcast-resp-collect-check>
<label for=m-zh-cndocsv27userexamplesbroadcast-resp-collect-check><a href=/zh-cn/docsv2.7/user/examples/broadcast-resp-collect/ title=收集Dubbo广播响应 class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesbroadcast-resp-collect><span>收集广播响应</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesinvoke-with-specified-ip-li><input type=checkbox id=m-zh-cndocsv27userexamplesinvoke-with-specified-ip-check>
<label for=m-zh-cndocsv27userexamplesinvoke-with-specified-ip-check><a href=/zh-cn/docsv2.7/user/examples/invoke-with-specified-ip/ title="指定Ip Port调用Provider" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesinvoke-with-specified-ip><span>指定IP</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesgeneric-reference-li><input type=checkbox id=m-zh-cndocsv27userexamplesgeneric-reference-check>
<label for=m-zh-cndocsv27userexamplesgeneric-reference-check><a href=/zh-cn/docsv2.7/user/examples/generic-reference/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesgeneric-reference><span>使用泛化调用</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesprotobuf-idl-li><input type=checkbox id=m-zh-cndocsv27userexamplesprotobuf-idl-check>
<label for=m-zh-cndocsv27userexamplesprotobuf-idl-check><a href=/zh-cn/docsv2.7/user/examples/protobuf-idl/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesprotobuf-idl><span>Protobuf</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplespb-generic-reference-li><input type=checkbox id=m-zh-cndocsv27userexamplespb-generic-reference-check>
<label for=m-zh-cndocsv27userexamplespb-generic-reference-check><a href=/zh-cn/docsv2.7/user/examples/pb-generic-reference/ title="GoogleProtobuf 对象泛化调用" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplespb-generic-reference><span>Protobuf 泛化调用</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesgeneric-service-li><input type=checkbox id=m-zh-cndocsv27userexamplesgeneric-service-check>
<label for=m-zh-cndocsv27userexamplesgeneric-service-check><a href=/zh-cn/docsv2.7/user/examples/generic-service/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesgeneric-service><span>实现泛化调用</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesecho-service-li><input type=checkbox id=m-zh-cndocsv27userexamplesecho-service-check>
<label for=m-zh-cndocsv27userexamplesecho-service-check><a href=/zh-cn/docsv2.7/user/examples/echo-service/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesecho-service><span>回声测试</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplescontext-li><input type=checkbox id=m-zh-cndocsv27userexamplescontext-check>
<label for=m-zh-cndocsv27userexamplescontext-check><a href=/zh-cn/docsv2.7/user/examples/context/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplescontext><span>上下文信息</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesattachment-li><input type=checkbox id=m-zh-cndocsv27userexamplesattachment-check>
<label for=m-zh-cndocsv27userexamplesattachment-check><a href=/zh-cn/docsv2.7/user/examples/attachment/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesattachment><span>隐式参数</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesasync-call-li><input type=checkbox id=m-zh-cndocsv27userexamplesasync-call-check>
<label for=m-zh-cndocsv27userexamplesasync-call-check><a href=/zh-cn/docsv2.7/user/examples/async-call/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesasync-call><span>异步调用</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesasync-execute-on-provider-li><input type=checkbox id=m-zh-cndocsv27userexamplesasync-execute-on-provider-check>
<label for=m-zh-cndocsv27userexamplesasync-execute-on-provider-check><a href=/zh-cn/docsv2.7/user/examples/async-execute-on-provider/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesasync-execute-on-provider><span>异步执行</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexampleslocal-call-li><input type=checkbox id=m-zh-cndocsv27userexampleslocal-call-check>
<label for=m-zh-cndocsv27userexampleslocal-call-check><a href=/zh-cn/docsv2.7/user/examples/local-call/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexampleslocal-call><span>本地调用</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplescallback-parameter-li><input type=checkbox id=m-zh-cndocsv27userexamplescallback-parameter-check>
<label for=m-zh-cndocsv27userexamplescallback-parameter-check><a href=/zh-cn/docsv2.7/user/examples/callback-parameter/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplescallback-parameter><span>参数回调</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesevents-notify-li><input type=checkbox id=m-zh-cndocsv27userexamplesevents-notify-check>
<label for=m-zh-cndocsv27userexamplesevents-notify-check><a href=/zh-cn/docsv2.7/user/examples/events-notify/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesevents-notify><span>事件通知</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexampleslocal-stub-li><input type=checkbox id=m-zh-cndocsv27userexampleslocal-stub-check>
<label for=m-zh-cndocsv27userexampleslocal-stub-check><a href=/zh-cn/docsv2.7/user/examples/local-stub/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexampleslocal-stub><span>本地存根</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexampleslocal-mock-li><input type=checkbox id=m-zh-cndocsv27userexampleslocal-mock-check>
<label for=m-zh-cndocsv27userexampleslocal-mock-check><a href=/zh-cn/docsv2.7/user/examples/local-mock/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexampleslocal-mock><span>本地伪装</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesdelay-publish-li><input type=checkbox id=m-zh-cndocsv27userexamplesdelay-publish-check>
<label for=m-zh-cndocsv27userexamplesdelay-publish-check><a href=/zh-cn/docsv2.7/user/examples/delay-publish/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesdelay-publish><span>延迟暴露</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesconcurrency-control-li><input type=checkbox id=m-zh-cndocsv27userexamplesconcurrency-control-check>
<label for=m-zh-cndocsv27userexamplesconcurrency-control-check><a href=/zh-cn/docsv2.7/user/examples/concurrency-control/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesconcurrency-control><span>并发控制</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesconfig-connections-li><input type=checkbox id=m-zh-cndocsv27userexamplesconfig-connections-check>
<label for=m-zh-cndocsv27userexamplesconfig-connections-check><a href=/zh-cn/docsv2.7/user/examples/config-connections/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesconfig-connections><span>连接控制</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexampleslazy-connect-li><input type=checkbox id=m-zh-cndocsv27userexampleslazy-connect-check>
<label for=m-zh-cndocsv27userexampleslazy-connect-check><a href=/zh-cn/docsv2.7/user/examples/lazy-connect/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexampleslazy-connect><span>延迟连接</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesstickiness-li><input type=checkbox id=m-zh-cndocsv27userexamplesstickiness-check>
<label for=m-zh-cndocsv27userexamplesstickiness-check><a href=/zh-cn/docsv2.7/user/examples/stickiness/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesstickiness><span>粘滞连接</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplestls-li><input type=checkbox id=m-zh-cndocsv27userexamplestls-check>
<label for=m-zh-cndocsv27userexamplestls-check><a href=/zh-cn/docsv2.7/user/examples/tls/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplestls><span>TLS</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplestoken-authorization-li><input type=checkbox id=m-zh-cndocsv27userexamplestoken-authorization-check>
<label for=m-zh-cndocsv27userexamplestoken-authorization-check><a href=/zh-cn/docsv2.7/user/examples/token-authorization/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplestoken-authorization><span>令牌验证</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesrouting-rule-li><input type=checkbox id=m-zh-cndocsv27userexamplesrouting-rule-check>
<label for=m-zh-cndocsv27userexamplesrouting-rule-check><a href=/zh-cn/docsv2.7/user/examples/routing-rule/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesrouting-rule><span>路由规则</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesrouting-rule-deprecated-li><input type=checkbox id=m-zh-cndocsv27userexamplesrouting-rule-deprecated-check>
<label for=m-zh-cndocsv27userexamplesrouting-rule-deprecated-check><a href=/zh-cn/docsv2.7/user/examples/routing-rule-deprecated/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesrouting-rule-deprecated><span>旧路由规则</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesconfig-rule-li><input type=checkbox id=m-zh-cndocsv27userexamplesconfig-rule-check>
<label for=m-zh-cndocsv27userexamplesconfig-rule-check><a href=/zh-cn/docsv2.7/user/examples/config-rule/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesconfig-rule><span>配置规则</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesservice-downgrade-li><input type=checkbox id=m-zh-cndocsv27userexamplesservice-downgrade-check>
<label for=m-zh-cndocsv27userexamplesservice-downgrade-check><a href=/zh-cn/docsv2.7/user/examples/service-downgrade/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesservice-downgrade><span>服务降级</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesconfig-rule-deprecated-li><input type=checkbox id=m-zh-cndocsv27userexamplesconfig-rule-deprecated-check>
<label for=m-zh-cndocsv27userexamplesconfig-rule-deprecated-check><a href=/zh-cn/docsv2.7/user/examples/config-rule-deprecated/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesconfig-rule-deprecated><span>旧配置规则</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesconsumer-threadpool-li><input type=checkbox id=m-zh-cndocsv27userexamplesconsumer-threadpool-check>
<label for=m-zh-cndocsv27userexamplesconsumer-threadpool-check><a href=/zh-cn/docsv2.7/user/examples/consumer-threadpool/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesconsumer-threadpool><span>消费端线程池模型</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesgraceful-shutdown-li><input type=checkbox id=m-zh-cndocsv27userexamplesgraceful-shutdown-check>
<label for=m-zh-cndocsv27userexamplesgraceful-shutdown-check><a href=/zh-cn/docsv2.7/user/examples/graceful-shutdown/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesgraceful-shutdown><span>优雅停机</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexampleshostname-binding-li><input type=checkbox id=m-zh-cndocsv27userexampleshostname-binding-check>
<label for=m-zh-cndocsv27userexampleshostname-binding-check><a href=/zh-cn/docsv2.7/user/examples/hostname-binding/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexampleshostname-binding><span>主机绑定</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userexamplesset-host-li><input type=checkbox id=m-zh-cndocsv27userexamplesset-host-check>
<label for=m-zh-cndocsv27userexamplesset-host-check><a href=/zh-cn/docsv2.7/user/examples/set-host/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userexamplesset-host><span>主机配置</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userreferences-li><input type=checkbox id=m-zh-cndocsv27userreferences-check>
<label for=m-zh-cndocsv27userreferences-check><a href=/zh-cn/docsv2.7/user/references/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userreferences><span>参考手册</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userreferencesxml-li><input type=checkbox id=m-zh-cndocsv27userreferencesxml-check>
<label for=m-zh-cndocsv27userreferencesxml-check><a href=/zh-cn/docsv2.7/user/references/xml/ title="Schema 配置参考手册" class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userreferencesxml><span>XML 配置</span></a></label><ul class="ul-4 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-application-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-application-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-application-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-application/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-application><span>dubbo:application</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-argument-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-argument-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-argument-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-argument/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-argument><span>dubbo:argument</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-config-center-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-config-center-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-config-center-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-config-center/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-config-center><span>dubbo:config-center</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-consumer-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-consumer-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-consumer-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-consumer/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-consumer><span>dubbo:consumer</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-method-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-method-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-method-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-method/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-method><span>dubbo:method</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-module-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-module-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-module-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-module/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-module><span>dubbo:module</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-monitor-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-monitor-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-monitor-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-monitor/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-monitor><span>dubbo:monitor</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-parameter-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-parameter-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-parameter-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-parameter/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-parameter><span>dubbo:parameter</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-protocol-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-protocol-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-protocol-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-protocol/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-protocol><span>dubbo:protocol</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-provider-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-provider-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-provider-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-provider/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-provider><span>dubbo:provider</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-reference-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-reference-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-reference-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-reference/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-reference><span>dubbo:reference</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-registry-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-registry-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-registry-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-registry/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-registry><span>dubbo:registry</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesxmldubbo-service-li><input type=checkbox id=m-zh-cndocsv27userreferencesxmldubbo-service-check>
<label for=m-zh-cndocsv27userreferencesxmldubbo-service-check><a href=/zh-cn/docsv2.7/user/references/xml/dubbo-service/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesxmldubbo-service><span>dubbo:service</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userreferencesprotocol-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocol-check>
<label for=m-zh-cndocsv27userreferencesprotocol-check><a href=/zh-cn/docsv2.7/user/references/protocol/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userreferencesprotocol><span>协议参考手册</span></a></label><ul class="ul-4 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocoldubbo-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocoldubbo-check>
<label for=m-zh-cndocsv27userreferencesprotocoldubbo-check><a href=/zh-cn/docsv2.7/user/references/protocol/dubbo/ title="dubbo 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocoldubbo><span>dubbo://</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocolrest-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocolrest-check>
<label for=m-zh-cndocsv27userreferencesprotocolrest-check><a href=/zh-cn/docsv2.7/user/references/protocol/rest/ title="rest 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocolrest><span>rest://</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocolhttp-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocolhttp-check>
<label for=m-zh-cndocsv27userreferencesprotocolhttp-check><a href=/zh-cn/docsv2.7/user/references/protocol/http/ title="http 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocolhttp><span>http://</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocolhessian-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocolhessian-check>
<label for=m-zh-cndocsv27userreferencesprotocolhessian-check><a href=/zh-cn/docsv2.7/user/references/protocol/hessian/ title="hessian 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocolhessian><span>hessian://</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocolredis-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocolredis-check>
<label for=m-zh-cndocsv27userreferencesprotocolredis-check><a href=/zh-cn/docsv2.7/user/references/protocol/redis/ title="redis 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocolredis><span>redis://</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocolthrift-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocolthrift-check>
<label for=m-zh-cndocsv27userreferencesprotocolthrift-check><a href=/zh-cn/docsv2.7/user/references/protocol/thrift/ title="thrift 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocolthrift><span>thrift://</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocolgrpc-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocolgrpc-check>
<label for=m-zh-cndocsv27userreferencesprotocolgrpc-check><a href=/zh-cn/docsv2.7/user/references/protocol/grpc/ title="gRPC 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocolgrpc><span>grpc://</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocolmemcached-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocolmemcached-check>
<label for=m-zh-cndocsv27userreferencesprotocolmemcached-check><a href=/zh-cn/docsv2.7/user/references/protocol/memcached/ title="memcached 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocolmemcached><span>memcached://</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocolrmi-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocolrmi-check>
<label for=m-zh-cndocsv27userreferencesprotocolrmi-check><a href=/zh-cn/docsv2.7/user/references/protocol/rmi/ title="rmi 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocolrmi><span>rmi://</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesprotocolwebservice-li><input type=checkbox id=m-zh-cndocsv27userreferencesprotocolwebservice-check>
<label for=m-zh-cndocsv27userreferencesprotocolwebservice-check><a href=/zh-cn/docsv2.7/user/references/protocol/webservice/ title="webservice 协议" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesprotocolwebservice><span>webservice://</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userreferencesregistry-li><input type=checkbox id=m-zh-cndocsv27userreferencesregistry-check>
<label for=m-zh-cndocsv27userreferencesregistry-check><a href=/zh-cn/docsv2.7/user/references/registry/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userreferencesregistry><span>注册中心参考手册</span></a></label><ul class="ul-4 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesregistrynacos-li><input type=checkbox id=m-zh-cndocsv27userreferencesregistrynacos-check>
<label for=m-zh-cndocsv27userreferencesregistrynacos-check><a href=/zh-cn/docsv2.7/user/references/registry/nacos/ title="Nacos 注册中心" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesregistrynacos><span>Nacos</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesregistryzookeeper-li><input type=checkbox id=m-zh-cndocsv27userreferencesregistryzookeeper-check>
<label for=m-zh-cndocsv27userreferencesregistryzookeeper-check><a href=/zh-cn/docsv2.7/user/references/registry/zookeeper/ title="Zookeeper 注册中心" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesregistryzookeeper><span>Zookeeper</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesregistrymulticast-li><input type=checkbox id=m-zh-cndocsv27userreferencesregistrymulticast-check>
<label for=m-zh-cndocsv27userreferencesregistrymulticast-check><a href=/zh-cn/docsv2.7/user/references/registry/multicast/ title="Multicast 注册中心" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesregistrymulticast><span>Multicast</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesregistryredis-li><input type=checkbox id=m-zh-cndocsv27userreferencesregistryredis-check>
<label for=m-zh-cndocsv27userreferencesregistryredis-check><a href=/zh-cn/docsv2.7/user/references/registry/redis/ title="Redis 注册中心" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesregistryredis><span>Redis</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesregistrysimple-li><input type=checkbox id=m-zh-cndocsv27userreferencesregistrysimple-check>
<label for=m-zh-cndocsv27userreferencesregistrysimple-check><a href=/zh-cn/docsv2.7/user/references/registry/simple/ title="Simple 注册中心" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesregistrysimple><span>Simple</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesmetadata-li><input type=checkbox id=m-zh-cndocsv27userreferencesmetadata-check>
<label for=m-zh-cndocsv27userreferencesmetadata-check><a href=/zh-cn/docsv2.7/user/references/metadata/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesmetadata><span>元数据参考手册</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesapi-li><input type=checkbox id=m-zh-cndocsv27userreferencesapi-check>
<label for=m-zh-cndocsv27userreferencesapi-check><a href=/zh-cn/docsv2.7/user/references/api/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesapi><span>API 参考手册</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesqos-li><input type=checkbox id=m-zh-cndocsv27userreferencesqos-check>
<label for=m-zh-cndocsv27userreferencesqos-check><a href=/zh-cn/docsv2.7/user/references/qos/ title=在线运维命令参考手册 class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesqos><span>QOS 手册</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencestelnet-li><input type=checkbox id=m-zh-cndocsv27userreferencestelnet-check>
<label for=m-zh-cndocsv27userreferencestelnet-check><a href=/zh-cn/docsv2.7/user/references/telnet/ title="Telnet 命令参考手册" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencestelnet><span>Telnet 手册</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userreferencesmaven-li><input type=checkbox id=m-zh-cndocsv27userreferencesmaven-check>
<label for=m-zh-cndocsv27userreferencesmaven-check><a href=/zh-cn/docsv2.7/user/references/maven/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userreferencesmaven><span>Maven 插件参考手册</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userversions-li><input type=checkbox id=m-zh-cndocsv27userversions-check>
<label for=m-zh-cndocsv27userversions-check><a href=/zh-cn/docsv2.7/user/versions/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userversions><span>版本升级</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userversionsversion-270-li><input type=checkbox id=m-zh-cndocsv27userversionsversion-270-check>
<label for=m-zh-cndocsv27userversionsversion-270-check><a href=/zh-cn/docsv2.7/user/versions/version-270/ title=升级与可能的兼容性问题总结 class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userversionsversion-270><span>2.7.0</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userbest-practice-li><input type=checkbox id=m-zh-cndocsv27userbest-practice-check>
<label for=m-zh-cndocsv27userbest-practice-check><a href=/zh-cn/docsv2.7/user/best-practice/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userbest-practice><span>服务化最佳实践</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userrecommend-li><input type=checkbox id=m-zh-cndocsv27userrecommend-check>
<label for=m-zh-cndocsv27userrecommend-check><a href=/zh-cn/docsv2.7/user/recommend/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userrecommend><span>推荐用法</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27usercapacity-plan-li><input type=checkbox id=m-zh-cndocsv27usercapacity-plan-check>
<label for=m-zh-cndocsv27usercapacity-plan-check><a href=/zh-cn/docsv2.7/user/capacity-plan/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27usercapacity-plan><span>容量规划</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userperf-test-li><input type=checkbox id=m-zh-cndocsv27userperf-test-check>
<label for=m-zh-cndocsv27userperf-test-check><a href=/zh-cn/docsv2.7/user/perf-test/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userperf-test><span>性能测试报告</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27usercoveragence-li><input type=checkbox id=m-zh-cndocsv27usercoveragence-check>
<label for=m-zh-cndocsv27usercoveragence-check><a href=/zh-cn/docsv2.7/user/coveragence/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27usercoveragence><span>测试覆盖率报告</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userbenchmark-tool-li><input type=checkbox id=m-zh-cndocsv27userbenchmark-tool-check>
<label for=m-zh-cndocsv27userbenchmark-tool-check><a href=/zh-cn/docsv2.7/user/benchmark-tool/ title=基准测试工具包 class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userbenchmark-tool><span>基准测试</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userrest-li><input type=checkbox id=m-zh-cndocsv27userrest-check>
<label for=m-zh-cndocsv27userrest-check><a href=/zh-cn/docsv2.7/user/rest/ title="开发 REST 应用" class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userrest><span>REST 支持</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27usersimple-monitor-li><input type=checkbox id=m-zh-cndocsv27usersimple-monitor-check>
<label for=m-zh-cndocsv27usersimple-monitor-check><a href=/zh-cn/docsv2.7/user/simple-monitor/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27usersimple-monitor><span>简单监控</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userserialization-li><input type=checkbox id=m-zh-cndocsv27userserialization-check>
<label for=m-zh-cndocsv27userserialization-check><a href=/zh-cn/docsv2.7/user/serialization/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userserialization><span>Kryo 和 FST 序列化</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userlanguages-li><input type=checkbox id=m-zh-cndocsv27userlanguages-check>
<label for=m-zh-cndocsv27userlanguages-check><a href=/zh-cn/docsv2.7/user/languages/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userlanguages><span>其他语言支持</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27userlanguageserlang-li><input type=checkbox id=m-zh-cndocsv27userlanguageserlang-check>
<label for=m-zh-cndocsv27userlanguageserlang-check><a href=/zh-cn/docsv2.7/user/languages/erlang/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27userlanguageserlang><span>Erlang</span></a></label><ul class="ul-4 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userlanguageserlangquick-start-li><input type=checkbox id=m-zh-cndocsv27userlanguageserlangquick-start-check>
<label for=m-zh-cndocsv27userlanguageserlangquick-start-check><a href=/zh-cn/docsv2.7/user/languages/erlang/quick-start/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userlanguageserlangquick-start><span>快速开始</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userlanguageserlangreference-li><input type=checkbox id=m-zh-cndocsv27userlanguageserlangreference-check>
<label for=m-zh-cndocsv27userlanguageserlangreference-check><a href=/zh-cn/docsv2.7/user/languages/erlang/reference/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userlanguageserlangreference><span>消费者配置</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userlanguageserlangservice-li><input type=checkbox id=m-zh-cndocsv27userlanguageserlangservice-check>
<label for=m-zh-cndocsv27userlanguageserlangservice-check><a href=/zh-cn/docsv2.7/user/languages/erlang/service/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userlanguageserlangservice><span>提供者配置</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27userlanguageserlangserialization-li><input type=checkbox id=m-zh-cndocsv27userlanguageserlangserialization-check>
<label for=m-zh-cndocsv27userlanguageserlangserialization-check><a href=/zh-cn/docsv2.7/user/languages/erlang/serialization/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27userlanguageserlangserialization><span>序列化配置项</span></a></label></li></ul></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27usernew-features-in-a-glance-li><input type=checkbox id=m-zh-cndocsv27usernew-features-in-a-glance-check>
<label for=m-zh-cndocsv27usernew-features-in-a-glance-check><a href=/zh-cn/docsv2.7/user/new-features-in-a-glance/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27usernew-features-in-a-glance><span></span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27dev-li><input type=checkbox id=m-zh-cndocsv27dev-check>
<label for=m-zh-cndocsv27dev-check><a href=/zh-cn/docsv2.7/dev/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27dev><span>开发指南</span></a></label><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devbuild-li><input type=checkbox id=m-zh-cndocsv27devbuild-check>
<label for=m-zh-cndocsv27devbuild-check><a href=/zh-cn/docsv2.7/dev/build/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devbuild><span>源码构建</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devdesign-li><input type=checkbox id=m-zh-cndocsv27devdesign-check>
<label for=m-zh-cndocsv27devdesign-check><a href=/zh-cn/docsv2.7/dev/design/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devdesign><span>框架设计</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devspi-li><input type=checkbox id=m-zh-cndocsv27devspi-check>
<label for=m-zh-cndocsv27devspi-check><a href=/zh-cn/docsv2.7/dev/spi/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devspi><span>扩展点加载</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplementation-li><input type=checkbox id=m-zh-cndocsv27devimplementation-check>
<label for=m-zh-cndocsv27devimplementation-check><a href=/zh-cn/docsv2.7/dev/implementation/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplementation><span>实现细节</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27devimpls-li><input type=checkbox id=m-zh-cndocsv27devimpls-check>
<label for=m-zh-cndocsv27devimpls-check><a href=/zh-cn/docsv2.7/dev/impls/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27devimpls><span>SPI 扩展实现</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsprotocol-li><input type=checkbox id=m-zh-cndocsv27devimplsprotocol-check>
<label for=m-zh-cndocsv27devimplsprotocol-check><a href=/zh-cn/docsv2.7/dev/impls/protocol/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsprotocol><span>协议扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsfilter-li><input type=checkbox id=m-zh-cndocsv27devimplsfilter-check>
<label for=m-zh-cndocsv27devimplsfilter-check><a href=/zh-cn/docsv2.7/dev/impls/filter/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsfilter><span>调用拦截扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsinvoker-listener-li><input type=checkbox id=m-zh-cndocsv27devimplsinvoker-listener-check>
<label for=m-zh-cndocsv27devimplsinvoker-listener-check><a href=/zh-cn/docsv2.7/dev/impls/invoker-listener/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsinvoker-listener><span>引用监听扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsexporter-listener-li><input type=checkbox id=m-zh-cndocsv27devimplsexporter-listener-check>
<label for=m-zh-cndocsv27devimplsexporter-listener-check><a href=/zh-cn/docsv2.7/dev/impls/exporter-listener/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsexporter-listener><span>暴露监听扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplscluster-li><input type=checkbox id=m-zh-cndocsv27devimplscluster-check>
<label for=m-zh-cndocsv27devimplscluster-check><a href=/zh-cn/docsv2.7/dev/impls/cluster/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplscluster><span>集群扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsrouter-li><input type=checkbox id=m-zh-cndocsv27devimplsrouter-check>
<label for=m-zh-cndocsv27devimplsrouter-check><a href=/zh-cn/docsv2.7/dev/impls/router/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsrouter><span>路由扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsload-balance-li><input type=checkbox id=m-zh-cndocsv27devimplsload-balance-check>
<label for=m-zh-cndocsv27devimplsload-balance-check><a href=/zh-cn/docsv2.7/dev/impls/load-balance/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsload-balance><span>负载均衡扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsmerger-li><input type=checkbox id=m-zh-cndocsv27devimplsmerger-check>
<label for=m-zh-cndocsv27devimplsmerger-check><a href=/zh-cn/docsv2.7/dev/impls/merger/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsmerger><span>合并结果扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsregistry-li><input type=checkbox id=m-zh-cndocsv27devimplsregistry-check>
<label for=m-zh-cndocsv27devimplsregistry-check><a href=/zh-cn/docsv2.7/dev/impls/registry/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsregistry><span>注册中心扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsmonitor-li><input type=checkbox id=m-zh-cndocsv27devimplsmonitor-check>
<label for=m-zh-cndocsv27devimplsmonitor-check><a href=/zh-cn/docsv2.7/dev/impls/monitor/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsmonitor><span>监控中心扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsextension-factory-li><input type=checkbox id=m-zh-cndocsv27devimplsextension-factory-check>
<label for=m-zh-cndocsv27devimplsextension-factory-check><a href=/zh-cn/docsv2.7/dev/impls/extension-factory/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsextension-factory><span>扩展点加载扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsproxy-factory-li><input type=checkbox id=m-zh-cndocsv27devimplsproxy-factory-check>
<label for=m-zh-cndocsv27devimplsproxy-factory-check><a href=/zh-cn/docsv2.7/dev/impls/proxy-factory/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsproxy-factory><span>动态代理扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplscompiler-li><input type=checkbox id=m-zh-cndocsv27devimplscompiler-check>
<label for=m-zh-cndocsv27devimplscompiler-check><a href=/zh-cn/docsv2.7/dev/impls/compiler/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplscompiler><span>编译器扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsconfig-center-li><input type=checkbox id=m-zh-cndocsv27devimplsconfig-center-check>
<label for=m-zh-cndocsv27devimplsconfig-center-check><a href=/zh-cn/docsv2.7/dev/impls/config-center/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsconfig-center><span>配置中心扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsdispatcher-li><input type=checkbox id=m-zh-cndocsv27devimplsdispatcher-check>
<label for=m-zh-cndocsv27devimplsdispatcher-check><a href=/zh-cn/docsv2.7/dev/impls/dispatcher/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsdispatcher><span>消息派发扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsthreadpool-li><input type=checkbox id=m-zh-cndocsv27devimplsthreadpool-check>
<label for=m-zh-cndocsv27devimplsthreadpool-check><a href=/zh-cn/docsv2.7/dev/impls/threadpool/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsthreadpool><span>线程池扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsserialize-li><input type=checkbox id=m-zh-cndocsv27devimplsserialize-check>
<label for=m-zh-cndocsv27devimplsserialize-check><a href=/zh-cn/docsv2.7/dev/impls/serialize/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsserialize><span>序列化扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsremoting-li><input type=checkbox id=m-zh-cndocsv27devimplsremoting-check>
<label for=m-zh-cndocsv27devimplsremoting-check><a href=/zh-cn/docsv2.7/dev/impls/remoting/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsremoting><span>网络传输扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsexchanger-li><input type=checkbox id=m-zh-cndocsv27devimplsexchanger-check>
<label for=m-zh-cndocsv27devimplsexchanger-check><a href=/zh-cn/docsv2.7/dev/impls/exchanger/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsexchanger><span>信息交换扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsnetworker-li><input type=checkbox id=m-zh-cndocsv27devimplsnetworker-check>
<label for=m-zh-cndocsv27devimplsnetworker-check><a href=/zh-cn/docsv2.7/dev/impls/networker/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsnetworker><span>组网扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplstelnet-handler-li><input type=checkbox id=m-zh-cndocsv27devimplstelnet-handler-check>
<label for=m-zh-cndocsv27devimplstelnet-handler-check><a href=/zh-cn/docsv2.7/dev/impls/telnet-handler/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplstelnet-handler><span>Telnet 命令扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsstatus-checker-li><input type=checkbox id=m-zh-cndocsv27devimplsstatus-checker-check>
<label for=m-zh-cndocsv27devimplsstatus-checker-check><a href=/zh-cn/docsv2.7/dev/impls/status-checker/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsstatus-checker><span>状态检查扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplscontainer-li><input type=checkbox id=m-zh-cndocsv27devimplscontainer-check>
<label for=m-zh-cndocsv27devimplscontainer-check><a href=/zh-cn/docsv2.7/dev/impls/container/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplscontainer><span>容器扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplscache-li><input type=checkbox id=m-zh-cndocsv27devimplscache-check>
<label for=m-zh-cndocsv27devimplscache-check><a href=/zh-cn/docsv2.7/dev/impls/cache/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplscache><span>缓存扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplsvalidation-li><input type=checkbox id=m-zh-cndocsv27devimplsvalidation-check>
<label for=m-zh-cndocsv27devimplsvalidation-check><a href=/zh-cn/docsv2.7/dev/impls/validation/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplsvalidation><span>验证扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplslogger-adapter-li><input type=checkbox id=m-zh-cndocsv27devimplslogger-adapter-check>
<label for=m-zh-cndocsv27devimplslogger-adapter-check><a href=/zh-cn/docsv2.7/dev/impls/logger-adapter/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplslogger-adapter><span>日志适配扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devimplspage-li><input type=checkbox id=m-zh-cndocsv27devimplspage-check>
<label for=m-zh-cndocsv27devimplspage-check><a href=/zh-cn/docsv2.7/dev/impls/page/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devimplspage><span></span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27devprincipals-li><input type=checkbox id=m-zh-cndocsv27devprincipals-check>
<label for=m-zh-cndocsv27devprincipals-check><a href=/zh-cn/docsv2.7/dev/principals/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27devprincipals><span>设计原则</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devprincipalscode-detail-li><input type=checkbox id=m-zh-cndocsv27devprincipalscode-detail-check>
<label for=m-zh-cndocsv27devprincipalscode-detail-check><a href=/zh-cn/docsv2.7/dev/principals/code-detail/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devprincipalscode-detail><span>魔鬼在细节</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devprincipalsconfiguration-li><input type=checkbox id=m-zh-cndocsv27devprincipalsconfiguration-check>
<label for=m-zh-cndocsv27devprincipalsconfiguration-check><a href=/zh-cn/docsv2.7/dev/principals/configuration/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devprincipalsconfiguration><span>配置设计</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devprincipalsdummy-li><input type=checkbox id=m-zh-cndocsv27devprincipalsdummy-check>
<label for=m-zh-cndocsv27devprincipalsdummy-check><a href=/zh-cn/docsv2.7/dev/principals/dummy/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devprincipalsdummy><span>防痴呆设计</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devprincipalsexpansibility-li><input type=checkbox id=m-zh-cndocsv27devprincipalsexpansibility-check>
<label for=m-zh-cndocsv27devprincipalsexpansibility-check><a href=/zh-cn/docsv2.7/dev/principals/expansibility/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devprincipalsexpansibility><span>谈谈扩充式扩展与增量式扩展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devprincipalsextension-li><input type=checkbox id=m-zh-cndocsv27devprincipalsextension-check>
<label for=m-zh-cndocsv27devprincipalsextension-check><a href=/zh-cn/docsv2.7/dev/principals/extension/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devprincipalsextension><span>扩展点重构</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devprincipalsgeneral-knowledge-li><input type=checkbox id=m-zh-cndocsv27devprincipalsgeneral-knowledge-check>
<label for=m-zh-cndocsv27devprincipalsgeneral-knowledge-check><a href=/zh-cn/docsv2.7/dev/principals/general-knowledge/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devprincipalsgeneral-knowledge><span>一些设计上的基本常识</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devprincipalsrobustness-li><input type=checkbox id=m-zh-cndocsv27devprincipalsrobustness-check>
<label for=m-zh-cndocsv27devprincipalsrobustness-check><a href=/zh-cn/docsv2.7/dev/principals/robustness/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devprincipalsrobustness><span>设计实现的健壮性</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devprincipalsintroduction-li><input type=checkbox id=m-zh-cndocsv27devprincipalsintroduction-check>
<label for=m-zh-cndocsv27devprincipalsintroduction-check><a href=/zh-cn/docsv2.7/dev/principals/introduction/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devprincipalsintroduction><span></span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devcontract-li><input type=checkbox id=m-zh-cndocsv27devcontract-check>
<label for=m-zh-cndocsv27devcontract-check><a href=/zh-cn/docsv2.7/dev/contract/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devcontract><span>公共契约</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27devsource-li><input type=checkbox id=m-zh-cndocsv27devsource-check>
<label for=m-zh-cndocsv27devsource-check><a href=/zh-cn/docsv2.7/dev/source/ title="Dubbo 源代码分析" class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27devsource><span>源代码</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devsourcedubbo-spi-li><input type=checkbox id=m-zh-cndocsv27devsourcedubbo-spi-check>
<label for=m-zh-cndocsv27devsourcedubbo-spi-check><a href=/zh-cn/docsv2.7/dev/source/dubbo-spi/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devsourcedubbo-spi><span>Dubbo SPI</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devsourcerouter-li><input type=checkbox id=m-zh-cndocsv27devsourcerouter-check>
<label for=m-zh-cndocsv27devsourcerouter-check><a href=/zh-cn/docsv2.7/dev/source/router/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devsourcerouter><span>服务路由</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devsourceadaptive-extension-li><input type=checkbox id=m-zh-cndocsv27devsourceadaptive-extension-check>
<label for=m-zh-cndocsv27devsourceadaptive-extension-check><a href=/zh-cn/docsv2.7/dev/source/adaptive-extension/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devsourceadaptive-extension><span>SPI 自适应拓展</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devsourceexport-service-li><input type=checkbox id=m-zh-cndocsv27devsourceexport-service-check>
<label for=m-zh-cndocsv27devsourceexport-service-check><a href=/zh-cn/docsv2.7/dev/source/export-service/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devsourceexport-service><span>服务导出</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devsourcerefer-service-li><input type=checkbox id=m-zh-cndocsv27devsourcerefer-service-check>
<label for=m-zh-cndocsv27devsourcerefer-service-check><a href=/zh-cn/docsv2.7/dev/source/refer-service/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devsourcerefer-service><span>服务引用</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devsourceservice-invoking-process-li><input type=checkbox id=m-zh-cndocsv27devsourceservice-invoking-process-check>
<label for=m-zh-cndocsv27devsourceservice-invoking-process-check><a href=/zh-cn/docsv2.7/dev/source/service-invoking-process/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devsourceservice-invoking-process><span>服务调用过程</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devsourcedirectory-li><input type=checkbox id=m-zh-cndocsv27devsourcedirectory-check>
<label for=m-zh-cndocsv27devsourcedirectory-check><a href=/zh-cn/docsv2.7/dev/source/directory/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devsourcedirectory><span>服务目录</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devsourcecluster-li><input type=checkbox id=m-zh-cndocsv27devsourcecluster-check>
<label for=m-zh-cndocsv27devsourcecluster-check><a href=/zh-cn/docsv2.7/dev/source/cluster/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devsourcecluster><span>集群</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devsourceloadbalance-li><input type=checkbox id=m-zh-cndocsv27devsourceloadbalance-check>
<label for=m-zh-cndocsv27devsourceloadbalance-check><a href=/zh-cn/docsv2.7/dev/source/loadbalance/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devsourceloadbalance><span>负载均衡</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devrelease-li><input type=checkbox id=m-zh-cndocsv27devrelease-check>
<label for=m-zh-cndocsv27devrelease-check><a href=/zh-cn/docsv2.7/dev/release/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devrelease><span>版本管理</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devchecklist-li><input type=checkbox id=m-zh-cndocsv27devchecklist-check>
<label for=m-zh-cndocsv27devchecklist-check><a href=/zh-cn/docsv2.7/dev/checklist/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devchecklist><span>检查列表</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devcoding-li><input type=checkbox id=m-zh-cndocsv27devcoding-check>
<label for=m-zh-cndocsv27devcoding-check><a href=/zh-cn/docsv2.7/dev/coding/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devcoding><span>编码约定</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devcode-smell-li><input type=checkbox id=m-zh-cndocsv27devcode-smell-check>
<label for=m-zh-cndocsv27devcode-smell-check><a href=/zh-cn/docsv2.7/dev/code-smell/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devcode-smell><span>坏味道</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27devtck-li><input type=checkbox id=m-zh-cndocsv27devtck-check>
<label for=m-zh-cndocsv27devtck-check><a href=/zh-cn/docsv2.7/dev/tck/ title=技术兼容性测试 class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27devtck><span>TCK</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27admin-li><input type=checkbox id=m-zh-cndocsv27admin-check>
<label for=m-zh-cndocsv27admin-check><a href=/zh-cn/docsv2.7/admin/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27admin><span>运维指南</span></a></label><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27adminops-li><input type=checkbox id=m-zh-cndocsv27adminops-check>
<label for=m-zh-cndocsv27adminops-check><a href=/zh-cn/docsv2.7/admin/ops/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27adminops><span>Dubbo Admin 运维指南</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27adminopsfunctions-li><input type=checkbox id=m-zh-cndocsv27adminopsfunctions-check>
<label for=m-zh-cndocsv27adminopsfunctions-check><a href=/zh-cn/docsv2.7/admin/ops/functions/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27adminopsfunctions><span>管理控制台运维</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27adminopsintroduction-li><input type=checkbox id=m-zh-cndocsv27adminopsintroduction-check>
<label for=m-zh-cndocsv27adminopsintroduction-check><a href=/zh-cn/docsv2.7/admin/ops/introduction/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27adminopsintroduction><span>Dubbo 管理控制台介绍</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27adminopstest-li><input type=checkbox id=m-zh-cndocsv27adminopstest-check>
<label for=m-zh-cndocsv27adminopstest-check><a href=/zh-cn/docsv2.7/admin/ops/test/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27adminopstest><span>服务测试</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27adminopssearch-li><input type=checkbox id=m-zh-cndocsv27adminopssearch-check>
<label for=m-zh-cndocsv27adminopssearch-check><a href=/zh-cn/docsv2.7/admin/ops/search/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27adminopssearch><span>服务查询和详情展示</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27adminopsapidocs-li><input type=checkbox id=m-zh-cndocsv27adminopsapidocs-check>
<label for=m-zh-cndocsv27adminopsapidocs-check><a href=/zh-cn/docsv2.7/admin/ops/apidocs/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27adminopsapidocs><span>API文档&测试</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27adminopsgovernance-li><input type=checkbox id=m-zh-cndocsv27adminopsgovernance-check>
<label for=m-zh-cndocsv27adminopsgovernance-check><a href=/zh-cn/docsv2.7/admin/ops/governance/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27adminopsgovernance><span>服务治理和配置管理</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27adminopsskywalking-li><input type=checkbox id=m-zh-cndocsv27adminopsskywalking-check>
<label for=m-zh-cndocsv27adminopsskywalking-check><a href=/zh-cn/docsv2.7/admin/ops/skywalking/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27adminopsskywalking><span>使用 Apache Skywalking 做分布式跟踪</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27adminopspinpoint-li><input type=checkbox id=m-zh-cndocsv27adminopspinpoint-check>
<label for=m-zh-cndocsv27adminopspinpoint-check><a href=/zh-cn/docsv2.7/admin/ops/pinpoint/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27adminopspinpoint><span>使用 Pinpoint 做分布式跟踪</span></a></label></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-zh-cndocsv27admininstall-li><input type=checkbox id=m-zh-cndocsv27admininstall-check>
<label for=m-zh-cndocsv27admininstall-check><a href=/zh-cn/docsv2.7/admin/install/ class="align-left pl-0 td-sidebar-link td-sidebar-link__section" id=m-zh-cndocsv27admininstall><span>安装手册</span></a></label><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27admininstalladmin-console-li><input type=checkbox id=m-zh-cndocsv27admininstalladmin-console-check>
<label for=m-zh-cndocsv27admininstalladmin-console-check><a href=/zh-cn/docsv2.7/admin/install/admin-console/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27admininstalladmin-console><span>管理控制台安装</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27admininstallprovider-demo-li><input type=checkbox id=m-zh-cndocsv27admininstallprovider-demo-check>
<label for=m-zh-cndocsv27admininstallprovider-demo-check><a href=/zh-cn/docsv2.7/admin/install/provider-demo/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27admininstallprovider-demo><span>示例提供者安装</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27admininstallconsumer-demo-li><input type=checkbox id=m-zh-cndocsv27admininstallconsumer-demo-check>
<label for=m-zh-cndocsv27admininstallconsumer-demo-check><a href=/zh-cn/docsv2.7/admin/install/consumer-demo/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27admininstallconsumer-demo><span>示例消费者安装</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27admininstallredis-li><input type=checkbox id=m-zh-cndocsv27admininstallredis-check>
<label for=m-zh-cndocsv27admininstallredis-check><a href=/zh-cn/docsv2.7/admin/install/redis/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27admininstallredis><span>Redis 注册中心安装</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27admininstallzookeeper-li><input type=checkbox id=m-zh-cndocsv27admininstallzookeeper-check>
<label for=m-zh-cndocsv27admininstallzookeeper-check><a href=/zh-cn/docsv2.7/admin/install/zookeeper/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27admininstallzookeeper><span>Zookeeper 注册中心安装</span></a></label></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-zh-cndocsv27admininstallmonitor-center-li><input type=checkbox id=m-zh-cndocsv27admininstallmonitor-center-check>
<label for=m-zh-cndocsv27admininstallmonitor-center-check><a href=/zh-cn/docsv2.7/admin/install/monitor-center/ class="align-left pl-0 td-sidebar-link td-sidebar-link__page" id=m-zh-cndocsv27admininstallmonitor-center><span>Simple 监控中心安装</span></a></label></li></ul></li></ul></li></ul></li></ul></nav></div></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><nav aria-label=breadcrumb class=td-breadcrumbs><ol class=breadcrumb><li class=breadcrumb-item><a href=https://dubbo.apache.org/zh-cn/docsv2.7/>文档 2.x</a></li><li class=breadcrumb-item><a href=https://dubbo.apache.org/zh-cn/docsv2.7/dev/>开发指南</a></li><li class=breadcrumb-item><a href=https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/>源代码</a></li><li class="breadcrumb-item active" aria-current=page><a href=https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/service-invoking-process/ aria-disabled=true class="btn-link disabled">服务调用过程</a></li></ol></nav><div class=td-content><h1>服务调用过程</h1><div class=lead>本文介绍了服务调用过程的原理和实现细节</div><header class=article-meta></header><h2 id=1-简介>1. 简介</h2><p>在前面的文章中，我们分析了 Dubbo SPI、服务导出与引入、以及集群容错方面的代码。经过前文的铺垫，本篇文章我们终于可以分析服务调用过程了。Dubbo 服务调用过程比较复杂，包含众多步骤，比如发送请求、编解码、服务降级、过滤器链处理、序列化、线程派发以及响应请求等步骤。限于篇幅原因，本篇文章无法对所有的步骤一一进行分析。本篇文章将会重点分析请求的发送与接收、编解码、线程派发以及响应的发送与接收等过程，至于服务降级、过滤器链和序列化大家自行进行分析，也可以将其当成一个黑盒，暂时忽略也没关系。介绍完本篇文章要分析的内容，接下来我们进入正题吧。</p><h2 id=2-源码分析>2. 源码分析</h2><p>在进行源码分析之前，我们先来通过一张图了解 Dubbo 服务调用过程。</p><p><img src=/imgs/dev/send-request-process.jpg alt=img></p><p>首先服务消费者通过代理对象 Proxy 发起远程调用，接着通过网络客户端 Client 将编码后的请求发送给服务提供方的网络层上，也就是 Server。Server 在收到请求后，首先要做的事情是对数据包进行解码。然后将解码后的请求发送至分发器 Dispatcher，再由分发器将请求派发到指定的线程池上，最后由线程池调用具体的服务。这就是一个远程调用请求的发送与接收过程。至于响应的发送与接收过程，这张图中没有表现出来。对于这两个过程，我们也会进行详细分析。</p><h3 id=21-服务调用方式>2.1 服务调用方式</h3><p>Dubbo 支持同步和异步两种调用方式，其中异步调用还可细分为“有返回值”的异步调用和“无返回值”的异步调用。所谓“无返回值”异步调用是指服务消费方只管调用，但不关心调用结果，此时 Dubbo 会直接返回一个空的 RpcResult。若要使用异步特性，需要服务消费方手动进行配置。默认情况下，Dubbo 使用同步调用方式。</p><p>本节以及其他章节将会使用 Dubbo 官方提供的 Demo 分析整个调用过程，下面我们从 DemoService 接口的代理类开始进行分析。Dubbo 默认使用 Javassist 框架为服务接口生成动态代理类，因此我们需要先将代理类进行反编译才能看到源码。这里使用阿里开源 Java 应用诊断工具 <a href=https://github.com/alibaba/arthas>Arthas</a> 反编译代理类，结果如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#586e75>/**
</span></span></span><span style=display:flex><span><span style=color:#586e75> * Arthas 反编译步骤：
</span></span></span><span style=display:flex><span><span style=color:#586e75> * 1. 启动 Arthas
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    java -jar arthas-boot.jar
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * 2. 输入编号选择进程
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    Arthas 启动后，会打印 Java 应用进程列表，如下：
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    [1]: 11232 org.jetbrains.jps.cmdline.Launcher
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    [2]: 22370 org.jetbrains.jps.cmdline.Launcher
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    [3]: 22371 com.alibaba.dubbo.demo.consumer.Consumer
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    [4]: 22362 com.alibaba.dubbo.demo.provider.Provider
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    [5]: 2074 org.apache.zookeeper.server.quorum.QuorumPeerMain
</span></span></span><span style=display:flex><span><span style=color:#586e75> * 这里输入编号 3，让 Arthas 关联到启动类为 com.....Consumer 的 Java 进程上
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * 3. 由于 Demo 项目中只有一个服务接口，因此此接口的代理类类名为 proxy0，此时使用 sc 命令搜索这个类名。
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    $ sc *.proxy0
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    com.alibaba.dubbo.common.bytecode.proxy0
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * 4. 使用 jad 命令反编译 com.alibaba.dubbo.common.bytecode.proxy0
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    $ jad com.alibaba.dubbo.common.bytecode.proxy0
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * 更多使用方法请参考 Arthas 官方文档：
</span></span></span><span style=display:flex><span><span style=color:#586e75> *   https://arthas.aliyun.com/doc/quick-start.html
</span></span></span><span style=display:flex><span><span style=color:#586e75> */</span>
</span></span><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>proxy0</span> <span style=color:#268bd2>implements</span> ClassGenerator.DC, EchoService, DemoService {
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 方法数组</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>static</span> Method<span style=color:#719e07>[]</span> methods;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> InvocationHandler handler;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>proxy0</span>(InvocationHandler invocationHandler) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.handler <span style=color:#719e07>=</span> invocationHandler;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>proxy0</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> String <span style=color:#268bd2>sayHello</span>(String string) {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 将参数存储到 Object 数组中</span>
</span></span><span style=display:flex><span>        Object<span style=color:#719e07>[]</span> arrobject <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> Object<span style=color:#719e07>[]</span>{string};
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 调用 InvocationHandler 实现类的 invoke 方法得到调用结果</span>
</span></span><span style=display:flex><span>        Object object <span style=color:#719e07>=</span> <span style=color:#719e07>this</span>.handler.invoke(<span style=color:#719e07>this</span>, methods<span style=color:#719e07>[</span>0<span style=color:#719e07>]</span>, arrobject);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 返回调用结果</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> (String)object;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>/** 回声测试方法 */</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Object <span style=color:#268bd2>$echo</span>(Object object) {
</span></span><span style=display:flex><span>        Object<span style=color:#719e07>[]</span> arrobject <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> Object<span style=color:#719e07>[]</span>{object};
</span></span><span style=display:flex><span>        Object object2 <span style=color:#719e07>=</span> <span style=color:#719e07>this</span>.handler.invoke(<span style=color:#719e07>this</span>, methods<span style=color:#719e07>[</span>1<span style=color:#719e07>]</span>, arrobject);
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> object2;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上，代理类的逻辑比较简单。首先将运行时参数存储到数组中，然后调用 InvocationHandler 接口实现类的 invoke 方法，得到调用结果，最后将结果转型并返回给调用方。关于代理类的逻辑就说这么多，继续向下分析。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>InvokerInvocationHandler</span> <span style=color:#268bd2>implements</span> InvocationHandler {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Invoker<span style=color:#719e07>&lt;?&gt;</span> invoker;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>InvokerInvocationHandler</span>(Invoker<span style=color:#719e07>&lt;?&gt;</span> handler) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.invoker <span style=color:#719e07>=</span> handler;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Object <span style=color:#268bd2>invoke</span>(Object proxy, Method method, Object<span style=color:#719e07>[]</span> args) <span style=color:#268bd2>throws</span> Throwable {
</span></span><span style=display:flex><span>        String methodName <span style=color:#719e07>=</span> method.getName();
</span></span><span style=display:flex><span>        Class<span style=color:#719e07>&lt;?&gt;[]</span> parameterTypes <span style=color:#719e07>=</span> method.getParameterTypes();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 拦截定义在 Object 类中的方法（未被子类重写），比如 wait/notify</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (method.getDeclaringClass() <span style=color:#719e07>==</span> Object.class) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> method.invoke(invoker, args);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 如果 toString、hashCode 和 equals 等方法被子类重写了，这里也直接调用</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (<span style=color:#2aa198>&#34;toString&#34;</span>.equals(methodName) <span style=color:#719e07>&amp;&amp;</span> parameterTypes.length <span style=color:#719e07>==</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> invoker.toString();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (<span style=color:#2aa198>&#34;hashCode&#34;</span>.equals(methodName) <span style=color:#719e07>&amp;&amp;</span> parameterTypes.length <span style=color:#719e07>==</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> invoker.hashCode();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (<span style=color:#2aa198>&#34;equals&#34;</span>.equals(methodName) <span style=color:#719e07>&amp;&amp;</span> parameterTypes.length <span style=color:#719e07>==</span> 1) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> invoker.equals(args<span style=color:#719e07>[</span>0<span style=color:#719e07>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 将 method 和 args 封装到 RpcInvocation 中，并执行后续的调用</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> invoker.invoke(<span style=color:#719e07>new</span> RpcInvocation(method, args)).recreate();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>InvokerInvocationHandler 中的 invoker 成员变量类型为 MockClusterInvoker，MockClusterInvoker 内部封装了服务降级逻辑。下面简单看一下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>MockClusterInvoker</span><span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> <span style=color:#268bd2>implements</span> Invoker<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Invoker<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> invoker;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Result <span style=color:#268bd2>invoke</span>(Invocation invocation) <span style=color:#268bd2>throws</span> RpcException {
</span></span><span style=display:flex><span>        Result result <span style=color:#719e07>=</span> <span style=color:#cb4b16>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取 mock 配置值</span>
</span></span><span style=display:flex><span>        String value <span style=color:#719e07>=</span> directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (value.length() <span style=color:#719e07>==</span> 0 <span style=color:#719e07>||</span> value.equalsIgnoreCase(<span style=color:#2aa198>&#34;false&#34;</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 无 mock 逻辑，直接调用其他 Invoker 对象的 invoke 方法，</span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 比如 FailoverClusterInvoker</span>
</span></span><span style=display:flex><span>            result <span style=color:#719e07>=</span> <span style=color:#719e07>this</span>.invoker.invoke(invocation);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (value.startsWith(<span style=color:#2aa198>&#34;force&#34;</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// force:xxx 直接执行 mock 逻辑，不发起远程调用</span>
</span></span><span style=display:flex><span>            result <span style=color:#719e07>=</span> doMockInvoke(invocation, <span style=color:#cb4b16>null</span>);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// fail:xxx 表示消费方对调用服务失败后，再执行 mock 逻辑，不抛出异常</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 调用其他 Invoker 对象的 invoke 方法</span>
</span></span><span style=display:flex><span>                result <span style=color:#719e07>=</span> <span style=color:#719e07>this</span>.invoker.invoke(invocation);
</span></span><span style=display:flex><span>            } <span style=color:#719e07>catch</span> (RpcException e) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span> (e.isBiz()) {
</span></span><span style=display:flex><span>                    <span style=color:#719e07>throw</span> e;
</span></span><span style=display:flex><span>                } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 调用失败，执行 mock 逻辑</span>
</span></span><span style=display:flex><span>                    result <span style=color:#719e07>=</span> doMockInvoke(invocation, e);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> result;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略其他方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>服务降级不是本文重点，因此这里就不分析 doMockInvoke 方法了。考虑到前文已经详细分析过 FailoverClusterInvoker，因此本节略过 FailoverClusterInvoker，直接分析 DubboInvoker。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>abstract</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>AbstractInvoker</span><span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> <span style=color:#268bd2>implements</span> Invoker<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Result <span style=color:#268bd2>invoke</span>(Invocation inv) <span style=color:#268bd2>throws</span> RpcException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (destroyed.get()) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RpcException(<span style=color:#2aa198>&#34;Rpc invoker for service ...&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        RpcInvocation invocation <span style=color:#719e07>=</span> (RpcInvocation) inv;
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 设置 Invoker</span>
</span></span><span style=display:flex><span>        invocation.setInvoker(<span style=color:#719e07>this</span>);
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (attachment <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>&amp;&amp;</span> attachment.size() <span style=color:#719e07>&gt;</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置 attachment</span>
</span></span><span style=display:flex><span>            invocation.addAttachmentsIfAbsent(attachment);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Map<span style=color:#719e07>&lt;</span>String, String<span style=color:#719e07>&gt;</span> contextAttachments <span style=color:#719e07>=</span> RpcContext.getContext().getAttachments();
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (contextAttachments <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>&amp;&amp;</span> contextAttachments.size() <span style=color:#719e07>!=</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 添加 contextAttachments 到 RpcInvocation#attachment 变量中</span>
</span></span><span style=display:flex><span>            invocation.addAttachments(contextAttachments);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, <span style=color:#cb4b16>false</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置异步信息到 RpcInvocation#attachment 中</span>
</span></span><span style=display:flex><span>            invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 抽象方法，由子类实现</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> doInvoke(invocation);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (InvocationTargetException e) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (RpcException e) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> <span style=color:#719e07>new</span> RpcResult(e);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>abstract</span> Result <span style=color:#268bd2>doInvoke</span>(Invocation invocation) <span style=color:#268bd2>throws</span> Throwable;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略其他方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的代码来自 AbstractInvoker 类，其中大部分代码用于添加信息到 RpcInvocation#attachment 变量中，添加完毕后，调用 doInvoke 执行后续的调用。doInvoke 是一个抽象方法，需要由子类实现，下面到 DubboInvoker 中看一下。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DubboInvoker</span><span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> <span style=color:#268bd2>extends</span> AbstractInvoker<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> ExchangeClient<span style=color:#719e07>[]</span> clients;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> Result <span style=color:#268bd2>doInvoke</span>(<span style=color:#268bd2>final</span> Invocation invocation) <span style=color:#268bd2>throws</span> Throwable {
</span></span><span style=display:flex><span>        RpcInvocation inv <span style=color:#719e07>=</span> (RpcInvocation) invocation;
</span></span><span style=display:flex><span>        <span style=color:#268bd2>final</span> String methodName <span style=color:#719e07>=</span> RpcUtils.getMethodName(invocation);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 设置 path 和 version 到 attachment 中</span>
</span></span><span style=display:flex><span>        inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());
</span></span><span style=display:flex><span>        inv.setAttachment(Constants.VERSION_KEY, version);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ExchangeClient currentClient;
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (clients.length <span style=color:#719e07>==</span> 1) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 从 clients 数组中获取 ExchangeClient</span>
</span></span><span style=display:flex><span>            currentClient <span style=color:#719e07>=</span> clients<span style=color:#719e07>[</span>0<span style=color:#719e07>]</span>;
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>            currentClient <span style=color:#719e07>=</span> clients<span style=color:#719e07>[</span>index.getAndIncrement() <span style=color:#719e07>%</span> clients.length<span style=color:#719e07>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 获取异步配置</span>
</span></span><span style=display:flex><span>            <span style=color:#dc322f>boolean</span> isAsync <span style=color:#719e07>=</span> RpcUtils.isAsync(getUrl(), invocation);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// isOneway 为 true，表示“单向”通信</span>
</span></span><span style=display:flex><span>            <span style=color:#dc322f>boolean</span> isOneway <span style=color:#719e07>=</span> RpcUtils.isOneway(getUrl(), invocation);
</span></span><span style=display:flex><span>            <span style=color:#dc322f>int</span> timeout <span style=color:#719e07>=</span> getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 异步无返回值</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (isOneway) {
</span></span><span style=display:flex><span>                <span style=color:#dc322f>boolean</span> isSent <span style=color:#719e07>=</span> getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span style=color:#cb4b16>false</span>);
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 发送请求</span>
</span></span><span style=display:flex><span>                currentClient.send(inv, isSent);
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 设置上下文中的 future 字段为 null</span>
</span></span><span style=display:flex><span>                RpcContext.getContext().setFuture(<span style=color:#cb4b16>null</span>);
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 返回一个空的 RpcResult</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>return</span> <span style=color:#719e07>new</span> RpcResult();
</span></span><span style=display:flex><span>            } 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 异步有返回值</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (isAsync) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 发送请求，并得到一个 ResponseFuture 实例</span>
</span></span><span style=display:flex><span>                ResponseFuture future <span style=color:#719e07>=</span> currentClient.request(inv, timeout);
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 设置 future 到上下文中</span>
</span></span><span style=display:flex><span>                RpcContext.getContext().setFuture(<span style=color:#719e07>new</span> FutureAdapter<span style=color:#719e07>&lt;</span>Object<span style=color:#719e07>&gt;</span>(future));
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 暂时返回一个空结果</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>return</span> <span style=color:#719e07>new</span> RpcResult();
</span></span><span style=display:flex><span>            } 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 同步调用</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                RpcContext.getContext().setFuture(<span style=color:#cb4b16>null</span>);
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 发送请求，得到一个 ResponseFuture 实例，并调用该实例的 get 方法进行等待</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>return</span> (Result) currentClient.request(inv, timeout).get();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (TimeoutException e) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RpcException(..., <span style=color:#2aa198>&#34;Invoke remote method timeout....&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (RemotingException e) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RpcException(..., <span style=color:#2aa198>&#34;Failed to invoke remote method: ...&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略其他方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的代码包含了 Dubbo 对同步和异步调用的处理逻辑，搞懂了上面的代码，会对 Dubbo 的同步和异步调用方式有更深入的了解。Dubbo 实现同步和异步调用比较关键的一点就在于由谁调用 ResponseFuture 的 get 方法。同步调用模式下，由框架自身调用 ResponseFuture 的 get 方法。异步调用模式下，则由用户调用该方法。ResponseFuture 是一个接口，下面我们来看一下它的默认实现类 DefaultFuture 的源码。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DefaultFuture</span> <span style=color:#268bd2>implements</span> ResponseFuture {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> Map<span style=color:#719e07>&lt;</span>Long, Channel<span style=color:#719e07>&gt;</span> CHANNELS <span style=color:#719e07>=</span> 
</span></span><span style=display:flex><span>        <span style=color:#719e07>new</span> ConcurrentHashMap<span style=color:#719e07>&lt;</span>Long, Channel<span style=color:#719e07>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> Map<span style=color:#719e07>&lt;</span>Long, DefaultFuture<span style=color:#719e07>&gt;</span> FUTURES <span style=color:#719e07>=</span> 
</span></span><span style=display:flex><span>        <span style=color:#719e07>new</span> ConcurrentHashMap<span style=color:#719e07>&lt;</span>Long, DefaultFuture<span style=color:#719e07>&gt;</span>();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>long</span> id;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Channel channel;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Request request;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>int</span> timeout;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Lock lock <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> ReentrantLock();
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Condition done <span style=color:#719e07>=</span> lock.newCondition();
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>volatile</span> Response response;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>DefaultFuture</span>(Channel channel, Request request, <span style=color:#dc322f>int</span> timeout) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.channel <span style=color:#719e07>=</span> channel;
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.request <span style=color:#719e07>=</span> request;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取请求 id，这个 id 很重要，后面还会见到</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.id <span style=color:#719e07>=</span> request.getId();
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.timeout <span style=color:#719e07>=</span> timeout <span style=color:#719e07>&gt;</span> 0 <span style=color:#719e07>?</span> timeout : channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 存储 &lt;requestId, DefaultFuture&gt; 映射关系到 FUTURES 中</span>
</span></span><span style=display:flex><span>        FUTURES.put(id, <span style=color:#719e07>this</span>);
</span></span><span style=display:flex><span>        CHANNELS.put(id, channel);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Object <span style=color:#268bd2>get</span>() <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> get(timeout);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Object <span style=color:#268bd2>get</span>(<span style=color:#dc322f>int</span> timeout) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (timeout <span style=color:#719e07>&lt;=</span> 0) {
</span></span><span style=display:flex><span>            timeout <span style=color:#719e07>=</span> Constants.DEFAULT_TIMEOUT;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 检测服务提供方是否成功返回了调用结果</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>isDone()) {
</span></span><span style=display:flex><span>            <span style=color:#dc322f>long</span> start <span style=color:#719e07>=</span> System.currentTimeMillis();
</span></span><span style=display:flex><span>            lock.lock();
</span></span><span style=display:flex><span>            <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 循环检测服务提供方是否成功返回了调用结果</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>while</span> (<span style=color:#719e07>!</span>isDone()) {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 如果调用结果尚未返回，这里等待一段时间</span>
</span></span><span style=display:flex><span>                    done.await(timeout, TimeUnit.MILLISECONDS);
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 如果调用结果成功返回，或等待超时，此时跳出 while 循环，执行后续的逻辑</span>
</span></span><span style=display:flex><span>                    <span style=color:#719e07>if</span> (isDone() <span style=color:#719e07>||</span> System.currentTimeMillis() <span style=color:#719e07>-</span> start <span style=color:#719e07>&gt;</span> timeout) {
</span></span><span style=display:flex><span>                        <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#719e07>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RuntimeException(e);
</span></span><span style=display:flex><span>            } <span style=color:#719e07>finally</span> {
</span></span><span style=display:flex><span>                lock.unlock();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 如果调用结果仍未返回，则抛出超时异常</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>isDone()) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> TimeoutException(sent <span style=color:#719e07>&gt;</span> 0, channel, getTimeoutMessage(<span style=color:#cb4b16>false</span>));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 返回调用结果</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> returnFromResponse();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>boolean</span> <span style=color:#268bd2>isDone</span>() {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 通过检测 response 字段为空与否，判断是否收到了调用结果</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> response <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> Object <span style=color:#268bd2>returnFromResponse</span>() <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        Response res <span style=color:#719e07>=</span> response;
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (res <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IllegalStateException(<span style=color:#2aa198>&#34;response cannot be null&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 如果调用结果的状态为 Response.OK，则表示调用过程正常，服务提供方成功返回了调用结果</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (res.getStatus() <span style=color:#719e07>==</span> Response.OK) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> res.getResult();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 抛出异常</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (res.getStatus() <span style=color:#719e07>==</span> Response.CLIENT_TIMEOUT <span style=color:#719e07>||</span> res.getStatus() <span style=color:#719e07>==</span> Response.SERVER_TIMEOUT) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> TimeoutException(res.getStatus() <span style=color:#719e07>==</span> Response.SERVER_TIMEOUT, channel, res.getErrorMessage());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RemotingException(channel, res.getErrorMessage());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略其他方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上，当服务消费者还未接收到调用结果时，用户线程调用 get 方法会被阻塞住。同步调用模式下，框架获得 DefaultFuture 对象后，会立即调用 get 方法进行等待。而异步模式下则是将该对象封装到 FutureAdapter 实例中，并将 FutureAdapter 实例设置到 RpcContext 中，供用户使用。FutureAdapter 是一个适配器，用于将 Dubbo 中的 ResponseFuture 与 JDK 中的 Future 进行适配。这样当用户线程调用 Future 的 get 方法时，经过 FutureAdapter 适配，最终会调用 ResponseFuture 实现类对象的 get 方法，也就是 DefaultFuture 的 get 方法。</p><p>到这里关于 Dubbo 几种调用方式的代码逻辑就分析完了，下面来分析请求数据的发送与接收，以及响应数据的发送与接收过程。</p><h3 id=22-服务消费方发送请求>2.2 服务消费方发送请求</h3><h4 id=221-发送请求>2.2.1 发送请求</h4><p>本节我们来看一下同步调用模式下，服务消费方是如何发送调用请求的。在深入分析源码前，我们先来看一张图。</p><p><img src=/imgs/dev/send-request-thread-stack.jpg alt=img></p><p>这张图展示了服务消费方发送请求过程的部分调用栈，略为复杂。从上图可以看出，经过多次调用后，才将请求数据送至 Netty NioClientSocketChannel。这样做的原因是通过 Exchange 层为框架引入 Request 和 Response 语义，这一点会在接下来的源码分析过程中会看到。其他的就不多说了，下面开始进行分析。首先分析 ReferenceCountExchangeClient 的源码。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>final</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>ReferenceCountExchangeClient</span> <span style=color:#268bd2>implements</span> ExchangeClient {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> URL url;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> AtomicInteger referenceCount <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> AtomicInteger(0);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>ReferenceCountExchangeClient</span>(ExchangeClient client, ConcurrentMap<span style=color:#719e07>&lt;</span>String, LazyConnectExchangeClient<span style=color:#719e07>&gt;</span> ghostClientMap) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.client <span style=color:#719e07>=</span> client;
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 引用计数自增</span>
</span></span><span style=display:flex><span>        referenceCount.incrementAndGet();
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.url <span style=color:#719e07>=</span> client.getUrl();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> ResponseFuture <span style=color:#268bd2>request</span>(Object request) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 直接调用被装饰对象的同签名方法</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> client.request(request);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> ResponseFuture <span style=color:#268bd2>request</span>(Object request, <span style=color:#dc322f>int</span> timeout) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 直接调用被装饰对象的同签名方法</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> client.request(request, timeout);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>/** 引用计数自增，该方法由外部调用 */</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>incrementAndGetCount</span>() {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// referenceCount 自增</span>
</span></span><span style=display:flex><span>        referenceCount.incrementAndGet();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>close</span>(<span style=color:#dc322f>int</span> timeout) {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// referenceCount 自减</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (referenceCount.decrementAndGet() <span style=color:#719e07>&lt;=</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (timeout <span style=color:#719e07>==</span> 0) {
</span></span><span style=display:flex><span>                client.close();
</span></span><span style=display:flex><span>            } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                client.close(timeout);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            client <span style=color:#719e07>=</span> replaceWithLazyClient();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略部分方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ReferenceCountExchangeClient 内部定义了一个引用计数变量 referenceCount，每当该对象被引用一次 referenceCount 都会进行自增。每当 close 方法被调用时，referenceCount 进行自减。ReferenceCountExchangeClient 内部仅实现了一个引用计数的功能，其他方法并无复杂逻辑，均是直接调用被装饰对象的相关方法。所以这里就不多说了，继续向下分析，这次是 HeaderExchangeClient。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>HeaderExchangeClient</span> <span style=color:#268bd2>implements</span> ExchangeClient {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> ScheduledThreadPoolExecutor scheduled <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> ScheduledThreadPoolExecutor(2, <span style=color:#719e07>new</span> NamedThreadFactory(<span style=color:#2aa198>&#34;dubbo-remoting-client-heartbeat&#34;</span>, <span style=color:#cb4b16>true</span>));
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Client client;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> ExchangeChannel channel;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> ScheduledFuture<span style=color:#719e07>&lt;?&gt;</span> heartbeatTimer;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#dc322f>int</span> heartbeat;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#dc322f>int</span> heartbeatTimeout;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>HeaderExchangeClient</span>(Client client, <span style=color:#dc322f>boolean</span> needHeartbeat) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (client <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IllegalArgumentException(<span style=color:#2aa198>&#34;client == null&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.client <span style=color:#719e07>=</span> client;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 创建 HeaderExchangeChannel 对象</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.channel <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> HeaderExchangeChannel(client);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 以下代码均与心跳检测逻辑有关</span>
</span></span><span style=display:flex><span>        String dubbo <span style=color:#719e07>=</span> client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY);
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.heartbeat <span style=color:#719e07>=</span> client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>&amp;&amp;</span> dubbo.startsWith(<span style=color:#2aa198>&#34;1.0.&#34;</span>) <span style=color:#719e07>?</span> Constants.DEFAULT_HEARTBEAT : 0);
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.heartbeatTimeout <span style=color:#719e07>=</span> client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat <span style=color:#719e07>*</span> 3);
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (heartbeatTimeout <span style=color:#719e07>&lt;</span> heartbeat <span style=color:#719e07>*</span> 2) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IllegalStateException(<span style=color:#2aa198>&#34;heartbeatTimeout &lt; heartbeatInterval * 2&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (needHeartbeat) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 开启心跳检测定时器</span>
</span></span><span style=display:flex><span>            startHeartbeatTimer();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> ResponseFuture <span style=color:#268bd2>request</span>(Object request) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 直接 HeaderExchangeChannel 对象的同签名方法</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> channel.request(request);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> ResponseFuture <span style=color:#268bd2>request</span>(Object request, <span style=color:#dc322f>int</span> timeout) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 直接 HeaderExchangeChannel 对象的同签名方法</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> channel.request(request, timeout);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>close</span>() {
</span></span><span style=display:flex><span>        doClose();
</span></span><span style=display:flex><span>        channel.close();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>doClose</span>() {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 停止心跳检测定时器</span>
</span></span><span style=display:flex><span>        stopHeartbeatTimer();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>startHeartbeatTimer</span>() {
</span></span><span style=display:flex><span>        stopHeartbeatTimer();
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (heartbeat <span style=color:#719e07>&gt;</span> 0) {
</span></span><span style=display:flex><span>            heartbeatTimer <span style=color:#719e07>=</span> scheduled.scheduleWithFixedDelay(
</span></span><span style=display:flex><span>                    <span style=color:#719e07>new</span> HeartBeatTask(<span style=color:#719e07>new</span> HeartBeatTask.ChannelProvider() {
</span></span><span style=display:flex><span>                        <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>                        <span style=color:#268bd2>public</span> Collection<span style=color:#719e07>&lt;</span>Channel<span style=color:#719e07>&gt;</span> <span style=color:#268bd2>getChannels</span>() {
</span></span><span style=display:flex><span>                            <span style=color:#719e07>return</span> Collections.<span style=color:#719e07>&lt;</span>Channel<span style=color:#719e07>&gt;</span>singletonList(HeaderExchangeClient.this);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }, heartbeat, heartbeatTimeout),
</span></span><span style=display:flex><span>                    heartbeat, heartbeat, TimeUnit.MILLISECONDS);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>stopHeartbeatTimer</span>() {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (heartbeatTimer <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>&amp;&amp;</span> <span style=color:#719e07>!</span>heartbeatTimer.isCancelled()) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                heartbeatTimer.cancel(<span style=color:#cb4b16>true</span>);
</span></span><span style=display:flex><span>                scheduled.purge();
</span></span><span style=display:flex><span>            } <span style=color:#719e07>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span> (logger.isWarnEnabled()) {
</span></span><span style=display:flex><span>                    logger.warn(e.getMessage(), e);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        heartbeatTimer <span style=color:#719e07>=</span> <span style=color:#cb4b16>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略部分方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>HeaderExchangeClient 中很多方法只有一行代码，即调用 HeaderExchangeChannel 对象的同签名方法。那 HeaderExchangeClient 有什么用处呢？答案是封装了一些关于心跳检测的逻辑。心跳检测并非本文所关注的点，因此就不多说了，继续向下看。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>final</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>HeaderExchangeChannel</span> <span style=color:#268bd2>implements</span> ExchangeChannel {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Channel channel;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    HeaderExchangeChannel(Channel channel) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (channel <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IllegalArgumentException(<span style=color:#2aa198>&#34;channel == null&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 这里的 channel 指向的是 NettyClient</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.channel <span style=color:#719e07>=</span> channel;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> ResponseFuture <span style=color:#268bd2>request</span>(Object request) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> request(request, channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> ResponseFuture <span style=color:#268bd2>request</span>(Object request, <span style=color:#dc322f>int</span> timeout) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (closed) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RemotingException(..., <span style=color:#2aa198>&#34;Failed to send request ...);
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        // 创建 Request 对象
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        Request req = new Request();
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        req.setVersion(Version.getProtocolVersion());
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        // 设置双向通信标志为 true
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        req.setTwoWay(true);
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        // 这里的 request 变量类型为 RpcInvocation
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        req.setData(request);
</span></span></span><span style=display:flex><span><span style=color:#2aa198>                                        
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        // 创建 DefaultFuture 对象
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        DefaultFuture future = new DefaultFuture(channel, req, timeout);
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        try {
</span></span></span><span style=display:flex><span><span style=color:#2aa198>            // 调用 NettyClient 的 send 方法发送请求
</span></span></span><span style=display:flex><span><span style=color:#2aa198>            channel.send(req);
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        } catch (RemotingException e) {
</span></span></span><span style=display:flex><span><span style=color:#2aa198>            future.cancel();
</span></span></span><span style=display:flex><span><span style=color:#2aa198>            throw e;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        // 返回 DefaultFuture 对象
</span></span></span><span style=display:flex><span><span style=color:#2aa198>        return future;
</span></span></span><span style=display:flex><span><span style=color:#2aa198>    }
</span></span></span><span style=display:flex><span><span style=color:#2aa198>}
</span></span></span></code></pre></div><p>到这里大家终于看到了 Request 语义了，上面的方法首先定义了一个 Request 对象，然后再将该对象传给 NettyClient 的 send 方法，进行后续的调用。需要说明的是，NettyClient 中并未实现 send 方法，该方法继承自父类 AbstractPeer，下面直接分析 AbstractPeer 的代码。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>abstract</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>AbstractPeer</span> <span style=color:#268bd2>implements</span> Endpoint, ChannelHandler {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>send</span>(Object message) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 该方法由 AbstractClient 类实现</span>
</span></span><span style=display:flex><span>        send(message, url.getParameter(Constants.SENT_KEY, <span style=color:#cb4b16>false</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略其他方法</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>abstract</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>AbstractClient</span> <span style=color:#268bd2>extends</span> AbstractEndpoint <span style=color:#268bd2>implements</span> Client {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>send</span>(Object message, <span style=color:#dc322f>boolean</span> sent) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (send_reconnect <span style=color:#719e07>&amp;&amp;</span> <span style=color:#719e07>!</span>isConnected()) {
</span></span><span style=display:flex><span>            connect();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取 Channel，getChannel 是一个抽象方法，具体由子类实现</span>
</span></span><span style=display:flex><span>        Channel channel <span style=color:#719e07>=</span> getChannel();
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (channel <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>||</span> <span style=color:#719e07>!</span>channel.isConnected()) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RemotingException(<span style=color:#719e07>this</span>, <span style=color:#2aa198>&#34;message can not send ...&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 继续向下调用</span>
</span></span><span style=display:flex><span>        channel.send(message, sent);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>abstract</span> Channel <span style=color:#268bd2>getChannel</span>();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略其他方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>默认情况下，Dubbo 使用 Netty 作为底层的通信框架，因此下面我们到 NettyClient 类中看一下 getChannel 方法的实现逻辑。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>NettyClient</span> <span style=color:#268bd2>extends</span> AbstractClient {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 这里的 Channel 全限定名称为 org.jboss.netty.channel.Channel</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>volatile</span> Channel channel;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> com.alibaba.dubbo.remoting.Channel <span style=color:#268bd2>getChannel</span>() {
</span></span><span style=display:flex><span>        Channel c <span style=color:#719e07>=</span> channel;
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (c <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>||</span> <span style=color:#719e07>!</span>c.isConnected())
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> <span style=color:#cb4b16>null</span>;
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取一个 NettyChannel 类型对象</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> NettyChannel.getOrAddChannel(c, getUrl(), <span style=color:#719e07>this</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>final</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>NettyChannel</span> <span style=color:#268bd2>extends</span> AbstractChannel {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> ConcurrentMap<span style=color:#719e07>&lt;</span>org.jboss.netty.channel.Channel, NettyChannel<span style=color:#719e07>&gt;</span> channelMap <span style=color:#719e07>=</span> 
</span></span><span style=display:flex><span>        <span style=color:#719e07>new</span> ConcurrentHashMap<span style=color:#719e07>&lt;</span>org.jboss.netty.channel.Channel, NettyChannel<span style=color:#719e07>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> org.jboss.netty.channel.Channel channel;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>/** 私有构造方法 */</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>NettyChannel</span>(org.jboss.netty.channel.Channel channel, URL url, ChannelHandler handler) {
</span></span><span style=display:flex><span>        <span style=color:#268bd2>super</span>(url, handler);
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (channel <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IllegalArgumentException(<span style=color:#2aa198>&#34;netty channel == null;&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.channel <span style=color:#719e07>=</span> channel;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>static</span> NettyChannel <span style=color:#268bd2>getOrAddChannel</span>(org.jboss.netty.channel.Channel ch, URL url, ChannelHandler handler) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (ch <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> <span style=color:#cb4b16>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 尝试从集合中获取 NettyChannel 实例</span>
</span></span><span style=display:flex><span>        NettyChannel ret <span style=color:#719e07>=</span> channelMap.get(ch);
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (ret <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 如果 ret = null，则创建一个新的 NettyChannel 实例</span>
</span></span><span style=display:flex><span>            NettyChannel nc <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> NettyChannel(ch, url, handler);
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (ch.isConnected()) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 将 &lt;Channel, NettyChannel&gt; 键值对存入 channelMap 集合中</span>
</span></span><span style=display:flex><span>                ret <span style=color:#719e07>=</span> channelMap.putIfAbsent(ch, nc);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (ret <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>                ret <span style=color:#719e07>=</span> nc;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> ret;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>获取到 NettyChannel 实例后，即可进行后续的调用。下面看一下 NettyChannel 的 send 方法。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>send</span>(Object message, <span style=color:#dc322f>boolean</span> sent) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>    <span style=color:#268bd2>super</span>.send(message, sent);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#dc322f>boolean</span> success <span style=color:#719e07>=</span> <span style=color:#cb4b16>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#dc322f>int</span> timeout <span style=color:#719e07>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 发送消息(包含请求和响应消息)</span>
</span></span><span style=display:flex><span>        ChannelFuture future <span style=color:#719e07>=</span> channel.write(message);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// sent 的值源于 &lt;dubbo:method sent=&#34;true/false&#34; /&gt; 中 sent 的配置值，有两种配置值：</span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>//   1. true: 等待消息发出，消息发送失败将抛出异常</span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>//   2. false: 不等待消息发出，将消息放入 IO 队列，即刻返回</span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 默认情况下 sent = false；</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (sent) {
</span></span><span style=display:flex><span>            timeout <span style=color:#719e07>=</span> getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 等待消息发出，若在规定时间没能发出，success 会被置为 false</span>
</span></span><span style=display:flex><span>            success <span style=color:#719e07>=</span> future.await(timeout);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Throwable cause <span style=color:#719e07>=</span> future.getCause();
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (cause <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> cause;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#719e07>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RemotingException(<span style=color:#719e07>this</span>, <span style=color:#2aa198>&#34;Failed to send message ...&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 若 success 为 false，这里抛出异常</span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>success) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RemotingException(<span style=color:#719e07>this</span>, <span style=color:#2aa198>&#34;Failed to send message ...&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>经历多次调用，到这里请求数据的发送过程就结束了，过程漫长。为了便于大家阅读代码，这里以 DemoService 为例，将 sayHello 方法的整个调用路径贴出来。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>proxy0#sayHello(String)
</span></span><span style=display:flex><span>  —&gt; InvokerInvocationHandler#invoke(Object, Method, Object[])
</span></span><span style=display:flex><span>    —&gt; MockClusterInvoker#invoke(Invocation)
</span></span><span style=display:flex><span>      —&gt; AbstractClusterInvoker#invoke(Invocation)
</span></span><span style=display:flex><span>        —&gt; FailoverClusterInvoker#doInvoke(Invocation, List&lt;Invoker&lt;T&gt;&gt;, LoadBalance)
</span></span><span style=display:flex><span>          —&gt; Filter#invoke(Invoker, Invocation)  // 包含多个 Filter 调用
</span></span><span style=display:flex><span>            —&gt; ListenerInvokerWrapper#invoke(Invocation) 
</span></span><span style=display:flex><span>              —&gt; AbstractInvoker#invoke(Invocation) 
</span></span><span style=display:flex><span>                —&gt; DubboInvoker#doInvoke(Invocation)
</span></span><span style=display:flex><span>                  —&gt; ReferenceCountExchangeClient#request(Object, int)
</span></span><span style=display:flex><span>                    —&gt; HeaderExchangeClient#request(Object, int)
</span></span><span style=display:flex><span>                      —&gt; HeaderExchangeChannel#request(Object, int)
</span></span><span style=display:flex><span>                        —&gt; AbstractPeer#send(Object)
</span></span><span style=display:flex><span>                          —&gt; AbstractClient#send(Object, boolean)
</span></span><span style=display:flex><span>                            —&gt; NettyChannel#send(Object, boolean)
</span></span><span style=display:flex><span>                              —&gt; NioClientSocketChannel#write(Object)
</span></span></code></pre></div><p>在 Netty 中，出站数据在发出之前还需要进行编码操作，接下来我们来分析一下请求数据的编码逻辑。</p><h4 id=222-请求编码>2.2.2 请求编码</h4><p>在分析请求编码逻辑之前，我们先来看一下 Dubbo 数据包结构。</p><p><img src=/imgs/dev/data-format.jpg alt=img></p><p>Dubbo 数据包分为消息头和消息体，消息头用于存储一些元信息，比如魔数（Magic），数据包类型（Request/Response），消息体长度（Data Length）等。消息体中用于存储具体的调用消息，比如方法名称，参数列表等。下面简单列举一下消息头的内容。</p><table><thead><tr><th>偏移量(Bit)</th><th>字段</th><th>取值</th></tr></thead><tbody><tr><td>0 ~ 7</td><td>魔数高位</td><td>0xda00</td></tr><tr><td>8 ~ 15</td><td>魔数低位</td><td>0xbb</td></tr><tr><td>16</td><td>数据包类型</td><td>0 - Response, 1 - Request</td></tr><tr><td>17</td><td>调用方式</td><td>仅在第16位被设为1的情况下有效，0 - 单向调用，1 - 双向调用</td></tr><tr><td>18</td><td>事件标识</td><td>0 - 当前数据包是请求或响应包，1 - 当前数据包是心跳包</td></tr><tr><td>19 ~ 23</td><td>序列化器编号</td><td>2 - Hessian2Serialization<br>3 - JavaSerialization<br>4 - CompactedJavaSerialization<br>6 - FastJsonSerialization<br>7 - NativeJavaSerialization<br>8 - KryoSerialization<br>9 - FstSerialization</td></tr><tr><td>24 ~ 31</td><td>状态</td><td>20 - OK<br>30 - CLIENT_TIMEOUT<br>31 - SERVER_TIMEOUT<br>40 - BAD_REQUEST<br>50 - BAD_RESPONSE<br>&mldr;&mldr;</td></tr><tr><td>32 ~ 95</td><td>请求编号</td><td>共8字节，运行时生成</td></tr><tr><td>96 ~ 127</td><td>消息体长度</td><td>运行时计算</td></tr></tbody></table><p>了解了 Dubbo 数据包格式，接下来我们就可以探索编码过程了。这次我们开门见山，直接分析编码逻辑所在类。如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>ExchangeCodec</span> <span style=color:#268bd2>extends</span> TelnetCodec {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 消息头长度</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>int</span> HEADER_LENGTH <span style=color:#719e07>=</span> 16;
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 魔数内容</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>short</span> MAGIC <span style=color:#719e07>=</span> (<span style=color:#dc322f>short</span>) 0xdabb;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>byte</span> MAGIC_HIGH <span style=color:#719e07>=</span> Bytes.short2bytes(MAGIC)<span style=color:#719e07>[</span>0<span style=color:#719e07>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>byte</span> MAGIC_LOW <span style=color:#719e07>=</span> Bytes.short2bytes(MAGIC)<span style=color:#719e07>[</span>1<span style=color:#719e07>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>byte</span> FLAG_REQUEST <span style=color:#719e07>=</span> (<span style=color:#dc322f>byte</span>) 0x80;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>byte</span> FLAG_TWOWAY <span style=color:#719e07>=</span> (<span style=color:#dc322f>byte</span>) 0x40;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>byte</span> FLAG_EVENT <span style=color:#719e07>=</span> (<span style=color:#dc322f>byte</span>) 0x20;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> <span style=color:#dc322f>int</span> SERIALIZATION_MASK <span style=color:#719e07>=</span> 0x1f;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> Logger logger <span style=color:#719e07>=</span> LoggerFactory.getLogger(ExchangeCodec.class);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Short <span style=color:#268bd2>getMagicCode</span>() {
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> MAGIC;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>encode</span>(Channel channel, ChannelBuffer buffer, Object msg) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (msg <span style=color:#719e07>instanceof</span> Request) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对 Request 对象进行编码</span>
</span></span><span style=display:flex><span>            encodeRequest(channel, buffer, (Request) msg);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (msg <span style=color:#719e07>instanceof</span> Response) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对 Response 对象进行编码，后面分析</span>
</span></span><span style=display:flex><span>            encodeResponse(channel, buffer, (Response) msg);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#268bd2>super</span>.encode(channel, buffer, msg);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>encodeRequest</span>(Channel channel, ChannelBuffer buffer, Request req) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        Serialization serialization <span style=color:#719e07>=</span> getSerialization(channel);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 创建消息头字节数组，长度为 16</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>byte</span><span style=color:#719e07>[]</span> header <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> <span style=color:#dc322f>byte</span><span style=color:#719e07>[</span>HEADER_LENGTH<span style=color:#719e07>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 设置魔数</span>
</span></span><span style=display:flex><span>        Bytes.short2bytes(MAGIC, header);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 设置数据包类型（Request/Response）和序列化器编号</span>
</span></span><span style=display:flex><span>        header<span style=color:#719e07>[</span>2<span style=color:#719e07>]</span> <span style=color:#719e07>=</span> (<span style=color:#dc322f>byte</span>) (FLAG_REQUEST <span style=color:#719e07>|</span> serialization.getContentTypeId());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 设置通信方式(单向/双向)</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (req.isTwoWay()) {
</span></span><span style=display:flex><span>            header<span style=color:#719e07>[</span>2<span style=color:#719e07>]</span> <span style=color:#719e07>|=</span> FLAG_TWOWAY;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 设置事件标识</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (req.isEvent()) {
</span></span><span style=display:flex><span>            header<span style=color:#719e07>[</span>2<span style=color:#719e07>]</span> <span style=color:#719e07>|=</span> FLAG_EVENT;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 设置请求编号，8个字节，从第4个字节开始设置</span>
</span></span><span style=display:flex><span>        Bytes.long2bytes(req.getId(), header, 4);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取 buffer 当前的写位置</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>int</span> savedWriteIndex <span style=color:#719e07>=</span> buffer.writerIndex();
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 更新 writerIndex，为消息头预留 16 个字节的空间</span>
</span></span><span style=display:flex><span>        buffer.writerIndex(savedWriteIndex <span style=color:#719e07>+</span> HEADER_LENGTH);
</span></span><span style=display:flex><span>        ChannelBufferOutputStream bos <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> ChannelBufferOutputStream(buffer);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 创建序列化器，比如 Hessian2ObjectOutput</span>
</span></span><span style=display:flex><span>        ObjectOutput out <span style=color:#719e07>=</span> serialization.serialize(channel.getUrl(), bos);
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (req.isEvent()) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对事件数据进行序列化操作</span>
</span></span><span style=display:flex><span>            encodeEventData(channel, out, req.getData());
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对请求数据进行序列化操作</span>
</span></span><span style=display:flex><span>            encodeRequestData(channel, out, req.getData(), req.getVersion());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        out.flushBuffer();
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (out <span style=color:#719e07>instanceof</span> Cleanable) {
</span></span><span style=display:flex><span>            ((Cleanable) out).cleanup();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        bos.flush();
</span></span><span style=display:flex><span>        bos.close();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取写入的字节数，也就是消息体长度</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>int</span> len <span style=color:#719e07>=</span> bos.writtenBytes();
</span></span><span style=display:flex><span>        checkPayload(channel, len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 将消息体长度写入到消息头中</span>
</span></span><span style=display:flex><span>        Bytes.int2bytes(len, header, 12);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 将 buffer 指针移动到 savedWriteIndex，为写消息头做准备</span>
</span></span><span style=display:flex><span>        buffer.writerIndex(savedWriteIndex);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 从 savedWriteIndex 下标处写入消息头</span>
</span></span><span style=display:flex><span>        buffer.writeBytes(header);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 设置新的 writerIndex，writerIndex = 原写下标 + 消息头长度 + 消息体长度</span>
</span></span><span style=display:flex><span>        buffer.writerIndex(savedWriteIndex <span style=color:#719e07>+</span> HEADER_LENGTH <span style=color:#719e07>+</span> len);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略其他方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上就是请求对象的编码过程，该过程首先会通过位运算将消息头写入到 header 数组中。然后对 Request 对象的 data 字段执行序列化操作，序列化后的数据最终会存储到 ChannelBuffer 中。序列化操作执行完后，可得到数据序列化后的长度 len，紧接着将 len 写入到 header 指定位置处。最后再将消息头字节数组 header 写入到 ChannelBuffer 中，整个编码过程就结束了。本节的最后，我们再来看一下 Request 对象的 data 字段序列化过程，也就是 encodeRequestData 方法的逻辑，如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DubboCodec</span> <span style=color:#268bd2>extends</span> ExchangeCodec <span style=color:#268bd2>implements</span> Codec2 {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	<span style=color:#268bd2>protected</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>encodeRequestData</span>(Channel channel, ObjectOutput out, Object data, String version) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        RpcInvocation inv <span style=color:#719e07>=</span> (RpcInvocation) data;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 依次序列化 dubbo version、path、version</span>
</span></span><span style=display:flex><span>        out.writeUTF(version);
</span></span><span style=display:flex><span>        out.writeUTF(inv.getAttachment(Constants.PATH_KEY));
</span></span><span style=display:flex><span>        out.writeUTF(inv.getAttachment(Constants.VERSION_KEY));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 序列化调用方法名</span>
</span></span><span style=display:flex><span>        out.writeUTF(inv.getMethodName());
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 将参数类型转换为字符串，并进行序列化</span>
</span></span><span style=display:flex><span>        out.writeUTF(ReflectUtils.getDesc(inv.getParameterTypes()));
</span></span><span style=display:flex><span>        Object<span style=color:#719e07>[]</span> args <span style=color:#719e07>=</span> inv.getArguments();
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (args <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span>)
</span></span><span style=display:flex><span>            <span style=color:#719e07>for</span> (<span style=color:#dc322f>int</span> i <span style=color:#719e07>=</span> 0; i <span style=color:#719e07>&lt;</span> args.length; i<span style=color:#719e07>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 对运行时参数进行序列化</span>
</span></span><span style=display:flex><span>                out.writeObject(encodeInvocationArgument(channel, inv, i));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 序列化 attachments</span>
</span></span><span style=display:flex><span>        out.writeObject(inv.getAttachments());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>至此，关于服务消费方发送请求的过程就分析完了，接下来我们来看一下服务提供方是如何接收请求的。</p><h3 id=23-服务提供方接收请求>2.3 服务提供方接收请求</h3><p>前面说过，默认情况下 Dubbo 使用 Netty 作为底层的通信框架。Netty 检测到有数据入站后，首先会通过解码器对数据进行解码，并将解码后的数据传递给下一个入站处理器的指定方法。所以在进行后续的分析之前，我们先来看一下数据解码过程。</p><h4 id=231-请求解码>2.3.1 请求解码</h4><p>这里直接分析请求数据的解码逻辑，忽略中间过程，如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>ExchangeCodec</span> <span style=color:#268bd2>extends</span> TelnetCodec {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Object <span style=color:#268bd2>decode</span>(Channel channel, ChannelBuffer buffer) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#dc322f>int</span> readable <span style=color:#719e07>=</span> buffer.readableBytes();
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 创建消息头字节数组</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>byte</span><span style=color:#719e07>[]</span> header <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> <span style=color:#dc322f>byte</span><span style=color:#719e07>[</span>Math.min(readable, HEADER_LENGTH)<span style=color:#719e07>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 读取消息头数据</span>
</span></span><span style=display:flex><span>        buffer.readBytes(header);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 调用重载方法进行后续解码工作</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> decode(channel, buffer, readable, header);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> Object <span style=color:#268bd2>decode</span>(Channel channel, ChannelBuffer buffer, <span style=color:#dc322f>int</span> readable, <span style=color:#dc322f>byte</span><span style=color:#719e07>[]</span> header) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 检查魔数是否相等</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (readable <span style=color:#719e07>&gt;</span> 0 <span style=color:#719e07>&amp;&amp;</span> header<span style=color:#719e07>[</span>0<span style=color:#719e07>]</span> <span style=color:#719e07>!=</span> MAGIC_HIGH
</span></span><span style=display:flex><span>                <span style=color:#719e07>||</span> readable <span style=color:#719e07>&gt;</span> 1 <span style=color:#719e07>&amp;&amp;</span> header<span style=color:#719e07>[</span>1<span style=color:#719e07>]</span> <span style=color:#719e07>!=</span> MAGIC_LOW) {
</span></span><span style=display:flex><span>            <span style=color:#dc322f>int</span> length <span style=color:#719e07>=</span> header.length;
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (header.length <span style=color:#719e07>&lt;</span> readable) {
</span></span><span style=display:flex><span>                header <span style=color:#719e07>=</span> Bytes.copyOf(header, readable);
</span></span><span style=display:flex><span>                buffer.readBytes(header, length, readable <span style=color:#719e07>-</span> length);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#719e07>for</span> (<span style=color:#dc322f>int</span> i <span style=color:#719e07>=</span> 1; i <span style=color:#719e07>&lt;</span> header.length <span style=color:#719e07>-</span> 1; i<span style=color:#719e07>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span> (header<span style=color:#719e07>[</span>i<span style=color:#719e07>]</span> <span style=color:#719e07>==</span> MAGIC_HIGH <span style=color:#719e07>&amp;&amp;</span> header<span style=color:#719e07>[</span>i <span style=color:#719e07>+</span> 1<span style=color:#719e07>]</span> <span style=color:#719e07>==</span> MAGIC_LOW) {
</span></span><span style=display:flex><span>                    buffer.readerIndex(buffer.readerIndex() <span style=color:#719e07>-</span> header.length <span style=color:#719e07>+</span> i);
</span></span><span style=display:flex><span>                    header <span style=color:#719e07>=</span> Bytes.copyOf(header, i);
</span></span><span style=display:flex><span>                    <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 通过 telnet 命令行发送的数据包不包含消息头，所以这里</span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 调用 TelnetCodec 的 decode 方法对数据包进行解码</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> <span style=color:#268bd2>super</span>.decode(channel, buffer, readable, header);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 检测可读数据量是否少于消息头长度，若小于则立即返回 DecodeResult.NEED_MORE_INPUT</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (readable <span style=color:#719e07>&lt;</span> HEADER_LENGTH) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> DecodeResult.NEED_MORE_INPUT;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 从消息头中获取消息体长度</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>int</span> len <span style=color:#719e07>=</span> Bytes.bytes2int(header, 12);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 检测消息体长度是否超出限制，超出则抛出异常</span>
</span></span><span style=display:flex><span>        checkPayload(channel, len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>int</span> tt <span style=color:#719e07>=</span> len <span style=color:#719e07>+</span> HEADER_LENGTH;
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 检测可读的字节数是否小于实际的字节数</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (readable <span style=color:#719e07>&lt;</span> tt) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> DecodeResult.NEED_MORE_INPUT;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        ChannelBufferInputStream is <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> ChannelBufferInputStream(buffer, len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 继续进行解码工作</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> decodeBody(channel, is, header);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>finally</span> {
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (is.available() <span style=color:#719e07>&gt;</span> 0) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                    StreamUtils.skipUnusedStream(is);
</span></span><span style=display:flex><span>                } <span style=color:#719e07>catch</span> (IOException e) {
</span></span><span style=display:flex><span>                    logger.warn(e.getMessage(), e);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面方法通过检测消息头中的魔数是否与规定的魔数相等，提前拦截掉非常规数据包，比如通过 telnet 命令行发出的数据包。接着再对消息体长度，以及可读字节数进行检测。最后调用 decodeBody 方法进行后续的解码工作，ExchangeCodec 中实现了 decodeBody 方法，但因其子类 DubboCodec 覆写了该方法，所以在运行时 DubboCodec 中的 decodeBody 方法会被调用。下面我们来看一下该方法的代码。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DubboCodec</span> <span style=color:#268bd2>extends</span> ExchangeCodec <span style=color:#268bd2>implements</span> Codec2 {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> Object <span style=color:#268bd2>decodeBody</span>(Channel channel, InputStream is, <span style=color:#dc322f>byte</span><span style=color:#719e07>[]</span> header) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取消息头中的第三个字节，并通过逻辑与运算得到序列化器编号</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>byte</span> flag <span style=color:#719e07>=</span> header<span style=color:#719e07>[</span>2<span style=color:#719e07>]</span>, proto <span style=color:#719e07>=</span> (<span style=color:#dc322f>byte</span>) (flag <span style=color:#719e07>&amp;</span> SERIALIZATION_MASK);
</span></span><span style=display:flex><span>        Serialization s <span style=color:#719e07>=</span> CodecSupport.getSerialization(channel.getUrl(), proto);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取调用编号</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>long</span> id <span style=color:#719e07>=</span> Bytes.bytes2long(header, 4);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 通过逻辑与运算得到调用类型，0 - Response，1 - Request</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> ((flag <span style=color:#719e07>&amp;</span> FLAG_REQUEST) <span style=color:#719e07>==</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对响应结果进行解码，得到 Response 对象。这个非本节内容，后面再分析</span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 创建 Request 对象</span>
</span></span><span style=display:flex><span>            Request req <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> Request(id);
</span></span><span style=display:flex><span>            req.setVersion(Version.getProtocolVersion());
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 通过逻辑与运算得到通信方式，并设置到 Request 对象中</span>
</span></span><span style=display:flex><span>            req.setTwoWay((flag <span style=color:#719e07>&amp;</span> FLAG_TWOWAY) <span style=color:#719e07>!=</span> 0);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 通过位运算检测数据包是否为事件类型</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> ((flag <span style=color:#719e07>&amp;</span> FLAG_EVENT) <span style=color:#719e07>!=</span> 0) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 设置心跳事件到 Request 对象中</span>
</span></span><span style=display:flex><span>                req.setEvent(Request.HEARTBEAT_EVENT);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                Object data;
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span> (req.isHeartbeat()) {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 对心跳包进行解码，该方法已被标注为废弃</span>
</span></span><span style=display:flex><span>                    data <span style=color:#719e07>=</span> decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));
</span></span><span style=display:flex><span>                } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (req.isEvent()) {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 对事件数据进行解码</span>
</span></span><span style=display:flex><span>                    data <span style=color:#719e07>=</span> decodeEventData(channel, deserialize(s, channel.getUrl(), is));
</span></span><span style=display:flex><span>                } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                    DecodeableRpcInvocation inv;
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 根据 url 参数判断是否在 IO 线程上对消息体进行解码</span>
</span></span><span style=display:flex><span>                    <span style=color:#719e07>if</span> (channel.getUrl().getParameter(
</span></span><span style=display:flex><span>                            Constants.DECODE_IN_IO_THREAD_KEY,
</span></span><span style=display:flex><span>                            Constants.DEFAULT_DECODE_IN_IO_THREAD)) {
</span></span><span style=display:flex><span>                        inv <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> DecodeableRpcInvocation(channel, req, is, proto);
</span></span><span style=display:flex><span>                        <span style=color:#586e75>// 在当前线程，也就是 IO 线程上进行后续的解码工作。此工作完成后，可将</span>
</span></span><span style=display:flex><span>                        <span style=color:#586e75>// 调用方法名、attachment、以及调用参数解析出来</span>
</span></span><span style=display:flex><span>                        inv.decode();
</span></span><span style=display:flex><span>                    } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#586e75>// 仅创建 DecodeableRpcInvocation 对象，但不在当前线程上执行解码逻辑</span>
</span></span><span style=display:flex><span>                        inv <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> DecodeableRpcInvocation(channel, req,
</span></span><span style=display:flex><span>                                <span style=color:#719e07>new</span> UnsafeByteArrayInputStream(readMessageData(is)), proto);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    data <span style=color:#719e07>=</span> inv;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 设置 data 到 Request 对象中</span>
</span></span><span style=display:flex><span>                req.setData(data);
</span></span><span style=display:flex><span>            } <span style=color:#719e07>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 若解码过程中出现异常，则将 broken 字段设为 true，</span>
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 并将异常对象设置到 Reqeust 对象中</span>
</span></span><span style=display:flex><span>                req.setBroken(<span style=color:#cb4b16>true</span>);
</span></span><span style=display:flex><span>                req.setData(t);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> req;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上，decodeBody 对部分字段进行了解码，并将解码得到的字段封装到 Request 中。随后会调用 DecodeableRpcInvocation 的 decode 方法进行后续的解码工作。此工作完成后，可将调用方法名、attachment、以及调用参数解析出来。下面我们来看一下 DecodeableRpcInvocation 的 decode 方法逻辑。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DecodeableRpcInvocation</span> <span style=color:#268bd2>extends</span> RpcInvocation <span style=color:#268bd2>implements</span> Codec, Decodeable {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	<span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Object <span style=color:#268bd2>decode</span>(Channel channel, InputStream input) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        ObjectInput in <span style=color:#719e07>=</span> CodecSupport.getSerialization(channel.getUrl(), serializationType)
</span></span><span style=display:flex><span>                .deserialize(channel.getUrl(), input);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 通过反序列化得到 dubbo version，并保存到 attachments 变量中</span>
</span></span><span style=display:flex><span>        String dubboVersion <span style=color:#719e07>=</span> in.readUTF();
</span></span><span style=display:flex><span>        request.setVersion(dubboVersion);
</span></span><span style=display:flex><span>        setAttachment(Constants.DUBBO_VERSION_KEY, dubboVersion);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 通过反序列化得到 path，version，并保存到 attachments 变量中</span>
</span></span><span style=display:flex><span>        setAttachment(Constants.PATH_KEY, in.readUTF());
</span></span><span style=display:flex><span>        setAttachment(Constants.VERSION_KEY, in.readUTF());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 通过反序列化得到调用方法名</span>
</span></span><span style=display:flex><span>        setMethodName(in.readUTF());
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            Object<span style=color:#719e07>[]</span> args;
</span></span><span style=display:flex><span>            Class<span style=color:#719e07>&lt;?&gt;[]</span> pts;
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 通过反序列化得到参数类型字符串，比如 Ljava/lang/String;</span>
</span></span><span style=display:flex><span>            String desc <span style=color:#719e07>=</span> in.readUTF();
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (desc.length() <span style=color:#719e07>==</span> 0) {
</span></span><span style=display:flex><span>                pts <span style=color:#719e07>=</span> DubboCodec.EMPTY_CLASS_ARRAY;
</span></span><span style=display:flex><span>                args <span style=color:#719e07>=</span> DubboCodec.EMPTY_OBJECT_ARRAY;
</span></span><span style=display:flex><span>            } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 将 desc 解析为参数类型数组</span>
</span></span><span style=display:flex><span>                pts <span style=color:#719e07>=</span> ReflectUtils.desc2classArray(desc);
</span></span><span style=display:flex><span>                args <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> Object<span style=color:#719e07>[</span>pts.length<span style=color:#719e07>]</span>;
</span></span><span style=display:flex><span>                <span style=color:#719e07>for</span> (<span style=color:#dc322f>int</span> i <span style=color:#719e07>=</span> 0; i <span style=color:#719e07>&lt;</span> args.length; i<span style=color:#719e07>++</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                        <span style=color:#586e75>// 解析运行时参数</span>
</span></span><span style=display:flex><span>                        args<span style=color:#719e07>[</span>i<span style=color:#719e07>]</span> <span style=color:#719e07>=</span> in.readObject(pts<span style=color:#719e07>[</span>i<span style=color:#719e07>]</span>);
</span></span><span style=display:flex><span>                    } <span style=color:#719e07>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                        <span style=color:#719e07>if</span> (log.isWarnEnabled()) {
</span></span><span style=display:flex><span>                            log.warn(<span style=color:#2aa198>&#34;Decode argument failed: &#34;</span> <span style=color:#719e07>+</span> e.getMessage(), e);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置参数类型数组</span>
</span></span><span style=display:flex><span>            setParameterTypes(pts);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 通过反序列化得到原 attachment 的内容</span>
</span></span><span style=display:flex><span>            Map<span style=color:#719e07>&lt;</span>String, String<span style=color:#719e07>&gt;</span> map <span style=color:#719e07>=</span> (Map<span style=color:#719e07>&lt;</span>String, String<span style=color:#719e07>&gt;</span>) in.readObject(Map.class);
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (map <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>&amp;&amp;</span> map.size() <span style=color:#719e07>&gt;</span> 0) {
</span></span><span style=display:flex><span>                Map<span style=color:#719e07>&lt;</span>String, String<span style=color:#719e07>&gt;</span> attachment <span style=color:#719e07>=</span> getAttachments();
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span> (attachment <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>                    attachment <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> HashMap<span style=color:#719e07>&lt;</span>String, String<span style=color:#719e07>&gt;</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 将 map 与当前对象中的 attachment 集合进行融合</span>
</span></span><span style=display:flex><span>                attachment.putAll(map);
</span></span><span style=display:flex><span>                setAttachments(attachment);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对 callback 类型的参数进行处理</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>for</span> (<span style=color:#dc322f>int</span> i <span style=color:#719e07>=</span> 0; i <span style=color:#719e07>&lt;</span> args.length; i<span style=color:#719e07>++</span>) {
</span></span><span style=display:flex><span>                args<span style=color:#719e07>[</span>i<span style=color:#719e07>]</span> <span style=color:#719e07>=</span> decodeInvocationArgument(channel, <span style=color:#719e07>this</span>, pts, i, args<span style=color:#719e07>[</span>i<span style=color:#719e07>]</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置参数列表</span>
</span></span><span style=display:flex><span>            setArguments(args);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (ClassNotFoundException e) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IOException(StringUtils.toString(<span style=color:#2aa198>&#34;Read invocation data failed.&#34;</span>, e));
</span></span><span style=display:flex><span>        } <span style=color:#719e07>finally</span> {
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (in <span style=color:#719e07>instanceof</span> Cleanable) {
</span></span><span style=display:flex><span>                ((Cleanable) in).cleanup();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> <span style=color:#719e07>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的方法通过反序列化将诸如 path、version、调用方法名、参数列表等信息依次解析出来，并设置到相应的字段中，最终得到一个具有完整调用信息的 DecodeableRpcInvocation 对象。</p><p>到这里，请求数据解码的过程就分析完了。此时我们得到了一个 Request 对象，这个对象会被传送到下一个入站处理器中，我们继续往下看。</p><h4 id=232-调用服务>2.3.2 调用服务</h4><p>解码器将数据包解析成 Request 对象后，NettyHandler 的 messageReceived 方法紧接着会收到这个对象，并将这个对象继续向下传递。这期间该对象会被依次传递给 NettyServer、MultiMessageHandler、HeartbeatHandler 以及 AllChannelHandler。最后由 AllChannelHandler 将该对象封装到 Runnable 实现类对象中，并将 Runnable 放入线程池中执行后续的调用逻辑。整个调用栈如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>NettyHandler#messageReceived(ChannelHandlerContext, MessageEvent)
</span></span><span style=display:flex><span>  —&gt; AbstractPeer#received(Channel, Object)
</span></span><span style=display:flex><span>    —&gt; MultiMessageHandler#received(Channel, Object)
</span></span><span style=display:flex><span>      —&gt; HeartbeatHandler#received(Channel, Object)
</span></span><span style=display:flex><span>        —&gt; AllChannelHandler#received(Channel, Object)
</span></span><span style=display:flex><span>          —&gt; ExecutorService#execute(Runnable)    // 由线程池执行后续的调用逻辑
</span></span></code></pre></div><p>考虑到篇幅，以及很多中间调用的逻辑并非十分重要，所以这里就不对调用栈中的每个方法都进行分析了。这里我们直接分析调用栈中的分析第一个和最后一个调用方法逻辑。如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>@Sharable</span>
</span></span><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>NettyHandler</span> <span style=color:#268bd2>extends</span> SimpleChannelHandler {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Map<span style=color:#719e07>&lt;</span>String, Channel<span style=color:#719e07>&gt;</span> channels <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> ConcurrentHashMap<span style=color:#719e07>&lt;</span>String, Channel<span style=color:#719e07>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> URL url;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> ChannelHandler handler;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>NettyHandler</span>(URL url, ChannelHandler handler) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (url <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IllegalArgumentException(<span style=color:#2aa198>&#34;url == null&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (handler <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IllegalArgumentException(<span style=color:#2aa198>&#34;handler == null&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.url <span style=color:#719e07>=</span> url;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 这里的 handler 类型为 NettyServer</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.handler <span style=color:#719e07>=</span> handler;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	<span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>messageReceived</span>(ChannelHandlerContext ctx, MessageEvent e) <span style=color:#268bd2>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取 NettyChannel</span>
</span></span><span style=display:flex><span>        NettyChannel channel <span style=color:#719e07>=</span> NettyChannel.getOrAddChannel(ctx.getChannel(), url, handler);
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 继续向下调用</span>
</span></span><span style=display:flex><span>            handler.received(channel, e.getMessage());
</span></span><span style=display:flex><span>        } <span style=color:#719e07>finally</span> {
</span></span><span style=display:flex><span>            NettyChannel.removeChannelIfDisconnected(ctx.getChannel());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上，NettyHandler 中的 messageReceived 逻辑比较简单。首先根据一些信息获取 NettyChannel 实例，然后将 NettyChannel 实例以及 Request 对象向下传递。下面再来看看 AllChannelHandler 的逻辑，在详细分析代码之前，我们先来了解一下 Dubbo 中的线程派发模型。</p><h5 id=2321-线程派发模型>2.3.2.1 线程派发模型</h5><p>Dubbo 将底层通信框架中接收请求的线程称为 IO 线程。如果一些事件处理逻辑可以很快执行完，比如只在内存打一个标记，此时直接在 IO 线程上执行该段逻辑即可。但如果事件的处理逻辑比较耗时，比如该段逻辑会发起数据库查询或者 HTTP 请求。此时我们就不应该让事件处理逻辑在 IO 线程上执行，而是应该派发到线程池中去执行。原因也很简单，IO 线程主要用于接收请求，如果 IO 线程被占满，将导致它不能接收新的请求。</p><p>以上就是线程派发的背景，下面我们再来通过 Dubbo 调用图，看一下线程派发器所处的位置。</p><p><img src=/imgs/dev/dispatcher-location.jpg alt=img></p><p>如上图，红框中的 Dispatcher 就是线程派发器。需要说明的是，Dispatcher 真实的职责创建具有线程派发能力的 ChannelHandler，比如 AllChannelHandler、MessageOnlyChannelHandler 和 ExecutionChannelHandler 等，其本身并不具备线程派发能力。Dubbo 支持 5 种不同的线程派发策略，下面通过一个表格列举一下。</p><table><thead><tr><th>策略</th><th>用途</th></tr></thead><tbody><tr><td>all</td><td>所有消息都派发到线程池，包括请求，响应，连接事件，断开事件等</td></tr><tr><td>direct</td><td>所有消息都不派发到线程池，全部在 IO 线程上直接执行</td></tr><tr><td>message</td><td>只有<strong>请求</strong>和<strong>响应</strong>消息派发到线程池，其它消息均在 IO 线程上执行</td></tr><tr><td>execution</td><td>只有<strong>请求</strong>消息派发到线程池，不含响应。其它消息均在 IO 线程上执行</td></tr><tr><td>connection</td><td>在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池</td></tr></tbody></table><p>默认配置下，Dubbo 使用 <code>all</code> 派发策略，即将所有的消息都派发到线程池中。下面我们来分析一下 AllChannelHandler 的代码。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>AllChannelHandler</span> <span style=color:#268bd2>extends</span> WrappedChannelHandler {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>AllChannelHandler</span>(ChannelHandler handler, URL url) {
</span></span><span style=display:flex><span>        <span style=color:#268bd2>super</span>(handler, url);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>/** 处理连接事件 */</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>connected</span>(Channel channel) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取线程池</span>
</span></span><span style=display:flex><span>        ExecutorService cexecutor <span style=color:#719e07>=</span> getExecutorService();
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 将连接事件派发到线程池中处理</span>
</span></span><span style=display:flex><span>            cexecutor.execute(<span style=color:#719e07>new</span> ChannelEventRunnable(channel, handler, ChannelState.CONNECTED));
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> ExecutionException(..., <span style=color:#2aa198>&#34; error when process connected event .&#34;</span>, t);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>/** 处理断开事件 */</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>disconnected</span>(Channel channel) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        ExecutorService cexecutor <span style=color:#719e07>=</span> getExecutorService();
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            cexecutor.execute(<span style=color:#719e07>new</span> ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED));
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> ExecutionException(..., <span style=color:#2aa198>&#34;error when process disconnected event .&#34;</span>, t);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>/** 处理请求和响应消息，这里的 message 变量类型可能是 Request，也可能是 Response */</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>received</span>(Channel channel, Object message) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        ExecutorService cexecutor <span style=color:#719e07>=</span> getExecutorService();
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 将请求和响应消息派发到线程池中处理</span>
</span></span><span style=display:flex><span>            cexecutor.execute(<span style=color:#719e07>new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span>(message <span style=color:#719e07>instanceof</span> Request <span style=color:#719e07>&amp;&amp;</span> t <span style=color:#719e07>instanceof</span> RejectedExecutionException){
</span></span><span style=display:flex><span>                Request request <span style=color:#719e07>=</span> (Request)message;
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 如果通信方式为双向通信，此时将 Server side ... threadpool is exhausted </span>
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 错误信息封装到 Response 中，并返回给服务消费方。</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span>(request.isTwoWay()){
</span></span><span style=display:flex><span>                    String msg <span style=color:#719e07>=</span> <span style=color:#2aa198>&#34;Server side(&#34;</span> <span style=color:#719e07>+</span> url.getIp() <span style=color:#719e07>+</span> <span style=color:#2aa198>&#34;,&#34;</span> <span style=color:#719e07>+</span> url.getPort() 
</span></span><span style=display:flex><span>                        <span style=color:#719e07>+</span> <span style=color:#2aa198>&#34;) threadpool is exhausted ,detail msg:&#34;</span> <span style=color:#719e07>+</span> t.getMessage();
</span></span><span style=display:flex><span>                    Response response <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> Response(request.getId(), request.getVersion());
</span></span><span style=display:flex><span>                    response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR);
</span></span><span style=display:flex><span>                    response.setErrorMessage(msg);
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 返回包含错误信息的 Response 对象</span>
</span></span><span style=display:flex><span>                    channel.send(response);
</span></span><span style=display:flex><span>                    <span style=color:#719e07>return</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> ExecutionException(..., <span style=color:#2aa198>&#34; error when process received event .&#34;</span>, t);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>/** 处理异常信息 */</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>caught</span>(Channel channel, Throwable exception) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        ExecutorService cexecutor <span style=color:#719e07>=</span> getExecutorService();
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            cexecutor.execute(<span style=color:#719e07>new</span> ChannelEventRunnable(channel, handler, ChannelState.CAUGHT, exception));
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> ExecutionException(..., <span style=color:#2aa198>&#34;error when process caught event ...&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上，请求对象会被封装 ChannelEventRunnable 中，ChannelEventRunnable 将会是服务调用过程的新起点。所以接下来我们以 ChannelEventRunnable 为起点向下探索。</p><h5 id=2322-调用服务>2.3.2.2 调用服务</h5><p>本小节，我们从 ChannelEventRunnable 开始分析，该类的主要代码如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>ChannelEventRunnable</span> <span style=color:#268bd2>implements</span> Runnable {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> ChannelHandler handler;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Channel channel;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> ChannelState state;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Throwable exception;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Object message;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 检测通道状态，对于请求或响应消息，此时 state = RECEIVED</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (state <span style=color:#719e07>==</span> ChannelState.RECEIVED) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 将 channel 和 message 传给 ChannelHandler 对象，进行后续的调用</span>
</span></span><span style=display:flex><span>                handler.received(channel, message);
</span></span><span style=display:flex><span>            } <span style=color:#719e07>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                logger.warn(<span style=color:#2aa198>&#34;... operation error, channel is ... message is ...&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } 
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 其他消息类型通过 switch 进行处理</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#719e07>switch</span> (state) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> CONNECTED:
</span></span><span style=display:flex><span>                <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                    handler.connected(channel);
</span></span><span style=display:flex><span>                } <span style=color:#719e07>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                    logger.warn(<span style=color:#2aa198>&#34;... operation error, channel is ...&#34;</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> DISCONNECTED:
</span></span><span style=display:flex><span>                <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> SENT:
</span></span><span style=display:flex><span>                <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> CAUGHT:
</span></span><span style=display:flex><span>                <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>default</span>:
</span></span><span style=display:flex><span>                logger.warn(<span style=color:#2aa198>&#34;unknown state: &#34;</span> <span style=color:#719e07>+</span> state <span style=color:#719e07>+</span> <span style=color:#2aa198>&#34;, message is &#34;</span> <span style=color:#719e07>+</span> message);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上，请求和响应消息出现频率明显比其他类型消息高，所以这里对该类型的消息进行了针对性判断。ChannelEventRunnable 仅是一个中转站，它的 run 方法中并不包含具体的调用逻辑，仅用于将参数传给其他 ChannelHandler 对象进行处理，该对象类型为 DecodeHandler。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DecodeHandler</span> <span style=color:#268bd2>extends</span> AbstractChannelHandlerDelegate {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>DecodeHandler</span>(ChannelHandler handler) {
</span></span><span style=display:flex><span>        <span style=color:#268bd2>super</span>(handler);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>received</span>(Channel channel, Object message) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> Decodeable) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对 Decodeable 接口实现类对象进行解码</span>
</span></span><span style=display:flex><span>            decode(message);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> Request) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对 Request 的 data 字段进行解码</span>
</span></span><span style=display:flex><span>            decode(((Request) message).getData());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> Response) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对 Request 的 result 字段进行解码</span>
</span></span><span style=display:flex><span>            decode(((Response) message).getResult());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 执行后续逻辑</span>
</span></span><span style=display:flex><span>        handler.received(channel, message);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>decode</span>(Object message) {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// Decodeable 接口目前有两个实现类，</span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 分别为 DecodeableRpcInvocation 和 DecodeableRpcResult</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (message <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>&amp;&amp;</span> message <span style=color:#719e07>instanceof</span> Decodeable) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 执行解码逻辑</span>
</span></span><span style=display:flex><span>                ((Decodeable) message).decode();
</span></span><span style=display:flex><span>            } <span style=color:#719e07>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span> (log.isWarnEnabled()) {
</span></span><span style=display:flex><span>                    log.warn(<span style=color:#2aa198>&#34;Call Decodeable.decode failed: &#34;</span> <span style=color:#719e07>+</span> e.getMessage(), e);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>DecodeHandler 主要是包含了一些解码逻辑。2.2.1 节分析请求解码时说过，请求解码可在 IO 线程上执行，也可在线程池中执行，这个取决于运行时配置。DecodeHandler 存在的意义就是保证请求或响应对象可在线程池中被解码。解码完毕后，完全解码后的 Request 对象会继续向后传递，下一站是 HeaderExchangeHandler。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>HeaderExchangeHandler</span> <span style=color:#268bd2>implements</span> ChannelHandlerDelegate {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> ExchangeHandler handler;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>HeaderExchangeHandler</span>(ExchangeHandler handler) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (handler <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IllegalArgumentException(<span style=color:#2aa198>&#34;handler == null&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>this</span>.handler <span style=color:#719e07>=</span> handler;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>received</span>(Channel channel, Object message) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());
</span></span><span style=display:flex><span>        ExchangeChannel exchangeChannel <span style=color:#719e07>=</span> HeaderExchangeChannel.getOrAddChannel(channel);
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 处理请求对象</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> Request) {
</span></span><span style=display:flex><span>                Request request <span style=color:#719e07>=</span> (Request) message;
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span> (request.isEvent()) {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 处理事件</span>
</span></span><span style=display:flex><span>                    handlerEvent(channel, request);
</span></span><span style=display:flex><span>                } 
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 处理普通的请求</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 双向通信</span>
</span></span><span style=display:flex><span>                    <span style=color:#719e07>if</span> (request.isTwoWay()) {
</span></span><span style=display:flex><span>                        <span style=color:#586e75>// 向后调用服务，并得到调用结果</span>
</span></span><span style=display:flex><span>                        Response response <span style=color:#719e07>=</span> handleRequest(exchangeChannel, request);
</span></span><span style=display:flex><span>                        <span style=color:#586e75>// 将调用结果返回给服务消费端</span>
</span></span><span style=display:flex><span>                        channel.send(response);
</span></span><span style=display:flex><span>                    } 
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 如果是单向通信，仅向后调用指定服务即可，无需返回调用结果</span>
</span></span><span style=display:flex><span>                    <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                        handler.received(exchangeChannel, request.getData());
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }      
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 处理响应对象，服务消费方会执行此处逻辑，后面分析</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> Response) {
</span></span><span style=display:flex><span>                handleResponse(channel, (Response) message);
</span></span><span style=display:flex><span>            } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> String) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// telnet 相关，忽略</span>
</span></span><span style=display:flex><span>            } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                handler.received(exchangeChannel, message);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#719e07>finally</span> {
</span></span><span style=display:flex><span>            HeaderExchangeChannel.removeChannelIfDisconnected(channel);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Response <span style=color:#268bd2>handleRequest</span>(ExchangeChannel channel, Request req) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        Response res <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> Response(req.getId(), req.getVersion());
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 检测请求是否合法，不合法则返回状态码为 BAD_REQUEST 的响应</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (req.isBroken()) {
</span></span><span style=display:flex><span>            Object data <span style=color:#719e07>=</span> req.getData();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            String msg;
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (data <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>)
</span></span><span style=display:flex><span>                msg <span style=color:#719e07>=</span> <span style=color:#cb4b16>null</span>;
</span></span><span style=display:flex><span>            <span style=color:#719e07>else</span> <span style=color:#719e07>if</span>
</span></span><span style=display:flex><span>                (data <span style=color:#719e07>instanceof</span> Throwable) msg <span style=color:#719e07>=</span> StringUtils.toString((Throwable) data);
</span></span><span style=display:flex><span>            <span style=color:#719e07>else</span>
</span></span><span style=display:flex><span>                msg <span style=color:#719e07>=</span> data.toString();
</span></span><span style=display:flex><span>            res.setErrorMessage(<span style=color:#2aa198>&#34;Fail to decode request due to: &#34;</span> <span style=color:#719e07>+</span> msg);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置 BAD_REQUEST 状态</span>
</span></span><span style=display:flex><span>            res.setStatus(Response.BAD_REQUEST);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> res;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取 data 字段值，也就是 RpcInvocation 对象</span>
</span></span><span style=display:flex><span>        Object msg <span style=color:#719e07>=</span> req.getData();
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 继续向下调用</span>
</span></span><span style=display:flex><span>            Object result <span style=color:#719e07>=</span> handler.reply(channel, msg);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置 OK 状态码</span>
</span></span><span style=display:flex><span>            res.setStatus(Response.OK);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置调用结果</span>
</span></span><span style=display:flex><span>            res.setResult(result);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 若调用过程出现异常，则设置 SERVICE_ERROR，表示服务端异常</span>
</span></span><span style=display:flex><span>            res.setStatus(Response.SERVICE_ERROR);
</span></span><span style=display:flex><span>            res.setErrorMessage(StringUtils.toString(e));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>到这里，我们看到了比较清晰的请求和响应逻辑。对于双向通信，HeaderExchangeHandler 首先向后进行调用，得到调用结果。然后将调用结果封装到 Response 对象中，最后再将该对象返回给服务消费方。如果请求不合法，或者调用失败，则将错误信息封装到 Response 对象中，并返回给服务消费方。接下来我们继续向后分析，把剩余的调用过程分析完。下面分析定义在 DubboProtocol 类中的匿名类对象逻辑，如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DubboProtocol</span> <span style=color:#268bd2>extends</span> AbstractProtocol {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>static</span> <span style=color:#268bd2>final</span> String NAME <span style=color:#719e07>=</span> <span style=color:#2aa198>&#34;dubbo&#34;</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> ExchangeHandler requestHandler <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> ExchangeHandlerAdapter() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#268bd2>public</span> Object <span style=color:#268bd2>reply</span>(ExchangeChannel channel, Object message) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> Invocation) {
</span></span><span style=display:flex><span>                Invocation inv <span style=color:#719e07>=</span> (Invocation) message;
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 获取 Invoker 实例</span>
</span></span><span style=display:flex><span>                Invoker<span style=color:#719e07>&lt;?&gt;</span> invoker <span style=color:#719e07>=</span> getInvoker(channel, inv);
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span> (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 回调相关，忽略</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 通过 Invoker 调用具体的服务</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>return</span> invoker.invoke(inv);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RemotingException(channel, <span style=color:#2aa198>&#34;Unsupported request: ...&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 忽略其他方法</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Invoker<span style=color:#719e07>&lt;?&gt;</span> getInvoker(Channel channel, Invocation inv) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 忽略回调和本地存根相关逻辑</span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#dc322f>int</span> port <span style=color:#719e07>=</span> channel.getLocalAddress().getPort();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 计算 service key，格式为 groupName/serviceName:serviceVersion:port。比如：</span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>//   dubbo/com.alibaba.dubbo.demo.DemoService:1.0.0:20880</span>
</span></span><span style=display:flex><span>        String serviceKey <span style=color:#719e07>=</span> serviceKey(port, path, inv.getAttachments().get(Constants.VERSION_KEY), inv.getAttachments().get(Constants.GROUP_KEY));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 从 exporterMap 查找与 serviceKey 相对应的 DubboExporter 对象，</span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 服务导出过程中会将 &lt;serviceKey, DubboExporter&gt; 映射关系存储到 exporterMap 集合中</span>
</span></span><span style=display:flex><span>        DubboExporter<span style=color:#719e07>&lt;?&gt;</span> exporter <span style=color:#719e07>=</span> (DubboExporter<span style=color:#719e07>&lt;?&gt;</span>) exporterMap.get(serviceKey);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (exporter <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>)
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RemotingException(channel, <span style=color:#2aa198>&#34;Not found exported service ...&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取 Invoker 对象，并返回</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> exporter.getInvoker();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 忽略其他方法</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上逻辑用于获取与指定服务对应的 Invoker 实例，并通过 Invoker 的 invoke 方法调用服务逻辑。invoke 方法定义在 AbstractProxyInvoker 中，代码如下。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>abstract</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>AbstractProxyInvoker</span><span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> <span style=color:#268bd2>implements</span> Invoker<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Result <span style=color:#268bd2>invoke</span>(Invocation invocation) <span style=color:#268bd2>throws</span> RpcException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 调用 doInvoke 执行后续的调用，并将调用结果封装到 RpcResult 中，并</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> <span style=color:#719e07>new</span> RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()));
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (InvocationTargetException e) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> <span style=color:#719e07>new</span> RpcResult(e.getTargetException());
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> RpcException(<span style=color:#2aa198>&#34;Failed to invoke remote proxy method ...&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#268bd2>abstract</span> Object <span style=color:#268bd2>doInvoke</span>(T proxy, String methodName, Class<span style=color:#719e07>&lt;?&gt;[]</span> parameterTypes, Object<span style=color:#719e07>[]</span> arguments) <span style=color:#268bd2>throws</span> Throwable;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上，doInvoke 是一个抽象方法，这个需要由具体的 Invoker 实例实现。Invoker 实例是在运行时通过 JavassistProxyFactory 创建的，创建逻辑如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>JavassistProxyFactory</span> <span style=color:#268bd2>extends</span> AbstractProxyFactory {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略其他方法</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> Invoker<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> <span style=color:#268bd2>getInvoker</span>(T proxy, Class<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span> type, URL url) {
</span></span><span style=display:flex><span>        <span style=color:#268bd2>final</span> Wrapper wrapper <span style=color:#719e07>=</span> Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span style=color:#2aa198>&#39;$&#39;</span>) <span style=color:#719e07>&lt;</span> 0 <span style=color:#719e07>?</span> proxy.getClass() : type);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 创建匿名类对象</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> <span style=color:#719e07>new</span> AbstractProxyInvoker<span style=color:#719e07>&lt;</span>T<span style=color:#719e07>&gt;</span>(proxy, type, url) {
</span></span><span style=display:flex><span>            <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#268bd2>protected</span> Object <span style=color:#268bd2>doInvoke</span>(T proxy, String methodName,
</span></span><span style=display:flex><span>                                      Class<span style=color:#719e07>&lt;?&gt;[]</span> parameterTypes,
</span></span><span style=display:flex><span>                                      Object<span style=color:#719e07>[]</span> arguments) <span style=color:#268bd2>throws</span> Throwable {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 调用 invokeMethod 方法进行后续的调用</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Wrapper 是一个抽象类，其中 invokeMethod 是一个抽象方法。Dubbo 会在运行时通过 Javassist 框架为 Wrapper 生成实现类，并实现 invokeMethod 方法，该方法最终会根据调用信息调用具体的服务。以 DemoServiceImpl 为例，Javassist 为其生成的代理类如下。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#586e75>/** Wrapper0 是在运行时生成的，大家可使用 Arthas 进行反编译 */</span>
</span></span><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>Wrapper0</span> <span style=color:#268bd2>extends</span> Wrapper <span style=color:#268bd2>implements</span> ClassGenerator.DC {
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>static</span> String<span style=color:#719e07>[]</span> pns;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>static</span> Map pts;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>static</span> String<span style=color:#719e07>[]</span> mns;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>static</span> String<span style=color:#719e07>[]</span> dmns;
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#268bd2>static</span> Class<span style=color:#719e07>[]</span> mts0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 省略其他方法</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Object <span style=color:#268bd2>invokeMethod</span>(Object object, String string, Class<span style=color:#719e07>[]</span> arrclass, Object<span style=color:#719e07>[]</span> arrobject) <span style=color:#268bd2>throws</span> InvocationTargetException {
</span></span><span style=display:flex><span>        DemoService demoService;
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 类型转换</span>
</span></span><span style=display:flex><span>            demoService <span style=color:#719e07>=</span> (DemoService)object;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>catch</span> (Throwable throwable) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IllegalArgumentException(throwable);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 根据方法名调用指定的方法</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (<span style=color:#2aa198>&#34;sayHello&#34;</span>.equals(string) <span style=color:#719e07>&amp;&amp;</span> arrclass.length <span style=color:#719e07>==</span> 1) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>return</span> demoService.sayHello((String)arrobject<span style=color:#719e07>[</span>0<span style=color:#719e07>]</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>catch</span> (Throwable throwable) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> InvocationTargetException(throwable);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> NoSuchMethodException(<span style=color:#719e07>new</span> StringBuffer().append(<span style=color:#2aa198>&#34;Not found method \&#34;&#34;</span>).append(string).append(<span style=color:#2aa198>&#34;\&#34; in class com.alibaba.dubbo.demo.DemoService.&#34;</span>).toString());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>到这里，整个服务调用过程就分析完了。最后把调用过程贴出来，如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>ChannelEventRunnable#run()
</span></span><span style=display:flex><span>  —&gt; DecodeHandler#received(Channel, Object)
</span></span><span style=display:flex><span>    —&gt; HeaderExchangeHandler#received(Channel, Object)
</span></span><span style=display:flex><span>      —&gt; HeaderExchangeHandler#handleRequest(ExchangeChannel, Request)
</span></span><span style=display:flex><span>        —&gt; DubboProtocol.requestHandler#reply(ExchangeChannel, Object)
</span></span><span style=display:flex><span>          —&gt; Filter#invoke(Invoker, Invocation)
</span></span><span style=display:flex><span>            —&gt; AbstractProxyInvoker#invoke(Invocation)
</span></span><span style=display:flex><span>              —&gt; Wrapper0#invokeMethod(Object, String, Class[], Object[])
</span></span><span style=display:flex><span>                —&gt; DemoServiceImpl#sayHello(String)
</span></span></code></pre></div><h3 id=24-服务提供方返回调用结果>2.4 服务提供方返回调用结果</h3><p>服务提供方调用指定服务后，会将调用结果封装到 Response 对象中，并将该对象返回给服务消费方。服务提供方也是通过 NettyChannel 的 send 方法将 Response 对象返回，这个方法在 2.2.1 节分析过，这里就不在重复分析了。本节我们仅需关注 Response 对象的编码过程即可，这里仍然省略一些中间调用，直接分析具体的编码逻辑。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>ExchangeCodec</span> <span style=color:#268bd2>extends</span> TelnetCodec {
</span></span><span style=display:flex><span>	<span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>encode</span>(Channel channel, ChannelBuffer buffer, Object msg) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (msg <span style=color:#719e07>instanceof</span> Request) {
</span></span><span style=display:flex><span>            encodeRequest(channel, buffer, (Request) msg);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (msg <span style=color:#719e07>instanceof</span> Response) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对响应对象进行编码</span>
</span></span><span style=display:flex><span>            encodeResponse(channel, buffer, (Response) msg);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#268bd2>super</span>.encode(channel, buffer, msg);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>encodeResponse</span>(Channel channel, ChannelBuffer buffer, Response res) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#dc322f>int</span> savedWriteIndex <span style=color:#719e07>=</span> buffer.writerIndex();
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            Serialization serialization <span style=color:#719e07>=</span> getSerialization(channel);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 创建消息头字节数组</span>
</span></span><span style=display:flex><span>            <span style=color:#dc322f>byte</span><span style=color:#719e07>[]</span> header <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> <span style=color:#dc322f>byte</span><span style=color:#719e07>[</span>HEADER_LENGTH<span style=color:#719e07>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置魔数</span>
</span></span><span style=display:flex><span>            Bytes.short2bytes(MAGIC, header);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置序列化器编号</span>
</span></span><span style=display:flex><span>            header<span style=color:#719e07>[</span>2<span style=color:#719e07>]</span> <span style=color:#719e07>=</span> serialization.getContentTypeId();
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (res.isHeartbeat()) header<span style=color:#719e07>[</span>2<span style=color:#719e07>]</span> <span style=color:#719e07>|=</span> FLAG_EVENT;
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 获取响应状态</span>
</span></span><span style=display:flex><span>            <span style=color:#dc322f>byte</span> status <span style=color:#719e07>=</span> res.getStatus();
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置响应状态</span>
</span></span><span style=display:flex><span>            header<span style=color:#719e07>[</span>3<span style=color:#719e07>]</span> <span style=color:#719e07>=</span> status;
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置请求编号</span>
</span></span><span style=display:flex><span>            Bytes.long2bytes(res.getId(), header, 4);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 更新 writerIndex，为消息头预留 16 个字节的空间</span>
</span></span><span style=display:flex><span>            buffer.writerIndex(savedWriteIndex <span style=color:#719e07>+</span> HEADER_LENGTH);
</span></span><span style=display:flex><span>            ChannelBufferOutputStream bos <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> ChannelBufferOutputStream(buffer);
</span></span><span style=display:flex><span>            ObjectOutput out <span style=color:#719e07>=</span> serialization.serialize(channel.getUrl(), bos);
</span></span><span style=display:flex><span>           
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (status <span style=color:#719e07>==</span> Response.OK) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>if</span> (res.isHeartbeat()) {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 对心跳响应结果进行序列化，已废弃</span>
</span></span><span style=display:flex><span>                    encodeHeartbeatData(channel, out, res.getResult());
</span></span><span style=display:flex><span>                } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 对调用结果进行序列化</span>
</span></span><span style=display:flex><span>                    encodeResponseData(channel, out, res.getResult(), res.getVersion());
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#719e07>else</span> { 
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 对错误信息进行序列化</span>
</span></span><span style=display:flex><span>                out.writeUTF(res.getErrorMessage())
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            out.flushBuffer();
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (out <span style=color:#719e07>instanceof</span> Cleanable) {
</span></span><span style=display:flex><span>                ((Cleanable) out).cleanup();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            bos.flush();
</span></span><span style=display:flex><span>            bos.close();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 获取写入的字节数，也就是消息体长度</span>
</span></span><span style=display:flex><span>            <span style=color:#dc322f>int</span> len <span style=color:#719e07>=</span> bos.writtenBytes();
</span></span><span style=display:flex><span>            checkPayload(channel, len);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 将消息体长度写入到消息头中</span>
</span></span><span style=display:flex><span>            Bytes.int2bytes(len, header, 12);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 将 buffer 指针移动到 savedWriteIndex，为写消息头做准备</span>
</span></span><span style=display:flex><span>            buffer.writerIndex(savedWriteIndex);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 从 savedWriteIndex 下标处写入消息头</span>
</span></span><span style=display:flex><span>            buffer.writeBytes(header); 
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置新的 writerIndex，writerIndex = 原写下标 + 消息头长度 + 消息体长度</span>
</span></span><span style=display:flex><span>            buffer.writerIndex(savedWriteIndex <span style=color:#719e07>+</span> HEADER_LENGTH <span style=color:#719e07>+</span> len);
</span></span><span style=display:flex><span>        } <span style=color:#719e07>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 异常处理逻辑不是很难理解，但是代码略多，这里忽略了</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DubboCodec</span> <span style=color:#268bd2>extends</span> ExchangeCodec <span style=color:#268bd2>implements</span> Codec2 {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	<span style=color:#268bd2>protected</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>encodeResponseData</span>(Channel channel, ObjectOutput out, Object data, String version) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        Result result <span style=color:#719e07>=</span> (Result) data;
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 检测当前协议版本是否支持带有 attachment 集合的 Response 对象</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>boolean</span> attach <span style=color:#719e07>=</span> Version.isSupportResponseAttachment(version);
</span></span><span style=display:flex><span>        Throwable th <span style=color:#719e07>=</span> result.getException();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 异常信息为空</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (th <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            Object ret <span style=color:#719e07>=</span> result.getValue();
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 调用结果为空</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (ret <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 序列化响应类型</span>
</span></span><span style=display:flex><span>                out.writeByte(attach <span style=color:#719e07>?</span> RESPONSE_NULL_VALUE_WITH_ATTACHMENTS : RESPONSE_NULL_VALUE);
</span></span><span style=display:flex><span>            } 
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 调用结果非空</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 序列化响应类型</span>
</span></span><span style=display:flex><span>                out.writeByte(attach <span style=color:#719e07>?</span> RESPONSE_VALUE_WITH_ATTACHMENTS : RESPONSE_VALUE);
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 序列化调用结果</span>
</span></span><span style=display:flex><span>                out.writeObject(ret);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } 
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 异常信息非空</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 序列化响应类型</span>
</span></span><span style=display:flex><span>            out.writeByte(attach <span style=color:#719e07>?</span> RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS : RESPONSE_WITH_EXCEPTION);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 序列化异常对象</span>
</span></span><span style=display:flex><span>            out.writeObject(th);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (attach) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 记录 Dubbo 协议版本</span>
</span></span><span style=display:flex><span>            result.getAttachments().put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 序列化 attachments 集合</span>
</span></span><span style=display:flex><span>            out.writeObject(result.getAttachments());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上就是 Response 对象编码的过程，和前面分析的 Request 对象编码过程很相似。如果大家能看 Request 对象的编码逻辑，那么这里的 Response 对象的编码逻辑也不难理解，就不多说了。接下来我们再来分析双向通信的最后一环 —— 服务消费方接收调用结果。</p><h3 id=25-服务消费方接收调用结果>2.5 服务消费方接收调用结果</h3><p>服务消费方在收到响应数据后，首先要做的事情是对响应数据进行解码，得到 Response 对象。然后再将该对象传递给下一个入站处理器，这个入站处理器就是 NettyHandler。接下来 NettyHandler 会将这个对象继续向下传递，最后 AllChannelHandler 的 received 方法会收到这个对象，并将这个对象派发到线程池中。这个过程和服务提供方接收请求的过程是一样的，因此这里就不重复分析了。本节我们重点分析两个方面的内容，一是响应数据的解码过程，二是 Dubbo 如何将调用结果传递给用户线程的。下面先来分析响应数据的解码过程。</p><h4 id=251-响应数据解码>2.5.1 响应数据解码</h4><p>响应数据解码逻辑主要的逻辑封装在 DubboCodec 中，我们直接分析这个类的代码。如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DubboCodec</span> <span style=color:#268bd2>extends</span> ExchangeCodec <span style=color:#268bd2>implements</span> Codec2 {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>protected</span> Object <span style=color:#268bd2>decodeBody</span>(Channel channel, InputStream is, <span style=color:#dc322f>byte</span><span style=color:#719e07>[]</span> header) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#dc322f>byte</span> flag <span style=color:#719e07>=</span> header<span style=color:#719e07>[</span>2<span style=color:#719e07>]</span>, proto <span style=color:#719e07>=</span> (<span style=color:#dc322f>byte</span>) (flag <span style=color:#719e07>&amp;</span> SERIALIZATION_MASK);
</span></span><span style=display:flex><span>        Serialization s <span style=color:#719e07>=</span> CodecSupport.getSerialization(channel.getUrl(), proto);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 获取请求编号</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>long</span> id <span style=color:#719e07>=</span> Bytes.bytes2long(header, 4);
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 检测消息类型，若下面的条件成立，表明消息类型为 Response</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> ((flag <span style=color:#719e07>&amp;</span> FLAG_REQUEST) <span style=color:#719e07>==</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 创建 Response 对象</span>
</span></span><span style=display:flex><span>            Response res <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> Response(id);
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 检测事件标志位</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> ((flag <span style=color:#719e07>&amp;</span> FLAG_EVENT) <span style=color:#719e07>!=</span> 0) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 设置心跳事件</span>
</span></span><span style=display:flex><span>                res.setEvent(Response.HEARTBEAT_EVENT);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 获取响应状态</span>
</span></span><span style=display:flex><span>            <span style=color:#dc322f>byte</span> status <span style=color:#719e07>=</span> header<span style=color:#719e07>[</span>3<span style=color:#719e07>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 设置响应状态</span>
</span></span><span style=display:flex><span>            res.setStatus(status);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 如果响应状态为 OK，表明调用过程正常</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (status <span style=color:#719e07>==</span> Response.OK) {
</span></span><span style=display:flex><span>                <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                    Object data;
</span></span><span style=display:flex><span>                    <span style=color:#719e07>if</span> (res.isHeartbeat()) {
</span></span><span style=display:flex><span>                        <span style=color:#586e75>// 反序列化心跳数据，已废弃</span>
</span></span><span style=display:flex><span>                        data <span style=color:#719e07>=</span> decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));
</span></span><span style=display:flex><span>                    } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (res.isEvent()) {
</span></span><span style=display:flex><span>                        <span style=color:#586e75>// 反序列化事件数据</span>
</span></span><span style=display:flex><span>                        data <span style=color:#719e07>=</span> decodeEventData(channel, deserialize(s, channel.getUrl(), is));
</span></span><span style=display:flex><span>                    } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                        DecodeableRpcResult result;
</span></span><span style=display:flex><span>                        <span style=color:#586e75>// 根据 url 参数决定是否在 IO 线程上执行解码逻辑</span>
</span></span><span style=display:flex><span>                        <span style=color:#719e07>if</span> (channel.getUrl().getParameter(
</span></span><span style=display:flex><span>                                Constants.DECODE_IN_IO_THREAD_KEY,
</span></span><span style=display:flex><span>                                Constants.DEFAULT_DECODE_IN_IO_THREAD)) {
</span></span><span style=display:flex><span>                            <span style=color:#586e75>// 创建 DecodeableRpcResult 对象</span>
</span></span><span style=display:flex><span>                            result <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> DecodeableRpcResult(channel, res, is,
</span></span><span style=display:flex><span>                                    (Invocation) getRequestData(id), proto);
</span></span><span style=display:flex><span>                            <span style=color:#586e75>// 进行后续的解码工作</span>
</span></span><span style=display:flex><span>                            result.decode();
</span></span><span style=display:flex><span>                        } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                            <span style=color:#586e75>// 创建 DecodeableRpcResult 对象</span>
</span></span><span style=display:flex><span>                            result <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> DecodeableRpcResult(channel, res,
</span></span><span style=display:flex><span>                                    <span style=color:#719e07>new</span> UnsafeByteArrayInputStream(readMessageData(is)),
</span></span><span style=display:flex><span>                                    (Invocation) getRequestData(id), proto);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        data <span style=color:#719e07>=</span> result;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 设置 DecodeableRpcResult 对象到 Response 对象中</span>
</span></span><span style=display:flex><span>                    res.setResult(data);
</span></span><span style=display:flex><span>                } <span style=color:#719e07>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 解码过程中出现了错误，此时设置 CLIENT_ERROR 状态码到 Response 对象中</span>
</span></span><span style=display:flex><span>                    res.setStatus(Response.CLIENT_ERROR);
</span></span><span style=display:flex><span>                    res.setErrorMessage(StringUtils.toString(t));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } 
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 响应状态非 OK，表明调用过程出现了异常</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 反序列化异常信息，并设置到 Response 对象中</span>
</span></span><span style=display:flex><span>                res.setErrorMessage(deserialize(s, channel.getUrl(), is).readUTF());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#719e07>return</span> res;
</span></span><span style=display:flex><span>        } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 对请求数据进行解码，前面已分析过，此处忽略</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上就是响应数据的解码过程，上面逻辑看起来是不是似曾相识。对的，我们在前面章节分析过 DubboCodec 的 decodeBody 方法中关于请求数据的解码过程，该过程和响应数据的解码过程很相似。下面，我们继续分析调用结果的反序列化过程，如下：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DecodeableRpcResult</span> <span style=color:#268bd2>extends</span> RpcResult <span style=color:#268bd2>implements</span> Codec, Decodeable {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> Invocation invocation;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>decode</span>() <span style=color:#268bd2>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>hasDecoded <span style=color:#719e07>&amp;&amp;</span> channel <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>&amp;&amp;</span> inputStream <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 执行反序列化操作</span>
</span></span><span style=display:flex><span>                decode(channel, inputStream);
</span></span><span style=display:flex><span>            } <span style=color:#719e07>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 反序列化失败，设置 CLIENT_ERROR 状态到 Response 对象中</span>
</span></span><span style=display:flex><span>                response.setStatus(Response.CLIENT_ERROR);
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 设置异常信息</span>
</span></span><span style=display:flex><span>                response.setErrorMessage(StringUtils.toString(e));
</span></span><span style=display:flex><span>            } <span style=color:#719e07>finally</span> {
</span></span><span style=display:flex><span>                hasDecoded <span style=color:#719e07>=</span> <span style=color:#cb4b16>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> Object <span style=color:#268bd2>decode</span>(Channel channel, InputStream input) <span style=color:#268bd2>throws</span> IOException {
</span></span><span style=display:flex><span>        ObjectInput in <span style=color:#719e07>=</span> CodecSupport.getSerialization(channel.getUrl(), serializationType)
</span></span><span style=display:flex><span>                .deserialize(channel.getUrl(), input);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 反序列化响应类型</span>
</span></span><span style=display:flex><span>        <span style=color:#dc322f>byte</span> flag <span style=color:#719e07>=</span> in.readByte();
</span></span><span style=display:flex><span>        <span style=color:#719e07>switch</span> (flag) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> DubboCodec.RESPONSE_NULL_VALUE:
</span></span><span style=display:flex><span>                <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> DubboCodec.RESPONSE_VALUE:
</span></span><span style=display:flex><span>                <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> DubboCodec.RESPONSE_WITH_EXCEPTION:
</span></span><span style=display:flex><span>                <span style=color:#586e75>// ...</span>
</span></span><span style=display:flex><span>                <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 返回值为空，且携带了 attachments 集合</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS:
</span></span><span style=display:flex><span>                <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 反序列化 attachments 集合，并存储起来 </span>
</span></span><span style=display:flex><span>                    setAttachments((Map<span style=color:#719e07>&lt;</span>String, String<span style=color:#719e07>&gt;</span>) in.readObject(Map.class));
</span></span><span style=display:flex><span>                } <span style=color:#719e07>catch</span> (ClassNotFoundException e) {
</span></span><span style=display:flex><span>                    <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IOException(StringUtils.toString(<span style=color:#2aa198>&#34;Read response data failed.&#34;</span>, e));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 返回值不为空，且携带了 attachments 集合</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:
</span></span><span style=display:flex><span>                <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 获取返回值类型</span>
</span></span><span style=display:flex><span>                    Type<span style=color:#719e07>[]</span> returnType <span style=color:#719e07>=</span> RpcUtils.getReturnTypes(invocation);
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 反序列化调用结果，并保存起来</span>
</span></span><span style=display:flex><span>                    setValue(returnType <span style=color:#719e07>==</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>||</span> returnType.length <span style=color:#719e07>==</span> 0 <span style=color:#719e07>?</span> in.readObject() :
</span></span><span style=display:flex><span>                            (returnType.length <span style=color:#719e07>==</span> 1 <span style=color:#719e07>?</span> in.readObject((Class<span style=color:#719e07>&lt;?&gt;</span>) returnType<span style=color:#719e07>[</span>0<span style=color:#719e07>]</span>)
</span></span><span style=display:flex><span>                                    : in.readObject((Class<span style=color:#719e07>&lt;?&gt;</span>) returnType<span style=color:#719e07>[</span>0<span style=color:#719e07>]</span>, returnType<span style=color:#719e07>[</span>1<span style=color:#719e07>]</span>)));
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 反序列化 attachments 集合，并存储起来</span>
</span></span><span style=display:flex><span>                    setAttachments((Map<span style=color:#719e07>&lt;</span>String, String<span style=color:#719e07>&gt;</span>) in.readObject(Map.class));
</span></span><span style=display:flex><span>                } <span style=color:#719e07>catch</span> (ClassNotFoundException e) {
</span></span><span style=display:flex><span>                    <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IOException(StringUtils.toString(<span style=color:#2aa198>&#34;Read response data failed.&#34;</span>, e));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 异常对象不为空，且携带了 attachments 集合</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>case</span> DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS:
</span></span><span style=display:flex><span>                <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 反序列化异常对象</span>
</span></span><span style=display:flex><span>                    Object obj <span style=color:#719e07>=</span> in.readObject();
</span></span><span style=display:flex><span>                    <span style=color:#719e07>if</span> (obj <span style=color:#719e07>instanceof</span> Throwable <span style=color:#719e07>==</span> <span style=color:#cb4b16>false</span>)
</span></span><span style=display:flex><span>                        <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IOException(<span style=color:#2aa198>&#34;Response data error, expect Throwable, but get &#34;</span> <span style=color:#719e07>+</span> obj);
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 设置异常对象</span>
</span></span><span style=display:flex><span>                    setException((Throwable) obj);
</span></span><span style=display:flex><span>                    <span style=color:#586e75>// 反序列化 attachments 集合，并存储起来</span>
</span></span><span style=display:flex><span>                    setAttachments((Map<span style=color:#719e07>&lt;</span>String, String<span style=color:#719e07>&gt;</span>) in.readObject(Map.class));
</span></span><span style=display:flex><span>                } <span style=color:#719e07>catch</span> (ClassNotFoundException e) {
</span></span><span style=display:flex><span>                    <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IOException(StringUtils.toString(<span style=color:#2aa198>&#34;Read response data failed.&#34;</span>, e));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>            <span style=color:#719e07>default</span>:
</span></span><span style=display:flex><span>                <span style=color:#719e07>throw</span> <span style=color:#719e07>new</span> IOException(<span style=color:#2aa198>&#34;Unknown result flag, expect &#39;0&#39; &#39;1&#39; &#39;2&#39;, get &#34;</span> <span style=color:#719e07>+</span> flag);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (in <span style=color:#719e07>instanceof</span> Cleanable) {
</span></span><span style=display:flex><span>            ((Cleanable) in).cleanup();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> <span style=color:#719e07>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>本篇文章所分析的源码版本为 2.6.4，该版本下的 Response 支持 attachments 集合，所以上面仅对部分 case 分支进行了注释。其他 case 分支的逻辑比被注释分支的逻辑更为简单，这里就忽略了。我们所使用的测试服务接口 DemoService 包含了一个具有返回值的方法，正常调用下，线程会进入 RESPONSE_VALUE_WITH_ATTACHMENTS 分支中。然后线程会从 invocation 变量（大家探索一下 invocation 变量的由来）中获取返回值类型，接着对调用结果进行反序列化，并将序列化后的结果存储起来。最后对 attachments 集合进行反序列化，并存到指定字段中。到此，关于响应数据的解码过程就分析完了。接下来，我们再来探索一下响应对象 Response 的去向。</p><h4 id=252-向用户线程传递调用结果>2.5.2 向用户线程传递调用结果</h4><p>响应数据解码完成后，Dubbo 会将响应对象派发到线程池上。要注意的是，线程池中的线程并非用户的调用线程，所以要想办法将响应对象从线程池线程传递到用户线程上。我们在 2.1 节分析过用户线程在发送完请求后的动作，即调用 DefaultFuture 的 get 方法等待响应对象的到来。当响应对象到来后，用户线程会被唤醒，并通过<strong>调用编号</strong>获取属于自己的响应对象。下面我们来看一下整个过程对应的代码。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>HeaderExchangeHandler</span> <span style=color:#268bd2>implements</span> ChannelHandlerDelegate {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>public</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>received</span>(Channel channel, Object message) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());
</span></span><span style=display:flex><span>        ExchangeChannel exchangeChannel <span style=color:#719e07>=</span> HeaderExchangeChannel.getOrAddChannel(channel);
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> Request) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 处理请求，前面已分析过，省略</span>
</span></span><span style=display:flex><span>            } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> Response) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 处理响应</span>
</span></span><span style=display:flex><span>                handleResponse(channel, (Response) message);
</span></span><span style=display:flex><span>            } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (message <span style=color:#719e07>instanceof</span> String) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// telnet 相关，忽略</span>
</span></span><span style=display:flex><span>            } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                handler.received(exchangeChannel, message);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#719e07>finally</span> {
</span></span><span style=display:flex><span>            HeaderExchangeChannel.removeChannelIfDisconnected(channel);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>static</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>handleResponse</span>(Channel channel, Response response) <span style=color:#268bd2>throws</span> RemotingException {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (response <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span> <span style=color:#719e07>&amp;&amp;</span> <span style=color:#719e07>!</span>response.isHeartbeat()) {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 继续向下调用</span>
</span></span><span style=display:flex><span>            DefaultFuture.received(channel, response);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>public</span> <span style=color:#268bd2>class</span> <span style=color:#268bd2>DefaultFuture</span> <span style=color:#268bd2>implements</span> ResponseFuture {  
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Lock lock <span style=color:#719e07>=</span> <span style=color:#719e07>new</span> ReentrantLock();
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>final</span> Condition done <span style=color:#719e07>=</span> lock.newCondition();
</span></span><span style=display:flex><span>    <span style=color:#268bd2>private</span> <span style=color:#268bd2>volatile</span> Response response;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	<span style=color:#268bd2>public</span> <span style=color:#268bd2>static</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>received</span>(Channel channel, Response response) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 根据调用编号从 FUTURES 集合中查找指定的 DefaultFuture 对象</span>
</span></span><span style=display:flex><span>            DefaultFuture future <span style=color:#719e07>=</span> FUTURES.remove(response.getId());
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (future <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 继续向下调用</span>
</span></span><span style=display:flex><span>                future.doReceived(response);
</span></span><span style=display:flex><span>            } <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>                logger.warn(<span style=color:#2aa198>&#34;The timeout response finally returned at ...&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#719e07>finally</span> {
</span></span><span style=display:flex><span>            CHANNELS.remove(response.getId());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#268bd2>private</span> <span style=color:#dc322f>void</span> <span style=color:#268bd2>doReceived</span>(Response res) {
</span></span><span style=display:flex><span>        lock.lock();
</span></span><span style=display:flex><span>        <span style=color:#719e07>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 保存响应对象</span>
</span></span><span style=display:flex><span>            response <span style=color:#719e07>=</span> res;
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> (done <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#586e75>// 唤醒用户线程</span>
</span></span><span style=display:flex><span>                done.signal();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#719e07>finally</span> {
</span></span><span style=display:flex><span>            lock.unlock();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> (callback <span style=color:#719e07>!=</span> <span style=color:#cb4b16>null</span>) {
</span></span><span style=display:flex><span>            invokeCallback(callback);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上逻辑是将响应对象保存到相应的 DefaultFuture 实例中，然后再唤醒用户线程，随后用户线程即可从 DefaultFuture 实例中获取到相应结果。</p><p>本篇文章在多个地方都强调过调用编号很重要，但一直没有解释原因，这里简单说明一下。一般情况下，服务消费方会并发调用多个服务，每个用户线程发送请求后，会调用不同 DefaultFuture 对象的 get 方法进行等待。 一段时间后，服务消费方的线程池会收到多个响应对象。这个时候要考虑一个问题，如何将每个响应对象传递给相应的 DefaultFuture 对象，且不出错。答案是通过调用编号。DefaultFuture 被创建时，会要求传入一个 Request 对象。此时 DefaultFuture 可从 Request 对象中获取调用编号，并将 &lt;调用编号, DefaultFuture 对象> 映射关系存入到静态 Map 中，即 FUTURES。线程池中的线程在收到 Response 对象后，会根据 Response 对象中的调用编号到 FUTURES 集合中取出相应的 DefaultFuture 对象，然后再将 Response 对象设置到 DefaultFuture 对象中。最后再唤醒用户线程，这样用户线程即可从 DefaultFuture 对象中获取调用结果了。整个过程大致如下图：</p><p><img src=/imgs/dev/request-id-application.jpg alt=img></p><h2 id=3-总结>3. 总结</h2><p>本篇文章主要对 Dubbo 中的几种服务调用方式，以及从双向通信的角度对整个通信过程进行了详细的分析。按照通信顺序，通信过程包括服务消费方发送请求，服务提供方接收请求，服务提供方返回响应数据，服务消费方接收响应数据等过程。理解这些过程需要大家对网络编程，尤其是 Netty 有一定的了解。限于篇幅原因，本篇文章无法将服务调用的所有内容都一一进行分析。对于本篇文章未讲到或未详细分析的内容，比如服务降级、过滤器链、以及序列化等。大家若感兴趣，可自行进行分析。并将分析整理成文，分享给社区。</p><p>本篇文章就到这里了，感谢阅读。</p><div id=pre-footer><h2>反馈</h2><p class=feedback--prompt>此页是否对您有帮助？</p><button class="btn btn-primary mb-4 feedback--yes">是</button>
<button class="btn btn-primary mb-4 feedback--no">否</button></div><script>const yes=document.querySelector(".feedback--yes"),no=document.querySelector(".feedback--no");document.querySelectorAll(".feedback--link").forEach(e=>{e.href=e.href+window.location.pathname});const sendFeedback=e=>{gtag||console.log("!gtag"),gtag("event","click",{event_category:"Helpful",event_label:window.location.pathname,value:e})},disableButtons=()=>{yes.disabled=!0,yes.classList.add("feedback--button__disabled"),no.disabled=!0,no.classList.add("feedback--button__disabled")};yes.addEventListener("click",()=>{sendFeedback(1),disableButtons(),document.querySelector(".feedback--response").classList.remove("feedback--response__hidden")}),no.addEventListener("click",()=>{sendFeedback(0),disableButtons(),document.querySelector(".feedback--response").classList.remove("feedback--response__hidden")})</script><br><div class="text-muted mt-5 pt-3 border-top">最后修改 March 1, 2023: <a href=https://github.com/apache/dubbo-website/commit/f2070b3fdd1b7b200db0f8f2a50fb09d7c398a64>Add /zh/ docs aliases (#2336) (f2070b3fdd)</a></div></div></main><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"><div class="td-page-meta ml-2 pb-1 pt-2 mb-0"><a href=https://github.com/apache/dubbo-website/edit/master/content/zh-cn/docsv2.7/dev/source/service-invoking-process.md target=_blank><i class="fa fa-edit fa-fw"></i> 编辑此页</a>
<a href="https://github.com/apache/dubbo-website/new/master/content/zh-cn/docsv2.7/dev/source/service-invoking-process.md?filename=change-me.md&amp;value=---%0Atitle%3A+%22Long+Page+Title%22%0AlinkTitle%3A+%22Short+Nav+Title%22%0Aweight%3A+100%0Adescription%3A+%3E-%0A+++++Page+description+for+heading+and+indexes.%0A---%0A%0A%23%23+Heading%0A%0AEdit+this+template+to+create+your+new+page.%0A%0A%2A+Give+it+a+good+name%2C+ending+in+%60.md%60+-+e.g.+%60getting-started.md%60%0A%2A+Edit+the+%22front+matter%22+section+at+the+top+of+the+page+%28weight+controls+how+its+ordered+amongst+other+pages+in+the+same+directory%3B+lowest+number+first%29.%0A%2A+Add+a+good+commit+message+at+the+bottom+of+the+page+%28%3C80+characters%3B+use+the+extended+description+field+for+more+detail%29.%0A%2A+Create+a+new+branch+so+you+can+preview+your+new+file+and+request+a+review+via+Pull+Request.%0A" target=_blank><i class="fa fa-edit fa-fw"></i> 创建子页面</a>
<a href="https://github.com/apache/dubbo-website/issues/new?title=%e6%9c%8d%e5%8a%a1%e8%b0%83%e7%94%a8%e8%bf%87%e7%a8%8b" target=_blank><i class="fab fa-github fa-fw"></i> 登记问题</a>
<a href=https://github.com/apache/dubbo/issues/new target=_blank><i class="fas fa-tasks fa-fw"></i> 提交项目问题</a></div><nav id=TableOfContents><ul><li><a href=#1-简介>1. 简介</a></li><li><a href=#2-源码分析>2. 源码分析</a><ul><li><a href=#21-服务调用方式>2.1 服务调用方式</a></li><li><a href=#22-服务消费方发送请求>2.2 服务消费方发送请求</a></li><li><a href=#23-服务提供方接收请求>2.3 服务提供方接收请求</a></li><li><a href=#24-服务提供方返回调用结果>2.4 服务提供方返回调用结果</a></li><li><a href=#25-服务消费方接收调用结果>2.5 服务消费方接收调用结果</a></li></ul></li><li><a href=#3-总结>3. 总结</a></li></ul></nav></div></div></div></div><footer class="bg-dark py-5 row d-print-none footer-margin-0"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Dubbo mailing list archive" aria-label="Dubbo mailing list archive"><a class=text-white target=_blank rel="noopener noreferrer" href=https://lists.apache.org/list.html?dev@dubbo.apache.org><i class="fa fa-envelope"></i></a></li></ul></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel="noopener noreferrer" href=https://github.com/apache/dubbo><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Subscribe to mailing list" aria-label="Subscribe to mailing list"><a class=text-white target=_blank rel="noopener noreferrer" href=mailto:dev-subscribe@dubbo.apache.org><i class="fa fa-envelope"></i></a></li></ul></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2023 The Apache Software Foundation. Apache and the Apache feather logo are trademarks of The Apache Software Foundation. 保留所有权利</small></div></div></div></footer><div class="row pt-2 pb-2 footer-margin-0"><div class="container-fluid mx-sm-5"><div class=text-center id=my-footer><img style=float:left alt=apache_logo src=/imgs/apache_logo.png><ul><li><a href=https://www.apache.org>Foundation</a></li><li><a href=https://www.apache.org/licenses/>License</a></li><li><a href=https://dubbo.apache.org/en/docs/notices/security/>Security</a></li><li><a href=https://www.apache.org/events/current-event>Events</a></li><li><a href=https://www.apache.org/foundation/sponsorship.html>Sponsorship</a></li><li><a href=https://privacy.apache.org/policies/privacy-policy-public.html>Privacy</a></li><li><a href=https://www.apache.org/foundation/thanks.html>Thanks</a></li></ul></div></div></div><script src=/js/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script><script src=/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script><script src=/js/main.min.a4534a01940be8c082c4c0e6777b61df9884f202b61c9519352adb6d1039d5aa.js integrity="sha256-pFNKAZQL6MCCxMDmd3th35iE8gK2HJUZNSrbbRA51ao=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@docsearch/js@3></script><script>docsearch({appId:"L5F4T9F0I1",apiKey:"364ae307e1da9d02b2335675e9db1eb1",indexName:"apache_dubbo",container:"#docsearch",debug:!1}),docsearch({appId:"L5F4T9F0I1",apiKey:"364ae307e1da9d02b2335675e9db1eb1",indexName:"apache_dubbo",container:"#docsearch_zh_home",debug:!1})</script></body></html>