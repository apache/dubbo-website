<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Apache Dubbo 中文 on Apache Dubbo</title><link>https://dubbo.apache.org/zh-cn/</link><description>Recent content in Apache Dubbo 中文 on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://dubbo.apache.org/zh-cn/index.xml" rel="self" type="application/rss+xml"/><item><title>阿里巴巴升级 Dubbo3 全面取代 HSF2</title><link>https://dubbo.apache.org/zh-cn/blog/2023/01/16/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%8D%87%E7%BA%A7-dubbo3-%E5%85%A8%E9%9D%A2%E5%8F%96%E4%BB%A3-hsf2/</link><pubDate>Mon, 16 Jan 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/01/16/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%8D%87%E7%BA%A7-dubbo3-%E5%85%A8%E9%9D%A2%E5%8F%96%E4%BB%A3-hsf2/</guid><description>继业务全面上云后，2022 双十一，阿里巴巴微服务技术栈全面迁移到以 Dubbo3 为代表的云上开源标准中间件体系。在业务上，基于 Dubbo3 首次实现了关键业务不停推、不降级的全面用户体验提升，从技术上，大幅提高研发与运维效率的同时地址推送等关键资源利用率提升超 40%，基于三位一体的 Dubbo3 开源中间件体系打造了阿里在云上的单元化最佳实践和统一标准，同时将规模化实践经验与技术创新贡献开源社区，成为微服务开源技术与标准发展的核心源泉与推动力。
1 阿里电商 &amp;hellip;&amp;hellip;
整个电商体系的所有核心应用，包括交易相关、导购相关都都升级到了 Dubbo3 体系，用来升级原有的 HSF 框架，阿里电商是对 Dubbo3 实践最广泛、需求最强烈的体系，基于 Dubbo3 实现了以下关键目标。 2022 618大促、双11 大促期间 超 2000+ 应用、40w 节点均跑在 Dubbo3 之上。
应用级服务发现，解决了大促期间地址推送降级的问题，部分关键链路提升单机资源利用率 40%，大促期间地址推送SLA保障、资源利用率。 Triple协议，解决跨网关高效互通的问题，同时部分业务线升级了 Streaming 编程和通信模式。 统一的流量治理规则，阿里电商场景的路由规则非常复杂，基于实现了云原生体系的结合。 Service Mesh 解决方案，Thin SDK + Proxyless 的解决方案 服务柔性，目前正在落地和探索自适应负载均衡、自适应限流等策略。 2 蚂蚁金服 阿里集团内与蚂蚁体系的互通，目前都跑在 Dubbo3 Triple 互通链路上，与原有基于 HSF 的互通方案对比，Triple 协议链路的 RT 降低了 50%。集团与蚂蚁东西向流量的核心链路，飞猪、手淘、口碑、饿了么、1688、部分导购应用、商品库、评价等业务都采用此方案。
3 本地生活 截止 2022 年初，Dubbo3 实现了在饿了么全量业务的生产上线，取代了之前自建的微服务体系，在过去的近一年时间内，饿了么线上有 2000 应用、15w 实例节点平稳跑在 Dubbo3 之上。
饿了么成功升级 Dubbo3 及应用级服务发现模型，实现了和阿里电商系统互通、单元化体系互通架构的升级，实现了去 proxy 架构的目标，在饿了么关心的服务发现数据链路上：</description></item><item><title>0-1 - 线程池资源枯竭</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/1/</guid><description>服务端的线程资源耗尽了。 默认情况下，Dubbo 服务端的业务线程数是 200 个。如果多个并发请求量超过了 200，就会拒绝新的请求，抛出此错误。
可能的原因 Consumer 的并发请求量太大，导致 Provider 端创建的线程数量超限。 可能 Provider 端在执行业务的时候，由于业务调用外部应用接口，导致线程出现阻塞，从而导致线程池回收不了线程。 排查和解决步骤 开启 Dubbo 的访问日志功能，排查是否有短时间内大量调用 RPC 服务的情况。 通过 jps 和 jstack 指令检查线程池中各个线程的状态，看下是否有业务调用外部应用接口造成阻塞。 如果是 Consumer 的并发请求量太大，那么调整 Provider 端的 dubbo.provider.threads 参数，将 Dubbo 的线程池的数目调大。 如果 Provider 业务的 QPS 实在太大，目前的服务器数目处理不完，那么增加 Provider 端服务器的数量，让更多的服务器分担压力。 这个错误码的 FAQ 页面参考了空冥同学的 《Dubbo 常见错误及解决方法》 。 所引文章通过 CC-BY-4.0 协议赋予了汇编的权利。在此向原作者表示感谢。</description></item><item><title>1-1 - 地址非法</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/1/</guid><description>此日志可以忽略，服务版本或分组不匹配。仅出现在 zookeeper 注册中心中，在 3.1.7 版本中已经取消此检查。
可能的原因 Provider 端配置的 service.group 和 Consumer 端配置的 reference.group （即服务分组的配置）不匹配。 Provider 端配置的 service.version 和 Consumer 端配置的 reference.version （即服务版本的配置）不匹配。 排查和解决步骤 可以忽略，在 3.1.7 版本中已经取消此检查。</description></item><item><title>2-1 - 路由选址执行失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/1/</guid><description>路由选址执行失败</description></item><item><title>2.x 升级至 3.x</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/upgrades-and-compatibility/version/2.x-to-3.x-compatibility-guide/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/upgrades-and-compatibility/version/2.x-to-3.x-compatibility-guide/</guid><description>升级到 Dubbo 3.X 的收益 Dubbo3 依旧保持了 2.x 的经典架构，以解决微服务进程间通信为主要职责，通过丰富的服务治理（如地址发现、流量管理等）能力来更好的管控微服务集群；Dubbo3 对原有框架的升级是全面的，体现在核心 Dubbo 特性的几乎每个环节，通过升级实现了稳定性、性能、伸缩性、易用性的全面提升。
通用的通信协议。 全新的 RPC 协议应摒弃私有协议栈，以更通用的 HTTP/2 协议为传输层载体，借助 HTTP 协议的标准化特性，解决流量通用性、穿透性等问题，让协议能更好的应对前后端对接、网关代理等场景；支持 Stream 通信模式，满足不同业务通信模型诉求的同时给集群带来更大的吞吐量。 面向百万集群实例，集群高度可伸缩。 随着微服务实践的推广，微服务集群实例的规模也在不停的扩展，这得益于微服务轻量化、易于水平扩容的特性，同时也给整个集群容量带来了负担，尤其是一些中心化的服务治理组件；Dubbo3 需要解决实例规模扩展带来的种种资源瓶颈问题，实现真正的无限水平扩容。 全面拥抱云原生。 Dubbo 3.0 新特性 Dubbo 3.0 提供的新特性包括：
新的地址发现模型（应用级服务发现）。 查看应用级服务发现迁移示例。 查看应用级服务发现的迁移步骤 查看应用级服务发现地址迁移规则说明 下一代基于 HTTP/2 的 Triple 协议。 查看Triple 协议迁移步骤 查看 Triple 协议使用方式 查看 Triple 协议设计与实现。 统一的路由规则。 查看统一路由规则设计与实现 升级前的兼容性检查 在跨版本升级的过程中，存在的风险点从大到小分别有：直接修改 Dubbo 源码 -&amp;gt; 基于 Dubbo SPI 扩展点进行扩展 -&amp;gt; 基于 API 或者 Spring 的使用方式。
1. 直接修改 Dubbo 源码 对于直接修改 Dubbo 源码这部分的需要修改方自行判断是否在高版本中正常工作，对于这种非标准行为，Dubbo 无法保证其先前的兼容性。此外，通过 javagent 或者 asm 等通过运行时对 Dubbo 的修改也在此范围内。此类修改大部分可以通过后文提供的扫描工具检测出来。</description></item><item><title>3-1 - 将地址转换成 Invoker 失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/3/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/3/1/</guid><description>可能的原因 客户端配置的协议与服务端配置的协议并不匹配。（如客户端配置的协议是 Dubbo 协议，但服务端只能提供 Rest 协议的服务） 注册中心（或配置中心）不可靠，推送了并不合法的数据。 排查和解决步骤 检查提供方和消费方双方的协议配置。 更新注册中心的版本。</description></item><item><title>4-1 - 不支持的协议</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/1/</guid><description>可能的原因 这种情况可能出现在自定义 Protocol 的场景下。Dubbo 的 SPI 机制找不到 URL 中所指定的 Protocol。
排查和解决步骤 确定 Consumer 中有服务端所用到的 Protocol 的依赖。 确定 Protocol 的依赖包的 SPI 配置文件的名字没有写错。 另请参阅 Dubbo SPI 概述
协议扩展说明</description></item><item><title>5-1 - 配置中心连接失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/1/</guid><description>可能的原因 配置中心所在的服务器关机或宕机。 IP 或者端口号写错。 防火墙错误拦截了配置中心的端口。 排查和解决步骤 检查配置中心 IP 以及端口的配置。 检查服务器是否开机，是否正常工作。 检查防火墙等是否放行配置中心所用的端口。</description></item><item><title>6-1 - 服务端连接失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/1/</guid><description>网络通信层，在连接服务提供者服务时失败
可能的原因 服务提供者的网络异常断开或受防火墙及第三方工具的拦截，无法对外提供服务。
排查和解决步骤 如果为 rest 连接，检查请求的服务端配置是否正确。 检查网络通信是否正常，可使用一些简单的 cmd 命令进行检测，如 ping 等。</description></item><item><title>7-1 - QOS 已关闭</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/7/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/7/1/</guid><description>可能的原因 QOS 已关闭
排查和解决步骤 请参考QOS 操作手册。</description></item><item><title>81-1 - ZK 启动异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/81/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/81/1/</guid><description>可能的原因 zk 的服务端版本与客户端版本存在不兼容问题，无法进行连接。 zk 服务未正常启动或防火墙等原因不能对外提供服务。 排查和解决步骤 确认客户端版本与服务端版本一致。 zk 能够正常启动或对外能够提供正常服务。 可通过一些第三方的工具或者jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>99-0 - 内部未知错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/99/0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/99/0/</guid><description>Dubbo 内部的未知错误。
可能的原因 未知错误
排查和解决步骤 保护现场。将日志文件保存下来，尽可能记录下发生故障当时的情况。（此时可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息。） 如果在这个错误码之前有其它的错误码的日志记录，那么请先查看一下那个错误码的记录。 检查配置文件是否有误。 如果是修改了代码引入了这个错误，尝试回滚到上一个版本。 如果都没解决，请尽可能做出一个复现该问题的最小 Demo，之后到 GitHub Issue Tracker 下发 Issue。 另请参阅 配置项手册</description></item><item><title>Dubbo SPI</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/dubbo-spi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/dubbo-spi/</guid><description>1.简介 SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。SPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI，我们可以很容易的对 Dubbo 进行拓展。如果大家想要学习 Dubbo 的源码，SPI 机制务必弄懂。接下来，我们先来了解一下 Java SPI 与 Dubbo SPI 的用法，然后再来分析 Dubbo SPI 的源码。
需要特别说明的是，本篇文章以及本系列其他文章所分析的源码版本均为 dubbo-2.6.4。因此大家在阅读文章的过程中，需注意将代码版本切换到 dubbo-2.6.4 tag 上。
2.SPI 示例 2.1 Java SPI 示例 前面简单介绍了 SPI 机制的原理，本节通过一个示例演示 Java SPI 的使用方法。首先，我们定义一个接口，名称为 Robot。
public interface Robot { void sayHello(); } 接下来定义两个实现类，分别为 OptimusPrime 和 Bumblebee。
public class OptimusPrime implements Robot { @Override public void sayHello() { System.</description></item><item><title>dubbo 协议</title><link>https://dubbo.apache.org/zh-cn/docs/references/protocols/dubbo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/protocols/dubbo/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。
反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。
Transporter: mina, netty, grizzy Serialization: dubbo, hessian2, java, json Dispatcher: all, direct, message, execution, connection ThreadPool: fixed, cached 特性 缺省协议，使用基于 netty 3.2.5.Final 和 hessian2 3.2.1-fixed-2(Alibaba embed version) 的 tbremoting 交互。
连接个数：单连接 连接方式：长连接 传输协议：TCP 传输方式：NIO 异步传输 序列化：Hessian 二进制序列化 适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。 适用场景：常规远程服务方法调用 约束 参数及返回值需实现 Serializable 接口 参数及返回值不能自定义实现 List, Map, Number, Date, Calendar 等接口，只能用 JDK 自带的实现，因为 hessian 会做特殊处理，自定义实现类中的属性值都会丢失。 Hessian 序列化，只传成员属性值和值的类型，不传方法或静态变量，兼容情况 12： 数据通讯 情况 结果 A-&amp;gt;B 类A多一种 属性（或者说类B少一种 属性） 不抛异常，A多的那 个属性的值，B没有， 其他正常 A-&amp;gt;B 枚举A多一种 枚举（或者说B少一种 枚举），A使用多 出来的枚举进行传输 抛异常 A-&amp;gt;B 枚举A多一种 枚举（或者说B少一种 枚举），A不使用 多出来的枚举进行传输 不抛异常，B正常接 收数据 A-&amp;gt;B A和B的属性 名相同，但类型不相同 抛异常 A-&amp;gt;B serialId 不相同 正常传输 接口增加方法，对客户端无影响，如果该方法不是客户端需要的，客户端不需要重新部署。输入参数和结果集中增加属性，对客户端无影响，如果客户端并不需要新属性，不用重新部署。</description></item><item><title>dubbo 协议</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/dubbo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/dubbo/</guid><description>Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。
反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。
Transporter: mina, netty, grizzy Serialization: dubbo, hessian2, java, json Dispatcher: all, direct, message, execution, connection ThreadPool: fixed, cached 特性 缺省协议，使用基于 netty 3.2.5.Final 和 hessian2 3.2.1-fixed-2(Alibaba embed version) 的 tbremoting 交互。
连接个数：单连接 连接方式：长连接 传输协议：TCP 传输方式：NIO 异步传输 序列化：Hessian 二进制序列化 适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。 适用场景：常规远程服务方法调用 约束 参数及返回值需实现 Serializable 接口 参数及返回值不能自定义实现 List, Map, Number, Date, Calendar 等接口，只能用 JDK 自带的实现，因为 hessian 会做特殊处理，自定义实现类中的属性值都会丢失。 Hessian 序列化，只传成员属性值和值的类型，不传方法或静态变量，兼容情况 12： 数据通讯 情况 结果 A-&amp;gt;B 类A多一种 属性（或者说类B少一种 属性） 不抛异常，A多的那 个属性的值，B没有， 其他正常 A-&amp;gt;B 枚举A多一种 枚举（或者说B少一种 枚举），A使用多 出来的枚举进行传输 抛异常 A-&amp;gt;B 枚举A多一种 枚举（或者说B少一种 枚举），A不使用 多出来的枚举进行传输 不抛异常，B正常接 收数据 A-&amp;gt;B A和B的属性 名相同，但类型不相同 抛异常 A-&amp;gt;B serialId 不相同 正常传输 接口增加方法，对客户端无影响，如果该方法不是客户端需要的，客户端不需要重新部署。输入参数和结果集中增加属性，对客户端无影响，如果客户端并不需要新属性，不用重新部署。</description></item><item><title>dubbo:application</title><link>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-application/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
应用信息配置。对应的配置类：org.apache.dubbo.config.ApplicationConfig
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 name application string 必填 服务治理 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样，此参数不是匹配条件，你当前项目叫什么名字就填什么，和提供者消费者角色无关，比如：kylin应用调用了morgan应用的服务，则kylin项目配成kylin，morgan项目配成morgan，可能kylin也提供其它服务给别人使用，但kylin项目永远配成kylin，这样注册中心将显示kylin依赖于morgan 1.0.16以上版本 version application.version string 可选 服务治理 当前应用的版本 2.2.0以上版本 owner owner string 可选 服务治理 应用负责人，用于服务治理，请填写负责人公司邮箱前缀 2.0.5以上版本 organization organization string 可选 服务治理 组织名称(BU或部门)，用于注册中心区分服务来源，此配置项建议不要使用autoconfig，直接写死在配置中，比如china,intl,itu,crm,asc,dw,aliexpress等 2.0.0以上版本 architecture architecture string 可选 服务治理 用于服务分层对应的架构。如，intl、china。不同的架构使用不同的分层。 2.0.7以上版本 environment environment string 可选 服务治理 应用环境，如：develop/test/product，不同环境使用不同的缺省值，以及作为只用于开发测试功能的限制条件 2.0.0以上版本 compiler compiler string 可选 javassist 性能优化 Java字节码编译器，用于动态类的生成，可选：jdk或javassist 2.1.0以上版本 logger logger string 可选 slf4j 性能优化 日志输出方式，可选：slf4j,jcl,log4j,log4j2,jdk 2.2.0以上版本 metadata-type metadata-type String 可选 local 服务治理 metadata 传递方式，是以 Provider 视角而言的，Consumer 侧配置无效，可选值有：</description></item><item><title>dubbo:application</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-application/</guid><description>应用信息配置。对应的配置类：org.apache.dubbo.config.ApplicationConfig
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 name application string 必填 服务治理 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样，此参数不是匹配条件，你当前项目叫什么名字就填什么，和提供者消费者角色无关，比如：kylin应用调用了morgan应用的服务，则kylin项目配成kylin，morgan项目配成morgan，可能kylin也提供其它服务给别人使用，但kylin项目永远配成kylin，这样注册中心将显示kylin依赖于morgan 1.0.16以上版本 version application.version string 可选 服务治理 当前应用的版本 2.2.0以上版本 owner owner string 可选 服务治理 应用负责人，用于服务治理，请填写负责人公司邮箱前缀 2.0.5以上版本 organization organization string 可选 服务治理 组织名称(BU或部门)，用于注册中心区分服务来源，此配置项建议不要使用autoconfig，直接写死在配置中，比如china,intl,itu,crm,asc,dw,aliexpress等 2.0.0以上版本 architecture architecture string 可选 服务治理 用于服务分层对应的架构。如，intl、china。不同的架构使用不同的分层。 2.0.7以上版本 environment environment string 可选 服务治理 应用环境，如：develop/test/product，不同环境使用不同的缺省值，以及作为只用于开发测试功能的限制条件 2.0.0以上版本 compiler compiler string 可选 javassist 性能优化 Java字节码编译器，用于动态类的生成，可选：jdk或javassist 2.1.0以上版本 logger logger string 可选 slf4j 性能优化 日志输出方式，可选：slf4j,jcl,log4j,log4j2,jdk 2.2.0以上版本</description></item><item><title>dubbo:argument</title><link>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-argument/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-argument/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
方法参数配置。对应的配置类： org.apache.dubbo.config.ArgumentConfig。该标签为 &amp;lt;dubbo:method&amp;gt; 的子标签，用于方法参数的特征描述，比如：
&amp;lt;dubbo:method name=&amp;#34;findXxx&amp;#34; timeout=&amp;#34;3000&amp;#34; retries=&amp;#34;2&amp;#34;&amp;gt; &amp;lt;dubbo:argument index=&amp;#34;0&amp;#34; callback=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;/dubbo:method&amp;gt; 属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 index int 必填 标识 参数索引 2.0.6以上版本 type String 与index二选一 标识 通过参数类型查找参数的index 2.0.6以上版本 callback &amp;lt;metodName&amp;gt;&amp;lt;index&amp;gt;.retries boolean 可选 服务治理 参数是否为callback接口，如果为callback，服务提供方将生成反向代理，可以从服务提供方反向调用消费方，通常用于事件推送. 2.0.6以上版本</description></item><item><title>dubbo:argument</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-argument/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-argument/</guid><description>方法参数配置。对应的配置类： org.apache.dubbo.config.ArgumentConfig。该标签为 &amp;lt;dubbo:method&amp;gt; 的子标签，用于方法参数的特征描述，比如：
&amp;lt;dubbo:method name=&amp;#34;findXxx&amp;#34; timeout=&amp;#34;3000&amp;#34; retries=&amp;#34;2&amp;#34;&amp;gt; &amp;lt;dubbo:argument index=&amp;#34;0&amp;#34; callback=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;/dubbo:method&amp;gt; 属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 index int 必填 标识 参数索引 2.0.6以上版本 type String 与index二选一 标识 通过参数类型查找参数的index 2.0.6以上版本 callback &amp;lt;metodName&amp;gt;&amp;lt;index&amp;gt;.retries boolean 可选 服务治理 参数是否为callback接口，如果为callback，服务提供方将生成反向代理，可以从服务提供方反向调用消费方，通常用于事件推送. 2.0.6以上版本</description></item><item><title>dubbo:config-center</title><link>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-config-center/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-config-center/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
配置中心。对应的配置类：org.apache.dubbo.config.ConfigCenterConfig
属性 对应URL参数 类型 是否必填 缺省值 描述 兼容性 protocol config.protocol string 可选 zookeeper 使用哪个配置中心：apollo、zookeeper、nacos等。
以zookeeper为例
1. 指定protocol，则address可以简化为127.0.0.1:2181；
2. 不指定protocol，则address取值为zookeeper://127.0.0.1:2181 2.7.0+ address config.address string 必填 配置中心地址。
取值参见protocol说明 2.7.0+ highest-priority config.highestPriority boolean 可选 true 来自配置中心的配置项具有最高优先级，即会覆盖本地配置项。 2.7.0+ namespace config.namespace string 可选 dubbo 通常用于多租户隔离，实际含义视具体配置中心而不同。
如：
zookeeper - 环境隔离，默认值dubbo；
apollo - 区分不同领域的配置集合，默认使用dubbo和application 2.7.0+ cluster config.cluster string 可选 含义视所选定的配置中心而不同。
如Apollo中用来区分不同的配置集群 2.7.0+ group config.group string 可选 dubbo 含义视所选定的配置中心而不同。
nacos - 隔离不同配置集
zookeeper - 隔离不同配置集 2.7.0+ check config.</description></item><item><title>dubbo:config-center</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-config-center/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-config-center/</guid><description>配置中心。对应的配置类：org.apache.dubbo.config.ConfigCenterConfig
属性 对应URL参数 类型 是否必填 缺省值 描述 兼容性 protocol config.protocol string 可选 zookeeper 使用哪个配置中心：apollo、zookeeper、nacos等。
以zookeeper为例
1. 指定protocol，则address可以简化为127.0.0.1:2181；
2. 不指定protocol，则address取值为zookeeper://127.0.0.1:2181 2.7.0+ address config.address string 必填 配置中心地址。
取值参见protocol说明 2.7.0+ highest-priority config.highestPriority boolean 可选 true 来自配置中心的配置项具有最高优先级，即会覆盖本地配置项。 2.7.0+ namespace config.namespace string 可选 dubbo 通常用于多租户隔离，实际含义视具体配置中心而不同。
如：
zookeeper - 环境隔离，默认值dubbo；
apollo - 区分不同领域的配置集合，默认使用dubbo和application 2.7.0+ cluster config.cluster string 可选 含义视所选定的配置中心而不同。
如Apollo中用来区分不同的配置集群 2.7.0+ group config.group string 可选 dubbo 含义视所选定的配置中心而不同。
nacos - 隔离不同配置集
zookeeper - 隔离不同配置集 2.7.0+ check config.check boolean 可选 true 当配置中心连接失败时，是否终止应用启动。 2.</description></item><item><title>dubbo:consumer</title><link>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-consumer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-consumer/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
服务消费者缺省值配置。配置类： org.apache.dubbo.config.ConsumerConfig 。同时该标签为 &amp;lt;dubbo:reference&amp;gt; 标签的缺省值设置。
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 timeout default.timeout int 可选 1000 性能调优 远程服务调用超时时间(毫秒) 1.0.16以上版本 retries default.retries int 可选 2 性能调优 远程服务调用重试次数，不包括第一次调用，不需要重试请设为0,仅在cluster为failback/failover时有效 1.0.16以上版本 loadbalance default.loadbalance string 可选 random 性能调优 负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用 1.0.16以上版本 async default.async boolean 可选 false 性能调优 是否缺省异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程 2.0.0以上版本 connections default.connections int 可选 100 性能调优 每个服务对每个提供者的最大连接数，rmi、http、hessian等短连接协议支持此配置，dubbo协议长连接不支持此配置 1.0.16以上版本 generic generic boolean 可选 false 服务治理 是否缺省泛化接口，如果为泛化接口，将返回GenericService 2.0.0以上版本 check check boolean 可选 true 服务治理 启动时检查提供者是否存在，true报错，false忽略 1.</description></item><item><title>dubbo:consumer</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-consumer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-consumer/</guid><description>服务消费者缺省值配置。配置类： org.apache.dubbo.config.ConsumerConfig 。同时该标签为 &amp;lt;dubbo:reference&amp;gt; 标签的缺省值设置。
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 timeout default.timeout int 可选 1000 性能调优 远程服务调用超时时间(毫秒) 1.0.16以上版本 retries default.retries int 可选 2 性能调优 远程服务调用重试次数，不包括第一次调用，不需要重试请设为0,仅在cluster为failback/failover时有效 1.0.16以上版本 loadbalance default.loadbalance string 可选 random 性能调优 负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用 1.0.16以上版本 async default.async boolean 可选 false 性能调优 是否缺省异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程 2.0.0以上版本 connections default.connections int 可选 100 性能调优 每个服务对每个提供者的最大连接数，rmi、http、hessian等短连接协议支持此配置，dubbo协议长连接不支持此配置 1.0.16以上版本 generic generic boolean 可选 false 服务治理 是否缺省泛化接口，如果为泛化接口，将返回GenericService 2.0.0以上版本 check check boolean 可选 true 服务治理 启动时检查提供者是否存在，true报错，false忽略 1.0.16以上版本 proxy proxy string 可选 javassist 性能调优 生成动态代理方式，可选：jdk/javassist 2.</description></item><item><title>dubbo:method</title><link>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-method/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-method/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
方法级配置。对应的配置类： org.apache.dubbo.config.MethodConfig。同时该标签为 &amp;lt;dubbo:service&amp;gt; 或 &amp;lt;dubbo:reference&amp;gt; 的子标签，用于控制到方法级。
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 name string 必填 标识 方法名 1.0.8以上版本 timeout &amp;lt;methodName&amp;gt;.timeout int 可选 缺省为的timeout 性能调优 方法调用超时时间(毫秒) 1.0.8以上版本 retries &amp;lt;methodName&amp;gt;.retries int 可选 缺省为&amp;lt;dubbo:reference&amp;gt;的retries 性能调优 远程服务调用重试次数，不包括第一次调用，不需要重试请设为0 2.0.0以上版本 loadbalance &amp;lt;methodName&amp;gt;.loadbalance string 可选 缺省为的loadbalance 性能调优 负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用 2.0.0以上版本 async &amp;lt;methodName&amp;gt;.async boolean 可选 缺省为&amp;lt;dubbo:reference&amp;gt;的async 性能调优 是否异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程 1.0.9以上版本 sent &amp;lt;methodName&amp;gt;.sent boolean 可选 true 性能调优 异步调用时，标记sent=true时，表示网络已发出数据 2.0.6以上版本 actives &amp;lt;methodName&amp;gt;.actives int 可选 0 性能调优 每服务消费者最大并发调用限制 2.0.5以上版本 executes &amp;lt;methodName&amp;gt;.</description></item><item><title>dubbo:method</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-method/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-method/</guid><description>方法级配置。对应的配置类： org.apache.dubbo.config.MethodConfig。同时该标签为 &amp;lt;dubbo:service&amp;gt; 或 &amp;lt;dubbo:reference&amp;gt; 的子标签，用于控制到方法级。
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 name string 必填 标识 方法名 1.0.8以上版本 timeout &amp;lt;methodName&amp;gt;.timeout int 可选 缺省为的timeout 性能调优 方法调用超时时间(毫秒) 1.0.8以上版本 retries &amp;lt;methodName&amp;gt;.retries int 可选 缺省为&amp;lt;dubbo:reference&amp;gt;的retries 性能调优 远程服务调用重试次数，不包括第一次调用，不需要重试请设为0 2.0.0以上版本 loadbalance &amp;lt;methodName&amp;gt;.loadbalance string 可选 缺省为的loadbalance 性能调优 负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用 2.0.0以上版本 async &amp;lt;methodName&amp;gt;.async boolean 可选 缺省为&amp;lt;dubbo:reference&amp;gt;的async 性能调优 是否异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程 1.0.9以上版本 sent &amp;lt;methodName&amp;gt;.sent boolean 可选 true 性能调优 异步调用时，标记sent=true时，表示网络已发出数据 2.0.6以上版本 actives &amp;lt;methodName&amp;gt;.actives int 可选 0 性能调优 每服务消费者最大并发调用限制 2.0.5以上版本 executes &amp;lt;methodName&amp;gt;.executes int 可选 0 性能调优 每服务每方法最大使用线程数限制- -，此属性只在&amp;lt;dubbo:method&amp;gt;作为&amp;lt;dubbo:service&amp;gt;子标签时有效 2.</description></item><item><title>dubbo:module</title><link>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-module/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-module/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
模块信息配置。对应的配置类 org.apache.dubbo.config.ModuleConfig
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 name module string 必填 服务治理 当前模块名称，用于注册中心计算模块间依赖关系 2.2.0以上版本 version module.version string 可选 服务治理 当前模块的版本 2.2.0以上版本 owner owner string 可选 服务治理 模块负责人，用于服务治理，请填写负责人公司邮箱前缀 2.2.0以上版本 organization organization string 可选 服务治理 组织名称(BU或部门)，用于注册中心区分服务来源，此配置项建议不要使用autoconfig，直接写死在配置中，比如china,intl,itu,crm,asc,dw,aliexpress等 2.2.0以上版本</description></item><item><title>dubbo:module</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-module/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-module/</guid><description>模块信息配置。对应的配置类 org.apache.dubbo.config.ModuleConfig
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 name module string 必填 服务治理 当前模块名称，用于注册中心计算模块间依赖关系 2.2.0以上版本 version module.version string 可选 服务治理 当前模块的版本 2.2.0以上版本 owner owner string 可选 服务治理 模块负责人，用于服务治理，请填写负责人公司邮箱前缀 2.2.0以上版本 organization organization string 可选 服务治理 组织名称(BU或部门)，用于注册中心区分服务来源，此配置项建议不要使用autoconfig，直接写死在配置中，比如china,intl,itu,crm,asc,dw,aliexpress等 2.2.0以上版本</description></item><item><title>dubbo:monitor</title><link>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-monitor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-monitor/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
监控中心配置。对应的配置类： org.apache.dubbo.config.MonitorConfig
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 protocol protocol string 可选 dubbo 服务治理 监控中心协议，如果为protocol=&amp;ldquo;registry&amp;rdquo;，表示从注册中心发现监控中心地址，否则直连监控中心。 2.0.9以上版本 address &amp;lt;url&amp;gt; string 可选 N/A 服务治理 直连监控中心服务器地址，address=&amp;ldquo;10.20.130.230:12080&amp;rdquo; 1.0.16以上版本</description></item><item><title>dubbo:monitor</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-monitor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-monitor/</guid><description>监控中心配置。对应的配置类： org.apache.dubbo.config.MonitorConfig
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 protocol protocol string 可选 dubbo 服务治理 监控中心协议，如果为protocol=&amp;ldquo;registry&amp;rdquo;，表示从注册中心发现监控中心地址，否则直连监控中心。 2.0.9以上版本 address &amp;lt;url&amp;gt; string 可选 N/A 服务治理 直连监控中心服务器地址，address=&amp;ldquo;10.20.130.230:12080&amp;rdquo; 1.0.16以上版本</description></item><item><title>dubbo:parameter</title><link>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-parameter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-parameter/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
选项参数配置。对应的配置类：java.util.Map。同时该标签为&amp;lt;dubbo:protocol&amp;gt;或&amp;lt;dubbo:service&amp;gt;或&amp;lt;dubbo:provider&amp;gt;或&amp;lt;dubbo:reference&amp;gt;或&amp;lt;dubbo:consumer&amp;gt;的子标签，用于配置自定义参数，该配置项将作为扩展点设置自定义参数使用。
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 key key string 必填 服务治理 路由参数键 2.0.0以上版本 value value string 必填 服务治理 路由参数值 2.0.0以上版本 比如：
&amp;lt;dubbo:protocol name=&amp;#34;napoli&amp;#34;&amp;gt; &amp;lt;dubbo:parameter key=&amp;#34;http://10.20.160.198/wiki/display/dubbo/napoli.queue.name&amp;#34; value=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;/dubbo:protocol&amp;gt; 也可以：
&amp;lt;dubbo:protocol name=&amp;#34;jms&amp;#34; p:queue=&amp;#34;xxx&amp;#34; /&amp;gt;</description></item><item><title>dubbo:parameter</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-parameter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-parameter/</guid><description>选项参数配置。对应的配置类：java.util.Map。同时该标签为&amp;lt;dubbo:protocol&amp;gt;或&amp;lt;dubbo:service&amp;gt;或&amp;lt;dubbo:provider&amp;gt;或&amp;lt;dubbo:reference&amp;gt;或&amp;lt;dubbo:consumer&amp;gt;的子标签，用于配置自定义参数，该配置项将作为扩展点设置自定义参数使用。
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 key key string 必填 服务治理 路由参数键 2.0.0以上版本 value value string 必填 服务治理 路由参数值 2.0.0以上版本 比如：
&amp;lt;dubbo:protocol name=&amp;#34;napoli&amp;#34;&amp;gt; &amp;lt;dubbo:parameter key=&amp;#34;http://10.20.160.198/wiki/display/dubbo/napoli.queue.name&amp;#34; value=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;/dubbo:protocol&amp;gt; 也可以：
&amp;lt;dubbo:protocol name=&amp;#34;jms&amp;#34; p:queue=&amp;#34;xxx&amp;#34; /&amp;gt;</description></item><item><title>dubbo:protocol</title><link>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-protocol/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
服务提供者协议配置。对应的配置类： org.apache.dubbo.config.ProtocolConfig。同时，如果需要支持多协议，可以声明多个 &amp;lt;dubbo:protocol&amp;gt; 标签，并在 &amp;lt;dubbo:service&amp;gt; 中通过 protocol 属性指定使用的协议。
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 id string 可选 dubbo 配置关联 协议BeanId，可以在&amp;lt;dubbo:service protocol=&amp;quot;&amp;quot;&amp;gt;中引用此ID，如果ID不填，缺省和name属性值一样，重复则在name后加序号。 2.0.5以上版本 name &amp;lt;protocol&amp;gt; string 必填 dubbo 性能调优 协议名称 2.0.5以上版本 port &amp;lt;port&amp;gt; int 可选 dubbo协议缺省端口为20880，rmi协议缺省端口为1099，http和hessian协议缺省端口为80；如果没有配置port，则自动采用默认端口，如果配置为-1，则会分配一个没有被占用的端口。Dubbo 2.4.0+，分配的端口在协议缺省端口的基础上增长，确保端口段可控。 服务发现 服务端口 2.0.5以上版本 host &amp;lt;host&amp;gt; string 可选 自动查找本机IP 服务发现 -服务主机名，多网卡选择或指定VIP及域名时使用，为空则自动查找本机IP，-建议不要配置，让Dubbo自动获取本机IP 2.0.5以上版本 threadpool threadpool string 可选 fixed 性能调优 线程池类型，可选：fixed/cached 2.0.5以上版本 threads threads int 可选 200 性能调优 服务线程池大小(固定大小) 2.0.5以上版本 iothreads threads int 可选 cpu个数+1 性能调优 io线程池大小(固定大小) 2.</description></item><item><title>dubbo:protocol</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-protocol/</guid><description>服务提供者协议配置。对应的配置类： org.apache.dubbo.config.ProtocolConfig。同时，如果需要支持多协议，可以声明多个 &amp;lt;dubbo:protocol&amp;gt; 标签，并在 &amp;lt;dubbo:service&amp;gt; 中通过 protocol 属性指定使用的协议。
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 id string 可选 dubbo 配置关联 协议BeanId，可以在&amp;lt;dubbo:service protocol=&amp;quot;&amp;quot;&amp;gt;中引用此ID，如果ID不填，缺省和name属性值一样，重复则在name后加序号。 2.0.5以上版本 name &amp;lt;protocol&amp;gt; string 必填 dubbo 性能调优 协议名称 2.0.5以上版本 port &amp;lt;port&amp;gt; int 可选 dubbo协议缺省端口为20880，rmi协议缺省端口为1099，http和hessian协议缺省端口为80；如果没有配置port，则自动采用默认端口，如果配置为-1，则会分配一个没有被占用的端口。Dubbo 2.4.0+，分配的端口在协议缺省端口的基础上增长，确保端口段可控。 服务发现 服务端口 2.0.5以上版本 host &amp;lt;host&amp;gt; string 可选 自动查找本机IP 服务发现 -服务主机名，多网卡选择或指定VIP及域名时使用，为空则自动查找本机IP，-建议不要配置，让Dubbo自动获取本机IP 2.0.5以上版本 threadpool threadpool string 可选 fixed 性能调优 线程池类型，可选：fixed/cached 2.0.5以上版本 threads threads int 可选 200 性能调优 服务线程池大小(固定大小) 2.0.5以上版本 iothreads threads int 可选 cpu个数+1 性能调优 io线程池大小(固定大小) 2.</description></item><item><title>dubbo:provider</title><link>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-provider/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-provider/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
服务提供者缺省值配置。对应的配置类： org.apache.dubbo.config.ProviderConfig。同时该标签为 &amp;lt;dubbo:service&amp;gt; 和 &amp;lt;dubbo:protocol&amp;gt; 标签的缺省值设置。
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 id string 可选 dubbo 配置关联 协议BeanId，可以在&amp;lt;dubbo:service proivder=&amp;quot;&amp;quot;&amp;gt;中引用此ID 1.0.16以上版本 protocol &amp;lt;protocol&amp;gt; string 可选 dubbo 性能调优 协议名称 1.0.16以上版本 host &amp;lt;host&amp;gt; string 可选 自动查找本机IP 服务发现 服务主机名，多网卡选择或指定VIP及域名时使用，为空则自动查找本机IP，建议不要配置，让Dubbo自动获取本机IP 1.0.16以上版本 threads threads int 可选 200 性能调优 服务线程池大小(固定大小) 1.0.16以上版本 payload payload int 可选 8388608(=8M) 性能调优 请求及响应数据包大小限制，单位：字节 2.0.0以上版本 path &amp;lt;path&amp;gt; string 可选 服务发现 提供者上下文路径，为服务path的前缀 2.0.0以上版本 server server string 可选 dubbo协议缺省为netty，http协议缺省为servlet 性能调优 协议的服务器端实现类型，比如：dubbo协议的mina,netty等，http协议的jetty,servlet等 2.</description></item><item><title>dubbo:provider</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-provider/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-provider/</guid><description>服务提供者缺省值配置。对应的配置类： org.apache.dubbo.config.ProviderConfig。同时该标签为 &amp;lt;dubbo:service&amp;gt; 和 &amp;lt;dubbo:protocol&amp;gt; 标签的缺省值设置。
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 id string 可选 dubbo 配置关联 协议BeanId，可以在&amp;lt;dubbo:service proivder=&amp;quot;&amp;quot;&amp;gt;中引用此ID 1.0.16以上版本 protocol &amp;lt;protocol&amp;gt; string 可选 dubbo 性能调优 协议名称 1.0.16以上版本 host &amp;lt;host&amp;gt; string 可选 自动查找本机IP 服务发现 服务主机名，多网卡选择或指定VIP及域名时使用，为空则自动查找本机IP，建议不要配置，让Dubbo自动获取本机IP 1.0.16以上版本 threads threads int 可选 200 性能调优 服务线程池大小(固定大小) 1.0.16以上版本 payload payload int 可选 8388608(=8M) 性能调优 请求及响应数据包大小限制，单位：字节 2.0.0以上版本 path &amp;lt;path&amp;gt; string 可选 服务发现 提供者上下文路径，为服务path的前缀 2.0.0以上版本 server server string 可选 dubbo协议缺省为netty，http协议缺省为servlet 性能调优 协议的服务器端实现类型，比如：dubbo协议的mina,netty等，http协议的jetty,servlet等 2.0.0以上版本 client client string 可选 dubbo协议缺省为netty 性能调优 协议的客户端实现类型，比如：dubbo协议的mina,netty等 2.</description></item><item><title>dubbo:reference</title><link>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-reference/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
服务消费者引用服务配置。对应的配置类： org.apache.dubbo.config.ReferenceConfig
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 id string 必填 配置关联 服务引用BeanId 1.0.0以上版本 interface class 必填 服务发现 服务接口名 1.0.0以上版本 version version string 可选 服务发现 服务版本，与服务提供者的版本一致 1.0.0以上版本 group group string 可选 服务发现 服务分组，当一个接口有多个实现，可以用分组区分，必需和服务提供方一致 1.0.7以上版本 timeout timeout long 可选 缺省使用&amp;lt;dubbo:consumer&amp;gt;的timeout 性能调优 服务方法调用超时时间(毫秒) 1.0.5以上版本 retries retries int 可选 缺省使用&amp;lt;dubbo:consumer&amp;gt;的retries 性能调优 远程服务调用重试次数，不包括第一次调用，不需要重试请设为0 2.0.0以上版本 connections connections int 可选 缺省使用&amp;lt;dubbo:consumer&amp;gt;的connections 性能调优 对每个提供者的最大连接数，rmi、http、hessian等短连接协议表示限制连接数，dubbo等长连接协表示建立的长连接个数 2.0.0以上版本 loadbalance loadbalance string 可选 缺省使用&amp;lt;dubbo:consumer&amp;gt;的loadbalance 性能调优 负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用 2.0.0以上版本 async async boolean 可选 缺省使用&amp;lt;dubbo:consumer&amp;gt;的async 性能调优 是否异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程 2.</description></item><item><title>dubbo:reference</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-reference/</guid><description>服务消费者引用服务配置。对应的配置类： org.apache.dubbo.config.ReferenceConfig
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 id string 必填 配置关联 服务引用BeanId 1.0.0以上版本 interface class 必填 服务发现 服务接口名 1.0.0以上版本 version version string 可选 服务发现 服务版本，与服务提供者的版本一致 1.0.0以上版本 group group string 可选 服务发现 服务分组，当一个接口有多个实现，可以用分组区分，必需和服务提供方一致 1.0.7以上版本 timeout timeout long 可选 缺省使用&amp;lt;dubbo:consumer&amp;gt;的timeout 性能调优 服务方法调用超时时间(毫秒) 1.0.5以上版本 retries retries int 可选 缺省使用&amp;lt;dubbo:consumer&amp;gt;的retries 性能调优 远程服务调用重试次数，不包括第一次调用，不需要重试请设为0 2.0.0以上版本 connections connections int 可选 缺省使用&amp;lt;dubbo:consumer&amp;gt;的connections 性能调优 对每个提供者的最大连接数，rmi、http、hessian等短连接协议表示限制连接数，dubbo等长连接协表示建立的长连接个数 2.0.0以上版本 loadbalance loadbalance string 可选 缺省使用&amp;lt;dubbo:consumer&amp;gt;的loadbalance 性能调优 负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用 2.0.0以上版本 async async boolean 可选 缺省使用&amp;lt;dubbo:consumer&amp;gt;的async 性能调优 是否异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程 2.</description></item><item><title>dubbo:registry</title><link>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-registry/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
注册中心配置。对应的配置类： org.apache.dubbo.config.RegistryConfig。同时如果有多个不同的注册中心，可以声明多个 &amp;lt;dubbo:registry&amp;gt; 标签，并在 &amp;lt;dubbo:service&amp;gt; 或 &amp;lt;dubbo:reference&amp;gt; 的 registry 属性指定使用的注册中心。
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 id string 可选 配置关联 注册中心引用BeanId，可以在&amp;lt;dubbo:service registry=&amp;quot;&amp;quot;&amp;gt;或&amp;lt;dubbo:reference registry=&amp;quot;&amp;quot;&amp;gt;中引用此ID 1.0.16以上版本 address &amp;lt;host:port&amp;gt; string 必填 服务发现 注册中心服务器地址，如果地址没有端口缺省为9090，同一集群内的多个地址用逗号分隔，如：ip:port,ip:port，不同集群的注册中心，请配置多个&amp;lt;dubbo:registry&amp;gt;标签 1.0.16以上版本 protocol &amp;lt;protocol&amp;gt; string 可选 dubbo 服务发现 注册中心地址协议，支持dubbo, multicast, zookeeper, redis, consul(2.7.1), sofa(2.7.2), etcd(2.7.2), nacos(2.7.2)等协议 2.0.0以上版本 port &amp;lt;port&amp;gt; int 可选 9090 服务发现 注册中心缺省端口，当address没有带端口时使用此端口做为缺省值 2.0.0以上版本 username &amp;lt;username&amp;gt; string 可选 服务治理 登录注册中心用户名，如果注册中心不需要验证可不填 2.0.0以上版本 password &amp;lt;password&amp;gt; string 可选 服务治理 登录注册中心密码，如果注册中心不需要验证可不填 2.</description></item><item><title>dubbo:registry</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-registry/</guid><description>注册中心配置。对应的配置类： org.apache.dubbo.config.RegistryConfig。同时如果有多个不同的注册中心，可以声明多个 &amp;lt;dubbo:registry&amp;gt; 标签，并在 &amp;lt;dubbo:service&amp;gt; 或 &amp;lt;dubbo:reference&amp;gt; 的 registry 属性指定使用的注册中心。
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 id string 可选 配置关联 注册中心引用BeanId，可以在&amp;lt;dubbo:service registry=&amp;quot;&amp;quot;&amp;gt;或&amp;lt;dubbo:reference registry=&amp;quot;&amp;quot;&amp;gt;中引用此ID 1.0.16以上版本 address &amp;lt;host:port&amp;gt; string 必填 服务发现 注册中心服务器地址，如果地址没有端口缺省为9090，同一集群内的多个地址用逗号分隔，如：ip:port,ip:port，不同集群的注册中心，请配置多个&amp;lt;dubbo:registry&amp;gt;标签 1.0.16以上版本 protocol &amp;lt;protocol&amp;gt; string 可选 dubbo 服务发现 注册中心地址协议，支持dubbo, multicast, zookeeper, redis, consul(2.7.1), sofa(2.7.2), etcd(2.7.2), nacos(2.7.2)等协议 2.0.0以上版本 port &amp;lt;port&amp;gt; int 可选 9090 服务发现 注册中心缺省端口，当address没有带端口时使用此端口做为缺省值 2.0.0以上版本 username &amp;lt;username&amp;gt; string 可选 服务治理 登录注册中心用户名，如果注册中心不需要验证可不填 2.0.0以上版本 password &amp;lt;password&amp;gt; string 可选 服务治理 登录注册中心密码，如果注册中心不需要验证可不填 2.0.0以上版本 transport registry.</description></item><item><title>dubbo:service</title><link>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/xml/dubbo-service/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
服务提供者暴露服务配置。对应的配置类：org.apache.dubbo.config.ServiceConfig
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 interface class 必填 服务发现 服务接口名 1.0.0以上版本 ref object 必填 服务发现 服务对象实现引用 1.0.0以上版本 version version string 可选 0.0.0 服务发现 服务版本，建议使用两位数字版本，如：1.0，通常在接口不兼容时版本号才需要升级 1.0.0以上版本 group group string 可选 服务发现 服务分组，当一个接口有多个实现，可以用分组区分 1.0.7以上版本 path &amp;lt;path&amp;gt; string 可选 缺省为接口名 服务发现 服务路径 (注意：1.0不支持自定义路径，总是使用接口名，如果有1.0调2.0，配置服务路径可能不兼容) 1.0.12以上版本 delay delay int 可选 0 性能调优 延迟注册服务时间(毫秒) ，设为-1时，表示延迟到Spring容器初始化完成时暴露服务 1.0.14以上版本 timeout timeout int 可选 1000 性能调优 远程服务调用超时时间(毫秒) 2.0.0以上版本 retries retries int 可选 2 性能调优 远程服务调用重试次数，不包括第一次调用，不需要重试请设为0 2.</description></item><item><title>dubbo:service</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/xml/dubbo-service/</guid><description>服务提供者暴露服务配置。对应的配置类：org.apache.dubbo.config.ServiceConfig
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 interface class 必填 服务发现 服务接口名 1.0.0以上版本 ref object 必填 服务发现 服务对象实现引用 1.0.0以上版本 version version string 可选 0.0.0 服务发现 服务版本，建议使用两位数字版本，如：1.0，通常在接口不兼容时版本号才需要升级 1.0.0以上版本 group group string 可选 服务发现 服务分组，当一个接口有多个实现，可以用分组区分 1.0.7以上版本 path &amp;lt;path&amp;gt; string 可选 缺省为接口名 服务发现 服务路径 (注意：1.0不支持自定义路径，总是使用接口名，如果有1.0调2.0，配置服务路径可能不兼容) 1.0.12以上版本 delay delay int 可选 0 性能调优 延迟注册服务时间(毫秒) ，设为-1时，表示延迟到Spring容器初始化完成时暴露服务 1.0.14以上版本 timeout timeout int 可选 1000 性能调优 远程服务调用超时时间(毫秒) 2.0.0以上版本 retries retries int 可选 2 性能调优 远程服务调用重试次数，不包括第一次调用，不需要重试请设为0 2.0.0以上版本 connections connections int 可选 100 性能调优 对每个提供者的最大连接数，rmi、http、hessian等短连接协议表示限制连接数，dubbo等长连接协表示建立的长连接个数 2.</description></item><item><title>使用 Java 接口方式开发 triple 通信服务</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/triple/interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/triple/interface/</guid><description>不同于谷歌官方 gRPC 实现，Dubbo 实现的 triple 协议易用性更好（不绑定 Protobuf），你可以继续使用 Java 接口 直接定义服务。对于期望平滑升级、没有多语言业务或者不熟悉 Protobuf 的用户而言，Java 接口方式是最简单的使用 triple 的方式。
以下是一个使用Java 接口开发 Dubbo 服务的基本示例，示例使用 triple 协议通信，可在此查看 本示例的完整代码。
注意 本文使用的示例是基于原生 API 编码的，这里还有一个 Spring Boot 版本的示例 供参考，同样是 Java接口+triple 的模式，此示例还额外加入了服务发现配置。 运行示例 首先，可通过以下命令下载示例源码
git clone --depth=1 https://github.com/apache/dubbo-samples.git 进入示例源码目录：
cd dubbo-samples/1-basic/dubbo-samples-api 启动Server 运行以下命令启动 server
mvn -Dexec.mainClass=org.apache.dubbo.samples.provider.Application exec:java 启动Client 有两种方式可以调用 server 发布的服务
使用标准的 http 工具，如 cURL 使用 Dubbo SDK 开发一个 client cURL curl \ --header &amp;#34;Content-Type: application/json&amp;#34; \ --data &amp;#39;[&amp;#34;Dubbo&amp;#34;]&amp;#39; \ http://localhost:50052/org.</description></item><item><title>Metrics</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/merics/meter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/merics/meter/</guid><description>概述 Dubbo Metrics 的总体设计请参考 可观测性 Metrics Proposal。
以下是 Dubbo Java 相关的具体实现与使用方式讲解。
使用方式 要为 Dubbo 进程开启指标采集，需要在项目中引入相关依赖并增加配置。以 Spring Boot 项目为例，增加以下 spring-boot-starter 依赖到项目中，即会自动开启指标采集。
&amp;lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo-metrics-prometheus --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-spring-boot-observability-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.2.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 完整示例请参见 dubbo-samples-metrics-spring-boot 完整配置参数请参见 Metrics 配置项手册 实现原理解析 代码结构与工作流程 移除原来与 Metrics 相关的类 创建新模块 dubbo-metrics/dubbo-metrics-api、dubbo-metrics/dubbo-metrics-prometheus，MetricsConfig 作为该模块的配置类 使用micrometer，在Collector中使用基本类型代表指标，如Long、Double等，并在dubbo-metrics-api中引入micrometer，由micrometer对内部指标进行转换 以下是 Dubbo 实现中的关键组件及数据流转过程
指标上报接口 根据上图架构，指标接口是 Dubbo 对外暴露指标数据的出口，以下是指标接口的具体定义：
另外，该 Service 还作为一些 智能自适应流量调度算法 的数据来源
public interface MetricsService { /** * Default {@link MetricsService} extension name. */ String DEFAULT_EXTENSION_NAME = &amp;#34;default&amp;#34;; /** * The contract version of {@link MetricsService}, the future update must make sure compatible.</description></item><item><title>Nacos 注册中心</title><link>https://dubbo.apache.org/zh-cn/docs/references/registry/nacos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/registry/nacos/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Nacos 是 Dubbo 生态系统中重要的注册中心实现，其中 dubbo-registry-nacos 则是 Dubbo 融合 Nacos 注册中心的实现。
预备工作 当您将 dubbo-registry-nacos 整合到您的 Dubbo 工程之前，请确保后台已经启动 Nacos 服务。如果您尚且不熟悉 Nacos 的基本使用的话，可先行参考 Nacos 快速入门。建议使用 Nacos 1.0.0 及以上的版本。
快速上手 Dubbo 融合 Nacos 成为注册中心的操作步骤非常简单，大致步骤可分为“增加 Maven 依赖”以及“配置注册中心“。
增加 Maven 依赖 首先，您需要将 dubbo-registry-nacos 的 Maven 依赖添加到您的项目 pom.xml 文件中，并且强烈地推荐您使用 Dubbo 2.6.5：
&amp;lt;dependencies&amp;gt; ... &amp;lt;!-- Dubbo Nacos registry dependency --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-registry-nacos&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.0.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- Keep latest Nacos client version --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.nacos&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;nacos-client&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;[0.6.1,)&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!</description></item><item><title>Nacos 注册中心</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/registry/nacos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/registry/nacos/</guid><description>Nacos 是 Dubbo 生态系统中重要的注册中心实现，其中 dubbo-registry-nacos 则是 Dubbo 融合 Nacos 注册中心的实现。
预备工作 当您将 dubbo-registry-nacos 整合到您的 Dubbo 工程之前，请确保后台已经启动 Nacos 服务。如果您尚且不熟悉 Nacos 的基本使用的话，可先行参考 Nacos 快速入门。建议使用 Nacos 1.0.0 及以上的版本。
快速上手 Dubbo 融合 Nacos 成为注册中心的操作步骤非常简单，大致步骤可分为“增加 Maven 依赖”以及“配置注册中心“。
增加 Maven 依赖 首先，您需要将 dubbo-registry-nacos 的 Maven 依赖添加到您的项目 pom.xml 文件中，并且强烈地推荐您使用 Dubbo 2.6.5：
&amp;lt;dependencies&amp;gt; ... &amp;lt;!-- Dubbo Nacos registry dependency --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-registry-nacos&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.0.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- Keep latest Nacos client version --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.nacos&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;nacos-client&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.6.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- Dubbo dependency --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.</description></item><item><title>使用 GraalVM 打包 Native Image</title><link>https://dubbo.apache.org/zh-cn/docs/references/graalvm/support-graalvm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/graalvm/support-graalvm/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
dubbo3.0支持native-image文档
概述 本文档将介绍将dubbo3.0项目接入GraalVM，进行native-image编译为二进制的流程。
关于GraalVm的更多信息可以阅读 https://www.graalvm.org/docs/getting-started/container-images/ 此文档。
使用样例 在编译我们的dubbo项目之前，需要确保我们正基于graalVm的环境。
安装GraalVM 进入https://www.graalvm.org/ 官网根据自己的系统选取最新版本安装：
安装完成后，修改配置JAVA_HOME的路径，生效后查看本地jdk可以看到如下：
这里我们使用的基于jdk1.8版本的GraalVM。
安装native-image，只需执行gu install native-image即可。 拉取dubbo代码，切换到apache:3.0分支。 手动执行生成SPI代码。 由于目前编译native-image不支持代码动态生成编译，所以有关代码动态生成的部分需要我们手动先生成，这里提供了工具函数：
执行CodeGenerator即可在dubbo-native模块下生成SPI代码。
在根目录下执行install MacdeMacBook-pro-3:incubator-dubbo mac$ pwd /Users/mac/Documents/Mi/project/incubator-dubbo MacdeMacBook-pro-3:incubator-dubbo mac$ mvn clean package install -Dmaven.test.skip=true 编译demo项目 这里我们提供了可直接进行编译的示例项目，dubbo-demo/dubbo-demo-native。上面步骤install完成后，先到dubbo-demo-native的provider下，执行native-image编译：
mvn clean package -P native -Dmaven.test.skip=true 这里由于我们在maven中引入了native-image插件，所以直接-P native即可执行该插件。
编译成功后可以在target下看到已经生成的二进制文件，本地启动一个zookeeper，直接执行该二进制，可见启动成功如下：
consumer端同样执行编译，在consumer的target下也会生成二进制文件：demo-native-consumer,执行该二进制可以看到调用结果如下：
具体步骤 实际上在这个demo下我们做了一些工作来确保项目可以编译执行，主要有以下几个步骤
引入dubbo-native依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-native&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${project.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 该模块下有我们生成的SPI代码。
引入native-image插件 &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.graalvm.nativeimage&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;native-image-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;21.0.0.2&amp;lt;/version&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;native-image&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;skip&amp;gt;false&amp;lt;/skip&amp;gt; &amp;lt;imageName&amp;gt;demo-native-provider&amp;lt;/imageName&amp;gt; &amp;lt;mainClass&amp;gt;org.</description></item><item><title>Pixiu Filter体系介绍</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/dev/filter-extension/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/dev/filter-extension/</guid><description>怎样编写一个Filter 更详细的信息，请移步Blog《谈谈Pixiu的Filter》
我们来尝试写一个简单的Filter，这个Filter将会有简单的配置，在Decode阶段把请求的Body Log出来，并翻转后作为Mock的返回值。最后在Encode阶段根据配置把返回值Log出来。
1.首先创建一个Filter
type DemoFilter struct { logPrefix string } // Decode阶段，发生在调用Upstream之前 func (f *DemoFilter) Decode(ctx *contexthttp.HttpContext) filter.FilterStatus { body, _ := ioutil.ReadAll(ctx.Request.Body) logger.Infof(&amp;#34;request body: %s&amp;#34;, body) //reverse res str runes := []rune(string(body)) for i := 0; i &amp;lt; len(runes)/2; i += 1 { runes[i], runes[len(runes)-1-i] = runes[len(runes)-1-i], runes[i] } reverse := string(runes) //mock response ctx.SendLocalReply(200, []byte(reverse)) return filter.Stop } // Encode阶段，此时可以获取到Upstream的Response func (f *DemoFilter) Encode(ctx *contexthttp.HttpContext) filter.FilterStatus { res := ctx.</description></item><item><title>Pixiu 是什么</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/overview/what-is-pixiu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/overview/what-is-pixiu/</guid><description>Pixiu 说明 Pixiu 是一款开源的 Dubbo 生态的 API 网关和 接入 dubbo 集群的语言解决方案。作为 API 网关形态， Pixiu 能接收外界的网络请求，将其转换为 dubbo 等协议请求，转发给背后集群；作为 Sidecar，Pixiu 期望可以代替代理服务注册到 Dubbo 集群，让多语言服务接入 Dubbo 集群提供更快捷的解决方案。
API 网关 作为一款网关产品，Pixiu 帮助用户轻松创建、发布、维护、监控和保护任意规模的 API ，接受和处理成千上万个并发 API 调用，包括流量管理、 CORS 支持、授权和访问控制、限制、监控，以及 API 版本管理。除此以外，作为 Dubbo 的衍生产品，Pixiu 可以帮助 Dubbo 用户进行协议转换，实现跨系统、跨协议的服务能力互通。 Pixiu 的整体设计遵守以下原则：
High performance: 高吞吐量以及毫秒级的延时。 可扩展: 通过 go-plugin，用户可以根据自己的需求延展 Pixiu 的功能。 简单可用: 用户通过少量配置，即可上线。 Sidecar 模式 目前最为主流的接入 dubbo 集群的方式当然是集成语言对应的 sdk，但是如图的左侧部分。但是对于dubbo来讲，它的多语言支持能力不足，目前较为成熟的只有 java 版本和 go 版本，当然 js 版本 和 python 版本也在努力追赶中.其次，就是使用sdk的通用问题，比如代码耦合度高，版本升级困难，服务发现，服务路由和负载均衡策略不易整体调控等。
所以 mesh 话或者 sidecar 的方案，也就是 service mesh 在16年时被提出。将服务发现，服务路由和负载均衡等逻辑放在 sidecar，服务使用轻量级 sdk 与之进行交互。</description></item><item><title>Prometheus</title><link>https://dubbo.apache.org/zh-cn/overview/reference/integrations/prometheus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/integrations/prometheus/</guid><description>安装 你可以使用 Dubbo 社区提供的示例配置快速安装 Prometheus。
kubectl create -f https://raw.githubusercontent.com/apache/dubbo-kubernetes/master/deploy/kubernetes/prometheus.yaml 本安装仅适用于测试或体验使用，生产级别的安装请参考 Prometheus 官方安装文档。
执行端口映射 kubectl -n dubbo-system port-forward svc/prometheus-server 9090:9090，访问页面 http://localhost:9090，切换到 graph 视图。
Scrape 配置 Dubbo 的每个实例都会暴露一个 http 端口用于 Metrics 采集，Prometheus 通过 scraping 每个实例的 http 接口来采集统计数据。具体的 scraping 路径可以通过 Prometheus 配置文件进行调整，该文件控制 scraping 实例的端口、路径、TLS 设置等。
Kubernetes 注解约定 在 Kubernetes 部署模式下，使用官方社区维护的 Helm Charts 安装 Prometheus，Prometheus 服务可以自动识别包含 prometheus.io 注解的 Dubbo Pod 实例，并将它们列入 Scraping 实例列表。
Dubbo 官网给出的示例即是基于 prometheus.io 注解实现了 scraping target 地址的自动发现，具体注解配置可参见示例中的 Deployment 资源定义。
annotations: prometheus.io/scrape: &amp;#34;true&amp;#34; prometheus.</description></item><item><title>如何在 triple 协议场景下使用 protobuf、json 序列化</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/triple/protobuf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/triple/protobuf/</guid><description>1 介绍 Protobuf（Protocol Buffers） 是由 Google 开发的一种轻量级、高效的数据交换格式，它被用于结构化数据的序列化、反序列化和传输。 相比于XML 和JSON 等文本格式，Protobuf 具有更小的数据体积、更快的解析速度和更强的可扩展性。
2 使用方式 在使用 Protobuf(IDL) 开发 triple 通信服务 的时候，dubbo server 将自动启用 protobuf、protobuf-json 序列化模式支持。
2.1 添加依赖 使用 triple + protobuf 模式，必须添加以下依赖：
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.google.protobuf&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;protobuf-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.19.6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 提供 protobuf-json 格式请求支持 --&amp;gt;&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.google.protobuf&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;protobuf-java-util&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.19.6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 2.2 配置启用 只要是基于 Protobuf(IDL) 开发模式进行 triple 协议通信 ，就会使用 protobuf 序列化，只要定义 protobuf 文件并启用 triple 协议即可。
当使用 cURL 访问 triple 服务时，是会启用 protobuf-json 序列化模式
curl \ --header &amp;#34;Content-Type: application/json&amp;#34; \ --data &amp;#39;{&amp;#34;name&amp;#34;:&amp;#34;Dubbo&amp;#34;}&amp;#39; \ http://localhost:50052/org.</description></item><item><title>QOS 概述</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/overview/</guid><description>如何使用 QoS 提供了一些启动参数，来对启动进行配置，他们主要包括：
参数 说明 默认值 qos-enable 是否启动QoS true qos-port 启动QoS绑定的端口 22222 qos-accept-foreign-ip 是否允许远程访问 false qos-accept-foreign-ip-whitelist 支持的远端主机ip地址（段） (无) qos-anonymous-access-permission-level 支持的匿名访问的权限级别 PUBLIC(1) 注意，从2.6.4/2.7.0开始，qos-accept-foreign-ip默认配置改为false，如果qos-accept-foreign-ip设置为true，有可能带来安全风险，请仔细评估后再打开。
telnet 与 http 协议 telnet 模块现在同时支持 http 协议和 telnet 协议，方便各种情况的使用 示例：
➜ ~ telnet localhost 22222 Trying ::1... telnet: connect to address ::1: Connection refused Trying 127.0.0.1... Connected to localhost. Escape character is &amp;#39;^]&amp;#39;. ████████▄ ███ █▄ ▀█████████▄ ▀█████████▄ ▄██████▄ ███ ▀███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ▄███▄▄▄██▀ ▄███▄▄▄██▀ ███ ███ ███ ███ ███ ███ ▀▀███▀▀▀██▄ ▀▀███▀▀▀██▄ ███ ███ ███ ███ ███ ███ ███ ██▄ ███ ██▄ ███ ███ ███ ▄███ ███ ███ ███ ███ ███ ███ ███ ███ ████████▀ ████████▀ ▄█████████▀ ▄█████████▀ ▀██████▀ dubbo&amp;gt;ls As Provider side: +----------------------------------+---+ | Provider Service Name |PUB| +----------------------------------+---+ |org.</description></item><item><title>Request Routing</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/bookinfo-proxyless/security/request-routing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/bookinfo-proxyless/security/request-routing/</guid><description>Before you begin Setup Istio by following the instructions in the Installation guide.
Deploy the Bookinfo sample application.
Review the Traffic Management concepts doc.
About this task The Istio Bookinfo sample consists of four separate microservices, each with multiple versions. Three different versions of one of the microservices, reviews, have been deployed and are running concurrently. To illustrate the problem this causes, access the Bookinfo app’s /productpage in a browser and refresh several times.</description></item><item><title>Request Routing</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/bookinfo-proxyless/traffic/request-routing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/bookinfo-proxyless/traffic/request-routing/</guid><description>Before you begin Setup Istio by following the instructions in the Installation guide.
Deploy the Bookinfo sample application.
Review the Traffic Management concepts doc.
About this task The Istio Bookinfo sample consists of four separate microservices, each with multiple versions. Three different versions of one of the microservices, reviews, have been deployed and are running concurrently. To illustrate the problem this causes, access the Bookinfo app’s /productpage in a browser and refresh several times.</description></item><item><title>Request Routing</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/bookinfo-sidecar/security/request-routing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/bookinfo-sidecar/security/request-routing/</guid><description>Before you begin Setup Istio by following the instructions in the Installation guide.
Deploy the Bookinfo sample application.
Review the Traffic Management concepts doc.
About this task The Istio Bookinfo sample consists of four separate microservices, each with multiple versions. Three different versions of one of the microservices, reviews, have been deployed and are running concurrently. To illustrate the problem this causes, access the Bookinfo app’s /productpage in a browser and refresh several times.</description></item><item><title>Request Routing</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/bookinfo-sidecar/traffic/request-routing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/bookinfo-sidecar/traffic/request-routing/</guid><description>Before you begin Setup Istio by following the instructions in the Installation guide.
Deploy the Bookinfo sample application.
Review the Traffic Management concepts doc.
About this task The Istio Bookinfo sample consists of four separate microservices, each with multiple versions. Three different versions of one of the microservices, reviews, have been deployed and are running concurrently. To illustrate the problem this causes, access the Bookinfo app’s /productpage in a browser and refresh several times.</description></item><item><title>Rest 协议</title><link>https://dubbo.apache.org/zh-cn/overview/reference/proposals/protocol-http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/proposals/protocol-http/</guid><description>本文将介绍 Dubbo 的 REST/HTTP 协议设计。
RestProtocol 设计 原版本dubbo rest consumer
restClient支持 依赖resteasy 不支持spring mvc provider(较重)
依赖web container (tomcat,jetty，)servlet 模式，jaxrs netty server
新版本dubbo rest 更加轻量，具有dubbo风格的rest，微服务体系互通（Springcloud Alibaba）
1.注解解析
2.报文编解码
3.restClient
4.restServer(netty)
支持程度：
content-type text json xml form(后续会扩展)
注解
param,header,body,pathvaribale （spring mvc &amp;amp; resteasy）
Http 协议报文 POST /test/path? HTTP/1.1 Host: localhost:8080 Connection: keep-alive Content-type: application/json {&amp;quot;name&amp;quot;:&amp;quot;dubbo&amp;quot;,&amp;quot;age&amp;quot;:10,&amp;quot;address&amp;quot;:&amp;quot;hangzhou&amp;quot;} dubbo http(header) // service key header path: com.demo.TestInterface group: demo port: 80 version: 1.0.0 // 保证长连接 Keep-Alive,Connection: keep-alive Keep-alive: 60 // RPCContext Attachment userId: 123456 支持粒度 数据位置 content-type spring注解 resteasy注解 body 无要求 ReuqestBody 无注解即为body querystring(?</description></item><item><title>RPC 协议 Triple&amp;Dubbo 基准测试</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/performance/rpc-benchmarking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/performance/rpc-benchmarking/</guid><description>Dubbo3 的 _Dubbo协议 _实现与 Dubbo2 版本在性能上基本持平。 由于 Triple协议 本身是基于 HTTP/2 构建，因此在单条链路上的 RPC 调用并未比基于 TCP 的 Dubbo2 有提升，反而在某些调用场景出现一定下降。但 _Triple协议 _更大的优势在于网关穿透性、通用性，以及 Stream 通信模型带来的总体吞吐量提升。 Triple 预期在网关代理场景下一定会有更好的性能表现，鉴于当前压测环境，本轮 benchmark 暂未提供。 1.1 环境 描述 机器 4C8G Linux JDK 1.8（Provider）4C8G Linux JDK 1.8 （Consumer） 压测用例 RPC 方法类型包括：无参无返回值、普通pojo返回值、pojo列表返回值
2.7 版本 Dubbo 协议（Hessian2 序列化）
3.0 版本 Dubbo 协议（Hessian2 序列化）
3.0 版本 Dubbo 协议（Protobuf 序列化）
3.0 版本 Triple 协议（Protobuf 序列化）
3.0 版本 Triple 协议（Protobuf 套 Hessian2 序列化） 压测方法 单链接场景下，消费端起 32 并发线程（当前机器配置 qps rt 较均衡的并发数），持续压后采集压测数据</description></item><item><title>RPC 基准测试 控制台</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/performance/page-benchmarking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/performance/page-benchmarking/</guid><description> dubbo-benchmark We're sorry but dubbo-benchmark doesn't work properly without JavaScript enabled. Please enable it to continue.</description></item><item><title>Seata分布式事务</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/transaction/seata/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/transaction/seata/</guid><description>先执行以下命令，启动 seata-server。
cd ../dockercompose docker-compose -f docker-compose.yml up -d seata-server 再执行 triple/client/cmd 和 triple/server/cmd 目录下的 main()方法。
完整示例源码地址</description></item><item><title>使用 Sentinel 应对突发流量，保护您的应用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/rate-limit/sentinel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/rate-limit/sentinel/</guid><description>在复杂的生产环境下可能部署着成千上万的 Dubbo 服务实例，流量持续不断地进入，服务之间进行相互调用。但是分布式系统中可能会因流量激增、系统负载过高、网络延迟等一系列问题，导致某些服务不可用，如果不进行相应的控制可能导致级联故障，影响服务的可用性，因此如何对流量进行合理的控制，成为保障服务稳定性的关键。
Sentinel 是阿里中间件团队开源的，面向分布式服务架构的轻量级流量控制产品，主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户保护服务的稳定性。
本文提供 Dubbo 整合 Sentinel 限流降级的最佳实践。
快速接入 Sentinel Sentinel 通过对服务提供方和服务消费方的限流提升服务在极端场景下的可用性，接下来我们看看 Sentinel 对服务提供方和服务消费方限流的技术实现方式。
使用时我们只需引入以下模块（以 Maven 为例）：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.csp&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;sentinel-apache-dubbo3-adapter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.8.6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- optional --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.csp&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;sentinel-transport-simple-http&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.8.6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 引入此依赖后，Dubbo 的服务接口和方法（包括调用端和服务端）就会成为 Sentinel 中的资源，在配置了规则后就可以自动享受到 Sentinel 的防护能力。
sentinel-apache-dubbo3-adapter 中包含 Sentinel Filter 实现，加入依赖之后会自动开启。如若不希望开启 Sentinel Dubbo Adapter 中的某个 Filter，可通过配置关闭，如 dubbo.provider.filter=&amp;quot;-sentinel.dubbo.consumer.filter&amp;quot;。
示例详解 可在此查看以下 示例的完整源码。
Provider 端限流 对服务提供方的流量控制可分为 服务提供方的自我保护能力 和 服务提供方对服务消费方的请求分配能力 两个维度。
基于 QPS 设定限流 为了保护 Provider 不被激增的流量拖垮影响稳定性，可以给 Provider 配置 QPS 模式 的限流，这样当每秒的请求量超过设定的阈值时会自动拒绝多出来的请求。</description></item><item><title>使用轻量的 Java SDK 开发 RPC Server 和 Client</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/lightweight-rpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/lightweight-rpc/</guid><description>本示例演示如何使用轻量 Dubbo SDK 开发 RPC Server 与 Client，示例使用 Java Interface 方式定义、发布和访问 RPC 服务，底层使用 Triple 协议通信。本示例完整代码请参见 dubbo-samples。
基于 Dubbo 定义的 Triple 协议，你可以轻松编写浏览器、gRPC 兼容的 RPC 服务，并让这些服务同时运行在 HTTP/1 和 HTTP/2 上。Dubbo Java SDK 支持使用 IDL 或编程语言特有的方式定义服务，并提供一套轻量的 API 来发布或调用这些服务。
Maven 依赖 在基于 Dubbo RPC 编码之前，您只需要在项目添加一个非常轻量的 dubbo依赖包即可，以 Maven 为例：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0-beta.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 为了避免 Netty 依赖冲突，您也可以是选择使用 dubbo-shaded 版本！--&amp;gt; &amp;lt;!-- &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-shaded&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0-beta.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; --&amp;gt; 定义服务 定义一个名为 DemoService的标准 Java 接口作为 Dubbo 服务（Dubbo 还支持基于 IDL 的服务定义模式）。</description></item><item><title>Dubbo SPI 概述</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/overview/</guid><description>使用 IoC 容器帮助管理组件的生命周期、依赖关系注入等是很多开发框架的常用设计，Dubbo 中内置了一个轻量版本的 IoC 容器，用来管理框架内部的插件，实现包括插件实例化、生命周期、依赖关系自动注入等能力。
感兴趣的读者可以了解：
Dubbo SPI 扩展体系的工作原理 Dubbo SPI 扩展使用示例 Dubbo 插件体系与 IoC 容器具有以下特点：
核心组件均被定义为插件，用户或二次开发者扩展非常简单。 在无需改造框架内核的情况下，用户可以基于自身需求扩展如负载均衡、注册中心、通信协议、路由等策略。 平等对待第三方扩展实现。 Dubbo 中所有内部实现和第三方实现都是平等的，用户可以基于自身业务需求替换 Dubbo 提供的原生实现。 插件依赖支持自动注入（IoC）。 如果插件实现依赖其他插件属性，则 Dubbo 框架会完成该依赖对象的自动注入，支持属性、构造函数等方式。 插件扩展实现支持 AOP 能力。 框架可以自动发现扩展类的包装类，通过包装器模式对插件进行 AOP 增强。 支持插件自动激活。 通过为插件实现指定激活条件（通过注解参数等），框架可在运行时自动根据当前上下文决策是否激活该插件实现。 支持插件扩展排序。</description></item><item><title>Spring Boot</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/develop/springboot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/develop/springboot/</guid><description>Dubbo 提供了对 Spring 框架的完整支持，我们推荐使用官方提供的 dubbo-spring-boot-starter 高效开发 Dubbo 微服务应用。
创建项目 创建 Dubbo 应用最快捷的方式就是使用官方项目脚手架工具 - start.dubbo.apache.org 在线服务。它可以帮助开发者创建 Spring Boot 结构应用，自动管理 dubbo-spring-boot-starter 等依赖和必要配置。
另外，Jetbrain 官方也提供了 Apache Dubbo 项目插件，可用于快速创建 Dubbo Spring Boot 项目，能力与 start.dubbo.apache.org 对等，具体安装使用请查看 博客文章
dubbo-spring-boot-starter 在 快速开始 中，我们已经详细介绍了典型的 Dubbo Spring Boot 工程源码及其项目结构，不熟悉的开发者可以前往查看。
dubbo-spring-boot-starter 可为项目引入 dubbo 核心依赖，自动扫描 dubbo 相关配置与注解。
Maven 依赖 使用 Dubbo Spring Boot Starter，首先引入以下 Maven 依赖
&amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-bom&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0-beta.1&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; 然后，在相应模块的 pom 中增加必要的 starter 依赖：</description></item><item><title>Triple 协议设计理念与规范</title><link>https://dubbo.apache.org/zh-cn/overview/reference/protocols/triple-spec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/protocols/triple-spec/</guid><description>1 协议设计理念 Triple 协议的设计参考了 gRPC、gRPC-Web、通用 HTTP 等多种协议模式，吸取每个协议各自的特性和优点，最终设计成为一个易于浏览器访问、完全兼容 gRPC 且支持 Streaming 通信的协议，Triple 支持同时运行在 HTTP/1、HTTP/2 协议之上。
Triple 协议的设计目标如下：
Triple 设计为对人类、开发调试友好的一款基于 HTTP 的协议，尤其是对 unary 类型的 RPC 请求。 完全兼容基于 HTTP/2 的 gRPC 协议，因此 Dubbo Triple 协议实现可以 100% 与 gRPC 体系互调互通。 仅依赖标准的、被广泛使用的 HTTP 特性，以便在实现层面可以直接依赖官方的标准 HTTP 网络库。 当与 Protocol Buffers 一起使用时（即使用 IDL 定义服务），Triple 协议可支持 unary、client-streaming、server-streaming 和 bi-streaming RPC 通信模式，支持二进制 Protobuf、JSON 两种数据格式 payload。 Triple 实现并不绑定 Protocol Buffers，比如你可以使用 Java 接口定义服务，Triple 协议有对这种模式的扩展 Content-type 支持。
2 示例 2.1 Unary 请求 以 HTTP/1 请求为例，目前 HTTP/1 协议仅支持 Unary RPC，支持使用 application/proto 和 application/json 编码类型，使用方式与 REST 风格请求保持一致，同时响应也包含常规的 HTTP 响应编码（如 200 OK）。</description></item><item><title>Triple 协议优势与目标</title><link>https://dubbo.apache.org/zh-cn/overview/reference/protocols/triple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/protocols/triple/</guid><description>简介 Triple 协议是 Dubbo3 设计的基于 HTTP 的 RPC 通信协议规范，它完全兼容 gRPC 协议，支持 Request-Response、Streaming 流式等通信模型，可同时运行在 HTTP/1 和 HTTP/2 之上。
Dubbo 框架提供了 Triple 协议的多种语言实现，它们可以帮助你构建浏览器、gRPC 兼容的 HTTP API 接口：你只需要定义一个标准的 Protocol Buffer 格式的服务并实现业务逻辑，Dubbo 负责帮助生成语言相关的 Server Stub、Client Stub，并将整个调用流程无缝接入如路由、服务发现等 Dubbo 体系。Go、Java 等语言的 Triple 协议实现原生支持 HTTP/1 传输层通信，相比于 gRPC 官方实现，Dubbo 框架提供的协议实现更简单、更稳定，帮助你更容易的开发和治理微服务应用。
针对某些语言版本，Dubbo 框架还提供了更贴合语言特性的编程模式，即不绑定 IDL 的服务定义与开发模式，比如在 Dubbo Java 中，你可以选择使用 Java Interface 和 Pojo 类定义 Dubbo 服务，并将其发布为基于 Triple 协议通信的微服务。
协议规范(Specification) 基于 Triple 协议，你可以实现以下目标：
当 Dubbo 作为 Client 时 Dubbo Client 可以访问 Dubbo 服务端 (Server) 发布的 Triple 协议服务，同时还可以访问标准的 gRPC 服务端。</description></item><item><title>Web 浏览器访问 Dubbo 服务</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/web-sdk/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/web-sdk/quick-start/</guid><description>基于 Dubbo3 定义的 Triple 协议，你可以轻松编写浏览器、gRPC 兼容的 RPC 服务，并让这些服务同时运行在 HTTP/1 和 HTTP/2 上。Dubbo TypeScript SDK 支持使用 IDL 或编程语言特有的方式定义服务，并提供一套轻量的 API 来发布或调用这些服务。
Dubbo-js 已于 9 月份发布支持 Dubbo3 协议的首个 alpha 版本，它的发布将有机会彻底改变微服务前后端的架构与通信模式，让你能直接在浏览器页面或web服务器中访问后端 Dubbo RPC 服务。
浏览器 Web 应用示例 本示例演示了如何使用 dubbo-js 开发运行在浏览器上的 web 应用程序，web 页面将调用 dubbo node.js 开发的后端服务并生成页面内容。本示例演示基于 IDL 和非 IDL 两种编码模式。
IDL 模式 前置条件 首先，我们将使用 Vite 来生成我们的前端项目模板，它内置了我们稍后需要的所有功能支持。
npm create vite@latest -- dubbo-web-example --template react-ts cd dubbo-web-example npm install 因为使用 Protocol Buffer 的原因，我们首先需要安装相关的代码生成工具，这包括 @bufbuild/protoc-gen-es、@bufbuild/protobuf、@apachedubbo/protoc-gen-apache-dubbo-es、@apachedubbo/dubbo。
npm install @bufbuild/protoc-gen-es @bufbuild/protobuf @apachedubbo/protoc-gen-apache-dubbo-es @apachedubbo/dubbo 使用 Proto 定义服务 现在，使用 Protocol Buffer (IDL) 来定义一个 Dubbo 服务。</description></item><item><title>XML 配置</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/configuration/xml/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/configuration/xml/</guid><description>有关 XML 的详细配置项，请参见：配置参考手册。如果不想使用 Spring 配置，而希望通过 API 的方式进行调用，请参见：API配置。想知道如何使用配置，请参见：快速启动。
请在此查看文档描述的完整示例
provider.xml 示例 &amp;lt;beans xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;dubbo:application name=&amp;#34;demo-provider&amp;#34;/&amp;gt; &amp;lt;dubbo:registry address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;20890&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;demoService&amp;#34; class=&amp;#34;org.apache.dubbo.samples.basic.impl.DemoServiceImpl&amp;#34;/&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;org.apache.dubbo.samples.basic.api.DemoService&amp;#34; ref=&amp;#34;demoService&amp;#34;/&amp;gt; &amp;lt;/beans&amp;gt; consumer.xml示例 &amp;lt;beans xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;dubbo:application name=&amp;#34;demo-consumer&amp;#34;/&amp;gt; &amp;lt;dubbo:registry group=&amp;#34;aaa&amp;#34; address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; &amp;lt;dubbo:reference id=&amp;#34;demoService&amp;#34; check=&amp;#34;false&amp;#34; interface=&amp;#34;org.apache.dubbo.samples.basic.api.DemoService&amp;#34;/&amp;gt; &amp;lt;/beans&amp;gt; 所有标签都支持自定义参数，用于不同扩展点实现的特殊配置，如：
&amp;lt;dubbo:protocol name=&amp;#34;jms&amp;#34;&amp;gt; &amp;lt;dubbo:parameter key=&amp;#34;queue&amp;#34; value=&amp;#34;your_queue&amp;#34; /&amp;gt; &amp;lt;/dubbo:protocol&amp;gt; 或： 1
&amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xmlns:p=&amp;#34;http://www.springframework.org/schema/p&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;dubbo:protocol name=&amp;#34;jms&amp;#34; p:queue=&amp;#34;your_queue&amp;#34; /&amp;gt; &amp;lt;/beans&amp;gt; 配置之间的关系 标签 用途 解释 &amp;lt;dubbo:service/&amp;gt; 服务配置 用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心 &amp;lt;dubbo:reference/&amp;gt; 2 引用配置 用于创建一个远程服务代理，一个引用可以指向多个注册中心 &amp;lt;dubbo:protocol/&amp;gt; 协议配置 用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受 &amp;lt;dubbo:application/&amp;gt; 应用配置 用于配置当前应用信息，不管该应用是提供者还是消费者 &amp;lt;dubbo:module/&amp;gt; 模块配置 用于配置当前模块信息，可选 &amp;lt;dubbo:registry/&amp;gt; 注册中心配置 用于配置连接注册中心相关信息 &amp;lt;dubbo:monitor/&amp;gt; 监控中心配置 用于配置连接监控中心相关信息，可选 &amp;lt;dubbo:provider/&amp;gt; 提供方配置 当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选 &amp;lt;dubbo:consumer/&amp;gt; 消费方配置 当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选 &amp;lt;dubbo:method/&amp;gt; 方法配置 用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息 &amp;lt;dubbo:argument/&amp;gt; 参数配置 用于指定方法参数配置 不同粒度配置的覆盖关系 以 timeout 为例，下图显示了配置的查找顺序，其它 retries, loadbalance, actives 等类似：</description></item><item><title>Zookeeper 注册中心</title><link>https://dubbo.apache.org/zh-cn/docs/references/registry/zookeeper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/registry/zookeeper/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Zookeeper 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用 1。
流程说明：
服务提供者启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址 服务消费者启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址 监控中心启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址。 支持以下功能：
当提供者出现断电等异常停机时，注册中心能自动删除提供者信息 当注册中心重启时，能自动恢复注册数据，以及订阅请求 当会话过期时，能自动恢复注册数据，以及订阅请求 当设置 &amp;lt;dubbo:registry check=&amp;quot;false&amp;quot; /&amp;gt; 时，记录失败注册和订阅请求，后台定时重试 可通过 &amp;lt;dubbo:registry username=&amp;quot;admin&amp;quot; password=&amp;quot;1234&amp;quot; /&amp;gt; 设置 zookeeper 登录信息 可通过 &amp;lt;dubbo:registry group=&amp;quot;dubbo&amp;quot; /&amp;gt; 设置 zookeeper 的根节点，不配置将使用默认的根节点。 支持 * 号通配符 &amp;lt;dubbo:reference group=&amp;quot;*&amp;quot; version=&amp;quot;*&amp;quot; /&amp;gt;，可订阅服务的所有分组和所有版本的提供者 使用 在 provider 和 consumer 中增加 zookeeper 客户端 jar 包依赖：</description></item><item><title>Zookeeper 注册中心</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/registry/zookeeper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/registry/zookeeper/</guid><description>Zookeeper 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用 1。
流程说明：
服务提供者启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址 服务消费者启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址 监控中心启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址。 支持以下功能：
当提供者出现断电等异常停机时，注册中心能自动删除提供者信息 当注册中心重启时，能自动恢复注册数据，以及订阅请求 当会话过期时，能自动恢复注册数据，以及订阅请求 当设置 &amp;lt;dubbo:registry check=&amp;quot;false&amp;quot; /&amp;gt; 时，记录失败注册和订阅请求，后台定时重试 可通过 &amp;lt;dubbo:registry username=&amp;quot;admin&amp;quot; password=&amp;quot;1234&amp;quot; /&amp;gt; 设置 zookeeper 登录信息 可通过 &amp;lt;dubbo:registry group=&amp;quot;dubbo&amp;quot; /&amp;gt; 设置 zookeeper 的根节点，不配置将使用默认的根节点。 支持 * 号通配符 &amp;lt;dubbo:reference group=&amp;quot;*&amp;quot; version=&amp;quot;*&amp;quot; /&amp;gt;，可订阅服务的所有分组和所有版本的提供者 使用 在 provider 和 consumer 中增加 zookeeper 客户端 jar 包依赖：</description></item><item><title>版本信息</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/versions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/versions/</guid><description>推荐版本 当前网站文档适用于以下版本，如果您正使用 dubbo-go 其他版本，请参考对应历史版本文档。
Go Dubbo-go protoc-gen-go-triple 说明 1.20 v3.2.0-rc1（当前文档） v3.0.0 当前最新稳定版本，推荐使用 历史版本 3.x 查看 3.1.x 及之前版本文档：
Go Dubbo-go protoc-gen-go-triple 说明 1.16 v3.1.1 v3.0.0 请参考 README 说明，了解如何生成老版本兼容的服务 stub 代码 1.16 v3.1.0 v3.0.0 请参考 README 说明，了解如何生成老版本兼容的服务 stub 代码 1.16 v3.0.4 v3.0.0 请参考 README 说明，了解如何生成老版本兼容的服务 stub 代码 1.16 v3.0.3 v3.0.0 请参考 README 说明，了解如何生成老版本兼容的服务 stub 代码 1.16 v3.0.2 v3.0.0 请参考 README 说明，了解如何生成老版本兼容的服务 stub 代码 1.16 v3.0.1 v3.0.0 请参考 README 说明，了解如何生成老版本兼容的服务 stub 代码 1.16 v3.</description></item><item><title>版本信息</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/versions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/versions/</guid><description>我们提供了不同版本的 Dubbo Java 实现文档，您可以在下方版本列表中选择不同的版本文档，查看每个版本的维护情况、组件版本、升级注意事项等。
版本说明 Dubbo 分支 最新版本 JDK Spring Boot 组件版本 详细说明 3.3.x (当前文档) 3.3.0 8, 17, 21 2.x、3.x 详情 - 版本变更记录 - 生产可用（推荐，长期维护）！ 最新Triple协议升级，内置Metrics、Tracing、GraalVM支持等 3.2.x 3.2.10 8, 17 2.x、3.x 详情 - 版本变更记录 - 生产可用（长期维护）！ 3.1.x 3.1.11 8, 17 2.x、3.x 详情 - 版本变更记录 - 仅修复安全漏洞！ 3.0.x 3.0.15 8 2.x 详情 - 版本变更记录 - 停止维护！ 2.7.x 2.7.23 8 2.x 详情 - 了解如何升级到Dubbo3 - 停止维护！ 2.6.x 2.6.20 6, 7 - _ - 了解如何升级到Dubbo3 - 停止维护！ 2.</description></item><item><title>背景</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/preface/background/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/preface/background/</guid><description>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。
单一应用架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。
垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。
分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。
流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</description></item><item><title>使用 dubbogo.yml 配置文件开发应用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/configuration/file/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/configuration/file/</guid><description>1.介绍 本文档演示如何在框架中使用 yaml 配置文件进行微服务开发，是相比于 API 的另一种微服务开发模式。你可以完全使用 yml 配置文件进行开发，也可以将部分全局配置放到配置文件，而只在 API 中完成服务定义。
这种模式下，一定要通过 DUBBO_GO_CONFIG_PATH 指定配置文件路径：
export DUBBO_GO_CONFIG_PATH=&amp;#34;../conf/dubbogo.yml&amp;#34; 2. 使用说明 可在此查看 完整示例源码。
2.1 运行示例 . ├── go-client │ ├── cmd │ │ └── main.go │ └── conf │ └── dubbogo.yml ├── go-server │ ├── cmd │ │ └── main.go │ └── conf │ └── dubbogo.yml └─── proto ├── greet.pb.go ├── greet.proto └── greet.triple.go 通过 IDL./proto/greet.proto 定义服务 使用triple协议
build Proto cd path_to_dubbogo-sample/config_yaml/proto protoc --go_out=. --go-triple_out=.</description></item><item><title>Dubbo 框架标准监控指标</title><link>https://dubbo.apache.org/zh-cn/overview/reference/metrics/standard_metrics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/metrics/standard_metrics/</guid><description>Dubbo 指标含义 Provider Metrics Metrics Name Description 说明 dubbo_provider_qps_total The number of requests received by the provider per second 提供者每秒接收的请求数 dubbo_provider_requests_total The total number of received requests by the provider 提供者总的接收请求数 dubbo_provider_requests_total_aggregate The total number of received requests by the provider under the sliding window 滑动窗口下的提供者总的接收请求数 dubbo_provider_requests_processing The number of received requests being processed by the provider 提供者正在处理的接收的请求数 dubbo_provider_requests_succeed_total The number of requests successfully received by the provider 提供者请求成功接收的请求数 dubbo_provider_requests_succeed_aggregate The number of successful requests received by the provider under the sliding window 滑动窗口下的提供者成功的接收请求数 dubbo_provider_rt_milliseconds_min The minimum response time among all requests processed by the provider 提供者所有处理请求中最小的响应时间 dubbo_provider_rt_min_milliseconds_aggregate The minimum response time of the provider under the sliding window 滑动窗口下的提供者最小响应时间 dubbo_provider_rt_milliseconds_avg The average response time of all requests processed by the provider 提供者所有处理请求的平均响应时间 dubbo_provider_rt_avg_milliseconds_aggregate The average response time of the provider under the sliding window 滑动窗口下的提供者平均响应时间 dubbo_provider_rt_milliseconds_sum The total time taken by the provider to process all requests 提供者所有处理请求的时间总和 dubbo_provider_rt_milliseconds_max The maximum response time among all requests from the provider 提供者所有请求中最大的响应时间 dubbo_provider_rt_max_milliseconds_aggregate The maximum response time of the provider under the sliding window 滑动窗口下的提供者最大响应时间 dubbo_provider_rt_milliseconds_last The current response time in the provider&amp;rsquo;s processing of requests 提供者处理请求中当前的响应时间 dubbo_provider_rt_milliseconds_p50 The total response time spent by providers processing 50% of requests 提供者处理请求中50%的请求耗费的总响应时间 dubbo_provider_rt_milliseconds_p90 The total response time spent by providers processing 90% of requests 提供者处理请求中90%的请求耗费的总响应时间 dubbo_provider_rt_milliseconds_p95 The total response time spent by providers processing 95% of requests 提供者处理请求中95%的请求耗费的总响应时间 dubbo_provider_rt_milliseconds_p99 The total response time spent by providers processing 99% of requests 提供者处理请求中99%的请求耗费的总响应时间 dubbo_provider_requests_processing_total The number of received requests being processed by the provider 提供者正在处理的接收的请求数 dubbo_provider_rt_milliseconds_histogram_seconds_bucket The histogram of response time of the provider under the sliding window 滑动窗口下的提供者响应时间直方图 dubbo_provider_rt_milliseconds_histogram_seconds_count The count of histogram of response time of the provider under the sliding window 滑动窗口下的提供者响应时间直方图总数 dubbo_provider_rt_milliseconds_histogram_seconds_max The max of histogram of response time of the provider under the sliding window 滑动窗口下的提供者响应时间直方图最大值 dubbo_provider_rt_milliseconds_histogram_seconds_sum The sum of histogram of response time of the provider under the sliding window 滑动窗口下的提供者响应时间直方图总和 dubbo_provider_requests_business_failed_total Total Failed Business Requests 当RPC请求异常状态码为 RpcException.</description></item><item><title>部署 Istio 环境</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/deploy2/istio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/deploy2/istio/</guid><description>1. 准备工作 docker、helm、kubectl 环境已安装。 dubbo-go cli 工具和依赖工具已安装 2. 部署 Istio 环境 使用helm 安装 istio 基础 CRD 和 istiod 组件。也可以参考 Istio 文档 使用 istioctl 安装。 $ helm repo add istio https://istio-release.storage.googleapis.com/charts $ kubectl create namespace istio-system $ helm install istio-base istio/base -n istio-system $ helm install istiod istio/istiod --namespace istio-system 删除istio 水平扩展资源
*目前 dubbo-go 依赖单个 istiod 实例进行服务发现。
$ kubectl delete hpa istiod -n istio-system 安装完成后，可以在 istio-system 命名空间下看到一个 istiod pod 在正常运行。</description></item><item><title>如何成为 Dubbo Committer</title><link>https://dubbo.apache.org/zh-cn/contact/contributor/become-a-committer_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/contact/contributor/become-a-committer_dev/</guid><description>每个人都可以成为 Apache 项目的贡献者。作为一个贡献者只是意味着你对项目感兴趣并以某种方式做出贡献，从提出合理的问题（这些问题记录了项目并向开发人员提供反馈）到提供新的特性作为补丁。
如果你成为对一个项目有价值的贡献者，你有可能被邀请成为一个 Committer。Committer 是 ASF（Apache 软件基金会）中用来表示提交特定项目的人的术语。它给你带来对项目仓库和资源写的权限。
在 Dubbo 社区，如果一个 Committer 获得大量的优秀成绩，就可以被邀请加入项目管理委员会（PMC）。
当您不熟悉ASF使用的开源的开发过程时，有时难以理解的一点，就是我们更重视社区而不是代码。一个强大而健康的社区将受到尊重，成为一个有趣和有益的地方。更重要的是，一个多元化和健康的社区可以长时间的持续支持代码，即使个别公司在这个领域来来往往，也是如此。
更多详细信息可以在 这里 找到。
我可以贡献什么？ 请参阅新的贡献者指南。</description></item><item><title>传统基于 Zookeeper、Nacos 的注册中心部署架构，部署 Dubbo 应用到虚拟机环境</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/deploy/deploy-on-vm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/deploy/deploy-on-vm/</guid><description>下图是使用 Nacos、Zookeeper 作为注册中心的典型 Dubbo 微服务部署架构。
安装 Nacos 请参考以下文档了解如何在本地 安装 Nacos。
部署应用 我们仍然以 快速开始 中的项目为例，演示应用打包部署的具体步骤。
克隆示例项目到本地：
$ git clone -b main --depth 1 https://github.com/apache/dubbo-samples 切换到示例目录：
$ cd dubbo-samples/11-quickstart 以下是两种打包部署模式：
方式一：本地进程 本地打包进程：
$ mvn clean package 启动 Dubbo 进程：
$ java -jar ./quickstart-service/target/quickstart-service-0.0.1-SNAPSHOT.jar 提示 为了程序正常运行，请确保 application.yml 文件中的注册中心地址已经正确指向你想要的注册中心。 方式二：docker容器 $ docker build -f ./Dockerfile -t quickstart $ docker run quickstart -p port1:port2 # 对于一些端口或连接注册中心的细节要写清楚 提示 Docker 容器环境下，不同容器间用于网络通信的地址需要特别关注，因此你可能需要设置 Dubbo 进程监听或者注册到注册中心的地址，请参考以下链接了解更多内容。
见 dubbo 通过环境变量设置 host</description></item><item><title>单端口多协议实现原理解析</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-protocol/</guid><description>通过对protocol进行配置，dubbo3可以支持端口的协议复用。 比如使用Triple协议启动端口复用后，可以在相同的端口上为服务增加 Dubbo协议支持，以及Qos协议支持。这些协议的识别都是由一个统一的端口复用 服务器进行处理的，可以用于服务的协议迁移，并且可以节约端口以及相关的资源，减少运维的复杂性。
在服务的创建阶段，通过从Config层获取到服务导出的协议配置从而创建不同的Protocol对象进行导出。在导出的过程 中，如果不是第一次创建端口复用的Server，那么Exchanger会将Protcol层传递的数据保存到Server，用于后续处理该协议类型的消息。
当客户端的消息传递过来后，首先会通过Server传递给ProtocolDetector，如果完成了识别，那么就会标记该客户端为对应的协议。并通过WireProtocol配置对应的处理逻辑，最后交给ChannelOperator完成底层的IO框架和对应的Dubbo框架的处理逻辑的绑定。
以上的协议识别完成之后，Channel已经确定了如何处理远程的客户端消息，通过对应的ServerPipeline进行处理即可（在处理的过程中也会根据配置信息决定消息的处理线程）。
使用场景 最常用的是用于服务发现。这允许应用程序通过网络发现服务，然后使用同一端口与它们通信，有助于降低网络通信的复杂性，并使其更易于管理。
可以用于负载平衡。这允许应用程序在多个远程服务或服务集群之间平衡负载，有助于提高服务的可扩展性、可靠性和可用性。
可以用于服务监控。这允许应用程序监视远程服务的运行状况，并在服务出现故障或变得不可用时发出警报，有助于确保服务的可用性并减少停机时间。
参考用例 https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-port-unification
使用方式 在同一主机上部署多个服务或需要通过负载均衡器访问多个服务。
关于Dubbo支持的配置方式 配置说明
服务多协议导出 ext-protocol参数支持配置多个不同的协议，协议之间通过&amp;quot;,&amp;ldquo;进行分隔。
xml 配置 &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;-1&amp;#34; ext-protocol=&amp;#34;tri,&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;greetingService&amp;#34; class=&amp;#34;org.apache.dubbo.demo.provider.GreetingServiceImpl&amp;#34;/&amp;gt; &amp;lt;dubbo:service delay=&amp;#34;5000&amp;#34; version=&amp;#34;1.0.0&amp;#34; group=&amp;#34;greeting&amp;#34; timeout=&amp;#34;5000&amp;#34; interface=&amp;#34;org.apache.dubbo.demo.GreetingService&amp;#34; ref=&amp;#34;greetingService&amp;#34; protocol=&amp;#34;dubbo&amp;#34;/&amp;gt; API 配置 ProtocolConfig config = new ProtocolConfig(CommonConstants.TRIPLE, -1); config.setExtProtocol(CommonConstants.DUBBO+&amp;#34;,&amp;#34;); yaml 配置 dubbo: application: name: dubbo-springboot-demo-provider protocol: name: tri port: -1 ext-protocol: dubbo, properties 配置 dubbo.protocol.name=tri dubbo.protocol.ext-protocol=dubbo, dubbo.protocol.port=20880 Qos接入 Qos模块导入 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-qos&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 完成Qos模块的导入之后，相关的配置项可参考Qos操作手册进行配置。</description></item><item><title>地址同步</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/migration/dubbo-mesh/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/migration/dubbo-mesh/</guid><description>遵循以下步骤，可以轻松掌握如何开发符合 Service Mesh 架构的 Dubbo 服务，并将其部署到 Kubernetes 并接入 Istio 的流量治理体系。在此查看 完整示例源码
1 总体目标 部署 Dubbo 应用到 Kubernetes Istio 自动注入 Envoy 并实现流量拦截 基于 Istio 规则进行流量治理 2 基本流程与工作原理 这个示例演示了如何将 Dubbo 开发的应用部署在 Istio 体系下，以实现 Envoy 对 Dubbo 服务的自动代理，示例总体架构如下图所示。
完成示例将需要的步骤如下：
创建一个 Dubbo 应用( dubbo-samples-mesh-k8s ) 构建容器镜像并推送到镜像仓库（ 本示例官方镜像 ） 分别部署 Dubbo Provider 与 Dubbo Consumer 到 Kubernetes 并验证 Envoy 代理注入成功 验证 Envoy 发现服务地址、正常拦截 RPC 流量并实现负载均衡 基于 Istio VirtualService 实现按比例流量转发 3 详细步骤 3.1 环境要求 请确保本地安装如下环境，以提供容器运行时、Kubernetes集群及访问工具
Docker Minikube Kubectl Istio Kubens(optional) 通过以下命令启动本地 Kubernetes 集群</description></item><item><title>多实例部署的设计理念</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/multi-instance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/multi-instance/</guid><description>背景 Java 提供的静态变量（static field）能力可以将持有对象引用的行为绑定到类上面来，这给开发者提供了巨大的便利。注入单例模式、工厂模式等设计模式的实现方案都依赖了静态变量的功能。通过使用静态变量，开发者可以在任何时间、任何地点简单地获取到所需要的对象信息。
public class Test { public static Object obj; } Test.obj = xxx; 在一直以来的 Dubbo 框架开发中，静态变量受到了广泛地应用，诸如使用一个全局共享的 ConfigManager 来存储全局配置信息、ServiceRepository 来存储服务信息，不论从中心化管理配置或者是参数获取的便利性的角度来说，这种设计都是最佳的。在 Dubbo 2.7 以前的所有版本，Dubbo 所需要的运行时配置信息都通过全局静态变量获取，通过 RPC 服务三元组（interface + version + group）的方式进行唯一定位。
但是随着 Dubbo 用户基数的不断扩大以及在阿里集团内由 Dubbo 作为内核的 HSF3 框架都对原来的这种设计模式提出了挑战。
对于开源用户，社区收到的诉求主要包括以下几点：
在同一个应用内能够创建多个三元组一样的订阅。这个行为在 Dubbo 2.7 中虽然没有做强限制，但是由于 Dubbo 很多参数是取自全局的，而这个获取的索引使用的就是三元组。如果用户创建了两个三元组一样的订阅，他们的参数会被相互覆盖，地址推送等功能也会收到很大的影响。 Java 提供了自定义 ClassLoader 的机制可以自定义指定类的加载器来源，但是对于 Dubbo 来说并没有去支持多 ClassLoader 的场景，在动态代理生成和序列化场景下都不支持 ClassLoader 切换的行为。 Dubbo 众多的测试用例都共享了同一份配置信息，导致在进行单元测试的时候极为容易造成环境污染的问题。 对于阿里集团内大规模落地来说，我们遇到的问题主要有：
阿里集团内有众多的中间件框架，这些框架提供了各种各样的类加载方式，同时业务方期望在同一应用内的配置等信息是相互隔离的。 一些业务方的定制逻辑需要支持动态热部署的模式，具体体现在动态对某个虚拟环境进行销毁，这需要 Dubbo 内的生命周期管理更加完善。 集团内有多个对 Spring 容器进行定制化开发的框架，需要 Dubbo 能够支持多个 Spring Context 独立管理生命周期的场景。 基于众多的这些原因，在八月初的时候我们决定对 Dubbo 的生命周期进行重构，经过一个月的紧张开发，目前社区版本已经完整支持了多实例化的功能，Dubbo 的生命周期也变得更加清晰。</description></item><item><title>泛化实现</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/generic-impl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/generic-impl/</guid><description>注意 请注意区分上一篇文档介绍的 泛化调用，泛化调用是给消费端用的，而泛化实现是给提供端用的。 泛接口实现方式主要用于服务器端没有 API 接口及模型类元的情况，参数及返回值中的所有 POJO 均用 Map 表示，通常用于框架集成，比如：实现一个通用的远程服务 Mock 框架，可通过实现 GenericService 接口处理所有服务请求。
使用场景 注册服务: 服务提供者在服务注册表中注册服务，例如 Zookeeper，服务注册表存储有关服务的信息，例如其接口、实现类和地址。
部署服务: 服务提供商将服务部署在服务器并使其对消费者可用。
调用服务: 使用者使用服务注册表生成的代理调用服务，代理将请求转发给服务提供商，服务提供商执行服务并将响应发送回消费者。
监视服务：提供者和使用者可以使用 Dubbo 框架监视服务，允许他们查看服务的执行情况，并在必要时进行调整。
使用方式 本示例的完整源码请参考 dubbo-samples-generic-impl。
在 Java 代码中实现 GenericService 接口
package com.foo; public class MyGenericService implements GenericService { public Object $invoke(String methodName, String[] parameterTypes, Object[] args) throws GenericException { if (&amp;#34;sayHello&amp;#34;.equals(methodName)) { return &amp;#34;Welcome &amp;#34; + args[0]; } } } 通过 Spring 暴露泛化实现 在 Spring XML 配置申明服务的实现</description></item><item><title>服务发现</title><link>https://dubbo.apache.org/zh-cn/docs/concepts/service-discovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/concepts/service-discovery/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
服务发现，即消费端自动发现服务地址列表的能力，是微服务框架需要具备的关键能力，借助于自动化的服务发现，微服务之间可以在无需感知对端部署位置与 IP 地址的情况下实现通信。
实现服务发现的方式有很多种，Dubbo 提供的是一种 Client-Based 的服务发现机制，通常还需要部署额外的第三方注册中心组件来协调服务发现过程，如常用的 Nacos、Consul、Zookeeper 等，Dubbo 自身也提供了对多种注册中心组件的对接，用户可以灵活选择。
Dubbo 基于消费端的自动服务发现能力，其基本工作原理如下图：
服务发现的一个核心组件是注册中心，Provider 注册地址到注册中心，Consumer 从注册中心读取和订阅 Provider 地址列表。 因此，要启用服务发现，需要为 Dubbo 增加注册中心配置：
以 dubbo-spring-boot-starter 使用方式为例，增加 registry 配置
# application.properties dubbo registry address: zookeeper://127.0.0.1:2181 What&amp;rsquo;s New in Dubbo3 就使用方式上而言，Dubbo3 与 Dubbo2 的服务发现配置是完全一致的，不需要改动什么内容。但就实现原理上而言，Dubbo3 引入了全新的服务发现模型 - 应用级服务发现， 在工作原理、数据格式上已完全不能兼容老版本服务发现。
Dubbo3 应用级服务发现，以应用粒度组织地址数据 Dubbo2 接口级服务发现，以接口粒度组织地址数据 Dubbo3 格式的 Provider 地址不能被 Dubbo2 的 Consumer 识别到，反之 Dubbo2 的消费者也不能订阅到 Dubbo3 Provider。
对于新用户，我们提倡直接启用 Dubbo3 的默认行为，即启用应用级服务发现，参见《应用级服务发现》； 对于老用户，要面临如何平滑迁移到应用级服务发现的问题，考虑到老用户的规模如此之大，Dubbo3 默认保持了接口级地址发现的行为，这保证了老用户可以直接无感升级到 Dubbo3。 而如果要开启应用级服务发现，则需要通过配置显示开启（双注册、双订阅），具体开启与平滑迁移过程，可参见《地址发现迁移指南》。 应用级服务发现简介 概括来说，Dubbo3 引入的应用级服务发现主要有以下优势</description></item><item><title>服务发现的工作方式、基本使用方法与配置细节</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/service-discovery/registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/service-discovery/registry/</guid><description>Dubbo 支持基于注册中心的自动实例发现机制，即 Dubbo 提供者注册实例地址到注册中心，Dubbo 消费者通过订阅注册中心变更事件自动获取最新实例变化，从而确保流量始终转发到正确的节点之上。Dubbo 目前支持 Nacos、Zookeeper、Kubernetes Service 等多种注册中心接入。
注册中心 以下是 Dubbo 服务发现接入的一些主流注册中心实现，更多扩展实现与工作原理请查看 注册中心参考手册：
注册中心 配置值 服务发现模型 是否支持鉴权 spring-boot-starter Nacos nacos 应用级、接口级 是 dubbo-nacos-spring-boot-starter Zookeeper zookeeper 应用级、接口级 是 - dubbo-zookeeper-spring-boot-starter - dubbo-zookeeper-curator5-spring-boot-starter Kubernetes Service 参考独立使用文档 应用级 是 无 延迟注册 如果你的服务需要预热时间，比如初始化缓存、等待相关资源就位等，可以使用 delay 参数进行延迟注册。如果是在 Spring 应用中，则 delay = n(n &amp;gt; 0) 延迟的时间是 Spring 上下文初始化完成后开始算起。
@DubboService(delay = 5000) public class DemoServiceImpl implements DemoService { } 以上配置后，应用将延迟 5 秒暴露此服务（应用启动 5s 后发布该服务到注册中心）。或者可以配置全局默认值，让所有服务都延迟 5s 后注册：
dubbo: provider: delay: 5000 手动注册 通过配置 delay = -1，可以禁止框架自动发布服务到注册中心，直到用户通过调用 online 等命令手动完成发布，可以用这个特性配合部署系统实现服务的优雅上线，让用户对上线时机有更好的控制。具体配置如下：</description></item><item><title>服务路由</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/router/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/router/</guid><description>1. 简介 上一篇文章分析了集群容错的第一部分 — 服务目录 Directory。服务目录在刷新 Invoker 列表的过程中，会通过 Router 进行服务路由，筛选出符合路由规则的服务提供者。在详细分析服务路由的源码之前，先来介绍一下服务路由是什么。服务路由包含一条路由规则，路由规则决定了服务消费者的调用目标，即规定了服务消费者可调用哪些服务提供者。Dubbo 目前提供了三种服务路由实现，分别为条件路由 ConditionRouter、脚本路由 ScriptRouter 和标签路由 TagRouter。其中条件路由是我们最常使用的，标签路由是一个新的实现，暂时还未发布，该实现预计会在 2.7.x 版本中发布。本篇文章将分析条件路由相关源码，脚本路由和标签路由这里就不分析了。
2. 源码分析 条件路由规则由两个条件组成，分别用于对服务消费者和提供者进行匹配。比如有这样一条规则：
host = 10.20.153.10 =&amp;gt; host = 10.20.153.11
该条规则表示 IP 为 10.20.153.10 的服务消费者只可调用 IP 为 10.20.153.11 机器上的服务，不可调用其他机器上的服务。条件路由规则的格式如下：
[服务消费者匹配条件] =&amp;gt; [服务提供者匹配条件]
如果服务消费者匹配条件为空，表示不对服务消费者进行限制。如果服务提供者匹配条件为空，表示对某些服务消费者禁用服务。官方文档中对条件路由进行了比较详细的介绍，大家可以参考下，这里就不过多说明了。
条件路由实现类 ConditionRouter 在进行工作前，需要先对用户配置的路由规则进行解析，得到一系列的条件。然后再根据这些条件对服务进行路由。本章将分两节进行说明，2.1节介绍表达式解析过程。2.2 节介绍服务路由的过程。下面，我们先从表达式解析过程看起。
2.1 表达式解析 条件路由规则是一条字符串，对于 Dubbo 来说，它并不能直接理解字符串的意思，需要将其解析成内部格式才行。条件表达式的解析过程始于 ConditionRouter 的构造方法，下面一起看一下：
public ConditionRouter(URL url) { this.url = url; // 获取 priority 和 force 配置 this.priority = url.getParameter(Constants.PRIORITY_KEY, 0); this.force = url.</description></item><item><title>服务重试</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0%E9%85%8D%E7%BD%AE/</guid><description>背景 Dubbo 服务在尝试调用一次之后，如出现非业务异常(服务突然不可用、超时等)，Dubbo 默认会进行额外的最多2次重试.
重试次数支持两种自定义配置: 1.通过注解/xml进行固定配置；2.通过上下文进行运行时动态配置
示例 通过注解/xml进行固定配置
&amp;lt;dubbo:consumer retries=&amp;#34;2&amp;#34;&amp;gt;&amp;lt;/dubbo:consumer&amp;gt; 通过RpcContext进行运行时动态配置，优先级高于注解/xml进行的固定配置(两者都配置的情况下，以RpcContext配置为准).
// dubbo服务调用前，通过RpcContext动态设置本次调用的重试次数 RpcContext rpcContext = RpcContext.getContext(); rpcContext.setAttachment(&amp;#34;retries&amp;#34;, 5);</description></item><item><title>负载均衡策略与配置细节</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/load-balance/loadbalance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/load-balance/loadbalance/</guid><description>Dubbo-go 内置了 client-based 负载均衡机制，如下是当前支持的负载均衡算法，结合上文提到的自动服务发现机制，消费端会自动使用 Weighted Random LoadBalance 加权随机负载均衡策略 选址调用。
如果要调整负载均衡算法，以下是 Dubbo 框架内置的负载均衡策略：
算法 特性 备注 配置值 Weighted Random LoadBalance 加权随机 默认算法，默认权重相同 random (默认) RoundRobin LoadBalance 加权轮询 借鉴于 Nginx 的平滑加权轮询算法，默认权重相同 roundrobin LeastActive LoadBalance 最少活跃优先 + 加权随机 背后是能者多劳的思想 leastactive Consistent Hash LoadBalance 一致性哈希 确定的入参，确定的提供者，适用于有状态请求 consistenthashing P2C LoadBalance Power of Two Choice 随机选择两个节点后，继续选择“连接数”较小的那个节点。 p2c Interleaved Weighted Round Robin 一种加权轮训算法 https://en.wikipedia.org/wiki/Weighted_round_robin#Interleaved_WRR interleavedweightedroundrobin Alias Method Round Robin https://en.wikipedia.org/wiki/Alias_method aliasmethod 全局配置 Dubbo 框架的默认策略是 random 加权随机负载均衡。如果要调整策略，只需要设置 loadbalance 相应取值即可，每种负载均衡策略取值请参见文档最上方表格。</description></item><item><title>负载均衡策略与配置细节</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/service-discovery/loadbalance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/service-discovery/loadbalance/</guid><description>Dubbo 内置了 client-based 负载均衡机制，如下是当前支持的负载均衡算法，结合上文提到的自动服务发现机制，消费端会自动使用 Weighted Random LoadBalance 加权随机负载均衡策略 选址调用。
如果要调整负载均衡算法，以下是 Dubbo 框架内置的负载均衡策略：
算法 特性 备注 配置值 Weighted Random LoadBalance 加权随机 默认算法，默认权重相同 random (默认) RoundRobin LoadBalance 加权轮询 借鉴于 Nginx 的平滑加权轮询算法，默认权重相同 roundrobin LeastActive LoadBalance 最少活跃优先 + 加权随机 背后是能者多劳的思想 leastactive Shortest-Response LoadBalance 最短响应优先 + 加权随机 更加关注响应速度 shortestresponse ConsistentHash LoadBalance 一致性哈希 确定的入参，确定的提供者，适用于有状态请求 consistenthash P2C LoadBalance Power of Two Choice 随机选择两个节点后，继续选择“连接数”较小的那个节点。 p2c Adaptive LoadBalance 自适应负载均衡 在 P2C 算法基础上，选择二者中 load 最小的那个节点 adaptive 全局配置 Dubbo 框架的默认策略是 random 加权随机负载均衡。如果要调整策略，只需要设置 loadbalance 相应取值即可，每种负载均衡策略取值请参见文档最上方表格。</description></item><item><title>了解 Dubbo 核心概念和架构</title><link>https://dubbo.apache.org/zh-cn/overview/what/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/overview/</guid><description>以上是 Dubbo 的工作原理图，从抽象架构上分为两层：服务治理抽象控制面 和 Dubbo 数据面 。
服务治理控制面。服务治理控制面不是特指如注册中心类的单个具体组件，而是对 Dubbo 治理体系的抽象表达。控制面包含协调服务发现的注册中心、流量管控策略、Dubbo Admin 控制台等，如果采用了 Service Mesh 架构则还包含 Istio 等服务网格控制面。 Dubbo 数据面。数据面代表集群部署的所有 Dubbo 进程，进程之间通过 RPC 协议实现数据交换，Dubbo 定义了微服务应用开发与调用规范并负责完成数据传输的编解码工作。 服务消费者 (Dubbo Consumer)，发起业务调用或 RPC 通信的 Dubbo 进程 服务提供者 (Dubbo Provider)，接收业务调用或 RPC 通信的 Dubbo 进程 Dubbo 数据面 从数据面视角，Dubbo 帮助解决了微服务实践中的以下问题：
Dubbo 作为 服务开发框架 约束了微服务定义、开发与调用的规范，定义了服务治理流程及适配模式 Dubbo 作为 RPC 通信协议实现 解决服务间数据传输的编解码问题 服务开发框架 微服务的目标是构建足够小的、自包含的、独立演进的、可以随时部署运行的分布式应用程序，几乎每个语言都有类似的应用开发框架来帮助开发者快速构建此类微服务应用，比如 Java 微服务体系的 Spring Boot，它帮 Java 微服务开发者以最少的配置、最轻量的方式快速开发、打包、部署与运行应用。
微服务的分布式特性，使得应用间的依赖、网络交互、数据传输变得更频繁，因此不同的应用需要定义、暴露或调用 RPC 服务，那么这些 RPC 服务如何定义、如何与应用开发框架结合、服务调用行为如何控制？这就是 Dubbo 服务开发框架的含义，Dubbo 在微服务应用开发框架之上抽象了一套 RPC 服务定义、暴露、调用与治理的编程范式，比如 Dubbo Java 作为服务开发框架，当运行在 Spring 体系时就是构建在 Spring Boot 应用开发框架之上的微服务开发框架，并在此之上抽象了一套 RPC 服务定义、暴露、调用与治理的编程范式。</description></item><item><title>管理控制台安装</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/admin/install/admin-console/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/admin/install/admin-console/</guid><description>目前版本的管理控制台正在开发中，已经完成了服务查询和服务治理的功能，采用前后端分离的模式，具体的安装和使用步骤如下：
安装:
git clone https://github.com/apache/dubbo-admin.git /var/tmp/dubbo-admin cd /var/tmp/dubbo-admin mvn clean package 配置 1:
配置文件为： dubbo-admin-server/src/main/resources/application.properties 主要的配置有： admin.registry.address=zookeeper://127.0.0.1:2181 admin.config-center=zookeeper://127.0.0.1:2181 admin.metadata-report.address=zookeeper://127.0.0.1:2181 启动:
mvn --projects dubbo-admin-server spring-boot:run 其他配置请访问 github 中的文档:
https://github.com/apache/dubbo-admin 访问:
http://127.0.0.1:8080 当前版本中未实现登录功能，会在后续版本加上&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>管理控制台运维</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/admin/ops/functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/admin/ops/functions/</guid><description>搜索页面 当你需要管理 Dubbo 的服务时，首先要搜索到这个服务，然后打开它的管理页面
服务提供者页面 服务消费者页面 添加路由规则页面 添加动态配置页面</description></item><item><title>前端 http 流量接入 Dubbo 后端微服务体系的基础架构</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/gateway/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/gateway/architecture/</guid><description>不论你开发的是什么样的产品（电子商城、管理系统、手机 app 等），绝大多数下产品的流量入口都会是 http，用户可能通过浏览器、手机移动设备、桌面软件等来访问产品。在这种情况下，如何将后端开发的 Dubbo 微服务集群接入前端访问设备就成为一个需要解决的问题，其实也就是 http 与 rpc 之间的转换与连接问题。
总的来说，有中心化和去中心化两种架构模式。其中，中心化接入模式更具通用性，对后端 rpc 协议、前端网关没有太多特殊要求，但保证中心化应用的性能、稳定性是一个较大的挑战；去中心化模式由于不需要维护入口应用，因此可适应更大流量、更大规模的集群。
中心化接入方式 中心化接入方式的架构图如下：
在后端服务与前端设备之间有一层网关，负责流量过滤、路由、限流等流量管理工作 在后端集群中有一个连接 http 与 dubbo 服务的 “统一微服务入口应用”（通常也叫做 BFF，即Backend for Frontend）。 BFF 应用通常可以使用 Spring Web 等常用框架开发，应用发布一系列的 http 服务，接收网关或前端设备流量，同时负责按需发起 dubbo 调用。
注意 dubbo、triple 协议都支持这种接入架构。另外，在配置 BFF 应用调用 dubbo 服务时，可以使用普通的 dubbo 配置方式，也可以使用泛化调用等方式：
配置接入 dubbo 协议时，使用 泛化调用 的优势是可以避免对服务二进制包的依赖，实现配置动态生效的效果。 配置接入 triple 协议时，可以使用 http 调用方式，同样可避免对服务二进制包的依赖，实现配置动态生效的效果。 去中心化接入方式 与中心化架构相比，此方式并没有太大的差异，唯一的区别在于不需要额外的 BFF 应用，我们可以在网关直接调用后端 dubbo 服务。
但这种方式对网关有特别要求。如果后端是 dubbo 协议的话，则要求网关具备 http -&amp;gt; dubbo 协议转换的能力，但你会在接下来的文档中发现，我们可以通过多协议发布绕过协议转换，让网关直接通过 http 访问后端服务；如果后端是 triple 协议，就会更简单了，因为 triple 协议支持 application/json 格式的 http 请求。</description></item><item><title>基准测试</title><link>https://dubbo.apache.org/zh-cn/docs/performance/benchmarking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/performance/benchmarking/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
1 Benchmark 结论 对比 2.x 版本，Dubbo3 版本
服务发现资源利用率显著提升。 对比接口级服务发现，单机常驻内存下降 50%，地址变更期 GC 消耗下降一个数量级 (百次 -&amp;gt; 十次) 对比应用级服务发现，单机常驻内存下降 75%，GC 次数趋零 Dubbo 协议性能持平，Triple 协议在网关、Stream吞吐量方面更具优势。 Dubbo协议 （3.0 vs 2.x），3.0 实现较 2.x 总体 qps rt 持平，略有提升 Triple协议 vs Dubbo协议，直连调用场景 Triple 性能并无优势，其优势在网关、Stream调用场景。 以下是详细压测过程与数据
2 应用级服务发现（地址推送链路） 此部分压测数据是由工商银行 Dubbo 团队基于内部生产数据给出，压测过程模拟了“生产环境地址+zookeeper”的服务发现架构。
2.1 环境 描述 压测数据 提供者500运行实例✖️8interface✖️5protocol，即每个提供者向注册中心注册40个URL，总计20000个URL，每个URL字符长度约1k。注册中心2个独立zookeeper注册中心，服务提供者消费者采用并行配置。消费者配置1c2g，xmx=768，开启GC，从2个注册中心订阅，每5秒调用一次服务。运行20小时。 压测环境 Java version &amp;ldquo;1.8.0&amp;rdquo;Java(TM) SE Runtime Enviroment (build pxa6480sr3fp12-20160919_01(SR3 FP12))IBM J9 VM (Build 2.8, JRE 1.8.0 Linux amd64-64 Compressed References 20160915_318796, JIT enabled, AOT enabled) 2.</description></item><item><title>Admin 整体架构与安装步骤</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/control-plane/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/control-plane/architecture/</guid><description>回顾 Dubbo 服务治理体系的总体架构，Admin 是服务治理控制面中的一个核心组件，负责微服务集群的服务治理、可视化展示等。
Admin 部署架构 总体上来说，Admin 部署架构分为以下几个部分：
Admin 主进程，包括服务发现元数据管理、可视化控制台、安全认证策略管控、其他定制化服务治理能力等组件。 强依赖组件，包括 Mysql 数据库、注册/配置/元数据中心（可以是 Kubernetes、Nacos、Zookeeper 等） 可选依赖组件，包括 Prometheus、Grafana、Zipkin 等 安装 Admin Dubboctl 安装 Download 当前Dubboctl未正式发行，可按以下方式进行尝试。 拉取Dubbo Admin并编译Dubboctl
git clone https://github.com/apache/dubbo-admin.git cd dubbo-admin/cmd/dubboctl go build -o dubboctl . 将 dubboctl 放入可执行路径
ln -s dubbo-admin/cmd/dubboctl/dubboctl /usr/local/bin/dubboctl Install 安装过程会依次：
将用户自定义的配置profile以及set参数覆盖于默认profile，得到最终的profile # default profile apiVersion: dubbo.apache.org/v1alpha1 kind: DubboOperator metadata: namespace: dubbo-system spec: profile: default namespace: dubbo-system componentsMeta: admin: enabled: true grafana: enabled: true repoURL: https://grafana.github.io/helm-charts version: 6.</description></item><item><title>Dubbo3 简介</title><link>https://dubbo.apache.org/zh-cn/docs/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/introduction/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Apache Dubbo 是一款微服务开发框架，它提供了 RPC通信 与 微服务治理 两大关键能力。这意味着，使用 Dubbo 开发的微服务，将具备相互之间的远程发现与通信能力， 同时利用 Dubbo 提供的丰富服务治理能力，可以实现诸如服务发现、负载均衡、流量调度等服务治理诉求。同时 Dubbo 是高度可扩展的，用户几乎可以在任意功能点去定制自己的实现，以改变框架的默认行为来满足自己的业务需求。
Dubbo3 基于 Dubbo2 演进而来，在保持原有核心功能特性的同时， Dubbo3 在易用性、超大规模微服务实践、云原生基础设施适配、安全设计等几大方向上进行了全面升级。 以下文档都将基于 Dubbo3 展开。
What Dubbo3 is 如开篇所述，Dubbo 提供了构建云原生微服务业务的一站式解决方案，可以使用 Dubbo 快速定义并发布微服务组件，同时基于 Dubbo 开箱即用的丰富特性及超强的扩展能力，构建运维整个微服务体系所需的各项服务治理能力，如 Tracing、Transaction 等，Dubbo 提供的基础能力包括：
服务发现 流式通信 负载均衡 流量治理 &amp;hellip;.. Dubbo 计划提供丰富的多语言客户端实现，其中 Java、Golang 版本是当前稳定性、活跃度最好的版本，其他多语言客户端正在持续建设中。
自开源以来，Dubbo 就被一众大规模互联网、IT公司选型，经过多年企业实践积累了大量经验。Dubbo3 是站在巨人肩膀上的下一代产品，它汲取了上一代的优点并针对已知问题做了大量优化，因此，Dubbo 在解决业务落地与规模化实践方面有着无可比拟的优势：
开箱即用 易用性高，如 Java 版本的面向接口代理特性能实现本地透明调用 功能丰富，基于原生库或轻量扩展即可实现绝大多数的微服务治理能力 超大规模微服务集群实践 高性能的跨进程通信协议 地址发现、流量治理层面，轻松支持百万规模集群实例 企业级微服务治理能力 服务测试 服务Mock Dubbo3 是在云原生背景下诞生的，使用 Dubbo 构建的微服务遵循云原生思想，能更好的复用底层云原生基础设施、贴合云原生微服务架构。这体现在：
服务支持部署在容器、Kubernetes平台，服务生命周期可实现与平台调度周期对齐； 支持经典 Service Mesh 微服务架构，引入了 Proxyless Mesh 架构，进一步简化 Mesh 的落地与迁移成本，提供更灵活的选择； 作为桥接层，支持与 SpringCloud、gRPC 等异构微服务体系的互调互通 一站式微服务解决方案 Dubbo 提供了从服务定义、服务发现、服务通信到流量管控等几乎所有的服务治理能力，并且尝试从使用上对用户屏蔽底层细节，以提供更好的易用性。</description></item><item><title>接入 Ingress 流量</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/gateway/http_triple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/gateway/http_triple/</guid><description>1. 准备工作 kubectl 一个 k8s 集群，配置好 kubeconfig 2. 使用 HTTP 协议通过网关调用 Triple 应用 Dubbo-go-pixiu 网关支持调用 GO/Java 的 Dubbo 集群。在 Dubbo-go 3.0 的场景下，我们可以通过 Pixiu 网关，在集群外以 HTTP 协议请求 pixiu 网关，在网关层进行协议转换，进一步调用集群内的Dubbo-go 服务。
用户调用 Dubbo-go 服务的 path 为http://$(app_name)/$(service_name)/$(method)。
例如一个proto文件内有如下定义：
package org.apache.dubbo.quickstart.samples; service UserProvider { rpc SayHello (HelloRequest) returns (User) {} } message HelloRequest { string name = 1; } 并在dubbo-go 服务启动时在dubbogo.yml 内配置应用名为my-dubbogo-app:
dubbo: application: name: my-dubbogo-app pixiu 网关即可解析 path 为 my-dubbogo-app/org.apache.dubbo.quickstart.samples.UserProvider/SayHello 的路由，并转发至对应服务。来自外部HTTP 请求的 body 为 json 序列化的请求参数，例如 {&amp;ldquo;name&amp;rdquo;:&amp;ldquo;test&amp;rdquo;}。</description></item><item><title>开发 RPC Server &amp; RPC Client</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/quickstart/rpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/quickstart/rpc/</guid><description>基于 Dubbo 定义的 Triple 协议，你可以轻松编写浏览器、gRPC 兼容的 RPC 服务，并让这些服务同时运行在 HTTP/1 和 HTTP/2 上。Dubbo Go SDK 支持使用 IDL 或编程语言特有的方式定义服务，并提供一套轻量的 API 来发布或调用这些服务。
本示例演示了基于 Triple 协议的 RPC 通信模式，示例使用 Protocol Buffer 定义 RPC 服务，并演示了代码生成、服务发布和服务访问等过程。
前置条件 因为使用 Protocol Buffer 的原因，我们首先需要安装相关的代码生成工具，这包括 protoc、protoc-gen-go、protoc-gen-go-triple。
安装 protoc
查看 Protocol Buffer Compiler 安装指南
安装 protoc 插件
接下来，我们安装插件 protoc-gen-go、protoc-gen-go-triple。
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest go install dubbo.apache.org/dubbo-go/v3/cmd/protoc-gen-go-triple@v3.0.1 确保 protoc-gen-go、protoc-gen-go-triple 在你的 PATH 中。这可以通过 which protoc-gen-go 验证，如果该命令不能正常工作的话，请执行以下命令：
[ -n &amp;#34;$(go env GOBIN)&amp;#34; ] &amp;amp;&amp;amp; export PATH=&amp;#34;$(go env GOBIN):${PATH}&amp;#34; [ -n &amp;#34;$(go env GOPATH)&amp;#34; ] &amp;amp;&amp;amp; export PATH=&amp;#34;$(go env GOPATH)/bin:${PATH}&amp;#34; 快速运行示例 下载示例源码 我们在 apache/dubbo-go-samples 仓库维护了一系列 dubbo-go 使用示例，用来帮助用户快速学习 dubbo-go 使用方式。</description></item><item><title>可观测性</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/observability/console/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/observability/console/</guid><description>管理 Dubbo 最直接的方式就是通过 Dubbo 控制面（即 dubbo-control-plane）提供的可视化界面，之前我们在【快速开始 - 部署 Dubbo 应用】一文的最后，也有用到它查看服务启动后的状态。
dubbo-control-plane 支持可视化的展示、监控集群状态，还支持实时下发流量管控规则。
安装控制台 为了体验效果，我们首先需要安装 dubbo-control-plane，以下是在 Linux 环境下安装 dubbo-control-plane 的具体步骤：
下载 &amp;amp; 解压 curl -L https://dubbo.apache.org/releases/downloadDubbo.sh | sh - cd dubbo-$version export PATH=$PWD/bin:$PATH 安装 dubbo-cp run --mode universal --config conf/dubbo.yml 注意，conf/dubbo.yml 配置需要按需调整，指向你要连接的注册中心等后台服务，具体请查看 dubbo-control-plane 架构中依赖的后台服务。 访问 http://xxx 即可打开控制台页面。 注意 请查看文档了解 dubbo-control-plane 详细安装步骤，包括多个平台的安装方法与配置指导。 对于 Kubernetes 环境下的 Dubbo 服务开发（包括 dubbo-control-plane 安装），我们有专门的章节说明，对于 Kubernetes 环境下的开发者可以去参考。 功能介绍 Admin 控制台提供了从开发、测试到流量治理等不同层面的丰富功能，功能总体上可分为以下几类：
服务状态与依赖关系查询 服务在线测试与文档管理 集群状态监控 实例诊断 流量管控 服务状态与依赖关系查询 服务状态查询以接口为维度展示 dubbo 集群信息，包含服务提供者、消费者信息和服务的元数据等。元数据包含了服务定义、方法名和参数列表等信息。Admin 支持最新版本 dubbo3 所提供的应用级发现模型，以统一的页面交互展示了应用级&amp;amp;接口级地址信息，并以特殊的标记对记录进行区分。</description></item><item><title>快速开始</title><link>https://dubbo.apache.org/zh-cn/docs/languages/erlang/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/erlang/quick-start/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
建议先使用 java 定义接口 jar，并使用 erlanalysis 工具解析java接口至Erlang lib
导入依赖库 使用 Rebar 编译工具。 Add dubblerl to rebar.config with your project
{deps, [ {dubboerl, {git, &amp;#34;https://github.com/apache/dubbo-erlang.git&amp;#34;, {branch, &amp;#34;master&amp;#34;}}} ]}. 使用 erlang.mk 编译工具 待补充
导入接口库 Suppose the interface lib you exported is called dubbo_service.
If you didn&amp;rsquo;t upload your lib to your git repository, It is recommended that you copy the dubbo_service lib into the project&amp;rsquo;s apps directory. If it is upload to your git repository, you can import like this: {deps, [ {dubboerl, {git, &amp;#34;https://github.</description></item><item><title>快速开始</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/languages/erlang/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/languages/erlang/quick-start/</guid><description>建议先使用 java 定义接口 jar，并使用 erlanalysis 工具解析java接口至Erlang lib
导入依赖库 使用 Rebar 编译工具。 Add dubblerl to rebar.config with your project
{deps, [ {dubboerl, {git, &amp;#34;https://github.com/apache/dubbo-erlang.git&amp;#34;, {branch, &amp;#34;master&amp;#34;}}} ]}. 使用 erlang.mk 编译工具 待补充
导入接口库 Suppose the interface lib you exported is called dubbo_service.
If you didn&amp;rsquo;t upload your lib to your git repository, It is recommended that you copy the dubbo_service lib into the project&amp;rsquo;s apps directory. If it is upload to your git repository, you can import like this: {deps, [ {dubboerl, {git, &amp;#34;https://github.</description></item><item><title>快速开始</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/nodejs-sdk/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/nodejs-sdk/quick-start/</guid><description>基于 Dubbo 定义的 Triple 协议，你可以轻松编写浏览器、gRPC 兼容的 RPC 服务，并让这些服务同时运行在 HTTP/1 和 HTTP/2 上。Dubbo Node.js SDK 支持使用 IDL 或编程语言特有的方式定义服务，并提供一套轻量的 API 来发布或调用这些服务。
本示例演示了基于 Triple 协议的 RPC 通信模式，示例使用 Protocol Buffer 定义 RPC 服务，并演示了代码生成、服务发布和服务访问等过程。
前置条件 因为使用 Protocol Buffer 的原因，我们首先需要安装相关的代码生成工具，这包括 @bufbuild/protoc-gen-es、@bufbuild/protobuf、@apachedubbo/protoc-gen-apache-dubbo-es、@apachedubbo/dubbo。
npm install @bufbuild/protoc-gen-es @bufbuild/protobuf @apachedubbo/protoc-gen-apache-dubbo-es @apachedubbo/dubbo 定义服务 现在，使用 Protocol Buffer (IDL) 来定义一个 Dubbo 服务。
创建目录，并生成文件
mkdir -p proto &amp;amp;&amp;amp; touch proto/example.proto 写入内容
syntax = &amp;#34;proto3&amp;#34;; package apache.dubbo.demo.example.v1; message SayRequest { string sentence = 1; } message SayResponse { string sentence = 1; } service ExampleService { rpc Say(SayRequest) returns (SayResponse) {} } 这个文件声明了一个叫做 ExampleService 的服务，为这个服务定义了 Say 方法以及它的请求参数 SayRequest 和返回值 SayResponse。</description></item><item><title>快速开始</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/quick-start/</guid><description>请在此查看完整 示例。
1 前置条件 安装 Rust 开发环境 安装 protoc 工具 2 使用 IDL 定义 Dubbo 服务 Greeter 服务定义如下，包含一个 Unary(request-response) 模型的 Dubbo 服务。
// ./proto/greeter.proto syntax = &amp;#34;proto3&amp;#34;; option java_multiple_files = true; package org.apache.dubbo.sample.tri; // The request message containing the user&amp;#39;s name. message GreeterRequest { string name = 1; } // The response message containing the greetings message GreeterReply { string message = 1; } service Greeter{ // unary rpc greet(GreeterRequest) returns (GreeterReply); } 3 添加 Dubbo-rust 及相关依赖到项目 # .</description></item><item><title>快速开始</title><link>https://dubbo.apache.org/zh-cn/overview/reference/erlang-sdk/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/erlang-sdk/quick-start/</guid><description>建议先使用 java 定义接口 jar，并使用 erlanalysis 工具解析java接口至Erlang lib
导入依赖库 使用 Rebar 编译工具。 Add dubblerl to rebar.config with your project
{deps, [ {dubboerl, {git, &amp;#34;https://github.com/apache/dubbo-erlang.git&amp;#34;, {branch, &amp;#34;master&amp;#34;}}} ]}. 使用 erlang.mk 编译工具 待补充
导入接口库 Suppose the interface lib you exported is called dubbo_service.
If you didn&amp;rsquo;t upload your lib to your git repository, It is recommended that you copy the dubbo_service lib into the project&amp;rsquo;s apps directory. If it is upload to your git repository, you can import like this: {deps, [ {dubboerl, {git, &amp;#34;https://github.</description></item><item><title>快速易用</title><link>https://dubbo.apache.org/zh-cn/overview/what/advantages/usability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/advantages/usability/</guid><description>无论你是计划采用微服务架构开发一套全新的业务系统，还是准备将已有业务从单体架构迁移到微服务架构，Dubbo 框架都可以帮助到你。Dubbo 让微服务开发变得非常容易，它允许你选择多种编程语言、使用任意通信协议，并且它还提供了一系列针对微服务场景的开发、测试工具帮助提升研发效率。
多语言 SDK Dubbo 提供几乎所有主流语言的 SDK 实现，定义了一套统一的微服务开发范式。Dubbo 与每种语言体系的主流应用开发框架做了适配，总体编程方式、配置符合大多数开发者已有编程习惯。
比如在 Java 语言体系下，你可以使用 dubbo-spring-boot-starter 来开发符合 Spring、Spring Boot 模式的微服务应用，开发 Dubbo 应用只是为 Spring Bean 添加几个注解、完善 application.properties 配置文件。
任意通信协议 Dubbo 微服务间远程通信实现细节，支持 HTTP、HTTP/2、gRPC、TCP 等所有主流通信协议。与普通 RPC 框架不同，Dubbo 不是某个单一 RPC 协议的实现，它通过上层的 RPC 抽象可以将任意 RPC 协议接入 Dubbo 的开发、治理体系。
多协议支持让用户选型，多协议迁移、互通等变得更灵活。
加速微服务开发 项目脚手架 项目脚手架 让 Dubbo 项目创建、依赖管理更容易。
比如通过如下可视化界面，勾选 Dubbo 版本、Zookeeper 注册中心以及必要的微服务生态选项后，一个完整的 Dubbo 项目模板就可以自动生成，接下来基于脚手架项目添加业务逻辑就可以了。更多脚手架使用方式的讲解，请参见任务模块的 通过模板生成项目脚手架
开发测试 相比于单体应用，微服务分布式的特性会让不同组织之间的研发协同变得困难，这时我们需要有效的配套工具，用来提升整体的微服务研发效率。
Dubbo 从内核设计和实现阶段就考虑了如何解决开发、测试与运维问题，比如 Dubbo RPC 协议均支持 curl 访问，让开发协作更简单；配合官方提供的生态工具，可以实现服务测试、服务 Mock、文档管理、单机运维等能力，并通过 Dubbo Admin 控制台将所有操作都可视化的展现出来。</description></item><item><title>框架介绍</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/introduction/</guid><description>什么是 dubbo-go Dubbo-go 是 Apache Dubbo 的 go 语言实现，它完全遵循 Apache Dubbo 设计原则与目标，是 go 语言领域的一款优秀微服务开发框架。dubbo-go 提供：
API 与 RPC 协议：帮助解决组件之间的 RPC 通信问题，提供基于 HTTP/1/2 的通信协议、streaming流式通信模型。 丰富的微服务治理能力：解决地址发现、流量管控、可观测性、全链路追踪、日志等微服务整体解决方案。 概念与架构 以下是 dubbo-go 的整体架构图： dubbo-go 总体上遵循 框架内核+插件 的的设计理念，左侧的 框架内核 定义了 dubbo-go 作为微服务框架的一些核心概念，右侧的 插件 部分则提供了核心概念扩展实现。
框架内核 可分为 4 个层次，从上到下依次为：
API 层：dubbo-go 同时支持基于 IDL、interface/struct 的服务契约定义，兼顾跨语言与易用性诉求；支持基于纯 yaml 文件的微服务配置模式；提供了同步、异步、单次(unary)、流式(streaming) 等 RPC 通信与编码模型。
服务治理层：dubbo-go 内置了多维度的服务治理能力抽象，确保满足微服务开发与集群治理的核心诉求，这包括地址发现（Service Discovery）、负载均衡（Load Balancing）、可观测指标（Metrics）、流量管控（Traffic Management）、全链路追踪（Tracing）等。
RPC 协议层：dubbo-go 实现的最核心的 RPC 协议是 - triple 协议，triple 可同时工作在 http1/2 之上 (支持 CURL 直接访问)，兼容 gRPC；从设计上，dubbo-go 还提供了多协议发布服务的支持，你可以在一个进程内同时发布 triple、dubbo2、rest、jsonRPC 等多种不同通信协议的服务。</description></item><item><title>配置和管理框架日志</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/observability/logger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/observability/logger/</guid><description>本示例演示如何配置 dubbo-go 框架日志组件，将框架运行态日志保存到指定的位置。可在此查看 完整示例源码地址。
注意 这里配置的只是 dubbo-go 框架自身的日志组件行为，即框架内部使用的日志，不影响业务日志框架的使用！ 1. 日志配置 如下所示，可以通过 log.WithZap()、log.WithLevel(&amp;quot;warn&amp;quot;) 设置 dubbo 框架日志行为：
ins, err := dubbo.NewInstance( dubbo.WithLogger( log.WithLevel(&amp;#34;warn&amp;#34;), log.WithZap(), ), ) 2. 应用共享日志组件 注意，这里配置的只是 dubbo-go 框架自身的日志组件行为（即框架内部使用的日志），不影响业务日志框架的使用！
通过以下方式，业务应用也可以选择复用这个日志组件：
import app_logger &amp;#34;github.com/dubbogo/gost/log/logger&amp;#34; app_logger.Info(&amp;#34;hello&amp;#34;) 日志 Interface
type Logger interface { Info(args ...interface{}) Warn(args ...interface{}) Error(args ...interface{}) Debug(args ...interface{}) Fatal(args ...interface{}) Infof(fmt string, args ...interface{}) Warnf(fmt string, args ...interface{}) Errorf(fmt string, args ...interface{}) Debugf(fmt string, args ...interface{}) Fatalf(fmt string, args ...interface{}) } 注意 日志API不可以在Init 阶段使用，否则可能会发生意料之外的问题。 2.</description></item><item><title>全链路追踪使用与实现说明</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/observability/tracing/tracing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/observability/tracing/tracing/</guid><description>Dubbo 内置了全链路追踪能力，你可以通过引入 spring-boot-starter 或者相关依赖开启链路跟踪能力，通过将跟踪数据导出到一些主流实现如 Zipkin、Skywalking、Jaeger 等后端系统，可以实现全链路跟踪数据的分析与可视化展示。
Dubbo 目前借助 Micrometer Observation 完成 Tracing 的所有埋点工作，依赖 Micrometer 提供的各种 Bridge 适配，我们可以实现将 Tracing 导入各种后端系统，具体工作原理如下。
使用方式 以 Dubbo Spring Boot 应用为例，通过加入如下依赖即可开启链路追踪，并使用 zipkin exporter bridge 将链路追踪数据导入 Zipkin 后端系统。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-spring-boot-tracing-otel-zipkin-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.2.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 更多完整示例请参见：
使用 Zipkin 实现 Dubbo 全链路追踪 使用 Skywalking 实现 Dubbo 全链路追踪 关联日志 Dubbo Tracing 还实现了与日志系统的自动关联，即将 tracing-id、span-id 等信息自动置入日志 MDC 上下文，你只需要设置日志输出格式中包含类似 %X{traceId:-},%X{spanId:-}]，即可实现业务日志与 tracing 系统的自动关联，具体可参见 Tracing 日志上下文配置示例。
工作原理 Tracing相关概念 Span：基本工作单元。例如，发送 RPC 是一个新的 span，发送对 RPC 的响应也是如此。Span还有其他数据，例如description、带时间戳的事件、键值注释（标签）、导致它们的跨度的 ID 和进程 ID（通常是 IP 地址）。跨度可以启动和停止，并且它们会跟踪它们的时间信息。创建跨度后，您必须在将来的某个时间点停止它。</description></item><item><title>流式通信</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/rpc/streaming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/rpc/streaming/</guid><description>Streaming 流式通信是 Dubbo3 新提供的一种 RPC 数据传输模式，适用于以下场景:
接口需要发送大量数据，这些数据无法被放在一个 RPC 的请求或响应中，需要分批发送，但应用层如果按照传统的多次 RPC 方式无法解决顺序和性能的问题，如果需要保证有序，则只能串行发送 流式场景，数据需要按照发送顺序处理, 数据本身是没有确定边界的 推送类场景，多个消息在同一个调用的上下文中被发送和处理 Streaming 流式通信类型分为以下三种:
SERVER_STREAM(服务端流) CLIENT_STREAM(客户端流) BIDIRECTIONAL_STREAM(双向流) 1.介绍 本文档演示如何在 Dubbo-go 中使用流式通信，可在此查看 完整示例源码地址。
2.如何使用Dubbo-go流式通信 在proto文件中需要流式通信的方法的参数前面添加stream，使用proto-gen-triple生成相应文件
service GreetService { rpc Greet(GreetRequest) returns (GreetResponse) {} rpc GreetStream(stream GreetStreamRequest) returns (stream GreetStreamResponse) {} rpc GreetClientStream(stream GreetClientStreamRequest) returns (GreetClientStreamResponse) {} rpc GreetServerStream(GreetServerStreamRequest) returns (stream GreetServerStreamResponse) {} } 编写服务端handler文件
源文件路径: dubbo-go-sample/streaming/go-server/cmd/server.go
type GreetTripleServer struct { } func (srv *GreetTripleServer) Greet(ctx context.Context, req *greet.GreetRequest) (*greet.GreetResponse, error) { resp := &amp;amp;greet.</description></item><item><title>路由规则</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/traffic/router/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/traffic/router/</guid><description/></item><item><title>Dubbo 路由（router）机制及其如何实现流量管控介绍</title><link>https://dubbo.apache.org/zh-cn/overview/what/core-features/traffic/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/core-features/traffic/introduction/</guid><description>Dubbo 提供了丰富的流量管控策略
地址发现与负载均衡，地址发现支持服务实例动态上下线，负载均衡确保流量均匀的分布到每个实例上。 基于路由规则的流量管控，路由规则对每次请求进行条件匹配，并将符合条件的请求路由到特定的地址子集。 服务发现保证调用方看到最新的提供方实例地址，服务发现机制依赖注册中心 (Zookeeper、Nacos、Istio 等) 实现。在消费端，Dubbo 提供了多种负载均衡策略，如随机负载均衡策略、一致性哈希负载、基于权重的轮询、最小活跃度优先、P2C 等。
Dubbo 的流量管控规则可以基于应用、服务、方法、参数等粒度精准的控制流量走向，根据请求的目标服务、方法以及请求体中的其他附加参数进行匹配，符合匹配条件的流量会进一步的按照特定规则转发到一个地址子集。流量管控规则有以下几种：
条件路由规则 标签路由规则 脚本路由规则 动态配置规则 如果底层用的是基于 HTTP 的 RPC 协议 (如 REST、gRPC、Triple 等)，则服务和方法等就统一映射为 HTTP 路径 (path)，此时 Dubbo 路由规则相当于是基于 HTTP path 和 headers 的流量分发机制。
Dubbo 中有应用、服务和方法的概念，一个应用可以发布多个服务，一个服务包含多个可被调用的方法，从抽象的视角来看，一次 Dubbo 调用就是某个消费方应用发起了对某个提供方应用内的某个服务特定方法的调用，Dubbo 的流量管控规则可以基于应用、服务、方法、参数等粒度精准的控制流量走向。
Router工作原理 以下是 Dubbo 单个路由器的工作过程，路由器接收一个服务的实例地址集合作为输入，基于请求上下文 (Request Context) 和 (Router Rule) 实际的路由规则定义对输入地址进行匹配，所有匹配成功的实例组成一个地址子集，最终地址子集作为输出结果继续交给下一个路由器或者负载均衡组件处理。
通常，在 Dubbo 中，多个路由器组成一条路由链共同协作，前一个路由器的输出作为另一个路由器的输入，经过层层路由规则筛选后，最终生成有效的地址集合。
Dubbo 中的每个服务都有一条完全独立的路由链，每个服务的路由链组成可能不通，处理的规则各异，各个服务间互不影响。 对单条路由链而言，即使每次输入的地址集合相同，根据每次请求上下文的不同，生成的地址子集结果也可能不同。 路由规则分类 标签路由规则 标签路由通过将某一个服务的实例划分到不同的分组，约束具有特定标签的流量只能在指定分组中流转，不同分组为不同的流量场景服务，从而实现流量隔离的目的。标签路由可以作为蓝绿发布、灰度发布等场景能力的基础。
标签路由规则是一个非此即彼的流量隔离方案，也就是匹配标签的请求会 100% 转发到有相同标签的实例，没有匹配标签的请求会 100% 转发到其余未匹配的实例。如果您需要按比例的流量调度方案，请参考示例 基于权重的按比例流量路由。
标签主要是指对 Provider 端应用实例的分组，目前有两种方式可以完成实例分组，分别是动态规则打标和静态规则打标。动态规则打标 可以在运行时动态的圈住一组机器实例，而 静态规则打标 则需要实例重启后才能生效，其中，动态规则相较于静态规则优先级更高，而当两种规则同时存在且出现冲突时，将以动态规则为准。</description></item><item><title>魔鬼在细节</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/principals/code-detail/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/principals/code-detail/</guid><description>最近一直担心如果 Dubbo 分布式服务框架维护人员增多或变更，会出现质量的下降的问题， 我在想，有没有什么规则是需要大家共同遵守的。根据平时写代码时的一习惯，总结了以下在写代码过程中，尤其是框架代码，要时刻牢记的细节。可能下面要讲的这些，大家都会觉得很简单，很基础，但要做到时刻牢记。在每一行代码中都考虑这些因素，是需要很大耐心的， 大家经常说，魔鬼在细节中，确实如此。
防止空指针和下标越界 这是我最不喜欢看到的异常，尤其在核心框架中，我更愿看到信息详细的参数不合法异常。这也是一个编写健壮程序的开发人员，在写每一行代码都应在潜意识中防止的异常。基本上要能确保每一次写完的代码，在不测试的情况下，都不会出现这两个异常才算合格。
保证线程安全性和可见性 对于框架的开发人员，对线程安全性和可见性的深入理解是最基本的要求。需要开发人员，在写每一行代码时都应在潜意识中确保其正确性。因为这种代码，在小并发下做功能测试时，会显得很正常。但在高并发下就会出现莫明其妙的问题，而且场景很难重现，极难排查。
尽早失败和前置断言 尽早失败也应该成为潜意识，在有传入参数和状态变化时，均在入口处全部断言。一个不合法的值和状态，在第一时间就应报错，而不是等到要用时才报错。因为等到要用时，可能前面已经修改其它相关状态，而在程序中很少有人去处理回滚逻辑。这样报错后，其实内部状态可能已经混乱，极易在一个隐蔽分支上引发程序不可恢复。
分离可靠操作和不可靠操作 这里的可靠是狭义的指是否会抛出异常或引起状态不一致，比如，写入一个线程安全的 Map，可以认为是可靠的，而写入数据库等，可以认为是不可靠的。开发人员必须在写每一行代码时，都注意它的可靠性与否，在代码中尽量划分开，并对失败做异常处理，并为容错，自我保护，自动恢复或切换等补偿逻辑提供清晰的切入点，保证后续增加的代码不至于放错位置，而导致原先的容错处理陷入混乱。
异常防御，但不忽略异常 这里讲的异常防御，指的是对非必须途径上的代码进行最大限度的容忍，包括程序上的 BUG，比如：获取程序的版本号，会通过扫描 Manifest 和 jar 包名称抓取版本号，这个逻辑是辅助性的，但代码却不少，初步测试也没啥问题，但应该在整个 getVersion() 中加上一个全函数的 try-catch 打印错误日志，并返回基本版本，因为 getVersion() 可能存在未知特定场景异常，或被其他的开发人员误修改逻辑(但一般人员不会去掉 try-catch)，而如果它抛出异常会导致主流程异常，这是我们不希望看到的。但这里要控制个度，不要随意 try-catch，更不要无声无息的吃掉异常。
缩小可变域和尽量 final 如果一个类可以成为不变类(Immutable Class)，就优先将它设计成不变类。不变类有天然的并发共享优势，减少同步或复制，而且可以有效帮忙分析线程安全的范围。就算是可变类，对于从构造函数传入的引用，在类中持有时，最好将字段 final，以免被中途误修改引用。不要以为这个字段是私有的，这个类的代码都是我自己写的，不会出现对这个字段的重新赋值。要考虑的一个因素是，这个代码可能被其他人修改，他不知道你的这个弱约定，final 就是一个不变契约。
降低修改时的误解性，不埋雷 前面不停的提到代码被其他人修改，这也开发人员要随时紧记的。这个其他人包括未来的自己，你要总想着这个代码可能会有人去改它。我应该给修改的人一点什么提示，让他知道我现在的设计意图，而不要在程序里面加潜规则，或埋一些容易忽视的雷，比如：你用 null 表示不可用，size 等于 0 表示黑名单，这就是一个雷，下一个修改者，包括你自己，都不会记得有这样的约定，可能后面为了改某个其它 BUG，不小心改到了这里，直接引爆故障。对于这个例子，一个原则就是永远不要区分 null 引用和 empty 值。
提高代码的可测性 这里的可测性主要指 Mock 的容易程度，和测试的隔离性。至于测试的自动性，可重复性，非偶然性，无序性，完备性(全覆盖)，轻量性(可快速执行)，一般开发人员，加上 JUnit 等工具的辅助基本都能做到，也能理解它的好处，只是工作量问题。这里要特别强调的是测试用例的单一性(只测目标类本身)和隔离性(不传染失败)。现在的测试代码，过于强调完备性，大量重复交叉测试，看起来没啥坏处，但测试代码越多，维护代价越高。经常出现的问题是，修改一行代码或加一个判断条件，引起 100 多个测试用例不通过。时间一紧，谁有这个闲功夫去改这么多形态各异的测试用例？久而久之，这个测试代码就已经不能真实反应代码现在的状况，很多时候会被迫绕过。最好的情况是，修改一行代码，有且只有一行测试代码不通过。如果修改了代码而测试用例还能通过，那也不行，表示测试没有覆盖到。另外，可 Mock 性是隔离的基础，把间接依赖的逻辑屏蔽掉。可 Mock 性的一个最大的杀手就是静态方法，尽量少用。</description></item><item><title>配置中心</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config-center/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config-center/introduction/</guid><description>配置中心 (config-center) 在 Dubbo 中可承担两类职责：
外部化配置：启动配置的集中式存储 （简单理解为 dubbo.properties 的外部化存储）。 流量治理规则存储 请参考具体扩展实现了解如何启用配置中心。
值得注意的是 Dubbo 动态配置中心定义了两个不同层次的隔离选项，分别是 namespace 和 group。
namespace - 配置命名空间，默认值 dubbo。命名空间通常用于多租户隔离，即对不同用户、不同环境或完全不关联的一系列配置进行逻辑隔离，区别于物理隔离的点是不同的命名空间使用的还是同一物理集群。 group - 配置分组，默认值 dubbo。group 通常用于归类一组相同类型/目的的配置项，是对 namespace 下配置项的进一步隔离。 参考 配置说明 - 配置项手册 了解 namespace 和 group 之外 config-center 开放的更多配置项。
使用注册中心作为默认配置中心 在使用 Zookeeper、Nacos 作为注册中心且没有显式配置配置中心的情况下，Dubbo 框架会默认将此 Zookeeper、Nacos 用作配置中心，用作服务治理用途。</description></item><item><title>启动时检查</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/preflight-check/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/preflight-check/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check=&amp;quot;true&amp;quot;。
可以通过 check=&amp;quot;false&amp;quot; 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。
另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check=&amp;quot;false&amp;quot;，总是会返回引用，当服务恢复时，能自动连上。
示例 通过 spring 配置文件 关闭某个服务的启动时检查 (没有提供者时报错)：
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; check=&amp;#34;false&amp;#34; /&amp;gt; 关闭所有服务的启动时检查 (没有提供者时报错)：
&amp;lt;dubbo:consumer check=&amp;#34;false&amp;#34; /&amp;gt; 关闭注册中心启动时检查 (注册订阅失败时报错)：
&amp;lt;dubbo:registry check=&amp;#34;false&amp;#34; /&amp;gt; 通过 dubbo.properties dubbo.reference.com.foo.BarService.check=false dubbo.consumer.check=false dubbo.registry.check=false 通过 -D 参数 java -Ddubbo.reference.com.foo.BarService.check=false java -Ddubbo.consumer.check=false java -Ddubbo.registry.check=false 配置的含义 dubbo.reference.com.foo.BarService.check，覆盖 com.foo.BarService的 reference 的 check 值，就算配置中有声明，也会被覆盖。
dubbo.consumer.check=false，是设置reference的 check 的缺省值，如果配置中有显式的声明，如：&amp;lt;dubbo:reference check=&amp;quot;true&amp;quot;/&amp;gt;，不会受影响。
dubbo.registry.check=false，前面两个都是指订阅成功，但提供者列表是否为空是否报错，如果注册订阅失败时，也允许启动，需使用此选项，将在后台定时重试。</description></item><item><title>启动时检查</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/preflight-check/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/preflight-check/</guid><description>背景 Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check=&amp;quot;true&amp;quot;。
可以通过 check=&amp;quot;false&amp;quot; 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。
另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check=&amp;quot;false&amp;quot;，总是会返回引用，当服务恢复时，能自动连上。
示例 通过 spring 配置文件 关闭某个服务的启动时检查 (没有提供者时报错)：
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; check=&amp;#34;false&amp;#34; /&amp;gt; 关闭所有服务的启动时检查 (没有提供者时报错)：
&amp;lt;dubbo:consumer check=&amp;#34;false&amp;#34; /&amp;gt; 关闭注册中心启动时检查 (注册订阅失败时报错)：
&amp;lt;dubbo:registry check=&amp;#34;false&amp;#34; /&amp;gt; 通过 dubbo.properties dubbo.reference.com.foo.BarService.check=false dubbo.reference.check=false dubbo.consumer.check=false dubbo.registry.check=false 通过 -D 参数 java -Ddubbo.reference.com.foo.BarService.check=false java -Ddubbo.reference.check=false java -Ddubbo.consumer.check=false java -Ddubbo.registry.check=false 配置的含义 dubbo.reference.check=false，强制改变所有 reference 的 check 值，就算配置中有声明，也会被覆盖。
dubbo.consumer.check=false，是设置 check 的缺省值，如果配置中有显式的声明，如：&amp;lt;dubbo:reference check=&amp;quot;true&amp;quot;/&amp;gt;，不会受影响。
dubbo.registry.check=false，前面两个都是指订阅成功，但提供者列表是否为空是否报错，如果注册订阅失败时，也允许启动，需使用此选项，将在后台定时重试。</description></item><item><title>请求耗时采样</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/troubleshoot/profiler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/troubleshoot/profiler/</guid><description>性能采样功能可以对 Dubbo 处理链路上的各处耗时进行检测，在出现超时的时候 ( usageTime / timeout &amp;gt; profilerWarnPercent * 100 ) 通过日志记录调用的耗时。
此功能分为 simple profiler 和 detail profiler 两个模式，其中 simple profiler 模式默认开启，detail profiler 模式默认关闭。 detail profiler 相较 simple profiler 模式多采集了每个 filter 的处理耗时、协议上的具体耗时等。 在 simple profiler 模式下如果发现 Dubbo 框架内部存在耗时长的情况，可以开启 detail profiler 模式，以便更好地排查问题。
使用场景 需要对 Dubbo 请求的精确耗时进行采集分析的场景，如服务不明原因的超时等
使用方式 simple profiler 默认自动开启，对于请求处理时间超过超时时间 3/4 的，都会通过日志打印出慢调用信息。如果需要开启 detail profiler 模式或者修改超时告警比例，可以参考性能采样命令文档。
日志说明 日志中各字段的含义如下：
[Dubbo-Consumer] execute service 接口#方法 cost 实际耗时, this invocation almost (maybe already) timeout. Timeout: 超时时间 invocation context: 请求上下文 thread info: Start time: 开始请求时间（nano 时间） +-[ Offset: 当前节点开始时间; Usage: 当前节点使用总耗时, 当前节点耗时比例 ] 当前节点描述 +-[ Offset: 当前节点开始时间; Usage: 当前节点使用总耗时, 当前节点耗时比例 ] 当前节点描述 对于请求耗时这里以两个例子进行介绍：</description></item><item><title>自定义 SPI 扩展的基本步骤</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/extensibility/spi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/extensibility/spi/</guid><description>下面以 RPC 协议插件 为例，说明如何利用 Dubbo 提供的 SPI 插件提供一个自定义的 RPC 协议实现。如果想了解 SPI 机制的工作原理以及框架内置的 SPI 扩展点列表，请查看 参考手册 - SPI扩展。
1. 提供 SPI 插件实现类 提供一个 Java 类实现 org.apache.dubbo.rpc.Protocol 接口。
package com.spi.demo; import org.apache.dubbo.rpc.Protocol; @Activate public class CustomizedProtocol implements Protocol { // ... } 2. 在指定文件配置实现类 在应用 resources/META-INF/services/ 目录下添加 org.apache.dubbo.rpc.Protocol 文件，文件中增加如下配置：
customized=com.spi.demo.CustomizedProtocol 配置注意事项 文件名必须为 SPI 插件定义的 package 全路径名，具体取决于你要扩展的 SPI 定义，如示例中的 resources/META-INF/services/org.apache.dubbo.rpc.Protocol。 文件中的内容必须是 key=value 形式，其中 key 可随便定义，但建议增加特定前缀以避免与 Dubbo 内置实现重名，value 必须设置为扩展类实现的全路径名。 3. 通过配置启用自定义协议实现 在应用中修改协议配置，告诉 Dubbo 框架使用自定义协议：</description></item><item><title>从 dubbo2 升级到 dubbo3（涵盖 2.5.x、2.6.x、2.7.x 等版本）</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/upgrades-and-compatibility/migration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/upgrades-and-compatibility/migration/</guid><description>总体来说，Dubbo2 升级到 Dubbo3 后的核心能力都是兼容的，对于 90% 以上的常规用户而言（指未做深度 SPI 扩展或源码定制的用户），可以非常简单的完成升级。
2.7.x 升级 Dubbo3 步骤一：升级核心依赖 首先，在应用中增加 bom 依赖管理：
&amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-dependencies-bom&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; 如果您之前用的是 org.apache.dubbo:dubbo 依赖，请升级到以下版本（如果项目中还有其它 dubbo 子模块依赖，请一并升级版本号）：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 如果之前的应用是 Spring Boot，建议使用以下 starter 依赖方式并升级到最新版本（如果之前未使用 starter，请删除所有老的 dubbo 模块依赖，直接使用以下配置即可）：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; Dubbo3 相关的 Spring、Spring Boot 版本升级说明 Dubbo3 支持的 Spring、Spring Boot 版本兼容范围非常广：
既支持 Spring 3.x ~ Spring 5.x 相关版本，同时也支持 Spring Boot 1.x ~ Spring Boot 2.</description></item><item><title>生态组件</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/ecology/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/ecology/</guid><description>Dubbo-go github.com/apache/dubbo-go
Apache Dubbo Go 语言实现主仓库
Dubbo-go-samples github.com/apache/dubbo-go-samples
dubbo-go 的使用示例：
config-api: 使用 API 进行配置初始化 configcenter: 使用不同的配置中心，目前支持三种：zookeeper、apollo、和 nacos context: 如何使用上下文传递 attachment direct: 直连模式 game: 游戏服务例子 generic: 泛化调用 rpc: RPC 调用例子, 包含 Triple、Dubbo等协议以及跨语言/gRPC互通示例 helloworld: RPC调用入门例子 logger: 日志例子 registry: 展示与不同注册中心的对接，包含了 zk、nacos、etcd metrics: 数据上报 filter: 使用提供filter和自定义filter的例子 registry/servicediscovery：应用级服务发现例子 router: 路由例子 tracing: 链路追踪例子 Dubbo-go-pixiu github.com/apache/dubbo-go-pixiu
dubbo-go-pixiu 网关支持以 dubbo 协议和 http 协议调用 dubbo/dubbo-go 集群
Dubbo-getty github.com/apache/dubbo-getty
dubbo-getty 是一个Go语言异步网络 io 库，支持 tcp/udp/websocket 协议。
Dubbo-go-hessian2 github.com/apache/dubbo-go-hessian2
Dubbo-go-hessian2 是一个Go语言 hessian2 序列化协议库</description></item><item><title>示例应用架构</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/architecture/</guid><description>此任务基于一个简单的线上商城微服务系统演示了 Dubbo 的流量管控能力。
注意 本示例展示的所有能力均基于 Dubbo 路由规则 实现，如想了解具体工作原理可查看详情。 线上商城的架构图如下：
系统由 5 个微服务应用组成：
Frontend 商城主页，作为与用户交互的 web 界面，通过调用 User、Detail、Order 等提供用户登录、商品展示和订单管理等服务。 User 用户服务，负责用户数据管理、身份校验等。 Order 订单服务，提供订订单创建、订单查询等服务，依赖 Detail 服务校验商品库存等信息。 Detail 商品详情服务，展示商品详情信息，调用 Comment 服务展示用户对商品的评论记录。 Comment 评论服务，管理用户对商品的评论数据。 部署商场系统 为方便起见，我们将整个系统部署在 Kubernetes 集群，执行以下命令即可完成商城项目部署，项目源码示例在 dubbo-samples/task。
kubectl apply -f https://raw.githubusercontent.com/apache/dubbo-samples/master/10-task/dubbo-samples-shop/deploy/All.yml 完整的部署架构图如下：
Order 订单服务有两个版本 v1 和 v2，v2 是订单服务优化后发布的新版本。
版本 v1 只是简单的创建订单，不展示订单详情 版本 v2 在订单创建成功后会展示订单的收货地址详情 Detail 和 Comment 服务也分别有两个版本 v1 和 v2，我们通过多个版本来演示流量导流后的效果。
版本 v1 默认为所有请求提供服务 版本 v2 模拟被部署在特定的区域的服务，因此 v2 实例会带有特定的标签 执行以下命令，确定所有服务、Pod都已正常运行：
$ kubectl get services -n dubbo-demo $ kubectl get pods -n dubbo-demo 为了保障系统完整性，除了商城相关的几个微服务应用，示例还在后台拉起了 Nacos 注册配置中心、Dubbo Admin 控制台 和 Skywalking 全链路追踪系统。</description></item><item><title>条件路由规则</title><link>https://dubbo.apache.org/zh-cn/overview/what/core-features/traffic/condition-rule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/core-features/traffic/condition-rule/</guid><description>条件路由规则将符合特定条件的请求转发到特定的地址实例子集上。规则首先对发起流量的请求参数进行匹配，符合匹配条件的请求将被转发到包含特定实例地址列表的子集。
以下是一个条件路由规则示例。
基于以下示例规则，所有 org.apache.dubbo.samples.CommentService 服务 getComment 方法的调用都将被转发到有 region=Hangzhou 标记的地址子集。
configVersion: v3.0 scope: service force: true runtime: true enabled: true key: org.apache.dubbo.samples.CommentService conditions: - method=getComment =&amp;gt; region=Hangzhou 可以看具体的例子代码： 条件路由
ConditionRule 条件路由规则主体。定义路由规则生效的目标服务或应用、流量过滤条件以及一些特定场景下的行为。
字段名 类型 描述 必填 configVersion string 条件路由的版本，当前版本为 v3.0 是 scope string 支持 service 和 application 两种规则 是 key string 应用到的目标服务或应用程序的标识符- 当 scope:service 时, key应该是该规则生效的服务名比如 org.apache.dubbo.samples.CommentService - 当 scope:application 时, then key应该是该规则应该生效的应用名称，比如说my-dubbo-service. 是 enabled bool 规则是否生效 当 enabled:false 时，规则不生效 是 conditions string[] 配置中定义的条件规则，详情可以看条件规则 是 force bool T路由后实例子集为空时的行为。 true 则抛出一个No Provider Exception。 false 则忽略规则，直接去请求其他的实例。默认值是false 否 runtime bool 是否为每个 rpc 调用运行路由规则或使用路由缓存（如果可用）。默认值是false（false则走缓存，true不走缓存） 否 Condition Condition 为条件路由规则的主体，类型为一个复合结构的 string 字符串，如 method=getComment =&amp;gt; region=Hangzhou。其中，</description></item><item><title>通用 Release 流程</title><link>https://dubbo.apache.org/zh-cn/contact/committer/release-guide/common/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/contact/committer/release-guide/common/</guid><description>理解 Apache 发布的内容和流程 总的来说，Source Release 是 Apache 关注的重点，也是发布的必须内容；而 Binary Release 是可选项，Dubbo 可以选择是否发布二进制包到 Apache 仓库或者发布到 Maven 中央仓库。
请参考以下链接，找到更多关于 ASF 的发布指南:
Apache Release Guide Apache Release Policy Maven Release Info 发布流程 1. 准备分支 从主干分支拉取新分支作为发布分支，如现在要发布 ${release_version} 版本，则从开发分支拉出新分支 ${release_version}-release，此后${release_version} Release Candidates 涉及的修改及打标签等都在${release_version}-release分支进行，最终发布完成后合入主干分支。
例：如 Java SDK 需要发布 3.0.10 版本，从 3.0 分支拉出新分支 3.0.10-release，并在此分支提交从 Snapshot 替换为 3.0.10 版本号的 commit。
2. Github 打标签并发布 Pre Release 状态 在对应 GitHub 仓库中基于 ${release_version}-release 分支，打标签 ${release_version}-release，填写 Release Note 并发布 Pre Release 状态。（不允许在投票流程正式通过前把 Release 状态置为正式发布状态）</description></item><item><title>网络协议</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/sourcecode/protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/sourcecode/protocol/</guid><description>对于 Dubbogo 微服务框架，网络协议为远程过程调用中负责网络通信的模块，负责应用层到网络层的数据序列化、打包、请求发起、网络端口监听等功能。Dubbogo 为协议抽象了一套接口如下：
type Protocol interface { // Export service for remote invocation Export(invoker Invoker) Exporter // Refer a remote service Refer(url *common.URL) Invoker // Destroy will destroy all invoker and exporter, so it only is called once. Destroy() } 该接口包含三个方法。其中 Export 方法负责服务的暴露过程。入参 invoker 为dubbo 的概念，其封装了一个可以被调用的实例。在具体网络协议（例如Triple）实现的 Export 方法中，会针对特定的协议，将封装有一定逻辑的可调用实例 Invoker 以网络端口监听的形式暴露给外部服务，来自外部针对该网络端口的请求将会被 Export 方法开启的监听协程获取，进而根据网络协议进行拆解包和反序列化，得到解析后的请求数据。
Refer 方法负责服务的引用过程，其入参 url 为 dubbo 框架通用的结构，可以描述一个希望引用的服务，url 参数中包含了多个希望引用服务的参数，例如对应服务的接口名(interface)，版本号(version)，使用协议(protocol) 等等。在具体网络协议（例如Triple）实现的 Refer 方法中，会将特定的网络协议封装到 Invoker 可调用实例的方法中，用户层发起的 RPC 调用即可直接通过返回的 Invoker 对象，发起特定协议的网络请求。
Destroy 方法作用为销毁当前暴露的服务，用于服务下线场景。Dubbogo 框架有优雅下线机制，可以在服务进程终止前以监听信号的形式，下线所有已启动的服务。</description></item><item><title>微服务开发</title><link>https://dubbo.apache.org/zh-cn/overview/what/core-features/service-definition/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/core-features/service-definition/</guid><description>Dubbo 解决企业微服务从开发、部署到治理运维的一系列挑战，Dubbo 为开发者提供从项目创建、开发测试，到部署、可视化监测、流量治理，再到生态集成的全套服务。
开发层面，Dubbo 提供了 Java、Go、Rust、Node.js 等语言实现并定义了一套微服务开发范式，配套脚手架可用于快速创建微服务项目骨架 部署层面，Dubbo 应用支持虚拟机、Docker 容器、Kubernetes、服务网格架构部署 服务治理层面，Dubbo 提供了地址发现、负载均衡、流量管控等治理能力，官方还提供 Admin 可视化控制台、丰富的微服务生态集成 开发 接下来以 Java 体系 Spring Boot 项目为例讲解 Dubbo 应用开发的基本步骤，整个过程非常直观简单，其他语言开发过程类似。
创建项目 Dubbo 微服务项目脚手架（支持浏览器页面、命令行和 IDE）可用于快速创建微服务项目，只需要告诉脚手架期望包含的功能或组件，脚手架最终可以帮助开发者生成具有必要依赖的微服务工程。更多脚手架使用方式的讲解，请参见任务模块的 通过模板生成项目脚手架
开发服务 1. 定义服务
public interface DemoService { String hello(String arg); } 2. 提供业务逻辑实现
@DubboService public class DemoServiceImpl implements DemoService { public String hello(String arg) { // put your microservice logic here } } 发布服务 1. 发布服务定义
为使消费方顺利调用服务，服务提供者首先要将服务定义以 Jar 包形式发布到 Maven 中央仓库。
2. 对外暴露服务</description></item><item><title>协议概述</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/overview/</guid><description>Dubbo 作为一款 RPC 框架内置了高效的 RPC 通信协议，帮助解决服务间的编码与通信问题，目前支持的协议包括：
triple，基于 HTTP/1、HTTP/2 的高性能通信协议，100% 兼容 gRPC，支持 Unary、Streming 等通信模式；支持发布 REST 风格的 HTTP 服务。 dubbo，基于 TCP 的高性能私有通信协议，缺点是通用性较差，更适合在 Dubbo SDK 间使用； 任意协议扩展，通过扩展 protocol 可以之前任意 RPC 协议，官方生态库提供 JsonRPC、thrift 等支持。 协议选型 开发者该如何确定使用哪一种协议那？ 以下是我们从使用场景、性能、编程易用性、多语言互通等方面对多个主流协议的对比分析：
协议 性能 网关友好 流式通信 多语言支持 编程API 说明 triple 高 高 支持，客户端流、服务端流、双向流 支持（Java、Go、Node.js、JavaScript、Rust） Java Interface、Protobuf(IDL) 在多语言兼容、性能、网关、Streaming、gRPC 等方面最均衡的协议实现，官方推荐。 支持 application/json 格式 payload http 直接访问。 dubbo 高 低 不支持 支持（Java、Go） Java Interface 性能最高的私有协议，但前端流量接入、多语言支持等成本较高 以下是 triple、dubbo 两个主要协议的具体开发、配置、运行态信息：
协议名称 配置值 服务定义方式 默认端口 传输层协议 序列化协议 是否默认 triple tri - Java Interface - Java Interface+SpringWeb注解 - Java Interface+JaxRS注解 - Protobuf(IDL) 50051 HTTP/1、HTTP/2 Protobuf Binary、Protobuf-json 否 dubbo dubbo - Java Interface 20880 TCP Hessian、Fastjson2、JSON、JDK、Avro、Kryo 等 是 注意 自 3.</description></item><item><title>协议扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/protocol/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 RPC 协议扩展，封装远程调用细节。
契约：
当用户调用 refer() 所返回的 Invoker 对象的 invoke() 方法时，协议需相应执行同 URL 远端 export() 传入的 Invoker 对象的 invoke() 方法。 其中，refer() 返回的 Invoker 由协议实现，协议通常需要在此 Invoker 中发送远程请求，export() 传入的 Invoker 由框架实现并传入，协议不需要关心。 注意：
协议不关心业务接口的透明代理，以 Invoker 为中心，由外层将 Invoker 转换为业务接口。 协议不一定要是 TCP 网络通讯，比如通过共享文件，IPC 进程间通讯等。 扩展接口 org.apache.dubbo.rpc.Protocol org.apache.dubbo.rpc.Exporter org.apache.dubbo.rpc.Invoker public interface Protocol { /** * 暴露远程服务：&amp;lt;br&amp;gt; * 1. 协议在接收请求时，应记录请求来源方地址信息：RpcContext.getContext().setRemoteAddress();&amp;lt;br&amp;gt; * 2. export()必须是幂等的，也就是暴露同一个URL的Invoker两次，和暴露一次没有区别。&amp;lt;br&amp;gt; * 3. export()传入的Invoker由框架实现并传入，协议不需要关心。&amp;lt;br&amp;gt; * * @param &amp;lt;T&amp;gt; 服务的类型 * @param invoker 服务的执行体 * @return exporter 暴露服务的引用，用于取消暴露 * @throws RpcException 当暴露服务出错时抛出，比如端口已占用 */ &amp;lt;T&amp;gt; Exporter&amp;lt;T&amp;gt; export(Invoker&amp;lt;T&amp;gt; invoker) throws RpcException; /** * 引用远程服务：&amp;lt;br&amp;gt; * 1.</description></item><item><title>协议扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/protocol/</guid><description>扩展说明 RPC 协议扩展，封装远程调用细节。
契约：
当用户调用 refer() 所返回的 Invoker 对象的 invoke() 方法时，协议需相应执行同 URL 远端 export() 传入的 Invoker 对象的 invoke() 方法。 其中，refer() 返回的 Invoker 由协议实现，协议通常需要在此 Invoker 中发送远程请求，export() 传入的 Invoker 由框架实现并传入，协议不需要关心。 注意：
协议不关心业务接口的透明代理，以 Invoker 为中心，由外层将 Invoker 转换为业务接口。 协议不一定要是 TCP 网络通讯，比如通过共享文件，IPC 进程间通讯等。 扩展接口 org.apache.dubbo.rpc.Protocol org.apache.dubbo.rpc.Exporter org.apache.dubbo.rpc.Invoker public interface Protocol { /** * 暴露远程服务：&amp;lt;br&amp;gt; * 1. 协议在接收请求时，应记录请求来源方地址信息：RpcContext.getContext().setRemoteAddress();&amp;lt;br&amp;gt; * 2. export()必须是幂等的，也就是暴露同一个URL的Invoker两次，和暴露一次没有区别。&amp;lt;br&amp;gt; * 3. export()传入的Invoker由框架实现并传入，协议不需要关心。&amp;lt;br&amp;gt; * * @param &amp;lt;T&amp;gt; 服务的类型 * @param invoker 服务的执行体 * @return exporter 暴露服务的引用，用于取消暴露 * @throws RpcException 当暴露服务出错时抛出，比如端口已占用 */ &amp;lt;T&amp;gt; Exporter&amp;lt;T&amp;gt; export(Invoker&amp;lt;T&amp;gt; invoker) throws RpcException; /** * 引用远程服务：&amp;lt;br&amp;gt; * 1.</description></item><item><title>协议扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/protocol/</guid><description>扩展说明 RPC 协议扩展，封装远程调用细节。
契约：
当用户调用 refer() 所返回的 Invoker 对象的 invoke() 方法时，协议需相应执行同 URL 远端 export() 传入的 Invoker 对象的 invoke() 方法。 其中，refer() 返回的 Invoker 由协议实现，协议通常需要在此 Invoker 中发送远程请求，export() 传入的 Invoker 由框架实现并传入，协议不需要关心。 注意 协议不关心业务接口的透明代理，以 Invoker 为中心，由外层将 Invoker 转换为业务接口。 协议不一定要是 TCP 网络通讯，比如通过共享文件，IPC 进程间通讯等。 扩展接口 org.apache.dubbo.rpc.Protocol org.apache.dubbo.rpc.Exporter org.apache.dubbo.rpc.Invoker public interface Protocol { /** * 暴露远程服务：&amp;lt;br&amp;gt; * 1. 协议在接收请求时，应记录请求来源方地址信息：RpcContext.getContext().setRemoteAddress();&amp;lt;br&amp;gt; * 2. export()必须是幂等的，也就是暴露同一个URL的Invoker两次，和暴露一次没有区别。&amp;lt;br&amp;gt; * 3. export()传入的Invoker由框架实现并传入，协议不需要关心。&amp;lt;br&amp;gt; * * @param &amp;lt;T&amp;gt; 服务的类型 * @param invoker 服务的执行体 * @return exporter 暴露服务的引用，用于取消暴露 * @throws RpcException 当暴露服务出错时抛出，比如端口已占用 */ &amp;lt;T&amp;gt; Exporter&amp;lt;T&amp;gt; export(Invoker&amp;lt;T&amp;gt; invoker) throws RpcException; /** * 引用远程服务：&amp;lt;br&amp;gt; * 1.</description></item><item><title>需求</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/preface/requirements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/preface/requirements/</guid><description>在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过 F5 等硬件进行负载均衡。
服务配置 当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。 此时需要一个服务注册中心，动态地注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。
服务依赖 当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清关系。
服务容量 接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？ 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阈值，记录此时的访问量，再以此访问量乘以机器数反推总容量。
以上是 Dubbo 最基本的几个需求。</description></item><item><title>序列化安全</title><link>https://dubbo.apache.org/zh-cn/overview/notices/serialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/notices/serialization/</guid><description>概述 Dubbo 支持序列化协议的扩展，理论上用户可以基于该扩展机制启用任意的序列化协议，这带来了极大的灵活的，但同时也要意识到其中潜藏的安全性风险。 数据反序列化是最容易被被攻击者利用的一个环节，攻击者利用它执行 RCE 攻击等窃取或破坏服务端数据。 用户在切换序列化协议或实现前， 应充分调研目标序列化协议及其框架实现的安全性保障，并提前设置相应的安全措施（如设置黑/白名单）。 Dubbo 框架自身并不能直接保证目标序列化机制的安全性。
Dubbo 2.7 官方版本提供的序列化协议有如下几种：
Hessian2 Fastjson Kryo FST JDK Protostuff Protocol Buffers Avro Gson 从 Dubbo 3.0 开始默认仅提供以下序列化协议支持：
Hessian2 JDK Protocol Buffers 从 Dubbo 3.2 开始默认提供以下序列化协议支持：
Hessian2 Fastjson2 JDK Protocol Buffers 处于安全性考虑，从 Dubbo 3.3 开始将默认仅提供以下序列化协议支持：
Hessian2 Fastjson2 Protocol Buffers 针对以上序列化扩展，在发现或收到相关的漏洞报告之后，Dubbo 官方会跟进并升级依赖到最新的安全版本，但最终的漏洞修复方案取决于序列化的框架实现。
针对使用 dubbo hessian2 版本的用户，Dubbo 官方会保证hessian2序列化机制的安全性并尽可能的修复上报的安全漏洞
此外，从 Dubbo 3.2 版本开始，对于 Hessian2 和 Fastjson2 默认采用白名单机制，如果您发现部分数据处理移除，可以参考文档进行配置。
全面加固 为了尽可能提高应用序列化的安全性，Dubbo3.0在序列化协议安全方面进行了升级加固，推荐使用 Tripe 协议的非 Wrapper 模式。 该协议默认安全，但需要开发人员编写IDL文件。</description></item><item><title>Dubbo 序列化机制介绍</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/serialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/serialization/</guid><description>支持的协议列表 以下是 Dubbo 框架支持的序列化协议列表，根据 triple、dubbo RPC 通信协议进行分类。
RPC协议 编程模式 序列化协议 配置方式 JDK版本 说明 triple IDL protobuf、protobuf-json 默认值 8, 17, 21 使用 IDL 时的默认序列化方式，client 也可以选择 protobuf-json 序列化通信，无需额外配置 Java接口 protobuf-wrapper serialization=&amp;ldquo;hessian&amp;rdquo; 8, 17, 21 这种模式下采用的是两次序列化模式，即数据先被 hessian 序列化，再由 protobuf 序列化。为了支持与 IDL 同等的调用模型，易用性较好但性能略有下降 dubbo Java接口 hessian 默认值，serialization=&amp;ldquo;hessian&amp;rdquo; 8, 17, 21 dubbo 协议默认序列化方式，具备兼容性好、高性能、跨语言的优势(java、go、c/c++、php、python、.net) Java接口 protostuff serialization=&amp;ldquo;protostuff&amp;rdquo; 8 A java serialization library with built-in support for forward-backward compatibility (schema evolution) and validation. Java接口 gson serialization=&amp;ldquo;gson&amp;rdquo; 8, 17, 21 谷歌推出的一款 json 序列化库 Java接口 avro serialization=&amp;ldquo;avro&amp;rdquo; 8, 17, 21 一款 Java 高性能序列化库 Java接口 msgpack serialization=&amp;ldquo;msgpack&amp;rdquo; 8, 17, 21 具备兼容性好，提供多语言（Java、C/C++、Python等）实现等优势 Java接口 kryo serialization=&amp;ldquo;kryo&amp;rdquo; 8, 17, 21 Kryo是一种非常成熟的序列化实现，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用。 Java接口 fastjson2 serialization=&amp;ldquo;fastjson2&amp;rdquo; 8, 17, 21 fastjson Java接口 更多扩展 dubbo-spi-extensions 性能对比报告 序列化对于远程调用的响应速度、吞吐量、网络带宽消耗等起着至关重要的作用，是我们提升分布式系统性能的最关键因素之一。</description></item><item><title>序列化协议安全</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/serialization-security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/serialization-security/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo3.0在序列化协议安全方面进行了升级加固，推荐使用Tripe协议非Wrapper模式。 该协议默认安全，但需要开发人员编写IDL文件。
Triple协议Wrapper模式下，允许兼容其它序列化数据，提供了良好的兼容性。但其它协议可能存在反序列化安全缺陷，对于Hession2协议，高安全属性用户应当按照samples代码指示，开启白名单模式，框架默认会开启黑名单模式，拦截恶意调用。
不建议使用其它序列化协议，当攻击者可访问Provider接口时，其它序列化协议的安全缺陷，可能导致 Povider 接口命令执行。
若必须使用其它序列化协议，同时希望具备一定安全性。应当开启Token鉴权机制，防止未鉴权的不可信请求来源威胁Provider的安全性。开启Token鉴权机制时，应当同步开启注册中心的鉴权功能。</description></item><item><title>Dubbo 支持的 RPC 通信协议</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/protocol/</guid><description>Dubbo 作为一款 RPC 框架内置了高效的 RPC 通信协议，帮助解决服务间的编码与通信问题，目前支持的协议包括：
triple，基于 HTTP/1、HTTP/2 的高性能通信协议，100% 兼容 gRPC，支持 Unary、Streming 等通信模式；支持发布 REST 风格的 HTTP 服务。 dubbo，基于 TCP 的高性能私有通信协议，缺点是通用性较差，更适合在 Dubbo SDK 间使用； 任意协议扩展，通过扩展 protocol 可以之前任意 RPC 协议，官方生态库提供 JsonRPC、thrift 等支持。 协议概览 使用哪个协议？ 开发者该如何确定使用哪一种协议那？ 以下是我们从使用场景、性能、编程易用性、多语言互通等方面对多个主流协议的对比分析：
协议 性能 网关友好 流式通信 多语言支持 编程API 说明 triple 高 高 支持，客户端流、服务端流、双向流 支持（Java、Go、Node.js、JavaScript、Rust） Java Interface、Protobuf(IDL) 在多语言兼容、性能、网关、Streaming、gRPC 等方面最均衡的协议实现，官方推荐。 dubbo 高 低 不支持 支持（Java、Go） Java Interface 性能最高的私有协议，但前端流量接入、多语言支持等成本较高 rest 低 高 不支持 支持 Java Interface rest 协议在前端接入、互通等方面具备最高的灵活性，但对比 rpc 存在性能、弱类型等缺点。注意，rest 在 dubbo3 中仅是 triple 协议的一种发布形式 注意 自 3.</description></item><item><title>应用级服务发现基准测试</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/performance/benchmarking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/performance/benchmarking/</guid><description>1 Benchmark 结论 对比 2.x 版本，Dubbo3 版本
服务发现资源利用率显著提升。 对比接口级服务发现，单机常驻内存下降 50%，地址变更期 GC 消耗下降一个数量级 (百次 -&amp;gt; 十次) 对比应用级服务发现，单机常驻内存下降 75%，GC 次数趋零 以下是详细压测过程与数据
2 应用级服务发现（地址推送链路） 此部分压测数据是由工商银行 Dubbo 团队基于内部生产数据给出，压测过程模拟了“生产环境地址+zookeeper”的服务发现架构。
2.1 环境 描述 压测数据 提供者500运行实例✖️8interface✖️5protocol，即每个提供者向注册中心注册40个URL，总计20000个URL，每个URL字符长度约1k。注册中心2个独立zookeeper注册中心，服务提供者消费者采用并行配置。消费者配置1c2g，xmx=768，开启GC，从2个注册中心订阅，每5秒调用一次服务。运行20小时。 压测环境 Java version &amp;ldquo;1.8.0&amp;rdquo;Java(TM) SE Runtime Enviroment (build pxa6480sr3fp12-20160919_01(SR3 FP12))IBM J9 VM (Build 2.8, JRE 1.8.0 Linux amd64-64 Compressed References 20160915_318796, JIT enabled, AOT enabled) 2.2 数据分析 图一 服务发现模型内存占用变化
Dubbo3 接口级服务发现模型，常驻内存较 2.x 版本下降约 50% Dubbo3 应用级服务发现模型，常驻内存较 2.x 版本下降约 75% 图二 服务发现模型 GC 变化</description></item><item><title>应用启动失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/troubleshoot/start-failed/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/troubleshoot/start-failed/</guid><description>在开发与生产部署过程中，由于各种非预期的变更，可能会出现应用无法启动的情况。对于 Dubbo 来说，通常启动失败时都会有类似以下的报错信息。
Caused by: java.lang.IllegalStateException: Dubbo Module[1.1.1] is stopping or stopped, can not start again [DUBBO] Dubbo Application[1.1](first-dubbo-consumer) start failure 一句话总结 正确配置日志输出，往前翻到第一个报错的位置并进行处理。
排查方式 1 配置日志输出 目前 Dubbo 支持多种日志框架，如果环境中存在多种日志框架的支持（如 log4j 和 logback），Dubbo 会按照 （log4j &amp;gt; slf4j &amp;gt; log4j2 &amp;gt; jcl）的顺序输出日志框架。
如果与预期的日志框架不同时，会出现日志无法输出的问题。此时可以通过以下的配置进行调整：
dubbo.application.logger=slf4j 注：3.2.0 及以上的版本中将自动分析日志框架是否存在配置，优选日志框架输出。
2 找到真正的报错信息 在正确配置日志输出之后，可以在日志中搜索 [DUBBO] Model start failed 或者 start failure 关键字，查看真正导致 Dubbo 启动失败的原因。
如下所示，启动失败的原因为有服务订阅找不到提供者。
[27/02/23 12:49:18:018 CST] main ERROR deploy.DefaultModuleDeployer: [DUBBO] Model start failed: Dubbo Module[1.1.1] start failed: java.</description></item><item><title>元数据中心概述</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/metadata-center/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/metadata-center/overview/</guid><description>元数据中心为 Dubbo 中的两类元数据提供了存取能力
1 地址发现元数据，用于应用级服务发现 2 服务运维元数据，用于外围运维系统如可视化控制台进行服务查询、测试等。 1 地址发现元数据 Dubbo3 中引入了 应用级服务发现机制 用来解决异构微服务体系互通与大规模集群实践的性能问题，应用级服务发现将全面取代 2.x 时代的接口级服务发现。 同时为了保持 Dubbo 面向服务/接口的易用性、服务治理的灵活性，Dubbo 围绕应用级服务发现构建了一套元数据机制，即 接口 - 应用映射关系 与 接口配置元数据。
1.1 接口 - 应用映射关系 Dubbo 一直以来都能做到精确的地址发现，即只订阅 Consumer 声明要关心的服务及相关的地址列表，相比于拉取/订阅全量地址列表，这样做有很好的性能优势。 在应用级服务发现模型中，想做到精确地址订阅并不容易，因为 Dubbo Consumer 只声明了要消费的接口列表，Consumer 需要能够将接口转换为 Provider 应用名才能进行精准服务订阅，
为此，Dubbo 需要在元数据中心维护这一份 接口名-&amp;gt;应用名 的对应关系，Dubbo3 中通过 provider 启动的时候主动向元数据中心上报实现。 接口 (service name) - 应用 (Provider application name) 的映射关系可以是一对多的，即一个 service name 可能会对应多个不同的 application name。
以 zookeeper 为例，映射关系保存在以下位置:
$ ./zkCli.sh $ get /dubbo/mapping/org.apache.dubbo.demo.DemoService $ demo-provider,two-demo-provider,dubbo-demo-annotation-provider ① 节点路径是 /dubbo/mapping/{interface name}</description></item><item><title>源码构建</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/build/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/build/</guid><description>代码签出 通过以下的这个命令签出最新的项目源码 1：
git clone https://github.com/apache/dubbo.git 分支 我们使用 master 作为主干版本的开发，使用分支作为维护版本。可以通过 https://github.com/apache/dubbo/tags 来查看所有版本的标签。
构建 Dubbo 使用 maven 作为构建工具。
要求
Java 1.8 以上的版本 Maven 2.2.1 或者以上的版本 构建之前需要配置以下的 MAVEN_OPTS
export MAVEN_OPTS=-Xmx1024m -XX:MaxPermSize=512m 使用以下命令做一次构建
mvn clean install 可以通过以下的构建命令来跳过单元测试
mvn install -Dmaven.test.skip 构建源代码 jar 包 通过以下命令以构建 Dubbo 的源代码 jar 包
mvn clean source:jar install -Dmaven.test.skip 并且修改你的样例项目中的 dubbo 依赖为本地仓库的 SANPSHOT 版本，然后使用远程 debug 来调试 dubbo。
IDE 支持 使用以下命令来生成 IDE 的工程
Intellij Idea mvn idea:idea eclipse mvn eclipse:eclipse 在 eclipse 中导入</description></item><item><title>Apache 提交者注册流程</title><link>https://dubbo.apache.org/zh-cn/contact/committer/new-committer-guide_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/contact/committer/new-committer-guide_dev/</guid><description>一、Apache 提交者的产生 项目孵化初始化提交者 项目孵化阶段，在孵化项目提案中，会有初始化提交者列表这一选项。确认你是初始化提交者的一员。项目在 apache 孵化器社区投票通过后，提交者可以开始准备注册账户了。可以参看孵化器 wiki
活跃的贡献者被选举为提交者 在后期的开发过程中，活跃的贡献者可以被选举为提交者。见如何成为 committer
二、个人开发者提交 ICLA 1、选择 apache id 在 apache 提交者列表页查看已经注册过的 apache id，
2、个人提交者授权协议（ICLA）： 下载 ICLA 模板，查找可用的 id。将 icla.pdf 个人信息填写正确后打印,签名、扫描、并当做附件发送邮件给秘书 secretary@apache.org，秘书会帮忙创建 apache 用户 id。同时会创建一个 your_id@apache.org 的邮箱，可以在 apache 提交者列表页查看查找用户是否已经创建。
3、导师帮助提交用户id创建请求 导师将帮助提交 apache 账户创建请求给 root 邮件组，会有人帮助建立 id。一般需要2天时间账户会建立，请等待并在 apache 提交者列表页查看查找用户是否已经创建。
三、加入apache开发者组 登陆 Apache 账户工具，在登陆页面点击&amp;quot;忘记密码&amp;quot;设置始化密码，会有一封密码重置邮件发送到 forward 邮箱(在孵化项目提案中提交的开发者邮件) 关于 apache 邮箱：apache.org 邮箱并没有自己的邮件内容存储服务器。它需要借用其他邮件提供商的邮件内容存储、分发功能。在很多投票环节是建议使用 apache 邮箱的。 这里就有一个问题，怎么在其它邮箱里面配置 apache.org 邮箱转发功能： 收件箱：收取发送到 apache.org 的邮件。这个在第一步配置好 Apache 账户工具的 forward 邮箱就可以用 forward 邮箱收取邮件了 发件箱：将发出的邮件显示发件邮箱为 apache.org 邮箱。请参考：设置 apache 邮箱指南和 gmail 邮箱设置方式。 其他邮箱服务的设置方式不方便找到，gmail 的最方便，建议换成 gmail 邮箱(不是广告)。 修改编辑页面的 homepage url，apache 提交者列表页中你的账户能加主页链接。 修改编辑页面的 github 账户(username)，提交确认后两个小时内会有邮件邀请你加入 github.</description></item><item><title>注册中心</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/sourcecode/registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/sourcecode/registry/</guid><description>Dubbogo 为注册中心抽象了一套接口如下：
// Registry Extension - Registry type Registry interface { common.Node // Register is used for service provider calling, register services // to registry. And it is also used for service consumer calling, register // services cared about, for dubbo&amp;#39;s admin monitoring. Register(url *common.URL) error // UnRegister is required to support the contract: // 1. If it is the persistent stored data of dynamic=false, the // registration data can not be found, then the IllegalStateException // is thrown, otherwise it is ignored.</description></item><item><title>注册中心概述</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/overview/</guid><description>注册中心是 Dubbo 服务治理的核心组件，Dubbo 依赖注册中心的协调实现服务（地址）发现，自动化的服务发现是微服务实现动态扩缩容、负载均衡、、流量治理的基础。Dubbo 的服务发现机制经历了 Dubbo2 时代的接口级服务发现、Dubbo3 时代的应用级服务发现，具体可参见 服务发现机制 解析了解具体演进过程。
基本使用 开发应用时可以指定 Dubbo 注册中心（registry）组件，配置很简单，只需指定注册中心的集群地址即可：
以 Spring Boot 开发为例，在 application.yml 增加 registry 配置项目
dubbo registry address: {protocol}://{cluster-address} 其中，protocol 为选择的配置中心类型，cluster-address 为访问注册中心的集群地址，如
address: nacos://localhost:8848
如需集群格式地址可使用 backup 参数
address: nacos://localhost:8848?backup=localshot:8846,localshot:8847
流的语义保证 3.3.0 及之后的版本可不配置注册中心。而在 3.3.0 版本之前的 Dubbo 应用必须指定注册中心配置，即使不启用注册中心也要配置（可通过设置地址为空 address=&amp;lsquo;N/A&amp;rsquo; ）。 每个注册中心组件有自己特有的配置，可以用来控制命名空间、分组、鉴权等，具体可以参考 registry 配置参考手册或通过 parameters 参数进行扩展。
配置中心与元数据中心 配置中心、元数据中心是实现 Dubbo 高阶服务治理能力会依赖的组件，如流量管控规则等，相比于注册中心通常这两个组件的配置是可选的。
需要注意的是，对于部分注册中心类型（如 Zookeeper、Nacos 等），Dubbo 会默认同时将其用作元数据中心和配置中心（建议保持默认开启状态）。
dubbo registry address: nacos://localhost:8848 框架解析后的默认行为：
dubbo registry address: nacos://localhost:8848 config-center address: nacos://localhost:8848 metadata-report address: nacos://localhost:8848 如果您不想使用 nacos 作为配置中心，可以通过以下两个参数来调整或控制默认行为：</description></item><item><title>3.x 升级与兼容性指南</title><link>https://dubbo.apache.org/zh-cn/docs/migration/migration-and-compatibility-guide/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/migration/migration-and-compatibility-guide/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
无需改动任何代码，直接升级到 Dubbo 3.0。
在 3.0 版本的设计与开发之初，我们就定下了兼容老版本 Dubbo 用户（2.5、2.6、2.7）的目标。因此，往 3.0 版本的升级过程将会是完全透明的，用户无需做任何业务改造，升级 3.x 后的框架行为将保持与 2.x 版本完全一致。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 但也要注意，透明升级仅仅是通往 3.0 的第一步，因为 &amp;ldquo;框架行为保持一致&amp;rdquo; 也就意味着用户将无法体验到 3.0 的新特性。如果要启用 3.0 的带来的新特性，用户则需要进行一定的改造，我们称这个过程为迁移，这是一个按需开启的过程。
因此，对老用户而言，有两条不同的迁移路径：
分两步走，先以兼容模式推动业务升级到 3.0 版本（无需改造），之后在某些时机按需启用新特性（按需改造）； 升级与迁移同步完成，在业务升级到 3.0 版本的同时，完成改造并启用新特性； Dubbo 3.0 提供的新特性包括：
新的地址发现模型（应用级服务发现）。 查看应用级服务发现的迁移步骤 查看应用级服务发现的使用方式 查看应用级服务发现设计与实现。 下一代基于 HTTP/2 的 Triple 协议。 查看Triple 协议迁移步骤 查看 Triple 协议使用方式 查看 Triple 协议设计与实现。 统一的路由规则。 查看统一路由规则的迁移步骤 查看统一路由规则使用方式 查看统一路由规则设计与实现</description></item><item><title>使用 Apache APISIX 代理 Dubbo 服务（triple协议）</title><link>https://dubbo.apache.org/zh-cn/blog/2024/04/22/%E4%BD%BF%E7%94%A8-apache-apisix-%E4%BB%A3%E7%90%86-dubbo-%E6%9C%8D%E5%8A%A1triple%E5%8D%8F%E8%AE%AE/</link><pubDate>Mon, 22 Apr 2024 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2024/04/22/%E4%BD%BF%E7%94%A8-apache-apisix-%E4%BB%A3%E7%90%86-dubbo-%E6%9C%8D%E5%8A%A1triple%E5%8D%8F%E8%AE%AE/</guid><description>关于如何用网关代理 triple 协议服务的原理介绍，请参见 HTTP 网关接入 一节文档。
本文我们使用 Apache APISIX + triple 协议 + Nacos 注册中心 的组合，演示如何使用 Apache APISIX 代理 Dubbo 服务。
示例应用说明 本示例完整源码与部署资源文件可查看 dubbo-samples-gateway-triple-apisix，示例架构图如下：
在该示例中定义并发布了一个 org.apache.dubbo.samples.gateway.apisix.DemoService 的 triple 服务，接口定义为：
public interface DemoService { String sayHello(String name); } 接口实现如下：
@DubboService public class DemoServiceImpl implements DemoService { @Override public String sayHello(String name) { return &amp;#34;Hello &amp;#34; + name; } } Dubbo服务相关配置：
dubbo: application: name: gateway-apisix-triple registry: address: nacos://${nacos.address:127.0.0.1}:8848 username: nacos password: nacos protocol: name: tri port: 50052 部署应用 在 本地下载并启动 Nacos</description></item><item><title>工商银行 Dubbo3 应用级服务发现实践</title><link>https://dubbo.apache.org/zh-cn/blog/2023/01/15/%E5%B7%A5%E5%95%86%E9%93%B6%E8%A1%8C-dubbo3-%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%AE%9E%E8%B7%B5/</link><pubDate>Sun, 15 Jan 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/01/15/%E5%B7%A5%E5%95%86%E9%93%B6%E8%A1%8C-dubbo3-%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%AE%9E%E8%B7%B5/</guid><description>问题分析 以下是经典的 Dubbo 的工作原理图，服务提供者和消费者通过注册中心协调实现地址的自动发现。
工商银行面临的主要瓶颈是在注册中心与服务消费端，接口级别地址的数量已经是亿级规模，一方面存储容量达到瓶颈、另一方面推送效率明显下降；而在消费端这一侧，Dubbo2 框架常驻内存已超 40%，每次地址推送带来的 cpu 等资源消耗率也非常高，影响正常的业务调用。
这是 Dubbo2 接口级服务发现架构在大规模集群场景下的固有问题（具体原因请查看应用级服务发现原理解析），通过常规的性能优化无法从根本上解决问题。因此工商银行采用了 Dubbo3 中提出的应用级服务发现模型，经过实测，新的服务发现模型能实现节点到注册中心间数据传输量 90% 的下降，这就使得注册中心的压力极大降低，同时消费端的框架常驻内存也实现超 50% 下降。
压测数据 下面是工商银行联合 Dubbo 社区给出的一组基于真实服务特点给出的模拟压测数据。
上图是对使用了应用级服务发现的消费端进程采样的内存对比数据。其中横轴是不同的 Dubbo 版本，纵轴是实际采样到的内存表现，可以看到 Dubbo 2.6、2.7 版本表现几乎一致，而升级到 3.0 版本后，即使不升级应用级服务发现，内存也降低接近 40%，而当切换到应用级服务发现之后，内存占用下降到只有原来的 30%。
上图是消费端的 GC 情况统计，同样的，横轴是不同的 Dubbo 版本，纵轴是实际采样到的 GC 表现。这里的压测数据，是通过模拟注册中心不停的往消费端进程推送地址列表的场景得到的。可以看到 Dubbo 2.6、2.7 版本表现几乎一致，而在 3.0 版本中切换到应用级服务发现之后，GC 已经趋近于零次。</description></item><item><title>0-2 - 非法属性值</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/2/</guid><description>可能的原因 这个提示是指用户配置的值与属性本身所需的数据类型并不匹配。比如 dubbo.comsumer.threads 属性只能接受数值属性，但是用户所输入的值混入了字母。
排查和解决步骤 根据配置项参考手册，查找出错的配置项，检查该项指定的类型，检查是否出现类型不一致的情况。</description></item><item><title>2-2 - 没有可用的 Provider（地址找不到）</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/2/</guid><description>可能的原因 Provider 服务没启动，或者注册中心（比如 ZooKeeper，Nacos，Consul）宕机了。 Dubbo 的服务配置有误差，必须保证服务名，组别 （默认是 Dubbo），version 三者都正确。 访问的环境有误：通常我们会有开发环境、测试环境、线上生产环境等多套环境。有时候发布的服务到了测试环境，而访问调用时却走了开发环境。 排查和解决步骤 访问注册中心的 Ops 系统，查询对应的服务是否有提供者列表；同时检查调用者应用所在服务器的日志(一般每种注册服务的客户端都会有对应的日志记录)，查看是否有地址信息的推送/拉取记录。 如无，则表明发布者发布服务失败，检查发布者的应用启动是否成功。 如有服务，则检查调用者应用所连接的注册中心，确认跟预期的环境要匹配。 如上述都没有问题，检查是否配置了路由过滤的规则等。 这个错误码的 FAQ 页面参考了空冥同学的 《Dubbo 常见错误及解决方法》 。
所引文章通过 CC-BY-4.0 协议赋予了汇编的权利。在此向原作者表示感谢。</description></item><item><title>3-2 - 发布或推送服务失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/3/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/3/2/</guid><description>可能的原因 注册中心无法连接。 注册中心无法对外提供服务。 排查和解决步骤 服务与注册中心网络是否正常。 注册中心是否正常启动，并可通过第三方工具进行连接。 服务引用的版本与注册中心的版本是否存在版本兼容性问题。</description></item><item><title>3.0 升级至 3.1</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/upgrades-and-compatibility/version/3.0-to-3.1-compatibility-guide/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/upgrades-and-compatibility/version/3.0-to-3.1-compatibility-guide/</guid><description>功能修改点 1. Nacos Group 对齐（应用级服务发现） 在 Dubbo 2.7.x 中，配置在 Nacos Registry URL 上的 group 值是对齐 Nacos 注册中心中的 group 分组的。（group 可以当成类似 namespace 的软隔离）
在 Dubbo 3.0.x 中，配置在 Nacos Registry URL 上的 group 默认不使用，全部使用 DEFAULT_GROUP。（group 不再提供隔离功能）
在 Dubbo 3.1.x 中，配置在 Nacos Registry URL 上的 group 值将会重新对齐 Nacos 注册中心中的 group 分组的。
注意事项：
请检查注册中心 URL 上是否已经配置了 group 属性，如果是的话需要检查服务端和消费端的 group 是否都一致，如果不一致请修改为一致 如果不希望 group 重新对齐到 Nacos 注册中心中的 group 分组，可以配置 dubbo.nacos-service-discovery.use-default-group=false 全局属性值忽略该功能</description></item><item><title>4-2 - 序列化优化器初始发生错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/2/</guid><description>可能的原因 当前使用了 Kryo 和 FST 的序列化配置。
排查和解决步骤 Kryo 和 FST 序列化</description></item><item><title>5-2 - 注册/注销关闭钩子方法失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/2/</guid><description>可能的原因 自定义钩子方法,业务处理逻辑存在异常。
排查和解决步骤 检查自定义钩子方法，业务处理逻辑是否存在运行时异常。</description></item><item><title>6-2 - 客户端超时</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/2/</guid><description>超时是调用端发生在请求发出后，无法在指定的时间内获得对应的响应。
可能的原因 服务端确实处理比较慢，无法在指定的时间返回结果，调用端就自动返回一个超时的异常响应来结束此次调用。 服务端如果响应的比较快，但当客户端 Load 很高，负载压力很大的时候，会因为客户端请求发不出去、响应卡在 TCP Buffer 等问题，造成超时。因为客户端接收到服务端发来的数据或者请求服务端的数据，都会在系统层面排队，如果系统负载比较高，在内核态的时间占比就会加长，从而造成客户端获取到值时已经超时。 通常是业务处理太慢，可在服务提供方机器上执行：jstack [PID] &amp;gt; jstack.log 分析线程都卡在哪个方法调用上，这里就是慢的原因。如果不能调优性能，请调高 timeout 阈值。 排查和解决步骤 两边可能有 GC，检查服务端和客户端 GC 日志，耗时很长的 GC，会导致超时。超时的发生很可能意味着调用端或者服务端的资源（CPU，内存或者网络）出现了瓶颈，需要检查服务端的问题还是调用端的问题来排除 GC 抖动等嫌疑。 检查服务端的网络质量，比如重传率来排除网络嫌疑。 借助链路跟踪的分析服务（比如阿里的 ARMS ，开源的 OpenTracing 系的实现 Zipkin 、SkyWalking 等）来分析下各个点的耗时情况。 这个错误码的 FAQ 页面参考了空冥同学的 《Dubbo 常见错误及解决方法》 。 所引文章通过 CC-BY-4.0 协议赋予了汇编的权利。在此向原作者表示感谢。</description></item><item><title>7-2 - QOS 已开启</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/7/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/7/2/</guid><description>可能的原因 QOS 已开启，默认为开启状态。
排查和解决步骤 请参考QOS 操作手册。</description></item><item><title>81-2 - ZK 销毁异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/81/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/81/2/</guid><description>可能的原因 当前实例已销毁完成。 网络或已断开。
排查和解决步骤 可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>99-1 - 程序被打断</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/99/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/99/1/</guid><description>Dubbo 内部的未知错误。
可能的原因 程序收到来自 JVM 层面的打断通知，被迫停止阻塞等待
排查和解决步骤 此异常通常发生在线程池关闭或者应用关闭的过程中。 请检查是否影响业务正常使用，如无影响可以忽略，如果有影响请参照对应的排查手册。 更多的排查思路可以参考 99-0 一文。</description></item><item><title>API 配置</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config/api/api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config/api/api/</guid><description>作为一款 RPC 框架，Dubbo 定义了一套完善的 API 接口，我们可以基于原生 API 开发 Dubbo 应用，关于如何使用原生API开发轻量RPC、微服务应用等的具体示例可查看 使用教程 - API开发模式 中的示例。它的适用场景包括以下两类：
轻量 RPC Server &amp;amp; Client，通常用于一些应用内、基础组件、中间件等内的简单远程调用场景 微服务应用，不依赖 Spring、Spring Boot 的情况下，直接用 API 开发微服务；同时，直接使用 API 对于一些网关或测试平台集成场景也可能比较有用。 目前的入口 API 主要有 Bootstrap、ServiceConfig、ReferenceConfig 等，分别用于不同场景下的 Dubbo 应用开发。
Bootstrap API DubboBootstrap 实例代表一个 Dubbo 应用，是整个 Dubbo 应用的启动入口。在 DubboBootstrap 基础上，我们可以设置 protocol、service、registry、metrics 等来注册服务、连接注册中心等，这和我们在 Spring Boot 中调整 application.yml 或者 application.properties 文件是对等的作用。
官方推荐使用 DubboBootstrap.start() 作为应用的集中启动入口，但为了方便在进程启动后，在运行态单独发布一些服务，Dubbo 也允许直接调用 ServiceConfig.export() 或 ReferenceConfig.refer() 方法发布服务，这时 Service/Reference 会注册到默认的 DubboBootstrap 实例中，效果同调用 DubboBootstrap.service(&amp;hellip;).start() 类似。
import org.apache.dubbo.config.bootstrap.DubboBootstrap; import org.</description></item><item><title>CLA 签署向导</title><link>https://dubbo.apache.org/zh-cn/contact/committer/cla-signing-guide_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/contact/committer/cla-signing-guide_dev/</guid><description>以下情况，需要您签署 Apache ICLA：
在 Dubbo 被捐赠给 Apache 之前，您已经为 Dubbo 作出了很多贡献，并且您以前没有签署过 Alibaba-CLA。 您已经为 Dubbo 作出了很多贡献，并且您被邀请成为 Dubbo 提交者，且之前没有签署过 Alibaba-CLA 或者 Apache ICLA。 步骤 下载这篇 pdf 文档 编辑该文档，在必要的空格处填上适当的内容 打印 在打印好的文件上签字 扫描 发送一封邮件到secretary@apache.org，并抄送给private@dubbo.apache.org： 邮件标题为 “ICLA submission” 请在邮件正文附上您的github账号链接 请记得将您的 ICLA 文档放入邮件的附件里 空格填写必要说明 Mailing address：首选英文格式的公司地址 Preferred apache id(s)：如果您被邀请成为一名提交者，那么需要您填写一个apache账号，否则，可以不填 Notify project：Dubbo（意思就是Dubbo就是通知您签署ICLA的项目）</description></item><item><title>Debug参考文档</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/mesh/mesh/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/mesh/mesh/</guid><description>前置环境准备 docker环境 kubernetes环境（推荐docker desktop，图形化界面，还内嵌了一个小型的Kubernetes环境，后文演示也是基于docker desktop） istio环境 dubbo-samples代码，master分支即可 dubbo 版本 &amp;gt;= 3.1.0 搭建 Kubernetes 环境 目前 Dubbo 仅支持在 Kubernetes 环境下的 Mesh 部署，所以在运行启动本示例前需要先搭Kubernetes 环境。(建议采用docker desktop进行搭建，直接就可以运行一个kubernetes环境) https://docs.docker.com/desktop/install/mac-install/ 搭建 Kubernetes 环境 目前 Dubbo 仅支持在 Kubernetes 环境下的 Mesh 部署，所以在运行启动本示例前需要先搭Kubernetes 环境。(建议采用docker desktop进行搭建，直接就可以运行一个kubernetes环境) https://docs.docker.com/desktop/install/mac-install/
搭建 Istio 环境 搭建 Istio 环境参考文档： Istio 安装文档(https://istio.io/latest/docs/setup/getting-started/) 注：安装 Istio 的时候需要开启 first-party-jwt 支持（使用 istioctl 工具安装的时候加上 &amp;ndash;set values.global.jwtPolicy=first-party-jwt 参数），否则将导致客户端认证失败的问题。 附安装命令参考：
curl -L https://istio.io/downloadIstio | sh - cd istio-1.xx.x export PATH=$PWD/bin:$PATH istioctl install --set profile=demo --set values.</description></item><item><title>Dubbo 管理控制台介绍</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/admin/ops/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/admin/ops/introduction/</guid><description>目前的管理控制台已经发布 0.1 版本，结构上采取了前后端分离的方式，前端使用 Vue 和 Vuetify 分别作为 Javascript 框架和UI框架，后端采用 Spring Boot 框架。既可以按照标准的 Maven 方式进行打包，部署，也可以采用前后端分离的部署方式，方便开发，功能上，目前具备了服务查询，服务治理(包括 Dubbo 2.7 中新增的治理规则)以及服务测试三部分内容。
Maven方式部署 安装 git clone https://github.com/apache/dubbo-admin.git cd dubbo-admin mvn clean package cd dubbo-admin-distribution/target java -jar dubbo-admin-0.1.jar 访问 http://localhost:8080
前后端分离部署 前端 cd dubbo-admin-ui npm install npm run dev 后端 cd dubbo-admin-server mvn clean package cd target java -jar dubbo-admin-server-0.1.jar 访问 http://localhost:8081
前后端分离模式下，前端的修改可以实时生效 配置: 1 配置文件为：
dubbo-admin-server/src/main/resources/application.properties 主要的配置有：
admin.config-center=zookeeper://127.0.0.1:2181 admin.registry.address=zookeeper://127.0.0.1:2181 admin.metadata-report.address=zookeeper://127.0.0.1:2181 三个配置项分别指定了配置中心，注册中心和元数据中心的地址，关于这三个中心的详细说明，可以参考这里。
也可以和 Dubbo 2.7 一样，在配置中心指定元数据和注册中心的地址，以 zookeeper 为例，配置的路径和内容如下:</description></item><item><title>dubbo-pilot Control Plane 部署</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/dev/dubbo-pilot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/dev/dubbo-pilot/</guid><description>1.总体目标 2.基本流程 3.详细步骤 3.1 环境要求 3.2 istio 本地部署 3.2.1 编译 3.2.2 部署 &amp;amp; debug 3.3 istio 容器部署 3.3.1 编译 3.3.2 部署 &amp;amp; debug 1 总体目标 控制面编译和镜像构建 使用 istioctl 在 kubernetes 环境部署 如何对控制面程序 debug 2 基本流程 这个例子将演示如何在编译 dubbo-pilot 控制平面并在 kubernetes 环境下如何使用 istioctl 进行部署 本地启动控制平面，对 dubbo-pilot 进行启动和 debug 使用 istioctl 在 k8s 环境启动和 debug 3 详细步骤 3.1 环境要求 Golang Docker Minikube/Kind Kubectl Dlv 3.2 本地部署 3.2.1 编译 编译 docker-builder cd dubbo-go-pixiu/tools/docker-builder &amp;amp;&amp;amp; go install docker-builder -h: Builds Istio docker images Usage: [flags] Flags: --architecures strings architectures to build (default [linux/amd64]) --base-version string base version to use (default &amp;#34;latest&amp;#34;) --builder string type of builder to use.</description></item><item><title>Dubbo2 协议规范</title><link>https://dubbo.apache.org/zh-cn/overview/reference/protocols/tcp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/protocols/tcp/</guid><description>协议规范 Specification Magic - Magic High &amp;amp; Magic Low (16 bits)
标识协议版本号，Dubbo 协议：0xdabb
Req/Res (1 bit)
标识是请求或响应。请求： 1; 响应： 0。
2 Way (1 bit)
仅在 Req/Res 为1（请求）时才有用，标记是否期望从服务器返回值。如果需要来自服务器的返回值，则设置为1。
Event (1 bit)
标识是否是事件消息，例如，心跳事件。如果这是一个事件，则设置为1。
Serialization ID (5 bit)
标识序列化类型：比如 fastjson 的值为6。
Status (8 bits)
仅在 Req/Res 为0（响应）时有用，用于标识响应的状态。
20 - OK 30 - CLIENT_TIMEOUT 31 - SERVER_TIMEOUT 40 - BAD_REQUEST 50 - BAD_RESPONSE 60 - SERVICE_NOT_FOUND 70 - SERVICE_ERROR 80 - SERVER_ERROR 90 - CLIENT_ERROR 100 - SERVER_THREADPOOL_EXHAUSTED_ERROR Request ID (64 bits)</description></item><item><title>通过网关将 http 流量接入 Dubbo 后端服务</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/gateway/dubbo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/gateway/dubbo/</guid><description>由于 dubbo 协议是基于 TCP 的二进制私有协议，因此更适合作为后端微服务间的高效 RPC 通信协议，这也导致 dubbo 协议对于前端流量接入不是很友好。在 Dubbo 框架中，有两种方式可以帮助开发者解决这个问题：
多协议发布【推荐】，为 dubbo 协议服务暴露 rest 风格的 http 协议访问方式，这种模式架构上会变得非常简单，通用的网关产品即可支持。 通过网关实现 http-&amp;gt;dubbo 协议转换，这种方式需要将 http 协议转换为后端服务能识别的 dubbo 协议，要求网关必须支持 dubbo 协议。 同时发布 http、dubbo 协议 如果我们能让一个服务同时发布 dubbo、http 协议，这样后端调用是基于高效的 dubbo 二进制协议，同时浏览器、web服务等前端设施也可以用 http 协议访问到相同的服务。 好消息是，Dubbo 框架支持为同一个服务发布多个协议，并且支持客户端通过同一个端口以不同的协议访问服务，如下所示：
为了实现同时发布 dubbo、http 协议，我们只需要在配置文件中增加一行配置即可：
dubbo: protocol: dubbo: dubbo port: 20880 ext-protocol: tri 增加 ext-protocol: tri 配置后，进程就可以在 20880 端口上提供 http 服务了，这点我们从之前的 triple 协议中有过具体了解了，启用应用后就可以在 20880 端口访问：
curl \ --header &amp;#34;Content-Type: application/json&amp;#34; \ --data &amp;#39;[&amp;#34;Dubbo&amp;#34;]&amp;#39; \ http://localhost:20880/org.</description></item><item><title>基于 TCP 的 RPC 通信协议 - dubbo</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/dubbo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/dubbo/</guid><description>本示例演示了如何开发基于 dubbo 协议通信的服务，可在此查看 本示例的完整代码：
注意 为了保证老版本兼容性，Dubbo 3.3.0 及之前版本的默认协议都是 dubbo。但如果您是新用户，正在考虑使用 Dubbo 构建一套全新的微服务系统，我们推荐您在应用中明确配置使用 triple 协议。 运行示例 你可以跟随以下步骤，尝试运行本文档对应的示例源码。
首先，可通过以下命令下载示例源码
git clone --depth=1 https://github.com/apache/dubbo-samples.git 进入示例源码目录：
cd dubbo-samples/2-advanced/dubbo-samples-dubbo 使用 maven 打包示例：
mvn clean install -DskipTests 启动提供者 运行以下命令启动提供者：
java -jar ./dubbo-samples-dubbo-provider/target/dubbo-samples-dubbo-provider-1.0-SNAPSHOT.jar 启动消费者 运行以下命令：
java -jar ./dubbo-samples-dubbo-consumer/target/dubbo-samples-dubbo-consumer-1.0-SNAPSHOT.jar 源码讲解 定义服务 首先是服务定义，使用 dubbo 协议时，我们首选需要通过 Java Interface 定义 Dubbo 服务。
public interface DemoService { String sayHello(String name); } 服务提供者 其次，对于提供者一侧而言，需要提供服务的具体实现。
@DubboService public class DemoServiceImpl implements DemoService { @Override public String sayHello(String name) { return &amp;#34;Hello &amp;#34; + name; } } 配置使用 dubbo 协议：</description></item><item><title>Filter</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/extensibility/filter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/extensibility/filter/</guid><description>在 RPC框架 - Filter请求拦截 一节中，我们了解了 Filter 的工作机制，以及 Dubbo 框架提供的一些内置 Filter 实现。在本文中，我们来了解如何扩展自定义的过滤器实现：一个可以对返回的结果进行统一的处理、验证等统一 Filter 处理器，减少对开发人员的打扰。
本示例的完整源码请参见 dubbo-samples-extensibility。除了本示例之外，Dubbo 核心仓库 apache/dubbo 以及扩展库 apache/dubbo-spi-extensions 中的众多 Filter 实现，都可以作为扩展参考实现。
任务详情 对所有调用Provider服务的请求在返回的结果的后面统一添加's customized AppendedFilter。
实现方式 在Provider中自定义一个Filter，在Filter中修改返回结果。
代码结构 src |-main |-java |-org |-apache |-dubbo |-samples |-extensibility |-filter |-provider |-AppendedFilter.java (实现Filter接口) |-resources |-META-INF |-application.properties (Dubbo Provider配置文件) |-dubbo |-org.apache.dubbo.rpc.Filter (纯文本文件) 代码详情 package org.apache.dubbo.samples.extensibility.filter.provider; import org.apache.dubbo.rpc.Filter; import org.apache.dubbo.rpc.Result; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.RpcException; import org.apache.dubbo.rpc.AsyncRpcResult; public class AppendedFilter implements Filter { @Override public Result invoke(Invoker&amp;lt;?</description></item><item><title>Grafana</title><link>https://dubbo.apache.org/zh-cn/overview/reference/integrations/grafana/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/integrations/grafana/</guid><description>Grafana 是一种开源的监控解决方案，可用于为 Dubbo 配置可视化仪表板，您可以使用 Grafana 来监控 Dubbo 集群的运行状况。
配置可视化控制面板 以下是 Dubbo 社区提供的默认指标面板，您配置好数据源并直接导入使用即可。如果默认面板不能满足要求，您还可以自定义 Grafana 面板。
Apache Dubbo Observability Dashboard： JVM (Micrometer) Dashboard： 您可以通过以下几种方式快速的导入 Grafana 监控面板。
方式一：Kubernetes 安装 你可以使用 Dubbo 社区提供的示例配置快速安装 Grafana，安装后的 Grafana 提供了社区默认指标面板视图。
kubectl create -f https://raw.githubusercontent.com/apache/dubbo-kubernetes/master/deploy/kubernetes/grafana.yaml 你可能需要端口映射获得访问地址 $ kubectl port-forward service/grafana 3000:3000，打开浏览器访问页面 http://localhost:3000。
获取登录信息
kubectl get secrets grafana -o jsonpath=&amp;#34;{.data.admin-user}&amp;#34; | base64 --decode ; echo &amp;amp;&amp;amp; kubectl get secrets grafana -o jsonpath=&amp;#34;{.data.admin-password}&amp;#34; | base64 --decode ; echo 方式二：向已经安装好的集群导入 dashboard 如果你已经有安装好的 Grafana 服务了，则还可以通过 Grafana 控制台的导入菜单 导入 dashboard。根据 Grafana 的要求，导入 dashboard 的过程中需要同时指定 Prometheus 数据源地址。</description></item><item><title>Hessian</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/dubbo/hessian/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/dubbo/hessian/</guid><description>1 介绍 Hessian序列化是一种支持动态类型、跨语言、基于对象传输的网络协议，Java对象序列化的二进制流可以被其他语言（如，c++，python）。特性如下：
自描述序列化类型。不依赖外部描述文件或者接口定义，用一个字节表示常用的基础类型，极大缩短二进制流。 语言无关，支持脚本语言 协议简单，比Java原生序列化高效 相比hessian1，hessian2中增加了压缩编码，其序列化二进制流大小是Java序列化的50%，序列化耗时是Java序列化的30%，反序列化耗时是Java序列化的20%。 2 使用方式 在 Dubbo 框架中，当使用 dubbo 通信协议时，默认使用 Hessian2 作为序列化。
2.1 配置启用 # application.yml (Spring Boot) dubbo: protocol: serialization: hessian2 或
# dubbo.properties dubbo.protocol.serialization=hessian2 # or dubbo.consumer.serialization=hessian2 # or dubbo.reference.com.demo.DemoService.serialization=hessian2 或
&amp;lt;dubbo:protocol serialization=&amp;#34;hessian2&amp;#34; /&amp;gt; &amp;lt;!-- or --&amp;gt; &amp;lt;dubbo:consumer serialization=&amp;#34;hessian2&amp;#34; /&amp;gt; &amp;lt;!-- or --&amp;gt; &amp;lt;dubbo:reference interface=&amp;#34;xxx&amp;#34; serialization=&amp;#34;hessian2&amp;#34; /&amp;gt;</description></item><item><title>Istio 环境部署 Dubbo-go 应用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/deploy2/deploy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/deploy2/deploy/</guid><description>在本章节中，我们将使用应用模板快速创建一组 Dubbo-go Server和 Client 端应用，部署在 Istio 集群中；观察、调试和验证服务发现和调用成功。
1. 准备工作 dubbo-go cli 工具和依赖工具已安装、grpc_cli (如需本地调试)。 docker、helm、kubectl 环境已安装。（arm 机器需支持 docker buildx） 任务【istio 环境部署】 已完成 2. 开发 server 端 Dubbo-go 应用 2.1 使用 dubbogo-cli 创建项目模板 $ mkdir mesh-app-server $ cd mesh-app-server $ dubbogo-cli newApp . $ tree . . ├── Makefile ├── api │ └── api.proto ├── build │ └── Dockerfile ├── chart │ ├── app │ │ ├── Chart.yaml │ │ ├── templates │ │ │ ├── _helpers.</description></item><item><title>Java SDK Release 流程</title><link>https://dubbo.apache.org/zh-cn/contact/committer/release-guide/java-sdk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/contact/committer/release-guide/java-sdk/</guid><description>理解 Apache 发布的内容和流程 总的来说，Source Release 是 Apache 关注的重点，也是发布的必须内容；而 Binary Release 是可选项，Dubbo 可以选择是否发布二进制包到 Apache 仓库或者发布到 Maven 中央仓库。
请参考以下链接，找到更多关于 ASF 的发布指南:
Apache Release Guide Apache Release Policy Maven Release Info 本地构建环境准备 主要包括签名工具、Maven 仓库认证相关准备
安装GPG 详细文档请参见这里, Mac OS 下配置如下
$ brew install gpg $ gpg --version #检查版本，应该为2.x 用gpg生成key 根据提示，生成 key
$ gpg --full-gen-key gpg (GnuPG) 2.0.12; Copyright (C) 2009 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it.</description></item><item><title>部署 Dubbo 应用到 Kubernetes 环境</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/deploy/deploy-on-kubernetes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/deploy/deploy-on-kubernetes/</guid><description>这种模式与传统的非 Kubernetes 部署并无太大差异，如下图所示，仍然使用 Nacos 或者 Zookeeper 等作为注册中心，只不过将 Kubernetes 作为应用生命周期调度的底层平台。
安装 Nacos 在 Kubernetes 模式下，我们推荐使用 dubboctl 快速安装 Nacos、dubbo-control-plane、prometheus 等组件：
$ dubboctl install --profile=demo 提示 请查看 dubboctl 了解更多细节 您也可以在此了解 Nacos 官方提供的 Kubernetes 集群安装方案 部署应用 我们仍然以 快速开始 中的项目为例，演示应用打包部署的具体步骤。
首先，克隆示例项目到本地：
$ git clone -b main --depth 1 https://github.com/apache/dubbo-samples 切换到示例目录：
$ cd dubbo-samples/11-quickstart 打包镜像 $ dubboctl build # 具体写一下推送到 docker 仓库 部署 $ dubboctl deploy 以下是生成的完整 Kubernetes manifests：
执行以下命令，将应用部署到 Kubernetes 集群：
$ kubectl apply -f xxx.</description></item><item><title>metrics监控</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/observability/rpc_metrics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/observability/rpc_metrics/</guid><description>Dubbo 支持采集运行态 Metrics 指标并接入 Prometheus、Grafana 系统，实现对微服务集群的可视化监控，以下是一个具体的使用示例，可查看 示例完整源码。
Contents server/main.go - is the main definition of the service, handler and rpc server client/main.go - is the rpc client proto - contains the protobuf definition of the API How to run Run server go run ./go-server/cmd/main.go test server work as expected:
curl \ --header &amp;#34;Content-Type: application/json&amp;#34; \ --data &amp;#39;{&amp;#34;name&amp;#34;: &amp;#34;Dubbo&amp;#34;}&amp;#39; \ http://localhost:20000/greet.GreetService/Greet Run client go run ./go-client/cmd/main.go deploy to local install prometheus and open prometheus config file prometheus.</description></item><item><title>Multicast 注册中心</title><link>https://dubbo.apache.org/zh-cn/docs/references/registry/multicast/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/registry/multicast/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Multicast 注册中心不需要启动任何中心节点，只要广播地址一样，就可以互相发现。
提供方启动时广播自己的地址 消费方启动时广播订阅请求 提供方收到订阅请求时，单播自己的地址给订阅者，如果设置了 unicast=false，则广播给订阅者 消费方收到提供方地址时，连接该地址进行 RPC 调用。 组播受网络结构限制，只适合小规模应用或开发阶段使用。组播地址段: 224.0.0.0 - 239.255.255.255
配置 &amp;lt;dubbo:registry address=&amp;#34;multicast://224.5.6.7:1234&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:registry protocol=&amp;#34;multicast&amp;#34; address=&amp;#34;224.5.6.7:1234&amp;#34; /&amp;gt; 为了减少广播量，Dubbo 缺省使用单播发送提供者地址信息给消费者，如果一个机器上同时启了多个消费者进程，消费者需声明 unicast=false，否则只会有一个消费者能收到消息; 当服务者和消费者运行在同一台机器上，消费者同样需要声明unicast=false，否则消费者无法收到消息，导致No provider available for the service异常：
&amp;lt;dubbo:application name=&amp;#34;demo-consumer&amp;#34;&amp;gt; &amp;lt;dubbo:parameter key=&amp;#34;unicast&amp;#34; value=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;/dubbo:application&amp;gt; 或
&amp;lt;dubbo:consumer&amp;gt; &amp;lt;dubbo:parameter key=&amp;#34;unicast&amp;#34; value=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;/dubbo:consumer&amp;gt;</description></item><item><title>Multicast 注册中心</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/registry/multicast/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/registry/multicast/</guid><description>Multicast 注册中心不需要启动任何中心节点，只要广播地址一样，就可以互相发现。
提供方启动时广播自己的地址 消费方启动时广播订阅请求 提供方收到订阅请求时，单播自己的地址给订阅者，如果设置了 unicast=false，则广播给订阅者 消费方收到提供方地址时，连接该地址进行 RPC 调用。 组播受网络结构限制，只适合小规模应用或开发阶段使用。组播地址段: 224.0.0.0 - 239.255.255.255
配置 &amp;lt;dubbo:registry address=&amp;#34;multicast://224.5.6.7:1234&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:registry protocol=&amp;#34;multicast&amp;#34; address=&amp;#34;224.5.6.7:1234&amp;#34; /&amp;gt; 为了减少广播量，Dubbo 缺省使用单播发送提供者地址信息给消费者，如果一个机器上同时启了多个消费者进程，消费者需声明 unicast=false，否则只会有一个消费者能收到消息; 当服务者和消费者运行在同一台机器上，消费者同样需要声明unicast=false，否则消费者无法收到消息，导致No provider available for the service异常：
&amp;lt;dubbo:application name=&amp;#34;demo-consumer&amp;#34;&amp;gt; &amp;lt;dubbo:parameter key=&amp;#34;unicast&amp;#34; value=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;/dubbo:application&amp;gt; 或
&amp;lt;dubbo:consumer&amp;gt; &amp;lt;dubbo:parameter key=&amp;#34;unicast&amp;#34; value=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;/dubbo:consumer&amp;gt;</description></item><item><title>Nacos</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/metadata-center/nacos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/metadata-center/nacos/</guid><description>1 预备工作 了解 Dubbo 基本开发步骤 参考 Nacos 启动 Nacos server 当Dubbo使用3.0.0及以上版本时，需要使用Nacos 2.0.0及以上版本
2 使用说明 Dubbo 融合 Nacos 成为元数据中心的操作步骤非常简单，大致分为 增加 Maven 依赖 以及 配置元数据中心 两步。
如果元数据地址(dubbo.metadata-report.address)也不进行配置，会使用注册中心的地址来用作元数据中心。
2.1 增加 Maven 依赖 如果项目已经启用 Nacos 作为注册中心，则无需增加任何额外配置。
如果未启用 Nacos 注册中心，则请参考 为注册中心增加 Nacos 依赖。
2.2 启用 Nacos 配置中心 &amp;lt;dubbo:metadata-report address=&amp;#34;nacos://127.0.0.1:8848&amp;#34;/&amp;gt; 或者
dubbo metadata-report address: nacos://127.0.0.1:8848 或者
dubbo.metadata-report.address=nacos://127.0.0.1:8848 或者
MetadataReportConfig metadataConfig = new MetadataReportConfig(); metadataConfig.setAddress(&amp;#34;nacos://127.0.0.1:8848&amp;#34;); address 格式请参考 Nacos 注册中心 - 启用配置
3 高级配置 完整配置参数请参考 metadata-report-config。
4 工作原理 4.</description></item><item><title>OTlp</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/observability/tracing/otlp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/observability/tracing/otlp/</guid><description>概述 这个案例展示了在 Dubbo 项目中以 OpenTelemetry 作为 Tracer，将 Trace 信息上报到 Otlp Collector，再由 collector 转发至 Zipkin、Jagger。代码地址
有三部分组成：
dubbo-samples-spring-boot-tracing-otel-oltp-interface dubbo-samples-spring-boot-tracing-otel-oltp-provider dubbo-samples-spring-boot-tracing-otel-oltp-consumer 案例架构图 快速开始 安装 &amp;amp; 启动 Otlp Collector 按照 OpenTelemetry Collector Quick Start 去启动 otlp collector.
启动 Provider 直接运行org.apache.dubbo.springboot.demo.provider.ProviderApplication directly from IDE.
启动 Consumer Start org.apache.dubbo.springboot.demo.consumer.ConsumerApplication directly from IDE.
查看 Trace 信息 在浏览器中打开zipkin看板 http://localhost:9411/zipkin/ :
在浏览器中打开Jaeger看板 http://localhost:16686/search :
如何在SpringBoot项目中使用 1. 在你的项目中添加依赖 对于 SpringBoot 项目，你可以使用dubbo-spring-boot-tracing-otel-otlp-starter ：
&amp;lt;!-- OpenTelemetry as Tracer, Otlp as exporter --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description></item><item><title>Pixiu 术语</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/overview/terminology/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/overview/terminology/</guid><description>Listener 监听器 Lisnter 代表网络端口监听的能力，可以配置监听的协议类型，地址，端口。目前支持 TCP、HTTP、HTTP2 和 TRIPLE 协议。
Network Filter 网络过滤器 NetworkFilter 直接和 Listener 进行对接，代表对基础网络请求的处理，包括原始协议解析，路由解析等功能。
Http Filter &amp;amp; Dubbo Filter HTTP &amp;amp; Dubbo 过滤器 Http Filter 和 Dubbo Filter 可以看做二级 Filter，提供诸如协议转换，限流，身份认证等通用功能。
Route 路由 Route 代表请求的路由规则
Cluster 集群 Cluter 代表相同服务的集群，Endpoint 则代表服务集群中的单一服务实例。
Adapter 适配器 Adapter 则代表 Pixiu 和外界进行元数据获取的能力。能够根据服务中的服务元数据，进行路由和集群信息的动态获取。目前 Pixiu 支持两宽 Adapter，分别是从 Dubbo 集群和 Springcloud 集群获取信息。</description></item><item><title>从 Prometheus 查询 Metrics 监控指标</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/observability/prometheus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/observability/prometheus/</guid><description>准备条件 本文演示如何在 Kubernetes 环境下部署 Prometheus 并实现对 Dubbo 集群的监控数据统计与查询，你需要完成或具备以下内容：
本地或远端 Kubernetes 集群 确保 Prometheus 正确安装 部署 示例应用 并开启指标采集 使用 Prometheus dashboard 查询数据指标 确保 Prometheus 正确运行 验证 Prometheus 已经正确部署
kubectl -n dubbo-system get svc prometheus-server NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE prometheus-server ClusterIP 10.109.160.254 &amp;lt;none&amp;gt; 9090/TCP 4m 部署示例 kubectl apply -f https://raw.githubusercontent.com/apache/dubbo-samples/master/4-governance/dubbo-samples-metrics-spring-boot/Deployment.yml 等待示例应用正常运行，通过以下命令确认应用状态：
kubectl -n dubbo-demo get deployments 查询 Prometheus 获得 Prometheus 访问地址 kubectl port-forward service/prometheus-server 9090:9090， 打开浏览器，访问 localhost:9090/graph 即可打开 Prometheus 控制台。</description></item><item><title>基于 Java 接口模式开发 triple 服务时，底层的序列化机制实现</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/triple/wrapper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/triple/wrapper/</guid><description>1 介绍 Dubbo 实现的 triple 协议易用性更好（不绑定 Protobuf），开发者可以继续使用 Java 接口 直接定义服务。对于期望平滑升级、没有多语言业务或者不熟悉 Protobuf 的用户而言，Java 接口方式是最简单的使用 triple 的方式。
以下介绍这种协议模式下的底层序列化细节：框架会用一个内置的 protobuf 对象将 request 和 response 进行包装（wrapper），也就是对象会被序列化两次，第一次是使用如 serialization=hessian 指定的方式进行序列化，第二次是用 protobuf wrapper 对第一步中序列化后的 byte[] 进行包装后传输。
2 使用方式 在使用 Java 接口方式开发 triple 通信服务 的时候，dubbo server 将自动启用 protobuf、protobuf-json 序列化模式支持。
2.1 添加依赖 使用 triple 协议，必须先添加如下依赖：
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.google.protobuf&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;protobuf-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.19.6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 提供 protobuf-json 格式请求支持 --&amp;gt;&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.google.protobuf&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;protobuf-java-util&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.19.6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 2.2 配置启用 只要是基于 Java 接口方式模式使用 triple 协议 ，就会使用 protobuf wrapper 序列化，只要定义 Java 接口并启用 triple 协议即可：</description></item><item><title>使用 Protobuf(IDL) 开发 triple 通信服务</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/triple/idl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/triple/idl/</guid><description>本示例演示如何使用 Protocol Buffers 定义服务，并将其发布为对外可调用的 triple 协议服务。如果你有多语言业务互调、gRPC互通，或者熟悉并喜欢 Protobuf 的开发方式，则可以使用这种模式，否则可以考虑上一篇基于Java接口的 triple 开发模式。
可在此查看 本示例的完整代码。
注意 本文使用的示例是基于原生 API 编码的，这里还有一个 Spring Boot 版本的示例 供参考，同样是 protobuf+triple 的模式，但额外加入了服务发现配置。 运行示例 首先，可通过以下命令下载示例源码：
git clone --depth=1 https://github.com/apache/dubbo-samples.git 进入示例源码目录：
cd dubbo-samples/1-basic/dubbo-samples-api-idl 编译项目，由 IDL 生成代码，这会调用 dubbo 提供的 protoc 插件生成对应的服务定义代码：
mvn clean compile 生成代码如下
├── build │ └── generated │ └── source │ └── proto │ └── main │ └── java │ └── org │ └── apache │ └── dubbo │ └── samples │ └── tri │ └── unary │ ├── DubboGreeterTriple.</description></item><item><title>Protocol</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/extensibility/protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/extensibility/protocol/</guid><description>在 通信协议 一章中，我们了解了 Dubbo 内置的几个核心 RPC 协议 dubbo、rest、和tri 以及它们的使用方式。本文讲解如何通过扩展 org.apache.dubbo.rpc.Protocol SPI，提供自定义的 RPC 协议实现。
自定义一套私有协议有两种方式，第一种是对原有的协议进行包装，添加一些特定的业务逻辑。另外一种是完全自定义一套协议。前者实现简单，在dubbo中也是有广泛的使用，比如：ProtocolFilterWrapper, QosProtocolWrapper, ProtocolListenerWrapper等。后者实现相对复杂，但却具有最大的灵活性，比如 Dubbo 框架内置的协议 dubbo、triple 协议都可以算作这种实现方式。
本示例的完整源码请参见 dubbo-samples-extensibility。除了本示例之外，Dubbo 核心仓库 apache/dubbo 以及扩展库 apache/dubbo-spi-extensions 中的众多 Protocol 实现，都可以作为扩展参考实现：
# Dubbo对外支持的常用协议 dubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol tri=org.apache.dubbo.rpc.protocol.tri.TripleProtocol 任务详情 基于现有的dubbo协议来实现自定义协议edubbo。
实现方式 通过对dubbo协议进行包装来实现edubbo协议。
代码结构 Common src |-main |-java |-org |-apache |-dubbo |-samples |-extensibility |-protocol |-common |-EnhancedProtocol.java (实现Protocol接口) Provider src |-main |-java |-org |-apache |-dubbo |-samples |-extensibility |-protocol |-provider |-ExtensibilityProtocolProviderApplication.java |-ExtensibilityProtocolServiceImpl.java |-resources |-META-INF |-application.properties (Dubbo Provider配置文件) |-dubbo |-org.</description></item><item><title>rest 协议</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/rest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/rest/</guid><description>基于标准的Java REST API——JAX-RS 2.0（Java API for RESTful Web Services的简写）实现的REST调用支持
快速入门 在dubbo中开发一个REST风格的服务会比较简单，下面以一个注册用户的简单服务为例说明。
这个服务要实现的功能是提供如下URL（注：这个URL不是完全符合REST的风格，但是更简单实用）：
http://localhost:8080/users/register 而任何客户端都可以将包含用户信息的JSON字符串POST到以上URL来完成用户注册。
首先，开发服务的接口：
public interface UserService { void registerUser(User user); } 然后，开发服务的实现：
@Path(&amp;#34;/users&amp;#34;) public class UserServiceImpl implements UserService { @POST @Path(&amp;#34;/register&amp;#34;) @Consumes({MediaType.APPLICATION_JSON}) public void registerUser(User user) { // save the user... } } 上面的实现非常简单，但是由于该 REST 服务是要发布到指定 URL 上，供任意语言的客户端甚至浏览器来访问，所以这里额外添加了几个 JAX-RS 的标准 annotation 来做相关的配置。
@Path(&amp;quot;/users&amp;quot;)：指定访问UserService的URL相对路径是/users，即http://localhost:8080/users
@Path(&amp;quot;/register&amp;quot;)：指定访问registerUser()方法的URL相对路径是/register，再结合上一个@Path为UserService指定的路径，则调用UserService.register()的完整路径为http://localhost:8080/users/register
@POST：指定访问registerUser()用HTTP POST方法
@Consumes({MediaType.APPLICATION_JSON})：指定registerUser()接收JSON格式的数据。REST框架会自动将JSON数据反序列化为User对象
最后，在spring配置文件中添加此服务，即完成所有服务开发工作：
&amp;lt;!-- 用rest协议在8080端口暴露服务 --&amp;gt; &amp;lt;dubbo:protocol name=&amp;#34;rest&amp;#34; port=&amp;#34;8080&amp;#34;/&amp;gt; &amp;lt;!-- 声明需要暴露的服务接口 --&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;xxx.</description></item><item><title>RPC 协议安全</title><link>https://dubbo.apache.org/zh-cn/overview/notices/protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/notices/protocol/</guid><description>Dubbo 支持 RPC 协议的扩展，理论上用户可以基于该扩展机制启用任意的 RPC 协议，这带来了极大的灵活的，但同时也要意识到其中潜藏的安全性风险。
Dubbo 2.7 官方版本提供的序列化协议有如下几种：
Dubbo RMI Hessian Http / Rest Webservice Thrift gRPC …… 从 Dubbo 3.0 开始默认仅提供以下序列化协议支持：
Dubbo Triple / gRPC Http / Rest 对于 Triple、gRPC、Http、Rest 协议都是基于 HTTP 协议构建的，可以严格区分请求的格式，如 Header 为纯文本，避免在读取 Token 时带来的 RCE 等风险。 对于 Dubbo 协议，由于其基于 TCP 二进制直接设计，除了特定几个字段外均使用序列化协议写入，因此如果开启了有风险的序列化协议，仍然会存在 RCE 等风险。 对于 RMI 协议，由于其基于 Java 序列化机制，存在 RCE 等风险。 对于 Hessian 协议，由于其基于 Hessian 序列化机制，且默认 Hessian 协议（非 Dubbo Shade 的 Hessian-Lite 协议）无法配置黑白名单且无默认黑名单，存在 RCE 等风险。
（1）如果用户希望使用 Token 鉴权机制，防止未鉴权的不可信请求来源威胁 Provider 的安全性，应使用 Triple 等基于 Http 标准扩展的协议，避免 token 参数读取时的安全风险。</description></item><item><title>Rust和Java互相调用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/java-interoperability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/java-interoperability/</guid><description>1 前置条件 安装 Rust 开发环境 安装 protoc 工具 安装 Java 开发环境 2 运行示例 Java 版本的 Dubbo provider Java 版本的 Dubbo provider 示例源码见https://github.com/apache/dubbo-samples/tree/master/3-extensions/protocol/dubbo-samples-triple。
Clone 源代码、编译构建，并运行 provider：
$ # clone 源代码 $ git clone https://github.com/apache/dubbo-samples.git $ cd dubbo-samples/dubbo-samples-triple/ $ # 构建 $ mvn clean compile package -DskipTests $ # 运行 provider $ java -Dprovider.port=8888 -jar ./target/dubbo-samples-triple-1.0-SNAPSHOT.jar # ……省略部分日志 Dubbo triple stub server started, port=8888 Java 侧的接口定义
3 运行 Rust 版本的 Dubbo consumer Rust 版本的 Dubbo consumer 示例源码见https://github.</description></item><item><title>Dubbo SPI 插件及详情</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/spi-list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/spi-list/</guid><description>Dubbo 在框架中定义了非常多的扩展点，因此，当你发现官方库没法满足业务需求，想为 Dubbo 框架提供定制能力时，请优先查阅以下扩展点定义，看是否能通过提供扩展实现的方式无侵入的定制 Dubbo 框架。
具体可参见本文下方的 Dubbo SPI 扩展定义汇总。
扩展点汇总 生命周期与事件回调 SPI 扩展定义 功能说明 示例实现 激活条件 org.apache.dubbo.common.lang.ShutdownHookCallback 优雅下线回调逻辑扩展点，Dubbo 进程销毁前会调用所有 ShutdownHookCallback 实现 无 无需配置，自动激活 org.apache.dubbo.common.threadpool.event.ThreadPoolExhaustedListener 当 dubbo 业务线程池满时，会调用这个扩展点发出事件通知 org.apache.dubbo.metrics.collector.sample.MetricThreadPoolExhaustedListener 通过 dubbo.protocol.thread-pool-exhausted-listeners=spi-name1,spi-name2 设置激活哪些实现 org.apache.dubbo.rpc.ExporterListener 每个 Exporter 成功 export/unexport 发布后，都会回调这个扩展点 org.apache.dubbo.rpc.listener.InjvmExporterListener 扩展实现必须增加 @Activate 注解激活，可按需配置激活条件。支持通过在 URL 中配置 exporter.listener=spi-name1,spi-name2 控制具体激活哪个实现 org.apache.dubbo.rpc.InvokerListener 每个服务 Invoker 成功 refer/destroy 发布后，都会回调这个扩展点 org.apache.dubbo.rpc.protocol.CountInvokerListener 扩展实现必须增加 @Activate 注解激活，可按需配置激活条件。支持通过在 URL 中配置 invoker.listener=spi-name1,spi-name2 控制具体激活哪个实现 org.apache.dubbo.common.status.StatusChecker 对外透出内部组件状态的扩展点，每个需要透出状态的组件均可实现此扩展点。 org.apache.dubbo.rpc.protocol.dubbo.status.ThreadPoolStatusChecker 通过设置 dubbo.protocol.status=spi-name1,spi-name2 激活 org.apache.dubbo.config.ServiceListener ServciceConfig 回调扩展点，每个 ServiceConfig 成功 export/unexport 后都会被回调。拦截点与 ExporterListener 略有不同 无 无需配置，自动激活 org.</description></item><item><title>SPI 自适应拓展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/adaptive-extension/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/adaptive-extension/</guid><description>1.原理 在 Dubbo 中，很多拓展都是通过 SPI 机制进行加载的，比如 Protocol、Cluster、LoadBalance 等。有时，有些拓展并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载。这听起来有些矛盾。拓展未被加载，那么拓展方法就无法被调用（静态方法除外）。拓展方法未被调用，拓展就无法被加载。对于这个矛盾的问题，Dubbo 通过自适应拓展机制很好的解决了。自适应拓展机制的实现逻辑比较复杂，首先 Dubbo 会为拓展接口生成具有代理功能的代码。然后通过 javassist 或 jdk 编译这段代码，得到 Class 类。最后再通过反射创建代理类，整个过程比较复杂。为了让大家对自适应拓展有一个感性的认识，下面我们通过一个示例进行演示。这是一个与汽车相关的例子，我们有一个车轮制造厂接口 WheelMaker：
public interface WheelMaker { Wheel makeWheel(URL url); } WheelMaker 接口的自适应实现类如下：
public class AdaptiveWheelMaker implements WheelMaker { public Wheel makeWheel(URL url) { if (url == null) { throw new IllegalArgumentException(&amp;#34;url == null&amp;#34;); } // 1.从 URL 中获取 WheelMaker 名称 String wheelMakerName = url.getParameter(&amp;#34;Wheel.maker&amp;#34;); if (wheelMakerName == null) { throw new IllegalArgumentException(&amp;#34;wheelMakerName == null&amp;#34;); } // 2.</description></item><item><title>Trie 前缀树介绍</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/dev/trie/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/dev/trie/</guid><description>简介 网关的核心之一是路由逻辑，决定一个请求需要经过怎样的加工，被转发到哪个下行服务。
其中 80% 的路由需求表达都以 URL 为基础。需要描述清楚具有某个特征的 URL 或者 URL 集合对应怎样的一系列下游处理策略。
例如，&amp;rsquo;/test/&amp;rsquo; 开头的 URL 路由到测试环境集群，&amp;rsquo;/release/user/&amp;rsquo; 开头的 URL 会被路由到正式环境的 user 服务集群。
同时网关作为所有请求的入口，每一毫秒的延时都会做用在全量的业务下，在 mesh 场景下，延时还会随着调用链路的加深，被倍数放大。按照生产环境业务相应 &amp;lt;=7 毫秒的标准来看，规则匹配的性能要求也是十分苛刻的。一定不能随着规则数目的增加而性能退化。
使用介绍 仅从使用方的角度阐述 pixiu 的配置文件如何描述 URL 相关的路由规则。（下面，我们介绍一下如何配置 URL 路由规则）
如下是一份 pixiu 的 api 配置文件，这份配置文件会被解析后生成一份对应的内存模型，作为 pixiu 路由相关配置的初始状态。之后由 RDS 协议修改解析后得到的内存模型，实现路由逻辑动态生效的效果。RDS 协议（RDS：xDS 协议下描述路由规则的部分）相关内容是后话不详细阐述。我们把注意力聚焦到resource部分。
resource 下 path 部分就是上文阐述的，URL 相关的路由描述。意思是满足 path 描述特征的 URL 会被成功匹配。
name: server description: server sample resources: - path: &amp;#39;/api/v1/test-dubbo/user/name/:name&amp;#39; type: restful description: user methods: - httpVerb: GET enable: true timeout: 1000ms inboundRequest: requestType: http uri: - name: name required: true integrationRequest: requestType: dubbo mappingParams: - name: uri.</description></item><item><title>协议概述</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/triple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/triple/</guid><description>请参考文档其他部分了解 triple 协议规范规范 和 基本使用方式。本文只展开 triple 协议 Java 实现中的一些具体细节内容。
编程模式 使用 triple 协议时，开发者可以使用 Java Interface、Protobuf(IDL) 两种方式定义 RPC 服务，两种服务定义方式的协议能力是对等的，仅影响开发者的编程体验、序列化方式，具体选用那种开发模式，取决于使用者的业务背景。
Java接口 适合于 Dubbo 老用户、没有跨语言诉求的开发团队，具备学习成本低的优势，Dubbo2 老用户可以零成本切换到该协议。
服务定义范例：
public interface DemoService { String sayHello(String name); } 这种模式下，序列化方式可以选用 Hessian、JSON、Kryo、JDK、自定义扩展等任意编码协议。在使用体验上，可以说与老版本 dubbo 协议没有任何区别，只需要改一个 protocol 配置项即可，因此对于 dubbo 协议迁移到 triple 也会更平滑。
请通过【进阶学习 - 通信协议】查看 java Interface + Triple 协议的具体使用示例。
Protobuf 使用 Protobuf(IDL) 的方式定义服务，适合于当前或未来有跨语言诉求的开发团队，同一份 IDL 服务可同时用于 Java/Go/Node.js 等多语言微服务开发，劣势是学习成本较高。
syntax = &amp;#34;proto3&amp;#34;; option java_multiple_files = true; package org.apache.dubbo.springboot.demo.idl; message GreeterRequest { string name = 1; } message GreeterReply { string message = 1; } service Greeter{ rpc greet(GreeterRequest) returns (GreeterReply); } 通过 Dubbo 提供的 protoc 编译插件，将以上 IDL 服务定义预编译为相关 stub 代码，其中就包含 Dubbo 需要的 Interface 接口定义，因此在后续编码上区别并不大，只不过相比于前面的用户自定义 Java Interface 模式，这里由插件自动帮我们生成 Interface 定义。</description></item><item><title>Zookeeper</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config-center/zookeeper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config-center/zookeeper/</guid><description>1 前置条件 了解 Dubbo 基本开发步骤 安装并启动 Zookeeper 2 使用说明 在此查看完整示例代码
2.1 增加 Maven 依赖 如果项目已经启用 Zookeeper 作为注册中心，则无需增加任何额外配置。
如果未使用 Zookeeper 注册中心，则请参考 为注册中心增加 Zookeeper 相关依赖。
2.2 启用 Zookeeper 配置中心 &amp;lt;dubbo:config-center address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; 或者
dubbo config-center address: zookeeper://127.0.0.1:2181 或者
dubbo.config-center.address=zookeeper://127.0.0.1:2181 或者
ConfigCenterConfig configCenter = new ConfigCenterConfig(); configCenter.setAddress(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;); address 格式请参考 zookeeper 注册中心 - 启用配置
3 高级配置 如要开启认证鉴权，请参考 zookeeper 注册中心 - 启用认证鉴权
3.1 定制外部化配置 key 1. 启用外部化配置，并指定 key
dubbo config-center address: zookeeper://127.0.0.1:2181 config-file: dubbo.properties config-file - 外部化配置文件 key 值，默认 dubbo.</description></item><item><title>标签路由规则</title><link>https://dubbo.apache.org/zh-cn/overview/what/core-features/traffic/tag-rule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/core-features/traffic/tag-rule/</guid><description>标签路由通过将某一个服务的实例划分到不同的分组，约束具有特定标签的流量只能在指定分组中流转，不同分组为不同的流量场景服务，从而达到实现流量隔离的目的，可以作为蓝绿发布、灰度发布等场景能力的基础。目前有两种方式可以对实例打标，分别是动态规则打标和静态规则打标。动态规则打标 可以在运行时动态的圈住一组机器实例，而 静态规则打标 则需要实例重启后才能生效，其中，动态规则相较于静态规则优先级更高，而当两种规则同时存在且出现冲突时，将以动态规则为准。
本文要讲的就是标签路由规则就是 动态规则打标。
标签路由是一套严格隔离的流量体系，对于同一个应用而言，一旦打了标签则这部分地址子集就被隔离出来，只有带有对应标签的请求流量可以访问这个地址子集，这部分地址不再接收没有标签或者具有不同标签的流量。
举个例子，如果我们将一个应用进行打标，打标后划分为 tag-a、tag-b、无 tag 三个地址子集，则访问这个应用的流量，要么路由到 tag-a (当请求上下文 dubbo.tag=tag-a)，要么路由到 tag-b (dubbo.tag=tag-b)，或者路由到无 tag 的地址子集 (dubbo.tag 未设置)，不会出现混调的情况。
标签路由的作用域是提供者应用，消费者应用无需配置标签路由规则。一个提供者应用内的所有服务只能有一条分组规则，不会有服务 A 使用一条路由规则、服务 B 使用另一条路由规则的情况出现。以下条件路由示例，在 shop-detail 应用中圈出了一个隔离环境 gray，gray 环境包含所有带有 env=gray 标识的机器实例。
configVersion: v3.0 force: true enabled: true key: shop-detail tags: - name: gray match: - key: env value: exact: gray TagRule 标签路由规则主体。定义路由规则生效的目标应用、标签分类规则以及一些特定场景下的行为。
Field Type Description Required configVersion string The version of the tag rule definition, currently available version is v3.0 Yes key string The identifier of the target application that this rule is about to control Yes enabled bool Whether enable this rule or not, set enabled:false to disable this rule.</description></item><item><title>超高性能</title><link>https://dubbo.apache.org/zh-cn/overview/what/advantages/performance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/advantages/performance/</guid><description>Dubbo 被设计用于解决阿里巴巴超大规模的电商微服务集群实践，并在各个行业头部企业经过多年的十万、百万规模的微服务实践检验，因此，Dubbo 在通信性能、稳定性方面具有无可比拟的优势，非常适合构建近乎无限水平伸缩的微服务集群，这也是 Dubbo 从实践层面优于业界很多同类的产品的巨大优势。
高性能数据传输 Dubbo 内置支持 Dubbo2、Triple 两款高性能通信协议。其中
Dubbo2 是基于 TCP 传输协议之上构建的二进制私有 RPC 通信协议，是一款非常简单、紧凑、高效的通信协议。 Triple 是基于 HTTP/2 的新一代 RPC 通信协议，在网关穿透性、通用性以及 Streaming 通信上具备优势，Triple 完全兼容 gRPC 协议。 以下是基于 Dubbo 3.2 版本得出的压测指标数据，您也可以通过 dubbo-benchmark 项目自行压测。
TCP protocol benchmark 对比 Dubbo 2.x 及早期 3.x 版本
较小报文场景 createUser、getUser 下，提升率约 180%。 极小报文 existUser(仅一个boolean值)下提升率约 24% 较大报文 listUser 提升率最高，达到了 1000%！ Triple protocol benchmark 较小报文场景 createUser、existUser、getUser 下，较 3.1 版本性能提升约 40-45%，提升后的性能与 gRPC 同场景的性能基本持平。 较大报文场景 listUser 下较 3.1 版本提升了约 17%，相较于同场景下的 gRPC 低 11%。 了解更多</description></item><item><title>超时时间</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/rpc/timeout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/rpc/timeout/</guid><description>1.介绍 本示例演示如何在 Dubbo-go 客户端发起调用时设置请求超时时间。可在此查看 完整示例源码地址
2.如何设置请求超时时间 在创建客户端时，可以使用 client.WithRequestTimeout() 方法设置全局超时时间（所有使用改 client 的服务代理共享）。
cli, err := client.NewClient( client.WithClientURL(&amp;#34;tri://127.0.0.1:20000&amp;#34;), client.WithClientRequestTimeout(3 * time.Second), ) 可以使用 client.WithRequestTimeout() 创建服务粒度的超时时间（以下服务代理 svc 发起的方法调用都使用这个时间）。
svc, err := greet.NewGreetService(cli, client.WithRequestTimeout(5 * time.Second)) 也可以在调用发起时，使用 client.WithCallRequestTimeout() 指定一个超时时间
resp, err := svc.GreetTimeout(context.Background(), &amp;amp;greet.GreetRequest{Name: &amp;#34;hello world&amp;#34;}, client.WithCallRequestTimeout(10 * time.Second)) 从上往下，以上三种方式的优先级逐步提高，client.WithCallRequestTimeout() 指定的超时时间优先级最高。
3.示例详解 3.1服务端介绍 服务端proto文件 源文件路径：dubbo-go-sample/timeout/proto/greet.proto
syntax = &amp;#34;proto3&amp;#34;; package greet; option go_package = &amp;#34;github.com/apache/dubbo-go-samples/timeout/proto;greet&amp;#34;; message GreetRequest { string name = 1; } message GreetResponse { string greeting = 1; } service GreetService { rpc Greet(GreetRequest) returns (GreetResponse) {} rpc GreetTimeout(GreetRequest) returns (GreetResponse) {} } 服务端handler文件 Greet方法直接响应，GreetTimeout方法等待五秒后响应（模拟超时）。</description></item><item><title>创建基于Spring Boot的微服务应用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/quick-start/starter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/quick-start/starter/</guid><description>以下文档将引导您从头创建一个基于 Spring Boot 的 Dubbo 应用，并为应用配置 Triple 通信协议、服务发现等微服务基础能力。
快速创建应用 通过访问 start.dubbo.apache.org 在线服务创建 Dubbo 微服务应用。如下图所示依次添加组件，您可以在几十秒之内快速创建一个 Dubbo 应用。下载生成的示例应用并解压源码即可。
直接使用官方准备好的示例 您还可以直接下载官方预先准备好的示例项目：
$ git clone -b main --depth 1 https://github.com/apache/dubbo-samples $ cd dubbo-samples/11-quickstart 本地启动应用 接下来，让我们尝试在本地启动应用。运行以下命令启动应用：
./mvnw 注意 由于配置文件中启用了注册中心，为了能够成功启动应用，您需要首先在本地启动 Nacos 或 Zookeeper 注册中心 server。 在应用启动成功后，本地进程使用 Triple 协议在指定端口发布了服务，可直接使用 cURL 测试服务是否已经正常运行：
curl \ --header &amp;#34;Content-Type: application/json&amp;#34; \ --data &amp;#39;[&amp;#34;Dubbo&amp;#34;]&amp;#39; \ http://localhost:50051/com.example.demo.dubbo.api.DemoService/sayHello/ 除了使用命令行之外，我们还可以在 IDE 中启动项目，调整示例或进行本地 debug。
源码解析 将以上准备好的示例项目导入最喜欢的 IDE 开发工具（以 IntelliJ IDEA 为例），项目结构如下：
Maven 依赖 打开 pom.xml，可以看到示例项目中 Dubbo 相关核心依赖如下：</description></item><item><title>使用原生 API 开发 Dubbo 应用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/develop/api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/develop/api/</guid><description>你可能已经注意到了，文档中大部分的功能、示例都是基于 Spring Boot 模式编写的，但 Spring Boot 或 Spring 仅仅是 Dubbo 适配的一种应用或者微服务开发模式。作为一款 RPC 框架，Dubbo 定义了一套完善的 API 接口，我们可以基于原生 API 开发 Dubbo 应用，纯 API 可以实现的业务场景包括：
轻量 RPC Server &amp;amp; Client，通常用于一些应用内、基础组件、中间件等内的简单远程调用场景 微服务应用，不依赖 Spring 的情况下，直接用 API 开发微服务 API 概览 public class Application { public static void main(String[] args) { DubboBootstrap.getInstance() .protocol(new ProtocolConfig(CommonConstants.TRIPLE, 50051)) .service(ServiceBuilder.newBuilder().ref(new DemoServiceImpl()).build()) .start() .await(); } } 以上是启动 Dubbo RPC Server 的一段代码示例，DubboBootstrap 实例代表一个 Dubbo 应用，是整个 Dubbo 应用的启动入口。在 DubboBootstrap 基础上，我们可以设置 protocol、service、registry、metrics 等来注册服务、连接注册中心等，这和我们在 Spring Boot 中调整 application.</description></item><item><title>代码架构</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/code-architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/code-architecture/</guid><description>整体设计 图例说明：
图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。 图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。 图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。 图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调用链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。 各层说明 Config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类 Proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory Registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService Cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance Monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService Protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter Exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer Transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec Serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool 关系说明 在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。 图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓扑节点，保持统一概念。 而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。 Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。 而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。 Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。 模块分包 模块说明：</description></item><item><title>地址找不到异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/troubleshoot/no-provider/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/troubleshoot/no-provider/</guid><description>在开发与生产部署过程中，由于 Dubbo 是一个需要基于服务发现功能进行调用的框架，很容易由于各种客观原因出现 No Provder 的异常，本文旨在通过体系化的排查思路，让您能够在异常的时候快速定位原因并解决。
java.lang.IllegalStateException: Failed to check the status of the service org.apache.dubbo.samples.api.GreetingsService. No provider available for the service org.apache.dubbo.samples.api.GreetingsService from the url consumer://*** to the consumer 30.221.146.226 use dubbo version 3.2.0-beta.4 Exception in thread &amp;#34;main&amp;#34; org.apache.dubbo.rpc.RpcException: No provider available from registry 127.0.0.1:2181 for service org.apache.dubbo.samples.api.GreetingsService on consumer 30.221.146.226 use dubbo version 3.2.0-beta.4, please check status of providers(disabled, not registered or in blacklist). 一句话总结 服务找不到时先自查服务是否已经开发完部署了，然后在注册中心中确认是否已经注册，如果注册检查服务端发布情况、如果未注册检查消费端订阅情况，中间任何一步出问题都会导致异常。
排查思路全览 详细教程 1 识别异常的服务以及订阅模式 为了后续正确定位排查的方向，第一步需要先确认有报错的服务名。</description></item><item><title>调用拦截扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/filter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/filter/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 服务提供方和服务消费方调用过程拦截，Dubbo 本身的大多功能均基于此扩展点实现，每次远程方法执行，该拦截都会被执行，请注意对性能的影响。
约定：
用户自定义 filter 默认在内置 filter 之后。 特殊值 default，表示缺省扩展点插入的位置。比如：filter=&amp;quot;xxx,default,yyy&amp;quot;，表示 xxx 在缺省 filter 之前，yyy 在缺省 filter 之后。 特殊符号 -，表示剔除。比如：filter=&amp;quot;-foo1&amp;quot;，剔除添加缺省扩展点 foo1。比如：filter=&amp;quot;-default&amp;quot;，剔除添加所有缺省扩展点。 provider 和 service 同时配置的 filter 时，累加所有 filter，而不是覆盖。比如：&amp;lt;dubbo:provider filter=&amp;quot;xxx,yyy&amp;quot;/&amp;gt; 和 &amp;lt;dubbo:service filter=&amp;quot;aaa,bbb&amp;quot; /&amp;gt;，则 xxx,yyy,aaa,bbb 均会生效。如果要覆盖，需配置：&amp;lt;dubbo:service filter=&amp;quot;-xxx,-yyy,aaa,bbb&amp;quot; /&amp;gt; 扩展接口 org.apache.dubbo.rpc.Filter
扩展配置 &amp;lt;!-- 消费方调用过程拦截 --&amp;gt; &amp;lt;dubbo:reference filter=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 消费方调用过程缺省拦截器，将拦截所有reference --&amp;gt; &amp;lt;dubbo:consumer filter=&amp;#34;xxx,yyy&amp;#34;/&amp;gt; &amp;lt;!-- 提供方调用过程拦截 --&amp;gt; &amp;lt;dubbo:service filter=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 提供方调用过程缺省拦截器，将拦截所有service --&amp;gt; &amp;lt;dubbo:provider filter=&amp;#34;xxx,yyy&amp;#34;/&amp;gt; 已知扩展 org.apache.dubbo.rpc.filter.EchoFilter org.apache.dubbo.rpc.filter.GenericFilter org.apache.dubbo.rpc.filter.GenericImplFilter org.apache.dubbo.rpc.filter.TokenFilter org.apache.dubbo.rpc.filter.AccessLogFilter org.</description></item><item><title>调用拦截扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/filter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/filter/</guid><description>扩展说明 服务提供方和服务消费方调用过程拦截，Dubbo 本身的大多功能均基于此扩展点实现，每次远程方法执行，该拦截都会被执行，请注意对性能的影响。
约定：
用户自定义 filter 默认在内置 filter 之后。 特殊值 default，表示缺省扩展点插入的位置。比如：filter=&amp;quot;xxx,default,yyy&amp;quot;，表示 xxx 在缺省 filter 之前，yyy 在缺省 filter 之后。 特殊符号 -，表示剔除。比如：filter=&amp;quot;-foo1&amp;quot;，剔除添加缺省扩展点 foo1。比如：filter=&amp;quot;-default&amp;quot;，剔除添加所有缺省扩展点。 provider 和 service 同时配置的 filter 时，累加所有 filter，而不是覆盖。比如：&amp;lt;dubbo:provider filter=&amp;quot;xxx,yyy&amp;quot;/&amp;gt; 和 &amp;lt;dubbo:service filter=&amp;quot;aaa,bbb&amp;quot; /&amp;gt;，则 xxx,yyy,aaa,bbb 均会生效。如果要覆盖，需配置：&amp;lt;dubbo:service filter=&amp;quot;-xxx,-yyy,aaa,bbb&amp;quot; /&amp;gt; 扩展接口 org.apache.dubbo.rpc.Filter
扩展配置 &amp;lt;!-- 消费方调用过程拦截 --&amp;gt; &amp;lt;dubbo:reference filter=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 消费方调用过程缺省拦截器，将拦截所有reference --&amp;gt; &amp;lt;dubbo:consumer filter=&amp;#34;xxx,yyy&amp;#34;/&amp;gt; &amp;lt;!-- 提供方调用过程拦截 --&amp;gt; &amp;lt;dubbo:service filter=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 提供方调用过程缺省拦截器，将拦截所有service --&amp;gt; &amp;lt;dubbo:provider filter=&amp;#34;xxx,yyy&amp;#34;/&amp;gt; 已知扩展 org.apache.dubbo.rpc.filter.EchoFilter org.apache.dubbo.rpc.filter.GenericFilter org.apache.dubbo.rpc.filter.GenericImplFilter org.apache.dubbo.rpc.filter.TokenFilter org.apache.dubbo.rpc.filter.AccessLogFilter org.apache.dubbo.rpc.filter.CountFilter org.apache.dubbo.rpc.filter.ActiveLimitFilter org.</description></item><item><title>调用拦截扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/filter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/filter/</guid><description>扩展说明 服务提供方和服务消费方调用过程拦截，Dubbo 本身的大多功能均基于此扩展点实现，每次远程方法执行，该拦截都会被执行，请注意对性能的影响。
约定：
用户自定义 filter 默认在内置 filter 之后。 特殊值 default，表示缺省扩展点插入的位置。比如：filter=&amp;quot;xxx,default,yyy&amp;quot;，表示 xxx 在缺省 filter 之前，yyy 在缺省 filter 之后。 特殊符号 -，表示剔除。比如：filter=&amp;quot;-foo1&amp;quot;，剔除添加缺省扩展点 foo1。比如：filter=&amp;quot;-default&amp;quot;，剔除添加所有缺省扩展点。 provider 和 service 同时配置的 filter 时，累加所有 filter，而不是覆盖。比如：&amp;lt;dubbo:provider filter=&amp;quot;xxx,yyy&amp;quot;/&amp;gt; 和 &amp;lt;dubbo:service filter=&amp;quot;aaa,bbb&amp;quot; /&amp;gt;，则 xxx,yyy,aaa,bbb 均会生效。如果要覆盖，需配置：&amp;lt;dubbo:service filter=&amp;quot;-xxx,-yyy,aaa,bbb&amp;quot; /&amp;gt; 扩展接口 org.apache.dubbo.rpc.Filter
扩展配置 &amp;lt;!-- 消费方调用过程拦截 --&amp;gt; &amp;lt;dubbo:reference filter=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 消费方调用过程缺省拦截器，将拦截所有reference --&amp;gt; &amp;lt;dubbo:consumer filter=&amp;#34;xxx,yyy&amp;#34;/&amp;gt; &amp;lt;!-- 提供方调用过程拦截 --&amp;gt; &amp;lt;dubbo:service filter=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 提供方调用过程缺省拦截器，将拦截所有service --&amp;gt; &amp;lt;dubbo:provider filter=&amp;#34;xxx,yyy&amp;#34;/&amp;gt; 已知扩展 org.apache.dubbo.rpc.filter.EchoFilter org.apache.dubbo.rpc.filter.GenericFilter org.apache.dubbo.rpc.filter.GenericImplFilter org.apache.dubbo.rpc.filter.TokenFilter org.apache.dubbo.rpc.filter.AccessLogFilter org.apache.dubbo.rpc.filter.CountFilter org.apache.dubbo.rpc.filter.ActiveLimitFilter org.</description></item><item><title>动态调整服务超时时间</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/timeout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/timeout/</guid><description>Dubbo 提供动态调整服务超时时间的能力，在无需重启应用的情况下调整服务的超时时间，这对于临时解决一些服务上下游依赖不稳定而导致的调用失败问题非常有效。
开始之前 部署 Shop 商城项目 部署并打开 Dubbo Admin 任务详情 商城项目通过 org.apache.dubbo.samples.UserService 提供用户信息管理服务，访问 http://localhost:8080/ 打开商城并输入任意账号密码，点击 Login 即可以正常登录到系统。
有些场景下，User 服务的运行速度会变慢，比如存储用户数据的数据库负载过高导致查询变慢，这时就会出现 UserService 访问超时的情况，导致登录失败。
在示例系统中，可通过下图 Timeout Login 模拟突发的 UserService 访问超时异常
通过规则动态调整超时时间 为了解决突发的登录超时问题，我们只需要适当增加 UserService 服务调用的等待时间即可。
操作步骤 打开 Dubbo Admin 控制台 在左侧导航栏选择【服务治理】&amp;gt;【动态配置】 点击 &amp;ldquo;创建&amp;rdquo;，输入服务 org.apache.dubbo.samples.UserService 和新的超时时间如 2000 即可。 保存后，再次点击 Timeout Login，此时在经过短暂的等待后系统可以正常登录。
规则详解 规则 key ：org.apache.dubbo.samples.UserService
规则体
configVersion: v3.0 enabled: true configs: - side: provider parameters: timeout: 2000 从 UserService 服务提供者视角，将超时时间总体调整为 2s。
parameters: timeout: 2000 side: provider 配置会将规则发送到服务提供方实例，所有 UserService 服务实例会基于新的 timeout 值进行重新发布，并通过注册中心通知给所有消费方。</description></item><item><title>动态配置中心</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/configuration/config-center/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/configuration/config-center/</guid><description>配置中心（v2.7.0）在 Dubbo 中承担两个职责：
外部化配置。启动配置的集中式存储 （简单理解为 dubbo.properties 的外部化存储）。 服务治理。服务治理规则的存储与通知。 启用动态配置，以 Zookeeper 为例，可查看 动态配置配置项详解
&amp;lt;dubbo:config-center address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; 或者
dubbo.config-center.address=zookeeper://127.0.0.1:2181 或者
ConfigCenterConfig configCenter = new ConfigCenterConfig(); configCenter.setAddress(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;); 为了兼容 2.6.x 版本配置，在使用 Zookeeper 作为注册中心，且没有显示配置配置中心的情况下，Dubbo 框架会默认将此 Zookeeper 用作配置中心，但将只作服务治理用途。
外部化配置 外部化配置目的之一是实现配置的集中式管理，这部分业界已经有很多成熟的专业配置系统如 Apollo, Nacos 等，Dubbo 所做的主要是保证能配合这些系统正常工作。
外部化配置和其他本地配置在内容和格式上并无区别，可以简单理解为 dubbo.properties 的外部化存储，配置中心更适合将一些公共配置如注册中心、元数据中心配置等抽取以便做集中管理。
# 将注册中心地址、元数据中心地址等配置集中管理，可以做到统一环境、减少开发侧感知。 dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.registry.simplified=true dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 dubbo.protocol.name=dubbo dubbo.protocol.port=20880 dubbo.application.qos.port=33333 优先级
外部化配置默认较本地配置有更高的优先级，因此这里配置的内容会覆盖本地配置值，关于 各配置形式间的覆盖关系 有单独一章说明，你也可通过以下选项调整配置中心的优先级：
-Ddubbo.config-center.highest-priority=false 作用域
外部化配置有全局和应用两个级别，全局配置是所有应用共享的，应用级配置是由每个应用自己维护且只对自身可见的。当前已支持的扩展实现有Zookeeper、Apollo。
Zookeeper &amp;lt;dubbo:config-center address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; 默认所有的配置都存储在 /dubbo/config 节点，具体节点结构图如下：
namespace，用于不同配置的环境隔离。 config，Dubbo约定的固定节点，不可更改，所有配置和服务治理规则都存储在此节点下。 dubbo/application，分别用来隔离全局配置、应用级别配置：dubbo是默认group值，application对应应用名 dubbo.properties，此节点的node value存储具体配置内容 Apollo &amp;lt;dubbo:config-center protocol=&amp;#34;apollo&amp;#34; address=&amp;#34;127.0.0.1:2181&amp;#34;/&amp;gt; Apollo中的一个核心概念是命名空间 - namespace（和上面zookeeper的namespace概念不同），在这里全局和应用级别配置就是通过命名空间来区分的。</description></item><item><title>泛化调用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/generic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/generic/</guid><description>废弃警告 dubbo-go 泛化调用仅适用于 dubbo2 协议，不适用 triple 协议 泛化调用是一种 Dubbo-Go 的特殊调用方式，它允许中间节点在没有接口信息的情况下传递调用信息，常被用于测试、网关的场景下。泛化调用支持 Dubbo 和 Triple 协议，但是目前序列化方案只支持 Hessian。
背景 为了便于理解，这篇文档中以网关使用场景介绍泛化调用。我们先来考虑普通调用（非泛化调用）。下图包含了 consumer 和 provider 两个关键角色（后文中用 endpoint 代表一个 consumer 或一个 provider），各自都有一份关于 org.apache.dubbo.sample.User 接口的定义。假定在调用行为中需要使用 org.apache.dubbo.sample.User 接口。
RPC 需要借助网络介质传输，因此数据不能以 go struct 形式传输，而必须以二进制形式传输。这就要求 consumer 端在传输前，需要将实现 org.apache.dubbo.sample.User 接口的结构体序列化为二进制格式。同样的，对于 provider 端，需要将二进制数据反序列化为结构体信息。总之，普通调用要求接口信息在每一个 endpoint 必须有相同的定义，这样才能保证数据序列化和反序列化的结果与预期一致。
在网关场景下，网关不可能存储全部接口定义。比如一个网关需要转发 100 个服务调用，每个服务需要的接口数量为 10 个，普通调用要求把 1000 个（100 * 10）接口定义提前全部存储在网关内，这显然是难以做到的。所以有没有一种方式可以既不需要提前存储接口定义，又能正确转发调用呢？答案是肯定的，这就是使用泛化调用的原因。
原理 泛化调用本质上就是把复杂结构转化为通用结构，这里说的通用结构是指 map、string 等，网关是可以顺利解析并传递这些通用结构的。
目前，Dubbo-go v3 只支持 Map 泛化方式（default）。我们以 User 接口为例，其定义如下所示。
// definition type User struct { ID string Name string Age int32 } func (u *User) JavaClassName() string { return &amp;#34;org.</description></item><item><title>服务发现</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/service-discovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/service-discovery/</guid><description>Dubbo Rust服务发现简介 Dubbo Rust提供的是一种 Client-Based 的服务发现机制，依赖第三方注册中心组件来协调服务发现过程，支持的注册中心： Nacos、Zookeeper
以下是 Dubbo Rust服务发现机制的基本工作原理图：
服务发现包含提供者、消费者和注册中心三个参与角色，其中，Dubbo 提供者实例注册 URL 地址到注册中心，注册中心负责对数据进行聚合，Dubbo 消费者从注册中心读取地址列表并订阅变更，每当地址列表发生变化，注册中心将最新的列表通知到所有订阅的消费者实例。
Dubbo Rust注册中心以服务粒度聚合实例数据，消费者按消费需求精准订阅。 Dubbo Rust服务发现的一个示例：example
高效地址推送实现 从注册中心视角来看，它负责以服务名 (例如：org.apache.dubbo.sample.tri.Greeter) 对整个集群的实例地址进行聚合，每个对外提供服务的实例将自身的实例ip:port 地址信息 (例如：127.0.0.1:8848) 注册到注册中心。
配置方式 Dubbo Rust服务发现支持两种注册中心组件，既Nacos、Zookeeper，可以通过以下方式创建不同的注册中心，并将其绑定到Dubbo Rust框架。
配置方式： 假设有服务：Greeter，对应的服务实现为GreeterServerImpl
服务端：
//注册服务 register_server(GreeterServerImpl { name: &amp;#34;greeter&amp;#34;.to_string(), }); //创建注册中心 let zkr = ZookeeperRegistry::default(); let r = RootConfig::new(); let r = match r.load() { Ok(config) =&amp;gt; config, Err(_err) =&amp;gt; panic!(&amp;#34;err: {:?}&amp;#34;, _err), // response was droped }; //启动Dubbo框架 let mut f = Dubbo::new() .</description></item><item><title>服务发现</title><link>https://dubbo.apache.org/zh-cn/overview/what/core-features/service-discovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/core-features/service-discovery/</guid><description>Dubbo 提供的是一种 Client-Based 的服务发现机制，依赖第三方注册中心组件来协调服务发现过程，支持常用的注册中心如 Nacos、Consul、Zookeeper 等。
以下是 Dubbo 服务发现机制的基本工作原理图：
服务发现包含提供者、消费者和注册中心三个参与角色，其中，Dubbo 提供者实例注册 URL 地址到注册中心，注册中心负责对数据进行聚合，Dubbo 消费者从注册中心读取地址列表并订阅变更，每当地址列表发生变化，注册中心将最新的列表通知到所有订阅的消费者实例。
面向百万实例集群的服务发现机制 区别于其他很多微服务框架的是，Dubbo3 的服务发现机制诞生于阿里巴巴超大规模微服务电商集群实践场景，因此，其在性能、可伸缩性、易用性等方面的表现大幅领先于业界大多数主流开源产品。是企业面向未来构建可伸缩的微服务集群的最佳选择。
首先，Dubbo 注册中心以应用粒度聚合实例数据，消费者按消费需求精准订阅，避免了大多数开源框架如 Istio、Spring Cloud 等全量订阅带来的性能瓶颈。 其次，Dubbo SDK 在实现上对消费端地址列表处理过程做了大量优化，地址通知增加了异步、缓存、bitmap 等多种解析优化，避免了地址更新常出现的消费端进程资源波动。 最后，在功能丰富度和易用性上，服务发现除了同步 ip、port 等端点基本信息到消费者外，Dubbo 还将服务端的 RPC/HTTP 服务及其配置的元数据信息同步到消费端，这让消费者、提供者两端的更细粒度的协作成为可能，Dubbo 基于此机制提供了很多差异化的治理能力。 高效地址推送实现 从注册中心视角来看，它负责以应用名 (dubbo.application.name) 对整个集群的实例地址进行聚合，每个对外提供服务的实例将自身的应用名、实例ip:port 地址信息 (通常还包含少量的实例元数据，如机器所在区域、环境等) 注册到注册中心。
Dubbo2 版本注册中心以服务粒度聚合实例地址，比应用粒度更细，也就意味着传输的数据量更大，因此在大规模集群下也遇到一些性能问题。 针对 Dubbo2 与 Dubbo3 跨版本数据模型不统一的问题，Dubbo3 给出了平滑迁移方案，可做到模型变更对用户无感。
每个消费服务的实例从注册中心订阅实例地址列表，相比于一些产品直接将注册中心的全量数据 (应用 + 实例地址) 加载到本地进程，Dubbo 实现了按需精准订阅地址信息。比如一个消费者应用依赖 app1、app2，则只会订阅 app1、app2 的地址列表更新，大幅减轻了冗余数据推送和解析的负担。 丰富元数据配置 除了与注册中心的交互，Dubbo3 的完整地址发现过程还有一条额外的元数据通路，我们称之为元数据服务 (MetadataService)，实例地址与元数据共同组成了消费者端有效的地址列表。
完整工作流程如上图所示，首先，消费者从注册中心接收到地址 (ip:port) 信息，然后与提供者建立连接并通过元数据服务读取到对端的元数据配置信息，两部分信息共同组装成 Dubbo 消费端有效的面向服务的地址列表。以上两个步骤都是在实际的 RPC 服务调用发生之前。
关于 MetadataService 的定义及完整服务发现流程分析，请查看 应用级服务发现详解。</description></item><item><title>服务路由规则</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/router-module/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/router-module/</guid><description>条件路由 使用模式与 条件路由文档 中的模式类似，但配置格式略有不同，以下是条件路由规则示例。
基于以下示例规则，所有 org.apache.dubbo.sample.tri.Greeter 服务 greet 方法的调用都将被转发到有 port=8888 标记的地址子集
configVersion: v1.0 scope: &amp;#34;service&amp;#34; force: false enabled: true key: &amp;#34;org.apache.dubbo.sample.tri.Greeter&amp;#34; conditions: - method=greet =&amp;gt; port=8888 注：
dubbo rust目前还没有实现对于应用粒度的区分，无法区分服务来自哪个应用
因此对于标签路由和条件路由，都仅能配置一条应用级别的配置
对于应用级别的配置，默认key指定为application，此配置将对全部服务生效
例如：
configVersion: v1.0 scope: &amp;#34;application&amp;#34; force: false enabled: true key: application conditions: - ip=127.0.0.1 =&amp;gt; port=8000~8888 匹配/过滤条件 参数支持
服务调用上下文，如：service_name, method等 URL 本身的字段，如：location, ip, port等 URL params中存储的字段信息 条件支持
等号 = 表示 &amp;ldquo;匹配&amp;rdquo;，如：method = getComment 不等号 != 表示 &amp;ldquo;不匹配&amp;rdquo;，如：method != getComment 值支持</description></item><item><title>通过重试提高服务调用成功率</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/retry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/retry/</guid><description>在服务初次调用失败后，通过重试能有效的提升总体调用成功率。但也要注意重试可能带来的响应时间增长，系统负载升高等，另外，重试一般适用于只读服务，或者具有幂等性保证的写服务。
开始之前 部署 Shop 商城项目 部署并打开 Dubbo Admin 任务详情 成功登录商城项目后，商城会默认在首页展示当前登录用户的详细信息。
但有些时候，提供用户详情的 Dubbo 服务也会由于网络不稳定等各种原因变的不稳定，比如我们提供用户详情的 User 服务就很大概率会调用失败，导致用户无法看到账户的详细信息。
用户账户详情查询失败后的系统界面如下：
商城为了获得带来更好的使用体验，用户信息的加载过程是异步的，因此用户信息加载失败并不会影响对整个商城页面的正常访问，但如果能始终展示完整的用户信息总能给使用者留下更好的印象。
增加重试提高成功率 考虑到访问用户详情的过程是异步的（隐藏在页面加载背后），只要最终数据能加载出来，适当的增加等待时间并不是大的问题。因此，我们可以考虑通过对每次用户访问增加重试次数的方式，提高服务详情服务的整体访问成功率。
操作步骤 打开 Dubbo Admin 控制台 在左侧导航栏选择【服务治理】&amp;gt;【动态配置】 点击 &amp;ldquo;创建&amp;rdquo;，输入服务 org.apache.dubbo.samples.UserService 和失败重试次数如 4 即可。 保存后，尝试多次刷新页面，发现用户详情数据总是能正常显示，虽然有时由于重试的缘故加载时间会明显变长。
规则详解 规则 key ：org.apache.dubbo.samples.UserService
规则体
configVersion: v3.0 enabled: true configs: - side: consumer parameters: retries: 5 从 UserService 服务消费者视角（即 Frontend 应用）增加了调用失败后的重试次数。
parameters: retries: 5 side: consumer 配置会将规则发送到服务消费方实例，所有 UserService 服务实例会基于新的 timeout 值进行重新发布，并通过注册中心通知给所有消费方。
清理 为了不影响其他任务效果，通过 Admin 删除或者禁用刚刚配置的重试规则。</description></item><item><title>基础命令手册</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/introduction/command/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/introduction/command/</guid><description>基础命令功能提供了一系列的基础命令。
help 命令 显示更多命令
//列出所有命令 dubbo&amp;gt;help //列出单个命令的具体使用情况 dubbo&amp;gt;help online +--------------+----------------------------------------------------------------------------------+ | COMMAND NAME | online | +--------------+----------------------------------------------------------------------------------+ | EXAMPLE | online dubbo | | | online xx.xx.xxx.service | +--------------+----------------------------------------------------------------------------------+ dubbo&amp;gt; version 命令 显示当前运行的 Dubbo 的版本号
dubbo&amp;gt;version dubbo version &amp;#34;3.0.10-SNAPSHOT&amp;#34; dubbo&amp;gt; quit 命令 退出命令状态
dubbo&amp;gt;quit BYE! Connection closed by foreign host.</description></item><item><title>集群容错</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/fault-tolerent-strategy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/fault-tolerent-strategy/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。
各节点关系：
这里的 Invoker 是 Provider 的一个可调用 Service 的抽象，Invoker 封装了 Provider 地址及 Service 接口信息 Directory 代表多个 Invoker，可以把它看成 List&amp;lt;Invoker&amp;gt; ，但与 List 不同的是，它的值可能是动态变化的，比如注册中心推送变更 Cluster 将 Directory 中的多个 Invoker 伪装成一个 Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个 Router 负责从多个 Invoker 中按路由规则选出子集，比如读写分离，应用隔离等 LoadBalance 负责从多个 Invoker 中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选 集群容错模式 可以自行扩展集群容错策略，参见：集群扩展
Failover Cluster 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=&amp;quot;2&amp;quot; 来设置重试次数(不含第一次)。
重试次数配置如下：
&amp;lt;dubbo:service retries=&amp;#34;2&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:reference retries=&amp;#34;2&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:reference&amp;gt; &amp;lt;dubbo:method name=&amp;#34;findFoo&amp;#34; retries=&amp;#34;2&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; 提示 该配置为缺省配置 Failfast Cluster 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。
Failsafe Cluster 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</description></item><item><title>集群容错</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/fault-tolerent-strategy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/fault-tolerent-strategy/</guid><description>背景 在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。
各节点关系：
这里的 Invoker 是 Provider 的一个可调用 Service 的抽象，Invoker 封装了 Provider 地址及 Service 接口信息 Directory 代表多个 Invoker，可以把它看成 List&amp;lt;Invoker&amp;gt; ，但与 List 不同的是，它的值可能是动态变化的，比如注册中心推送变更 Cluster 将 Directory 中的多个 Invoker 伪装成一个 Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个 Router 负责从多个 Invoker 中按路由规则选出子集，比如读写分离，应用隔离等 LoadBalance 负责从多个 Invoker 中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选 集群容错模式 可以自行扩展集群容错策略，参见：集群扩展
Failover Cluster 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=&amp;quot;2&amp;quot; 来设置重试次数(不含第一次)。
重试次数配置如下：
&amp;lt;dubbo:service retries=&amp;#34;2&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:reference retries=&amp;#34;2&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:reference&amp;gt; &amp;lt;dubbo:method name=&amp;#34;findFoo&amp;#34; retries=&amp;#34;2&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; 提示 该配置为缺省配置 Failfast Cluster 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。
Failsafe Cluster 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</description></item><item><title>开发微服务</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/quickstart/microservices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/quickstart/microservices/</guid><description>本示例演示了使用 dubbo-go 开发微服务应用，为应用增加包括服务发现、负载均衡、流量管控等微服务核心能力。
前置条件 本示例我们继续使用 Protobuf 开发微服务应用，请参考 开发 rpc server 和 rpc client 了解如何安装 protoc、protoc-gen-go-triple 等必须插件。
快速运行示例 下载示例源码 我们在 apache/dubbo-go-samples 仓库维护了一系列 dubbo-go 使用示例，用来帮助用户快速学习 dubbo-go 使用方式。
你可以 下载示例zip包并解压，或者克隆仓库：
$ git clone --depth 1 https://github.com/apache/dubbo-go-samples 切换到快速开始示例目录：
$ cd dubbo-go-samples/registry/nacos 启动 Nacos 由于示例应用中启用了服务发现能力且使用 Nacos 作为注册中心，在运行示例之前需要先启动注册中心。请参考 Nacos 本地安装 了解如何快速安装和启动 Nacos。
运行 server 在 go-server/cmd 示例目录：
运行以下命令，启动 server：
$ go run server.go 使用 cURL 验证 server 正常启动：
$ curl \ --header &amp;#34;Content-Type: application/json&amp;#34; \ --data &amp;#39;{&amp;#34;name&amp;#34;: &amp;#34;Dubbo&amp;#34;}&amp;#39; \ http://localhost:50051/greet.</description></item><item><title>快速开始</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/quick-start/</guid><description>Dubbo 采用全 Spring 配置方式，透明化接入应用，对应用没有任何 API 侵入，只需用 Spring 加载 Dubbo 的配置即可，Dubbo 基于 Spring 的 Schema 扩展 进行加载。
如果不想使用 Spring 配置，可以通过 API 的方式 进行调用。
服务提供者 完整安装步骤，请参见：示例提供者安装
定义服务接口 DemoService.java 1：
package org.apache.dubbo.demo; public interface DemoService { String sayHello(String name); } 在服务提供方实现接口 DemoServiceImpl.java 2：
package org.apache.dubbo.demo.provider; import org.apache.dubbo.demo.DemoService; public class DemoServiceImpl implements DemoService { public String sayHello(String name) { return &amp;#34;Hello &amp;#34; + name; } } 用 Spring 配置声明暴露服务 provider.xml：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.</description></item><item><title>Dubbo 框架内置的并发控制策略</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/rate-limit/concurrency-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/rate-limit/concurrency-control/</guid><description>Dubbo 通过 Filter 拦截器机制，内置了并发控制策略实现。限制从同一客户端到同一服务的并发请求数，防止恶意请求使服务器过载，确保服务的稳定性，并防止使用过多资源。
控制某些服务的最大并发请求数，确保其他服务的资源可用性。系统过载和确保系统稳定性。 允许在需求增加时更平滑地扩展服务。 确保服务在高峰使用时间保持可靠和稳定。 注意 这种方式要求用户准确的预先评估系统能处理的并发数，而准确的评估系统处理能力并不是一件容易的事情，因此 Dubbo 还提供了自适应限流模式，根据系统负载自动识别系统健康程度并进行限流保护，可以在此查看 自适应限流模式使用文档。 限流策略配置 限制服务器端并发执行数(服务粒度) 限制 com.foo.BarService 的每个方法，服务器端并发执行（或占用线程池线程数）不能超过 10 个
XML 方式：
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; executes=&amp;#34;10&amp;#34; /&amp;gt; 注解方式：
@DubboService(executes=10) private DemoServiceImpl implements DemoService{} 限制服务器端并发执行数(方法粒度) 限制 com.foo.BarService 的 sayHello 方法，服务器端并发执行（或占用线程池线程数）不能超过 10 个
XML 方式：
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;sayHello&amp;#34; executes=&amp;#34;10&amp;#34; /&amp;gt; &amp;lt;/dubbo:service&amp;gt; 注解方式：
@DubboService(executes=10, methods = {@Method(name=&amp;#34;sayHello&amp;#34;,executes=10)}) private DemoServiceImpl implements DemoService{} 限制消费端并发调用数(服务粒度) 限制 com.foo.BarService 的每个方法，每客户端并发执行（或占用连接的请求数）不能超过 10 个
XML 方式：
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; actives=&amp;#34;10&amp;#34; /&amp;gt; 注解方式：</description></item><item><title>框架设计</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/design/</guid><description>整体设计 图例说明：
图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。 图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。 图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。 图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。 各层说明 config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类 proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool 关系说明 在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。 图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓扑节点，保持统一概念。 而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。 Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。 而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。 Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。 模块分包 模块说明：</description></item><item><title>QoS 命令列表，命令大全</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/qos-list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/qos-list/</guid><description>QoS 命令 说明 telnet 用法示例 http 用法示例 cd 设定服务上下文，cd 之后所有的命令都是针对该服务 cd org.demo.DemoService http://localhost:22222/cd?service=org.demo.DemoService count 展示服务或方法调用次数。暂时只支持 dubbo 协议，不支持 triple 协议；RpcStatus 实现依赖 Active/Limit Filter，需改造 count org.demo.DemoService count org.demo.DemoService methodName http://localhost:22222/count?service=org.demo.DemoService&amp;amp;method=methodName disableDetailProfiler 关闭 RPC 调用 profiler 工具（细粒度版本） disableDetailProfiler http://localhost:22222/disableDetailProfiler disableRouterSnapshot 关闭 RPC 请求 Router 路由结果跟踪 disableRouterSnapshot http://localhost:22222/disableRouterSnapshot disableSimpleProfiler 关闭 RPC 调用 profiler 工具（粗粒度版） disableSimpleProfiler http://localhost:22222/disableSimpleProfiler enableDetailProfiler 开启 RPC 调用 profiler 工具（细粒度版本） enableDetailProfiler http://localhost:22222/enableDetailProfiler enableRouterSnapshot 开启 RPC 请求 Router 路由结果跟踪，有助于跟踪路由规则执行是否符合预期 enableRouterSnapshot org.demo.DemoService http://localhost:22222/enableRouterSnapshot?service=org.demo.DemoService enableSimpleProfiler 开启 RPC 调用 profiler 工具（粗粒度版） enableSimpleProfiler http://localhost:22222/enableSimpleProfiler getAddress 查看某个服务的有效 ip 地址列表 getAddress org.</description></item><item><title>配置设计</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/principals/configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/principals/configuration/</guid><description>Dubbo 现在的设计是完全无侵入，也就是使用者只依赖于配置契约。经过多个版本的发展，为了满足各种需求场景，配置越来越多。为了保持兼容，配置只增不减，里面潜伏着各种风格，约定，规则。新版本也将配置做了一次调整，将想到的一些记在这，备忘。
配置分类 首先，配置的用途是有多种的，大致可以分为：
环境配置，比如：连接数，超时等配置。 描述配置，比如：服务接口描述，服务版本等。 扩展配置，比如：协议扩展，策略扩展等。 配置格式 通常环境配置，用 properties 配置会比较方便，因为都是一些离散的简单值，用 key-value 配置可以减少配置的学习成本。
而描述配置，通常信息比较多，甚至有层次关系，用 xml 配置会比较方便，因为树结构的配置表现力更强。如果非常复杂，也可以考虑自定义 DSL 做为配置。有时候这类配置也可以用 Annotation 代替， 因为这些配置和业务逻辑相关，放在代码里也是合理的。
另外扩展配置，可能不尽相同。如果只是策略接口实现类替换，可以考虑 properties 等结构。如果有复杂的生命周期管理，可能需要 XML 等配置。有时候扩展会通过注册接口的方式提供。
配置加载 对于环境配置，在 java 世界里，比较常规的做法，是在 classpath 下约定一个以项目为名称的 properties 配置，比如：log4j.properties，velocity.properties等。产品在初始化时，自动从 classpath 下加载该配置。我们平台的很多项目也使用类似策略，如：dubbo.properties，comsat.xml 等。这样有它的优势，就是基于约定，简化了用户对配置加载过程的干预。但同样有它的缺点，当 classpath 存在同样的配置时，可能误加载，以及在 ClassLoader 隔离时，可能找不到配置，并且，当用户希望将配置放到统一的目录时，不太方便。
而对于描述配置，因为要参与业务逻辑，通常会嵌到应用的生命周期管理中。现在使用 spring 的项目越来越多，直接使用 spring 配置的比较普遍，而且 spring 允许自定义 schema，配置简化后很方便。当然，也有它的缺点，就是强依赖 spring，可以提编程接口做了配套方案。
在 Dubbo 既存在描述配置也有环境配置。一部分用 spring 的 schema 做配置加载，一部分从 classpath 扫描 properties 做配置加载。在新版本中做了一个优先级约定，统一以 spring 的 schema 驱动配置加载，dubbo.properties作为配置补充。
同时，在 Spring 的场景下，除了使用 schema 外，还支持完全以 application.</description></item><item><title>配置中心参考手册</title><link>https://dubbo.apache.org/zh-cn/docs/references/config-center/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/config-center/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
配置中心在 Dubbo 中承担3个职责：
外部化配置：启动配置的集中式存储 （简单理解为 dubbo.properties 的外部化存储）。 服务治理：服务治理规则的存储与通知。 动态配置：控制动态开关或者动态变更属性值 启用动态配置，以 Zookeeper 为例，可查看 配置中心属性详解
&amp;lt;dubbo:config-center address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; 或者
dubbo.config-center.address=zookeeper://127.0.0.1:2181 或者
ConfigCenterConfig configCenter = new ConfigCenterConfig(); configCenter.setAddress(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;); 为了兼容 2.6.x 版本配置，在使用 Zookeeper 作为注册中心，且没有显示配置配置中心的情况下，Dubbo 框架会默认将此 Zookeeper 用作配置中心，但将只作服务治理用途。
外部化配置 请参考文档 外部化配置
动态配置 [TODO 待完善]
服务治理 Zookeeper 默认节点结构：
namespace，用于不同配置的环境隔离。 config，Dubbo 约定的固定节点，不可更改，所有配置和服务治理规则都存储在此节点下。 dubbo，所有服务治理规则都是全局性的，dubbo 为默认节点 configurators/tag-router/condition-router/migration，不同的服务治理规则类型，node value 存储具体规则内容 Apollo 所有的服务治理规则都是全局性的，默认从公共命名空间 dubbo 读取和订阅：
不同的规则以不同的 key 后缀区分：
configurators，覆盖规则 tag-router，标签路由 condition-router，条件路由 migration，迁移规则 Nacos 所有的服务治理规则都是全局的，默认从 namespace: public 下进行读取， 通过 dataId: interface name 以及 group: dubbo 去读取和订阅：</description></item><item><title>升级到triple协议</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/upgrades-and-compatibility/migration-triple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/upgrades-and-compatibility/migration-triple/</guid><description>请注意 本文档内容并不是升级 Dubbo3 必须的，您完全可以只升级框架并继续使用 dubbo 通信协议。 如果您是 Dubbo 新用户，强烈建议直接 使用 triple 协议 即可。 本文档适合服务已经运行在 dubbo 协议之上的老用户，请先参考上一篇文档 如何从 Dubbo2 升级到 Dubbo3 完成框架版本升级，然后遵循以下步骤以最小改动平滑迁移到 triple 协议。
以下是协议升级的架构图，展示了平滑升级过程中不同 Dubbo 应用的状态：
按先后顺序，升级基本步骤如下：
Provider 提供者侧配置单端口双协议（dubbo、triple）发布 Provider 提供者侧配置首选协议为 triple（此时，提供者注册的URL地址为 dubbo://host:port/DemoService?preferred-protocol=tri） Consumer 消费者升级，根据情况不同有以下两种方式： 升级消费者到 3.3 版本，消费者会根据 preferred-protocol=tri 优先调用 triple 协议 无法升级到 3.3 版本的消费者应用，可以配置 @DubboReference(protocol=&amp;quot;tri&amp;quot;) 调用 triple 协议 推动所有应用升级到最新 Dubbo3 版本，最终所有流量都是 triple 协议 请注意 请注意，以上提到的单端口多协议、识别 preferred-protocol 首选协议等功能，需要 Dubbo 3.3.0+ 版本！ 步骤一：提供者双协议发布 假设我们有以下应用配置，即在 20880 端口发布 dubbo 协议：
dubbo: protocol: name: dubbo port: 20880 我们需要增加两个配置项，如下所示：</description></item><item><title>示例提供者安装</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/admin/install/provider-demo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/admin/install/provider-demo/</guid><description>安装：
git clone https://github.com/apache/dubbo.git cd dubbo/dubbo-demo/dubbo-demo-xml 运行 dubbo-demo-xml-provider中的org.apache.dubbo.demo.provider.Application 如果使用Intellij Idea 请加上-Djava.net.preferIPv4Stack=true 配置：
resources/spring/dubbo-provider.xml 修改其中的dubbo:registry，替换成真实的注册中心地址，推荐使用zookeeper，如： &amp;lt;dubbo:registry address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt;</description></item><item><title>属性配置</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/configuration/properties/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/configuration/properties/</guid><description>如果你的应用足够简单，例如，不需要多注册中心或多协议，并且需要在spring容器中共享配置，那么，我们可以直接使用 dubbo.properties 作为默认配置。
Dubbo 可以自动加载 classpath 根目录下的 dubbo.properties，但是你同样可以使用 JVM 参数来指定路径：-Ddubbo.properties.file=xxx.properties。
映射规则 可以将 xml 的 tag 名和属性名组合起来，用 ‘.’ 分隔。每行一个属性。
dubbo.application.name=foo 相当于 &amp;lt;dubbo:application name=&amp;quot;foo&amp;quot; /&amp;gt; dubbo.registry.address=10.20.153.10:9090 相当于 &amp;lt;dubbo:registry address=&amp;quot;10.20.153.10:9090&amp;quot; /&amp;gt; 如果在 xml 配置中有超过一个的 tag，那么你可以使用 ‘id’ 进行区分。如果你不指定 id，它将作用于所有 tag。
dubbo.protocol.rmi.port=1099 相当于 &amp;lt;dubbo:protocol id=&amp;quot;rmi&amp;quot; name=&amp;quot;rmi&amp;quot; port=&amp;quot;1099&amp;quot; /&amp;gt; dubbo.registry.china.address=10.20.153.10:9090 相当于 &amp;lt;dubbo:registry id=&amp;quot;china&amp;quot; address=&amp;quot;10.20.153.10:9090&amp;quot; /&amp;gt; 如下，是一个典型的 dubbo.properties 配置样例。
dubbo.application.name=foo dubbo.application.owner=bar dubbo.registry.address=10.20.153.10:9090 重写与优先级 优先级从高到低：
JVM -D 参数：当你部署或者启动应用时，它可以轻易地重写配置，比如，改变 dubbo 协议端口； XML：XML 中的当前配置会重写 dubbo.properties 中的； Properties：默认配置，仅仅作用于以上两者没有配置时。 如果在 classpath 下有超过一个 dubbo.</description></item><item><title>Admin 服务查询</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/control-plane/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/control-plane/search/</guid><description>Admin 支持可视化的展示 Dubbo 微服务集群的状态，方便用户从全局掌握集群的应用、服务和实例分布，Admin 还可以通过查询的方式了解某一个服务更详细的信息：
首页集群大盘，展示集群应用、服务、示例的总体分布，集群总体流量情况等 支持根据应用名、服务名(可包含版本&amp;amp;分组)、实例 IP 查询详细信息 支持服务名/应用名的自动补全 支持查看单条服务实例的详情 首页大盘 根据 Dubbo 服务名查询 精确输入接口名:版本 查询服务
通过 * 通配符模糊查询服务
根据应用名查询 输入应用名查询某应用关联的所有服务（包含提供和消费的服务）
根据实例 IP 名查询 输入实例 IP 查询某实例关联的所有服务（包含提供和消费的服务）
支持基于端口过滤服务
查看服务实例详情 在服务列表点击 详情 查看服务详细情况</description></item><item><title>消费端线程模型，提供者端线程模型</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/threading-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/threading-model/</guid><description>消费端线程模型 对 2.7.5 版本之前的 Dubbo 应用，尤其是一些消费端应用，当面临需要消费大量服务且并发数比较大的大流量场景时（典型如网关类场景），经常会出现消费端线程数分配过多的问题，具体问题讨论可参见 Need a limited Threadpool in consumer side #2013
改进后的消费端线程池模型，通过复用业务端被阻塞的线程，很好的解决了这个问题。
老的线程池模型
我们重点关注 Consumer 部分：
业务线程发出请求，拿到一个 Future 实例。 业务线程紧接着调用 future.get 阻塞等待业务结果返回。 当业务数据返回后，交由独立的 Consumer 端线程池进行反序列化等处理，并调用 future.set 将反序列化后的业务结果置回。 业务线程拿到结果直接返回 当前线程池模型
业务线程发出请求，拿到一个 Future 实例。 在调用 future.get() 之前，先调用 ThreadlessExecutor.wait()，wait 会使业务线程在一个阻塞队列上等待，直到队列中被加入元素。 当业务数据返回后，生成一个 Runnable Task 并放入 ThreadlessExecutor 队列 业务线程将 Task 取出并在本线程中执行：反序列化业务数据并 set 到 Future。 业务线程拿到结果直接返回 这样，相比于老的线程池模型，由业务线程自己负责监测并解析返回结果，免去了额外的消费端线程池开销。
提供端线程模型 Dubbo协议的和Triple协议目前的线程模型还并没有对齐，下面分开介绍Triple协议和Dubbo协议的线程模型。
Dubbo协议 介绍Dubbo协议的Provider端线程模型之前，先介绍Dubbo对channel上的操作抽象成了五种行为：
建立连接：connected，主要是的职责是在channel记录read、write的时间，以及处理建立连接后的回调逻辑，比如dubbo支持在断开后自定义回调的hook（onconnect），即在该操作中执行。 断开连接：disconnected，主要是的职责是在channel移除read、write的时间，以及处理端开连接后的回调逻辑，比如dubbo支持在断开后自定义回调的hook（ondisconnect），即在该操作中执行。 发送消息：sent，包括发送请求和发送响应。记录write的时间。 接收消息：received，包括接收请求和接收响应。记录read的时间。 异常捕获：caught，用于处理在channel上发生的各类异常。 Dubbo框架的线程模型与以上这五种行为息息相关，Dubbo协议Provider线程模型可以分为五类，也就是AllDispatcher、DirectDispatcher、MessageOnlyDispatcher、ExecutionDispatcher、ConnectionOrderedDispatcher。
配置方式 线程模型 配置值 All Dispatcher all Direct Dispatcher direct Execution Dispatcher execution Message Only Dispatcher message Connection Ordered Dispatcher connection 拿 application.</description></item><item><title>消费者配置</title><link>https://dubbo.apache.org/zh-cn/docs/languages/erlang/reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/erlang/reference/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
基础配置 消费者配置项需要添加到 sys.config 文件 dubboerl 应用配置项里。
{dubboerl,[ %% other config ... {consumer,[ {&amp;lt;&amp;lt;&amp;#34;interface fullname&amp;#34;&amp;gt;&amp;gt;,[Option]}, %% eg: {&amp;lt;&amp;lt;&amp;#34;org.apache.dubbo.erlang.sample.service.facade.UserOperator&amp;#34;&amp;gt;&amp;gt;,[]}, ]} ]} Option 配置项待添加中。</description></item><item><title>消费者配置</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/languages/erlang/reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/languages/erlang/reference/</guid><description>基础配置 消费者配置项需要添加到 sys.config 文件 dubboerl 应用配置项里。
{dubboerl,[ %% other config ... {consumer,[ {&amp;lt;&amp;lt;&amp;#34;interface fullname&amp;#34;&amp;gt;&amp;gt;,[Option]}, %% eg: {&amp;lt;&amp;lt;&amp;#34;org.apache.dubbo.erlang.sample.service.facade.UserOperator&amp;#34;&amp;gt;&amp;gt;,[]}, ]} ]} Option 配置项待添加中。</description></item><item><title>消费者配置</title><link>https://dubbo.apache.org/zh-cn/overview/reference/erlang-sdk/reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/erlang-sdk/reference/</guid><description>基础配置 消费者配置项需要添加到 sys.config 文件 dubboerl 应用配置项里。
{dubboerl,[ %% other config ... {consumer,[ {&amp;lt;&amp;lt;&amp;#34;interface fullname&amp;#34;&amp;gt;&amp;gt;,[Option]}, %% eg: {&amp;lt;&amp;lt;&amp;#34;org.apache.dubbo.erlang.sample.service.facade.UserOperator&amp;#34;&amp;gt;&amp;gt;,[]}, ]} ]} Option 配置项待添加中。</description></item><item><title>RPC 通信协议</title><link>https://dubbo.apache.org/zh-cn/docs/concepts/rpc-protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/concepts/rpc-protocol/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo3 提供了 Triple(Dubbo3)、Dubbo2 协议，这是 Dubbo 框架的原生协议。除此之外，Dubbo3 也对众多第三方协议进行了集成，并将它们纳入 Dubbo 的编程与服务治理体系， 包括 gRPC、Thrift、JsonRPC、Hessian2、REST 等。以下重点介绍 Triple 与 Dubbo2 协议。
Triple 协议 Triple 协议是 Dubbo3 推出的主力协议。Triple 意为第三代，通过 Dubbo1.0/ Dubbo2.0 两代协议的演进，以及云原生带来的技术标准化浪潮，Dubbo3 新协议 Triple 应运而生。
RPC 协议的选择 协议是 RPC 的核心，它规范了数据在网络中的传输内容和格式。除必须的请求、响应数据外，通常还会包含额外控制数据，如单次请求的序列化方式、超时时间、压缩方式和鉴权信息等。
协议的内容包含三部分
数据交换格式： 定义 RPC 的请求和响应对象在网络传输中的字节流内容，也叫作序列化方式 协议结构： 定义包含字段列表和各字段语义以及不同字段的排列方式 协议通过定义规则、格式和语义来约定数据如何在网络间传输。一次成功的 RPC 需要通信的两端都能够按照协议约定进行网络字节流的读写和对象转换。如果两端对使用的协议不能达成一致，就会出现鸡同鸭讲，无法满足远程通信的需求。 RPC 协议的设计需要考虑以下内容：
通用性： 统一的二进制格式，跨语言、跨平台、多传输层协议支持 扩展性： 协议增加字段、升级、支持用户扩展和附加业务元数据 性能：As fast as it can be 穿透性：能够被各种终端设备识别和转发：网关、代理服务器等 通用性和高性能通常无法同时达到，需要协议设计者进行一定的取舍。 HTTP/1.1 比于直接构建于 TCP 传输层的私有 RPC 协议，构建于 HTTP 之上的远程调用解决方案会有更好的通用性，如WebServices 或 REST 架构，使用 HTTP + JSON 可以说是一个事实标准的解决方案。</description></item><item><title>协议识别</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/migration/deploy-on-k8s/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/migration/deploy-on-k8s/</guid><description>可以按照下文步骤，将 Dubbo 服务轻松部署到 Kubernetes 集群，此查看文章用到的 完整代码示例地址
1 总体目标 部署 Dubbo 应用到 Kubernetes 基于 Kubernetes 内置 Service 实现服务发现 将 Dubbo 应用对接到 Kubernetes 生命周期 2 基本流程 创建一个 Dubbo 应用( dubbo-samples-kubernetes ) 构建容器镜像并推送到镜像仓库（ dubbo-demo 示例例镜像 ） 分别部署 Dubbo Provider 与 Dubbo Consumer 到 Kubernetes 验证服务发现与调用正常 3 详细步骤 3.1 环境要求 请确保本地安装如下环境，以提供容器运行时、Kubernetes集群及访问工具
Docker Minikube Kubectl Kubens(optional) 通过以下命令启动本地 Kubernetes 集群
minikube start 通过 kubectl 检查集群正常运行，且 kubectl 绑定到默认本地集群
kubectl cluster-info 3.2 前置条件 由于示例 Dubbo 项目均部署在 Pod 中且与 API-SERVER 有交互，因此有相应的权限要求，我们这里创建独立 ServiceAccount 并绑定必须的 Roles，后面所有的 Dubbo Kubernetes 资源都将使用这里新建的 ServiceAccount。</description></item><item><title>What's New in Dubbo3</title><link>https://dubbo.apache.org/zh-cn/docs/new-in-dubbo3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/new-in-dubbo3/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
全新服务发现模型 相比于 2.x 版本中的基于接口粒度的服务发现机制，3.x 引入了全新的基于应用粒度的服务发现机制， 新模型带来两方面的巨大优势：
进一步提升了 Dubbo3 在大规模集群实践中的性能与稳定性。新模型可大幅提高系统资源利用率，降低 Dubbo 地址的单机内存消耗（50%），降低注册中心集群的存储与推送压力（90%）， Dubbo 可支持集群规模步入百万实例层次。 打通与其他异构微服务体系的地址互发现障碍。新模型使得 Dubbo3 能实现与异构微服务体系如Spring Cloud、Kubernetes Service、gRPC 等，在地址发现层面的互通， 为连通 Dubbo 与其他微服务体系提供可行方案。 在 Dubbo3 前期版本将会同时提供对两套地址发现模型的支持，以最大程度保证业务升级的兼容性。
下一代 RPC 通信协议 定义了全新的 RPC 通信协议 &amp;ndash; Triple，一句话概括 Triple：它是基于 HTTP/2 上构建的 RPC 协议，完全兼容 gRPC，并在此基础上扩展出了更丰富的语义。 使用 Triple 协议，用户将获得以下能力
更容易到适配网关、Mesh架构，Triple 协议让 Dubbo 更方便的与各种网关、Sidecar 组件配合工作。 多语言友好，推荐配合 Protobuf 使用 Triple 协议，使用 IDL 定义服务，使用 Protobuf 编码业务数据。 流式通信支持。Triple 协议支持 Request Stream、Response Stream、Bi-direction Stream 云原生 Dubbo3 构建的业务应用可直接部署在 VM、Container、Kubernetes 等平台，Dubbo3 很好的解决了 Dubbo 服务与调度平台之间的生命周期对齐，Dubbo 服务发现地址 与容器平台绑定的问题。</description></item><item><title>新贡献者向导</title><link>https://dubbo.apache.org/zh-cn/contact/contributor/new-contributor-guide_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/contact/contributor/new-contributor-guide_dev/</guid><description>这篇向导旨在给正在准备向 Dubbo 提交贡献的新手提供指导。
邮件列表描述 邮件列表是 Dubbo 官方推荐的讨论方式，所有与 Dubbo 相关的内容都可以在这里讨论，请点击 Issue 了解更多关于邮件列表订阅的内容
如需订阅如下邮件列表，请参考 邮件列表订阅向导
dev@dubbo.apache.org：开发邮件列表，您在使用或者开发 Dubbo 的过程中遇到的任何问题，都可以在这里进行提问。 commits@dubbo.apache.org：所有的提交内容都会推送到这个邮件列表，如果您对 Dubbo 的进展感兴趣，可以订阅这个邮件列表。 issues@dubbo.apache.org：所有的 JIRA Issues 和修改信息都会推送到这个邮件列表。Dubbo 社区已经决定使用 GitHub Issues 代替 JIRA Issues，因此大部分 Issues 将由 GitHub Issues 进行跟踪。JIRA Issues 用于跟踪 ASF 相关问题。 报告问题 非安全问题直接在 GitHub Issue 中提出，另请参考 Issue Template 。 安全问题请参考 “反馈漏洞” 。 贡献代码流程 此贡献流程适用于所有的 Apache Dubbo 社区内容，包括但不限于 dubbo（主干仓库）、dubbo-admin、dubbo-website。
以下以贡献 dubbo （主干仓库） 为例，详细说明贡献流程。
1. Fork apache/dubbo 项目到您的 GitHub 帐号下 2. 克隆您 Fork 的 Dubbo 代码仓库到您本地 git clone ${your fork dubbo repo address，for example：https://github.</description></item><item><title>应用级地址发现迁移指南</title><link>https://dubbo.apache.org/zh-cn/docs/migration/migration-service-discovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/migration/migration-service-discovery/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
总体上来说，在地址注册与发现环节，3.x 是完全兼容 2.x 版本的，这意味着，用户可以选择将集群内任意数量的应用或机器升级到 3.x，同时在这个过程中保持与 2.x 版本的互操作性。
1 快速升级步骤 简单的修改 pom.xml 到最新版本就可以完成升级，如果要迁移到应用级地址，只需要调整开关控制 3.x 版本的默认行为。
升级 Provider 应用到最新 3.x 版本依赖，配置双注册开关dubbo.application.register-mode=all（建议通过全局配置中心设置，默认已自动开启），完成应用发布。 升级 Consumer 应用到最新 3.x 版本依赖，配置双订阅开关dubbo.application.service-discovery.migration=APPLICATION_FIRST（建议通过全局配置中心设置，默认已自动开启），完成应用发布。 在确认 Provider 的上有 Consumer 全部完成应用级地址迁移后，Provider 切到应用级地址单注册。完成升级 以下是关于迁移流程的详细描述。
2 Provider 端升级过程详解 在不改变任何 Dubbo 配置的情况下，可以将一个应用或实例升级到 3.x 版本，升级后的 Dubbo 实例会默保保证与 2.x 版本的兼容性，即会正常注册 2.x 格式的地址到注册中心，因此升级后的实例仍会对整个集群仍保持可见状态。
同时新的地址发现模型（注册应用级别的地址）也将会自动注册。
通过 -D 参数，可以指定 provider 启动时的注册行为
-Ddubbo.application.register-mode=all # 可选值 interface、instance、all，默认是 all，即接口级地址、应用级地址都注册 另外，可以在配置中心修改全局默认行为，来控制所有 3.x 实例注册行为。其中，全局性开关的优先级低于 -D 参数。
为了保证平滑迁移，即升级到 3.x 的实例能同时被 2.x 与 3.x 的消费者实例发现，3.x 实例需要开启双注册；当所有上游的消费端都迁移到 3.</description></item><item><title>与 gRPC、Spring Cloud、Istio 的关系</title><link>https://dubbo.apache.org/zh-cn/overview/what/xyz-difference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/xyz-difference/</guid><description>很多开发者经常会问到 Apache Dubbo 与 Spring Cloud、gRPC 以及一些 Service Mesh 项目如 Istio 的关系，要解释清楚它们的关系并不困难，你只需要跟随这篇文章和 Dubbo 文档做一些更深入的了解，但总的来说，它们之间有些能力是重合的，但在一些场景你可以把它们放在一起使用。
虽然这是一篇 Dubbo 维护者写的文档，我们仍会尽力将 Dubbo 与其他组件之间的联系与差异客观、透明的展现出来，但考虑到每个人对不同产品的熟悉程度不一，这里的个别表述可能并不完全准确，希望能给开发者带来帮助。
Dubbo 与 Spring Cloud 从上图我们可以看出，Dubbo 和 Spring Cloud 有很多相似之处，它们都在整个架构图的相同位置并提供一些相似的功能。
Dubbo 和 Spring Cloud 都侧重在对分布式系统中常见问题模式的抽象（如服务发现、负载均衡、动态配置等），同时对每一个问题都提供了配套组件实现，形成了一套微服务整体解决方案，让使用 Dubbo 及 Spring Cloud 的用户在开发微服务应用时可以专注在业务逻辑开发上。 Dubbo 和 Spring Cloud 都完全兼容 Spring 体系的应用开发模式，Dubbo 对 Spring 应用开发框架、Spring Boot 微服务框架都做了很好的适配，由于 Spring Cloud 出自 Spring 体系，在这一点上自然更不必多说。 虽然两者有很多相似之处，但由于它们在诞生背景与架构设计上的巨大差异，两者在性能、适用的微服务集群规模、生产稳定性保障、服务治理等方面都有很大差异。
Spring Cloud 的优势在于：
同样都支持 Spring 开发体系的情况下，Spring Cloud 得到更多的原生支持 对一些常用的微服务模式做了抽象如服务发现、动态配置、异步消息等，同时包括一些批处理任务、定时任务、持久化数据访问等领域也有涉猎。 基于 HTTP 的通信模式，加上相对比较完善的入门文档和演示 demo 和 starters，让开发者在第一感觉上更易于上手 Spring Cloud 的问题有：</description></item><item><title>注册中心、配置中心和元数据中心</title><link>https://dubbo.apache.org/zh-cn/overview/reference/proposals/registry-config-meta/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/proposals/registry-config-meta/</guid><description>三中心逻辑架构 本节侧重描述传统模式下的 Dubbo 部署架构，在云原生背景下的部署架构会有些变化，主要体现在基础设施（Kubernetes、Service Mesh等）会承担更多的职责， 中心化组件如注册中心、元数据中心、配置中心等的职责被集成、运维变得更加简单，但通过强调这些中心化的组件能让我们更容易理解 Dubbo 的工作原理。
作为一个微服务框架，Dubbo sdk 跟随着微服务组件被部署在分布式集群各个位置，为了在分布式环境下实现各个微服务组件间的协作， Dubbo 定义了一些中心化组件，这包括：
注册中心。协调 Consumer 与 Provider 之间的地址注册与发现 配置中心。 存储 Dubbo 启动阶段的全局配置，保证配置的跨环境共享与全局一致性 负责服务治理规则（路由规则、动态配置等）的存储与推送。 元数据中心。 接收 Provider 上报的服务接口元数据，为 Admin 等控制台提供运维能力（如服务测试、接口文档等） 作为服务发现机制的补充，提供额外的接口/方法级别配置信息的同步能力，相当于注册中心的额外扩展 上图完整的描述了 Dubbo 微服务组件与各个中心的交互过程。
以上三个中心并不是运行 Dubbo 的必要条件，用户完全可以根据自身业务情况决定只启用其中一个或多个，以达到简化部署的目的。通常情况下，所有用户都会以独立的注册中心 以开始 Dubbo 服务开发，而配置中心、元数据中心则会在微服务演进的过程中逐步的按需被引入进来。
注册中心 注册中心扮演着非常重要的角色，它承载着服务注册和服务发现的职责。目前Dubbo支持以下两种粒度的服务发现和服务注册，分别是接口级别和应用级别，注册中心可以按需进行部署：
在传统的Dubbo SDK使用姿势中，如果仅仅提供直连模式的RPC服务，不需要部署注册中心。
无论是接口级别还是应用级别，如果需要Dubbo SDK自身来做服务注册和服务发现，则可以选择部署注册中心，在Dubbo中集成对应的注册中心。
在Dubbo + Mesh 的场景下，随着 Dubbo 服务注册能力的弱化，Dubbo内的注册中心也不再是必选项，其职责开始被控制面取代，如果采用了Dubbo + Mesh的部署方式，无论是ThinSDK的mesh方式还是Proxyless的mesh方式，都不再需要独立部署注册中心。
而注册中心并不依赖于配置中心和元数据中心，如下图所示：
该图中没有部署配置中心和元数据中心，在Dubbo中会默认将注册中心的实例同时作为配置中心和元数据中心，这是Dubbo的默认行为，如果确实不需要配置中心或者元数据中心的能力，可在配置中关闭，在注册中心的配置中有两个配置分别为use-as-config-center和use-as-metadata-center，将配置置为false即可。
元数据中心 元数据中心在2.7.x版本开始支持，随着应用级别的服务注册和服务发现在Dubbo中落地，元数据中心也变的越来越重要。在以下几种情况下会需要部署元数据中心：
对于一个原先采用老版本Dubbo搭建的应用服务，在迁移到Dubbo 3时，Dubbo 3 会需要一个元数据中心来维护RPC服务与应用的映射关系（即接口与应用的映射关系），因为如果采用了应用级别的服务发现和服务注册，在注册中心中将采用“应用 —— 实例列表”结构的数据组织形式，不再是以往的“接口 —— 实例列表”结构的数据组织形式，而以往用接口级别的服务注册和服务发现的应用服务在迁移到应用级别时，得不到接口与应用之间的对应关系，从而无法从注册中心得到实例列表信息，所以Dubbo为了兼容这种场景，在Provider端启动时，会往元数据中心存储接口与应用的映射关系。 为了让注册中心更加聚焦于地址的发现和推送能力，减轻注册中心的负担，元数据中心承载了所有的服务元数据、大量接口/方法级别配置信息等，无论是接口粒度还是应用粒度的服务发现和注册，元数据中心都起到了重要的作用。 如果有以上两种需求，都可以选择部署元数据中心，并通过Dubbo的配置来集成该元数据中心。
元数据中心并不依赖于注册中心和配置中心，用户可以自由选择是否集成和部署元数据中心，如下图所示：
该图中不配备配置中心，意味着可以不需要全局管理配置的能力。该图中不配备注册中心，意味着可能采用了Dubbo mesh的方案，也可能不需要进行服务注册，仅仅接收直连模式的服务调用。</description></item><item><title>自动加载环境变量</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/configuration/environment-variables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/configuration/environment-variables/</guid><description>从 2.7.3 版本开始，Dubbo 会自动从约定 key 中读取配置，并将配置以 Key-Value 的形式写入到URL中。
支持的 key 有以下两个：
dubbo.labels，指定一些列配置到 URL 中的键值对，通常通过 JVM -D 或系统环境变量指定。
增加以下配置：
# JVM -Ddubbo.labels = &amp;#34;tag1=value1; tag2=value2&amp;#34; # 环境变量 DUBBO_LABELS = &amp;#34;tag1=value1; tag2=value2&amp;#34; 最终生成的 URL 会包含 tag1、tag2 两个 key: dubbo://xxx?tag1=value1&amp;amp;tag2=value2
dubbo.env.keys，指定环境变量 key 值，Dubbo 会尝试从环境变量加载每个 key
# JVM -Ddubbo.env.keys = &amp;#34;DUBBO_TAG1, DUBBO_TAG2&amp;#34; # 环境变量 DUBBO_ENV_KEYS = &amp;#34;DUBBO_TAG1, DUBBO_TAG2&amp;#34; 最终生成的 URL 会包含 DUBBO_TAG1、DUBBO_TAG2 两个 key: dubbo://xxx?DUBBO_TAG1=value1&amp;amp;DUBBO_TAG2=value2</description></item><item><title>Dubbo Admin 控制面总体架构设计</title><link>https://dubbo.apache.org/zh-cn/overview/reference/proposals/admin/</link><pubDate>Tue, 28 Feb 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/proposals/admin/</guid><description>1 Dubbo 整体架构 架构上分为：服务治理抽象控制面 和 Dubbo 数据面 。
服务治理控制面。控制面包含注册中心、流量管控策略、Admin 控制台、Istio、OpenSergo 等组件。 Dubbo 数据面。数据面代表集群部署的所有 Dubbo 进程，进程之间通过 RPC 协议实现数据交换，并与控制面进行治理策略交互。 **进一步解释：**https://cn.dubbo.apache.org/zh-cn/overview/what/overview/
Dubbo Admin 的整体定位与解释 Dubbo Admin 是对微服务治理体系的统一定义与抽象，通过自定义核心组件与一系列配套工具，为不同部署架构和基础设施环境下部署的微服务集群带来统一的开发与运维差异。
2 面向用户的开发步骤 第一步：安装 Dubbo Stack/Admin 核心思路是，屏蔽架构差异，通过统一入口将治理组件的安装和配置纳入成为 Dubbo 体系中的前置步骤
dubboctl install dubbo-stack 安装请参见: Dubbo Admin 安装指南
第二步：服务框架开发 Java Go Node.js Rust 3 控制面方案 3.1 确定 Dubbo 微服务治理体系的核心能力 服务发现 配置管理 流量治理规则 安全基础设施 可视化控制台 3.2 统一服务治理层接入方式 **对于任何微服务部署模式，Dubbo 数据面统一面向 ****dubbo://hopst:ip**抽象服务治理控制面编程。
具体工作流程：
数据面通过配置先与 admin 组件进行交互，admin 返回当前部署架构下的实际注册中心、配置中心等组件地址，如图中的 nacos://host:port。 数据面组件接收到新的组件地址后，直接与 Nacos 建立通信，此后依赖 Nacos 完成服务发现等功能。 3.</description></item><item><title>饿了么全站成功升级 Dubbo3</title><link>https://dubbo.apache.org/zh-cn/blog/2023/01/15/%E9%A5%BF%E4%BA%86%E4%B9%88%E5%85%A8%E7%AB%99%E6%88%90%E5%8A%9F%E5%8D%87%E7%BA%A7-dubbo3/</link><pubDate>Sun, 15 Jan 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/01/15/%E9%A5%BF%E4%BA%86%E4%B9%88%E5%85%A8%E7%AB%99%E6%88%90%E5%8A%9F%E5%8D%87%E7%BA%A7-dubbo3/</guid><description>升级目标 这里是饿了么的的基本部署架构图。
在升级之前，饿了么的微服务框架采用的是 HSF2，跨单元的 RPC 调用是通过 proxy 中转代理，在这个过程中 proxy 所承载的机器数和流量迅速增长，比较突出的一点是 proxy 在订阅所有的地址数据后资源消耗和稳定性都收到严峻挑战。
通过全站升级 Dubbo3，业务线期望达到两个目标：
将地址模型切换到应用级服务发现大幅减轻中心化节点和消费端节点的资源消耗压力。 以应用级服务发现架构下的全局共享注册中心取代 proxy 模式，实现跨单元节点通信直连。 升级过程 不论是针对 Dubbo2 还是 HSF2，我们都做了全面的 API 兼容，因此 Dubbo3 基本可以做到零改造升级，并且每个应用都是独立透明升级，不需要关心它的上下游应用的升级状态，因为 Dubbo3 升级之后不论是从地址发现模型还是协议的默认行为都保持与 2.0 版本兼容，用户可以在任意时间点对任意应用按需切换 Dubbo3 行为。 如右图所示，我们模拟展示了饿了么集群 Dubbo3 升级过程的一个中间状态，其中灰色标记的是老版本 HSF2 应用，橙色和绿色标记的是已经升级 Dubbo3 的应用，橙色部分的应用及其调用链路代表不但已经升级到 Dubbo3，同时也完成了 Dubbo3 行为的切换，在这里是指已经切换到了应用级地址模型。这里的升级过程主要为了说明 Dubbo3 框架升级的兼容性和独立性。
接下来，我们详细分析一下橙色部分节点往 Dubbo3 应用级发现迁移的具体过程。
首先看 Provider 侧，服务提供者在升级 Dubbo3 后会默认保持双注册行为，即同时注册接口级地址和应用级地址到注册中心，一方面保持兼容，另一方面为未来消费端迁移做好准备。双注册的开关可通过 -Ddubbo.application.register-mode=al/interface/interface控制，我们推荐保持双注册的默认行为以减少后续迁移成本。
大家可能担心双注册给注册中心带来的存储压力，实际上在应用级服务发现模型下这并不是一个问题，因为大家如果回想前面我们对应用级服务发现工作原理的分析，注册地址已经被大幅精简，根据我们实际推算，每多注册一条应用级服务发现 URL 地址，只会增加 0.1% ～ 1% 的额外开销。
与提供端类似，要实现平滑迁移消费端也要经历双订阅的过程，流程上就不再赘述。消费端的双订阅行为也可通过规则或开关进行动态调整，控制消费端的消费的某个服务、应用迁移到应用级地址模型；除此之外，Dubbo3 还内置了自动决策机制，在发现应用级地址可用的情况下即会自动完成切换，并且这个行为是默认的。
以下是消费端双订阅时的选址流程：
升级效果 饿了么成功升级 Dubbo3 及应用级服务发现模型，实现了去 proxy 架构的目标，在我们关心的服务发现数据链路上：</description></item><item><title>0-3 - 无法访问缓存路径</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/3/</guid><description>其它模块复用了 Common 层的基于文件的缓存机制（目前是元数据模块），而 Common 层的文件缓存机制无法访问它指定的目录。
2022-08-29 00:35:00,189 ERROR [org.apache.dubbo.common.cache.FileCacheStoreFactory:?] - [DUBBO] Cache store path can&amp;#39;t be created: , dubbo version: , current host: 10.0.1.1, error code: 0-3. This may be caused by inaccessible of cache path, go to https://dubbo.apache.org/faq/0/3 to find instructions. java.nio.file.FileAlreadyExistsException: [Path] at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:87) at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103) at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108) at java.base/sun.nio.fs.WindowsFileSystemProvider.createDirectory(WindowsFileSystemProvider.java:521) at java.base/java.nio.file.Files.createDirectory(Files.java:700) at java.base/java.nio.file.Files.createAndCheckIsDirectory(Files.java:807) at java.base/java.nio.file.Files.createDirectories(Files.java:753) at org.apache.dubbo.common.cache.FileCacheStoreFactory.getInstance(FileCacheStoreFactory.java:90) ... 可能的原因 多个 Dubbo 进程（或其他 Java 进程）使用了同一个缓存文件。 由于缓存文件所在目录的文件系统权限问题，导致读写失败。 排查和解决步骤 根据下面显示的实际异常找到访问不了的目录，确定下它的文件访问权限。 确定下是否有别的 Dubbo 实例正在访问这个路径。 尝试配置 Java System Property（用 -D 配置的 Java 系统属性） dubbo.</description></item><item><title>1-3 - URL 销毁失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/3/</guid><description>可能的原因 当FrameworkExecutorRepository被销毁以后，调用CacheableFailbackRegistry.evictURLCache会导致销毁失败，产生错误码。
排查和解决步骤 另请参阅 配置项参考手册</description></item><item><title>2-3 - 路由关闭失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/3/</guid><description>可能的原因 用户自定义路由未按规范编写。 排查和解决步骤 参照社区SPI扩展使用手册，检查用户自定义路由 《SPI 扩展使用手册》。</description></item><item><title>3-3 - 通过Javassist生成字节码失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/3/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/3/3/</guid><description>可能的原因 该错误码的意义已经调整。对于 Dubbo 3.1.4、3.2.0-beta.3 及其之前的版本的该错误码的出错，请参考错误码 3-8。
排查和解决步骤 （该错误码目前空缺）</description></item><item><title>3.1 升级至 3.2</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/upgrades-and-compatibility/version/3.1-to-3.2-compatibility-guide/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/upgrades-and-compatibility/version/3.1-to-3.2-compatibility-guide/</guid><description>对于绝大多数的用户，升级到 Dubbo 3.2.0 是完全平滑的，仅需要修改依赖包版本即可。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.2.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 或者
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.2.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 兼容性 CheckList 1. 序列化检查模式（重要！！！） 在 Dubbo 3.2.0 版本中，Dubbo 将默认开启序列化白名单的强校验，以提升 Dubbo 的安全性，避免远程命令执行的问题。 对于一些使用了泛型等可能存在扫描不全或者是服务规模较大的用户，我们建议您添加 -Ddubbo.application.serialize-check-status=WARN 配置。 观察一段时间后（通过日志、QoS 命令），如果没有触发安全告警，则可以配置强校验模式。
关于自定义白名单的配置，可以参考官网的 文档 / SDK 手册 / Java SDK / 高级特性和用法 / 提升安全性 / 类检查机制 一文进行配置。
Q1：为什么要开启序列化白名单的强校验？ 由于 Java 本身机制的问题，Dubbo 支持的非 IDL 序列化天然允许访问任意类，这将可能导致远程命令执行（RCE）风险。
Q2：升级到 3.2 的最佳实践是什么？ 我们建议所有用户在升级 Dubbo 3.2.0 版本前添加 -Ddubbo.application.serialize-check-status=WARN 配置以保证最佳的兼容性。否则可能导致线上数据异常的情况！
2. 默认序列化切换 Dubbo 3.2.0 版本开始默认序列化方式从 hessian2 切换为 fastjson2，对于升级到 3.</description></item><item><title>4-3 - 接口引用调用失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/3/</guid><description>可能的原因 根据指定的协议参数，未找到暴露的服务接口或方法。
排查和解决步骤 可根据接口 URL 及方法名称，确认服务端是否存在。</description></item><item><title>5-3 - 销毁方法调用时发生意外错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/3/</guid><description>可能的原因 自定义销毁方法，业务处理上存在异常。
排查和解决步骤 检查自定义销毁方法，业务处理逻辑是否存在运行时异常。</description></item><item><title>6-3 - 网络连接关闭失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/3/</guid><description>可能的原因 非优雅关闭服务，此时服务端可能在对外输出流未完成。
排查和解决步骤 一般为提示类警告信息，不影响后续的程序执行。</description></item><item><title>7-3 - 设置超时时间的警告百分比值</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/7/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/7/3/</guid><description>可能的原因 QOS 设置超时时间的警告百分比值, 默认为0.75。修改后，控制台会打印此消息。
排查和解决步骤 请参考 QOS 操作手册性能采样命令。</description></item><item><title>81-3 - 通过url无法下载文件</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/81/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/81/3/</guid><description>可能的原因 url 映射文件不存在。 url 无法连接。 排查和解决步骤 检查 url 映射文件是否存在。 通过浏览器或其他工具，能否正常访问。</description></item><item><title>API 配置</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/configuration/api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/configuration/api/</guid><description>API 属性与配置项一对一，各属性含义，请参见：配置参考手册，比如：ApplicationConfig.setName(&amp;quot;xxx&amp;quot;) 对应 &amp;lt;dubbo:application name=&amp;quot;xxx&amp;quot; /&amp;gt; 1
服务提供者 import org.apache.dubbo.rpc.config.ApplicationConfig; import org.apache.dubbo.rpc.config.RegistryConfig; import org.apache.dubbo.rpc.config.ProviderConfig; import org.apache.dubbo.rpc.config.ServiceConfig; import com.xxx.XxxService; import com.xxx.XxxServiceImpl; // 服务实现 XxxService xxxService = new XxxServiceImpl(); // 当前应用配置 ApplicationConfig application = new ApplicationConfig(); application.setName(&amp;#34;xxx&amp;#34;); // 连接注册中心配置 RegistryConfig registry = new RegistryConfig(); registry.setAddress(&amp;#34;10.20.130.230:9090&amp;#34;); registry.setUsername(&amp;#34;aaa&amp;#34;); registry.setPassword(&amp;#34;bbb&amp;#34;); // 服务提供者协议配置 ProtocolConfig protocol = new ProtocolConfig(); protocol.setName(&amp;#34;dubbo&amp;#34;); protocol.setPort(12345); protocol.setThreads(200); // 注意：ServiceConfig为重对象，内部封装了与注册中心的连接，以及开启服务端口 // 服务提供者暴露服务配置 ServiceConfig&amp;lt;XxxService&amp;gt; service = new ServiceConfig&amp;lt;XxxService&amp;gt;(); // 此实例很重，封装了与注册中心的连接，请自行缓存，否则可能造成内存和连接泄漏 service.setApplication(application); service.setRegistry(registry); // 多个注册中心可以用setRegistries() service.</description></item><item><title>Dubbo协议</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/dubbo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/dubbo/</guid><description>Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。dubbo RPC是dubbo体系中最核心的一种高性能、高吞吐量的远程调用方式，我喜欢称之为多路复用的TCP长连接调用。
主要用于两个dubbo系统之间作远程调用，特别适合高并发、小数据的互联网场景。反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。
长连接：避免了每次调用新建TCP连接，提高了调用的响应速度。 多路复用：单个TCP连接可交替传输多个请求和响应的消息，降低了连接的等待闲置时间，从而减少了同样并发数下的网络连接数，提高了系统吞吐量。 Transporter: mina, netty, grizzy Serialization: dubbo, hessian2, java, json Dispatcher: all, direct, message, execution, connection ThreadPool: fixed, cached 缺省协议，使用基于 netty 3.2.5.Final 和 hessian2 3.2.1-fixed-2(Alibaba embed version) 的 tbremoting 交互。
连接个数：单连接 连接方式：长连接 传输协议：TCP 传输方式：NIO 异步传输 序列化：Hessian 二进制序列化 适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。 适用场景：常规远程服务方法调用 约束
参数及返回值需实现 Serializable 接口 参数及返回值不能自定义实现 List, Map, Number, Date, Calendar 等接口，只能用 JDK 自带的实现，因为 hessian 会做特殊处理，自定义实现类中的属性值都会丢失。 Hessian 序列化，只传成员属性值和值的类型，不传方法或静态变量，兼容情况由吴亚军提供 数据通讯 情况 结果 A-&amp;gt;B 类A多一种 属性（或者说类B少一种 属性） 不抛异常，A多的那 个属性的值，B没有，其他正常 A-&amp;gt;B 枚举A多一种 枚举（或者说B少一种 枚举） A使用多 出来的枚举进行传输 A-&amp;gt;B 枚举A多一种 枚举（或者说B少一种 枚举） A不使用 多出来的枚举进行传输 A-&amp;gt;B A和B的属性 名相同，但类型不相同 抛异常 A-&amp;gt;B serialId 不相同 正常传输 接口增加方法，对客户端无影响，如果该方法不是客户端需要的，客户端不需要重新部署。输入参数和结果集中增加属性，对客户端无影响，如果客户端并不需要新属性，不用重新部署。</description></item><item><title>Fastjson2</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/dubbo/fastjson2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/dubbo/fastjson2/</guid><description>1 介绍 FASTJSON v2是FASTJSON项目的重要升级，目标是为下一个十年提供一个高性能的JSON库。通过同一套API，
支持JSON/JSONB两种协议，JSONPath 是一等公民。 支持全量解析和部分解析。 支持Java服务端、客户端Android、大数据场景。 支持Kotlin https://alibaba.github.io/fastjson2/kotlin_cn 支持JSON Schema https://alibaba.github.io/fastjson2/json_schema_cn 支持Android 8+ 支持Graal Native-Image 支持 JSON Schema https://alibaba.github.io/fastjson2/json_schema_cn 2 使用方式 2.1 添加依赖 &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.fastjson2&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;fastjson2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.23&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 注：Fastjson2 序列化仅 Dubbo &amp;gt; 3.1.0 版本支持。在 Dubbo &amp;gt; 3.2.0 中将替代 Hessian 作为默认序列化方式。
2.2 配置启用 # application.yml (Spring Boot) dubbo: protocol: serialization: fastjson2 或
# dubbo.properties dubbo.protocol.serialization=fastjson2 # or dubbo.consumer.serialization=fastjson2 # or dubbo.reference.com.demo.DemoService.serialization=fastjson2 或
&amp;lt;dubbo:protocol serialization=&amp;#34;fastjson2&amp;#34; /&amp;gt; &amp;lt;!-- or --&amp;gt; &amp;lt;dubbo:consumer serialization=&amp;#34;fastjson2&amp;#34; /&amp;gt; &amp;lt;!</description></item><item><title>使用 Filter 过滤器动态拦截请求（request）或响应（response）</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/filter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/filter/</guid><description>Filter 过滤器动态拦截请求（request）或响应（response）以转换或使用请求或响应中包含的信息。过滤器本身通常不会创建响应，而是提供可以“附加”到任何一次 RPC 请求的通用函数。Dubbo Filter 是可插拔的，我们可以在一次 RPC 请求中插入任意类型的、任意多个 Filter。
Filter 工作原理如下图所示：
可以通过 Filter 实现的一些典型能力如下：
记录请求参数、响应结果等到日志文件 为 RPC 请求添加认证或校验逻辑 在发送或执行请求之前，格式化请求体或 header 参数 压缩响应结果 对请求数据进行埋点，统计调用耗时、成功、失败次数等 监测并发执行的请求数量，实现限流降级能力 使用方式 如上图所示，Dubbo 代理会自动加载 Filter 实现并将它们组装到调用链路。Filter 是一个标准的 SPI 定义，框架按照一定的激活规则自动加载 Filter 实现。
@SPI(scope = ExtensionScope.MODULE) public interface Filter extends BaseFilter {} Filter 的默认激活状态可在定义中通过 @Activate 注解设置，如以下定义表示该 Filter 在提供者端执行 RPC 请求时自动开启（在消费端不开启）。@Activate 支持多种条件控制，包括 classpath 下有某个类的定义时开启，URL 中有哪个参数值时开启等，具体可参见 SPI 扩展 Activate 介绍。
@Activate(group = PROVIDER) public class AccessLogFilter implements Filter {} 关闭自动加载 如想关闭某个 filter 加载，在不修改 Filter 定义的情况下，可通过以下几种配置关闭。</description></item><item><title>使用 Grafana 可视化查看集群 Metrics 指标</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/observability/grafana/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/observability/grafana/</guid><description>指标可视化页面目前推荐的方式是使用 Grafana 来配置 Dubbo 的可观测性监控大盘。
在您开始之前 一个可以访问的 Kubernetes 集群 正确安装并配置 普罗米修斯服务 安装 Grafana 部署 示例应用 并开启指标采集 确认组件正常运行 Kubernetes 确保 Prometheus 正常运行
$ kubectl -n dubbo-system get svc prometheus NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE prometheus ClusterIP 10.0.250.230 &amp;lt;none&amp;gt; 9090/TCP 180s 确保 Grafana 正常运行
$ kubectl -n dubbo-system get svc grafana NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE grafana ClusterIP 10.0.244.130 &amp;lt;none&amp;gt; 3000/TCP 180s 部署示例 kubectl apply -f https://raw.githubusercontent.com/apache/dubbo-samples/master/4-governance/dubbo-samples-metrics-spring-boot/Deployment.yml 等待示例应用正常运行，通过以下命令确认应用状态：
kubectl -n dubbo-demo get deployments 查看 Grafana 可视化面板 示例程序启动后会自动模拟服务调用，只需等待一会能在 Grafana 中可视化的看到 Metrics 指标。</description></item><item><title>HTTP 协议规范</title><link>https://dubbo.apache.org/zh-cn/overview/reference/protocols/http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/protocols/http/</guid><description>注意 从 Dubbo 3.3 版本开始，Rest 协议已移至 Extensions 库，由 Triple 协议来对 Rest 提供更全面的支持，具体参见 Triple Rest用户手册， 如需继续使用原 Rest 协议，可引入对应 dubbo-spi-extensions 库依赖 什么是 Dubbo Http 基于 spring web 和 resteasy 注解编码风格，通过http协议进行服务间调用互通，dubbo protocol扩展实现的协议
为什么选择Dubbo Http dubbo http 可以实现微服务与dubbo之间的互通 多协议发布服务，可以实现服务协议的平滑迁移 http的通用性，解决跨语言互通 最新版本的http 无需添加其他组件，更轻量 resteasy以及spring web的编码风格，上手更快 协议规范 Request 相对于原生的http协议dubbo http 请求增加version和group两个header用于确定服务的唯一, 如果provider一端没有声明group和version,http请求时就不需要传递这连个header,反之必须要传递目标 服务的group和version, 如果使用dubbo http的RestClient这两个header将会默认通过attachment传递 为区别于其他的header，attachment将会增加rest-service-前缀，因此通过其他形式的http client调用 dubbo http服务需要传递 rest-service-version 和 rest-service-group 两个header
POST /test/path HTTP/1.1 Host: localhost:8080 Content-type: application/json Accept: text/html rest-service-version: 1.0.0 rest-service-group: dubbo {&amp;#34;name&amp;#34;:&amp;#34;dubbo&amp;#34;,&amp;#34;age&amp;#34;:10,&amp;#34;address&amp;#34;:&amp;#34;hangzhou&amp;#34;} Response HTTP/1.</description></item><item><title>http 协议</title><link>https://dubbo.apache.org/zh-cn/docs/references/protocols/http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/protocols/http/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
基于 HTTP 表单的远程调用协议，采用 Spring 的 HttpInvoker 实现
提示 2.3.0 以上版本支持 特性 连接个数：多连接 连接方式：短连接 传输协议：HTTP 传输方式：同步传输 序列化：表单序列化 适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。 适用场景：需同时给应用程序和浏览器 JS 使用的服务。 约束 参数及返回值需符合 Bean 规范 配置 配置协议：
&amp;lt;dubbo:protocol name=&amp;#34;http&amp;#34; port=&amp;#34;8080&amp;#34; /&amp;gt; 配置 Jetty Server (默认)：
&amp;lt;dubbo:protocol ... server=&amp;#34;jetty&amp;#34; /&amp;gt; 配置 Servlet Bridge Server (推荐使用)：
&amp;lt;dubbo:protocol ... server=&amp;#34;servlet&amp;#34; /&amp;gt; 配置 DispatcherServlet：
&amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;dubbo&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;org.apache.dubbo.remoting.http.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;dubbo&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; 注意，如果使用 servlet 派发请求：
协议的端口 &amp;lt;dubbo:protocol port=&amp;quot;8080&amp;quot; /&amp;gt; 必须与 servlet 容器的端口相同， 协议的上下文路径 &amp;lt;dubbo:protocol contextpath=&amp;quot;foo&amp;quot; /&amp;gt; 必须与 servlet 应用的上下文路径相同。</description></item><item><title>http 协议</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/http/</guid><description>基于 HTTP 表单的远程调用协议，采用 Spring 的 HttpInvoker 实现
提示 2.3.0 以上版本支持 特性 连接个数：多连接 连接方式：短连接 传输协议：HTTP 传输方式：同步传输 序列化：表单序列化 适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。 适用场景：需同时给应用程序和浏览器 JS 使用的服务。 约束 参数及返回值需符合 Bean 规范 配置 配置协议：
&amp;lt;dubbo:protocol name=&amp;#34;http&amp;#34; port=&amp;#34;8080&amp;#34; /&amp;gt; 配置 Jetty Server (默认)：
&amp;lt;dubbo:protocol ... server=&amp;#34;jetty&amp;#34; /&amp;gt; 配置 Servlet Bridge Server (推荐使用)：
&amp;lt;dubbo:protocol ... server=&amp;#34;servlet&amp;#34; /&amp;gt; 配置 DispatcherServlet：
&amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;dubbo&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;org.apache.dubbo.remoting.http.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;dubbo&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; 注意，如果使用 servlet 派发请求：
协议的端口 &amp;lt;dubbo:protocol port=&amp;quot;8080&amp;quot; /&amp;gt; 必须与 servlet 容器的端口相同， 协议的上下文路径 &amp;lt;dubbo:protocol contextpath=&amp;quot;foo&amp;quot; /&amp;gt; 必须与 servlet 应用的上下文路径相同。</description></item><item><title>Dubbo Maven Plugin 的配置方式</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config/maven-plugin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config/maven-plugin/</guid><description>本文主要讲解 Dubbo Maven Plugin 的配置方式。
当前 Dubbo Maven Plugin 支持以下功能：
Dubbo Maven Plugin For Protobuf：生成 Dubbo 服务接口的 Stub 代码 Dubbo Maven Plugin For Native Image：基于 AOT 机制，生成 Native Image 必要的 Metadata 信息 Dubbo Maven Plugin For Protobuf 如何使用 Dubbo Maven Plugin 生成 Protobuf Stub 代码 1. 编写 .proto 文件 greeter.proto
syntax = &amp;#34;proto3&amp;#34;; option java_multiple_files = true; option java_package = &amp;#34;org.apache.dubbo.demo&amp;#34;; option java_outer_classname = &amp;#34;DemoServiceProto&amp;#34;; option objc_class_prefix = &amp;#34;DEMOSRV&amp;#34;; package demoservice; // The demo service definition.</description></item><item><title>Nacos</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config-center/nacos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config-center/nacos/</guid><description>1 前置条件 了解 Dubbo 基本开发步骤 安装并启动 Nacos 当Dubbo使用3.0.0及以上版本时，需要使用Nacos 2.0.0及以上版本。请参考 nacos 注册中心 了解 nacos 版本适配情况。
2 使用说明 2.1 增加 Maven 依赖 如果项目已经启用 Nacos 作为注册中心，则无需增加任何额外配置。
如果未启用 Nacos 注册中心，则请参考 为注册中心增加 Nacos 依赖。
2.2 启用 Nacos 配置中心 &amp;lt;dubbo:config-center address=&amp;#34;nacos://127.0.0.1:8848&amp;#34;/&amp;gt; 或者
dubbo config-center address: nacos://127.0.0.1:8848 或者
dubbo.config-center.address=nacos://127.0.0.1:8848 或者
ConfigCenterConfig configCenter = new ConfigCenterConfig(); configCenter.setAddress(&amp;#34;nacos://127.0.0.1:8848&amp;#34;); address 格式请参考 Nacos 注册中心 - 启用配置
3 高级配置 如要开启认证鉴权，请参考 Nacos 注册中心 - 启用认证鉴权
3.1 外部化配置 3.1.1 全局外部化配置 1. 应用开启 config-center 配置</description></item><item><title>Pixiu 常见问题</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/overview/faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/overview/faq/</guid><description>常见问题 Q1 Pixiu 目前可以用于生产环境吗？
A: 0.4.0版本之后就可以上生产环境，欢迎已经在使用的企业参与此 issue: who&amp;rsquo;s using Pixiu
常见问题 Q2 Pixiu 目前支持高可用吗？
A: 目前 Pixiu 仅支持单实例部署，可以和 Nginx 组成无状态多实例集群。</description></item><item><title>Redis 注册中心</title><link>https://dubbo.apache.org/zh-cn/docs/references/registry/redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/registry/redis/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
基于 Redis [^1] 实现的注册中心。
提示 从 2.1.0 版本开始支持。
Redis 过期数据通过心跳的方式检测脏数据，服务器时间必须同步，并且对服务器有一定压力，否则过期检测会不准确
使用 Redis 的 Key/Map 结构存储数据结构：
主 Key 为服务名和类型 Map 中的 Key 为 URL 地址 Map 中的 Value 为过期时间，用于判断脏数据，脏数据由监控中心删除 [^3] 使用 Redis 的 Publish/Subscribe 事件通知数据变更：
通过事件的值区分事件类型：register, unregister, subscribe, unsubscribe 普通消费者直接订阅指定服务提供者的 Key，只会收到指定服务的 register, unregister 事件 监控中心通过 psubscribe 功能订阅 /dubbo/*，会收到所有服务的所有变更事件 调用过程：
服务提供方启动时，向 Key:/dubbo/com.foo.BarService/providers 下，添加当前提供者的地址 并向 Channel:/dubbo/com.foo.BarService/providers 发送 register 事件 服务消费方启动时，从 Channel:/dubbo/com.foo.BarService/providers 订阅 register 和 unregister 事件 并向 Key:/dubbo/com.foo.BarService/consumers 下，添加当前消费者的地址 服务消费方收到 register 和 unregister 事件后，从 Key:/dubbo/com.</description></item><item><title>Redis 注册中心</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/registry/redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/registry/redis/</guid><description>基于 Redis [^1] 实现的注册中心。
提示 从 2.1.0 版本开始支持。
Redis 过期数据通过心跳的方式检测脏数据，服务器时间必须同步，并且对服务器有一定压力，否则过期检测会不准确
使用 Redis 的 Key/Map 结构存储数据结构：
主 Key 为服务名和类型 Map 中的 Key 为 URL 地址 Map 中的 Value 为过期时间，用于判断脏数据，脏数据由监控中心删除 [^3] 使用 Redis 的 Publish/Subscribe 事件通知数据变更：
通过事件的值区分事件类型：register, unregister, subscribe, unsubscribe 普通消费者直接订阅指定服务提供者的 Key，只会收到指定服务的 register, unregister 事件 监控中心通过 psubscribe 功能订阅 /dubbo/*，会收到所有服务的所有变更事件 调用过程：
服务提供方启动时，向 Key:/dubbo/com.foo.BarService/providers 下，添加当前提供者的地址 并向 Channel:/dubbo/com.foo.BarService/providers 发送 register 事件 服务消费方启动时，从 Channel:/dubbo/com.foo.BarService/providers 订阅 register 和 unregister 事件 并向 Key:/dubbo/com.foo.BarService/consumers 下，添加当前消费者的地址 服务消费方收到 register 和 unregister 事件后，从 Key:/dubbo/com.</description></item><item><title>Registry</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/extensibility/registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/extensibility/registry/</guid><description>在 服务发现 一章中，我们了解了 Dubbo 内置的几个核心注册中心实现 Nacos、Zookeeper 的使用方式与工作原理。本文讲解如何通过扩展 org.apache.dubbo.registry.client.ServiceDiscovery 和 org.apache.dubbo.registry.nacos.NacosServiceDiscoveryFactory SPI，提供自定义的注册中心实现。
本示例的完整源码请参见 dubbo-registry-etcd。除了本示例之外，Dubbo 核心仓库 apache/dubbo 以及扩展库 apache/dubbo-spi-extensions 中的众多注册中心扩展实现，都可以作为扩展参考实现：
# Dubbo对外支持的常用注册中心实现 nacos=org.apache.dubbo.registry.nacos.NacosServiceDiscoveryFactory zookeeper=org.apache.dubbo.registry.zookeeper.ZookeeperServiceDiscoveryFactory 任务详情 通过扩展 SPI 实现基于的 etcd 注册中心。
实现方式 代码详情 首先，通过继承 AbstractServiceDiscoveryFactory 实现 ServiceDiscoveryFactory 接口
public class EtcdServiceDiscoveryFactory extends AbstractServiceDiscoveryFactory { @Override protected ServiceDiscovery createDiscovery(URL registryURL) { return new EtcdServiceDiscovery(applicationModel, registryURL); } } EtcdServiceDiscovery 的一些关键方法与实现如下：
public class EtcdServiceDiscovery extends AbstractServiceDiscovery { private final Set&amp;lt;String&amp;gt; services = new ConcurrentHashSet&amp;lt;&amp;gt;(); private final Map&amp;lt;String, InstanceChildListener&amp;gt; childListenerMap = new ConcurrentHashMap&amp;lt;&amp;gt;(); EtcdClient etcdClient; public EtcdServiceDiscovery(ApplicationModel applicationModel, URL registryURL) { super(applicationModel, registryURL); EtcdTransporter etcdTransporter = applicationModel.</description></item><item><title>发布 REST 风格的服务</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/rest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/rest/</guid><description>本文要讲的 &amp;ldquo;rest 协议&amp;rdquo; 实际上并不是一个真正的协议实现，而是关于如何使得 triple 协议支持以 rest 风格的 http 请求直接访问。 我们将演示如何使用 rest 请求访问标准 triple 协议的 Dubbo 服务。 注意 从 Dubbo 3.3 版本开始，rest 协议已移至 extensions 库，由 triple 协议来对 Rest 提供更全面的支持，新版本的内置协议实现只剩下 triple 和 dubbo。 因此，当我们提到 rest 时，都是指 triple 协议的 rest 访问支持能力，具体参见 Triple Rest用户手册 在讲解 triple 协议示例 时，我们曾提到 triple 协议支持以 application/json 格式直接访问：
curl \ --header &amp;#34;Content-Type: application/json&amp;#34; \ --data &amp;#39;[&amp;#34;Dubbo&amp;#34;]&amp;#39; \ http://localhost:50052/org.apache.dubbo.samples.api.GreetingsService/sayHi/ 如果你认为以上 http://localhost:50052/org.apache.dubbo.samples.api.GreetingsService/sayHi 格式的 path 请求不够友好，还可以通过注解自定义 http 请求的路径和方法等参数， 目前已支持 内置，Spring Web和JAX-RS 三种注解格式。以下示例的完整代码请参见 dubbo-samples-triple-rest。</description></item><item><title>Sentinel限流降级</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/traffic/sentinel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/traffic/sentinel/</guid><description>Dubbo-go 中提供了内置的限流组件，用户可根据自己的业务场景调整限流值、限流后的行为等，具体可 TpsLimiter 定义与具体实现。用户可通过类似以下方式在服务端设置简单的限流策略：
server.WithTpsLimiter(&amp;#34;method-service&amp;#34;) // 目前支持 method-service、polaris 等几个实现 server.WithTpsLimiterXxx() // 设置限流相关阈值，请根据具体方法填写 //tps.limit.strategy: &amp;#34;slidingWindow&amp;#34; //tps.limit.rejected.handler: &amp;#34;default&amp;#34; //tps.limit.interval: 1000 //tps.limit.rate: 3 Dubbo-go 内置限流策略相对简单，对于一些更复杂的场景，我们建议通过使用 Sentinel 等专业的第三方框架可以实现更丰富、更灵活的限流策略。
可在此查看 本示例完整源码，也可以参考 Dubbo+Sentinel 的 Java 示例 获得更多灵感。
Provider 限流 基于 QpS 限流 基于并发任务数限流(当前在运行任务数) Consumer 限流 熔断策略 基于并发请求数限流(未收到响应的请求数)</description></item><item><title>Skywalking</title><link>https://dubbo.apache.org/zh-cn/overview/reference/integrations/skywalking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/integrations/skywalking/</guid><description>安装 你可以使用 Dubbo 社区提供的示例配置快速安装 Skywalking。
kubectl create -f https://raw.githubusercontent.com/apache/dubbo-kubernetes/master/deploy/kubernetes/skywalking.yaml 本安装仅适用于测试或体验使用，生产级别的安装请参考 Skywalking 官方安装文档。</description></item><item><title>Spring Boot</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config/spring/spring-boot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config/spring/spring-boot/</guid><description>关于 Spring Boot 的注解、基本使用方法等请参考 使用教程 - Spring Boot。以下是 spring boot 支持的配置详情与 starter 列表。
application.yaml 以下是 Dubbo 框架支持的配置组件列表，可以在 Spring Boot 配置文件中指定所需配置。
配置示例 dubbo: application: name: dubbo-springboot-demo-provider logger: slf4j protocol: name: dubbo port: 50052 registry: address: nacos://${nacos.address:127.0.0.1}:8848?username=nacos&amp;amp;password=nacos dubbo dubbo.application - org.apache.dubbo.config.ApplicationConfig dubbo.config-center - org.apache.dubbo.config.ConfigCenterConfig dubbo.consumer - org.apache.dubbo.config.ConsumerConfig dubbo.metadata-report - org.apache.dubbo.config.MetadataReportConfig dubbo.protocol - org.apache.dubbo.config.ProtocolConfig dubbo.provider - org.apache.dubbo.config.ProviderConfig dubbo.registry - org.apache.dubbo.config.RegistryConfig dubbo.metrics - org.apache.dubbo.config.MetricsConfig dubbo.tracing - org.apache.dubbo.config.TracingConfig dubbo.ssl - org.apache.dubbo.config.SslConfig dubbo.monitor - org.apache.dubbo.config.MonitorConfig dubbo.module - org.</description></item><item><title>Streaming 通信模型</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/streaming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/streaming/</guid><description>本文重点讲解 Dubbo Rust Streaming 通信模式，请先查看 Quick Start 了解 Dubbo Rust 基本使用，在此查看本文的完整示例。
1 IDL 中增加 Streaming 模型定义 完整 Greeter 服务定义如下，包含一个 Unary、Client stream、Server stream、Bidirectional stream 模型的 Dubbo 服务。
// ./proto/greeter.proto syntax = &amp;#34;proto3&amp;#34;; option java_multiple_files = true; package org.apache.dubbo.sample.tri; // The request message containing the user&amp;#39;s name. message GreeterRequest { string name = 1; } // The response message containing the greetings message GreeterReply { string message = 1; } service Greeter{ // unary rpc greet(GreeterRequest) returns (GreeterReply); // clientStream rpc greetClientStream(stream GreeterRequest) returns (GreeterReply); // serverStream rpc greetServerStream(GreeterRequest) returns (stream GreeterReply); // bi streaming rpc greetStream(stream GreeterRequest) returns (stream GreeterReply); } 2 使用 Streaming 模型定义编写逻辑 2.</description></item><item><title>通过网关将 http 流量接入 Dubbo 后端服务</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/gateway/triple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/gateway/triple/</guid><description>在 triple协议规范 中我们曾详细介绍了 triple 对于浏览器、网关的友好性设计，其中非常重要的一点是 triple 同时支持跑在 HTTP/1、HTTP/2 上：
在后端服务之间使用高效的 triple 二进制协议。 对于前端接入层，则支持所有标准 HTTP 工具如 cURL 等以标准 application/json 、application/yaml 等格式请求后端服务。 接下来我们就看一下，对于前端 HTTP 流量而言，如何通过一些通用的网关产品快速接入后端的 triple 微服务体系。
注意 使用 triple 协议后，不再需要泛化调用、http -&amp;gt; dubbo 协议转换等步骤，任何主流的网关设备都可以通过 http 流量直接访问后端 triple 协议服务。 具体参见 发布 REST 风格的服务 原生 HTTP 接入 如上图所示，从浏览器、手机或 Web 服务器过来的 HTTP 请求，网关可直接转发给后端 Dubbo 服务，后端服务之间则继续走 triple 二进制协议。由于进出网关的都是标准的 HTTP 流量，网关不需要做任何的私有协议转换工作，不需要任何定制化逻辑，只需专注于流量路由等职责即可。
在真正的生产环境下，唯一需要网关解决的只剩下地址发现问题，即如何动态感知后端 triple 服务的实例变化？ 好消息是，目前几款主流的开源网关产品如 Apache APISIX、Higress 等普遍支持以 Nacos、Zookeeper、Kubernetes 作为 upstream 数据源。
以下我们以 Higress + Nacos + Dubbo 的典型用法为例，详细说明整套机制的工作流程。</description></item><item><title>Zipkin</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/observability/tracing/zipkin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/observability/tracing/zipkin/</guid><description>这个示例演示了 Dubbo 集成 Zipkin 全链路追踪的基础示例，完整代码请参考 dubbo-samples-tracing-zipkin，此示例共包含三部分内容：
dubbo-samples-spring-boot3-tracing-provider dubbo-samples-spring-boot3-tracing-consumer dubbo-samples-spring-boot3-tracing-interface 快速开始 安装 &amp;amp; 启动 Zipkin 参考 Zipkin&amp;rsquo;s quick start 安装 Zipkin。
这里我们使用 Docker 来演示如何快速的启动 Zipkin 服务。
docker run -d -p 9411:9411 --name zipkin openzipkin/zipkin 紧接着，你可以通过如下链接确认 Zipkin 正常工作 [http://localhost:9411](http://localhost:9411)
安装 &amp;amp; 启动 Nacos 跟随 Nacos&amp;rsquo;s quick start 快速安装并启动 Nacos。
启动示例 Provider 在 IDE 中直接运行 org.apache.dubbo.springboot.demo.provider.ProviderApplication。
启动示例 Consumer 在 IDE 中直接运行 org.apache.dubbo.springboot.demo.consumer.ConsumerApplication。
检查监控效果 在浏览器中打开 http://localhost:9411/zipkin/ 查看效果。
如何在SpringBoot项目中使用 Dubbo Tracing 1. 添加 Dubbo Tracing 相关的 Starter 依赖 从下面两个 starter 中选择一个加入到你的项目中，区别在于 Tracer 的选型不一样，一个是 Opentelemetry，一个是 Brave：</description></item><item><title>使用 Zookeeper 作为注册中心实现自动服务发现</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/zookeeper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/zookeeper/</guid><description>本示例演示 Zookeeper 作为注册中心实现自动服务发现，示例基于 Spring Boot 应用展开，可在此查看 完整示例代码
1 基本配置 1.1 增加 Maven 依赖 添加 dubbo、zookeeper 等依赖。dubbo-spring-boot-starter 将自动为应用增加 Zookeeper 相关客户端的依赖，减少用户使用 Zookeeper 成本，如使用中遇到版本兼容问题，用户也可以选择自行添加 Curator、Zookeeper Client 等依赖。
对于 Spring Boot 应用而言，可使用如下依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${dubbo.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 推荐 Zookeeper Server 3.8.0+ 版本 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-zookeeper-curator5-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${dubbo.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 仅当 Zookeeper Server 版本是 3.4.x 及以下时，使用此依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-zookeeper-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${dubbo.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; --&amp;gt; 其中，dubbo-zookeeper-spring-boot-starter 或 dubbo-zookeeper-curator5-spring-boot-starter 负责管理 zookeeper 相关依赖。
注意 如果您不使用 Spring Boot，也可以使用以下方式管理依赖
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description></item><item><title>Zookeeper</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/metadata-center/zookeeper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/metadata-center/zookeeper/</guid><description>1 预备工作 了解 Dubbo 基本开发步骤 安装并启动 Zookeeper 2 使用说明 2.1 增加 Maven 依赖 如果项目已经启用 Zookeeper 作为注册中心，则无需增加任何额外配置。
如果未使用 Zookeeper 注册中心，则请参考 为注册中心增加 Zookeeper 相关依赖。
2.2 启用 Zookeeper 配置中心 &amp;lt;dubbo:metadata-report address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; 或者
dubbo metadata-report address: zookeeper://127.0.0.1:2181 或者
dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 或者
MetadataReportConfig metadataConfig = new MetadataReportConfig(); metadataConfig.setAddress(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;); address 格式请参考 zookeeper 注册中心 - 启用配置
3 高级配置 完整配置参数请参考 metadata-report-config。
4 工作原理 4.1 服务运维元数据 Zookeeper 基于树形结构进行数据存储，它的元数据信息位于以下节点:
Provider: /dubbo/metadata/{interface name}/{version}/{group}/provider/{application name} Consumer: /dubbo/metadata/{interface name}/{version}/{group}/consumer/{application name} 当 version 或者 group 不存在时，version 路径和 group 路径会取消，路径如下:</description></item><item><title>快速部署Dubbo应用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/quick-start/deploy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/quick-start/deploy/</guid><description>在上一篇文章中，我们从头创建了一个 Dubbo 应用并详细介绍了它的代码结构，接下来，我们将学习部署这个 Dubbo 应用。
本文将以 Kubernetes 集群作为基础环境来讲解 Dubbo 应用的部署，部署架构如下图所示。 注意 在实际使用中，部署环境可能变化多样，包括 Kubernetes Service、服务网格(Service Mesh)、虚拟机等多种部署模式，请参考 部署文档 了解更多详细内容。 前置条件 Dubbo 社区提供了工具和解决方案来简化整个 Kubernetes 环境的打包与部署过程，所以开始前我们需要先安装相关工具。
安装 dubboctl（如尚未安装） curl -L https://raw.githubusercontent.com/apache/dubbo-kubernetes/master/release/downloadDubbo.sh | sh - cd dubbo-$version export PATH=$PWD/bin:$PATH 部署应用 初始化微服务集群 dubboctl 安装完成之后，接下来通过以下命令初始化微服务部署环境
dubboctl manifest install --profile=demo 作为演示目的，以上命令会一键安装 Zookeeper、Dubbo Control Plane、Prometheus、Grafana、Zipkin、Ingress 等组件，关于 --profile=demo 更多解释及配置请参见文档说明。
检查环境准备就绪
kubectl get services -n dubbo-system 最后，为目标 kubernetes namespace 开启自动注入模式，以便应用部署后能够自动连接到刚刚安装的 Zookeeper 注册中心等组件。
kubectl label namespace dubbo-demo dubbo-injection=enabled --overwrite 部署 Dubbo 应用 接下来我们为之前创建的应用打包镜像（请确保本地安装有 Docker 环境并且已经启动 Docker 进程），在应用根目录分别运行以下命令：</description></item><item><title>为服务调用指定 timeout 超时时间</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/timeout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/timeout/</guid><description>为 RPC 调用设置超时时间可以提升集群整体稳定性，避免无限等待响应结果导致的资源占用（比如大量长期无响应的请求占用线程池等）。在调用没有响应的情况下，比如 5s 之后，Dubbo 框架就会自动终止调用等待过程（抛出 TimeoutException），释放此次调用占用的资源。
使用方式 有多种方式可以配置 rpc 调用超时时间，从粗粒度的全局默认值，到特定服务、特定方法级别的独立配置：
配置全局默认超时时间为 5s（不配置的情况下，所有服务的默认超时时间是 1s）。
dubbo: provider: timeout: 5000 在消费端，指定 DemoService 服务调用的超时时间为 5s
@DubboReference(timeout=5000) private DemoService demoService; 在提供端，指定 DemoService 服务调用的超时时间为 5s（可作为所有消费端的默认值，如果消费端有指定则优先级更高）
@DubboService(timeout=5000) public class DemoServiceImpl implements DemoService{} 在消费端，指定 DemoService sayHello 方法调用的超时时间为 5s
@DubboReference(methods = {@Method(name = &amp;#34;sayHello&amp;#34;, timeout = 5000)}) private DemoService demoService; 在提供端，指定 DemoService sayHello 方法调用的超时时间为 5s（可作为所有消费端的默认值，如果消费端有指定则优先级更高）
@DubboService(methods = {@Method(name = &amp;#34;sayHello&amp;#34;, timeout = 5000)}) public class DemoServiceImpl implements DemoService{} 以上配置形式的优先级从高到低依次为：方法级别配置 &amp;gt; 服务级别配置 &amp;gt; 全局配置 &amp;gt; 默认值。</description></item><item><title>防痴呆设计</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/principals/dummy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/principals/dummy/</guid><description>最近有点痴呆，因为解决了太多的痴呆问题。服务框架实施面越来越广，已有 50 多个项目在使用，每天都要去帮应用查问题，来来回回，发现大部分都是配置错误，或者重复的文件或类，或者网络不通等，所以准备在新版本中加入防痴呆设计。估且这么叫吧，可能很简单，但对排错速度还是有点帮助，希望能抛砖引玉，也希望大家多给力，想出更多的防范措施共享出来。
检查重复的jar包 最痴呆的问题，就是有多个版本的相同jar包，会出现新版本的 A 类，调用了旧版本的 B 类，而且和JVM加载顺序有关，问题带有偶然性，误导性，遇到这种莫名其妙的问题，最头疼，所以，第一条，先把它防住，在每个 jar 包中挑一个一定会加载的类，加上重复类检查，给个示例：
static { Duplicate.checkDuplicate(Xxx.class); } 检查重复工具类：
public final class Duplicate { private Duplicate() {} public static void checkDuplicate(Class cls) { checkDuplicate(cls.getName().replace(&amp;#39;.&amp;#39;, &amp;#39;/&amp;#39;) + &amp;#34;.class&amp;#34;); } public static void checkDuplicate(String path) { try { // 在ClassPath搜文件 Enumeration urls = Thread.currentThread().getContextClassLoader().getResources(path); Set files = new HashSet(); while (urls.hasMoreElements()) { URL url = urls.nextElement(); if (url != null) { String file = url.getFile(); if (file !</description></item><item><title>通过动态开启访问日志跟踪服务调用情况</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/accesslog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/accesslog/</guid><description>访问日志可以很好的记录某台机器在某段时间内处理的所有服务请求信息，包括请求接收时间、远端 IP、请求参数、响应结果等，运行态动态的开启访问日志对于排查问题非常有帮助。
开始之前 部署 Shop 商城项目 部署并打开 Dubbo Admin 任务详情 商城的所有用户服务都由 User 应用的 UserService 提供，通过这个任务，我们为 User 应用的某一台或几台机器开启访问日志，以便观察用户服务的整体访问情况。
动态开启访问日志 Dubbo 通过 accesslog 标记识别访问日志的开启状态，我们可以指定日志文件的输出位置，也可以单独打开某台机器的访问日志。
操作步骤 打开 Dubbo Admin 控制台 在左侧导航栏选择【服务治理】&amp;gt;【动态配置】 点击 &amp;ldquo;创建&amp;rdquo;，输入应用名 shop-user 并勾选 &amp;ldquo;开启访问日志&amp;rdquo;（此时访问日志将和普通日志打印在一起）。 再次访问登录页面，登录到 User 应用的任意一台机器，可以看到如下格式的访问日志。
[2022-12-30 12:36:31.15900] -&amp;gt; [2022-12-30 12:36:31.16000] 192.168.0.103:60943 -&amp;gt; 192.168.0.103:20884 - org.apache.dubbo.samples.UserService login(java.lang.String,java.lang.String) [&amp;#34;test&amp;#34;,&amp;#34;&amp;#34;], dubbo version: 3.2.0-beta.4-SNAPSHOT, current host: 192.168.0.103 [2022-12-30 12:36:33.95900] -&amp;gt; [2022-12-30 12:36:33.95900] 192.168.0.103:60943 -&amp;gt; 192.168.0.103:20884 - org.apache.dubbo.samples.UserService getInfo(java.lang.String) [&amp;#34;test&amp;#34;], dubbo version: 3.2.0-beta.4-SNAPSHOT, current host: 192.</description></item><item><title>服务测试</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/admin/ops/test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/admin/ops/test/</guid><description>请参考这篇博客</description></item><item><title>Admin 服务测试功能简介</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/control-plane/test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/control-plane/test/</guid><description>服务测试功能通常提供给 Dubbo 服务的开发者使用，用来对自己发布的服务进行自测。通过在 Admin 控制台上模拟真实的消费端进程，对服务提供者发起调用，并验证调用结果是否符合预期。
使用方式 准备用例 启动用例
可以参考 快速开始 启动一个简单的 Dubbo 服务，对于服务测试来说，只需要启动 provider 即可。
查询服务
完成服务端部署后，可以到 Admin 的 服务测试 页面查询对应的服务:
这里的信息和元数据类似，包含方法名，参数类型和返回值信息，点击右边的标签就可以进入服务测试页面
执行服务测试 服务测试页面包含了两个 json 编辑器，参数类型的信息都是以 json 格式保存。
如以下示例所示，在左侧编辑器中填入对应的参数值(本例中数类型是 String )，填写完成后点击 执行 即可对服务端发起调用，调用结果展示在右边的编辑器中。
如果调用失败，会显示详细的失败原因，下面来看一下调用失败的例子：
本例中，先关掉 Dubbo 服务提供者的进程，再执行服务测试，可以看到返回的结果是找不到服务提供者的异常。和普通调用一样，业务和框架的异常都会返回在结果中，方便业务排查。
复合类型参数的填写 考虑 UserService 中的以下方法和类型：
//org.apache.dubbo.demo.api.UserService Result getUser(String name, UserInfoDO userInfoDO); public class UserInfoDO { private int id; private LocationDO locationDO; private DepartmentDO departmentDO; @Override public String toString() { return &amp;#34;UserInfoDO{&amp;#34; + &amp;#34;id=&amp;#34; + id + &amp;#34;, locationDO=&amp;#34; + locationDO.</description></item><item><title>服务查询和详情展示</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/admin/ops/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/admin/ops/search/</guid><description>服务查询是 Dubbo OPS 最基本的功能，目前支持服务，应用和 IP 三个维度的查询，并且服务和应用支持模糊查询和自动提示:
其中详情页展示了服务提供者，消费者等信息，元数据信息需要在 Dubbo 2.7 及之后的版本才会展示:</description></item><item><title>服务导出</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/export-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/export-service/</guid><description>1.简介 本篇文章，我们来研究一下 Dubbo 导出服务的过程。Dubbo 服务导出过程始于 Spring 容器发布刷新事件，Dubbo 在接收到事件后，会立即执行服务导出逻辑。整个逻辑大致可分为三个部分，第一部分是前置工作，主要用于检查参数，组装 URL。第二部分是导出服务，包含导出服务到本地 (JVM)，和导出服务到远程两个过程。第三部分是向注册中心注册服务，用于服务发现。本篇文章将会对这三个部分代码进行详细的分析。
2.源码分析 服务导出的入口方法是 ServiceBean 的 onApplicationEvent。onApplicationEvent 是一个事件响应方法，该方法会在收到 Spring 上下文刷新事件后执行服务导出操作。方法代码如下：
public void onApplicationEvent(ContextRefreshedEvent event) { // 是否有延迟导出 &amp;amp;&amp;amp; 是否已导出 &amp;amp;&amp;amp; 是不是已被取消导出 if (isDelay() &amp;amp;&amp;amp; !isExported() &amp;amp;&amp;amp; !isUnexported()) { // 导出服务 export(); } } 这个方法首先会根据条件决定是否导出服务，比如有些服务设置了延时导出，那么此时就不应该在此处导出。还有一些服务已经被导出了，或者当前服务被取消导出了，此时也不能再次导出相关服务。注意这里的 isDelay 方法，这个方法字面意思是“是否延迟导出服务”，返回 true 表示延迟导出，false 表示不延迟导出。但是该方法真实意思却并非如此，当方法返回 true 时，表示无需延迟导出。返回 false 时，表示需要延迟导出。与字面意思恰恰相反，这个需要大家注意一下。下面我们来看一下这个方法的逻辑。
// -☆- ServiceBean private boolean isDelay() { // 获取 delay Integer delay = getDelay(); ProviderConfig provider = getProvider(); if (delay == null &amp;amp;&amp;amp; provider !</description></item><item><title>服务管理命令</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/introduction/service-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/introduction/service-management/</guid><description>服务管理功能提供了一系列的命令对 Dubbo 服务进行管理。
服务管理 ls 命令 列出消费者和提供者
dubbo&amp;gt;ls As Provider side: +------------------------------------------------------------------------+---------------------+ | Provider Service Name | PUB | +------------------------------------------------------------------------+---------------------+ |DubboInternal - UserRead/org.apache.dubbo.metadata.MetadataService:1.0.0| | +------------------------------------------------------------------------+---------------------+ | com.dubbo.dubbointegration.UserReadService |nacos-A(Y)/nacos-I(Y)| +------------------------------------------------------------------------+---------------------+ As Consumer side: +-----------------------------------------+-----------------+ | Consumer Service Name | NUM | +-----------------------------------------+-----------------+ |com.dubbo.dubbointegration.BackendService|nacos-AF(I-2,A-2)| +-----------------------------------------+-----------------+ 列出 dubbo 的所提供的服务和消费的服务，以及消费的服务地址数。
注意 带有 DubboInternal 前缀的服务是 Dubbo 内置的服务，默认不向注册中心中注册。 服务发布状态中的 nacos-A(Y) 第一部分是对应的注册中心名，第二部分是注册的模式（A 代表应用级地址注册，I 代表接口级地址注册），第三部分代表对应模式是否已经注册 服务订阅状态中的 nacos-AF(I-2,A-2) 第一部分是对应的注册中心名，第二部分是订阅的模式（AF 代表双订阅模式，FA 代表仅应用级订阅，FI 代表仅接口级订阅），第三部分中前半部分代表地址模式来源（A 代表应用级地址，I 代表接口级地址）后半部分代表对应的地址数量 上线 online 命令 Online 上线服务命令</description></item><item><title>部署 Dubbo 应用到虚拟机环境</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/deploy/deploy-on-kubernetes-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/deploy/deploy-on-kubernetes-service/</guid><description>这种模式将 Dubbo Service 与 Kubernetes Service 概念映射起来，不再需要 Nacos 等传统注册中心，而是由 Kubernetes APISERVER 承担注册中心指责。
安装 Control Plane 在这个模式下，我们需要安装 dubbo-control-plane
这里是要用 istio 配合一起工作（提供xds推送能力），还是dubbo-control-plane自己实现xds server？
dubboctl manifests install --profile=control-plane 部署应用 打包镜像 定义 YAML 请查看 dubbo-samples 了解示例
kind: service kind: deployment 优雅上下线 配置 probe 配置 pre-stop
观测服务状态 与 Service Mesh 的区别 特性说明 Pod 的生命周期 与服务调度息息相关，通过对 Kubernetes 官方探针的实现，能够使 Dubbo3 乃至整个应用的生命周期与 Pod 的生命周期，在 Pod 的整个生命周期中，影响到 Pod 的就只有健康检查这一部分, 我们可以通过配置 liveness probe（存活探针）和 readiness probe（可读性探针）来影响容器的生命周期。
通过 Dubbo3 的 SPI 机制，在内部实现多种“探针”，基于 Dubbo3 QOS 运维模块的 HTTP 服务，使容器探针能够获取到应用内对应探针的状态。另外，SPI 的实现机制也利于用户自行拓展内部“探针”，使整个应用的生命周期更有效的进行管控。</description></item><item><title>服务治理</title><link>https://dubbo.apache.org/zh-cn/overview/what/advantages/governance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/advantages/governance/</guid><description>流量管控 在地址发现和负载均衡机制之外，Dubbo 丰富的流量管控规则可以控制服务间的流量走向和 API 调用，基于这些规则可以实现在运行期动态的调整服务行为如超时时间、重试次数、限流参数等，通过控制流量分布可以实现 A/B 测试、金丝雀发布、多版本按比例流量分配、条件匹配路由、黑白名单等，提高系统稳定性。
Dubbo 流量管控能解决哪些问题 场景一：搭建多套独立的逻辑测试环境。
场景二：搭建一套完全隔离的线上灰度环境用来部署新版本服务。
场景三：金丝雀发布
场景四：同区域优先。当应用部署在多个不同机房/区域的时候，优先调用同机房/区域的服务提供者，避免了跨区域带来的网络延时，从而减少了调用的响应时间。
除了以上几个典型场景，我们还可以基于 Dubbo 支持的流量管控规则实现微服务场景中更丰富的流量管控，如：
动态调整超时时间 服务重试 访问日志 同区域优先 灰度环境隔离 参数路由 按权重比例分流 金丝雀发布 服务降级 实例临时拉黑 指定机器导流 可以在 流量管理任务 中了解以上实践场景细节。背后的规则定义与工作原理请参见 Dubbo 流量管控规则设计与定义。。
微服务生态 围绕 Dubbo 我们构建了完善的微服务治理生态，对于绝大多数服务治理需求，通过简单几行配置即可开启。对于官方尚未适配的组件或者用户内部系统，也可以通过 Dubbo 扩展机制轻松适配。
可视化控制台 Dubbo Admin 是 Dubbo 官方提供的可视化 Web 交互控制台，基于 Admin 你可以实时监测集群流量、服务部署状态、排查诊断问题。
安全体系 Dubbo 支持基于 TLS 的 HTTP、HTTP/2、TCP 数据传输通道，并且提供认证、鉴权策略，让开发者实现更细粒度的资源访问控制。
服务网格 基于 Dubbo 开发的服务可以透明的接入 Istio 等服务网格体系，Dubbo 支持基于 Envoy 的流量拦截方式，也支持更加轻量的 Proxyless Mesh 部署模式。</description></item><item><title>负载均衡</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/loadbalance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/loadbalance/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。
具体实现上，Dubbo 提供的是客户端负载均衡，即由 Consumer 通过负载均衡算法得出需要将请求提交到哪个 Provider 实例。
可以自行扩展负载均衡策略，参见：负载均衡扩展
负载均衡策略 目前 Dubbo 内置了如下负载均衡算法，用户可直接配置使用：
算法 特性 备注 RandomLoadBalance 加权随机 默认算法，默认权重相同 RoundRobinLoadBalance 加权轮询 借鉴于 Nginx 的平滑加权轮询算法，默认权重相同， LeastActiveLoadBalance 最少活跃优先 + 加权随机 背后是能者多劳的思想 ShortestResponseLoadBalance 最短响应优先 + 加权随机 更加关注响应速度 ConsistentHashLoadBalance 一致性 Hash 确定的入参，确定的提供者，适用于有状态请求 Random 加权随机，按权重设置随机概率。 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。 缺点：存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。 RoundRobin 加权轮询，按公约后的权重设置轮询比率，循环调用节点 缺点：同样存在慢的提供者累积请求的问题。 加权轮询过程过程中，如果某节点权重过大，会存在某段时间内调用过于集中的问题。
例如 ABC 三节点有如下权重：{A: 3, B: 2, C: 1}
那么按照最原始的轮询算法，调用过程将变成：A A A B B C
对此，Dubbo 借鉴 Nginx 的平滑加权轮询算法，对此做了优化，调用过程可抽象成下表:
轮前加和权重 本轮胜者 合计权重 轮后权重（胜者减去合计权重） 起始轮 \ \ A(0), B(0), C(0) A(3), B(2), C(1) A 6 A(-3), B(2), C(1) A(0), B(4), C(2) B 6 A(0), B(-2), C(2) A(3), B(0), C(3) A 6 A(-3), B(0), C(3) A(0), B(2), C(4) C 6 A(0), B(2), C(-2) A(3), B(4), C(-1) B 6 A(3), B(-2), C(-1) A(6), B(0), C(0) A 6 A(0), B(0), C(0) 我们发现经过合计权重（3+2+1）轮次后，循环又回到了起点，整个过程中节点流量是平滑的，且哪怕在很短的时间周期内，概率都是按期望分布的。</description></item><item><title>负载均衡</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/loadbalance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/loadbalance/</guid><description>背景 在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。
可以自行扩展负载均衡策略，参见：负载均衡扩展
负载均衡策略 Random LoadBalance 随机，按权重设置随机概率。 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。 RoundRobin LoadBalance 轮询，按公约后的权重设置轮询比率。 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。 LeastActive LoadBalance 最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。 ConsistentHash LoadBalance 一致性 Hash，相同参数的请求总是发到同一提供者。 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。 算法参见：http://en.wikipedia.org/wiki/Consistent_hashing 缺省只对第一个参数 Hash，如果要修改，请配置 &amp;lt;dubbo:parameter key=&amp;quot;hash.arguments&amp;quot; value=&amp;quot;0,1&amp;quot; /&amp;gt; 缺省用 160 份虚拟节点，如果要修改，请配置 &amp;lt;dubbo:parameter key=&amp;quot;hash.nodes&amp;quot; value=&amp;quot;320&amp;quot; /&amp;gt; 配置 服务端服务级别 &amp;lt;dubbo:service interface=&amp;#34;...&amp;#34; loadbalance=&amp;#34;roundrobin&amp;#34; /&amp;gt; 客户端服务级别 &amp;lt;dubbo:reference interface=&amp;#34;...&amp;#34; loadbalance=&amp;#34;roundrobin&amp;#34; /&amp;gt; 服务端方法级别 &amp;lt;dubbo:service interface=&amp;#34;...&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;...&amp;#34; loadbalance=&amp;#34;roundrobin&amp;#34;/&amp;gt; &amp;lt;/dubbo:service&amp;gt; 客户端方法级别 &amp;lt;dubbo:reference interface=&amp;#34;...&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;...&amp;#34; loadbalance=&amp;#34;roundrobin&amp;#34;/&amp;gt; &amp;lt;/dubbo:reference&amp;gt;</description></item><item><title>负载均衡</title><link>https://dubbo.apache.org/zh-cn/overview/what/core-features/load-balance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/core-features/load-balance/</guid><description>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 weighted random 基于权重的随机负载均衡策略。
具体实现上，Dubbo 提供的是客户端负载均衡，即由 Consumer 通过负载均衡算法得出需要将请求提交到哪个 Provider 实例。
负载均衡策略 目前 Dubbo 内置了如下负载均衡算法，可通过调整配置项启用。
算法 特性 备注 Weighted Random LoadBalance 加权随机 默认算法，默认权重相同 RoundRobin LoadBalance 加权轮询 借鉴于 Nginx 的平滑加权轮询算法，默认权重相同， LeastActive LoadBalance 最少活跃优先 + 加权随机 背后是能者多劳的思想 Shortest-Response LoadBalance 最短响应优先 + 加权随机 更加关注响应速度 ConsistentHash LoadBalance 一致性哈希 确定的入参，确定的提供者，适用于有状态请求 P2C LoadBalance Power of Two Choice 随机选择两个节点后，继续选择“连接数”较小的那个节点。 Adaptive LoadBalance 自适应负载均衡 在 P2C 算法基础上，选择二者中 load 最小的那个节点 Weighted Random 加权随机，按权重设置随机概率。 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。 缺点：存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。 RoundRobin 加权轮询，按公约后的权重设置轮询比率，循环调用节点 缺点：同样存在慢的提供者累积请求的问题。 加权轮询过程中，如果某节点权重过大，会存在某段时间内调用过于集中的问题。 例如 ABC 三节点有如下权重：{A: 3, B: 2, C: 1} 那么按照最原始的轮询算法，调用过程将变成：A A A B B C</description></item><item><title>回声测试</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/echo-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/echo-service/</guid><description>特性说明 回声测试用于检测服务是否可用，回声测试按照正常请求流程执行，能够测试整个调用是否通畅，可用于监控。执行回声测试，客户端发送一个包含特定值（如字符串）的请求。服务器应使用相同的值进行响应，从而验证请求是否已成功接收和处理。如果响应与请求不匹配，则表示服务运行不正常，应进一步调查。要求 Dubbo 服务器正在运行，并且服务器和客户端之间具有网络连接。在客户端，必须配置 Dubbo 客户端以连接到服务器，客户端将向服务器发送请求，然后服务器应返回与请求相同的响应。
使用场景 测试验证是否可以调用服务以及响应是否正确，对于在尝试在生产环境中使用服务之前验证服务特别有用。 echo 测试是验证 Dubbo 服务基本功能的一种简单有效的方法，在将服务部署到生产环境之前执行此测试非常重要，以确保服务按预期工作。
使用方式 本示例完整源码请参考 dubbo-samples-echo。
所有服务自动实现 EchoService 接口，只需将任意服务引用强制转型为 EchoService，即可使用。
如有以下 Dubbo proxy 实例：
@DubboReference private DemoService demoService; 代码示例 EchoService echoService = (EchoService) demoService; String status = (String) echoService.$echo(&amp;#34;OK&amp;#34;);</description></item><item><title>基本依赖</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/dependencies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/dependencies/</guid><description>必须依赖 JDK 1.6+ 1
缺省依赖 通过 mvn dependency:tree &amp;gt; dep.log 命令分析，Dubbo 缺省依赖以下三方库：
[INFO] +- com.alibaba:dubbo:jar:2.5.9-SNAPSHOT:compile [INFO] | +- org.springframework:spring-context:jar:4.3.10.RELEASE:compile [INFO] | +- org.javassist:javassist:jar:3.21.0-GA:compile [INFO] | \- org.jboss.netty:netty:jar:3.2.5.Final:compile 这里所有依赖都是按照 Dubbo 缺省配置选的，这些缺省值是基于稳定性和性能考虑的。
javassist.jar 2: 如果 &amp;lt;dubbo:provider proxy=&amp;quot;jdk&amp;quot; /&amp;gt; 或 &amp;lt;dubbo:consumer proxy=&amp;quot;jdk&amp;quot; /&amp;gt;，以及 &amp;lt;dubbo:application compiler=&amp;quot;jdk&amp;quot; /&amp;gt;，则不需要。 spring-context.jar 3: 如果用 ServiceConfig 和 ReferenceConfig 的 API 调用，则不需要。 netty.jar 4: 如果 &amp;lt;dubbo:protocol server=&amp;quot;mina&amp;quot;/&amp;gt; 或 &amp;lt;dubbo:protocol server=&amp;quot;grizzly&amp;quot;/&amp;gt;，则换成 mina.jar 或 grizzly.jar。如果 &amp;lt;protocol name=&amp;quot;rmi&amp;quot;/&amp;gt;，则不需要。 可选依赖 以下依赖，在主动配置使用相应实现策略时用到，需自行加入依赖。
netty-all 4.0.35.Final mina: 1.</description></item><item><title>架构</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/preface/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/preface/architecture/</guid><description>
节点角色说明 节点 角色说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 调用关系说明 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。
连通性 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小 监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示 服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销 服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销 注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外 注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者 注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表 注册中心和监控中心都是可选的，服务消费者可以直连服务提供者 健壮性 监控中心宕掉不影响使用，只是丢失部分采样数据 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务 注册中心对等集群，任意一台宕掉后，将自动切换到另一台 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯 服务提供者无状态，任意一台宕掉后，不影响使用 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复 伸缩性 注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心 服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者 升级性 当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。下图是未来可能的一种架构：
节点角色说明 节点 角色说明 Deployer 自动部署服务的本地代理 Repository 仓库用于存储服务应用发布包 Scheduler 调度中心基于访问压力自动增减服务提供者 Admin 统一管理控制台 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心</description></item><item><title>健康检查</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/rpc/healthcheck/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/rpc/healthcheck/</guid><description>背景 Dubbo-go 内置了基于 triple 协议的健康检查服务，帮助用户管理和监测服务健康状态，可在此查看 完整示例源码。
使用方法 框架在通过 instance 启动后会自动向框架中注册健康检查服务 grpc.health.v1.Health，用于记录并对外暴露每个triple服务的健康状态。 健康检查服务可以通过发起 http 请求检查框架中服务的状态，也可以通过客户端调用该健康检查服务，调用的接口为grpc.health.v1.Health，方法为 check。 1、通过客户端调用健康检查服务 启动 dubbo-go-samples/healthcheck/go-server 中的服务，通过下方客户端即可查看 greet.GreetService 的状态。
package main import ( &amp;#34;context&amp;#34; &amp;#34;dubbo.apache.org/dubbo-go/v3/client&amp;#34; _ &amp;#34;dubbo.apache.org/dubbo-go/v3/imports&amp;#34; health &amp;#34;dubbo.apache.org/dubbo-go/v3/protocol/triple/health/triple_health&amp;#34; &amp;#34;github.com/dubbogo/gost/log/logger&amp;#34; ) func main() { cli, err := client.NewClient( client.WithClientURL(&amp;#34;tri://127.0.0.1:20000&amp;#34;), ) if err != nil { panic(err) } svc, err := health.NewHealth(cli) if err != nil { panic(err) } check, err := svc.Check(context.Background(), &amp;amp;health.HealthCheckRequest{Service: &amp;#34;greet.GreetService&amp;#34;}) if err != nil { logger.</description></item><item><title>脚本路由规则</title><link>https://dubbo.apache.org/zh-cn/overview/what/core-features/traffic/script-rule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/core-features/traffic/script-rule/</guid><description>脚本路由为流量管理提供了最大的灵活性，所有流量在执行负载均衡选址之前，都会动态的执行一遍规则脚本，根据脚本执行的结果确定可用的地址子集。
脚本路由只对消费者生效且只支持应用粒度管理，因此， key 必须设置为消费者应用名；脚本语法支持多种，以 Dubbo Java SDK 为例，脚本语法支持 Javascript、Groovy、Kotlin 等，具体可参见每个语言实现的限制。
脚本路由由于可以动态加载远端代码执行，因此存在潜在的安全隐患，在启用脚本路由前，一定要确保脚本规则在安全沙箱内运行。
configVersion: v3.0 key: demo-provider type: javascript enabled: true script: | (function route(invokers,invocation,context) { var result = new java.util.ArrayList(invokers.size()); for (i = 0; i &amp;lt; invokers.size(); i ++) { if (&amp;#34;10.20.3.3&amp;#34;.equals(invokers.get(i).getUrl().getHost())) { result.add(invokers.get(i)); } } return result; } (invokers, invocation, context)); // 表示立即执行方法 ScriptRule 脚本路由规则主体。定义脚本规则生效的目标消费者应用、流量过滤脚本以及一些特定场景下的行为。
Field Type Description Required configVersion string The version of the script rule definition, currently available version is v3.</description></item><item><title>Spring Boot 快速开发 Dubbo 服务</title><link>https://dubbo.apache.org/zh-cn/docs/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/quick-start/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo 还提供了包括XML、API 等多种启动与接入方式，更多开发方式和配置细节可参见配置手册。
下载示例代码 完整示例代码在 dubbo-samples 中
下载源码 git clone -b master https://github.com/apache/dubbo-samples.git 进入示例目录 cd dubbo-samples/dubbo-samples-spring-boot ls # 查看目录结构 快速运行示例 编译 Provider 在 dubbo-samples-spring-boot 目录，进入 dubbo-samples-spring-boot-provider 目录并执行 maven 命令 cd ./dubbo-samples-spring-boot-provider mvn clean package 运行 Provider java -jar ./target/dubbo-samples-spring-boot-provider-1.0-SNAPSHOT.jar 编译 Consumer 进入 dubbo-samples-spring-boot-consumer 目录并执行 maven 命令 cd ../dubbo-samples-spring-boot-consumer mvn clean package 运行 consumer java -jar ./target/dubbo-samples-spring-boot-consumer-1.0-SNAPSHOT.jar 详细解释 定义服务接口 dubbo-samples-spring-boot-interface/DemoService.java
package org.apache.dubbo.samples.basic.api; public interface DemoService { String sayHello(String name); } 提供方实现接口并暴露服务 dubbo-samples-spring-boot-provider/DemoServiceImpl.</description></item><item><title>扩展点加载</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/spi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/spi/</guid><description>扩展点配置 来源： Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。
Dubbo 改进了 JDK 标准的 SPI 的以下问题：
JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。 如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK 标准的 ScriptEngine，通过 getName() 获取脚本类型的名称，但如果 RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby 脚本时，会报不支持 ruby，而不是真正失败的原因。 增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。 约定： 在扩展类的 jar 包内 1，放置扩展点配置文件 META-INF/dubbo/接口全限定名，内容为：配置名=扩展实现类全限定名，多个实现类用换行符分隔。
示例： 以扩展 Dubbo 的协议为例，在协议的实现 jar 包内放置文本文件：META-INF/dubbo/org.apache.dubbo.rpc.Protocol，内容为：
xxx=com.alibaba.xxx.XxxProtocol 实现类内容 2：
package com.alibaba.xxx; import org.apache.dubbo.rpc.Protocol; public class XxxProtocol implements Protocol { // .</description></item><item><title>服务流量管理</title><link>https://dubbo.apache.org/zh-cn/docs/concepts/traffic-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/concepts/traffic-management/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
流量管理 流量管理的本质是将请求根据制定好的路由规则分发到应用服务上，如下图所示：
其中：
路由规则可以有多个，不同的路由规则之间存在优先级。如：Router(1) -&amp;gt; Router(2) -&amp;gt; …… -&amp;gt; Router(n) 一个路由规则可以路由到多个不同的应用服务。如：Router(2) 既可以路由到 Service(1) 也可以路由到 Service(2) 多个不同的路由规则可以路由到同一个应用服务。如：Router(1) 和 Router(2) 都可以路由到 Service(2) 路由规则也可以不路由到任何应用服务。如：Router(m) 没有路由到任何一个 Service 上，所有命中 Router(m) 的请求都会因为没有对应的应用服务处理而导致报错 应用服务可以是单个的实例，也可以是一个应用集群。 Dubbo 流量管理介绍 Dubbo 提供了支持 mesh 方式的流量管理策略，可以很容易实现 A/B测试、金丝雀发布、蓝绿发布 等能力。
Dubbo 将整个流量管理分成 VirtualService 和 DestinationRule 两部分。当 Consumer 接收到一个请求时，会根据 VirtualService 中定义的 DubboRoute 和 DubboRouteDetail 匹配到对应的 DubboDestination 中的 subnet，最后根据 DestinationRule 中配置的 subnet 信息中的 labels 找到对应需要具体路由的 Provider 集群。其中：
VirtualService 主要处理入站流量分流的规则，支持服务级别和方法级别的分流。 DubboRoute 主要解决服务级别的分流问题。同时，还提供的重试机制、超时、故障注入、镜像流量等能力。 DubboRouteDetail 主要解决某个服务中方法级别的分流问题。支持方法名、方法参数、参数个数、参数类型、header 等各种维度的分流能力。同时也支持方法级的重试机制、超时、故障注入、镜像流量等能力。 DubboDestination 用来描述路由流量的目标地址，支持 host、port、subnet 等方式。 DestinationRule 主要处理目标地址规则，可以通过 hosts、subnet 等方式关联到 Provider 集群。同时可以通过 trafficPolicy 来实现负载均衡。 这种设计理念很好的解决流量分流和目标地址之间的耦合问题。不仅将配置规则进行了简化有效避免配置冗余的问题，还支持 VirtualService 和 DestinationRule 的任意组合，可以非常灵活的支持各种业务使用场景。</description></item><item><title>流量管理</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/deploy2/traffic_management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/deploy2/traffic_management/</guid><description>在本节中，我们将延续上一个任务【在 Istio 环境部署 Dubbo-go 应用】。
在之前的任务中，我们在集群中部署了一组 Dubbo-go Server和 Client 端应用，验证了服务发现和调用成功。在本节中，我们将创建新版本的 Server 端应用。通过配置 VirtualService 和 DestinationRule ，实现路由管理，和流量转移能力
1. 准备工作 dubbo-go cli 工具和依赖工具已安装、grpc_cli (如需本地调试)。 docker、helm、kubectl 环境已安装。（arm 机器需支持 docker buildx） 任务【在 Istio 环境部署 Dubbo-go 应用】已完成 2. 开发多版本Dubbo-go 应用。 2.1 使用 dubbogo-cli 创建另一个项目模板 $ dubbogo-cli newApp . 2.2 开发和部署客户端 Dubbo-go 应用 v2： 编写业务逻辑 修改 package/service/service.go 的实现方法，返回版本号为 v2.0.0 func (s *GreeterServerImpl) SayHello(ctx context.Context, in *api.HelloRequest) (*api.User, error) { return &amp;amp;api.User{Name: &amp;#34;Hello &amp;#34; + in.Name, Id: &amp;#34;v2.</description></item><item><title>多实例相关的模型与概念定义</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/model/</guid><description>Dubbo 架构 JVM —— 虚拟机层 目的：Dubbo 框架之间完全隔离（端口不能复用）
Dubbo Framework —— 框架层 目的：将需要全局缓存的进行复用（端口、序列化等）
Application —— 应用层 目的：隔离应用之间的信息，包括注册中心、配置中心、元数据中心
Services —— 模块层 目的：提供热加载能力，可以按 ClassLoader、Spring Context 进行隔离上下文
Dubbo 概念对齐 DubboBoorstrap 需要拆分 export/refer services、ServiceInstance、Metadata/Config 等 Client ConfigManager 需要拆分应用级配置信息、模块级配置信息 ApplicationModel 实际存储应用层信息，持有到 ConfigManager 应用级配置信息的引用 ConsumerModel 实际存储接口信息，由 ModuleModel 持有引用 ProviderModel 实际存储接口信息，由 ModuleModel 持有引用 ExtensionLoader 需要根据不同层级 load 出不同的实例对象 Registry 应用级别共享，需要确保多实例订阅正常（考虑单元化场景） Router / Filter 模块级别共享 Protocol / Remoting 框架级别共享，复用 IO，多应用间贡献 Metadata 应用级别共享，考虑应用级服务发现 QoS 框架级别共享，与 IO 有关 Serialization 框架级别共享，与 IO 有关 ConfigCenter 应用级别贡献 ModuleModel（新） 实际存储模块层信息，持有接口级信息 FrameworkModel（新） 实际存储框架层信息 配置存储梳理 FrameworkModel Qos、Protocol、Remoting、Serialization、ExtensionLoader</description></item><item><title>其他问题？</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/migration/proxyless/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/migration/proxyless/</guid><description>Proxyless 模式是指 Dubbo 直接与 Istiod 通信，通过 xDS 协议实现服务发现和服务治理等能力。 本示例中将通过一个简单的示例来演示如何使用 Proxyless 模式。
示例地址
代码架构 本小节中主要介绍本文所使用的示例的代码架构，通过模仿本示例中的相关配置改造已有的项目代码可以使已有的项目快速跑在 Proxyless Mesh 模式下。
1. 接口定义 为了示例足够简单，这里使用了一个简单的接口定义，仅对参数做拼接进行返回。
public interface GreetingService { String sayHello(String name); } 2. 接口实现 @DubboService(version = &amp;#34;1.0.0&amp;#34;) public class AnnotatedGreetingService implements GreetingService { @Override public String sayHello(String name) { System.out.println(&amp;#34;greeting service received: &amp;#34; + name); return &amp;#34;hello, &amp;#34; + name + &amp;#34;! from host: &amp;#34; + NetUtils.getLocalHost(); } } 3. 客户端订阅方式 由于原生 xDS 协议无法支持获取从接口到应用名的映射，因此需要配置 providedBy 参数来标记此服务来自哪个应用。</description></item><item><title>多实例启动流程与模块依赖关系</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/workflow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/workflow/</guid><description>1、应用启动流程 初始化应用配置，启动内部模块，启动其它模块。 应用启动方式包括：DubboBootstrap.start(), ApplicationModel.getDeployer().start() 2、模块启动流程 上图中从ModuleDeployer.start() 开始，自动初始化应用配置，启动内部模块，然后启动当前模块。 模块启动方式包括：
Spring context 加载dubbo xml配置或者注解 手工启动模块：ModuleModel.getDeployer().start() 3、服务接口API方式启动 ServiceConfig.export() 或者 ReferenceConfig.get() 先自动启动module，然后执行export/refer服务接口</description></item><item><title>请求成功率低</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/troubleshoot/request-failed/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/troubleshoot/request-failed/</guid><description>在生产环境中，请求成功率与延时是最关键的指标，本文将介绍在请求成功率下降时候的排查思路。
一句话总结 全链路指标（消费端、网络、服务端、外部依赖等）分析瓶颈
排查思路 1 消费端是否正常构造请求 1.1 检查类对象是否都是可以序列化的 在使用 Dubbo 进行 RPC 进行远程调用的时候，由于是跨进程的调用，为了防止非预期的数据在网络中请求，Dubbo 遵循 Java 的序列化最佳实践会检查所有数据对象是否实现了 Serializable 接口。
以下是检查到序列化异常时的日志样例：
io.netty.handler.codec.EncoderException: java.lang.IllegalArgumentException: [Serialization Security] Serialized class org.apache.dubbo.samples.api.GreetingsService$Data has not implement Serializable interface. Current mode is strict check, will disallow to deserialize it by default. at io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:125) at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:881) at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:863) at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:968) at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:856) at io.netty.handler.timeout.IdleStateHandler.write(IdleStateHandler.java:304) at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:879) at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:863) at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:968) at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:856) at io.netty.channel.ChannelDuplexHandler.write(ChannelDuplexHandler.java:115) at org.apache.dubbo.remoting.transport.netty4.NettyClientHandler.write(NettyClientHandler.java:88) at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0(AbstractChannelHandlerContext.java:879) at io.</description></item><item><title>请求重试</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/rpc/retry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/rpc/retry/</guid><description>当一次服务调用失败时，我们可以让框架选择自动重试几次，这样能提高用户侧看到的请求成功率。在 failover cluster 模式下 dubbo-go 支持自动重试。
1.介绍 本示例演示如何在 client 端调用失败时配置重试功能，完整示例源码地址
2.如何使用重试功能 在使用 client.NewClient() 创建客户端时，可以使用 client.WithClientRetries() 方法设置重试次数。
cli, err := client.NewClient( client.WithClientURL(&amp;#34;tri://127.0.0.1:20000&amp;#34;), client.WithClientRetries(3), ) 或者，可以使用 client.WithRequestTimeout() 设置服务粒度的超时时间（以下配置对服务 svc 起作用）。
svc, err := greet.NewGreetService(cli, client.WithClientRetries(5)) 也可以在调用发起时，使用 client.WithCallRetries() 指定重试次数
resp, err := svc.Greet(context.Background(), &amp;amp;greet.GreetRequest{Name: &amp;#34;hello world&amp;#34;}, client.WithCallRetries(6)) 从上往下，以上三种方式的优先级逐步提高，client.WithCallRetries() 指定的重试次数优先级最高。
3.示例解读 3.1服务端介绍 服务端proto文件 源文件路径：dubbo-go-sample/retry/proto/greet.proto
syntax = &amp;#34;proto3&amp;#34;; package greet; option go_package = &amp;#34;github.com/apache/dubbo-go-samples/retry/proto;greet&amp;#34;; message GreetRequest { string name = 1; } message GreetResponse { string greeting = 1; } service GreetService { rpc Greet(GreetRequest) returns (GreetResponse) {} rpc GreetTimeout(GreetRequest) returns (GreetResponse) {} } 服务端handler文件 Greet方法直接响应，GreetRetry方法用于模拟重试。</description></item><item><title>链路追踪</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/observability/tracing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/observability/tracing/</guid><description>Dubbo-go 支持基于 OpenTelemetry 标准的全链路追踪埋点，同时支持通过以下 exporter 导出到不同的 tracing 后端系统。
Stdout exporter Jaeger exporter Zipkin exporter OTLP-HTTP exporter OTLP-gRPC exporter 使用方式 请注意，仅支持通过 dubbo.NewInstance 方式创建 dubbo 应用时开启 tracing 功能，也就是我们快速开始中提到的 微服务应用模式，对于 轻量 RPC API 暂时不支持开启 tracing。
示例详解 可在此查看 完整示例源码地址。
使用 dubbo.WithTracing() 开启 tracing，可以通过多个参数控制 tracing 行为：
package main import ( &amp;#34;dubbo.apache.org/dubbo-go/v3&amp;#34; _ &amp;#34;dubbo.apache.org/dubbo-go/v3/imports&amp;#34; &amp;#34;dubbo.apache.org/dubbo-go/v3/otel/trace&amp;#34; ) func main() { instance, err := dubbo.NewInstance( dubbo.WithTracing( // add tracing options here trace.WithEnabled(), // enable tracing feature trace.WithStdoutExporter(), trace.WithW3cPropagator(), trace.</description></item><item><title>日志管理</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/observability/logging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/observability/logging/</guid><description>支持的日志框架 Dubbo 支持以下日志框架，用户可根据业务应用实际使用的日志框架进行配置。
第三方日志框架 优先级 说明 Log4j 最高（默认就用这个） log4j 的直接适配，需要增加 log4j-core、log4j-api 依赖与 log4j.properties SLF4J 次高（当前推荐） 可支持 log4j、log4j2、logback 等实现。如 logback 可添加slf4j-api、logback-classic、logback-core 依赖与 logback.xml Log4j2 次低 log4j2 的直接适配，需要增加 log4j2-core 依赖与 log4j2.xml 配置 Common Logging(jcl就是common logging) 次低（Log4j和SLF4J在项目中均没有就用这个） 较少项目使用 JDK log 最低（最后的选择） 较少项目使用 注意 无论使用哪种日志框架，除了 Dubbo 侧配置外，还需要确保应用中加入正确的日志框架依赖和配置文件。 使用 slf4j 对于 spring boot 用户，通过在 application.yaml 或 application.properties 增加以下配置，开启 slf4j 日志：
dubbo: application: logger: slf4j dubbo.application.logger=slf4j 除此之外，还可以使用使用 JVM 参数进行设置：
java -Ddubbo.application.logger=slf4j 使用 slf4j-log4j2 提供日志输出 增加依赖：
&amp;lt;!-- SLF4J API --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description></item><item><title>多实例让源码开发更复杂，学习如何正确的扩展 SPI 实现</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/develop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/develop/</guid><description>本文对Dubbo 3多实例改造后编码相关变化进行一个简单的总结。
层次模型 从只有ApplicationModel，新增 ScopeModel/FrameworkModel/ModuleModel 表达多实例的层次模型。 每个ScopeModel实例都会创建并绑定属于自己的重要成员：
ExtensionDirector BeanFactory ServiceRepository ScopeModel 作为最基础的模型，可以在SPI/Bean/URL 等持有和传递。
SPI扩展 ExtensionScope SPI 注解添加scope属性，标记其所属的作用域。 ExtensionScope 与层次模型对应关系：
FRAMEWORK APPLICATION MODULE �
ExtensionDirector 新增ExtensionDirector用于实现多层级的spi管理及依赖注入。
ExtensionDirector spi extension 创建流程如下： 每个SPI 只能在匹配的Scope的ExtensionDirector上创建，目的是实现层级之间共享实例和正确注入依赖对象。即APPLICATION scope的SPI必定在ApplicationModel绑定的ExtensionDirector上创建，FRAMEWORK scope的SPI必定在FrameworkModel绑定的ExtensionDirector上创建。 可见性与scope作用范围相关，这里的可见性是是否能直接注入依赖。即FRAMEWORK scope的SPI可以在FRAMEWORK/APPLICATION/MODULE 都可见，而 APPLICATION scope的SPI只能在APPLICATION/MODULE 可见。 不可见的SPI需要通过上下文来获取，如可以通过URL传递ScopeModel，可以解决在FRAMEWORK spi访问 APPLICATION spi。 Scope 作用范围如下图： 上层对象可以注入本层及下层的SPI/Bean对象，下层对象不能注入上层的SPI/Bean对象。 Bean托管 新增ScopeBeanFactory用于内部Bean托管，支持在多个不同模块中共享一个实例对象。 ScopeBeanFactory 也支持scope，注入规则与ExtensionDirector相同。 用法请参考：FrameworkStatusReportService、RemoteMetadataServiceImpl、MetadataReportInstance
ServiceRepository 将原来的ServiceRepository拆分为3个类，分别对应3个层次的模型。 FrameworkServiceRepository �ServiceRepository ModuleServiceRepository � 将服务接口信息ProviderModel/ConsumerModel/ServiceDescriptor 注册到ModuleServiceRepository 中，同时在FrameworkServiceRepository 保存一份映射，用于根据请求查找对应的服务接口模型。
编码变化总结 1、如何获取ApplicationModel及应用数据 原方法：ApplicationModel 提供了一系列静态方法用于获取共享应用实例的数据
ApplicationModel.getConfigManager() ApplicationModel.getEnvironment() ApplicationModel.getServiceRepository() ApplicationModel.getExecutorRepository() ApplicationModel.getName() 新办法：先找到ApplicationModel实例，然后通过实例的方法获取数据</description></item><item><title>升级到应用级服务发现</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/upgrades-and-compatibility/migration-service-discovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/upgrades-and-compatibility/migration-service-discovery/</guid><description>请注意 本文档内容并不是升级 Dubbo3 必须的，您完全可以只升级框架并使用 框架的服务发现默认行为。 本文档更适用于 Dubbo2 老用户，用于了解在升级到 Dubbo3 版本后，框架中的服务发现模型切换过程与工作原理。新用户请直接 配置启用应用级服务发现。 对于 Dubbo2 老用户而言，在升级 Dubbo3 时有以下两个选择，而决策的考虑因素仅有一个：性能。
如果您的集群规模不算大，之前使用 Dubbo2 未遇到任何地址推送等性能问题，完全可以继续使用接口级别服务发现 如果您集群规模较大，之前使用 Dubbo2 遇到服务发现负载飙高等问题，则建议迁移到新的应用级服务发现 基于以上决策结论，请在升级 Dubbo3 框架时调整以下配置。
继续使用接口级服务发现 在升级到 Dubbo3 框架时，您需要调整应用配置如下，（仅仅是一个配置项调整，提供者应用必须配置、消费者应用可选）：
&amp;lt;dubbo:application name=&amp;#34;xxx&amp;#34; register-mode=&amp;#34;interface&amp;#34;&amp;gt; 或者
dubbo: application: name: xxx register-mode: interface #表示继续使用老版本服务发现模型，可选值 interface、instance、all 或者，以上是全局默认配置，可以根据每个注册中心来单独配置
&amp;lt;dubbo:registry address=&amp;#34;nacos://localhost:8848&amp;#34; register-mode=&amp;#34;interface&amp;#34;&amp;gt; 或者
dubbo: registry: address: nacos://localhost:8848 register-mode: interface #表示继续使用老版本服务发现模型，可选值 interface、instance、all 启用应用级服务发现(默认) 对于老用户而言，如果要启用应用级服务发现，就需要一个平滑迁移的过程。这时需要让新升级的 Dubbo3 应用进行双注册双订阅（当前框架默认行为，因此用户无需修改任何配置，以下内容均会自行发生，注意：未来版本可能切换为应用级单注册单订阅），以确保新老服务发现模型都能兼顾。
请注意 对于新用户而言，可以直接配置 dubbo.application.register-mode=instance，即在一开始就配置仅使用应用级服务发现。 提供者端注册行为 在默认情况下，Dubbo3 框架会同时注册接口级、应用级两种服务发现地址，因此，集群中的新老应用都能够正常的发现改应用地址，并正常发起调用。如下图所示：
消费者端订阅行为 在默认情况下，Dubbo3 框架具备同时发现 Dubbo2 与 Dubbo3 地址列表的能力。在默认情况下，如果集群中存在可以消费的 Dubbo3 的地址，将自动消费 Dubbo3 的地址，如果不存在新地址则自动消费 Dubbo2 的地址（Dubbo3 提供了开关来控制这个行为），具体如下图所示：</description></item><item><title>使用 dubbogo-cli 工具</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/use_dubbogo_cli/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/use_dubbogo_cli/</guid><description>废弃警告 自 dubbo-go 3.1.0 版本开始，本工具不再适用。本工具已经停止维护，未来将由 dubboctl 代替，请关注社区动态了解 dubboctl 最新进展。 1. 安装 dubbogo-cli 是 Apach/dubbo-go 生态的子项目，为开发者提供便利的应用模板创建、工具安装、接口调试等功能，以提高用户的研发效率。
执行以下指令安装dubbogo-cli 至 $GOPATH/bin
go install github.com/dubbogo/dubbogo-cli@latest 2. 功能概览 dubbogo-cli 支持以下能力
应用模板创建
dubbogo-cli newApp . 在当前目录下创建应用模板
Demo 创建
dubbogo-cli newDemo . 在当前目录下创建 RPC 示例，包含一个客户端和一个服务端
编译、调试工具安装
dubbogo-cli install all 一键安装以下等工具至 $GOPATH/bin
protoc-gen-go-triple
用于 triple 协议接口编译
imports-formatter
用于整理代码 import 块。
import-formatte README
查看 dubbo-go 应用注册信息
查看 Zookeeper 上面的注册信息, 获取接口及方法列表
$ dubbogo-cli show --r zookeeper --h 127.0.0.1:2181 interface: com.</description></item><item><title>使用Unix套接字连接器通信</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/unix-transport/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/unix-transport/</guid><description>本文重点讲解 Dubbo Rust Triple 协议使用Unix 套接，请先查看 Quick Start 了解 Dubbo Rust 基本使用，在此查看本文的完整示例。
1 使用 Unix 套接字连接器 说明 #[cfg(any(target_os = &amp;ldquo;macos&amp;rdquo;, target_os=&amp;ldquo;unix&amp;rdquo;))] 当操作系统符合cfg配置时，unix 模块会被编译使用，否则无法使用
2 使用 client/connection 使用 Unix 套接字连接器编写逻辑 2.1 编写 Client 端 // examples/echo/src/echo/client.rs // 使用 ClientBuilder 初始化 Client let builder = ClientBuilder::new().with_connector(&amp;#34;unix&amp;#34;).with_host(&amp;#34;unix://127.0.0.1:8888&amp;#34;); let mut cli = EchoClient::build(builder); 2.2 编写 Server 端 // examples/echo/src/echo/server.rs // 通过 serverbuilder 来初始化 Server let builder = ServerBuilder::new() .with_listener(&amp;#34;unix&amp;#34;.to_string()) .with_service_names(vec![&amp;#34;grpc.examples.echo.Echo&amp;#34;.to_string()]) .with_addr(&amp;#34;127.0.0.1:8888&amp;#34;); builder.build().serve().await.unwrap(); 3 运行示例 编译 执行cargo build来编译server和client。</description></item><item><title>使用 Zookeeper 作为注册中心实现自动服务发现</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/service-discovery/zookeeper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/service-discovery/zookeeper/</guid><description>本示例演示 Zookeeper 作为注册中心实现自动服务发现，示例基于 Spring Boot 应用展开，可在此查看 完整示例代码
1 基本配置 1.1 增加 Maven 依赖 添加 dubbo、zookeeper 等依赖。dubbo-spring-boot-starter 将自动为应用增加 Zookeeper 相关客户端的依赖，减少用户使用 Zookeeper 成本，如使用中遇到版本兼容问题，用户也可以选择自行添加 Curator、Zookeeper Client 等依赖。
对于 Spring Boot 应用而言，可使用如下依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0-beta.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 仅当 Zookeeper Server 版本是 3.4.x 及以下时，使用此依赖 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-zookeeper-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0-beta.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 仅当 Zookeeper Server 版本是 3.5.x 及以上时，使用此依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-zookeeper-curator5-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0-beta.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; --&amp;gt; 其中，dubbo-zookeeper-spring-boot-starter 或 dubbo-zookeeper-curator5-spring-boot-starter 负责管理 zookeeper 相关依赖。
注意 如果您不使用 Spring Boot，也可以使用以下方式管理依赖
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description></item><item><title>示例消费者安装</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/admin/install/consumer-demo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/admin/install/consumer-demo/</guid><description>安装:
git clone https://github.com/apache/dubbo.git cd dubbo/dubbo-demo/dubbo-demo-xml 运行 dubbo-demo-xml-consumer 中的 org.apache.dubbo.demo.consumer.Application 请确保先启动 Provider，如果使用 Intellij Idea 请加上 -Djava.net.preferIPv4Stack=true 配置:
resources/spring/dubbo-consumer.xml 修改其中的dubbo:registry，替换成Provider提供的注册中心地址, 如： &amp;lt;dubbo:registry address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt;</description></item><item><title>提供者配置</title><link>https://dubbo.apache.org/zh-cn/docs/languages/erlang/service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/erlang/service/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
基本配置 提供者配置项需要添加到 sys.config 文件 dubboerl 应用配置项里。
{dubboerl,[ %% other config ... {provider,[ {module_implements,interface_module,interface_fullname,[Options]}, %% eg: {userOperator_impl,userOperator,&amp;lt;&amp;lt;&amp;#34;org.apache.dubbo.erlang.sample.service.facade.UserOperator&amp;#34;&amp;gt;&amp;gt;,[Option]} ]} ]} ConfigName Type DefaultValue Remarks module_implements atom() - The service implements module name interface_module atom() - Interface module name is transfer form java jar interface_fullname binary() - Interface full name is the java class name Option is to be added.</description></item><item><title>提供者配置</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/languages/erlang/service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/languages/erlang/service/</guid><description>基本配置 提供者配置项需要添加到 sys.config 文件 dubboerl 应用配置项里。
{dubboerl,[ %% other config ... {provider,[ {module_implements,interface_module,interface_fullname,[Options]}, %% eg: {userOperator_impl,userOperator,&amp;lt;&amp;lt;&amp;#34;org.apache.dubbo.erlang.sample.service.facade.UserOperator&amp;#34;&amp;gt;&amp;gt;,[Option]} ]} ]} ConfigName Type DefaultValue Remarks module_implements atom() - The service implements module name interface_module atom() - Interface module name is transfer form java jar interface_fullname binary() - Interface full name is the java class name Option is to be added.</description></item><item><title>提供者配置</title><link>https://dubbo.apache.org/zh-cn/overview/reference/erlang-sdk/service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/erlang-sdk/service/</guid><description>基本配置 提供者配置项需要添加到 sys.config 文件 dubboerl 应用配置项里。
{dubboerl,[ %% other config ... {provider,[ {module_implements,interface_module,interface_fullname,[Options]}, %% eg: {userOperator_impl,userOperator,&amp;lt;&amp;lt;&amp;#34;org.apache.dubbo.erlang.sample.service.facade.UserOperator&amp;#34;&amp;gt;&amp;gt;,[Option]} ]} ]} ConfigName Type DefaultValue Remarks module_implements atom() - The service implements module name interface_module atom() - Interface module name is transfer form java jar interface_fullname binary() - Interface full name is the java class name Option is to be added.</description></item><item><title>通信协议</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/rpc/protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/rpc/protocol/</guid><description>Dubbo-go 框架内置提供了两款协议：triple、dubbo，除此之外，框架还提供了多种协议扩展接入方式。
triple，基于 HTTP/1、HTTP/2 的高性能通信协议，100% 兼容 gRPC，支持 Unary、Streming 等通信模式；支持发布 REST 风格的 HTTP 服务。 dubbo，基于 TCP 的高性能私有通信协议，缺点是通用性较差，更适合在 Dubbo SDK 间使用； 任意协议扩展，通过扩展 protocol 可以之前任意 RPC 协议，官方生态库提供 JsonRPC、thrift 等支持。 本篇文档中，我们将介绍关于 triple 协议的使用方式、如何实现与已有 dubbo2 系统的互相调用、扩展更多协议支持等。更多原理性介绍请参考 协议规范 或者 dubbo java 中相关描述文档。
triple 协议 triple 协议支持使用 protobuf 和 non-protobuf 两种开发模式，我们 推荐使用 protobuf 模式开发服务。
目前我们大部分示例都是使用这个模式开发，可查看 快速开始 学习完整开发示例，以下是基本步骤：
先使用 protobuf 定义服务 syntax = &amp;#34;proto3&amp;#34;; package greet; option go_package = &amp;#34;github.com/apache/dubbo-go-samples/helloworld/proto;greet&amp;#34;; message GreetRequest { string name = 1; } message GreetResponse { string greeting = 1; } service GreetService { rpc Greet(GreetRequest) returns (GreetResponse) {} } 安装 protoc 插件，编译生成代码： protoc --go_out=.</description></item><item><title>网站向导</title><link>https://dubbo.apache.org/zh-cn/contact/committer/website-guide_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/contact/committer/website-guide_dev/</guid><description> Apache Dubbo 的网站仓库是 https://github.com/apache/dubbo-website 网站构建完毕后，它会被自动发布到 dubbo.apache.org，您也可以通过 https://selfserve.apache.org 手动触发（需要使用 Apache 账号登陆）</description></item><item><title>给问题打标签</title><link>https://dubbo.apache.org/zh-cn/contact/committer/label-an-issue-guide_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/contact/committer/label-an-issue-guide_dev/</guid><description>如果您正在处理一个问题，请记得给这个问题标记一个或者多个您认为有意义的标签。有了标签，其他开发人员就会很轻松地识别出问题，以便对其进行分类并跟踪进度。
对于需要编码和发版修复的 issues 和 pull requests，需要您将其标记为 milestone。
一些常用的标签：
请求帮助 help wanted good first issue 优先级 priority/blocker priority/high priority/low priority/normal 状态 status/need-triage status/DO-NOT-MERGE status/READY-TO-MERGE status/invalid status/wontfix 类型 type/bug type/documentation type/enhancement type/feature</description></item><item><title>新特性</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/sourcecode/3.0_feature/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/sourcecode/3.0_feature/</guid><description>1. Triple 协议 1.1 概述 通信层面
Triple 协议，也称为Dubbo3协议，是基于HTTP2 + gRPC协议，增加特定字段和逻辑的扩展协议，保证了和原生gRPC协议互通。在此基础之上，Triple 新协议将更原生地支持 Dubbo 服务治理能力。并支持流式RPC调用。
简单来说，可以理解为 Triple = gRPC + Dubbo
序列化
Triple 协议使用高效的PB序列化方式，并在此基础之上增加序列化协议的可扩展支持。
用户开发习惯：
Triple 服务在开发前需要预定义.proto文件，对于习惯在编码前先定义IDL的Go语言开发者带来便捷。不同于符合java编程习惯的，定义JavaClassName用于描述接口的 Dubbo-go 1.x版本。
跨语言互通性：
可与 Dubbo-Java 实现跨语言互通。
2. 应用级服务发现 2.1 简介 在服务注册阶段，服务端实例将应用级别的注册信息，主要包含从应用名到实例IP的映射注册到注册中心。在服务发现阶段，客户端实例，通过注册中心获取到需要请求的服务实例IP。进入服务自省阶段，服务自省过程为通过应用信息获取接口信息的过程。如上图，包含两种模式：
remote模式：通过元数据中心（例如 zk ）获取应用到接口元数据的映射 local模式：直接通过服务端获取应用到接口元数据的映射（通过 Dubbo 协议针对 Metadata Service 发起 RPC 调用） 经过服务自省后，客户端正式向对应实例发起调用。这样做最明显的好处是减少了注册中心的数据量，即注册中心只保存了应用级别的数据。
用户在使用 Dubbo-go 3.0的应用级服务发现能力时，可以仿照示例，直接在配置文件中配置服务自省模式和元数据中心信息，引入依赖，开启应用级别服务发现。
2.2 应用级服务发现介绍文章 应用级服务发现解析
3. Mesh 路由规则 用户可定义路由文件：
virtual_service.yaml
以及 dist_rule.yml
框架可根据路由文件针对特定的请求进行流量转发。
4. 相关文章 阿里云官方介绍文章：《Dubbo 3.0 - 开启下一代云原生微服务》</description></item><item><title>异步调用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/async/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/async/</guid><description>Dubbo 异步调用分为 Provider 端异步调用和 Consumer 端异步两种模式。
Consumer 端异步是指发起 RPC 调用后立即返回，调用线程继续处理其他业务逻辑，当响应结果返回后通过回调函数通知消费端结果。 Provider 端异步执行将阻塞的业务从 Dubbo 内部线程池切换到业务自定义线程，避免Dubbo线程池的过度占用，有助于避免不同服务间的互相影响。 以下是消费端 consumer 异步调用的工作示例图：
Provider 端异步执行和 Consumer 端异步调用是相互独立的，你可以任意正交组合两端配置。
Consumer同步 - Provider同步 Consumer异步 - Provider同步 Consumer同步 - Provider异步 Consumer异步 - Provider异步 本文档演示的完整示例源码请参见：
Consumer 服务调用异步 Provider 服务执行异步 定义 CompletableFuture 方法签名的服务 Provider异步 1 使用CompletableFuture 接口定义：
public interface AsyncService { /** * 同步调用方法 */ String invoke(String param); /** * 异步调用方法 */ CompletableFuture&amp;lt;String&amp;gt; asyncInvoke(String param); } 服务实现：
@DubboService public class AsyncServiceImpl implements AsyncService { @Override public String invoke(String param) { try { long time = ThreadLocalRandom.</description></item><item><title>异常类型返回值</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/rpc/error/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/rpc/error/</guid><description>1.介绍 本文档演示如何在 RPC 调用过程中处理 error 错误类型响应，可在此查看 完整示例源码地址。
2.示例详解 2.1 服务端 服务端proto文件 源文件路径：dubbo-go-sample/error/proto/greet.proto
syntax = &amp;#34;proto3&amp;#34;; package greet; option go_package = &amp;#34;github.com/apache/dubbo-go-samples/error/proto;greet&amp;#34;; message GreetRequest { string name = 1; } message GreetResponse { string greeting = 1; } service GreetService { rpc Greet(GreetRequest) returns (GreetResponse) {} } 服务端handler文件 请注意，在本程序设计中，Greet方法只有接收到 name=&amp;quot;right name&amp;quot; 时才会认为是正确请求，否则会返回错误。
源文件路径：dubbo-go-sample/context/go-server/main.go
package main import ( &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;github.com/pkg/errors&amp;#34; _ &amp;#34;dubbo.apache.org/dubbo-go/v3/imports&amp;#34; &amp;#34;dubbo.apache.org/dubbo-go/v3/protocol&amp;#34; &amp;#34;dubbo.apache.org/dubbo-go/v3/server&amp;#34; greet &amp;#34;github.com/apache/dubbo-go-samples/helloworld/proto&amp;#34; &amp;#34;github.com/dubbogo/gost/log/logger&amp;#34; ) type GreetTripleServer struct { } func (srv *GreetTripleServer) Greet(ctx context.</description></item><item><title>引用监听扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/invoker-listener/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/invoker-listener/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 当有服务引用时，触发该事件。
扩展接口 org.apache.dubbo.rpc.InvokerListener
扩展配置 &amp;lt;!-- 引用服务监听 --&amp;gt; &amp;lt;dubbo:reference listener=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 引用服务缺省监听器 --&amp;gt; &amp;lt;dubbo:consumer listener=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.rpc.listener.DeprecatedInvokerListener
扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxInvokerListener.java (实现InvokerListener接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.InvokerListener (纯文本文件，内容为：xxx=com.xxx.XxxInvokerListener) XxxInvokerListener.java：
package com.xxx; import org.apache.dubbo.rpc.InvokerListener; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.RpcException; public class XxxInvokerListener implements InvokerListener { public void referred(Invoker&amp;lt;?&amp;gt; invoker) throws RpcException { // ... } public void destroyed(Invoker&amp;lt;?&amp;gt; invoker) throws RpcException { // ... } } META-INF/dubbo/org.</description></item><item><title>引用监听扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/invoker-listener/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/invoker-listener/</guid><description>扩展说明 当有服务引用时，触发该事件。
扩展接口 org.apache.dubbo.rpc.InvokerListener
扩展配置 &amp;lt;!-- 引用服务监听 --&amp;gt; &amp;lt;dubbo:reference listener=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 引用服务缺省监听器 --&amp;gt; &amp;lt;dubbo:consumer listener=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.rpc.listener.DeprecatedInvokerListener
扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxInvokerListener.java (实现InvokerListener接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.InvokerListener (纯文本文件，内容为：xxx=com.xxx.XxxInvokerListener) XxxInvokerListener.java：
package com.xxx; import org.apache.dubbo.rpc.InvokerListener; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.RpcException; public class XxxInvokerListener implements InvokerListener { public void referred(Invoker&amp;lt;?&amp;gt; invoker) throws RpcException { // ... } public void destroyed(Invoker&amp;lt;?&amp;gt; invoker) throws RpcException { // ... } } META-INF/dubbo/org.</description></item><item><title>引用监听扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/invoker-listener/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/invoker-listener/</guid><description>扩展说明 当有服务引用时，触发该事件。
扩展接口 org.apache.dubbo.rpc.InvokerListener
扩展配置 &amp;lt;!-- 引用服务监听 --&amp;gt; &amp;lt;dubbo:reference listener=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 引用服务缺省监听器 --&amp;gt; &amp;lt;dubbo:consumer listener=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.rpc.listener.DeprecatedInvokerListener
扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxInvokerListener.java (实现InvokerListener接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.InvokerListener (纯文本文件，内容为：xxx=com.xxx.XxxInvokerListener) XxxInvokerListener.java：
package com.xxx; import org.apache.dubbo.rpc.InvokerListener; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.RpcException; public class XxxInvokerListener implements InvokerListener { public void referred(Invoker&amp;lt;?&amp;gt; invoker) throws RpcException { // ... } public void destroyed(Invoker&amp;lt;?&amp;gt; invoker) throws RpcException { // ... } } META-INF/dubbo/org.</description></item><item><title>邮件列表订阅向导</title><link>https://dubbo.apache.org/zh-cn/contact/contributor/mailing-list-subscription-guide_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/contact/contributor/mailing-list-subscription-guide_dev/</guid><description>Apache incubator 的 Dubbo 开发者邮件列表（dev@dubbo.apache.org）已经建立，请随时订阅并参考[^1]获取更多细节。
你也可以直接查看历史邮件
下面是一个关于 Dubbo 邮件列表订阅的简短指南：
发一封邮件到 dev-subscribe@dubbo.apache.org，其内容和标题均可为空。随后，您会收到一封邮件，其内容如下： from: dev-help@dubbo.apache.org reply-to: dev-sc.xxxxxxx.xxxxxxxx-hello=example.com@dubbo.apache.org to: hello@example.com date: Sat, Feb 24, 2018 at 3:12 PM subject: confirm subscribe to dev@dubbo.apache.org mailed-by: apache.org Hi! This is the ezmlm program. I&amp;#39;m managing the dev@dubbo.apache.org mailing list. I&amp;#39;m working for my owner, who can be reached at dev-owner@dubbo.apache.org. To confirm that you would like hello@example.com added to the dev mailing list, please send a short reply to this address: dev-sc.</description></item><item><title>远程配置文件</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/configuration/remote/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/configuration/remote/</guid><description>Dubbo 框架支持将配置文件 &amp;lsquo;dubbogo.yaml&amp;rsquo; 的内容预先放入配置中心，再通过远程加载的方式与本地配置合并，以此实现一些配置的动态和集中式管理。
注意 凡是正确配置了config-center 地址的应用，都会优先从配置中心加载整个配置文件。 可在此查看 完整示例源码地址，本文使用 zookeeper 演示，nacos 使用方法类似，并且在以上地址中有具体源码示例。
启用配置中心 在 dubbo-go 应用通过 dubbo.WithConfigCenter() 启用配置中心：
ins, err := dubbo.NewInstance( dubbo.WithConfigCenter( config_center.WithZookeeper(), config_center.WithDataID(&amp;#34;dubbo-go-samples-configcenter-zookeeper-server&amp;#34;), config_center.WithAddress(&amp;#34;127.0.0.1:2181&amp;#34;), config_center.WithGroup(&amp;#34;dubbogo&amp;#34;), ), ) if err != nil { panic(err) } 在运行应用之前，提前将以下配置写入 zookeeper 集群，写入路径为 /dubbo/config/dubbogo/dubbo-go-samples-configcenter-zookeeper-server：
dubbo: registries: demoZK: protocol: zookeeper timeout: 3s address: &amp;#39;127.0.0.1:2181&amp;#39; protocols: triple: name: tri port: 20000 启动服务端并注册服务 srv, err := ins.NewServer() if err != nil { panic(err) } if err := greet.</description></item><item><title>注册中心安全</title><link>https://dubbo.apache.org/zh-cn/overview/notices/registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/notices/registry/</guid><description>Dubbo 支持注册中心的扩展，理论上用户可以基于该扩展机制启用任意的注册中心，这带来了极大的灵活的，但同时也要意识到其中潜藏的安全性风险。
Dubbo 2.7 官方版本提供的注册中心有如下几种：
Zookeeper Redis Nacos Etcd Consul …… 从 Dubbo 3.0 开始默认仅提供以下注册中心支持：
Zookeeper Nacos 对于注册中心，Dubbo 只能完全信任其推送的数据，因此如果注册中心存在安全漏洞，可能会导致 Dubbo 服务被恶意注册或者是被恶意推送数据，从而导致服务被攻击。 因此为了保证注册中心的安全性，Dubbo 官方建议您：
开启注册中心的鉴权机制，如 Zookeeper 的 ACL 机制、Nacos 的用户名密码机制等 避免将注册中心暴露在公网环境下，尽量将注册中心部署在可信内网环境下</description></item><item><title>自适应限流</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/rate-limit/adaptive-concurrency-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/rate-limit/adaptive-concurrency-control/</guid><description>自适应限流的设计与实现思路请参考 Dubbo 自适应限流功能。自适应限流能够确保分布式系统稳定性和可靠性，例如在服务提供商资源有限且多变的场景下。
使用场景 服务降级预防：当服务提供者因资源耗尽而性能下降时，使用自适应限流暂时减少其接受的请求数直至恢复正常。 峰值流量处理：当服务流量突然激增时，自适应流量限制可以通过动态减少接受的请求数量来帮助防止服务过载。 不可预测流量处理：服务提供商可能会遇到不可预测的流量，第三方应用程序使用服务时可能会偶尔产生流量，自适应流量限制可以根据当前系统负载调整允许的最大并发请求数并防止过载。 使用方式 设置方法与静态的最大并发值设置类似，只需在服务端设置 flowcontrol 参数即可，可选值有以下两种：
heuristicSmoothingFlowControl。当服务端收到一个请求时，首先判断CPU的使用率是否超过50%。如果没有超过50%，则接受这个请求进行处理。如果超过50%，说明当前的负载较高，便从 HeuristicSmoothingFlowControl 算法中获得当前的 maxConcurrency 值。如果当前正在处理的请求数量超过了 maxConcurrency，则拒绝该请求。 autoConcurrencyLimiter。与 HeuristicSmoothingFlowControl 的最大区别是，AutoConcurrencyLimiter 是基于窗口的，每当窗口内积累了一定量的采样数据时，才利用窗口内的数据来更新得到 maxConcurrency，其次，利用exploreRatio来对剩余的容量进行探索。 在确保服务端存在多个节点，并且消费端开启重试策略的前提下，限流功能才能更好的发挥作用。
示例一：使用 heuristicSmoothingFlowControl 自适应限流算法 dubbo.provider.flowcontrol=heuristicSmoothingFlowControl &amp;lt;dubbo:provider flowcontrol=&amp;#34;heuristicSmoothingFlowControl&amp;#34; /&amp;gt; 示例二：使用 autoConcurrencyLimiter 自适应限流算法 dubbo.provider.flowcontrol=autoConcurrencyLimiter &amp;lt;dubbo:provider flowcontrol=&amp;#34;autoConcurrencyLimiter&amp;#34; /&amp;gt; 示例三：设置服务粒度的 heuristicSmoothingFlowControl 自适应限流 &amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; flowcontrol=&amp;#34;heuristicSmoothingFlowControl&amp;#34; /&amp;gt;</description></item><item><title>指标埋点</title><link>https://dubbo.apache.org/zh-cn/overview/reference/proposals/metrics/</link><pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/proposals/metrics/</guid><description>概述 1. 指标接入说明 2. 指标体系设计 Dubbo的指标体系，总共涉及三块，指标收集、本地聚合、指标推送
指标收集：将Dubbo内部需要监控的指标推送至统一的Collector中进行存储 本地聚合：指标收集获取的均为基础指标，而一些分位数指标则需通过本地聚合计算得出 指标推送：收集和聚合后的指标通过一定的方式推送至第三方服务器，目前只涉及Prometheus 3. 结构设计 移除原来与 Metrics 相关的类 创建新模块 dubbo-metrics/dubbo-metrics-api、dubbo-metrics/dubbo-metrics-prometheus，MetricsConfig 作为该模块的配置类 使用micrometer，在Collector中使用基本类型代表指标，如Long、Double等，并在dubbo-metrics-api中引入micrometer，由micrometer对内部指标进行转换 4. 数据流转 5. 目标 指标接口将提供一个 MetricsService，该 Service 不仅提供柔性服务所的接口级数据，也提供所有指标的查询方式，其中方法级指标的查询的接口可按如下方式声明
public interface MetricsService { /** * Default {@link MetricsService} extension name. */ String DEFAULT_EXTENSION_NAME = &amp;#34;default&amp;#34;; /** * The contract version of {@link MetricsService}, the future update must make sure compatible. */ String VERSION = &amp;#34;1.0.0&amp;#34;; /** * Get metrics by prefixes * * @param categories categories * @return metrics - key=MetricCategory value=MetricsEntityList */ Map&amp;lt;MetricsCategory, List&amp;lt;MetricsEntity&amp;gt;&amp;gt; getMetricsByCategories(List&amp;lt;MetricsCategory&amp;gt; categories); /** * Get metrics by interface and prefixes * * @param serviceUniqueName serviceUniqueName (eg.</description></item><item><title>店小蜜升级 Triple 协议</title><link>https://dubbo.apache.org/zh-cn/blog/2023/01/15/%E5%BA%97%E5%B0%8F%E8%9C%9C%E5%8D%87%E7%BA%A7-triple-%E5%8D%8F%E8%AE%AE/</link><pubDate>Sun, 15 Jan 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/01/15/%E5%BA%97%E5%B0%8F%E8%9C%9C%E5%8D%87%E7%BA%A7-triple-%E5%8D%8F%E8%AE%AE/</guid><description>前言 阿里云-达摩院-云小蜜对话机器人产品基于深度机器学习技术、自然语言理解技术和对话管理技术，为企业提供多引擎、多渠道、多模态的对话机器人服务。17年云小蜜对话机器人在公共云开始公测，同期在混合云场景也不断拓展。为了同时保证公共云、混合云发版效率和稳定性，权衡再三我们采用了1-2个月一个大版本迭代。 经过几年发展，为了更好支撑业务发展，架构升级、重构总是一个绕不过去的坎，为了保证稳定性每次公共云发版研发同学都要做两件事：
1. 梳理各个模块相较线上版本接口依赖变化情况，决定十几个应用的上线顺序、每批次发布比例； 2. 模拟演练上述1产出的发布顺序，保证后端服务平滑升级，客户无感知； 上述 1、2 动作每次都需要 2-3 周左右的时间梳理、集中演练，但是也只能保证开放的PaaS API平滑更新；
控制台服务因为需要前端、API、后端保持版本一致才能做到体验无损（如果每次迭代统一升级API版本开发、协同成本又会非常大），权衡之下之前都是流量低谷期上线，尽量缩短发布时间，避免部分控制台模块偶发报错带来业务问题。针对上面问题，很早之前就考虑过用蓝绿发布、灰度等手段解决，但是无奈之前对话机器人在阿里云内部业务区域，该不再允许普通云产品扩容，没有冗余的机器，流量治理完全没法做。
迁移阿里云云上 带着上面的问题，终于迎来的 2021 年 9 月份，云小蜜将业务迁移至阿里云云上。
Dubbo3 的实践 “当时印象最深的就是这张图，虽然当时不知道中间件团队具体要做什么事情，但是记住了两个关键词：三位一体、红利。没想到在2021年底，真真切切享受到了这个红利。”
云小蜜使用的是集团内部的HSF服务框架，需要迁移至阿里云云上，并且存在阿里云云上与阿里内部业务域的互通、互相治理的诉求。云小蜜的公共服务部署在公有云VPC，部分依赖的数据服务部署在内部，内部与云上服务存在RPC互调的诉求，其实属于混合云的典型场景。 简单整理了下他们的核心诉求，概括起来有以下三点吧：希望尽可能采用开源方案，方便后续业务推广；在网络通信层面需要保障安全性；对于业务升级改造来说需要做到低成本。
在此场景下，经过许多讨论与探索，方案也敲定了下来
全链路升级至开源 Dubbo3.0，云原生网关默认支持Dubbo3.0，实现透明转发，网关转发RT小于1ms 利用 Dubbo3.0 支持HTTP2特性，云原生网关之间采用 mTLS 保障安全 利用云原生网关默认支持多种注册中心的能力，实现跨域服务发现对用户透明，业务侧无需做任何额外改动 业务侧升级SDK到支持 Dubbo3.0，配置发布 Triple 服务即可，无需额外改动 解决了互通、服务注册发现的问题之后，就是开始看如何进行服务治理方案了
阿里云云上流量治理 迁移至阿里云云上之后，流量控制方案有非常多，比如集团内部的全链路方案、集团内单元化方案等等。
设计目标和原则 要引入一套流量隔离方案，上线过程中，新、旧两个版本服务同时存在时，流量能保证在同一个版本的“集群”里流转，这样就能解决重构带来的内部接口不兼容问题。 要解决上线过程中控制台的平滑性问题，避免前端、后端、API更新不一致带来的问题。 无上线需求的应用，可以不参与上线。 资源消耗要尽量少，毕竟做产品最终还是要考虑成本和利润。 方案选型 集团内部的全链路方案：目前不支持阿里云云上 集团内单元化方案：主要解决业务规模、容灾等问题，和我们碰到的问题不一样 搭建独立集群，版本迭代时切集群：成本太大 自建：在同一个集群隔离新、老服务，保证同一个用户的流量只在同版本服务内流转 以RPC为例：
方案一：通过开发保证，当接口不兼容升级时，强制要求升级HSF version，并行提供两个版本的服务； 缺点是一个服务变更，关联使用方都要变更，协同成本特别大，并且为了保持平滑，新老接口要同时提供服务，维护成本也比较高 方案二：给服务（机器）按版本打标，通过RPC框架的路由规则，保证流量优先在同版本内流转 全链路灰度方案 就当1、2、3、4都觉得不完美，一边调研一边准备自建方案5的时候，兜兜绕绕拿到了阿里云 MSE 微服务治理团队《20分钟获得同款企业级全链路灰度能力》，方案中思路和准备自建的思路完全一致，也是利用了RPC框架的路由策略实现的流量治理，并且实现了产品化（微服务引擎-微服务治理中心），同时，聊了两次后得到几个“支持”，以及几个“后续可以支持”后，好像很多事情变得简单了&amp;hellip;
从上图可以看到，各个应用均需要搭建基线(base)环境和灰度(gray)环境，除了流量入口-业务网关以外，下游各个业务模块按需部署灰度（gray）环境，如果某次上线某模块没有变更则无需部署。
各个中间件的治理方案 Mysql、ElasticSearch：持久化或半持久化数据，由业务模块自身保证数据结构兼容升级； Redis：由于对话产品会有多轮问答场景，问答上下文是在Redis里，如果不兼容则上线会导致会话过程中的C端用户受影响，因此目前Redis由业务模块自身保证数据结构兼容升级； 配置中心：基线(base)环境、灰度(gray)环境维护两套全量配置会带来较大工作量，为了避免人工保证数据一致性成本，基线(base)环境监听dataId，灰度(gray)环境监听gray.dataId如果未配置gray.dataId则自动监听dataId；（云小蜜因为在18年做混合云项目为了保证混合云、公共云使用一套业务代码，建立了中间件适配层，本能力是在适配层实现） RPC服务：使用阿里云 one agent 基于Java Agent技术利用Dubbo框架的路由规则实现，无需修改业务代码； 应用只需要加一点配置：</description></item><item><title>瓜子二手车 Dubbo 实践</title><link>https://dubbo.apache.org/zh-cn/blog/2023/01/15/%E7%93%9C%E5%AD%90%E4%BA%8C%E6%89%8B%E8%BD%A6-dubbo-%E5%AE%9E%E8%B7%B5/</link><pubDate>Sun, 15 Jan 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/01/15/%E7%93%9C%E5%AD%90%E4%BA%8C%E6%89%8B%E8%BD%A6-dubbo-%E5%AE%9E%E8%B7%B5/</guid><description>前言 随着瓜子业务的不断发展，系统规模在逐渐扩大，目前在瓜子的私有云上已经运行着数百个dubbo应用，上千个dubbo实例。瓜子各部门业务迅速发展，版本没有来得及统一，各个部门都有自己的用法。随着第二机房的建设，dubbo版本统一的需求变得越发迫切。几个月前，公司发生了一次与dubbo相关的生产事故，成为了公司dubbo版本升级的诱因。
接下来，我会从这次事故开始，讲讲我们这段时间所做的dubbo版本升级的历程以及dubbo后续多机房的方案。
一、Ephermal节点未及时删除导致provider不能恢复注册的问题修复 事故背景 在生产环境，瓜子内部各业务线共用一套zookeeper集群作为dubbo的注册中心。2019年9月份，机房的一台交换机发生故障，导致zookeeper集群出现了几分钟的网络波动。在zookeeper集群恢复后，正常情况下dubbo的provider应该会很快重新注册到zookeeper上，但有一小部分的provider很长一段时间没有重新注册到zookeeper上，直到手动重启应用后才恢复注册。
排查过程 首先，我们统计了出现这种现象的dubbo服务的版本分布情况，发现在大多数的dubbo版本中都存在这种问题，且发生问题的服务比例相对较低，在github中我们也未找到相关问题的issues。因此，推断这是一个尚未修复的且在网络波动情况的场景下偶现的问题。
接着，我们便将出现问题的应用日志、zookeeper日志与dubbo代码逻辑进行相互印证。在应用日志中，应用重连zookeeper成功后provider立刻进行了重新注册，之后便没有任何日志打印。而在zookeeper日志中，注册节点被删除后，并没有重新创建注册节点。对应到dubbo的代码中，只有在FailbackRegistry.register(url)的doRegister(url)执行成功或线程被挂起的情况下，才能与日志中的情况相吻合。
public void register(URL url) { super.register(url); failedRegistered.remove(url); failedUnregistered.remove(url); try { // Sending a registration request to the server side doRegister(url); } catch (Exception e) { Throwable t = e; // If the startup detection is opened, the Exception is thrown directly. boolean check = getUrl().getParameter(Constants.CHECK_KEY, true) &amp;amp;&amp;amp; url.getParameter(Constants.CHECK_KEY, true) &amp;amp;&amp;amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol()); boolean skipFailback = t instanceof SkipFailbackWrapperException; if (check || skipFailback) { if (skipFailback) { t = t.</description></item><item><title>小米与 Dubbo 社区的合作</title><link>https://dubbo.apache.org/zh-cn/blog/2023/01/15/%E5%B0%8F%E7%B1%B3%E4%B8%8E-dubbo-%E7%A4%BE%E5%8C%BA%E7%9A%84%E5%90%88%E4%BD%9C/</link><pubDate>Sun, 15 Jan 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/01/15/%E5%B0%8F%E7%B1%B3%E4%B8%8E-dubbo-%E7%A4%BE%E5%8C%BA%E7%9A%84%E5%90%88%E4%BD%9C/</guid><description>小米一直在积极拥抱开源社区并提交贡献，参与Dubbo3建设发布以来，在内部业务也积极推进升级工作，目前实例数已经升级到了一定的比例 。升级过程总体平稳，稳定性指标正常，性能提升明显，率先升级完成的应用更早拥有了mesh化的条件。从升级后的数据表现来看，Dubbo3改变以往接口粒度的注册发现方式为应用粒度的注册发现方式，这样带来了注册中心存储和运行的更稳定，降低运维成本；使用protobuf协议进行序列化与反序列化，性能和字节大小均提升数量级；完全兼容gprc，给小米这样多言语并存的服务环境带来了极大便利。
Xiaomi is devoted to making continuous contribution to the open source community. Since the introduction of Dubbo3, internal projects are rapidly upgrading to the latest version of Dubbo. Currently, At present the numbers of instances has been upgrade to a certain proportion. Not only performance improvements have been seen, but services are also running smoothly with improvements in availability. Statistics provide proof that Dubbo’s switch from api-level discovery to application-level discovery has improved the availability and reliability of service discovery, which leads to lower operations cost.</description></item><item><title>中伦网络 Dubbo3 升级实践</title><link>https://dubbo.apache.org/zh-cn/blog/2023/01/15/%E4%B8%AD%E4%BC%A6%E7%BD%91%E7%BB%9C-dubbo3-%E5%8D%87%E7%BA%A7%E5%AE%9E%E8%B7%B5/</link><pubDate>Sun, 15 Jan 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/01/15/%E4%B8%AD%E4%BC%A6%E7%BD%91%E7%BB%9C-dubbo3-%E5%8D%87%E7%BA%A7%E5%AE%9E%E8%B7%B5/</guid><description>中伦网络在 2022 年完成了服务框架从 Dubbo2 到 Dubbo3 的全站升级，深度使用了应用级服务发现、Kubernetes 原生服务部署、服务治理等核心能力。来自中仑网络的技术负责人来彬彬对整个 Dubbo3 的选型、升级过程及收益等做了深入总结。
值得一提的是近期 Dubbo3 官网文档 整体有了本质的提升，并且社区承诺短期内文档还会投入大量精力完善文档，这点对于 Dubbo3 的使用和用户信心提升非常重要。
一、公司业务与技术架构简介 苏州中仑网络科技有限公司是一家“专注零售门店增收服务”的公司，一直以“解决中小零售门店经营难的问题”为初心，致力于为零售商户提供门店运营一体化解决方案，帮助零售门店实现增收。中仑网络以零售技术为核心，为零售商户打造出集收银系统、中仑掌柜、微商城、汇邻生活平台、大数据平台、移动支付、智慧农贸、汇邻门店运营服务等为一体的新零售生态体系，实现线上线下全方位融合，为零售商家赋能增收。技术团队在构建之初选取Dubbo 2.5.3+Zookeeper版本构建公司微服务基座支撑公司业务发展，后期同阿里云深度合作整体迁移使用阿里云，使用云原生基础设施ACK（Kubernetes）+MSE（Zookeeper）+Dubbo+PolarDB等构建，实现可动态缩扩容的服务能力。 伴随合作商扩展3000+，市场遍及300+城市，零售商户30万+，服务覆盖餐饮、茶饮、服装、母婴、烘焙、生鲜、商超、美业、美妆、宠物等多个行业。伴随着领域拓宽、商户量快速增长上升，系统数量和部署节点也迎来了暴增，随之在系统可用性上受到较大挑战：微服务治理能力、微服务地址注册发现，Kubernetes平台服务的无损上下线顺滑度上问题与挑战越来越多。架构图见图一。
图一
二、Dubbo3 升级总结 在升级微服务组件技术选型上主要考虑解决以前的痛点：服务治理能力、云原生友好性、服务注册发现，这几个制约业务发展的紧要问题。比较下来Dubbo3架构设计理念与我们较为契合，能较好的满足我们业务发展要求。
1、服务治理能力 Dubbo 3提供丰富的服务治理能力，可实现诸如服务发现、负载均衡、流量调度等服务治理诉求。在使用上我们有两种选择：一、使用Dubbo管理控制台管理配置、二、集成相关API能力到系统。同时Dubbo 扩展性较好，可以在很多功能点（见图二）去定制自己的实现，以改变框架的默认行为来满足自己的业务需求。Dubbo SPI ( Service Provider Interface)将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。基于此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能，如我们在此基础上实现了基于生产和消费者过滤器Filter实现全链路自定义的链路监控;基于路由扩展标签路由方式进行测试环境的隔离方便快速多版本服务测试验证。实操上我们基于生产者注册服务时打标，如原系统A V1版本部署在fat环境上,现在为了测试V2版本，我们将V2版本打标tag=fat-v2;使用端在消费时指定Invocation Attachment 参数,inv.setAttachment(TAG_KEY, routeTag);基于此我们可以方便自测试，同时生产上我们也可以做简单的生产灰度运用。
图二
2、云原生友好性 Dubbo 在设计上遵循云原生微服务开发理念，微服务支持 Kubernetes平台调度，实现服务生命周期与容器生命周期的对齐，包括 Dubbo 的启动、销毁、服务注册等生命周期事件。中仑网络微服务管理使用的是MSE（Zookeeper）,因而我们服务暴露使用需与之对齐。具体操作上我们自定义Startup 启动探针、 Liveness 存活探针、Readiness 就绪探针。项目的正常切换需要保障无损的上下线，在实施中无损上线相对于下线来说会更麻烦点，项目的发布上线过程大体会遵从如下流程：大致分成三个阶段，第一阶段升级少量（如 20% ）的实例，并切换少量流量到新版本，完成这个阶段后先暂停升级。经过人工确认之后继续第二个阶段，升级更大比例（如 90% ）的实例和流量，再次暂停等待人工确认。最后阶段将全量升级到新版本并验证完毕，从而完成整个发布过程。如果升级期间发现包括业务指标在内的任何异常，例如 CPU 或 memory 异常使用率升高或请求 500 日志过多等情况，可以快速回滚。因为我们使用的是MSE（Zookeeper）服务，dubbo服务自注册在应用启动过程暴露不受Kubernetes 生命周期的控制，出现项目未完全就绪部分服务可被提前可被访问问题。
图三
实施处理上我们主要利用Dubbo Qos指令,初始使用服务不暴露，在应用就绪后调用Qos online指令进行服务上线替换老节点，每次替换的节点数量基于发布策略来制定;下线过程针对需下线节点我们会先使用Qos指令进行下线offline操作等待应用执行完服务，从而进行优雅停机，从实践的效果来看能满足我们的生产需求。
3、实例级别升级切换 相比于 2.x 版本中的基于接口粒度的服务发现机制，3.x 引入了全新的基于应用粒度的服务发现机制，进一步提升了 Dubbo3 在大规模集群实践中的性能与稳定性。此次升级过程中我们也同步引入了配置中心与原数据中心，即将图四置灰部分启用</description></item><item><title>0-4 - 缓存条目超限</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/4/</guid><description>其它模块复用了 Common 层的基于文件的缓存机制（目前是元数据模块），而 Common 层的文件缓存机制 “发觉” 条目超限。
可能的原因 用户不合理地配置了 Java System Property （用 -D 配置的 Java 系统属性） dubbo.mapping.cache.entrySize 或者 dubbo.meta.cache.entrySize
默认值
dubbo.mapping.cache.entrySize dubbo.meta.cache.entrySize 10000 100 排查和解决步骤 尝试重新配置上述 Java System Property（用 -D 配置的 Java 系统属性）。 如果确实没有配置这些 System Property，请到 GitHub Issue Tracker 下发 Issue。</description></item><item><title>1-4 - 空地址</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/4/</guid><description>可能的原因 registry.integration.RegistryDirectory 中的1-4错误是refreshInvoker过程中invokerUrls为空导致的，可以忽略。 registry.support.CacheableFailbackRegistry 中的1-4错误可能是consumer和provider不匹配，并且关闭了“空保护”所导致。 排查和解决步骤 确保 Provider 和 Consumer 端的服务分组配置相对应。 确保 Provider 和 Consumer 端的服务版本配置相对应。 检查注册中心的enable-empty-protection是否为true（默认为true）。 另请参阅 配置项参考手册</description></item><item><title>2-4 - Merger接口加载失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/4/</guid><description>可能的原因 Dubbo 提供了聚合下游所有提供方响应的 SPI 扩展 Merger 接口，Dubbo 在加载用户在自定义扩展 Merger 接口时，加载配置失败。 排查和解决步骤 参照社区 SPI 扩展使用手册，检查用户自定义扩展 Merger 接口实现 《SPI 扩展使用手册》。</description></item><item><title>3-4 - 客户端发送请求超时</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/3/4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/3/4/</guid><description>可能的原因 客户端连接数过高，响应较慢, 无法及时向服务端发出请求。 网络的一些原因。 排查和解决步骤 网络是否正常。 可通过一些第三方的工具或者jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>3.2 升级至 3.3</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/upgrades-and-compatibility/version/3.2-to-3.3-compatibility-guide/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/upgrades-and-compatibility/version/3.2-to-3.3-compatibility-guide/</guid><description>对于绝大多数的用户，升级到 Dubbo 3.3.0 是完全平滑的，仅需要修改依赖包版本即可。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 或者
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 兼容性 CheckList 1. 默认序列化切换 Dubbo 3.3.0 版本开始默认序列化方式从 fastjson2 切换为 hessian2，对于升级到 3.3.0 的应用，Dubbo 会自动尝试采用 hessian2 进行序列化。
Q1：为什么要切换默认序列化方式？ hessian2 为 Dubbo 3.1.x 及以下版本中默认的序列化，长期的生产验证了其稳定性和兼容性，在评估了向前兼容性和长期可维护性后，Dubbo 团队决定将 hessian-lite 升级到最新 hessian4 主干版本，以支持 JDK17 和 JDK21。
升级到 Dubbo 3.3.0 以后，依赖的 hessian-lite 版本将同步升级为 4.0.x，主要包含以下修改：
同步 hessian 到上游 4.0.66 版本 修复 JDK17 及 JDK21 下类可见性带来的兼容性问题 支持 Record、ImmutableCollections 等 JDK9+ 特性 Q2：会不会影响和低版本的 Dubbo 互通？ 部分场景下可能会有影响，具体如下：</description></item><item><title>4-4 - 非安全序列化方式</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/4/</guid><description>可能的原因 当前在使用非安全的序列化器, 并不推荐。具体配置为：serialization=&amp;quot;java&amp;quot;
Java 序列化是不安全的。Dubbo 团队不推荐任何人使用它。如果你仍然想使用它，请遵循 JEP 290 来设置序列化过滤器，以防止反序列化泄露。
排查和解决步骤 修改serialization的参数值. 将 protocol 内的序列化参数值修改为其他,如hessian2，fastjson2等。</description></item><item><title>5-4 - 服务接口中找不到方法</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/4/</guid><description>可能的原因 消费端调用的接口名#方法不存在。 服务端未正确的暴露当前接口。 排查和解决步骤 检查消费端调用的接口名#方法是否存在。 检查服务端暴露的服务列表内是否存在。</description></item><item><title>6-4 - 网络通讯层未知异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/4/</guid><description>可能的原因 该错误码的意义已经调整。对于 Dubbo 3.1.4、3.2.0-beta.3 及其之前的版本的该错误码的出错，请参考错误码 99-0。
排查和解决步骤 （该错误码目前空缺）</description></item><item><title>7-4 - QOS 服务启动失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/7/4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/7/4/</guid><description>可能的原因 QOS 参数值未正确设置。主要参数有 qos.host 和 qos.port
排查和解决步骤 请参考QOS 操作手册QOS 概述。</description></item><item><title>81-4 - 嵌入式ZooKeeper运行异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/81/4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/81/4/</guid><description>可能的原因 ZooKeeper 服务运行异常或宕机。 Zookeeper 客户端版本与服务端启动版本不兼容，无法连接。 应用服务器与 ZooKeeper 服务连接中断。 受限防火墙或第三方防护工具。 排查和解决步骤 检查 ZooKeeper 服务及所在服务器健康状态。 检查 Zookeeper 客户端版本与服务端启动版本是否存在兼容问题，保持版本一致。 检查应用服务器与 ZooKeeper 服务端口是否通畅。 检查防火墙或第三方防护工具设置，是否已禁止。</description></item><item><title>API文档&amp;测试</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/admin/ops/apidocs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/admin/ops/apidocs/</guid><description>dubbo api docs dubbo 接口文档、测试工具,根据注解生成文档,并提供测试功能.
增加一些注解就能生成类似swagger的文档, 不会把非web的dubbo项目变为web项目.
相关仓库 dubbo-spi-extensions \分支: 2.7.x\dubbo-api-docs: Dubbo-Api-Docs 相关注解,解析注解 dubbo-admin: Dubbo-Api-Docs 文档展示,测试功能 如何使用? dubbo项目的方法参数中加上 dubbo api docs 注解 dubbo提供者项目引入 dubbo-api-docs-core 如果dubbo的接口和参数是一个单独的jar包项目,引入dubbo-api-docs-annotations 在提供者项目的项目启动类(标注了@SpringBootApplication的类)或者配制类(标注了@Configuration的类)中增加注解 @EnableDubboApiDocs 以启用Dubbo Api Docs功能 为避免增加生产环境中的资源占用, 建议单独创建一个配制类用于启用Dubbo Api Docs, 并配合 @Profile(&amp;ldquo;dev&amp;rdquo;) 注解使用 当然, Dubbo Api Docs 仅在项目启动时多消耗了点CPU资源, 并使用了一点点内存用于缓存, 将来会考虑将缓存中的内容放到元数据中心. 版本 当前版本: 同Dubbo版本号
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-api-docs-annotations&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${dubbo-version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-api-docs-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${dubbo-version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 下载 dubbo-admin 下载地址
启动 dubbo-admin
访问: http:// localhost:8080
进入&amp;quot;接口文档&amp;quot;模块
注解使用 @EnableDubboApiDocs: 配制注解, 启用 dubbo api docs 功能 @ApiModule: 类注解, dubbo接口模块信息,用于标注一个接口类模块的用途 value: 模块名称 apiInterface: 提供者实现的接口 version: 模块版本 @ApiDoc: 方法注解, dubbo 接口信息,用于标注一个接口的用途 value: 接口名称 description: 接口描述(可使用html标签) version: 接口版本 responseClassDescription: 响应的数据的描述 @RequestParam: 类属性/方法参数注解,标注请求参数 value: 参数名 required: 是否必传参数 description: 参数描述 example: 参数示例 defaultValue: 参数默认值 allowableValues: 允许的值,设置该属性后界面上将对参数生成下拉列表 注:使用该属性后将生成下拉选择框 boolean 类型的参数不用设置该属性,将默认生成 true/false 的下拉列表 枚举类型的参数会自动生成下拉列表,如果不想开放全部的枚举值,可以单独设置此属性.</description></item><item><title>Apollo</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config-center/apollo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config-center/apollo/</guid><description>1 前置条件 了解 Dubbo 基本开发步骤 安装并启动 Apollo 2 使用说明 在此查看完整示例代码
2.1 增加 Maven 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.9&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.ctrip.framework.apollo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;apollo-openapi&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.ctrip.framework.apollo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;apollo-client&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2.2 启用 Apollo 配置中心 &amp;lt;dubbo:config-center address=&amp;#34;apollo://localhost:8080&amp;#34;/&amp;gt; 或者
dubbo config-center address: apollo://localhost:8080 或者
dubbo.config-center.address=apollo://localhost:8080 或者
ConfigCenterConfig configCenter = new ConfigCenterConfig(); configCenter.setAddress(&amp;#34;apollo://localhost:8080&amp;#34;); 3 高级配置 Apollo中的一个核心概念是命名空间 - namespace，和上面 Zookeeper、Nacos 的 namespace 概念不同，因此使用方式上也比较特殊些，建议充分了解 Apollo 自身的用法后再阅读以下文档内容。
但总的来说，对 Apollo 的适配而言：
namespace 特用于流量治理规则隔离，参见 3.1 group 特用于外部化配置的隔离，参见 3.2 3.1 外部化配置 &amp;lt;dubbo:config-center group=&amp;#34;demo-provider&amp;#34; address=&amp;#34;apollo://localhost:8080&amp;#34;/&amp;gt; config-center 的 group 决定了 Apollo 读取外部化配置 dubbo.</description></item><item><title>Dubbo Admin 安全</title><link>https://dubbo.apache.org/zh-cn/overview/notices/admin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/notices/admin/</guid><description>为了便于使用 Dubbo，Dubbo 官方提供了 Dubbo Admin 控制台，以便于管理 Dubbo 应用。
风险 Dubbo Admin 默认拥有整个集群的查询、调用权限，因此对于线上环境，需要更加谨慎地使用。 此外，为了减低任意访问 Dubbo Admin 的风险，Dubbo Admin 还提供了简易的鉴权机制。 为了使 Dubbo Admin 更安全，请参考下面的文档。
鉴权方案 Dubbo Admin 默认提供基于用户名密码的登陆机制，在请求过程中基于 JWT Token 进行鉴权。 从便于初学者的角度出发，Dubbo Admin 包含了一个默认的用户名密码、JWT Secret Token。
由于 Dubbo Admin 是公开发行的，因此默认的用户名密码、JWT Secret Token 都是公开的。 在您的生产环境中，请务必更换默认的用户名密码、JWT Secret Token。
如何更换默认的用户名密码、JWT Secret Token 对于直接基于 Java 代码打包部署的用户，可以直接修改 dubbo-admin-server/src/main/resources/application.properties 中以下配置：
admin.root.user.name=root admin.root.user.password=root admin.check.signSecret=86295dd0c4ef69a1036b0b0c15158d77 对于通过 Docker 部署的用户，可以修改 /dubbo/dubbo-admin/properties 中以下配置：
admin.root.user.name=root admin.root.user.password=root admin.check.signSecret=86295dd0c4ef69a1036b0b0c15158d77 对于通过 Kubernetes 部署的用户，可以修改 ConfigMap 中以下配置：
admin.root.user.name=root admin.root.user.password=root admin.</description></item><item><title>Fastjson</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/dubbo/fastjson/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/dubbo/fastjson/</guid><description>1 介绍 Fastjson 是一个 Java 库，可用于将 Java 对象转换为其 JSON 表示形式。它还可用于将 JSON 字符串转换为等效的 Java 对象。 Fastjson 可以处理任意 Java 对象，包括您没有源代码的预先存在的对象。
2 使用方式 2.1 添加依赖 &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-serialization-fastjson&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.83&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 2.2 配置启用 # application.yml (Spring Boot) dubbo: protocol: serialization: fastjson 或
# dubbo.properties dubbo.protocol.serialization=fastjson # or dubbo.consumer.serialization=fastjson # or dubbo.reference.com.demo.DemoService.serialization=fastjson 或
&amp;lt;dubbo:protocol serialization=&amp;#34;fastjson&amp;#34; /&amp;gt; &amp;lt;!-- or --&amp;gt; &amp;lt;dubbo:consumer serialization=&amp;#34;fastjson&amp;#34; /&amp;gt; &amp;lt;!-- or --&amp;gt; &amp;lt;dubbo:reference interface=&amp;#34;xxx&amp;#34; serialization=&amp;#34;fastjson&amp;#34; /&amp;gt; 3 支持的rpc协议</description></item><item><title>hessian 协议</title><link>https://dubbo.apache.org/zh-cn/docs/references/protocols/hessian/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/protocols/hessian/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Hessian 1 协议用于集成 Hessian 的服务，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。
Dubbo 的 Hessian 协议可以和原生 Hessian 服务互操作，即：
提供者用 Dubbo 的 Hessian 协议暴露服务，消费者直接用标准 Hessian 接口调用 或者提供方用标准 Hessian 暴露服务，消费方用 Dubbo 的 Hessian 协议调用。 特性 连接个数：多连接 连接方式：短连接 传输协议：HTTP 传输方式：同步传输 序列化：Hessian二进制序列化 适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。 适用场景：页面传输，文件传输，或与原生hessian服务互操作 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.caucho&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hessian&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.0.7&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 约束 参数及返回值需实现 Serializable 接口 参数及返回值不能自定义实现 List, Map, Number, Date, Calendar 等接口，只能用 JDK 自带的实现，因为 hessian 会做特殊处理，自定义实现类中的属性值都会丢失。 配置 定义 hessian 协议：
&amp;lt;dubbo:protocol name=&amp;#34;hessian&amp;#34; port=&amp;#34;8080&amp;#34; server=&amp;#34;jetty&amp;#34; /&amp;gt; 设置默认协议：</description></item><item><title>hessian 协议</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/hessian/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/hessian/</guid><description>Hessian 1 协议用于集成 Hessian 的服务，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。
Dubbo 的 Hessian 协议可以和原生 Hessian 服务互操作，即：
提供者用 Dubbo 的 Hessian 协议暴露服务，消费者直接用标准 Hessian 接口调用 或者提供方用标准 Hessian 暴露服务，消费方用 Dubbo 的 Hessian 协议调用。 特性 连接个数：多连接 连接方式：短连接 传输协议：HTTP 传输方式：同步传输 序列化：Hessian二进制序列化 适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。 适用场景：页面传输，文件传输，或与原生hessian服务互操作 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.caucho&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hessian&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.0.7&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 约束 参数及返回值需实现 Serializable 接口 参数及返回值不能自定义实现 List, Map, Number, Date, Calendar 等接口，只能用 JDK 自带的实现，因为 hessian 会做特殊处理，自定义实现类中的属性值都会丢失。 配置 定义 hessian 协议：
&amp;lt;dubbo:protocol name=&amp;#34;hessian&amp;#34; port=&amp;#34;8080&amp;#34; server=&amp;#34;jetty&amp;#34; /&amp;gt; 设置默认协议：</description></item><item><title>Multicast</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/others/multicast/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/others/multicast/</guid><description>Multicast 注册中心不需要启动任何中心节点，只要广播地址一样，就可以互相发现。
1 使用说明 &amp;lt;dubbo:registry address=&amp;#34;multicast://224.5.6.7:1234&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:registry protocol=&amp;#34;multicast&amp;#34; address=&amp;#34;224.5.6.7:1234&amp;#34; /&amp;gt; 注意: 为了减少广播量，Dubbo 缺省使用单播发送提供者地址信息给消费者。 如果一个机器上同时启了多个消费者进程，消费者需声明 unicast=false，否则只会有一个消费者能收到消息; 当服务者和消费者运行在同一台机器上，消费者同样需要声明unicast=false，否则消费者无法收到消息，导致No provider available for the service异常：
&amp;lt;dubbo:application name=&amp;#34;demo-consumer&amp;#34;&amp;gt; &amp;lt;dubbo:parameter key=&amp;#34;unicast&amp;#34; value=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;/dubbo:application&amp;gt; 或
&amp;lt;dubbo:consumer&amp;gt; &amp;lt;dubbo:parameter key=&amp;#34;unicast&amp;#34; value=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;/dubbo:consumer&amp;gt; 2 工作原理 2.1 基本流程 提供方启动时广播自己的地址 消费方启动时广播订阅请求 提供方收到订阅请求时，单播自己的地址给订阅者，如果设置了 unicast=false，则广播给订阅者 消费方收到提供方地址时，连接该地址进行 RPC 调用。 2.2 使用限制 组播受网络结构限制，只适合小规模应用或开发阶段使用。组播地址段: 224.0.0.0 - 239.255.255.255</description></item><item><title>使用 Nacos 作为注册中心实现自动服务发现</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/nacos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/nacos/</guid><description>本示例演示 Nacos 作为注册中心实现自动服务发现，示例基于 Spring Boot 应用展开，可在此查看 完整示例代码
1 基本配置 1.1 增加依赖 对于 Spring Boot 应用，可以使用如下 spring-boot-starter：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0-beta.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-nacos-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0-beta.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 非 Spring Boot 用户，可以自行增加 dubbo、nacos-client 依赖：
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0-beta.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.nacos&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;nacos-client&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.1.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 1.2 Nacos 版本 Nacos 版本映射关系：
Dubbo 推荐 Nacos 版本 Nacos 兼容范围 3.3.0 2.3.0 2.x 3.2.21 2.1.0 2.x 3.1.11 2.0.9 2.x 3.0.10 2.0.9 2.x 2.7.21 1.x最新版本 1.x 2.</description></item><item><title>基于 protobuf 实现 triple 协议互通（适用于两边都用 protobuf 开发的场景）</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/interop-dubbo/call_java_protocol_triple_protobuf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/interop-dubbo/call_java_protocol_triple_protobuf/</guid><description>我们这里提供一个示例，演示如何使用 triple 协议实现 dubbo-java 和 dubbo-go 互通，可在此查看 示例完整源码。
示例主要内容如下：
go，go 语言实现的 rpc server 与 client java，java 语言实现的 rpc server 与 client 共享 protobuf 服务定义 共享服务定义如下，请注意以下 package、go_package 、java_package 的具体定义：
//protoc --go_out=. --go_opt=paths=source_relative --go-triple_out=. greet.proto syntax = &amp;#34;proto3&amp;#34;; package org.apache.dubbo.sample; option go_package = &amp;#34;github.com/apache/dubbo-go-samples/java_interop/protobuf-triple/go/proto;proto&amp;#34;; //package of go option java_package = &amp;#39;org.apache.dubbo.sample&amp;#39;; option java_multiple_files = true; option java_outer_classname = &amp;#34;HelloWorldProto&amp;#34;; option objc_class_prefix = &amp;#34;WH&amp;#34;; // The greeting service definition. service Greeter { // Sends a greeting rpc SayHello(HelloRequest) returns (HelloReply); // Sends a greeting via stream // rpc SayHelloStream (stream HelloRequest) returns (stream HelloReply) {} } // The request message containing the user&amp;#39;s name.</description></item><item><title>Redis 注册中心安装</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/admin/install/redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/admin/install/redis/</guid><description>Redis 1 使用方式参见: Redis 注册中心参考手册。
只需搭一个原生的 Redis 服务器，并将快速启动中 Provider 和 Consumer 里的 conf/dubbo.properties 中的 dubbo.registry.address 的值改为 redis://127.0.0.1:6379 即可使用。
Redis 注册中心集群 2 采用在客户端同时写入多个服务器，读取单个服务器的策略实现。
安装:
wget http://redis.googlecode.com/files/redis-2.4.8.tar.gz tar xzf redis-2.4.8.tar.gz cd redis-2.4.8 make 配置:
vi redis.conf 启动:
nohup ./src/redis-server redis.conf &amp;amp; 停止:
killall redis-server 命令行 3: ./src/redis-cli hgetall /dubbo/com.foo.BarService/providers 或者：
telnet 127.0.0.1 6379 hgetall /dubbo/com.foo.BarService/providers Redis 是一个高效的 KV 存储服务器，参见：http://redis.io/topics/quickstart&amp;#160;&amp;#x21a9;&amp;#xfe0e;
2.1.0 以上版本支持&amp;#160;&amp;#x21a9;&amp;#xfe0e;
参见: http://redis.io/commands&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>redis 协议</title><link>https://dubbo.apache.org/zh-cn/docs/references/protocols/redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/protocols/redis/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
基于 Redis 1 实现的 RPC 协议。
提示 2.3.0 以上版本支持 注册 redis 服务的地址 RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(&amp;#34;zookeeper://10.20.153.10:2181&amp;#34;)); registry.register(URL.valueOf(&amp;#34;redis://10.20.153.11/com.foo.BarService?category=providers&amp;amp;dynamic=false&amp;amp;application=foo&amp;amp;group=member&amp;amp;loadbalance=consistenthash&amp;#34;)); 在客户端引用 在客户端使用 2：
&amp;lt;dubbo:reference id=&amp;#34;store&amp;#34; interface=&amp;#34;java.util.Map&amp;#34; group=&amp;#34;member&amp;#34; /&amp;gt; 或者，点对点直连：
&amp;lt;dubbo:reference id=&amp;#34;store&amp;#34; interface=&amp;#34;java.util.Map&amp;#34; url=&amp;#34;redis://10.20.153.10:6379&amp;#34; /&amp;gt; 也可以使用自定义接口：
&amp;lt;dubbo:reference id=&amp;#34;store&amp;#34; interface=&amp;#34;com.foo.StoreService&amp;#34; url=&amp;#34;redis://10.20.153.10:6379&amp;#34; /&amp;gt; 方法名建议和 redis 的标准方法名相同，即：get(key), set(key, value), delete(key)。
如果方法名和 redis 的标准方法名不相同，则需要配置映射关系 3：
&amp;lt;dubbo:reference id=&amp;#34;cache&amp;#34; interface=&amp;#34;com.foo.CacheService&amp;#34; url=&amp;#34;redis://10.20.153.10:6379&amp;#34; p:set=&amp;#34;putFoo&amp;#34; p:get=&amp;#34;getFoo&amp;#34; p:delete=&amp;#34;removeFoo&amp;#34; /&amp;gt; Redis 是一个高效的 KV 存储服务器&amp;#160;&amp;#x21a9;&amp;#xfe0e;
不需要感知 Redis 的地址&amp;#160;&amp;#x21a9;&amp;#xfe0e;
其中 &amp;ldquo;p:xxx&amp;rdquo; 为 spring 的标准 p 标签&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>redis 协议</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/redis/</guid><description>基于 Redis 1 实现的 RPC 协议。
提示 2.3.0 以上版本支持 注册 redis 服务的地址 RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(&amp;#34;zookeeper://10.20.153.10:2181&amp;#34;)); registry.register(URL.valueOf(&amp;#34;redis://10.20.153.11/com.foo.BarService?category=providers&amp;amp;dynamic=false&amp;amp;application=foo&amp;amp;group=member&amp;amp;loadbalance=consistenthash&amp;#34;)); 在客户端引用 在客户端使用 2：
&amp;lt;dubbo:reference id=&amp;#34;store&amp;#34; interface=&amp;#34;java.util.Map&amp;#34; group=&amp;#34;member&amp;#34; /&amp;gt; 或者，点对点直连：
&amp;lt;dubbo:reference id=&amp;#34;store&amp;#34; interface=&amp;#34;java.util.Map&amp;#34; url=&amp;#34;redis://10.20.153.10:6379&amp;#34; /&amp;gt; 也可以使用自定义接口：
&amp;lt;dubbo:reference id=&amp;#34;store&amp;#34; interface=&amp;#34;com.foo.StoreService&amp;#34; url=&amp;#34;redis://10.20.153.10:6379&amp;#34; /&amp;gt; 方法名建议和 redis 的标准方法名相同，即：get(key), set(key, value), delete(key)。
如果方法名和 redis 的标准方法名不相同，则需要配置映射关系 3：
&amp;lt;dubbo:reference id=&amp;#34;cache&amp;#34; interface=&amp;#34;com.foo.CacheService&amp;#34; url=&amp;#34;redis://10.20.153.10:6379&amp;#34; p:set=&amp;#34;putFoo&amp;#34; p:get=&amp;#34;getFoo&amp;#34; p:delete=&amp;#34;removeFoo&amp;#34; /&amp;gt; Redis 是一个高效的 KV 存储服务器&amp;#160;&amp;#x21a9;&amp;#xfe0e;
不需要感知 Redis 的地址&amp;#160;&amp;#x21a9;&amp;#xfe0e;
其中 &amp;ldquo;p:xxx&amp;rdquo; 为 spring 的标准 p 标签&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>Router</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/extensibility/router/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/extensibility/router/</guid><description>通过自定义路由，可以根据业务场景的特点来实现特定的路由方式。本示例 router 扩展实现源码请参见 dubbo-samples-extensibility。
开始之前 任务详情 对所有的请求都使用第一提供服务的Provider，如果该Provider下线，则从新选择一个新的Provider。
实现方式 在Consumer中自定义一个Router，在Router中将第一次调用的Provider保存下来，如果后续有请求调用且Provider列表中包含第一次调用时使用的Provider，则继续使用第一次调用时使用的Provider，否则重新选去一个Provider。
代码结构 src |-main |-java |-org |-apache |-dubbo |-samples |-extensibility |-router |-consumer |-router |-StickFirstStateRouter.java (实现StateRouter接口) |-StickFirstStateRouterFactory.java (实现StateRouterFactory接口) |-resources |-META-INF |-application.properties (Dubbo Consumer配置文件) |-dubbo |-org.apache.dubbo.rpc.cluster.router.state.StateRouterFactory (纯文本文件) 代码详情 StickFirstStateRouter package org.apache.dubbo.samples.extensibility.router.consumer.router; import org.apache.dubbo.common.URL; import org.apache.dubbo.common.config.configcenter.ConfigChangeType; import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent; import org.apache.dubbo.common.config.configcenter.ConfigurationListener; import org.apache.dubbo.common.logger.ErrorTypeAwareLogger; import org.apache.dubbo.common.logger.LoggerFactory; import org.apache.dubbo.common.utils.CollectionUtils; import org.apache.dubbo.common.utils.Holder; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.RpcException; import org.apache.dubbo.rpc.cluster.router.RouterSnapshotNode; import org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter; import org.apache.dubbo.rpc.cluster.router.state.BitList; public class StickFirstStateRouter&amp;lt;T&amp;gt; extends AbstractStateRouter&amp;lt;T&amp;gt; implements ConfigurationListener { public StickFirstStateRouter(URL url) { super(url); } public static final String NAME = &amp;#34;STICK_FIRST_ROUTER&amp;#34;; private static final ErrorTypeAwareLogger logger = LoggerFactory.</description></item><item><title>Simple 注册中心</title><link>https://dubbo.apache.org/zh-cn/docs/references/registry/simple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/registry/simple/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Simple 注册中心本身就是一个普通的 Dubbo 服务，可以减少第三方依赖，使整体通讯方式一致。
配置 将 Simple 注册中心暴露成 Dubbo 服务：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;!-- 当前应用信息配置 --&amp;gt; &amp;lt;dubbo:application name=&amp;#34;simple-registry&amp;#34; /&amp;gt; &amp;lt;!-- 暴露服务协议配置 --&amp;gt; &amp;lt;dubbo:protocol port=&amp;#34;9090&amp;#34; /&amp;gt; &amp;lt;!-- 暴露服务配置 --&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;org.apache.dubbo.registry.RegistryService&amp;#34; ref=&amp;#34;registryService&amp;#34; registry=&amp;#34;N/A&amp;#34; ondisconnect=&amp;#34;disconnect&amp;#34; callbacks=&amp;#34;1000&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;subscribe&amp;#34;&amp;gt;&amp;lt;dubbo:argument index=&amp;#34;1&amp;#34; callback=&amp;#34;true&amp;#34; /&amp;gt;&amp;lt;/dubbo:method&amp;gt; &amp;lt;dubbo:method name=&amp;#34;unsubscribe&amp;#34;&amp;gt;&amp;lt;dubbo:argument index=&amp;#34;1&amp;#34; callback=&amp;#34;false&amp;#34; /&amp;gt;&amp;lt;/dubbo:method&amp;gt; &amp;lt;/dubbo:service&amp;gt; &amp;lt;!-- 简单注册中心实现，可自行扩展实现集群和状态同步 --&amp;gt; &amp;lt;bean id=&amp;#34;registryService&amp;#34; class=&amp;#34;org.apache.dubbo.registry.simple.SimpleRegistryService&amp;#34; /&amp;gt; &amp;lt;/beans&amp;gt; 引用 Simple Registry 服务：
&amp;lt;dubbo:registry address=&amp;#34;127.0.0.1:9090&amp;#34; /&amp;gt; 或者：</description></item><item><title>Simple 注册中心</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/registry/simple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/registry/simple/</guid><description>Simple 注册中心本身就是一个普通的 Dubbo 服务，可以减少第三方依赖，使整体通讯方式一致。
配置 将 Simple 注册中心暴露成 Dubbo 服务：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;!-- 当前应用信息配置 --&amp;gt; &amp;lt;dubbo:application name=&amp;#34;simple-registry&amp;#34; /&amp;gt; &amp;lt;!-- 暴露服务协议配置 --&amp;gt; &amp;lt;dubbo:protocol port=&amp;#34;9090&amp;#34; /&amp;gt; &amp;lt;!-- 暴露服务配置 --&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;org.apache.dubbo.registry.RegistryService&amp;#34; ref=&amp;#34;registryService&amp;#34; registry=&amp;#34;N/A&amp;#34; ondisconnect=&amp;#34;disconnect&amp;#34; callbacks=&amp;#34;1000&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;subscribe&amp;#34;&amp;gt;&amp;lt;dubbo:argument index=&amp;#34;1&amp;#34; callback=&amp;#34;true&amp;#34; /&amp;gt;&amp;lt;/dubbo:method&amp;gt; &amp;lt;dubbo:method name=&amp;#34;unsubscribe&amp;#34;&amp;gt;&amp;lt;dubbo:argument index=&amp;#34;1&amp;#34; callback=&amp;#34;false&amp;#34; /&amp;gt;&amp;lt;/dubbo:method&amp;gt; &amp;lt;/dubbo:service&amp;gt; &amp;lt;!-- 简单注册中心实现，可自行扩展实现集群和状态同步 --&amp;gt; &amp;lt;bean id=&amp;#34;registryService&amp;#34; class=&amp;#34;org.apache.dubbo.registry.simple.SimpleRegistryService&amp;#34; /&amp;gt; &amp;lt;/beans&amp;gt; 引用 Simple Registry 服务：
&amp;lt;dubbo:registry address=&amp;#34;127.0.0.1:9090&amp;#34; /&amp;gt; 或者：
&amp;lt;dubbo:service interface=&amp;#34;org.</description></item><item><title>Skywalking</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/observability/tracing/skywalking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/observability/tracing/skywalking/</guid><description>本文演示如何将 Dubbo 接入 Skywalking 全链路监控体系，完整示例请参考 dubbo-samples-tracing-skywalking。依赖的 Skywalking Agent 版本为 skywalking micrometer-1.10 api.
1. 添加 Micrometer Observation 依赖到你的项目 为了能够将 Micrometer 及相关 Metrics 依赖添加到 classpath，需要增加 dubbo-metrics-api 依赖，如下所示：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-metrics-api&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 2. 添加 Skywalking Micrometer-1.10 Api 到项目 为了将 Dubbo Micrometer tracing 数据集成到 Skywalking，需要添加以下依赖。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.skywalking&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;apm-toolkit-micrometer-1.10&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 3. 配置 ObservationRegistry @Configuration public class ObservationConfiguration { @Bean ApplicationModel applicationModel(ObservationRegistry observationRegistry) { ApplicationModel applicationModel = ApplicationModel.defaultModel(); observationRegistry.observationConfig() .observationHandler(new ObservationHandler.FirstMatchingCompositeObservationHandler( new SkywalkingSenderTracingHandler(), new SkywalkingReceiverTracingHandler(), new SkywalkingDefaultTracingHandler() )); applicationModel.</description></item><item><title>Streaming 通信</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/triple/streaming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/triple/streaming/</guid><description>在 选择 RPC 通信协议 一节提到，Streaming 是 Dubbo3 新提供的一种 RPC 数据传输模式，适用于以下场景:
接口需要发送大量数据，这些数据无法被放在一个 RPC 的请求或响应中，需要分批发送，但应用层如果按照传统的多次 RPC 方式无法解决顺序和性能的问题，如果需要保证有序，则只能串行发送 流式场景，数据需要按照发送顺序处理, 数据本身是没有确定边界的 推送类场景，多个消息在同一个调用的上下文中被发送和处理 Streaming 分为以下三种:
SERVER_STREAM(服务端流) CLIENT_STREAM(客户端流) BIDIRECTIONAL_STREAM(双向流) 以下示例演示 triple streaming 流式通信的基本使用方法，涵盖了客户端流、服务端流、双向流等三种模式，示例使用 Protocol Buffers 的服务开发模式，对于 Java 接口模式的开发者可以在本文最后查看相应说明。可在此查看 本示例完整代码。
运行示例 首先，可通过以下命令下载示例源码：
git clone --depth=1 https://github.com/apache/dubbo-samples.git 进入示例源码目录：
cd dubbo-samples/2-advanced/dubbo-samples-triple-streaming 编译项目，由 IDL 生成代码，这会调用 dubbo 提供的 protoc 插件生成对应的服务定义代码：
mvn clean compile 启动server 运行以下命令，启动 server：
$ mvn compile exec:java -Dexec.mainClass=&amp;#34;org.apache.dubbo.samples.tri.streaming.TriStreamServer&amp;#34; 启动client 运行以下命令，启动 client：
$ mvn compile exec:java -Dexec.mainClass=&amp;#34;org.apache.dubbo.samples.tri.streaming.TriStreamClient&amp;#34; 源码解读 与 使用 Protobuf(IDL) 开发 triple 协议服务 一节中提到的一样，这个示例使用 protobuf 定义服务，因此示例需要的依赖、配置等基本是一致的，请参考那一节了解完整详情。接下来，我们将重点讲解流式通信部分的内容。</description></item><item><title>thrift 协议</title><link>https://dubbo.apache.org/zh-cn/docs/references/protocols/thrift/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/protocols/thrift/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
当前 dubbo 支持的 thrift 协议是对 thrift 原生协议 1 的扩展，在原生协议的基础上添加了一些额外的头信息，比如 service name，magic number 等。
提示 2.3.0 以上版本支持 使用 dubbo thrift 协议同样需要使用 thrift 的 idl compiler 编译生成相应的 java 代码，后续版本中会在这方面做一些增强。
依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.thrift&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;libthrift&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.8.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 配置 所有服务共用一个端口 2：
&amp;lt;dubbo:protocol name=&amp;#34;thrift&amp;#34; port=&amp;#34;3030&amp;#34; /&amp;gt; 使用 可以参考 dubbo 项目中的示例代码
常见问题 Thrift 不支持 null 值，即：不能在协议中传递 null 值 Thrift 是 Facebook 捐给 Apache 的一个 RPC 框架&amp;#160;&amp;#x21a9;&amp;#xfe0e;
与原生Thrift不兼容&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>thrift 协议</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/thrift/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/thrift/</guid><description>当前 dubbo 支持的 thrift 协议是对 thrift 原生协议 1 的扩展，在原生协议的基础上添加了一些额外的头信息，比如 service name，magic number 等。
提示 2.3.0 以上版本支持 使用 dubbo thrift 协议同样需要使用 thrift 的 idl compiler 编译生成相应的 java 代码，后续版本中会在这方面做一些增强。
依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.thrift&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;libthrift&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.8.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 配置 所有服务共用一个端口 2：
&amp;lt;dubbo:protocol name=&amp;#34;thrift&amp;#34; port=&amp;#34;3030&amp;#34; /&amp;gt; 使用 可以参考 dubbo 项目中的示例代码
常见问题 Thrift 不支持 null 值，即：不能在协议中传递 null 值 Thrift 是 Facebook 捐给 Apache 的一个 RPC 框架&amp;#160;&amp;#x21a9;&amp;#xfe0e;
与原生Thrift不兼容&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>Triple协议迁移指南</title><link>https://dubbo.apache.org/zh-cn/docs/migration/migration-triple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/migration/migration-triple/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Triple 介绍 Triple 协议的格式和原理请参阅 RPC 通信协议
根据 Triple 设计的目标，Triple 协议有以下优势:
具备跨语言交互的能力，传统的多语言多 SDK 模式和 Mesh 化跨语言模式都需要一种更通用易扩展的数据传输协议。 提供更完善的请求模型，除了支持传统的 Request/Response 模型（Unary 单向通信），还支持 Stream（流式通信） 和 Bidirectional（双向通信）。 易扩展、穿透性高，包括但不限于 Tracing / Monitoring 等支持，也应该能被各层设备识别，网关设施等可以识别数据报文，对 Service Mesh 部署友好，降低用户理解难度。 完全兼容 grpc，客户端/服务端可以与原生grpc客户端打通。 可以复用现有 grpc 生态下的组件, 满足云原生场景下的跨语言、跨环境、跨平台的互通需求。 当前使用其他协议的 Dubbo 用户，框架提供了兼容现有序列化方式的迁移能力，在不影响线上已有业务的前提下，迁移协议的成本几乎为零。
需要新增对接 Grpc 服务的 Dubbo 用户，可以直接使用 Triple 协议来实现打通，不需要单独引入 grpc client 来完成，不仅能保留已有的 Dubbo 易用性，也能降低程序的复杂度和开发运维成本，不需要额外进行适配和开发即可接入现有生态。
对于需要网关接入的 Dubbo 用户，Triple 协议提供了更加原生的方式，让网关开发或者使用开源的 grpc 网关组件更加简单。网关可以选择不解析 payload ，在性能上也有很大提高。在使用 Dubbo 协议时，语言相关的序列化方式是网关的一个很大痛点，而传统的 HTTP 转 Dubbo 的方式对于跨语言序列化几乎是无能为力的。同时，由于 Triple 的协议元数据都存储在请求头中，网关可以轻松的实现定制需求，如路由和限流等功能。
Dubbo2 协议迁移流程 Dubbo2 的用户使用 dubbo 协议 + 自定义序列化，如 hessian2 完成远程调用。</description></item><item><title>XML 配置</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config/spring/xml/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config/spring/xml/</guid><description>Dubbo 有基于 Spring Schema 扩展的自定义配置组件，XML 支持的配置项与 配置参考手册 中描述的一一对。本文使用的示例请参考 dubbo-samples-spring-xml
XML完整示例 服务提供者 定义服务接口 DemoService.java：
package org.apache.dubbo.demo; public interface DemoService { String sayHello(String name); } 在服务提供方实现接口 DemoServiceImpl.java：
package org.apache.dubbo.demo.provider; import org.apache.dubbo.demo.DemoService; public class DemoServiceImpl implements DemoService { public String sayHello(String name) { return &amp;#34;Hello &amp;#34; + name; } } 用 Spring 配置声明暴露服务 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:context=&amp;#34;http://www.springframework.org/schema/context&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;#34;&amp;gt; &amp;lt;context:property-placeholder/&amp;gt; &amp;lt;dubbo:application name=&amp;#34;demo-provider&amp;#34;/&amp;gt; &amp;lt;dubbo:registry address=&amp;#34;zookeeper://${zookeeper.address:127.0.0.1}:2181&amp;#34;/&amp;gt; &amp;lt;dubbo:provider token=&amp;#34;true&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;demoService&amp;#34; class=&amp;#34;org.</description></item><item><title>Zipkin</title><link>https://dubbo.apache.org/zh-cn/overview/reference/integrations/zipkin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/integrations/zipkin/</guid><description>安装 你可以使用 Dubbo 社区提供的示例配置快速安装 Zipkin。
kubectl create -f https://raw.githubusercontent.com/apache/dubbo-kubernetes/master/deploy/kubernetes/zipkin.yaml 本安装仅适用于测试或体验使用，生产级别的安装请参考 Zipkin 官方安装文档。</description></item><item><title>Zookeeper 注册中心安装</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/admin/install/zookeeper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/admin/install/zookeeper/</guid><description>建议使用 dubbo-2.3.3 以上版本的 zookeeper 1 注册中心客户端。
Dubbo 未对 Zookeeper 服务器端做任何侵入修改，只需安装原生的 Zookeeper 服务器即可，所有注册中心逻辑适配都在调用 Zookeeper 客户端时完成。
安装:
wget http://archive.apache.org/dist/zookeeper/zookeeper-3.3.3/zookeeper-3.3.3.tar.gz tar zxvf zookeeper-3.3.3.tar.gz cd zookeeper-3.3.3 cp conf/zoo_sample.cfg conf/zoo.cfg 配置:
vi conf/zoo.cfg 如果不需要集群，zoo.cfg 的内容如下 2：
tickTime=2000 initLimit=10 syncLimit=5 dataDir=/home/dubbo/zookeeper-3.3.3/data clientPort=2181 如果需要集群，zoo.cfg 的内容如下 3：
tickTime=2000 initLimit=10 syncLimit=5 dataDir=/home/dubbo/zookeeper-3.3.3/data clientPort=2181 server.1=10.20.153.10:2555:3555 server.2=10.20.153.11:2555:3555 并在 data 目录 4 下放置 myid 文件：
mkdir data vi myid myid 指明自己的 id，对应上面 zoo.cfg 中 server. 后的数字，第一台的内容为 1，第二台的内容为 2，内容如下：
1 启动:
./bin/zkServer.sh start 停止:</description></item><item><title>版本与分组</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/version_group/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/version_group/</guid><description>Dubbo服务中，接口并不能唯一确定一个服务，只有 接口+分组+版本号 的三元组才能唯一确定一个服务。
当同一个接口针对不同的业务场景、不同的使用需求或者不同的功能模块等场景，可使用服务分组来区分不同的实现方式。同时，这些不同实现所提供的服务是可并存的，也支持互相调用。 当接口实现需要升级又要保留原有实现的情况下，即出现不兼容升级时，我们可以使用不同版本号进行区分。 本文示例完整源码可在以下链接查看：
dubbo-samples-group dubbo-samples-version dubbo-samples-merge 使用方式 使用 @DubboService 注解，配置 group 参数和 version 参数：
接口定义：
public interface DevelopService { String invoke(String param); } 接口实现1：
@DubboService(group = &amp;#34;group1&amp;#34;, version = &amp;#34;1.0&amp;#34;) public class DevelopProviderServiceV1 implements DevelopService{ @Override public String invoke(String param) { StringBuilder s = new StringBuilder(); s.append(&amp;#34;ServiceV1 param:&amp;#34;).append(param); return s.toString(); } } 接口实现2：
@DubboService(group = &amp;#34;group2&amp;#34;, version = &amp;#34;2.0&amp;#34;) public class DevelopProviderServiceV2 implements DevelopService{ @Override public String invoke(String param) { StringBuilder s = new StringBuilder(); s.</description></item><item><title>暴露监听扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/exporter-listener/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/exporter-listener/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 当有服务暴露时，触发该事件。
扩展接口 org.apache.dubbo.rpc.ExporterListener
扩展配置 &amp;lt;!-- 暴露服务监听 --&amp;gt; &amp;lt;dubbo:service listener=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 暴露服务缺省监听器 --&amp;gt; &amp;lt;dubbo:provider listener=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.registry.directory.RegistryExporterListener
扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxExporterListener.java (实现ExporterListener接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.ExporterListener (纯文本文件，内容为：xxx=com.xxx.XxxExporterListener) XxxExporterListener.java：
package com.xxx; import org.apache.dubbo.rpc.ExporterListener; import org.apache.dubbo.rpc.Exporter; import org.apache.dubbo.rpc.RpcException; public class XxxExporterListener implements ExporterListener { public void exported(Exporter&amp;lt;?&amp;gt; exporter) throws RpcException { // ... } public void unexported(Exporter&amp;lt;?&amp;gt; exporter) throws RpcException { // ... } } META-INF/dubbo/org.</description></item><item><title>暴露监听扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/exporter-listener/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/exporter-listener/</guid><description>扩展说明 当有服务暴露时，触发该事件。
扩展接口 org.apache.dubbo.rpc.ExporterListener
扩展配置 &amp;lt;!-- 暴露服务监听 --&amp;gt; &amp;lt;dubbo:service listener=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 暴露服务缺省监听器 --&amp;gt; &amp;lt;dubbo:provider listener=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.registry.directory.RegistryExporterListener
扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxExporterListener.java (实现ExporterListener接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.ExporterListener (纯文本文件，内容为：xxx=com.xxx.XxxExporterListener) XxxExporterListener.java：
package com.xxx; import org.apache.dubbo.rpc.ExporterListener; import org.apache.dubbo.rpc.Exporter; import org.apache.dubbo.rpc.RpcException; public class XxxExporterListener implements ExporterListener { public void exported(Exporter&amp;lt;?&amp;gt; exporter) throws RpcException { // ... } public void unexported(Exporter&amp;lt;?&amp;gt; exporter) throws RpcException { // ... } } META-INF/dubbo/org.</description></item><item><title>暴露监听扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/exporter-listener/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/exporter-listener/</guid><description>扩展说明 当有服务暴露时，触发该事件。
扩展接口 org.apache.dubbo.rpc.ExporterListener
扩展配置 &amp;lt;!-- 暴露服务监听 --&amp;gt; &amp;lt;dubbo:service listener=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 暴露服务缺省监听器 --&amp;gt; &amp;lt;dubbo:provider listener=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.registry.directory.RegistryExporterListener
扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxExporterListener.java (实现ExporterListener接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.ExporterListener (纯文本文件，内容为：xxx=com.xxx.XxxExporterListener) XxxExporterListener.java：
package com.xxx; import org.apache.dubbo.rpc.ExporterListener; import org.apache.dubbo.rpc.Exporter; import org.apache.dubbo.rpc.RpcException; public class XxxExporterListener implements ExporterListener { public void exported(Exporter&amp;lt;?&amp;gt; exporter) throws RpcException { // ... } public void unexported(Exporter&amp;lt;?&amp;gt; exporter) throws RpcException { // ... } } META-INF/dubbo/org.</description></item><item><title>成熟度</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/maturity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/maturity/</guid><description>功能成熟度 Feature Maturity Strength Problem Advise User 并发控制 Tested 并发控制 试用 连接控制 Tested 连接数控制 试用 直连提供者 Tested 点对点直连服务提供方，用于测试 测试环境使用 Alibaba 分组聚合 Tested 分组聚合返回值，用于菜单聚合等服务 特殊场景使用 可用于生产环境 参数验证 Tested 参数验证，JSR303验证框架集成 对性能有影响 试用 LaiWang 结果缓存 Tested 结果缓存，用于加速请求 试用 泛化引用 Stable 泛化调用，无需业务接口类进行远程调用，用于测试平台，开放网关桥接等 可用于生产环境 Alibaba 泛化实现 Stable 泛化实现，无需业务接口类实现任意接口，用于Mock平台 可用于生产环境 Alibaba 回声测试 Tested 回声测试 试用 隐式传参 Stable 附加参数 可用于生产环境 异步调用 Tested 不可靠异步调用 试用 本地调用 Tested 本地调用 试用 参数回调 Tested 参数回调 特殊场景使用 试用 Registry 事件通知 Tested 事件通知，在远程调用执行前后触发 试用 本地存根 Stable 在客户端执行部分逻辑 可用于生产环境 Alibaba 本地伪装 Stable 伪造返回结果，可在失败时执行，或直接执行，用于服务降级 需注册中心支持 可用于生产环境 Alibaba 延迟暴露 Stable 延迟暴露服务，用于等待应用加载warmup数据，或等待spring加载完成 可用于生产环境 Alibaba 延迟连接 Tested 延迟建立连接，调用时建立 试用 Registry 粘滞连接 Tested 粘滞连接，总是向同一个提供方发起请求，除非此提供方挂掉，再切换到另一台 试用 Registry 令牌验证 Tested 令牌验证，用于服务授权 需注册中心支持 试用 路由规则 Tested 动态决定调用关系 需注册中心支持 试用 配置规则 Tested 动态下发配置，实现功能的开关 需注册中心支持 试用 访问日志 Tested 访问日志，用于记录调用信息 本地存储，影响性能，受磁盘大小限制 试用 分布式事务 Research JTA/XA三阶段提交事务 不稳定 不可用 策略成熟度 Feature Maturity Strength Problem Advise User Zookeeper注册中心 Stable 支持基于网络的集群方式，有广泛周边开源产品，建议使用dubbo-2.</description></item><item><title>传递附加参数</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/rpc/attachments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/rpc/attachments/</guid><description>理解隐式参数传递的最直接方式 http header，它的工作方式与 http header 完全一致，在 GET 或 POST 请求体之外可以传递任意多个 header 参数。而对于 RPC 调用而言，context就是在方法签名的参数之外提供附加参数传递能力，在实现原理上，对于不同的协议，attachment 的实现方式略有不同：
对于 triple 协议，attachment 会转换为标准的 http header 进行传输。 对于 dubbo 协议，attachment 是编码在协议体的固定位置进行传输，具体请参见 dubbo 协议规范。、 注意 在使用 triple 协议时，由于 http header 的限制，仅支持小写的 ascii 字符 path, group, version, dubbo, token, timeout 等一些 key 是保留字段，传递 attachment 时应避免使用，尽量通过业务前缀等确保 key 的唯一性。 1.介绍 本文档演示如何在 Dubbo-go 框架中使用 context 上下文传递和读取附加参数，来实现上下文信息传递，可在此查看 完整示例源码地址
2.使用说明 2.1客户端使用说明 在客户端中，使用下述方式传递字段, 示例中 key 为 constant.AttachmentKey 即 &amp;ldquo;attachment&amp;rdquo;:
ctx := context.Background() ctx = context.</description></item><item><title>动态配置规则</title><link>https://dubbo.apache.org/zh-cn/overview/what/core-features/traffic/configuration-rule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/core-features/traffic/configuration-rule/</guid><description>动态配置规则 (ConfigurationRule) 是 Dubbo 设计的在无需重启应用的情况下，动态调整 RPC 调用行为的一种能力，也称为动态覆盖规则，因为它是通过在运行态覆盖 Dubbo 实例或者 Dubbo 实例中 URL 地址的各种参数值，实现改变 RPC 调用行为的能力。
使用动态配置规则，有以下几条关键信息值得注意：
设置规则生效过滤条件。 配置规则支持一系列的过滤条件，用来限定规则只对符合特定条件的服务、应用或实例才生效。 设置规则生效范围。 一个 rpc 服务有服务发起方（消费者）和服务处理方（提供者）两个角色，对某一个服务定义的规则，可以具体到限制是对消费者还是提供者生效。 选择规则管理粒度。 Dubbo 支持从服务和应用两个粒度来管理和下发规则。 以下一个应用级别的配置示例，配置生效后，shop-detail 应用下提供的所有服务都将启用 accesslog，对 shop-detail 部署的所有实例生效。
configVersion: v3.0 scope: application key: shop-detail configs: - side: provider parameters: accesslog: &amp;#39;true&amp;#39; 以下是一个服务级别的配置示例，key: org.apache.dubbo.samples.UserService 和 side: consumer 说明这条配置对所有正在消费 UserService 的 Dubbo 实例生效，在调用失败后都执行 4 次重试。match 条件进一步限制了消费端的范围，限定为只对应用名为 shop-frontend 的这个消费端应用生效。
configVersion: v3.0 scope: service key: org.apache.dubbo.samples.UserService configs: - match: application: oneof: - exact: shop-frontend side: consumer parameters: retries: &amp;#39;4&amp;#39; ConfigurationRule 配置规则主体，定义要设置的目标服务或应用、具体的规则配置。具体配置规则 (configs) 可以设置多条。</description></item><item><title>多协议</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/multi-protocols/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/multi-protocols/</guid><description>区别于普通的 RPC 框架，Dubbo 作为一款微服务框架提供了非常灵活的协议支持，它不绑定一个单一通信协议。因此你可以发布在一个进程中同时发布多个 RPC 协议、调用不同的 RPC 协议。接下来我们就详细介绍多协议的具体使用场景与使用方式。
使用场景 有很多场景可能会用到不同的协议，包括安全性、性能、与第三方系统互调等业务诉求。本文我们不分析具体的业务需求，而是从 Dubbo 框架提供的多协议能力出发分析框架能提供的多协议能力：
作为服务提供者（provider），同一个服务发布为多个协议，供不同消费端调用 作为服务提供者（provider），多个服务分别发布为不同协议，供不同消费端调用 作为服务消费者（consumer），指定以某个特定协议调用某一个服务 使用方式 同一个服务发布为多个协议 如果使用 Spring Boot，可以修改 application.yml 或 application.properties 如下：
dubbo: protocols: - id: dubbo-id name: dubbo port: 20880 - id: tri-id name: tri port: 50051 对于 Spring XML：
&amp;lt;dubbo:protocol id=&amp;#34;dubbo-id&amp;#34; name=&amp;#34;dubbo&amp;#34; port=&amp;#34;20880&amp;#34;/&amp;gt; &amp;lt;dubbo:protocol id=&amp;#34;triple-id&amp;#34; name=&amp;#34;tri&amp;#34; port=&amp;#34;50051&amp;#34;/&amp;gt; 接下来为服务配置（默认不配置的情况下，服务会发布到以上所有协议配置）：
@DubboService(protocol=&amp;#34;dubbo-id,triple-id&amp;#34;) private DemoServiceImpl implements DemoService {} 多个服务分别发布为不同协议 如果使用 Spring Boot，可以修改 application.yml 或 application.properties 如下：
dubbo: protocols: - id: dubbo-id name: dubbo port: 20880 - id: tri-id name: tri port: 50051 接下来为不同的服务分别配置不同的协议引用：</description></item><item><title>报告安全问题</title><link>https://dubbo.apache.org/zh-cn/contact/contributor/reporting-security-issues_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/contact/contributor/reporting-security-issues_dev/</guid><description>Apache Software Foundation 在消除其软件项目中的安全性问题方面采取严格的立场。Apache Dubbo 对与其功能和特性有关的问题非常敏感并很快提出。
报告漏洞 如果您对 Dubbo 的安全性有担心，或者发现漏洞或潜在威胁，请发送电子邮件至 security@dubbo.apache.org 与 Apache Dubbo 安全团队联系。在邮件中，指定问题或潜在威胁的描述。还敦促您推荐重现和复制问题的方法。Dubbo 社区会在评估和分析调查结果之后与您联系。
请先注意在安全电子邮件中报告安全问题，然后再在公共领域公开该问题。
漏洞处理 漏洞处理过程的概述是：
报告者将漏洞秘密报告给 Apache。 相应项目的安全团队与报告者私下合作来解决漏洞。 制作了包含该修复程序的有关 Apache 产品的新版本。 该漏洞已公开宣布。 有关此过程的详细说明，请参见此处</description></item><item><title>非protoubf模式协议互通（适用于老版本 dubbo java 应用）</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/interop-dubbo/call_java_protocol_dubbo_non_protobuf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/interop-dubbo/call_java_protocol_dubbo_non_protobuf/</guid><description>注意 在阅读本文档之前，请记住我们推荐使用 protobuf+triple 的模式编写 java 和 go 语言互通的服务。本文仅当您已经有老版本 dubbo java 应用的情况下适用，否则的话请参考上一篇文档，使用 protobuf+triple 开发服务。 可在此查看本文档 完整示例源码。
go-client 调用 java-server 但如果您是 dubbo java 的老用户，可能您的 dubbo java 应用并没有使用 protobuf（直接使用 java interface 定义服务），这个时候您需要使用以下方式开发 dubbo go-client，来调用老版本的 dubbo 服务。
以下方案同时支持 triple(non-protobuf) 和 dubbo 协议，你只需要调整协议配置 client.WithClientProtocolTriple() 即可。
假设我们当前的 java 服务定义如下：
package org.apache.dubbo.samples.api; public interface GreetingsService { String sayHi(String name); } 我们需要这么编写 go-client，以实现服务调用：
// 生成共享 client，指定 cliDubbo, _ := client.NewClient( client.WithClientProtocolDubbo(), client.WithClientSerialization(constant.Hessian2Serialization), ) // 生成服务代理，这里指定 java 服务全路径名 connDubbo, _ := cliDubbo.</description></item><item><title>Admin 服务 Mock 功能简介</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/control-plane/mock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/control-plane/mock/</guid><description>Mock 功能是设计用来提升微服务研发与测试效率的，它可以短路 Consumer 侧发起的远程调用，提前返回预先设定好的 Mock 值，这样即使在没有 Provider 可用的情况下，消费端也能正常的推进开发、测试进程。除此之外，mock 也可用于快速模拟负责返回值的测试数据、模拟服务端异常等场景
需要注意的是，Mock 能力仅限用于测试环境，应避免将其用于生产环境。
设计背景 在跨团队或是多应用开发时，在前期开发中往往会出现依赖的服务还未开发完成的情况，这样就会导致流程的阻塞，影响研发效率。基于这种情况，Dubbo Admin 提供了 mock 能力来解耦 Consumer 与 Provider 之间的依赖，以确保在 Provider 未就绪的情况下 Consumer 仍能正常开展测试，提高研发效率。
Dubbo 框架本身设计有服务降级（有时也称为 mock）能力，通过配置 org.apache.dubbo.config.ReferenceConfig 的 mock 字段（可设置为true或是对应接口的Mock实现）或动态配置规则，此时就可以启动服务降级能力。这种服务降级能力是为生产环境的限流降级准备的，虽然也可以用于本地开发测试场景，但灵活度并不高，基于提升开发效率的根本诉求，我们设计了基于 Admin 的服务降级能力。
Dubbo Admin 服务 mock 是一种更为轻量和便捷实现方式，主要用于开发测试阶段的，目标是提升微服务场景下的整体研发效率。需求详见：Dubbo Admin Mock需求。
架构设计 实现 Mock 能力，Dubbo 框架与 Admin 侧要支持的能力
Dubbo Admin 规则管理 规则新增 规则查询 规则修改 规则删除 请求历史记录 Mock 请求数据查询 MockService Provider 根据规则生成 Mock 数据 响应 Consumer Mock 请求 保存请求和返回数据 Dubbo 根据 mock 开关配置，转发请求到 Admin 注册的 MockService 处理 mock 返回值并转换为匹配方法签名的强类型数据 Mock 请求原理时序图</description></item><item><title>服务调用扩展点</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/service-invocation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/service-invocation/</guid><description>如上图所示，从服务调用的角度来看，Dubbo 在链路中提供了丰富的扩展点，覆盖了负载均衡方式、选址前后的拦截器、服务端处理拦截器等。 简单来说 Dubbo 发起远程调用的时候，主要工作流程可以分为消费端和服务端两个部分。
消费端的工作流程如下：
通过 Stub 接收来自用户的请求，并且封装在 Invocation 对象中 将 Invocation 对象传递给 ClusterFilter（扩展点）做选址前的请求预处理，如请求参数的转换、请求日志记录、限流等操作都是在此阶段进行的 将 Invocation 对象传递给 Cluster（扩展点）进行集群调用逻辑的决策，如快速失败模式、安全失败模式等决策都是在此阶段进行的 Cluster 调用 Directory 获取所有可用的服务端地址信息 Directory 调用 StateRouter（扩展点，推荐使用） 和 Router（扩展点） 对服务端的地址信息进行路由筛选，此阶段主要是从全量的地址信息中筛选出本次调用允许调用到的目标，如基于打标的流量路由就是在此阶段进行的 Cluster 获得从 Directory 提供的可用服务端信息后，会调用 LoadBalance （扩展点）从多个地址中选择出一个本次调用的目标，如随机调用、轮询调用、一致性哈希等策略都是在此阶段进行的 Cluster 获得目标的 Invoker 以后将 Invocation 传递给对应的 Invoker，并等待返回结果，如果出现报错则执行对应的决策（如快速失败、安全失败等） 经过上面的处理，得到了带有目标地址信息的 Invoker，会再调用 Filter（扩展点）进行选址后的请求处理（由于在消费端侧创建的 Filter 数量级和服务端地址量级一致，如无特殊需要建议使用 ClusterFilter 进行扩展拦截，以提高性能） 最后 Invocation 会被通过网络发送给服务端 服务端的工作流程如下：
服务端通信层收到请求以后，会将请求传递给协议层构建出 Invocation 将 Invocation 对象传递给 Filter （扩展点）做服务端请求的预处理，如服务端鉴权、日志记录、限流等操作都是在此阶段进行的 将 Invocation 对象传递给动态代理做真实的服务端调用 Filter（拦截器） 拦截器可以实现服务提供方和服务消费方调用过程拦截，Dubbo 本身的大多功能均基于此扩展点实现，每次远程方法执行，该拦截都会被执行，请注意对性能的影响。 其中在消费端侧，ClusterFilter 用于选址前的拦截和 Filter 用于选址后的拦截。如无特殊需要使用 ClusterFilter 进行扩展拦截，以提高性能。</description></item><item><title>服务引用</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/refer-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/refer-service/</guid><description>1. 简介 上一篇文章详细分析了服务导出的过程，本篇文章我们趁热打铁，继续分析服务引用过程。在 Dubbo 中，我们可以通过两种方式引用远程服务。第一种是使用服务直连的方式引用服务，第二种方式是基于注册中心进行引用。服务直连的方式仅适合在调试或测试服务的场景下使用，不适合在线上环境使用。因此，本文我将重点分析通过注册中心引用服务的过程。从注册中心中获取服务配置只是服务引用过程中的一环，除此之外，服务消费者还需要经历 Invoker 创建、代理类创建等步骤。这些步骤，将在后续章节中一一进行分析。
2.服务引用原理 Dubbo 服务引用的时机有两个，第一个是在 Spring 容器调用 ReferenceBean 的 afterPropertiesSet 方法时引用服务，第二个是在 ReferenceBean 对应的服务被注入到其他类中时引用。这两个引用服务的时机区别在于，第一个是饿汉式的，第二个是懒汉式的。默认情况下，Dubbo 使用懒汉式引用服务。如果需要使用饿汉式，可通过配置 &amp;lt;dubbo:reference&amp;gt; 的 init 属性开启。下面我们按照 Dubbo 默认配置进行分析，整个分析过程从 ReferenceBean 的 getObject 方法开始。当我们的服务被注入到其他类中时，Spring 会第一时间调用 getObject 方法，并由该方法执行服务引用逻辑。按照惯例，在进行具体工作之前，需先进行配置检查与收集工作。接着根据收集到的信息决定服务用的方式，有三种，第一种是引用本地 (JVM) 服务，第二是通过直连方式引用远程服务，第三是通过注册中心引用远程服务。不管是哪种引用方式，最后都会得到一个 Invoker 实例。如果有多个注册中心，多个服务提供者，这个时候会得到一组 Invoker 实例，此时需要通过集群管理类 Cluster 将多个 Invoker 合并成一个实例。合并后的 Invoker 实例已经具备调用本地或远程服务的能力了，但并不能将此实例暴露给用户使用，这会对用户业务代码造成侵入。此时框架还需要通过代理工厂类 (ProxyFactory) 为服务接口生成代理类，并让代理类去调用 Invoker 逻辑。避免了 Dubbo 框架代码对业务代码的侵入，同时也让框架更容易使用。
以上就是服务引用的大致原理，下面我们深入到代码中，详细分析服务引用细节。
3.源码分析 服务引用的入口方法为 ReferenceBean 的 getObject 方法，该方法定义在 Spring 的 FactoryBean 接口中，ReferenceBean 实现了这个方法。实现代码如下：
public Object getObject() throws Exception { return get(); } public synchronized T get() { if (destroyed) { throw new IllegalStateException(&amp;#34;Already destroyed!</description></item><item><title>服务治理和配置管理</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/admin/ops/governance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/admin/ops/governance/</guid><description>服务治理 服务治理主要作用是改变运行时服务的行为和选址逻辑，达到限流，权重配置等目的，主要有以下几个功能：
应用级别的服务治理 在 Dubbo 2.6 及更早版本中，所有的服务治理规则都只针对服务粒度，如果要把某条规则作用到应用粒度上，需要为应用下的所有服务配合相同的规则，变更，删除的时候也需要对应的操作，这样的操作很不友好，因此 Dubbo 2.7 版本中增加了应用粒度的服务治理操作，对于条件路由(包括黑白名单)，动态配置(包括权重，负载均衡)都可以做应用级别的配置：
上图是条件路由的配置，可以按照应用名，服务名两个维度来填写，也可以按照这两个维度来查询。
标签路由 标签路由是 Dubbo 2.7 引入的新功能，配置以应用作为维度，给不同的服务器打上不同名字的标签，配置如下图所示：
调用的时候，客户端可以通过setAttachment的方式，来设置不同的标签名称，比如本例中，setAttachment(tag1)，客户端的选址范围就在如图所示的三台机器中，可以通过这种方式来实现流量隔离，灰度发布等功能。
条件路由 条件路由是 Dubbo 一直以来就有的功能，目前可以配置服务和应用两个维度，条件路由为 yaml 格式，具体的规则体以及各种适用场景，请参考这里
黑白名单 黑白名单是条件路由的一部分，规则存储和条件路由放在一起，为了方便配置所以单独拿出来，同样可以通过服务和应用两个维度，指定黑名单和白名单:
动态配置 动态配置是和路由规则平行的另一类服务治理治理功能，主要作用是在不重启服务的情况下，动态改变调用行为，从Dubbo2.7版本开始，支持服务和应用两个维度的配置，采用yaml格式，界面如下：
具体的规则体说明请参考这里
权重调节 权重调节是动态配置的子功能，主要作用是改变服务端的权重，更大的权重会有更大的几率被客户端选中作为服务提供者，从而达到流量分配的目的：
负载均衡 负载均衡也是动态配置的子功能，主要作用是调整客户端的选址逻辑，目前可选的负载均衡策略有随机，轮训和最小活跃，关于各个策略的解释请参考这里
配置管理 配置管理也是配合Dubbo2.7新增的功能，在Dubbo2.7中，增加了全局和应用维度的配置，分别在全局和应用范围内生效，其中应用配置也可以指定该应用中的服务级别的配置，可以在控制台中查看，修改配置规则，默认展示全局维度的配置。
全局配置：
全局配置里可以指定注册中心，元数据中心的地址，服务端和客户端的超时时间等，这些配置在全局内生效。除了配置写入，也可以用来查看。如果使用zookeeper作为注册中心和元数据中心，还可以看到配置文件所在位置的目录结构。
应用， 服务配置
应用级别的配置可以为应用或者应用内的服务指定配置，在服务维度上，需要区分提供者和消费者。dubbo.reference.{serviceName}表示作为该服务消费者的配置，dubbo.provider.{servcieName}表示作为该服务提供者的配置。其中注册中心和元数据中心的地址，只能在全局配置中指定，这也是Dubbo2.7中推荐的使用方式。
优先级： 服务配置 &amp;gt; 应用配置 &amp;gt; 全局配置</description></item><item><title>软件捐献向导</title><link>https://dubbo.apache.org/zh-cn/contact/contributor/software-donation-guide_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/contact/contributor/software-donation-guide_dev/</guid><description>在您阅读这篇指南之前，请确保您已经向PMC确认了实际需要的 SGA。
如果您向 Apache Dubbo 捐赠了大量的代码或文档，则需要在合并代码或者文档之前签署软件授权书。
操作步骤 下载这篇pdf文档 打印下载好的文档 按要求填充表格（请看下边示例） 请您的领导在上边签字 扫描 将扫描好的文档以邮件的方式发送给secretary@apache.org，并抄送给private@dubbo.apache.org 示例 下边是一个文本示例，原始文本可以在这里找到
License Agreement This License Agreement is entered into as of the _12th_ day of ___April____, __2018__ by ___ABC Software Co., Ltd.____ (&amp;#34;Licensor&amp;#34;), in favor of The Apache Software Foundation, a Delaware nonstock membership corporation (the &amp;#34;Foundation&amp;#34;). WHEREAS, Licensor owns or has sufficient rights to contribute the software source code and other related intellectual property as itemized on Exhibit A (&amp;#34;Software&amp;#34;) under the terms of this agreement to the Foundation for use within Foundation software development projects (&amp;#34;Projects&amp;#34;).</description></item><item><title>框架状态命令</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/introduction/probe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/introduction/probe/</guid><description> 参考文档：Kubernetes 生命周期探针
startup 命令 检测当前框架是否已经启动完毕
dubbo&amp;gt;startup true dubbo&amp;gt; ready 命令 检测当前框架是否能正常提供服务（可能是临时下线）
dubbo&amp;gt;ready true dubbo&amp;gt; live 命令 检测当前框架是否正常运行（可能是永久异常）
dubbo&amp;gt;live true dubbo&amp;gt;</description></item><item><title>更多配置中心扩展实现</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config-center/others/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config-center/others/</guid><description>Dubbo 框架还默认提供了 etcd、consul 等配置中心适配实现。
Etcd Etcd 配置中心由社区生态库维护，具体可参见 。
增加依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-configcenter-etcd&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 调整配置：
dubbo config-center address: etcd://127.0.0.1:1111 Consul Consul 配置中心由社区生态库维护，具体可参见 。
增加依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-configcenter-consul&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 调整配置：
dubbo config-center address: consul://127.0.0.1:1111</description></item><item><title>更多元数据中心扩展实现</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/metadata-center/others/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/metadata-center/others/</guid><description>Dubbo 框架还默认提供了 redis、etcd、consul 等元数据中心适配实现
Redis Redis 实现由主干库提供内置实现，但需要增加以下依赖：
&amp;lt;dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.10.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependency&amp;gt; dubbo metadata-report address: redis://127.0.0.1:1111 或者
dubbo.metadata-report.address=redis://127.0.0.1:1111 Etcd Etcd 元数据中心由社区生态库维护，具体可参见 。
增加依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-metadata-report-etcd&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 调整配置：
dubbo metadata-report address: etcd://127.0.0.1:1111 Consul Consul 元数据中心由社区生态库维护，具体可参见 。
增加依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-metadata-report-consul&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 调整配置：
dubbo metadata-report address: consul://127.0.0.1:1111</description></item><item><title>配置管理</title><link>https://dubbo.apache.org/zh-cn/docs/concepts/configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/concepts/configuration/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo配置主要分为几大类： 启动阶段配置项、服务治理规则、动态配置项。
启动阶段配置项 Dubbo启动时读取的配置项，用于初始化各个组件，不会监听这些配置项的变化。
Dubbo的配置来源有多种，配置项划分为多个配置组件，详细请参考 配置概述。
配置方式 按照编程方式可以分为四种方式：API配置、XML配置、Annotation配置、属性配置。
API配置 以Java编码的方式组织配置，包括Raw API和Bootstrap API，具体请参考API配置。
XML配置 以XML方式配置各种组件，支持与Spring无缝集成，具体请参考XML配置。
Annotation配置 以注解方式暴露服务和引用服务接口，支持与Spring无缝集成，具体请参考Annotation配置。
属性配置 根据Key-value属性生成配置组件，类似SpringBoot的ConfigurationProperties，具体请参考属性配置。
属性配置的另外一个重要的功能特性是属性覆盖，使用外部属性的值覆盖已创建的配置组件属性。
如果要将属性配置放到外部的配置中心，请参考外部化配置。
服务治理规则 服务治理规则主要作用是改变运行时服务的行为和选址逻辑，达到限流，权重配置等目的，包括覆盖规则、标签路由、条件路由。
Dubbo启动后监听服务治理相关的配置项，当配置发生变化时，会自动进行相应的处理。
服务治理规则的用法介绍请参考 服务治理和配置管理
服务治理规则的存储方法请参考 配置中心#服务治理
动态配置项 动态配置项一般用于控制动态开关。
Dubbo启动后监听动态配置项，当配置发生变化时，会自动进行相应的处理。
动态配置的存储方式请参考 配置中心#动态配置
常用的动态配置项如下：
[TODO 补充动态配置项说明]
名称 描述 默认值 dubbo.application.migration.threshold dubbo.application.service-discovery.migration</description></item><item><title>启动时检查</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/rpc/start-check/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/rpc/start-check/</guid><description>Dubbo 框架缺省会在启动时检查依赖的服务是否可用（注册中心是否有可用地址），不可用时会抛出异常，阻止应用初始化完成，以便上线时，能及早发现问题，默认 check=&amp;ldquo;true&amp;rdquo;，并等待3s。
可以通过 check=&amp;ldquo;false&amp;rdquo; 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。
关闭 check 后，请注意 provider数量比较多时， consumer 订阅 provider 生成服务地址可能会有一定延迟，如果 consumer 一启动就对外提供服务，可能会造成&amp;quot;冷启动&amp;quot;。所以在这个时候，请对服务进行预热。
示例：
dubbo: consumer: check : false reference: myserivce: check: true 或者
cli, err := client.NewClient( client.WithClientCheck(false), ) 或者
svc, err := health.NewHealth(cli) svc.Check(context.Background(), &amp;amp;health.HealthCheckRequest{Service: &amp;#34;greet.GreetService&amp;#34;}, client.WithCheck(false))</description></item><item><title>生产环境验证</title><link>https://dubbo.apache.org/zh-cn/overview/what/advantages/production-ready/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/advantages/production-ready/</guid><description>Apache Dubbo 是一款有着数以万计企业用户的国际化开源项目，经过了多年大规模集群生产环境的检验，影响了数百万开发者，带动了大量微服务开源生态发展。Dubbo 从企业实践中孵化并走向开源，又迅速在开源社区获得了成功，大量的生产实践用户是 Dubbo 长期保持先进性、稳定性和活跃度的核心驱动力。
Dubbo 在阿里巴巴的应用 Dubbo 设计用于解决阿里巴巴内部复杂的电商微服务集群的开发和治理问题，在 2020 年，阿里巴巴与 Apache Dubbo 社区共同合作，基于 Dubbo2 &amp;amp; HSF2 发布了面向云原生架构的下一代服务框架 - Dubbo3，目前，Dubbo3 已经完全升级 HSF2、Dubbo2 成为阿里巴巴内部统一的服务框架，成功的跑在了数十万应用、数百万节点的双十一集群之上。
Dubbo3 吸取了 HSF2 框架所有大规模微服务集群的治理经验，解决了 Dubbo2 架构设计上长期积累的一些缺陷，同时增加了一系列面向云原生架构的新特性。
阿里巴巴结合 HSF 框架的大规模集群实践经验，基于 Apache Dubbo、开源社区需求等推出了面向云原生架构的全新服务框架 - Dubbo3，Dubbo3 在完全兼容之前 API 模式的情况下，完成了彻底的云原生架构升级。 Dubbo 的高度可扩展能力是其广泛适用的重要前提，阿里巴巴基于 Dubbo3 内核维护了一套内部特有的适配插件体系以实现平滑升级，这包括注册中心扩展、路由组件扩展、监控组件扩展等。 几乎所有主流云厂商、主流微服务开源社区都提供了 Dubbo 适配或托管服务。 关于阿里巴巴 Dubbo3 应用的更多细节，请参见 博客文章
更多案例 据 Wanted, Who&amp;rsquo;s Using Dubbo 统计，Dubbo 已知部分典型用户包括：
网联清算、银联商务、中国人寿、中国平安、中国银行、人民银行、工商银行、招商证券、平安保险、中国人寿、阿里巴巴、滴滴出行、携程网、小米、斗鱼直播、瓜子二手车、金蝶、亚信科技、中国电信、文思海辉、中科软、科大讯飞、恒生电子、红星凯美龙、海尔、新东方、软通动力、中远海运、昆明航空、中通快递、顺丰科技、普华永道等。</description></item><item><title>实现细节</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/implementation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/implementation/</guid><description>初始化过程细节 解析服务 基于 dubbo.jar 内的 META-INF/spring.handlers 配置，Spring 在遇到 dubbo 名称空间时，会回调 DubboNamespaceHandler。
所有 dubbo 的标签，都统一用 DubboBeanDefinitionParser 进行解析，基于一对一属性映射，将 XML 标签解析为 Bean 对象。
在 ServiceConfig.export() 或 ReferenceConfig.get() 初始化时，将 Bean 对象转换 URL 格式，所有 Bean 属性转成 URL 的参数。
然后将 URL 传给 协议扩展点，基于扩展点的 扩展点自适应机制，根据 URL 的协议头，进行不同协议的服务暴露或引用。
暴露服务 1. 只暴露服务端口： 在没有注册中心，直接暴露提供者的情况下 1，ServiceConfig 解析出的 URL 的格式为： dubbo://service-host/com.foo.FooService?version=1.0.0。
基于扩展点自适应机制，通过 URL 的 dubbo:// 协议头识别，直接调用 DubboProtocol的 export() 方法，打开服务端口。
2. 向注册中心暴露服务： 在有注册中心，需要注册提供者地址的情况下 2，ServiceConfig 解析出的 URL 的格式为: registry://registry-host/org.apache.dubbo.registry.RegistryService?export=URL.encode(&amp;quot;dubbo://service-host/com.foo.FooService?version=1.0.0&amp;quot;)，
基于扩展点自适应机制，通过 URL 的 registry:// 协议头识别，就会调用 RegistryProtocol 的 export() 方法，将 export 参数中的提供者 URL，先注册到注册中心。</description></item><item><title>使用 Nacos 作为注册中心实现自动服务发现</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/service-discovery/nacos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/service-discovery/nacos/</guid><description>本示例演示 Nacos 作为注册中心实现自动服务发现，示例基于 Spring Boot 应用展开，可在此查看 完整示例代码
1 基本配置 1.1 增加依赖 增加 dubbo、nacos-client 依赖：
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0-beta.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.nacos&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;nacos-client&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.1.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 对于 Spring Boot 应用，可以使用如下 spring-boot-starter：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0-beta.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-nacos-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0-beta.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 1.2 Nacos 版本 Nacos 版本映射关系：
Dubbo 推荐 Nacos 版本 Nacos 兼容范围 3.3.0 2.2.3 2.x 3.2.21 2.1.0 2.x 3.1.11 2.0.9 2.x 3.0.10 2.0.9 2.x 2.7.21 1.x 1.x 2.6.0 1.x 1.x 1.</description></item><item><title>谈谈扩充式扩展与增量式扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/principals/expansibility/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/principals/expansibility/</guid><description>我们平台的产品越来越多，产品的功能也越来越多。平台的产品为了适应各 BU 和部门以及产品线的需求，势必会将很多不相干的功能凑在一起，客户可以选择性的使用。为了兼容更多的需求，每个产品，每个框架，都在不停的扩展，而我们经常会选择一些扩展的扩展方式，也就是将新旧功能扩展成一个通用实现。我想讨论是，有些情况下也可以考虑增量式的扩展方式，也就是保留原功能的简单性，新功能独立实现。我最近一直做分布式服务框架的开发，就拿我们项目中的问题开涮吧。
比如：远程调用框架，肯定少不了序列化功能，功能很简单，就是把流转成对象，对象转成流。但因有些地方可能会使用 osgi，这样序列化时，IO 所在的 ClassLoader 可能和业务方的 ClassLoader 是隔离的。需要将流转换成 byte[] 数组，然后传给业务方的 ClassLoader 进行序列化。为了适应 osgi 需求，把原来非 osgi 与 osgi 的场景扩展了一下，这样，不管是不是 osgi 环境，都先将流转成 byte[] 数组，拷贝一次。然而，大部分场景都用不上 osgi，却为 osgi 付出了代价。而如果采用增量式扩展方式，非 osgi 的代码原封不动，再加一个 osgi 的实现，要用 osgi 的时候，直接依赖 osgi 实现即可。
再比如：最开始，远程服务都是基于接口方法，进行透明化调用的。这样，扩展接口就是， invoke(Method method, Object[] args)，后来，有了无接口调用的需求，就是没有接口方法也能调用，并将 POJO 对象都转换成 Map 表示。因为 Method 对象是不能直接 new 出来的，我们不自觉选了一个扩展式扩展，把扩展接口改成了 invoke(String methodName, String[] parameterTypes, String returnTypes, Object[] args)，导致不管是不是无接口调用，都得把 parameterTypes 从 Class[] 转成 String[]。如果选用增量式扩展，应该是保持原有接口不变，增加一个 GeneralService 接口，里面有一个通用的 invoke() 方法，和其它正常业务上的接口一样的调用方式，扩展接口也不用变，只是 GeneralServiceImpl 的 invoke() 实现会将收到的调用转给目标接口，这样就能将新功能增量到旧功能上，并保持原来结构的简单性。
再再比如：无状态消息发送，很简单，序列化一个对象发过去就行。后来有了同步消息发送需求，需要一个 Request/Response 进行配对，采用扩展式扩展，自然想到，无状态消息其实是一个没有 Response 的 Request，所以在 Request 里加一个 boolean 状态，表示要不要返回 Response。如果再来一个会话消息发送需求，那就再加一个 Session 交互，然后发现，原来同步消息发送是会话消息的一种特殊情况，所有场景都传 Session，不需要 Session 的地方无视即可。</description></item><item><title>同机房/区域优先</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/region/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/region/</guid><description>为了保证服务的整体高可用，我们经常会采用把服务部署在多个可用区(机房)的策略，通过这样的冗余/容灾部署模式，当一个区域出现故障的时候，我们仍可以保证服务整体的可用性。
当应用部署在多个不同机房/区域的时候，应用之间相互调用就会出现跨区域的情况，而跨区域调用会增加响应时间，影响用户体验。同机房/区域优先是指应用调用服务时，优先调用同机房/区域的服务提供者，避免了跨区域带来的网络延时，从而减少了调用的响应时间。
开始之前 部署 Shop 商城项目 部署并打开 Dubbo Admin 任务详情 Detail 应用和 Comment 应用都有双区域部署，其中 Detail v1 与 Comment v1 部署在区域 Beijing，Detail v2 与 Comment v2 部署在区域 Hangzhou 区域。为了保证服务调用的响应速度，我们需要增加同区域优先的调用规则，确保 Beijing 区域内的 Detail v1 始终默认调用 Comment v1，Hangzhou 区域内的 Detail v2 始终调用 Comment v2。
当同区域内的服务出现故障或不可用时，则允许跨区域调用。
配置 Detail 访问同区域部署的 Comment 服务 正常登录商城系统后，首页默认展示商品详情信息，多次刷新页面，发现商品详情 (description) 与评论 (comment) 选项会出现多个不同版本的组合，结合上面 Detail 和 Comment 的部署结构，这说明服务调用并没有遵循同区域优先的原则。
因此，接下来我们需要添加同区域优先规则，保证：
hangzhou 区域的 Detail 服务调用同区域的 Comment 服务，即 description v1 与 comment v1 始终组合展示 beijing 区域的 Detail 服务调用同区域的 Comment 服务，即 description v2 与 comment v2 始终组合展示 操作步骤 登录 Dubbo Admin 控制台 在左侧导航栏选择【服务治理】 &amp;gt; 【条件路由】。 点击 &amp;ldquo;创建&amp;rdquo; 按钮，填入要启用同区域优先的服务如 org.</description></item><item><title>线程模型</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/thread-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/thread-model/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
如果事件处理的逻辑能迅速完成，并且不会发起新的 IO 请求，比如只是在内存中记个标识，则直接在 IO 线程上处理更快，因为减少了线程池调度。
但如果事件处理逻辑较慢，或者需要发起新的 IO 请求，比如需要查询数据库，则必须派发到线程池，否则 IO 线程阻塞，将导致不能接收其它请求。
如果用 IO 线程处理事件，又在事件处理过程中发起新的 IO 请求，比如在连接事件中发起登录请求，会报“可能引发死锁”异常，但不会真死锁。
因此，需要通过不同的派发策略和不同的线程池配置的组合来应对不同的场景:
&amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; dispatcher=&amp;#34;all&amp;#34; threadpool=&amp;#34;fixed&amp;#34; threads=&amp;#34;100&amp;#34; /&amp;gt; Dispatcher
all 所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等。 direct 所有消息都不派发到线程池，全部在 IO 线程上直接执行。 message 只有请求响应消息派发到线程池，其它连接断开事件，心跳等消息，直接在 IO 线程上执行。 execution 只有请求消息派发到线程池，不含响应，响应和其它连接断开事件，心跳等消息，直接在 IO 线程上执行。 connection 在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池。 ThreadPool
fixed 固定大小线程池，启动时建立线程，不关闭，一直持有。(缺省) cached 缓存线程池，空闲一分钟自动删除，需要时重建。 limited 可伸缩线程池，但池中的线程数只会增长不会收缩。只增长不收缩的目的是为了避免收缩时突然来了大流量引起的性能问题。 eager 优先创建Worker线程池。在任务数量大于corePoolSize但是小于maximumPoolSize时，优先创建Worker来处理任务。当任务数量大于maximumPoolSize时，将任务放入阻塞队列中。阻塞队列充满时抛出RejectedExecutionException。(相比于cached:cached在任务数量超过maximumPoolSize时直接抛出异常而不是将任务放入阻塞队列)</description></item><item><title>线程模型</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/thread-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/thread-model/</guid><description>背景 如果事件处理的逻辑能迅速完成，并且不会发起新的 IO 请求，比如只是在内存中记个标识，则直接在 IO 线程上处理更快，因为减少了线程池调度。
但如果事件处理逻辑较慢，或者需要发起新的 IO 请求，比如需要查询数据库，则必须派发到线程池，否则 IO 线程阻塞，将导致不能接收其它请求。
如果用 IO 线程处理事件，又在事件处理过程中发起新的 IO 请求，比如在连接事件中发起登录请求，会报“可能引发死锁”异常，但不会真死锁。
示例 因此，需要通过不同的派发策略和不同的线程池配置的组合来应对不同的场景:
&amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; dispatcher=&amp;#34;all&amp;#34; threadpool=&amp;#34;fixed&amp;#34; threads=&amp;#34;100&amp;#34; /&amp;gt; Dispatcher
all 所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等。 direct 所有消息都不派发到线程池，全部在 IO 线程上直接执行。 message 只有请求响应消息派发到线程池，其它连接断开事件，心跳等消息，直接在 IO 线程上执行。 execution 只有请求消息派发到线程池，不含响应，响应和其它连接断开事件，心跳等消息，直接在 IO 线程上执行。 connection 在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池。 ThreadPool
fixed 固定大小线程池，启动时建立线程，不关闭，一直持有。(缺省) cached 缓存线程池，空闲一分钟自动删除，需要时重建。 limited 可伸缩线程池，但池中的线程数只会增长不会收缩。只增长不收缩的目的是为了避免收缩时突然来了大流量引起的性能问题。 eager 优先创建Worker线程池。在任务数量大于corePoolSize但是小于maximumPoolSize时，优先创建Worker来处理任务。当任务数量大于maximumPoolSize时，将任务放入阻塞队列中。阻塞队列充满时抛出RejectedExecutionException。(相比于cached:cached在任务数量超过maximumPoolSize时直接抛出异常而不是将任务放入阻塞队列)</description></item><item><title>序列化配置项</title><link>https://dubbo.apache.org/zh-cn/docs/languages/erlang/serialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/erlang/serialization/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
当前该库只实现了 dubbo:// 通讯协议。
序列化方式实现了 hessian 和 json 两种方式。
配置样例 序列化配置需要添加到 sys.config 文件 dubboerl 应用配置项里。
{dubboerl,[ %% other config ... {protocol,hessian} ]} ConfigName Type DefaultValue Remarks protocol atom() hessian hessian,json</description></item><item><title>序列化配置项</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/languages/erlang/serialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/languages/erlang/serialization/</guid><description>当前该库只实现了 dubbo:// 通讯协议。
序列化方式实现了 hessian 和 json 两种方式。
配置样例 序列化配置需要添加到 sys.config 文件 dubboerl 应用配置项里。
{dubboerl,[ %% other config ... {protocol,hessian} ]} ConfigName Type DefaultValue Remarks protocol atom() hessian hessian,json</description></item><item><title>序列化配置项</title><link>https://dubbo.apache.org/zh-cn/overview/reference/erlang-sdk/serialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/erlang-sdk/serialization/</guid><description>当前该库只实现了 dubbo:// 通讯协议。
序列化方式实现了 hessian 和 json 两种方式。
配置样例 序列化配置需要添加到 sys.config 文件 dubboerl 应用配置项里。
{dubboerl,[ %% other config ... {protocol,hessian} ]} ConfigName Type DefaultValue Remarks protocol atom() hessian hessian,json</description></item><item><title>用法</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/preface/usage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/preface/usage/</guid><description>本地服务 Spring 配置 local.xml
&amp;lt;bean id=“xxxService” class=“com.xxx.XxxServiceImpl” /&amp;gt; &amp;lt;bean id=“xxxAction” class=“com.xxx.XxxAction”&amp;gt; &amp;lt;property name=“xxxService” ref=“xxxService” /&amp;gt; &amp;lt;/bean&amp;gt; 远程服务 Spring 配置 在本地服务的基础上，只需做简单配置，即可完成远程化：
将上面的 local.xml 配置拆分成两份，将服务定义部分放在服务提供方 remote-provider.xml，将服务引用部分放在服务消费方 remote-consumer.xml。 并在提供方增加暴露服务配置 &amp;lt;dubbo:service&amp;gt;，在消费方增加引用服务配置 &amp;lt;dubbo:reference&amp;gt;。 remote-provider.xml
&amp;lt;!-- 和本地服务一样实现远程服务 --&amp;gt; &amp;lt;bean id=“xxxService” class=“com.xxx.XxxServiceImpl” /&amp;gt; &amp;lt;!-- 增加暴露远程服务配置 --&amp;gt; &amp;lt;dubbo:service interface=“com.xxx.XxxService” ref=“xxxService” /&amp;gt; remote-consumer.xml
&amp;lt;!-- 增加引用远程服务配置 --&amp;gt; &amp;lt;dubbo:reference id=“xxxService” interface=“com.xxx.XxxService” /&amp;gt; &amp;lt;!-- 和本地服务一样使用远程服务 --&amp;gt; &amp;lt;bean id=“xxxAction” class=“com.xxx.XxxAction”&amp;gt; &amp;lt;property name=“xxxService” ref=“xxxService” /&amp;gt; &amp;lt;/bean&amp;gt;</description></item><item><title>动态指定 IP 调用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/specify-ip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/specify-ip/</guid><description>特性说明 在发起 RPC 请求的时候，需要指定本次调用的服务端，常用的场景包括消息回调、流量隔离等。
使用方式 插件依赖 首先，需要添加以下插件依赖到项目中
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-cluster-specify-address-dubbo3&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 适配 Dubbo 2 版本
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-cluster-specify-address-dubbo2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 调用示例 ReferenceConfig&amp;lt;DemoService&amp;gt; referenceConfig = new ReferenceConfig&amp;lt;&amp;gt;(); // ... init DemoService demoService = referenceConfig.get(); // for invoke // 1. find 10.10.10.10:20880 exist // 2. if not exist, create a invoker to 10.10.10.10:20880 if `needToCreate` is true (only support in Dubbo 3.x&amp;#39;s implementation) UserSpecifiedAddressUtil.setAddress(new Address(&amp;#34;10.10.10.10&amp;#34;, 20880, true)); demoService.sayHello(&amp;#34;world&amp;#34;); // for invoke // 1.</description></item><item><title>注解配置</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/configuration/annotation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/configuration/annotation/</guid><description>提示 需要 2.6.3 及以上版本支持。 点此查看 完整示例 服务提供方 Service注解暴露服务 @Service public class AnnotationServiceImpl implements AnnotationService { @Override public String sayHello(String name) { return &amp;#34;annotation: hello, &amp;#34; + name; } } 增加应用共享配置 # dubbo-provider.properties dubbo.application.name=annotation-provider dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.protocol.name=dubbo dubbo.protocol.port=20880 指定Spring扫描路径 @Configuration @EnableDubbo(scanBasePackages = &amp;#34;org.apache.dubbo.samples.simple.annotation.impl&amp;#34;) @PropertySource(&amp;#34;classpath:/spring/dubbo-provider.properties&amp;#34;) static public class ProviderConfiguration { } 服务消费方 Reference注解引用服务 @Component(&amp;#34;annotationAction&amp;#34;) public class AnnotationAction { @Reference private AnnotationService annotationService; public String doSayHello(String name) { return annotationService.sayHello(name); } } 增加应用共享配置 # dubbo-consumer.</description></item><item><title>自适应负载均衡与限流</title><link>https://dubbo.apache.org/zh-cn/overview/reference/proposals/heuristic-flow-control/</link><pubDate>Mon, 30 Jan 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/proposals/heuristic-flow-control/</guid><description>整体介绍 本文所说的柔性服务主要是指consumer端的负载均衡和provider端的限流两个功能。在之前的dubbo版本中，
负载均衡部分更多的考虑的是公平性原则，即consumer端尽可能平等的从provider中作出选择，在某些情况下表现并不够理想。 限流部分只提供了静态的限流方案，需要用户对provider端设置静态的最大并发值，然而该值的合理选取对用户来讲并不容易。 我们针对这些存在的问题进行了改进。
负载均衡 使用介绍 在原本的dubbo版本中，有五种负载均衡的方案供选择，他们分别是 Random、ShortestResponse、RoundRobin、LeastActive 和 ConsistentHash。其中除 ShortestResponse 和 LeastActive 外，其他的几种方案主要是考虑选择时的公平性和稳定性。
对于 ShortestResponse 来说，其设计目的是从所有备选的 provider 中选择 response 时间最短的以提高系统整体的吞吐量。然而存在两个问题：
在大多数的场景下，不同provider的response时长没有非常明显的区别，此时该算法会退化为随机选择。 response的时间长短有时也并不能代表机器的吞吐能力。对于 LeastActive 来说，其认为应该将流量尽可能分配到当前并发处理任务较少的机器上。但是其同样存在和 ShortestResponse 类似的问题，即这并不能单独代表机器的吞吐能力。 基于以上分析，我们提出了两种新的负载均衡算法。一种是同样基于公平性考虑的单纯 P2C 算法，另一种是基于自适应的方法 adaptive，其试图自适应的衡量 provider 端机器的吞吐能力，然后将流量尽可能分配到吞吐能力高的机器上，以提高系统整体的性能。
总体效果 对于负载均衡部分的有效性实验在两个不同的情况下进行的，分别是提供端机器配置比较均衡和提供端机器配置差距较大的情况。
使用方法 Dubbo Java 实现的使用方法 与原本的负载均衡方法相同。只需要在consumer端将&amp;quot;loadbalance&amp;quot;设置为&amp;quot;p2c&amp;quot;或者&amp;quot;adaptive&amp;quot;即可。
代码结构 负载均衡部分的算法实现只需要在原本负载均衡框架内继承 LoadBalance接口即可。
原理介绍 P2C算法 Power of Two Choice 算法简单但是经典，主要思路如下：
对于每次调用，从可用的provider列表中做两次随机选择，选出两个节点providerA和providerB。 比较providerA和providerB两个节点，选择其“当前正在处理的连接数”较小的那个节点。 adaptive算法 代码的github地址
相关指标 cpuLoad 。该指标在provider端机器获得，并通过invocation的attachment传递给consumer端。
rt rt为一次rpc调用所用的时间，单位为毫秒。
timeout timeout为本次rpc调用超时剩余的时间，单位为毫秒。
weight weight是设置的服务权重。
currentProviderTime provider端在计算cpuLoad时的时间，单位是毫秒
currentTime currentTime为最后一次计算load时的时间，初始化为currentProviderTime，单位是毫秒。
multiple lastLatency beta 平滑参数，默认为0.</description></item><item><title>平安健康的 Dubbo3 迁移历程</title><link>https://dubbo.apache.org/zh-cn/blog/2023/01/15/%E5%B9%B3%E5%AE%89%E5%81%A5%E5%BA%B7%E7%9A%84-dubbo3-%E8%BF%81%E7%A7%BB%E5%8E%86%E7%A8%8B/</link><pubDate>Sun, 15 Jan 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/01/15/%E5%B9%B3%E5%AE%89%E5%81%A5%E5%BA%B7%E7%9A%84-dubbo3-%E8%BF%81%E7%A7%BB%E5%8E%86%E7%A8%8B/</guid><description>1 背景 我们公司从15年开始就使⽤dubbo作为微服务框架，当社区推出dubbo3时，我们也⽴刻跟进并做了深⼊调研，发现dubbo3 的应⽤/实例级服务注册和发现模式能够在一定程度上解决我们当前注册中⼼⾯临的压⼒，解决稳定性和安全性问题。同时dubbo3在服务治理上也做了升级，契合云原⽣架构，⽽且dubbo3能够向下兼容dubbo2，这也将降低升级的成本和⻛险。
升级项目有了阶段性的进展，目前仍然在进行中。通过本⽂，我们对公司内部的Dubbo3 升级过程及收益等做了深⼊总结。
2 Dubbo3 核⼼功能介绍 dubbo社区关于dubbo3的文档和资料越来越完善，以下是我们从社区引用的一些内容。
2.1 下一代云原生服务框架 Dubbo3被社区寄予厚望，将其视为下一代云原生服务框架打造，Dubbo3 提供的核心特性列表，主要包括四部分。
全新服务发现模型 。应用粒度服务发现，面向云原生设计，适配基础设施与异构系统；性能与集群伸缩性大幅提升。 **下一代 **** RPC **协议 Triple 。基于 HTTP/2 的 Triple 协议，兼容 gRPC；网关穿透性强、多语言友好、支持 Reactive Stream。 统一流量治理模型 。面向云原生流量治理，SDK、Mesh、VM、Container 等统一治理规则；能够支持更丰富的流量治理场景。 Service Mesh 。在最新的3.1.0的版本中支持Sidecar Mesh 与 Proxyless Mesh，提供更多架构选择，降低迁移、落地成本。 首先是性能、资源利用率的提升。社区资料显示，升级 Dubbo3 的应用预期能实现单机内存 50% 的下降，对于越大规模的集群效果将越明显，Dubbo3 从架构上支持百万实例级别的集群横向扩展,同时依赖应用级服务发现、Triple协议等可以大大提供应用的服务治理效率和吞吐量。
其次， Dubbo3 让业务架构升级变得更容易、更合理，尤其是RPC协议，在 2.x 版本中，web、移动端与后端的通信都要经过网关代理，完成协议转换、类型映射等工作，dubbo3的Triple 协议让这些变得更容易与自然；并通过流式通信模型满足更多的使用场景。
最后，得益于 Dubbo3 的完善云原生解决方案，Dubbo3的mesh架构可以帮助业务屏蔽底层云原生基础设施细节，让业务更专注于业务，这也是mesh的最根本的优势。
2.2 应用级服务发现核心原理 我们从 Dubbo 最经典的工作原理图说起，Dubbo 从设计之初就内置了服务地址发现的能力，Provider 注册地址到注册中心，Consumer 通过订阅实时获取注册中心的地址更新，在收到地址列表后，consumer 基于特定的负载均衡策略发起对 provider 的 RPC 调用。 在这个过程中
每个 Provider 通过特定的 key 向注册中心注册本机可访问地址； 注册中心通过这个 key 对 provider 实例地址进行聚合； Consumer 通过同样的 key 从注册中心订阅，以便及时收到聚合后的地址列表； 再来看一下Provider向注册中心注册的 URL 地址的详细格式，这里把 URL 地址数据划分成了几份：</description></item><item><title>0-5 - 缓存文件大小超限</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/5/</guid><description>其它模块复用了 Common 层的基于文件的缓存机制（目前是元数据模块），而 Common 层的文件缓存机制 “发觉” 文件大小超限。
可能的原因 用户不合理地配置了 Java System Property （用 -D 配置的 Java 系统属性） dubbo.mapping.cache.maxFileSize 或者 dubbo.meta.cache.maxFileSize 缓存文件因文件系统或磁盘错误而被破坏。 dubbo.mapping.cache.maxFileSize 和 dubbo.meta.cache.maxFileSize 没有显示默认值， 而根据 org.apache.dubbo.common.cache.FileCacheStore.LimitedLengthBufferedWriter 的逻辑而查到的最大文件大小的默认值为：Long.MAX_VALUE ( 263-1 ) 。
排查和解决步骤 尝试重新配置上述 Java System Property（用 -D 配置的 Java 系统属性）。 删除缓存文件夹重启 Provider 和 Consumer （缓存文件夹的位置一般在 ~/.dubbo。如果配置了 dubbo.meta.cache.filePath 和 dubbo.mapping.cache.filePath 则为该路径）。 如果确实没有配置这些 System Property，请到 GitHub Issue Tracker 下发 Issue。</description></item><item><title>1-5 - 接收到没有任何参数的 URL</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/5/</guid><description>可能的原因 在调用 CacheableFailbackRegistry.toUrlsWithoutEmpty 时，若传入的参数 Collection&amp;lt;String&amp;gt;providers 中存在某个 provider 其没有任何参数的话，就会接收到没有任何参数的 URL。
排查和解决步骤 该错误为 Dubbo 内部错误，如果您遇到可以在 github 创建 Issue 并提供错误信息以及复现步骤，我们将协助您解决问题。
另请参阅 Dubbo社区</description></item><item><title>2-5 - 筛选提供方失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/5/</guid><description>可能的原因 Dubbo 在负载均衡时会从提供方列表中最终选择一个提供方发起调用，在选择过程中提供方列表变动，发生读写冲突，导致筛选异常。 Dubbo 重试机制在调用提供方失败时，会重新筛选另一个提供方发起调用，重新筛选过程发生异常。 排查和解决步骤 检查注册中心提供方列表，与对应提供方可用性。 在社区提 Issue，提供环境现场信息及复现步骤。</description></item><item><title>3-5 - 异步响应出现异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/3/5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/3/5/</guid><description>可能的原因 业务逻辑确实出现运行时异常。 网络原因，连接被拒绝。 排查和解决步骤 业务代码请根据堆栈提示行，回溯定位排查。 检查服务提供方的网络是否正常。</description></item><item><title>4-5 - 流关闭异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/5/</guid><description>可能的原因 提示信息，不影响程序的执行结果。
排查和解决步骤 可通过一些第三方的工具或者jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>5-5 - 无法获得env变量</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/5/</guid><description>可能的原因 环境变量无法获取。
排查和解决步骤 检查提示的变量名，是否配置并可以正常读取加载。</description></item><item><title>6-5 - 网络连接断开失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/5/</guid><description>可能的原因 超时是调用端发生在请求发出后，无法在指定的时间内获得对应的响应，出现客户端主动断开连接
排查和解决步骤 一般为提示类警告信息，不影响后续的程序执行。</description></item><item><title>7-5 - QOS 命令未找到</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/7/5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/7/5/</guid><description>可能的原因 QOS 命令拼写错误。
排查和解决步骤 QOS 命令不存在。
请参考 QOS 操作手册基础命令手册。</description></item><item><title>Avro</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/dubbo/avro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/dubbo/avro/</guid><description>1 介绍 Avro是一种远程过程调用和数据序列化框架，是在Apache的Hadoop项目之内开发的。它使用JSON来定义数据类型和通讯协议，使用压缩二进制格式来序列化数据。它主要用于Hadoop，它可以为持久化数据提供一种序列化格式，并为Hadoop节点间及从客户端程序到Hadoop服务的通讯提供一种电报格式。
2 使用方式 2.1 添加依赖 &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-serialization-avro&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.avro&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;avro&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.11.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 2.2 配置启用 # application.yml (Spring Boot) dubbo: protocol: serialization: avro 或
# dubbo.properties dubbo.protocol.serialization=avro # or dubbo.consumer.serialization=avro # or dubbo.reference.com.demo.DemoService.serialization=avro 或
&amp;lt;dubbo:protocol serialization=&amp;#34;avro&amp;#34; /&amp;gt; &amp;lt;!-- or --&amp;gt; &amp;lt;dubbo:consumer serialization=&amp;#34;avro&amp;#34; /&amp;gt; &amp;lt;!-- or --&amp;gt; &amp;lt;dubbo:reference interface=&amp;#34;xxx&amp;#34; serialization=&amp;#34;avro&amp;#34; /&amp;gt;</description></item><item><title>Consul</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/others/consul/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/others/consul/</guid><description>前置条件 了解 Dubbo 基本开发步骤 安装并启动 Consul 服务 使用说明 添加依赖 从 Dubbo3 开始，consul 注册中国适配已经不再内嵌在 Dubbo 中，使用前需要单独引入独立的模块。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-registry-consul&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 基本配置 &amp;lt;dubbo:registry address=&amp;#34;redis://10.20.153.10:6379&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:registry address=&amp;#34;redis://10.20.153.10:6379?backup=10.20.153.11:6379,10.20.153.12:6379&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:registry protocol=&amp;#34;redis&amp;#34; address=&amp;#34;10.20.153.10:6379&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:registry protocol=&amp;#34;redis&amp;#34; address=&amp;#34;10.20.153.10:6379,10.20.153.11:6379,10.20.153.12:6379&amp;#34; /&amp;gt; 使用场景 使用 Consul 作为共享注册中心实现，可用于 Dubbo 与 Spring Cloud 体系的互通或迁移</description></item><item><title>Etcd</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/others/etcd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/others/etcd/</guid><description>前置条件 了解 Dubbo 基本开发步骤 安装并启动 Etcd 服务 使用说明 添加依赖 从 Dubbo3 开始，etcd 注册中心适配已经不再内嵌在 Dubbo 中，使用前需要单独引入独立的模块。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-registry-etcd&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 基本配置 &amp;lt;dubbo:registry address=&amp;#34;etcd://10.20.153.10:6379&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:registry address=&amp;#34;etcd://10.20.153.10:6379?backup=10.20.153.11:6379,10.20.153.12:6379&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:registry protocol=&amp;#34;etcd&amp;#34; address=&amp;#34;10.20.153.10:6379&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:registry protocol=&amp;#34;etcd&amp;#34; address=&amp;#34;10.20.153.10:6379,10.20.153.11:6379,10.20.153.12:6379&amp;#34; /&amp;gt;</description></item><item><title>gRPC 协议</title><link>https://dubbo.apache.org/zh-cn/docs/references/protocols/grpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/protocols/grpc/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo 自 2.7.5 版本开始支持 gRPC 协议，对于计划使用 HTTP/2 通信，或者想利用 gRPC 带来的 Stream、反压、Reactive 编程等能力的开发者来说， 都可以考虑启用 gRPC 协议。
支持 gRPC 的好处 为期望使用 gRPC 协议的用户带来服务治理能力，方便接入 Dubbo 体系 用户可以使用 Dubbo 风格的，基于接口的编程风格来定义和使用远程服务 如何在 Dubbo 中使用 gRPC 大概需要以下步骤：
使用 IDL 定义服务 配置 compiler 插件，本地预编译 配置暴露/引用 Dubbo 服务 具体可参见以下示例
除了原生 StreamObserver 接口类型之外，Dubbo 还支持 RxJava、Reactor 编程风格的 API</description></item><item><title>gRPC 协议</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/grpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/grpc/</guid><description>Dubbo 自 2.7.5 版本开始支持 gRPC 协议，对于计划使用 HTTP/2 通信，或者想利用 gRPC 带来的 Stream、反压、Reactive 编程等能力的开发者来说， 都可以考虑启用 gRPC 协议。
支持 gRPC 的好处 为期望使用 gRPC 协议的用户带来服务治理能力，方便接入 Dubbo 体系 用户可以使用 Dubbo 风格的，基于接口的编程风格来定义和使用远程服务 如何在 Dubbo 中使用 gRPC 大概需要以下步骤：
使用 IDL 定义服务 配置 compiler 插件，本地预编译 配置暴露/引用 Dubbo 服务 具体可参见以下示例
除了原生 StreamObserver 接口类型之外，Dubbo 还支持 RxJava、Reactor 编程风格的 API</description></item><item><title>memcached 协议</title><link>https://dubbo.apache.org/zh-cn/docs/references/protocols/memcached/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/protocols/memcached/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
基于 memcached 1 实现的 RPC 协议。
提示 2.3.0 以上版本支持 注册 memcached 服务的地址 RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(&amp;#34;zookeeper://10.20.153.10:2181&amp;#34;)); registry.register(URL.valueOf(&amp;#34;memcached://10.20.153.11/com.foo.BarService?category=providers&amp;amp;dynamic=false&amp;amp;application=foo&amp;amp;group=member&amp;amp;loadbalance=consistenthash&amp;#34;)); 在客户端引用 在客户端使用 2：
&amp;lt;dubbo:reference id=&amp;#34;cache&amp;#34; interface=&amp;#34;java.util.Map&amp;#34; group=&amp;#34;member&amp;#34; /&amp;gt; 或者，点对点直连：
&amp;lt;dubbo:reference id=&amp;#34;cache&amp;#34; interface=&amp;#34;java.util.Map&amp;#34; url=&amp;#34;memcached://10.20.153.10:11211&amp;#34; /&amp;gt; 也可以使用自定义接口：
&amp;lt;dubbo:reference id=&amp;#34;cache&amp;#34; interface=&amp;#34;com.foo.CacheService&amp;#34; url=&amp;#34;memcached://10.20.153.10:11211&amp;#34; /&amp;gt; 方法名建议和 memcached 的标准方法名相同，即：get(key), set(key, value), delete(key)。
如果方法名和 memcached 的标准方法名不相同，则需要配置映射关系 3：
&amp;lt;dubbo:reference id=&amp;#34;cache&amp;#34; interface=&amp;#34;com.foo.CacheService&amp;#34; url=&amp;#34;memcached://10.20.153.10:11211&amp;#34; p:set=&amp;#34;putFoo&amp;#34; p:get=&amp;#34;getFoo&amp;#34; p:delete=&amp;#34;removeFoo&amp;#34; /&amp;gt; Memcached 是一个高效的 KV 缓存服务器&amp;#160;&amp;#x21a9;&amp;#xfe0e;
不需要感知 Memcached 的地址&amp;#160;&amp;#x21a9;&amp;#xfe0e;
其中 &amp;ldquo;p:xxx&amp;rdquo; 为 spring 的标准 p 标签&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>memcached 协议</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/memcached/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/memcached/</guid><description>基于 memcached 1 实现的 RPC 协议。
提示 2.3.0 以上版本支持 注册 memcached 服务的地址 RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(&amp;#34;zookeeper://10.20.153.10:2181&amp;#34;)); registry.register(URL.valueOf(&amp;#34;memcached://10.20.153.11/com.foo.BarService?category=providers&amp;amp;dynamic=false&amp;amp;application=foo&amp;amp;group=member&amp;amp;loadbalance=consistenthash&amp;#34;)); 在客户端引用 在客户端使用 2：
&amp;lt;dubbo:reference id=&amp;#34;cache&amp;#34; interface=&amp;#34;java.util.Map&amp;#34; group=&amp;#34;member&amp;#34; /&amp;gt; 或者，点对点直连：
&amp;lt;dubbo:reference id=&amp;#34;cache&amp;#34; interface=&amp;#34;java.util.Map&amp;#34; url=&amp;#34;memcached://10.20.153.10:11211&amp;#34; /&amp;gt; 也可以使用自定义接口：
&amp;lt;dubbo:reference id=&amp;#34;cache&amp;#34; interface=&amp;#34;com.foo.CacheService&amp;#34; url=&amp;#34;memcached://10.20.153.10:11211&amp;#34; /&amp;gt; 方法名建议和 memcached 的标准方法名相同，即：get(key), set(key, value), delete(key)。
如果方法名和 memcached 的标准方法名不相同，则需要配置映射关系 3：
&amp;lt;dubbo:reference id=&amp;#34;cache&amp;#34; interface=&amp;#34;com.foo.CacheService&amp;#34; url=&amp;#34;memcached://10.20.153.10:11211&amp;#34; p:set=&amp;#34;putFoo&amp;#34; p:get=&amp;#34;getFoo&amp;#34; p:delete=&amp;#34;removeFoo&amp;#34; /&amp;gt; Memcached 是一个高效的 KV 缓存服务器&amp;#160;&amp;#x21a9;&amp;#xfe0e;
不需要感知 Memcached 的地址&amp;#160;&amp;#x21a9;&amp;#xfe0e;
其中 &amp;ldquo;p:xxx&amp;rdquo; 为 spring 的标准 p 标签&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>Nacos</title><link>https://dubbo.apache.org/zh-cn/overview/reference/integrations/nacos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/integrations/nacos/</guid><description>本文档讲解如何安装与配置 Nacos，涵盖本地、docker、kubernetes 等环境。以下仅为快速示例安装指南，如想搭建生产可用集群请参考 Nacos 官方文档。
本地下载 Nacos 依赖 Java 环境 来运行，目前支持 Linux、MacOS、Windows 等环境。
您可以 下载最新稳定版本 Nacos，解压缩二进制包：
unzip nacos-server-$version.zip cd nacos/bin #tar -xvf nacos-server-$version.tar.gz 启动命令 # Linux/Unix/Mac sh startup.sh -m standalone # Ubuntu bash startup.sh -m standalone # Windows startup.cmd -m standalone 验证 nacos 正常启动 通过浏览器访问以下链接打开控制台：http://127.0.0.1:8848/nacos/
docker 使用 docker 启动 nacos，请首先确保您已经在本地机器正确 下载页面 安装 docker。
docker run --name nacos-quick -e MODE=standalone -p 8849:8848 -d nacos/nacos-server:2.3.1 kubernetes 请参考 nacos-operator 了解如何部署 Nacos 到 Kubernetes 集群。</description></item><item><title>Redis</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/others/redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/others/redis/</guid><description>前置条件 了解 Dubbo 基本开发步骤 安装并启动 Redis 服务 使用说明 添加依赖 从 Dubbo3 开始，redis 注册中心适配已经不再内嵌在 Dubbo 中，使用前需要单独引入独立的模块。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-registry-redis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 基本配置 &amp;lt;dubbo:registry address=&amp;#34;redis://10.20.153.10:6379&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:registry address=&amp;#34;redis://10.20.153.10:6379?backup=10.20.153.11:6379,10.20.153.12:6379&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:registry protocol=&amp;#34;redis&amp;#34; address=&amp;#34;10.20.153.10:6379&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:registry protocol=&amp;#34;redis&amp;#34; address=&amp;#34;10.20.153.10:6379,10.20.153.11:6379,10.20.153.12:6379&amp;#34; /&amp;gt; 其他配置项 可通过 &amp;lt;dubbo:registry group=&amp;quot;dubbo&amp;quot; /&amp;gt; 设置 redis 中 key 的前缀，缺省为 dubbo。 可通过 &amp;lt;dubbo:registry cluster=&amp;quot;replicate&amp;quot; /&amp;gt; 设置 redis 集群策略，缺省为 failover： failover: 只写入和读取任意一台，失败时重试另一台，需要服务器端自行配置数据同步 replicate: 在客户端同时写入所有服务器，只读取单台，服务器端不需要同步，注册中心集群增大，性能压力也会更大 工作原理 基于 Redis [^1] 实现的注册中心。
Redis 过期数据通过心跳的方式检测脏数据，服务器时间必须同步，并且对服务器有一定压力，否则过期检测会不准确
使用 Redis 的 Key/Map 结构存储数据结构：</description></item><item><title>rmi 协议</title><link>https://dubbo.apache.org/zh-cn/docs/references/protocols/rmi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/protocols/rmi/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
RMI 协议采用 JDK 标准的 java.rmi.* 实现，采用阻塞式短连接和 JDK 标准序列化方式。
注意：如果正在使用 RMI 提供服务给外部访问 1，同时应用里依赖了老的 common-collections 包 2 的情况下，存在反序列化安全风险 3。
特性 连接个数：多连接 连接方式：短连接 传输协议：TCP 传输方式：同步传输 序列化：Java 标准二进制序列化 适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。 适用场景：常规远程服务方法调用，与原生RMI服务互操作 约束 参数及返回值需实现 Serializable 接口 dubbo 配置中的超时时间对 RMI 无效，需使用 java 启动参数设置：-Dsun.rmi.transport.tcp.responseTimeout=3000，参见下面的 RMI 配置 RMI配置 java -Dsun.rmi.transport.tcp.responseTimeout=3000 更多 RMI 优化参数请查看 JDK 文档
接口 如果服务接口继承了 java.rmi.Remote 接口，可以和原生 RMI 互操作，即：
提供者用 Dubbo 的 RMI 协议暴露服务，消费者直接用标准 RMI 接口调用， 或者提供方用标准 RMI 暴露服务，消费方用 Dubbo 的 RMI 协议调用。 如果服务接口没有继承 java.rmi.Remote 接口：</description></item><item><title>rmi 协议</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/rmi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/rmi/</guid><description>RMI 协议采用 JDK 标准的 java.rmi.* 实现，采用阻塞式短连接和 JDK 标准序列化方式。
注意：如果正在使用 RMI 提供服务给外部访问 1，同时应用里依赖了老的 common-collections 包 2 的情况下，存在反序列化安全风险 3。
特性 连接个数：多连接 连接方式：短连接 传输协议：TCP 传输方式：同步传输 序列化：Java 标准二进制序列化 适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。 适用场景：常规远程服务方法调用，与原生RMI服务互操作 约束 参数及返回值需实现 Serializable 接口 dubbo 配置中的超时时间对 RMI 无效，需使用 java 启动参数设置：-Dsun.rmi.transport.tcp.responseTimeout=3000，参见下面的 RMI 配置 dubbo.properties 配置 dubbo.service.protocol=rmi RMI配置 java -Dsun.rmi.transport.tcp.responseTimeout=3000 更多 RMI 优化参数请查看 JDK 文档
接口 如果服务接口继承了 java.rmi.Remote 接口，可以和原生 RMI 互操作，即：
提供者用 Dubbo 的 RMI 协议暴露服务，消费者直接用标准 RMI 接口调用， 或者提供方用标准 RMI 暴露服务，消费方用 Dubbo 的 RMI 协议调用。 如果服务接口没有继承 java.</description></item><item><title>Simple 监控中心安装</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/admin/install/monitor-center/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/admin/install/monitor-center/</guid><description>不再单独提供监控中心，功能会整合到运维控制台，基于Metrics提供更丰富，实时的信息展示，敬请期待</description></item><item><title>Triple 3.3新特性</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/triple-3.3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/triple-3.3/</guid><description>全新的 Rest 支持 特性 在3.3版本中，基于现有 HTTP 协议栈，triple实现了全面的 REST 风格服务导出能力，无需使用泛化或网关层协议转换，无需配置，用户即可通过 HTTP 协议去中心化直接访问后端的 Triple 协议服务。同时，针对高级 REST 用法，如路径定制、输出格式定制和异常处理，提供了丰富的注解和 SPI 扩展支持。其主要特性包括：
Triple协议融合
重用Triple原有HTTP协议栈， 无需额外配置或新增端口，即可同时支持 HTTP/1、HTTP/2 和 HTTP/3 协议的访问。 去中心化
可直接对外暴露 Rest API，不再依赖网关应用进行流量转发，从而提升性能，并降低因网关引发的稳定性风险。安全问题可通过应用内部扩展解决，这一实践已在淘宝内部的 MTOP 中得到验证。 支持已有servlet设施
支持 Servlet API 和 Filter，用户可以重用现有基于 Servlet API 的安全组件。通过实现一个 Servlet Filter，即可集成 OAuth 和 Spring Security 等安全框架。 多种方言
考虑到大部分用户习惯使用 SpringMVC 或 JAX-RS 进行 REST API 开发，Triple Rest 允许继续沿用这些方式定义服务，并支持大部分扩展和异常处理机制（具备原框架 80% 以上的功能）。对于追求轻量级的用户，可使用 Basic 方言，Triple 的开箱即用 REST 访问能力即基于此方言导出服务。 扩展能力强
提供超过 20 个 扩展点，用户不仅可以轻松实现自定义方言，还能灵活定制参数获取、类型转换、错误处理等逻辑。 开箱即用</description></item><item><title>webservice 协议</title><link>https://dubbo.apache.org/zh-cn/docs/references/protocols/webservice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/protocols/webservice/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
基于 WebService 的远程调用协议，基于 Apache CXF 1 的 frontend-simple 和 transports-http 实现。
提示 2.3.0 以上版本支持 可以和原生 WebService 服务互操作，即：
提供者用 Dubbo 的 WebService 协议暴露服务，消费者直接用标准 WebService 接口调用， 或者提供方用标准 WebService 暴露服务，消费方用 Dubbo 的 WebService 协议调用。 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.cxf&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;cxf-rt-frontend-simple&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.6.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.cxf&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;cxf-rt-transports-http&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.6.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 特性 连接个数：多连接 连接方式：短连接 传输协议：HTTP 传输方式：同步传输 序列化：SOAP 文本序列化 适用场景：系统集成，跨语言调用 约束 参数及返回值需实现 Serializable 接口 参数尽量使用基本类型和 POJO 配置 配置协议：
&amp;lt;dubbo:protocol name=&amp;#34;webservice&amp;#34; port=&amp;#34;8080&amp;#34; server=&amp;#34;jetty&amp;#34; /&amp;gt; 配置默认协议：
&amp;lt;dubbo:provider protocol=&amp;#34;webservice&amp;#34; /&amp;gt; 配置服务协议：</description></item><item><title>webservice 协议</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/webservice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/protocol/webservice/</guid><description>基于 WebService 的远程调用协议，基于 Apache CXF 1 的 frontend-simple 和 transports-http 实现。
提示 2.3.0 以上版本支持 可以和原生 WebService 服务互操作，即：
提供者用 Dubbo 的 WebService 协议暴露服务，消费者直接用标准 WebService 接口调用， 或者提供方用标准 WebService 暴露服务，消费方用 Dubbo 的 WebService 协议调用。 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.cxf&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;cxf-rt-frontend-simple&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.6.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.cxf&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;cxf-rt-transports-http&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.6.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 特性 连接个数：多连接 连接方式：短连接 传输协议：HTTP 传输方式：同步传输 序列化：SOAP 文本序列化 适用场景：系统集成，跨语言调用 约束 参数及返回值需实现 Serializable 接口 参数尽量使用基本类型和 POJO 配置 配置协议：
&amp;lt;dubbo:protocol name=&amp;#34;webservice&amp;#34; port=&amp;#34;8080&amp;#34; server=&amp;#34;jetty&amp;#34; /&amp;gt; 配置默认协议：
&amp;lt;dubbo:provider protocol=&amp;#34;webservice&amp;#34; /&amp;gt; 配置服务协议：
&amp;lt;dubbo:service protocol=&amp;#34;webservice&amp;#34; /&amp;gt; 多端口：</description></item><item><title>部署架构（注册中心 配置中心 元数据中心）</title><link>https://dubbo.apache.org/zh-cn/docs/concepts/registry-configcenter-metadata/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/concepts/registry-configcenter-metadata/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
作为一个微服务框架，Dubbo sdk 跟随着微服务组件被部署在分布式集群各个位置，为了在分布式环境下实现各个微服务组件间的协作， Dubbo 定义了一些中心化组件，这包括：
注册中心。协调 Consumer 与 Provider 之间的地址注册与发现 配置中心。 存储 Dubbo 启动阶段的全局配置，保证配置的跨环境共享与全局一致性 负责服务治理规则（路由规则、动态配置等）的存储与推送。 元数据中心。 接收 Provider 上报的服务接口元数据，为 Admin 等控制台提供运维能力（如服务测试、接口文档等） 作为服务发现机制的补充，提供额外的接口/方法级别配置信息的同步能力，相当于注册中心的额外扩展 上图完整的描述了 Dubbo 微服务组件与各个中心的交互过程。
以上三个中心并不是运行 Dubbo 的必要条件，用户完全可以根据自身业务情况决定只启用其中一个或多个，以达到简化部署的目的。通常情况下，所有用户都会以独立的注册中心 开始 Dubbo 服务开发，而配置中心、元数据中心则会在微服务演进的过程中逐步的按需被引入进来。
注册中心 注册中心扮演着非常重要的角色，它承载着服务注册和服务发现的职责。目前Dubbo支持以下两种粒度的服务发现和服务注册，分别是接口级别和应用级别，注册中心可以按需进行部署：
在传统的Dubbo SDK使用姿势中，如果仅仅提供直连模式的RPC服务，不需要部署注册中心。
无论是接口级别还是应用级别，如果需要Dubbo SDK自身来做服务注册和服务发现，则可以选择部署注册中心，在Dubbo中集成对应的注册中心。
在Dubbo + Mesh 的场景下，随着 Dubbo 服务注册能力的弱化，Dubbo内的注册中心也不再是必选项，其职责开始被控制面取代，如果采用了Dubbo + Mesh的部署方式，无论是ThinSDK的mesh方式还是Proxyless的mesh方式，都不再需要独立部署注册中心。
而注册中心并不依赖于配置中心和元数据中心，如下图所示：
该图中没有部署配置中心和元数据中心，在Dubbo中会默认将注册中心的实例同时作为配置中心和元数据中心，这是Dubbo的默认行为，如果确实不需要配置中心或者元数据中心的能力，可在配置中关闭，在注册中心的配置中有两个配置分别为use-as-config-center和use-as-metadata-center，将配置置为false即可。
元数据中心 元数据中心在2.7.x版本开始支持，随着应用级别的服务注册和服务发现在Dubbo中落地，元数据中心也变的越来越重要。在以下几种情况下会需要部署元数据中心：
对于一个原先采用老版本Dubbo搭建的应用服务，在迁移到Dubbo 3时，Dubbo 3 会需要一个元数据中心来维护RPC服务与应用的映射关系（即接口与应用的映射关系），因为如果采用了应用级别的服务发现和服务注册，在注册中心中将采用“应用 —— 实例列表”结构的数据组织形式，不再是以往的“接口 —— 实例列表”结构的数据组织形式，而以往用接口级别的服务注册和服务发现的应用服务在迁移到应用级别时，得不到接口与应用之间的对应关系，从而无法从注册中心得到实例列表信息，所以Dubbo为了兼容这种场景，在Provider端启动时，会往元数据中心存储接口与应用的映射关系。 为了让注册中心更加聚焦与地址的发现和推送能力，减轻注册中心的负担，元数据中心承载了所有的服务元数据、大量接口/方法级别配置信息等，无论是接口粒度还是应用粒度的服务发现和注册，元数据中心都起到了重要的作用。 如果有以上两种需求，都可以选择部署元数据中心，并通过Dubbo的配置来集成该元数据中心。
元数据中心并不依赖于注册中心和配置中心，用户可以自由选择是否集成和部署元数据中心，如下图所示：
该图中不配备配置中心，意味着可以不需要全局管理配置的能力。该图中不配备注册中心，意味着可能采用了Dubbo mesh的方案，也可能不需要进行服务注册，仅仅接收直连模式的服务调用。
配置中心 配置中心与其他两大中心不同，它无关于接口级还是应用级，它与接口并没有对应关系，它仅仅与配置数据有关，即使没有部署注册中心和元数据中心，配置中心也能直接被接入到Dubbo应用服务中。在整个部署架构中，整个集群内的实例（无论是Provider还是Consumer）都将会共享该配置中心集群中的配置，如下图所示： 该图中不配备注册中心，意味着可能采用了Dubbo mesh的方案，也可能不需要进行服务注册，仅仅接收直连模式的服务调用。
该图中不配备元数据中心，意味着Consumer可以从Provider暴露的MetadataService获取服务元数据，从而实现RPC调用
保证三大中心高可用的部署架构 虽然三大中心已不再是Dubbo应用服务所必须的，但是在真实的生产环境中，一旦已经集成并且部署了该三大中心，三大中心还是会面临可用性问题，Dubbo需要支持三大中心的高可用方案。在Dubbo中就支持多注册中心、多元数据中心、多配置中心，来满足同城多活、两地三中心、异地多活等部署架构模式的需求。</description></item><item><title>调用链路传递隐式参数</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/attachment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/attachment/</guid><description>在不修改方法签名与参数定义的情况下，可以通过 RpcContext 上的 setAttachment 和 getAttachment 在服务消费方和提供方之间进行参数的隐式传递。隐式参数传递支持以下两个方向：
从消费方到提供方，也就是在请求发起时，在方法参数之外通过 attachment 传递附加参数。 从提供方到消费方，也就是在响应结果返回时，在响应结果之外通过 attachment 传递附加参数。 理解隐式参数传递的最直接方式 http header，它的工作方式与 http header 完全一致，在 GET 或 POST 请求体之外可以传递任意多个 header 参数。在实现原理上，对于不同的协议，attachment 的实现方式略有不同：
对于 triple 协议，attachment 会转换为标准的 http header 进行传输。 对于 dubbo 协议，attachment 是编码在协议体的固定位置进行传输，具体请参见 dubbo 协议规范。 注意 在使用 triple 协议时，由于 http header 的限制，仅支持小写的 ascii 字符 path, group, version, dubbo, token, timeout 一些 key 是保留字段，传递 attachment 时应避免使用，尽量通过业务前缀等确保 key 的唯一性。 消费端隐式参数 本文示例完整源码可在以下链接查看 dubbo-samples-attachment
设置隐式参数 RpcContext.getClientAttachment().setAttachment(&amp;#34;index&amp;#34;, &amp;#34;1&amp;#34;); // 隐式传参，后面的远程调用都会隐式将这些参数发送到服务器端，类似cookie，比如用于框架集成 xxxService.xxx(); // 远程调用 // .</description></item><item><title>使用 Dubbo 开发 gRPC 服务</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/triple/grpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/protocols/triple/grpc/</guid><description>这个示例演示了如何使用 triple 协议实现 Dubbo 服务与标准 gRPC 服务的互相调用，可在此查看 示例完整源码
就像在 Triple协议规范 中所描述的，triple 协议与 gRPC 协议保持 100% 兼容，同时在易用性方面有了非常大的提升（比如支持 cURL、浏览器直接访问等），可以说 triple 是一个更好用的 gRPC 设计与实现。
运行示例 首先，可通过以下命令下载示例源码
git clone --depth=1 https://github.com/apache/dubbo-samples.git 进入示例源码目录：
cd dubbo-samples/2-advanced/dubbo-samples-triple-grpc 接下来，我们分别从 dubbo 调用 grpc、grpc 调用 dubbo 两个不同的方向，看一下如何基于 triple 协议实现互调。
作为标准的 gRPC Server 在这一部分，我们会发布一个 Dubbo Triple Server，然后启动一个标准的 gRPC 消费端（示例采用谷歌官方发布的 grpc-java 编码）来调用 Triple 服务。
启动 Dubbo server 确保你在 dubbo-samples-triple-grpc 目录，运行以下命令：
$ mvn compile exec:java -Dexec.mainClass=&amp;#34;org.apache.dubbo.samples.tri.grpc.interop.server.TriOpServer&amp;#34; 使用标准 gRPC client 调用 Triple 服务 打开一个新的终端，在 dubbo-samples-triple-grpc 目录运行以下命令：</description></item><item><title>服务调用过程</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/service-invoking-process/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/service-invoking-process/</guid><description>1. 简介 在前面的文章中，我们分析了 Dubbo SPI、服务导出与引入、以及集群容错方面的代码。经过前文的铺垫，本篇文章我们终于可以分析服务调用过程了。Dubbo 服务调用过程比较复杂，包含众多步骤，比如发送请求、编解码、服务降级、过滤器链处理、序列化、线程派发以及响应请求等步骤。限于篇幅原因，本篇文章无法对所有的步骤一一进行分析。本篇文章将会重点分析请求的发送与接收、编解码、线程派发以及响应的发送与接收等过程，至于服务降级、过滤器链和序列化大家自行进行分析，也可以将其当成一个黑盒，暂时忽略也没关系。介绍完本篇文章要分析的内容，接下来我们进入正题吧。
2. 源码分析 在进行源码分析之前，我们先来通过一张图了解 Dubbo 服务调用过程。
首先服务消费者通过代理对象 Proxy 发起远程调用，接着通过网络客户端 Client 将编码后的请求发送给服务提供方的网络层上，也就是 Server。Server 在收到请求后，首先要做的事情是对数据包进行解码。然后将解码后的请求发送至分发器 Dispatcher，再由分发器将请求派发到指定的线程池上，最后由线程池调用具体的服务。这就是一个远程调用请求的发送与接收过程。至于响应的发送与接收过程，这张图中没有表现出来。对于这两个过程，我们也会进行详细分析。
2.1 服务调用方式 Dubbo 支持同步和异步两种调用方式，其中异步调用还可细分为“有返回值”的异步调用和“无返回值”的异步调用。所谓“无返回值”异步调用是指服务消费方只管调用，但不关心调用结果，此时 Dubbo 会直接返回一个空的 RpcResult。若要使用异步特性，需要服务消费方手动进行配置。默认情况下，Dubbo 使用同步调用方式。
本节以及其他章节将会使用 Dubbo 官方提供的 Demo 分析整个调用过程，下面我们从 DemoService 接口的代理类开始进行分析。Dubbo 默认使用 Javassist 框架为服务接口生成动态代理类，因此我们需要先将代理类进行反编译才能看到源码。这里使用阿里开源 Java 应用诊断工具 Arthas 反编译代理类，结果如下：
/** * Arthas 反编译步骤： * 1. 启动 Arthas * java -jar arthas-boot.jar * * 2. 输入编号选择进程 * Arthas 启动后，会打印 Java 应用进程列表，如下： * [1]: 11232 org.jetbrains.jps.cmdline.Launcher * [2]: 22370 org.jetbrains.jps.cmdline.Launcher * [3]: 22371 com.</description></item><item><title>官方 Dubbo 主页的维护</title><link>https://dubbo.apache.org/zh-cn/contact/committer/apache-dubbo-page_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/contact/committer/apache-dubbo-page_dev/</guid><description>Apache 有一个官方的网站，用来维护所有的孵化项目的信息。每一个孵化项目在这个网站下都有一个信息页。 Dubbo 的信息页地址是 https://incubator.apache.org/projects/dubbo.html。
当项目发生比较大的变化，比如新的 committer 的加入，新的 PMC 的当选，或是新版本的 Release 等，都需要将这些更新信息维护到这个页面。
这个官方网站的项目地址是https://svn.apache.org/repos/asf/incubator/public/trunk。
维护这个页面的方法如下：
1.安装 SVN。若是 Mac OS X 系统或是 Linux 系统，则自带了 SVN。若是 Windows 系统，则请首先自行安装 SVN。
2.用 SVN 将这个项目 checkout 下来 。
3.修改 content/projects/dubbo.xml 文件，并保存。
4.安装 ANT。执行 trunk 目录下的 build.sh 或者 build.bat 脚本构建项目。
5.构建完成后，可以用浏览器打开 target/site/projects/dubbo.html 文件，预览修改是否生效。
6.用 SVN 的 commit 命令将 dubbo.xml 文件提交到服务器，并且不要提交 dubbo.html 文件（因为服务器端会定时自动构建）。 此过程会要求输入Apache id和密码。
参考:
http://incubator.apache.org/guides/website.html https://svn.apache.org/repos/asf/incubator/public/trunk/README.txt</description></item><item><title>通过标签实现流量隔离环境（灰度、多套开发环境等）</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/isolation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/isolation/</guid><description>无论是在日常开发测试环境，还是在预发生产环境，我们经常都会遇到流量隔离环境的需求。
在日常开发中，为了避免开发测试过程中互相干扰，我们有搭建多套独立测试环境的需求，但通过搭建物理集群的方式成本非常高且不够灵活 在生产发布过程中，为了保障新版本得到充分的验证，我们需要搭建一套完全隔离的线上灰度环境用来部署新版本服务，线上灰度环境能完全模拟生产运行情况，但只有固定的带有特定标记的线上流量会被导流到灰度环境，充分验证新版本的同时将线上变更风险降到最低。 利用 Dubbo 提供的标签路由能力，可以非常灵活的实现流量隔离能力。可以单独为集群中的某一个或多个应用划分隔离环境，也可以为整个微服务集群划分隔离环境；可以在部署态静态的标记隔离环境，也可以在运行态通过规则动态的隔离出一部分机器环境。
注意：标签路由是一套严格隔离的流量体系，对于同一个应用而言，一旦打了标签则这部分地址子集就被隔离出来，只有带有对应标签的请求流量可以访问这个地址子集，这部分地址不再接收没有标签或者具有不同标签的流量。举个例子，如果我们将一个应用进行打标，打标后划分为 tag-a、tag-b、无 tag 三个地址子集，则访问这个应用的流量，要么路由到 tag-a (当请求上下文 dubbo.tag=tag-a)，要么路由到 tag-b (dubbo.tag=tag-b)，或者路由到无 tag 的地址子集 (dubbo.tag 未设置)，不会出现混调的情况。
开始之前 部署 Shop 商城项目 部署并打开 Dubbo Admin 任务详情 我们决定为商城系统建立一套完整的线上灰度验证环境，灰度环境和线上环境共享一套物理集群，需要我们通过 Dubbo 标签路由从逻辑上完全隔离出一套环境，做到灰度流量和线上流量互不干扰。
为商城搭建一套完全隔离的灰度环境 首先，为 User、Detail、Comment、Order 几个应用都部署灰度环境实例，我们为这部分实例都带有 env=gray 的环境标。部署可以通过以下命令快速完成
kubectl apply -f https://raw.githubusercontent.com/apache/dubbo-samples/master/10-task/dubbo-samples-shop/deploy/Gray.yml 如何为机器或实例打标？ 方法一：通过 dubbo.labels 或 DUBBO_LABELS 指定需要增加到 URL 中的键值对。
# JVM 参数 -Ddubbo.labels = &amp;#34;tag1=value1; tag2=value2&amp;#34; # 环境变量 DUBBO_LABELS = &amp;#34;tag1=value1; tag2=value2&amp;#34; 最终生成的 URL 会包含 tag1、tag2 两个 key: dubbo://xxx?tag1=value1&amp;amp;tag2=value2
方法二：通过 dubbo.env.keys 或 DUBBO_ENV_KEYS 指定要加载的环境变量，Dubbo 会尝试从环境变量加载每个 key。</description></item><item><title>基于条件的流量路由</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/route/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/route/</guid><description>路由是 Dubbo 中的核心流量管控机制， 我们可以基于它实现金丝雀发布、按比例流量转发、同区域优先、全链路灰度等流量策略。Dubbo 中路由（Router）机制的设计与基本原理，内置的几种路由规则
常用流量管控场景 Dubbo 内置的流量策略非常的灵活，但同时也有一定的理解与使用成本，因此，我们根据总结了一些常用的使用场景，并给出了配置方法：
场景 效果 作用对象 说明 超时时间 访问日志 调用重试 接下来，我们就以一个条件路由为例，来看一下如何使用 Dubbo 流量管控机制。
一个条件路由示例 需求非常的直观明了。
匹配这个条件的流量，转发到这一批机器 匹配另一个条件的流量，转发到另一批机器 这在 Dubbo 中就是用 条件路由 来实现的，关于其详细工作原理我们在介绍中有详细讲解。 在以上示例中，xxx 代表；yyy 代表
我们需要把规则下发到运行中的dubbo sdk，在 dubbo 体系中这是如下如下工作的。
一个 zk/nacos、下发一条规则，dubbo实例接收到规则推送，rpc调用过程中应用规则筛选，选出地址子集调用
注意 传统 Nacos/Zookeeper 的微服务部署方案中，Dubbo 的路由规则配置中心存储并转发到 Dubbo SDK，而在 Kubernetes Service 或服务网格场景下，路由规则的存储与推送机制会有一些变化，具体请参考 Kubernetes 最佳实践。 这时，如果我们对 xxx 服务发送一个请求，
有一点非常
更多内容 配置了路由规则不生效？Dubbo 路由规则排查方法 当前的路由规则不够灵活，无法达到效果？来看看 脚本路由 吧 您还可以通过 扩展 Dubbo 的路由实现 定制自己的流量策略</description></item><item><title>集群扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/cluster/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/cluster/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 当有多个服务提供方时，将多个服务提供方组织成一个集群，并伪装成一个提供方。
扩展接口 org.apache.dubbo.rpc.cluster.Cluster
扩展配置 &amp;lt;dubbo:protocol cluster=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值配置，如果&amp;lt;dubbo:protocol&amp;gt;没有配置cluster时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider cluster=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.rpc.cluster.support.wrapper.MockClusterWrapper org.apache.dubbo.rpc.cluster.support.FailoverCluster org.apache.dubbo.rpc.cluster.support.FailfastCluster org.apache.dubbo.rpc.cluster.support.FailsafeCluster org.apache.dubbo.rpc.cluster.support.FailbackCluster org.apache.dubbo.rpc.cluster.support.ForkingCluster org.apache.dubbo.rpc.cluster.support.AvailableCluster org.apache.dubbo.rpc.cluster.support.MergeableCluster org.apache.dubbo.rpc.cluster.support.BroadcastCluster org.apache.dubbo.rpc.cluster.support.registry.ZoneAwareCluster 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxCluster.java (实现Cluster接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.Cluster (纯文本文件，内容为：xxx=com.xxx.XxxCluster) XxxCluster.java：
package com.xxx; import org.apache.dubbo.rpc.cluster.Cluster; import org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker; import org.apache.dubbo.rpc.cluster.Directory; import org.apache.dubbo.rpc.cluster.LoadBalance; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.Result; import org.apache.dubbo.rpc.RpcException; public class XxxCluster implements Cluster { public &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; merge(Directory&amp;lt;T&amp;gt; directory) throws RpcException { return new AbstractClusterInvoker&amp;lt;T&amp;gt;(directory) { public Result doInvoke(Invocation invocation, List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, LoadBalance loadbalance) throws RpcException { // .</description></item><item><title>集群扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/cluster/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/cluster/</guid><description>扩展说明 当有多个服务提供方时，将多个服务提供方组织成一个集群，并伪装成一个提供方。
扩展接口 org.apache.dubbo.rpc.cluster.Cluster
扩展配置 &amp;lt;dubbo:protocol cluster=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值配置，如果&amp;lt;dubbo:protocol&amp;gt;没有配置cluster时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider cluster=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.rpc.cluster.support.wrapper.MockClusterWrapper org.apache.dubbo.rpc.cluster.support.FailoverCluster org.apache.dubbo.rpc.cluster.support.FailfastCluster org.apache.dubbo.rpc.cluster.support.FailsafeCluster org.apache.dubbo.rpc.cluster.support.FailbackCluster org.apache.dubbo.rpc.cluster.support.ForkingCluster org.apache.dubbo.rpc.cluster.support.AvailableCluster org.apache.dubbo.rpc.cluster.support.MergeableCluster org.apache.dubbo.rpc.cluster.support.BroadcastCluster org.apache.dubbo.rpc.cluster.support.registry.ZoneAwareCluster 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxCluster.java (实现Cluster接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.Cluster (纯文本文件，内容为：xxx=com.xxx.XxxCluster) XxxCluster.java：
package com.xxx; import org.apache.dubbo.rpc.cluster.Cluster; import org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker; import org.apache.dubbo.rpc.cluster.Directory; import org.apache.dubbo.rpc.cluster.LoadBalance; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.Result; import org.apache.dubbo.rpc.RpcException; public class XxxCluster implements Cluster { public &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; merge(Directory&amp;lt;T&amp;gt; directory) throws RpcException { return new AbstractClusterInvoker&amp;lt;T&amp;gt;(directory) { public Result doInvoke(Invocation invocation, List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, LoadBalance loadbalance) throws RpcException { // .</description></item><item><title>集群扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/cluster/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/cluster/</guid><description>扩展说明 当有多个服务提供方时，将多个服务提供方组织成一个集群，并伪装成一个提供方。
扩展接口 org.apache.dubbo.rpc.cluster.Cluster
扩展配置 &amp;lt;dubbo:protocol cluster=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值配置，如果&amp;lt;dubbo:protocol&amp;gt;没有配置cluster时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider cluster=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.rpc.cluster.support.wrapper.MockClusterWrapper org.apache.dubbo.rpc.cluster.support.FailoverCluster org.apache.dubbo.rpc.cluster.support.FailfastCluster org.apache.dubbo.rpc.cluster.support.FailsafeCluster org.apache.dubbo.rpc.cluster.support.FailbackCluster org.apache.dubbo.rpc.cluster.support.ForkingCluster org.apache.dubbo.rpc.cluster.support.AvailableCluster org.apache.dubbo.rpc.cluster.support.MergeableCluster org.apache.dubbo.rpc.cluster.support.BroadcastCluster org.apache.dubbo.rpc.cluster.support.registry.ZoneAwareCluster 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxCluster.java (实现Cluster接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.Cluster (纯文本文件，内容为：xxx=com.xxx.XxxCluster) XxxCluster.java：
package com.xxx; import org.apache.dubbo.rpc.cluster.Cluster; import org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker; import org.apache.dubbo.rpc.cluster.Directory; import org.apache.dubbo.rpc.cluster.LoadBalance; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.Result; import org.apache.dubbo.rpc.RpcException; public class XxxCluster implements Cluster { public &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; merge(Directory&amp;lt;T&amp;gt; directory) throws RpcException { return new AbstractClusterInvoker&amp;lt;T&amp;gt;(directory) { public Result doInvoke(Invocation invocation, List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, LoadBalance loadbalance) throws RpcException { // .</description></item><item><title>扩展 Dubbo 向导</title><link>https://dubbo.apache.org/zh-cn/contact/contributor/dubbo-extension-guide_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/contact/contributor/dubbo-extension-guide_dev/</guid><description>Dubbo 使用微内核+插件的设计模式。内核只负责组装插件，Dubbo 的功能都是由扩展点（插件）实现，这就意味着 Dubbo 的所有功能都可以被用户定制的扩展所替代。
Dubbo 生态系统 我们建议您将扩展加入到 Dubbo 生态系统。使用这种模式，可以使 Dubbo 的核心仓库更干净，并且可以减少维护工作。更少的代码也可以提高核心仓库的构建速度。
依赖 要实现您自己的 Dubbo 扩展，通常只需依赖 API jar 就可以满足您的需求。例如：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-serialization-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${dubbo.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; Src指导 通常，要实现特殊的扩展，只需要参考开发者指南，实现Dubbo必要的接口和合适的扩展即可。除此之外，还有一些其它的事项需要注意：
良好的测试，您需要编写单元测试和冒烟测试以消除潜在的 bug。 没有警告，如有不可避免的警告，请使用 @SuppressWarnings 阻止它，但是请不要乱用。 README。添加必要的自述以说明如何使用扩展，以及需要注意的事项。 许可证：请确保使用Apache License 2.0。 通知社区 提交您的代码到 github。 加入邮件列表（建议）。点击这里查看如何加入邮件列表。 发送一封邮件到 dev@incubator.dubbo.apache.org 通知社区。 通常，发送邮件之后，社区会对您的扩展进行讨论，dubbo 组的管理员会联系您转移您的项目到 dubbo 生态系统。 转移项目到dubbo生态系统 dubbo 组的管理员会请您将您的项目的所有者转让给 dubbo。 dubbo 组的管理员会在 dubbo 组下新建一个项目并邀请您加入到这个项目。 一旦您接受邀请，您可以将您的项目转移到 dubbo 组下的新项目里。 dubbo 组的成员会对您的项目进行代码审查。随后，您可以对这些代码进行改进。</description></item><item><title>扩展点重构</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/principals/extension/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/principals/extension/</guid><description>随着服务化的推广，网站对Dubbo服务框架的需求逐渐增多，Dubbo 的现有开发人员能实现的需求有限，很多需求都被 delay，而网站的同学也希望参与进来，加上领域的推动，所以平台计划将部分项目对公司内部开放，让大家一起来实现，Dubbo 为试点项目之一。
既然要开放，那 Dubbo 就要留一些扩展点，让参与者尽量黑盒扩展，而不是白盒的修改代码，否则分支，质量，合并，冲突都会很难管理。
先看一下 Dubbo 现有的设计：
这里面虽然有部分扩展接口，但并不能很好的协作，而且扩展点的加载和配置都没有统一处理，所以下面对它进行重构。
第一步，微核心，插件式，平等对待第三方 即然要扩展，扩展点的加载方式，首先要统一，微核心+插件式，是比较能达到 OCP 原则的思路。
由一个插件生命周期管理容器，构成微核心，核心不包括任何功能，这样可以确保所有功能都能被替换，并且，框架作者能做到的功能，扩展者也一定要能做到，以保证平等对待第三方，所以，框架自身的功能也要用插件的方式实现，不能有任何硬编码。
通常微核心都会采用 Factory、IoC、OSGi 等方式管理插件生命周期。考虑 Dubbo 的适用面，不想强依赖 Spring 等 IoC 容器。自已造一个小的 IoC 容器，也觉得有点过度设计，所以打算采用最简单的 Factory 方式管理插件。
最终决定采用的是 JDK 标准的 SPI 扩展机制，参见：java.util.ServiceLoader ，也就是扩展者在 jar 包的 META-INF/services/ 目录下放置与接口同名的文本文件，内容为接口实现类名，多个实现类名用换行符分隔。比如，需要扩展 Dubbo 的协议，只需在 xxx.jar 中放置文件：META-INF/services/org.apache.dubbo.rpc.Protocol，内容为 com.alibaba.xxx.XxxProtocol。Dubbo 通过 ServiceLoader 扫描到所有 Protocol 实现。
并约定所有插件，都必须标注：@Extension(&amp;quot;name&amp;quot;)，作为加载后的标识性名称，用于配置选择。
第二步，每个扩展点只封装一个变化因子，最大化复用 每个扩展点的实现者，往往都只是关心一件事，现在的扩展点，并没有完全分离。比如：Failover, Route, LoadBalance, Directory 没有完全分开，全由 RoutingInvokerGroup 写死了。
再比如，协议扩展，扩展者可能只是想替换序列化方式，或者只替换传输方式，并且 Remoting 和 Http 也能复用序列化等实现。这样，需为传输方式，客户端实现，服务器端实现，协议头解析，数据序列化，都留出不同扩展点。
拆分后，设计如下：
第三步，全管道式设计，框架自身逻辑，均使用截面拦截实现 现在很多的逻辑，都是放在基类中实现，然后通过模板方法回调子类的实现，包括：local, mock, generic, echo, token, accesslog, monitor, count, limit 等等，可以全部拆分使用 Filter 实现，每个功能都是调用链上的一环。 比如：(基类模板方法)</description></item><item><title>统一路由规则升级指南</title><link>https://dubbo.apache.org/zh-cn/docs/migration/migration-routingrule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/migration/migration-routingrule/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。</description></item><item><title>配置加载流程</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/configuration/configuration-load-process/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/configuration/configuration-load-process/</guid><description>此篇文档主要讲在应用启动阶段，Dubbo框架如何将所需要的配置采集起来（包括应用配置、注册中心配置、服务配置等），以完成服务的暴露和引用流程。
根据驱动方式的不同（比如Spring或裸API编程）配置形式上肯定会有所差异，具体请参考XML配置、Annotation配置、API配置三篇文档。除了外围驱动方式上的差异，Dubbo的配置读取总体上遵循了以下几个原则：
Dubbo 支持了多层级的配置，并按预定优先级自动实现配置间的覆盖，最终所有配置汇总到数据总线URL后驱动后续的服务暴露、引用等流程。 ApplicationConfig、ServiceConfig、ReferenceConfig 可以被理解成配置来源的一种，是直接面向用户编程的配置采集方式。 配置格式以 Properties 为主，在配置内容上遵循约定的 path-based 的命名规范 配置来源 首先，从Dubbo支持的配置来源说起，默认有四种配置来源：
JVM System Properties，-D 参数 Externalized Configuration，外部化配置 ServiceConfig、ReferenceConfig 等编程接口采集的配置 本地配置文件 dubbo.properties 覆盖关系 下图展示了配置覆盖关系的优先级，从上到下优先级依次降低：
点此查看外部化配置详情
配置格式 目前Dubbo支持的所有配置都是.properties格式的，包括-D、Externalized Configuration等，.properties中的所有配置项遵循一种path-based的配置格式：
# 应用级别 dubbo.{config-type}[.{config-id}].{config-item}={config-item-value} # 服务级别 dubbo.service.{interface-name}[.{method-name}].{config-item}={config-item-value} dubbo.reference.{interface-name}[.{method-name}].{config-item}={config-item-value} # 多配置项 dubbo.{config-type}s.{config-id}.{config-item}={config-item-value} 应用级别
dubbo.application.name=demo-provider dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.protocol.port=-1 服务级别
dubbo.service.org.apache.dubbo.samples.api.DemoService.timeout=5000 dubbo.reference.org.apache.dubbo.samples.api.DemoService.timeout=6000 dubbo.reference.org.apache.dubbo.samples.api.DemoService.sayHello.timeout=7000 多配置项
dubbo.registries.unit1.address=zookeeper://127.0.0.1:2181 dubbo.registries.unit2.address=zookeeper://127.0.0.1:2182 dubbo.protocols.dubbo.name=dubbo dubbo.protocols.dubbo.port=20880 dubbo.protocols.hessian.name=hessian dubbo.protocols.hessian.port=8089 扩展配置
dubbo.application.parameters=[{item1:value1},{item2:value2}] dubbo.reference.org.apache.dubbo.samples.api.DemoService.parameters=[{item3:value3}] 几种编程配置方式 接下来，我们看一下选择不同的开发方式时，对应到 ServiceConfig、ReferenceConfig 等编程接口采集的配置的变化。
Spring XML 参见示例
&amp;lt;!-- dubbo-provier.xml --&amp;gt; &amp;lt;dubbo:application name=&amp;#34;demo-provider&amp;#34;/&amp;gt; &amp;lt;dubbo:config-center address=&amp;#34;zookeeper://127.</description></item><item><title>配置工作原理</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config/principle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config/principle/</guid><description>本文主要讲解 Dubbo 配置相关的 API 与工作原理，学习 Dubbo 的多种配置源、每种配置源的具体配置方式、不同配置源之间的优先级与覆盖关系。
实现原理 为了更好地管理各种配置，Dubbo 抽象了一套结构化的配置组件，各组件总体以用途划分，分别控制不同作用域的行为。
组件名称 描述 范围 是否必须配置 application 指定应用名等应用级别相关信息 一个应用内只允许出现一个 必选 service 声明普通接口或实现类为 Dubbo 服务 一个应用内可以有 0 到多个 service service/reference 至少一种 reference 声明普通接口为 Dubbo 服务 一个应用内可以有 0 到多个 reference service/reference 至少一种 protocol 要暴露的 RPC 协议及相关配置如端口号等 一个应用可配置多个，一个 protocol 可作用于一组 service&amp;amp;reference 可选，默认 dubbo registry 注册中心类型、地址及相关配置 一个应用内可配置多个，一个 registry 可作用于一组 service&amp;amp;reference 必选 config-center 配置中心类型、地址及相关配置 一个应用内可配置多个，所有服务共享 可选 metadata-report 元数据中心类型、地址及相关配置 一个应用内可配置多个，所有服务共享 可选 consumer reference 间共享的默认配置 一个应用内可配置多个，一个 consumer 可作用于一组 reference 可选 provider service 间共享的默认配置 一个应用内可配置多个，一个 provider 可作用于一组 service 可选 monitor 监控系统类型及地址 一个应用内只允许配置一个 可选 metrics 数据采集模块相关配置 一个应用内只允许配置一个 可选 ssl ssl/tls 安全链接相关的证书等配置 一个应用内只允许配置一个 可选 method 指定方法级的配置 service 和 reference 的子配置 可选 argument 某个方法的参数配置 method的子配置 可选 从实现原理层面，最终 Dubbo 所有的配置项都会被组装到 URL 中，以 URL 为载体在后续的启动、RPC 调用过程中传递，进而控制框架行为。如想了解更多，请参照 Dubbo 源码解析系列文档或 Blog。</description></item><item><title>日志框架运行时管理</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/introduction/logger-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/introduction/logger-management/</guid><description>注意 自 3.0.10 开始，dubbo-qos 运行时管控支持查询日志配置以及动态修改使用的日志框架和日志级别。
通过 dubbo-qos 修改的日志配置不进行持久化存储，在应用重启后将会失效。
查询日志配置 命令：loggerInfo
示例：
&amp;gt; telnet 127.0.0.1 22222 &amp;gt; loggerInfo 输出：
Trying 127.0.0.1... Connected to localhost. Escape character is &amp;#39;^]&amp;#39;. ___ __ __ ___ ___ ____ / _ \ / / / // _ ) / _ ) / __ \ / // // /_/ // _ |/ _ |/ /_/ / /____/ \____//____//____/ \____/ dubbo&amp;gt;loggerInfo Available logger adapters: [jcl, jdk, log4j, slf4j].</description></item><item><title>使用 Apache Skywalking 做分布式跟踪</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/admin/ops/skywalking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/admin/ops/skywalking/</guid><description>Apache Skywalking 简介 Apache Skywalking 专门为微服务架构和云原生架构系统而设计并且支持分布式链路追踪的APM系统。Apache Skywalking 通过加载探针的方式收集应用调用链路信息，并对采集的调用链路信息进行分析，生成应用间关系和服务间关系以及服务指标。Apache Skywalking 目前支持多种语言，其中包括 Java，.Net Core，Node.js 和 Go 语言。
目前 Skywalking 已经支持从 6 个可视化维度剖析分布式系统的运行情况。总览视图是应用和组件的全局视图，其中包括组件和应用数量，应用的告警波动，慢服务列表以及应用吞吐量；拓扑图从应用依赖关系出发，展现整个应用的拓扑关系；应用视图则是从单个应用的角度，展现应用的上下游关系，TopN 的服务和服务器，JVM 的相关信息以及对应的主机信息。服务视图关注单个服务入口的运行情况以及此服务的上下游依赖关系，依赖度，帮助用户针对单个服务的优化和监控；调用链展现了调用的单次请求经过的所有埋点以及每个埋点的执行时长；告警视图根据配置阈值针对应用、服务器、服务进行实时告警。
Dubbo 与 Apache Skywalking 编写 Dubbo 示例程序 Dubbo 实例程序已上传到 Github 仓库中。方便大家下载使用。
API 工程 服务接口：
package org.apache.skywalking.demo.interfaces; public interface HelloService { String sayHello(String name); } Dubbo 服务提供工程 package org.apache.skywalking.demo.provider; @Service(version = &amp;#34;${demo.service.version}&amp;#34;, application = &amp;#34;${dubbo.application.id}&amp;#34;, protocol = &amp;#34;${dubbo.protocol.id}&amp;#34;, registry = &amp;#34;${dubbo.registry.id}&amp;#34;, timeout = 60000) public class HelloServiceImpl implements HelloService { public String sayHello(String name) { LockSupport.</description></item><item><title>使用 Pinpoint 做分布式跟踪</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/admin/ops/pinpoint/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/admin/ops/pinpoint/</guid><description>在使用 Dubbo 进行服务化或者整合应用后，假设某个服务后台日志显示有异常，这个服务又被多个应用调用的情况下，我们通常很难判断是哪个应用调用的，问题的起因是什么，因此我们需要一套分布式跟踪系统来快速定位问题，Pinpoint 可以帮助我们快速定位问题（当然，解决方案也不止这一种）。
什么是 Pinpoint 摘自 Pinpoint 学习笔记
Pinpoint 是一个开源的 APM (Application Performance Management/应用性能管理)工具，用于基于java的大规模分布式系统。
仿照 Google Dapper，Pinpoint 通过跟踪分布式应用之间的调用来提供解决方案，以帮助分析系统的总体结构和内部模块之间如何相互联系。
注：对于各个模块之间的通讯英文原文中用的是transaction一词，但是我觉得如果翻译为&amp;quot;事务&amp;quot;容易引起误解，所以替换为&amp;quot;交互&amp;quot;或者&amp;quot;调用&amp;quot;这种比较直白的字眼。
在使用上力图简单高效：
安装 agent，不需要修改哪怕一行代码 最小化性能损失 服务器地图(ServerMap) 通过可视化分布式系统的模块和他们之间的相互联系来理解系统拓扑。点击某个节点会展示这个模块的详情，比如它当前的状态和请求数量。
实时活动线程图表(Realtime Active Thread Chart) 实时监控应用内部的活动线程。
请求/应答分布图表(Request/Response Scatter Chart) 长期可视化请求数量和应答模式来定位潜在问题。通过在图表上拉拽可以选择请求查看更多的详细信息。
调用栈(CallStack) 在分布式环境中为每个调用生成代码级别的可视图，在单个视图中定位瓶颈和失败点。
巡查(Inspector) 查看应用上的其他详细信息，比如CPU使用率，内存/垃圾回收，TPS，和JVM参数。
支持模块 JDK 6+ Tomcat 6/7/8, Jetty 8/9, JBoss EAP 6, Resin 4, Websphere 6/7/8, Vertx 3.3/3.4/3.5 Spring, Spring Boot (Embedded Tomcat, Jetty) Apache HTTP Client 3.x/4.x, JDK HttpConnector, GoogleHttpClient, OkHttpClient, NingAsyncHttpClient Thrift Client, Thrift Service, DUBBO PROVIDER, DUBBO CONSUMER ActiveMQ, RabbitMQ MySQL, Oracle, MSSQL, CUBRID,POSTGRESQL, MARIA Arcus, Memcached, Redis, CASSANDRA iBATIS, MyBatis DBCP, DBCP2, HIKARICP gson, Jackson, Json Lib log4j, Logback 自定义模块 Pinpoint 与 Dubbo 的结合 启动 Pinpoint 参考 Pinpoint 的 Quick start 搭建环境（不需要启动 TestApp）</description></item><item><title>基于 Kubernetes Service 的服务发现</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/service-discovery/kubernetes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/service-discovery/kubernetes/</guid><description>上面两节我们分别讲解了 Nacos、Zookeeper 两种注册中心模式，它们更像是传统的注册中心解决方案。在 Kubernetes 部署环境下，Dubbo 支持基于 Kubernetes Service 的服务发现模式，其基本工作原理如下图所示：
在这种模式下，服务发现与用户的部署运维操作形成统一，用户定义标准的 Kubernetes Service、Deployment，并将其部署到 Kubernetes，之后 Control Plane 通过监控 APISERVER 资源并与 SDK 进程联动，形成一整套的服务发现体系。
关于使用 Kubernetes 作为注册中心的具体实践案例，请参考 Kubernetes Service 部署 一节了解更多细节。</description></item><item><title>通信协议</title><link>https://dubbo.apache.org/zh-cn/overview/what/core-features/protocols/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/core-features/protocols/</guid><description>Dubbo 框架提供了自定义的高性能 RPC 通信协议：基于 HTTP/2 的 Triple 协议 和 基于 TCP 的 Dubbo2 协议。除此之外，Dubbo 框架支持任意第三方通信协议，如官方支持的 gRPC、Thrift、REST、JsonRPC、Hessian2 等，更多协议可以通过自定义扩展实现。这对于微服务实践中经常要处理的多协议通信场景非常有用。
Dubbo 框架不绑定任何通信协议，在实现上 Dubbo 对多协议的支持也非常灵活，它可以让你在一个应用内发布多个使用不同协议的服务，并且支持用同一个 port 端口对外发布所有协议。
通过 Dubbo 框架的多协议支持，你可以做到：
将任意通信协议无缝地接入 Dubbo 服务治理体系。Dubbo 体系下的所有通信协议，都可以享受到 Dubbo 的编程模型、服务发现、流量管控等优势。比如 gRPC over Dubbo 的模式，服务治理、编程 API 都能够零成本接入 Dubbo 体系。 兼容不同技术栈，业务系统混合使用不同的服务框架、RPC 框架。比如有些服务使用 gRPC 或者 Spring Cloud 开发，有些服务使用 Dubbo 框架开发，通过 Dubbo 的多协议支持可以很好的实现互通。 让协议迁移变的更简单。通过多协议、注册中心的协调，可以快速满足公司内协议迁移的需求。比如如从自研协议升级到 Dubbo 协议，Dubbo 协议自身升级，从 Dubbo 协议迁移到 gRPC，从 HTTP 迁移到 Dubbo 协议等。 HTTP/2 (Triple) Triple 协议是 Dubbo3 发布的面向云原生时代的通信协议，它基于 HTTP/2 并且完全兼容 gRPC 协议，原生支持 Streaming 通信语义，Triple 可同时运行在 HTTP/1 和 HTTP/2 传输协议之上，让你可以直接使用 curl、浏览器访问后端 Dubbo 服务。</description></item><item><title>限流 &amp; 熔断</title><link>https://dubbo.apache.org/zh-cn/overview/what/core-features/traffic/circuit-breaking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/core-features/traffic/circuit-breaking/</guid><description>由于微服务分布式的特点，如何构建稳定的微服务集群是一个很大的挑战，其中有两项非常关键的点值得关注
流量控制 (Rate Limiting) 熔断降级 (Circuit Breaking) 流量控制 流量控制更多的是站在 Dubbo 服务提供者视角来保证服务稳定性，通过明确的为 Dubbo 服务设置请求上限阈值，确保服务所处理的请求数始终在一个合理范围之内，从而确保系统整体的稳定性。
根据服务的具体部署情况，服务所能处理的流量上限是一定的，当对服务的请求数量保持在合理的范围时，系统运行正常；而当请求数量严重超过服务处理能力时，如大促期间的流量洪峰等场景，就可能造成服务提供者端的资源过度消耗、负载过高，进而出现响应延迟、请求无应答、系统假死等情况。
流量控制解决的问题和工作方式比较容易理解，而其使用的难点就是如何确定服务所能处理的流量最大值？
一种模式是由用户预先设定一个固定的限流值，如 Dubbo 通过集成 Sentinel 等产品实现的限流能力即是这种模式 Dubbo Sentinel 流量控制 另一种方式是 Dubbo 框架自动根据系统或集群负载情况执行限流，相比用户预先设置限流值更加灵活方便，Dubbo 目前内置了自适应限流模式，具体可参见： Java 自适应限流使用方式 Go 自适应限流使用方式 自适应限流设计原理 熔断降级 熔断降级则是更多的从 Dubbo 服务消费者视角来保障系统稳定性的重要手段。一个服务往往需要调用更多的下游 Dubbo 服务来完成业务逻辑，这时下游服务的稳定性就会影响当前服务甚至整个系统的稳定性，熔断（Circuit Breaking）即是面向不稳定服务场景设计的，它能最大限度避免下游服务不稳定对上游服务带来的影响。
而相比于熔断后直接返回调用失败信息，配合服务降级能力，我们可以继续调用预先设置好的服务降级逻辑，以降级逻辑的结果作为最终调用结果，以更优雅的返回给服务调用方。
如上图所示，Dubbo Consumer 依赖的下游的三个 Dubbo 服务，当 Service 3 出现不稳定的情况时（如响应时间变长、错误率增加等），从而 Consumer 调用 Service 3 的线程等资源就会产生堆积，如果此时我们不在 Consumer 侧做任何限制，则 Service 1 与 Service 2 的调用都会受到稳定性影响。通过熔断 Service 3 我们就能保证整个 Dubbo Consumer 服务的稳定性，不拖垮整个 Consumer 服务，熔断 Service 3 的方式可以有很多种实现，包括线程数、信号量、错误率等。</description></item><item><title>与 gRPC 应用互通</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/interop-grpc/call_grpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/interop-grpc/call_grpc/</guid><description>1.介绍 triple 协议 100% 兼容 gRPC，本示例演示使用 dubbo-go 开发与 grpc 互调的应用，可在此查看 完整示例源码地址
2.如何互通 Dubbo-go的Triple协议能够兼容grpc协议 在创建服务端时，可以设置protocol.WithTriple()使用Triple协议
srv, err := server.NewServer( server.WithServerProtocol( protocol.WithPort(20000), protocol.WithTriple(), ), ) 3.案例 3.1服务端介绍 服务端proto文件 源文件路径：dubbo-go-sample/rpc/grpc/proto/greet.proto
syntax = &amp;#34;proto3&amp;#34;; package greet; option go_package = &amp;#34;github.com/apache/dubbo-go-samples/rpc/grpc/proto;greet&amp;#34;; message GreetRequest { string name = 1; } message GreetResponse { string greeting = 1; } service GreetService { rpc Greet(GreetRequest) returns (GreetResponse) {} } dubbo-go服务端 源文件路径：dubbo-go-sample/rpc/grpc/go-server/cmd/main.go
type GreetTripleServer struct { } func (srv *GreetTripleServer) Greet(ctx context.</description></item><item><title>元数据参考手册</title><link>https://dubbo.apache.org/zh-cn/docs/references/metadata/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/metadata/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
背景 dubbo provider中的服务配置项有接近30个配置项。 排除注册中心服务治理需要之外，很大一部分配置项是provider自己使用，不需要透传给消费者。这部分数据不需要进入注册中心，而只需要以key-value形式持久化存储。 dubbo consumer中的配置项也有20+个配置项。在注册中心之中，服务消费者列表中只需要关注application，version，group，ip，dubbo版本等少量配置，其他配置也可以以key-value形式持久化存储。 这些数据是以服务为维度注册进入注册中心，导致了数据量的膨胀，进而引发注册中心(如zookeeper)的网络开销增大，性能降低。
除了上述配置项的存储之外，dubbo服务元数据信息也需要被存储下来。元数据信息包括服务接口，及接口的方法信息。这些信息将被用于服务mock，服务测试。
以上的元数据都是基于接口级别。在3.0版本中，引入了应用元数据的概念，应用元数据描述的是整个应用的信息概览。并且引入了服务自省映射，用于应用级别的服务发现。
目标 需要将注册中心原来的数据信息和元数据信息保存到独立的key-value的存储中，这个key-value可以是DB，redis或者其他持久化存储。核心代码中支持了zookeeper，redis, nacos(推荐)的默认支持。
因为是基于key-value存储，key不会改变，最新的value会将原来的value进行覆盖
Provider存储内容的格式，参见：org.apache.dubbo.metadata.definition.model.FullServiceDefinition。是该类型gson化之后的存储。 Consumer存储内容，为Map格式。从Consumer端注册到注册中心的URL中的获取参数信息。即通过URL.getParameterMap()获取到的Map，进行gson化之后进行存储。
详细的内容，可以参考下面的sample输出。
配置 默认的元数据存储，额外支持以下几个特性：
失败重试 每天定时重刷 失败重试 失败重试可以通过retrytimes （重试次数,默认100），retryperiod（重试周期，默认3000ms）进行设置。
定时刷新 默认开启，可以通过设置cycleReport=false进行关闭。
完整的配置项： dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 dubbo.metadata-report.username=xxx ##非必须 dubbo.metadata-report.password=xxx ##非必须 dubbo.metadata-report.retry-times=30 ##非必须,default值100 dubbo.metadata-report.retry-period=5000 ##非必须,default值3000 dubbo.metadata-report.cycle-report=false ##非必须,default值true dubbo.metadata-report.sync.report=false ##非必须,default值为false 如果元数据地址(dubbo.metadata-report.address)也不进行配置，会判断注册中心的协议是否支持元数据中心，如果支持，会使用注册中心的地址来用作元数据中心。
接下来看几个sample的配置。无论哪种配置方式，都需要引入maven依赖：
zookeeper:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-metadata-report-zookeeper&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; redis:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-metadata-report-redis&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; nacos:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-metadata-report-nacos&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 完整的sample，查看sample-2.7
方式一：在配置中心配置 参考sample：dubbo-samples-metadata-report/dubbo-samples-metadata-report-configcenter 工程。
配置中心配置 配置中心的配置，可以参考configcenter的文档。配置的内容如下：
dubbo.registry.address=zookeeper://127.0.0.1:2181 ### 注意驼峰式风格 dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 ###元数据存储的地址 在sample中，使用了Zookeeper作为配置中心。启动本地zookeeper服务之后，直接运行：org.apache.dubbo.samples.metadatareport.configcenter.ZKTools 就可以完成写入。 如果配置中心使用了nacos，apollo，这些产品本身支持ops配置。</description></item><item><title>元数据参考手册</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/metadata/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/metadata/</guid><description>背景 dubbo provider中的服务配置项有接近30个配置项。 排除注册中心服务治理需要之外，很大一部分配置项是provider自己使用，不需要透传给消费者。这部分数据不需要进入注册中心，而只需要以key-value形式持久化存储。 dubbo consumer中的配置项也有20+个配置项。在注册中心之中，服务消费者列表中只需要关注application，version，group，ip，dubbo版本等少量配置，其他配置也可以以key-value形式持久化存储。 这些数据是以服务为维度注册进入注册中心，导致了数据量的膨胀，进而引发注册中心(如zookeeper)的网络开销增大，性能降低。
除了上述配置项的存储之外，dubbo服务元数据信息也需要被存储下来。元数据信息包括服务接口，及接口的方法信息。这些信息将被用于服务mock，服务测试。
目标 需要将注册中心原来的数据信息和元数据信息保存到独立的key-value的存储中，这个key-value可以是DB，redis或者其他持久化存储。核心代码中支持了zookeeper，redis(推荐)的默认支持。
provider存储内容的格式，参见：org.apache.dubbo.metadata.definition.model.FullServiceDefinition。是该类型gson化之后的存储。 Consumer存储内容，为Map格式。从Consumer端注册到注册中心的URL中的获取参数信息。即通过URL.getParameterMap()获取到的Map，进行gson化之后进行存储。
详细的内容，可以参考下面的sample输出。
配置 默认的元数据存储，额外支持以下几个特性：
失败重试 每天定时重刷 失败重试 失败重试可以通过retrytimes （重试次数,默认100），retryperiod（重试周期，默认3000ms）进行设置。
定时刷新 默认开启，可以通过设置cycleReport=false进行关闭。
完整的配置项： dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 dubbo.metadata-report.username=xxx ##非必须 dubbo.metadata-report.password=xxx ##非必须 dubbo.metadata-report.retry-times=30 ##非必须,default值100 dubbo.metadata-report.retry-period=5000 ##非必须,default值3000 dubbo.metadata-report.cycle-report=false ##非必须,default值true 如果元数据地址(dubbo.metadata-report.address)也不进行配置，整个元数据的写入不会生效，但是不影响程序运行。
接下来看几个sample的配置。无论哪种配置方式，都需要引入maven依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-metadata-report-zookeeper&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 如果需要使用redis，可以引入对应的redis的依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-metadata-report-redis&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 完整的sample，查看sample-2.7
方式一：在配置中心配置 参考sample：dubbo-samples-metadata-report/dubbo-samples-metadata-report-configcenter 工程。
配置中心配置 配置中心的配置，可以参考configcenter的文档。配置的内容如下：
dubbo.registry.address=zookeeper://127.0.0.1:2181 ### 注意驼峰式风格 dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 ###元数据存储的地址 在sample中，使用了Zookeeper作为配置中心。启动本地zookeeper服务之后，直接运行：org.apache.dubbo.samples.metadatareport.configcenter.ZKTools 就可以完成写入。 如果配置中心使用了nacos，apollo，这些产品本身支持ops配置。
应用配置 ###dubbo.properties dubbo.config-center.address=zookeeper://127.0.0.1:2181 ... 完成上述两步之后，注册中心地址、元数据地址将从配置中心进行获取。现在可以依次运行Provider类和Consumer类，会在console中得到对应的输出或者直接通过zookeeper的cli查看。
Provider配置 provider端存储的元数据内容如下：
{ &amp;#34;parameters&amp;#34;: { &amp;#34;side&amp;#34;: &amp;#34;provider&amp;#34;, &amp;#34;methods&amp;#34;: &amp;#34;sayHello&amp;#34;, &amp;#34;dubbo&amp;#34;: &amp;#34;2.</description></item><item><title>直连提供者</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/explicit-target/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/explicit-target/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，点对点直连方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。
通过 XML 配置 如果是线上需求需要点对点，可在 &amp;lt;dubbo:reference&amp;gt; 中配置 url 指向提供者，将绕过注册中心，多个地址用分号隔开，配置如下：
&amp;lt;dubbo:reference id=&amp;#34;xxxService&amp;#34; interface=&amp;#34;com.alibaba.xxx.XxxService&amp;#34; url=&amp;#34;dubbo://localhost:20890&amp;#34; /&amp;gt; 提示 1.0.6 及以上版本支持 通过 -D 参数指定 在 JVM 启动参数中加入-D参数映射服务地址，如：
java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890 提示 key 为服务名，value 为服务提供者 url，此配置优先级最高，1.0.15 及以上版本支持 通过文件映射 如果服务比较多，也可以用文件映射，用 -Ddubbo.resolve.file 指定映射文件路径，此配置优先级高于 &amp;lt;dubbo:reference&amp;gt; 中的配置 [^3]，如：
java -Ddubbo.resolve.file=xxx.properties 然后在映射文件 xxx.properties 中加入配置，其中 key 为服务名，value 为服务提供者 URL：
com.alibaba.xxx.XxxService=dubbo://localhost:20890 提示 1.0.15 及以上版本支持，2.0 以上版本自动加载 ${user.home}/dubbo-resolve.properties文件，不需要配置 注意 为了避免复杂化线上环境，不要在线上使用这个功能，只应在测试阶段使用。</description></item><item><title>直连提供者</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/explicit-target/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/explicit-target/</guid><description>背景 在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，点对点直连方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。
示例 通过 XML 配置 如果是线上需求需要点对点，可在 &amp;lt;dubbo:reference&amp;gt; 中配置 url 指向提供者，将绕过注册中心，多个地址用分号隔开，配置如下：
&amp;lt;dubbo:reference id=&amp;#34;xxxService&amp;#34; interface=&amp;#34;com.alibaba.xxx.XxxService&amp;#34; url=&amp;#34;dubbo://localhost:20890&amp;#34; /&amp;gt; 提示 1.0.6 及以上版本支持 通过 -D 参数指定 在 JVM 启动参数中加入-D参数映射服务地址，如：
java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890 提示 key 为服务名，value 为服务提供者 url，此配置优先级最高，1.0.15 及以上版本支持 通过文件映射 如果服务比较多，也可以用文件映射，用 -Ddubbo.resolve.file 指定映射文件路径，此配置优先级高于 &amp;lt;dubbo:reference&amp;gt; 中的配置 [^3]，如：
java -Ddubbo.resolve.file=xxx.properties 然后在映射文件 xxx.properties 中加入配置，其中 key 为服务名，value 为服务提供者 URL：
com.alibaba.xxx.XxxService=dubbo://localhost:20890 提示 1.0.15 及以上版本支持，2.0 以上版本自动加载 ${user.home}/dubbo-resolve.properties文件，不需要配置 注意 为了避免复杂化线上环境，不要在线上使用这个功能，只应在测试阶段使用。</description></item><item><title>直连提供者</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/explicit-target/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/explicit-target/</guid><description>在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，点对点直连方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。
如果是线上需求需要点对点，可在 reference 节点中配置 url 指向提供者，将绕过注册中心，多个地址用分号隔开，配置如下：
注解配置方式 @DubboReference(url=&amp;#34;tri://localhost:50051&amp;#34;) private XxxService xxxService xml配置方式 &amp;lt;dubbo:reference id=&amp;#34;xxxService&amp;#34; interface=&amp;#34;com.alibaba.xxx.XxxService&amp;#34; url=&amp;#34;dubbo://localhost:20890&amp;#34; /&amp;gt; 更多配置方式 注意 请注意以下配置方式是为了兼容老版本 Dubbo2 而保留，在部分 Dubbo3 版本中可能存在问题，请尽量使用文档前面推荐的配置方式。 通过 -D 参数指定 在 JVM 启动参数中加入-D参数映射服务地址，如：
java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890 提示 key 为服务名，value 为服务提供者 url，此配置优先级最高，1.0.15 及以上版本支持 通过文件映射 如果服务比较多，也可以用文件映射，用 -Ddubbo.resolve.file 指定映射文件路径，此配置优先级高于 &amp;lt;dubbo:reference&amp;gt; 中的配置 [^3]，如：
java -Ddubbo.resolve.file=xxx.properties 然后在映射文件 xxx.properties 中加入配置，其中 key 为服务名，value 为服务提供者 URL：
com.alibaba.xxx.XxxService=dubbo://localhost:20890 提示 1.0.15 及以上版本支持，2.0 以上版本自动加载 ${user.home}/dubbo-resolve.properties文件，不需要配置 注意 为了避免复杂化线上环境，不要在线上使用这个功能，只应在测试阶段使用。</description></item><item><title>Dubbo3 应用级服务发现设计</title><link>https://dubbo.apache.org/zh-cn/overview/reference/proposals/service-discovery/</link><pubDate>Mon, 30 Jan 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/proposals/service-discovery/</guid><description>Objective 显著降低服务发现过程的资源消耗，包括提升注册中心容量上限、降低消费端地址解析资源占用等，使得 Dubbo3 框架能够支持更大规模集群的服务治理，实现无限水平扩容。 适配底层基础设施服务发现模型，如 Kubernetes、Service Mesh 等。 Background 我们从 Dubbo 最经典的工作原理图说起，Dubbo 从设计之初就内置了服务地址发现的能力，Provider 注册地址到注册中心，Consumer 通过订阅实时获取注册中心的地址更新，在收到地址列表后，consumer 基于特定的负载均衡策略发起对 provider 的 RPC 调用。
在这个过程中：
每个 Provider 通过特定的 key 向注册中心注册本机可访问地址； 注册中心通过这个 key 对 provider 实例地址进行聚合； Consumer 通过同样的 key 从注册中心订阅，以便及时收到聚合后的地址列表； 这里，我们对接口级地址发现的内部数据结构进行详细分析。
首先，看右下角 provider 实例内部的数据与行为。Provider 部署的应用中通常会有多个 Service，也就是 Dubbo2 中的服务，每个 service 都可能会有其独有的配置，我们所讲的 service 服务发布的过程，其实就是基于这个服务配置生成地址 URL 的过程，生成的地址数据如图所示；同样的，其他服务也都会生成地址。
然后，看一下注册中心的地址数据存储结构，注册中心以 service 服务名为数据划分依据，将一个服务下的所有地址数据都作为子节点进行聚合，子节点的内容就是实际可访问的ip地址，也就是我们 Dubbo 中 URL，格式就是刚才 provider 实例生成的。
这里把 URL 地址数据划分成了几份：
首先是实例可访问地址，主要信息包含 ip port，是消费端将基于这条数据生成 tcp 网络链接，作为后续 RPC 数据的传输载体 其次是 RPC 元数据，元数据用于定义和描述一次 RPC 请求，一方面表明这条地址数据是与某条具体的 RPC 服务有关的，它的版本号、分组以及方法相关信息，另一方面表明 下一部分是 RPC 配置数据，部分配置用于控制 RPC 调用的行为，还有一部分配置用于同步 Provider 进程实例的状态，典型的如超时时间、数据编码的序列化方式等。 最后一部分是自定义的元数据，这部分内容区别于以上框架预定义的各项配置，给了用户更大的灵活性，用户可任意扩展并添加自定义元数据，以进一步丰富实例状态。 结合以上两页对于 Dubbo2 接口级地址模型的分析，以及最开始的 Dubbo 基本原理图，我们可以得出这么几条结论：</description></item><item><title>0-6 - 线程中断异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/6/</guid><description>可能的原因 运行中的线程在处于 wait、sleep、join 时，被显示调用 interrupt()
排查和解决步骤 正常运行的线程在调用了 interrupt() 方法后，将对当前线程中断状态设置为 true，但线程的执行并不会受到影响。 可根据实际情况进行操作或检查业务代码有无被错误使用。</description></item><item><title>1-6 - 清空URL缓存出错</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/6/</guid><description>可能的原因 在CacheableFailbackRegistry.RemovalTask清空 url 缓存时候出错将会触发清空 URL 缓存出错。
排查和解决步骤 该错误为 Dubbo 内部错误，如果您遇到可以在 github 创建 issues 并提供错误信息以及复现步骤，我们将协助您解决问题。
另请参阅 Dubbo社区</description></item><item><title>2-6 - 条件路由筛选提供方列表为空</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/6/</guid><description>可能的原因 条件路由提供方过滤条件为空。 条件路由在强制降级下筛选提供方列表仍为空。 排查和解决步骤 参照社区请求路由示例，调整条件路由配置。</description></item><item><title>3-6 - 代理执行服务发生异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/3/6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/3/6/</guid><description>可能的原因 当前服务参数已显示入参 deprecated。 泛型声明类可能出现此提醒。 排查和解决步骤 确认URL中是否存在显示入参 deprecated=true 泛型声明类如果出现此错误，会试图创建没有实际接口类的代理。</description></item><item><title>4-6 - 反序列化失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/6/</guid><description>可能的原因 发生在使用自定义的序列化方式的时候，在自定义 SPI org.apache.dubbo.common.serialize.Serialization 序列化方法在使用时发生错误。
排查和解决步骤 可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，获取引起错误的对象内容，再配合自定义实现进行修改。
参考 序列化扩展</description></item><item><title>5-6 - 接口类型的属性冲突</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/6/</guid><description>可能的原因 泛化定义配置不正确。
排查和解决步骤 检查泛化定义是否正确。</description></item><item><title>6-6 - 不支持的消息</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/6/</guid><description>可能的原因 返回的数据序列化错误，或超出序列化最大值
排查和解决步骤 可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。
各组件支持的具体配置项及含义请参考 配置项手册</description></item><item><title>7-6 - QOS 发生未知异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/7/6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/7/6/</guid><description>可能的原因 QOS 发生未知异常
排查和解决步骤 检查当前请求的服务是否可正常访问。 可能由于某些原因，未能正确加载或返回 CommandContext 实例。可根据控制台的错误提醒信息，进行排查定位。</description></item><item><title>FST</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/dubbo/fst/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/dubbo/fst/</guid><description>1 介绍 FST序列化全称是Fast Serialization，它是对Java序列化的替换实现。既然前文中提到Java序列化的两点严重不足，在FST中得到了较大的改善，FST的特征如下：
比JDK提供的序列化提升了10倍，体积也减少 3-4 倍多 支持堆外Maps，和堆外Maps的持久化 支持序列化为JSON 2 使用方式 2.1 添加依赖 &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-serialization-fst&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;de.ruedigermoeller&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;fst&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 2.2 配置启用 # application.yml (Spring Boot) dubbo: protocol: serialization: fst 或
# dubbo.properties dubbo.protocol.serialization=fst # or dubbo.consumer.serialization=fst # or dubbo.reference.com.demo.DemoService.serialization=fst 或
&amp;lt;dubbo:protocol serialization=&amp;#34;fst&amp;#34; /&amp;gt; &amp;lt;!-- or --&amp;gt; &amp;lt;dubbo:consumer serialization=&amp;#34;fst&amp;#34; /&amp;gt; &amp;lt;!-- or --&amp;gt; &amp;lt;dubbo:reference interface=&amp;#34;xxx&amp;#34; serialization=&amp;#34;fst&amp;#34; /&amp;gt; 3 注册被序列化类 要让Kryo和FST完全发挥出高性能，最好将那些需要被序列化的类注册到dubbo系统中，实现如下
回调接口
public class SerializationOptimizerImpl implements SerializationOptimizer { public Collection&amp;lt;Class&amp;gt; getSerializableClasses() { List&amp;lt;Class&amp;gt; classes = new LinkedList&amp;lt;Class&amp;gt;(); classes.</description></item><item><title>Higress</title><link>https://dubbo.apache.org/zh-cn/overview/reference/integrations/higress/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/integrations/higress/</guid><description>本文档讲解如何安装与配置 Higress，涵盖本地、docker、kubernetes 等环境。以下仅为快速示例安装指南，如想搭建生产可用集群请参考 Higress 官方文档。
docker 使用 docker 启动 Higress，请首先确保您已经在本地机器正确 下载页面 安装 docker。
使用以下命令安装 Higress：
curl -fsSL https://higress.io/standalone/get-higress.sh | bash -s -- -a -c nacos://192.168.0.1:8848 --nacos-username=nacos --nacos-password=nacos 请将 192.168.0.1 替换为 Nacos 服务器的 IP（如果 Nacos 部署在本机，请不要使用如 localhost 或 127.0.0.1 的 Loopback 地址）。按需调整 &amp;ndash;nacos-username 和 &amp;ndash;nacos-password 的取值，如果 Nacos 服务未开启认证功能，则可以移除这两个参数。
注意 如果您还没有安装 nacos，请 参考文档完成安装。 如果您使用 Zookeeper 做服务发现，请修改对应的集群地址为 zookeeper 集群地址。 在浏览器中输入 http://127.0.0.1:8080 进入 Higress 控制台。
kubernetes 通过以下命令安装 Higress：
helm repo add higress.io https://higress.io/helm-charts helm install higress -n higress-system higress.</description></item><item><title>Rest 协议</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/others/v3.2_rest_protocol_design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/others/v3.2_rest_protocol_design/</guid><description>注意 从 Dubbo 3.3 版本开始，Rest 协议已移至 Extensions 库，由 Triple 协议来对 Rest 提供更全面的支持，具体参见 Triple Rest用户手册， 如需继续使用原 Rest 协议，可引入对应 dubbo-spi-extensions 库依赖 更加轻量，具有dubbo风格的rest，微服务体系互通（Springcloud Alibaba）
1.注解解析
2.报文编解码
3.restClient
4.restServer(netty)
支持程度：
content-type text json xml form(后续会扩展)
注解
param,header,body,pathvariable （spring mvc &amp;amp; resteasy）
Http 协议报文 POST /test/path? HTTP/1.1 Host: localhost:8080 Connection: keep-alive Content-type: application/json {&amp;quot;name&amp;quot;:&amp;quot;dubbo&amp;quot;,&amp;quot;age&amp;quot;:10,&amp;quot;address&amp;quot;:&amp;quot;hangzhou&amp;quot;} dubbo http(header) // service key header path: com.demo.TestInterface group: demo port: 80 version: 1.0.0 // 保证长连接 Keep-Alive,Connection: keep-alive Keep-alive: 60 // RPCContext Attachment userId: 123456 目前支持粒度： 数据位置 content-type spring注解 resteasy注解 body 无要求 ReuqestBody 无注解即为body querystring(?</description></item><item><title>Zookeeper</title><link>https://dubbo.apache.org/zh-cn/overview/reference/integrations/zookeeper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/integrations/zookeeper/</guid><description>这篇文章讲解如何安装与配置 Zookeeper，涵盖本地、docker、kubernetes 等环境。以下仅为快速示例安装指南，如想搭建生产可用集群请参考 Zookeeper 官方文档。
本地下载 下载Zookeeper 请到 Apache Zookeeper 下载页面 下载最新版本的 zookeeper 发行包。
解压下载的 zookeeper 包：
tar -zxvf apache-zookeeper-3.8.3.tar.gz cd apache-zookeeper-3.8.3 启动 Zookeeper 在启动 zookeeper 之前，首先需要在根目录以下位置创建文件 conf/zoo.cfg：
tickTime=2000 clientPort=2181 admin.enableServer=false 以下是一些参数的详细解释：
tickTime : Zookeeper 用到的基本时间设置，tickTime 为心跳检测间隔， 2*tickTime 是最大 session 超时时间等（单位是毫秒 ms）。 clientPort : 监听端口，客户端可通过这个端口方案 zookeeper server admin.enableServer：运维端口，默认为 8080，建议关闭防止和 Spring Web 应用程序冲突 接下来，可以以 standalone 模式启动 Zookeeper 了：
bin/zkServer.sh start 测试连接到 ZooKeeper 运行以下命令，连接到刚刚启动的 zookeeper server：
$ bin/zkCli.sh -server 127.0.0.1:2181 连接成功后，可看到以下输出：
Connecting to localhost:2181 .</description></item><item><title>根据请求参数引导流量分布</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/arguments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/arguments/</guid><description>根据请求参数值转发流量，是一种非常灵活且实用的流量管控策略。比如微服务实践中，根据参数（如用户 ID）路由流量，将一小部分用户请求转发到最新发布的产品版本，以验证新版本的稳定性、获取用户的产品体验反馈等，是生产实践中常用的一种有效的灰度机制。
或者，有些产品提供差异化的付费服务，需要根据请求参数中的用户 ID 将请求路由到具有不同服务等级保障的集群，就像接下来我们在示例任务中所做的那样。
开始之前 部署 Shop 商城项目 部署并打开 Dubbo Admin 任务详情 为了增加用户粘性，我们为商城示例系统新增了 VIP 用户服务，现在商城有两类用户：普通用户和 VIP 用户，其中 VIP 用户可以看到比普通用户更低的商品价格。
回到商城登录页面，我们以 VIP 用户 dubbo 登录系统，是否看到如下图所示的 VIP 专属商品价格，多刷新几次商品页面那？
哦，是不是价格忽高忽低？！这是因为在当前部署的示例系统中，只有 detail v2 版本才能识别 VIP 用户并提供特价服务，因此，我们要确保 dubbo 用户始终访问 detail v2 实例，以便享受稳定的 VIP 服务。
为 VIP 用户提供稳定的特价商品服务 Detail v2 版本能够识别 VIP 用户并在商品详情中展示特价。商品详情服务由 Detail 应用中的 org.apache.dubbo.samples.DetailService 服务提供，DetailService 显示商品详情的 getItem 方法定义如下，第二个参数为用户名。
public interface DetailService { Item getItem(long sku, String username); } 因此，接下来我们就为 DetailService 服务的 getItem 方法增加参数路由规则，如果用户参数是 dubbo 就转发到 v2 版本的服务。</description></item><item><title>多注册中心</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/multiple-registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/multiple-registry/</guid><description>1 关联服务与多注册中心 1.1 全局默认注册中心 Dubbo 注册中心和服务是独立配置的，通常开发者不用设置服务和注册中心组件之间的关联关系，Dubbo 框架会将自动执行以下动作：
对于所有的 Service 服务，向所有全局默认注册中心注册服务地址。 对于所有的 Reference 服务，从所有全局默认注册中心订阅服务地址。 # application.yml (Spring Boot) dubbo registries beijingRegistry address: zookeeper://localhost:2181 shanghaiRegistry address: zookeeper://localhost:2182 @DubboService public class DemoServiceImpl implements DemoService {} @DubboService public class HelloServiceImpl implements HelloService {} 以上以 Spring Boot 开发为例（XML、API 方式类似）配置了两个全局默认注册中心 beijingRegistry 和 shanghaiRegistry，服务 DemoService 与 HelloService 会分别注册到两个默认注册中心。
除了上面讲到的框架自动为服务设置全局注册中心之外，有两种方式可以灵活调整服务与多注册中心间的关联。
1.2 设置全局默认注册中心 # application.yml (Spring Boot) dubbo registries beijingRegistry address: zookeeper://localhost:2181 default: true shanghaiRegistry address: zookeeper://localhost:2182 default: false default 用来设置全局默认注册中心，默认值为 true 即被视作全局注册中心。未指定注册中心 id 的服务将自动注册或订阅全局默认注册中心。</description></item><item><title>基于应用级服务发现实现地址互通</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/interop-dubbo/service-discovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/interop-dubbo/service-discovery/</guid><description>前面两篇示例我们演示了 dubbo java 和 dubbo go 在协议层面的互通能力，涵盖 triple 和 dubbo 两种协议，
非 protoubf 模式协议互通（triple 和 dubbo 协议） protobuf+triple 协议互通（triple 协议） 在本篇文档中，我们将演示 dubbo java 和 dubbo go 的服务发现互通能力，这样结合协议兼容性，我们就能实现完整的打通 dubbo java 和 dubbo go 微服务体系。
本文档使用 Nacos 注册中心作为演示，可在此查看本文档 示例完整源码。
before run the code , you should Follow this instruction to install and start Nacos server.
应用级别服务发现 cd service start java server
cd java-server sh run.sh start go client
cd go-client go run client.</description></item><item><title>服务目录</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/directory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/directory/</guid><description>1. 简介 本篇文章，将开始分析 Dubbo 集群容错方面的源码。集群容错源码包含四个部分，分别是服务目录 Directory、服务路由 Router、集群 Cluster 和负载均衡 LoadBalance。这几个部分的源码逻辑相对比较独立，我们将会分四篇文章进行分析。本篇文章作为集群容错的开篇文章，将和大家一起分析服务目录相关的源码。在进行深入分析之前，我们先来了解一下服务目录是什么。服务目录中存储了一些和服务提供者有关的信息，通过服务目录，服务消费者可获取到服务提供者的信息，比如 ip、端口、服务协议等。通过这些信息，服务消费者就可通过 Netty 等客户端进行远程调用。在一个服务集群中，服务提供者数量并不是一成不变的，如果集群中新增了一台机器，相应地在服务目录中就要新增一条服务提供者记录。或者，如果服务提供者的配置修改了，服务目录中的记录也要做相应的更新。如果这样说，服务目录和注册中心的功能不就雷同了吗？确实如此，这里这么说是为了方便大家理解。实际上服务目录在获取注册中心的服务配置信息后，会为每条配置信息生成一个 Invoker 对象，并把这个 Invoker 对象存储起来，这个 Invoker 才是服务目录最终持有的对象。Invoker 有什么用呢？看名字就知道了，这是一个具有远程调用功能的对象。讲到这大家应该知道了什么是服务目录了，它可以看做是 Invoker 集合，且这个集合中的元素会随注册中心的变化而进行动态调整。
关于服务目录这里就先介绍这些，大家先有个大致印象。接下来我们通过继承体系图来了解一下服务目录的家族成员都有哪些。
2. 继承体系 服务目录目前内置的实现有两个，分别为 StaticDirectory 和 RegistryDirectory，它们均是 AbstractDirectory 的子类。AbstractDirectory 实现了 Directory 接口，这个接口包含了一个重要的方法定义，即 list(Invocation)，用于列举 Invoker。下面我们来看一下他们的继承体系图。
如上，Directory 继承自 Node 接口，Node 这个接口继承者比较多，像 Registry、Monitor、Invoker 等均继承了这个接口。这个接口包含了一个获取配置信息的方法 getUrl，实现该接口的类可以向外提供配置信息。另外，大家注意看 RegistryDirectory 实现了 NotifyListener 接口，当注册中心节点信息发生变化后，RegistryDirectory 可以通过此接口方法得到变更信息，并根据变更信息动态调整内部 Invoker 列表。
3. 源码分析 本章将分析 AbstractDirectory 和它两个子类的源码。AbstractDirectory 封装了 Invoker 列举流程，具体的列举逻辑则由子类实现，这是典型的模板模式。所以，接下来我们先来看一下 AbstractDirectory 的源码。
public List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; list(Invocation invocation) throws RpcException { if (destroyed) { throw new RpcException(&amp;#34;Directory already destroyed.</description></item><item><title>公共契约</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/contract/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/contract/</guid><description>URL 所有扩展点参数都包含 URL 参数，URL 作为上下文信息贯穿整个扩展点设计体系。 URL 采用标准格式：protocol://username:password@host:port/path?key=value&amp;amp;key=value 日志 如果不可恢复或需要报警，打印 ERROR 日志。 如果可恢复异常，或瞬时的状态不一致，打印 WARN 日志。 正常运行时的中间状态提示，打印 INFO 日志。</description></item><item><title>扩展适配</title><link>https://dubbo.apache.org/zh-cn/overview/what/core-features/extensibility/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/core-features/extensibility/</guid><description>Dubbo 从设计上是高度可扩展的，通过这些扩展点你可以做到：
拦截流量并控制流量行为 按需调优 Dubbo 的一些默认策略与实现 将 Dubbo 服务适配到公司内部微服务集群或其他主流的开源组件 一切皆可扩展 Dubbo 扩展能力使得 Dubbo 项目很方便的切分成一个一个的子模块，实现热插拔特性。用户完全可以基于自身需求，替换 Dubbo 原生实现，来满足自身业务需求。
协议与编码扩展。通信协议、序列化编码协议等 流量管控扩展。集群容错策略、路由规则、负载均衡、限流降级、熔断策略等 服务治理扩展。注册中心、配置中心、元数据中心、分布式事务、全链路追踪、监控系统等 诊断与调优扩展。流量统计、线程池策略、日志、QoS 运维命令、健康检查、配置加载等 基于扩展点的微服务生态 众多的扩展点与抽象，是 Dubbo 与众多微服务生态组件对接、实现微服务治理能力的基础。
全链路追踪 数据一致性 限流降级 Dubbo 的各语言 sdk 实现都是采用的 &amp;ldquo;微内核+插件&amp;rdquo; 的设计模式，几乎所有流程中的核心节点都被定义为扩展点，官方发布的组件也是以扩展点的实现形式发布，因此 Dubbo 可以平等的对待所有官方与第三方组件扩展。
扩展适配能力是实现 Dubbo 微服务生态的关键，Dubbo 生态组件如全链路追踪、注册中心实现等的适配都是基于 Filter、Registry、DynamicConfiguration 等扩展点实现。 扩展适配给用户带来最大的灵活性，开发者可以随时接入公司内部组件、按需定制核心能力等。 以上是按架构层次划分的 Dubbo 内的一些核心扩展点定义及实现，从三个层次来展开：
协议通信层 流量管控层 服务治理层 协议通信层 在通信协议一节我们强调过，Dubbo 不绑定任何协议，用户可以选择 Triple、gRPC、Dubbo2、REST、自定义协议等任一 RPC 远程通信协议，除此之外，RPC 协议之上的数据编码格式 (即序列化协议) 也是通过扩展点定义，用户可以灵活选择 RPC 与序列化的通信协议组合。
Protocol Protocol 扩展点定义对应的是 RPC 协议，利用这个扩展点可以让 Dubbo 作为统一的微服务开发和治理框架，而在下层通信协议上实现灵活切换。官方发布了对大多数主流 RPC 通信协议的适配，你可以通过几条简单的配置直接使用，如果你想使用公司自定义的 RPC 通信协议，请通过 Protocol 提供自定义扩展实现。</description></item><item><title>如何扩展 Dubbo</title><link>https://dubbo.apache.org/zh-cn/docs/concepts/extensibility/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/concepts/extensibility/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展设计理念 可扩展性是任何一个系统所追求的，对于 Dubbo 来说是同样适用。
什么是可扩展性 可扩展性是一种设计理念，代表了我们对未来的一种预想，我们希望在现有的架构或设计基础上，当未来某些方面发生变化的时候，我们能够以最小的改动来适应这种变化。
可扩展性的优点 可扩展性的优点主要表现模块之间解耦，它符合开闭原则，对扩展开放，对修改关闭。当系统增加新功能时，不需要对现有系统的结构和代码进行修改，仅仅新增一个扩展即可。
扩展实现方式 一般来说，系统会采用 Factory、IoC、OSGI 等方式管理扩展(插件)生命周期。考虑到 Dubbo 的适用面，不想强依赖 Spring 等 IoC 容器。 而自己造一个小的 IoC 容器，也觉得有点过度设计，所以选择最简单的 Factory 方式管理扩展(插件)。在 Dubbo 中，所有内部实现和第三方实现都是平等的。
Dubbo 中的可扩展性 平等对待第三方的实现。在 Dubbo 中，所有内部实现和第三方实现都是平等的，用户可以基于自身业务需求，替换 Dubbo 提供的原生实现。 每个扩展点只封装一个变化因子，最大化复用。每个扩展点的实现者，往往都只是关心一件事。如果用户有需求需要进行扩展，那么只需要对其关注的扩展点进行扩展就好，极大的减少用户的工作量。 Dubbo 扩展的特性 Dubbo 中的扩展能力是从 JDK 标准的 SPI 扩展点发现机制加强而来，它改进了 JDK 标准的 SPI 以下问题：
JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。 如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK 标准的 ScriptEngine，通过 getName() 获取脚本类型的名称，但如果 RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby 脚本时，会报不支持 ruby，而不是真正失败的原因。 用户能够基于 Dubbo 提供的扩展能力，很方便基于自身需求扩展其他协议、过滤器、路由等。下面介绍下 Dubbo 扩展能力的特性。</description></item><item><title>路由扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/router/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/router/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 从多个服务提供方中选择一个进行调用。
扩展接口 org.apache.dubbo.rpc.cluster.RouterFactory org.apache.dubbo.rpc.cluster.Router 已知扩展 org.apache.dubbo.rpc.cluster.router.ScriptRouterFactory org.apache.dubbo.rpc.cluster.router.FileRouterFactory org.apache.dubbo.rpc.cluster.router.condition.config.AppRouterFactory org.apache.dubbo.rpc.cluster.CacheableRouterFactory org.apache.dubbo.rpc.cluster.router.condition.ConditionRouterFactory org.apache.dubbo.rpc.cluster.router.mock.MockRouterFactory org.apache.dubbo.rpc.cluster.router.condition.config.ServiceRouterFactory org.apache.dubbo.rpc.cluster.router.tag.TagRouterFactory 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxRouterFactory.java (实现RouterFactory接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.RouterFactory (纯文本文件，内容为：xxx=com.xxx.XxxRouterFactory) XxxRouterFactory.java：
package com.xxx; import org.apache.dubbo.rpc.cluster.RouterFactory; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.RpcException; public class XxxRouterFactory implements RouterFactory { public Router getRouter(URL url) { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.RouterFactory：
xxx=com.xxx.XxxRouterFactory</description></item><item><title>路由扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/router/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/router/</guid><description>扩展说明 从多个服务提供方中选择一个进行调用。
扩展接口 org.apache.dubbo.rpc.cluster.RouterFactory org.apache.dubbo.rpc.cluster.Router 已知扩展 org.apache.dubbo.rpc.cluster.router.ScriptRouterFactory org.apache.dubbo.rpc.cluster.router.FileRouterFactory org.apache.dubbo.rpc.cluster.router.condition.config.AppRouterFactory org.apache.dubbo.rpc.cluster.CacheableRouterFactory org.apache.dubbo.rpc.cluster.router.condition.ConditionRouterFactory org.apache.dubbo.rpc.cluster.router.mock.MockRouterFactory org.apache.dubbo.rpc.cluster.router.condition.config.ServiceRouterFactory org.apache.dubbo.rpc.cluster.router.tag.TagRouterFactory 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxRouterFactory.java (实现RouterFactory接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.RouterFactory (纯文本文件，内容为：xxx=com.xxx.XxxRouterFactory) XxxRouterFactory.java：
package com.xxx; import org.apache.dubbo.rpc.cluster.RouterFactory; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.RpcException; public class XxxRouterFactory implements RouterFactory { public Router getRouter(URL url) { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.RouterFactory：
xxx=com.xxx.XxxRouterFactory</description></item><item><title>路由扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/router/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/router/</guid><description>扩展说明 从多个服务提供方中选择一个进行调用。
扩展接口 org.apache.dubbo.rpc.cluster.RouterFactory org.apache.dubbo.rpc.cluster.Router 已知扩展 org.apache.dubbo.rpc.cluster.router.ScriptRouterFactory org.apache.dubbo.rpc.cluster.router.FileRouterFactory org.apache.dubbo.rpc.cluster.router.condition.config.AppRouterFactory org.apache.dubbo.rpc.cluster.CacheableRouterFactory org.apache.dubbo.rpc.cluster.router.condition.ConditionRouterFactory org.apache.dubbo.rpc.cluster.router.mock.MockRouterFactory org.apache.dubbo.rpc.cluster.router.condition.config.ServiceRouterFactory org.apache.dubbo.rpc.cluster.router.tag.TagRouterFactory 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxRouterFactory.java (实现RouterFactory接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.RouterFactory (纯文本文件，内容为：xxx=com.xxx.XxxRouterFactory) XxxRouterFactory.java：
package com.xxx; import org.apache.dubbo.rpc.cluster.RouterFactory; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.RpcException; public class XxxRouterFactory implements RouterFactory { public Router getRouter(URL url) { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.RouterFactory：
xxx=com.xxx.XxxRouterFactory</description></item><item><title>配置项参考手册</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config/properties/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config/properties/</guid><description>JVM(-D) 参数 JVM 参数 示例值 说明 dubbo.{config-name}.{property} -Ddubbo.application.name=&amp;ldquo;dubbo-demo&amp;rdquo;-Ddubbo.registry.address=&amp;ldquo;nacos://host:port&amp;rdquo;-Ddubbo.protocol.port=&amp;ldquo;20880&amp;rdquo;&amp;hellip;&amp;hellip; Dubbo支持 所有的配置项 以JVM参数格式指定。其中config 是指如 application、registry、protocol 等配置项，而property则是指每个配置项中的具体属性。 dubbo.resolve.file -Ddubbo.resolve.file=/home/ken/&amp;hellip;/dubbo-resolve.properties 在文件中指定每个接口的直连地址url，如：org.apache.dubbo.demo.DemoService=tri://127.0.0.1:50051/org.apache.dubbo.demo.DemoService?xxx=xxx org.graalvm.nativeimage.imagecode https://github.com/oracle/graal/blob/master/sdk/src/org.graalvm.nativeimage/src/org/graalvm/nativeimage/ImageInfo.java dubbo.properties.file -Ddubbo.properties.file=foo.properties 指定 properties 配置文件地址，可以是绝对路径或者classpath相对路径。默认值为 dubbo.properties dubbo.jstack-dump.max-line -Ddubbo.jstack-dump.max-line=20 Dubbo 支持自动打印调用堆栈，这个参数可以控制堆栈行数，如示例中只会打印前20行堆栈 dubbo.json-framework.prefer -Ddubbo.json-framework.prefer=gson 设置框架中 json 序列化的具体实现，目前可选实现有 fastjson2、fastjson、gson、jackson。默认情况，框架会自动查找可用实现，以上按顺序优先级依次降低 dubbo.network.interface.ignored -Ddubbo.network.interface.ignored=eth1,eth2 在多网卡环境下，当需要手动控制注册到注册中心的网卡地址时使用。用于排除某些网卡 dubbo.network.interface.preferred -Ddubbo.network.interface.ignored=eth0 在多网卡环境下，当需要手动控制注册到注册中心的网卡地址时使用。用于指定一个特定网卡 sun.rmi.transport.tcp.responseTimeout -Dsun.rmi.transport.tcp.responseTimeout=5000 用于设置 RMI 协议下的超时时间，单位ms env Apollo 配置中心特有参数 app.id Apollo 配置中心特有参数 apollo.cluster Apollo 配置中心特有参数 apollo.meta Apollo 配置中心特有参数 dubbo.mapping.cache.filePath -Ddubbo.mapping.cache.filePath=~/.dubbo/mapping/ 用于设置接口-应用映射关系缓存文件，通常用于服务发现。文件绝对路径地址 dubbo.mapping.cache.fileName -Ddubbo.mapping.cache.fileName=dubbo-mapping 用于设置接口-应用映射关系缓存文件，通常用于服务发现。文件名，如此示例最终会读取和存储在文件 dubbo-mapping.dubbo.cache dubbo.mapping.cache.entrySize -Ddubbo.mapping.cache.maxFileSize=300 用于设置接口-应用映射关系缓存文件，通常用于服务发现。文件名中内容最大条目数限制 dubbo.mapping.cache.maxFileSize -Ddubbo.mapping.cache.maxFileSize=104857600 用于设置接口-应用映射关系缓存文件，通常用于服务发现。文件最大占用空间限制，单位byte dubbo.</description></item><item><title>Admin 文档管理功能介绍</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/control-plane/documentation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/control-plane/documentation/</guid><description>// TBD</description></item><item><title>一些设计上的基本常识</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/principals/general-knowledge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/principals/general-knowledge/</guid><description>最近给团队新人讲了一些设计上的常识，可能会对其它的新人也有些帮助，把暂时想到的几条，先记在这里。
API 与 SPI 分离 框架或组件通常有两类客户，一个是使用者，一个是扩展者。API (Application Programming Interface) 是给使用者用的，而 SPI (Service Provide Interface) 是给扩展者用的。在设计时，尽量把它们隔离开，而不要混在一起。也就是说，使用者是看不到扩展者写的实现的。
比如：一个 Web 框架，它有一个 API 接口叫 Action，里面有个 execute() 方法，是给使用者用来写业务逻辑的。然后，Web 框架有一个 SPI 接口给扩展者控制输出方式，比如用 velocity 模板输出还是用 json 输出等。如果这个 Web 框架使用一个都继承 Action 的 VelocityAction 和一个 JsonAction 做为扩展方式，要用 velocity 模板输出的就继承 VelocityAction，要用 json 输出的就继承 JsonAction，这就是 API 和 SPI 没有分离的反面例子，SPI 接口混在了 API 接口中。
合理的方式是，有一个单独的 Renderer 接口，有 VelocityRenderer 和 JsonRenderer 实现，Web 框架将 Action 的输出转交给 Renderer 接口做渲染输出。
服务域/实体域/会话域分离 任何框架或组件，总会有核心领域模型，比如：Spring 的 Bean，Struts 的 Action，Dubbo 的 Service，Napoli 的 Queue 等等。这个核心领域模型及其组成部分称为实体域，它代表着我们要操作的目标本身。实体域通常是线程安全的，不管是通过不变类，同步状态，或复制的方式。</description></item><item><title>应用级服务发现 vs 接口级服务发现</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/service-discovery-application-vs-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/service-discovery-application-vs-interface/</guid><description>Dubbo3 目前支持，其中接口级服务发现
应用级服务发现 设计目标 显著降低服务发现过程的资源消耗，包括提升注册中心容量上限、降低消费端地址解析资源占用等，使得 Dubbo3 框架能够支持更大规模集群的服务治理，实现无限水平扩容。 适配底层基础设施服务发现模型，如 Kubernetes、Service Mesh 等。 对比接口级 我们从 Dubbo 最经典的工作原理图说起，Dubbo 从设计之初就内置了服务地址发现的能力，Provider 注册地址到注册中心，Consumer 通过订阅实时获取注册中心的地址更新，在收到地址列表后，consumer 基于特定的负载均衡策略发起对 provider 的 RPC 调用。
在这个过程中：
每个 Provider 通过特定的 key 向注册中心注册本机可访问地址； 注册中心通过这个 key 对 provider 实例地址进行聚合； Consumer 通过同样的 key 从注册中心订阅，以便及时收到聚合后的地址列表； 这里，我们对接口级地址发现的内部数据结构进行详细分析。
首先，看右下角 provider 实例内部的数据与行为。Provider 部署的应用中通常会有多个 Service，也就是 Dubbo2 中的服务，每个 service 都可能会有其独有的配置，我们所讲的 service 服务发布的过程，其实就是基于这个服务配置生成地址 URL 的过程，生成的地址数据如图所示；同样的，其他服务也都会生成地址。
然后，看一下注册中心的地址数据存储结构，注册中心以 service 服务名为数据划分依据，将一个服务下的所有地址数据都作为子节点进行聚合，子节点的内容就是实际可访问的ip地址，也就是我们 Dubbo 中 URL，格式就是刚才 provider 实例生成的。
这里把 URL 地址数据划分成了几份：
首先是实例可访问地址，主要信息包含 ip port，是消费端将基于这条数据生成 tcp 网络链接，作为后续 RPC 数据的传输载体 其次是 RPC 元数据，元数据用于定义和描述一次 RPC 请求，一方面表明这条地址数据是与某条具体的 RPC 服务有关的，它的版本号、分组以及方法相关信息，另一方面表明 下一部分是 RPC 配置数据，部分配置用于控制 RPC 调用的行为，还有一部分配置用于同步 Provider 进程实例的状态，典型的如超时时间、数据编码的序列化方式等。 最后一部分是自定义的元数据，这部分内容区别于以上框架预定义的各项配置，给了用户更大的灵活性，用户可任意扩展并添加自定义元数据，以进一步丰富实例状态。 结合以上两页对于 Dubbo2 接口级地址模型的分析，以及最开始的 Dubbo 基本原理图，我们可以得出这么几条结论：</description></item><item><title>只订阅</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/subscribe-only/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/subscribe-only/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
为方便开发测试，经常会在线下共用一个所有服务可用的注册中心，这时，如果一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。
可以让服务提供者开发方，只订阅服务(开发的服务可能依赖其它服务)，而不注册正在开发的服务，通过直连测试正在开发的服务。
禁用注册配置
&amp;lt;dubbo:registry address=&amp;#34;10.20.153.10:9090&amp;#34; register=&amp;#34;false&amp;#34; /&amp;gt; 或者
&amp;lt;dubbo:registry address=&amp;#34;10.20.153.10:9090?register=false&amp;#34; /&amp;gt;</description></item><item><title>只订阅</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/subscribe-only/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/subscribe-only/</guid><description>背景 为方便开发测试，经常会在线下共用一个所有服务可用的注册中心，这时，如果一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。
可以让服务提供者开发方，只订阅服务(开发的服务可能依赖其它服务)，而不注册正在开发的服务，通过直连测试正在开发的服务。
示例 禁用注册配置
&amp;lt;dubbo:registry address=&amp;#34;10.20.153.10:9090&amp;#34; register=&amp;#34;false&amp;#34; /&amp;gt; 或者
&amp;lt;dubbo:registry address=&amp;#34;10.20.153.10:9090?register=false&amp;#34; /&amp;gt;</description></item><item><title>0-7 - 未找到反射类</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/7/</guid><description>可能的原因 一般是 Class.forName(className) 执行此方法时，找不到 className 当前类。 业务代码上显示排除了当前 className 类，导致加载时未找到。 排查和解决步骤 检查 Class.forName(className) 中，className 是否存在。 排查业务代码，有没有使用配置或扫描注解 exclude 排除了一些类或包。</description></item><item><title>1-7 - 通知注册事件失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/7/</guid><description>可能的原因 在应用于基于 xDS 协议的相关平台时，在更新元数据时，需要通知 consumer ，如果某个 consumer 离线会导致通知失败，并移除对应 consumer 的 listener。 排查和解决步骤 另请参阅 注册中心-配置项参考手册</description></item><item><title>2-7 - 条件路由执行异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/7/</guid><description>可能的原因 条件路由规则未按照规范配置，导致执行条件路由筛选时执行异常。 排查和解决步骤 参照社区请求路由示例。</description></item><item><title>3-7 - 服务端响应结果超时</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/3/7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/3/7/</guid><description>服务端未在客户端设定的时间内获得响应。
可能的原因 服务端的业务处理逻辑较复杂，无法在有效时间内响应。 服务端与客户端的连接断开，网络丢包。 服务端负荷过高。 排查和解决步骤 检查服务端的业务处理能力是否确实存在性能瓶颈。 网络是否正常。 可通过一些第三方的工具或者jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>4-7 - 关闭客户端时发生错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/7/</guid><description>可能的原因 见于各种 Connect Client 进行close或者destory的时候报错，不影响最终效果。
排查和解决步骤 可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>5-7 - 取消导出时发生意外错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/7/</guid><description>可能的原因 配置中心的服务无法连接。 配置的协议、IP、端口不正确。 使用配置中心客户端版本与服务端版本冲突，无法建立有效连接。 排查和解决步骤 检查配置中心的服务状态是否正常。 检查配置的协议、IP、端口不正确。 检查使用的配置中心客户端版本与服务端版本是否兼容。</description></item><item><title>6-7 - 线程连接数超限警告</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/7/</guid><description>可能的原因 连接数超过限制时的提醒消息,配置或连接数超过配置数的警告提醒。
排查和解决步骤 默认配置项 connect.queue.warning.size=1000,可通过配置进行调整。</description></item><item><title>7-7 - QOS 无权限访问</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/7/7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/7/7/</guid><description>可能的原因 本次 QoS 请求无权限访问对应的资源，通常出现在有恶意攻击的场景下
排查和解决步骤 检查请求是否是预期发生的，如果非预期请检查是否有恶意攻击源。
如果是预期的，请参考 QoS 安全 一文配置对应的权限信息。</description></item><item><title>API 参考手册</title><link>https://dubbo.apache.org/zh-cn/docs/references/api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/api/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo 的常规功能，都保持零侵入，但有些功能不得不用 API 侵入才能实现。
提示 Dubbo 中除这里声明以外的接口或类，都是内部接口或扩展接口，普通用户请不要直接依赖，否则升级版本可能出现不兼容。 API 汇总如下：
配置 API org.apache.dubbo.config.ServiceConfig org.apache.dubbo.config.ReferenceConfig org.apache.dubbo.config.ProtocolConfig org.apache.dubbo.config.RegistryConfig org.apache.dubbo.config.MonitorConfig org.apache.dubbo.config.ApplicationConfig org.apache.dubbo.config.ModuleConfig org.apache.dubbo.config.ProviderConfig org.apache.dubbo.config.ConsumerConfig org.apache.dubbo.config.MethodConfig org.apache.dubbo.config.ArgumentConfig 详细参见：API配置
注解 API org.apache.dubbo.config.annotation.DubboService org.apache.dubbo.config.annotation.DubboReference 详细参见：注解配置
模型 API org.apache.dubbo.common.URL org.apache.dubbo.rpc.RpcException 上下文 API org.apache.dubbo.rpc.RpcContext 详细参见：上下文信息 &amp;amp; 隐式传参 &amp;amp; 异步调用
服务 API org.apache.dubbo.rpc.service.GenericService org.apache.dubbo.rpc.service.GenericException 详细参见：泛化引用 &amp;amp; 泛化实现
org.apache.dubbo.rpc.service.EchoService 详细参见：回声测试</description></item><item><title>API 参考手册</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/api/</guid><description>Dubbo 的常规功能，都保持零侵入，但有些功能不得不用 API 侵入才能实现。
提示 Dubbo 中除这里声明以外的接口或类，都是内部接口或扩展接口，普通用户请不要直接依赖，否则升级版本可能出现不兼容。 API 汇总如下：
配置 API org.apache.dubbo.config.ServiceConfig org.apache.dubbo.config.ReferenceConfig org.apache.dubbo.config.ProtocolConfig org.apache.dubbo.config.RegistryConfig org.apache.dubbo.config.MonitorConfig org.apache.dubbo.config.ApplicationConfig org.apache.dubbo.config.ModuleConfig org.apache.dubbo.config.ProviderConfig org.apache.dubbo.config.ConsumerConfig org.apache.dubbo.config.MethodConfig org.apache.dubbo.config.ArgumentConfig 详细参见：API配置
注解 API org.apache.dubbo.config.annotation.Service org.apache.dubbo.config.annotation.Reference 详细参见：注解配置
模型 API org.apache.dubbo.common.URL org.apache.dubbo.rpc.RpcException 上下文 API org.apache.dubbo.rpc.RpcContext 详细参见：上下文信息 &amp;amp; 隐式传参 &amp;amp; 异步调用
服务 API org.apache.dubbo.rpc.service.GenericService org.apache.dubbo.rpc.service.GenericException 详细参见：泛化引用 &amp;amp; 泛化实现
org.apache.dubbo.rpc.service.EchoService 详细参见：回声测试</description></item><item><title>filter拦截器</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/rpc/filter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/rpc/filter/</guid><description>Filter 过滤器动态拦截请求（request）或响应（response）以转换或使用请求或响应中包含的信息。过滤器本身通常不会创建响应，而是提供可以“附加”到任何一次 RPC 请求的通用函数。Dubbo Filter 是可插拔的，我们可以在一次 RPC 请求中插入任意类型的、任意多个 Filter。
Filter 工作原理如下图所示：
使用方式 1. Filter 拦截器概念 Filter 定义如下：
// Filter interface defines the functions of a filter // Extension - Filter type Filter interface { // Invoke is the core function of a filter, it determines the process of the filter Invoke(context.Context, protocol.Invoker, protocol.Invocation) protocol.Result // OnResponse updates the results from Invoke and then returns the modified results. OnResponse(context.Context, protocol.Result, protocol.Invoker, protocol.</description></item><item><title>Gson</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/dubbo/gson/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/dubbo/gson/</guid><description>1 介绍 Gson是Google公司发布的一个开放源代码的Java库，主要用途为序列化Java对象为JSON字符串，或反序列化JSON字符串成Java对象。
2 使用方式 2.1 添加依赖 &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-serialization-gson&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.google.code.gson&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;gson&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.10.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 2.2 配置启用 # application.yml (Spring Boot) dubbo: protocol: serialization: gson 或
# dubbo.properties dubbo.protocol.serialization=gson # or dubbo.consumer.serialization=gson # or dubbo.reference.com.demo.DemoService.serialization=gson 或
&amp;lt;dubbo:protocol serialization=&amp;#34;gson&amp;#34; /&amp;gt; &amp;lt;!-- or --&amp;gt; &amp;lt;dubbo:consumer serialization=&amp;#34;gson&amp;#34; /&amp;gt; &amp;lt;!-- or --&amp;gt; &amp;lt;dubbo:reference interface=&amp;#34;xxx&amp;#34; serialization=&amp;#34;gson&amp;#34; /&amp;gt;</description></item><item><title>Thrift协议</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/others/thrift/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/others/thrift/</guid><description>特性说明 当前 dubbo 支持的 thrift 协议是对 thrift 原生协议的扩展，在原生协议的基础上添加了一些额外的头信息，比如 service name，magic number 等。2.3.0 以上版本支持。
Thrift 是 Facebook 捐给 Apache 的一个 RPC 框架。
使用 dubbo thrift 协议同样需要使用 thrift 的 idl compiler 编译生成相应的 java 代码，后续版本中会在这方面做一些增强。
使用场景 适用于 SOA 标准 RPC 框架。
使用方式 依赖 从 Dubbo 3 开始，Thrift 协议已经不再内嵌在 Dubbo 中，需要单独引入独立的模块。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-rpc-native-thrift&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.thrift&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;libthrift&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.8.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 所有服务共用一个端口 与原生 Thrift 不兼容
&amp;lt;dubbo:protocol name=&amp;#34;thrift&amp;#34; port=&amp;#34;3030&amp;#34; /&amp;gt; dubbo 项目中的示例代码
Thrift 不支持 null 值，即：不能在协议中传递 null 值</description></item><item><title>triple-rest用户手册</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/tripe-rest-manual/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/tripe-rest-manual/</guid><description>注意 从 Dubbo 3.3 版本开始，原 Rest 协议已移至 Extensions 库，由 Triple 协议来对 Rest 提供更全面的支持，如需继续使用原 Rest 协议， 可引入对应 dubbo-spi-extensions 库依赖 前言 从 Dubbo 3.3 版本开始，Triple 协议重用已有的 HTTP 协议栈，实现了全面的 REST 风格服务导出能力。无需使用泛化或网关层协议转换，无需配置，用户即可通过 HTTP 协议去中心化直接访问后端的 Triple 协议服务。同时，针对高级 REST 用法，如路径定制、输出格式定制和异常处理，提供了丰富的注解和 SPI 扩展支持。其主要特性包括：
Triple协议融合
重用Triple原有HTTP协议栈， 无需额外配置或新增端口，即可同时支持 HTTP/1、HTTP/2 和 HTTP/3 协议的访问。 去中心化
可直接对外暴露 Rest API，不再依赖网关应用进行流量转发，从而提升性能，并降低因网关引发的稳定性风险。安全问题可通过应用内部扩展解决，这一实践已在淘宝内部的 MTOP 中得到验证。 支持已有servlet设施
支持 Servlet API 和 Filter，用户可以重用现有基于 Servlet API 的安全组件。通过实现一个 Servlet Filter，即可集成 OAuth 和 Spring Security 等安全框架。 多种方言
考虑到大部分用户习惯使用 SpringMVC 或 JAX-RS 进行 REST API 开发，Triple Rest 允许继续沿用这些方式定义服务，并支持大部分扩展和异常处理机制（具备原框架 80% 以上的功能）。对于追求轻量级的用户，可使用 Basic 方言，Triple 的开箱即用 REST 访问能力即基于此方言导出服务。 扩展能力强</description></item><item><title>测试覆盖率向导</title><link>https://dubbo.apache.org/zh-cn/contact/contributor/test-coverage-guide_dev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/contact/contributor/test-coverage-guide_dev/</guid><description>写单元测试的收益 单元测试能帮助每个人深入代码细节，了解代码的功能。 通过测试用例我们能发现bug，并提交代码的健壮性。 测试用例同时也是代码的demo用法。 单元测试用例的一些设计原则 应该精心设计好步骤，颗粒度和组合条件。 注意边界条件。 单元测试也应该好好设计，不要写无用的代码。 当你发现一个方法很难写单元测试时，如果可以确认这个方法是臭代码，那么就和开发者一起重构它。 Dubbo中用的mock框架是: mockito. 下面是一些开发向导:mockito tutorial,mockito refcard TDD（可选）：当你开始写一个新的功能时，你可以试着先写测试用例。 测试覆盖率设定值 在现阶段，Delta更改代码的测试覆盖设定值为：&amp;gt;＝60%，越高越好。 我们可以在这个页面中看到测试报告: https://codecov.io/gh/apache/dubbo</description></item><item><title>泛化调用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/sourcecode/generic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/sourcecode/generic/</guid><description>1. Dubbo-go 泛化调用 Java Server 使用 Triple 协议 + hessian2 序列化方案
1.1 Java-Server启动 传输结构定义 package org.apache.dubbo; import java.io.Serializable; import java.util.Date; public class User implements Serializable { private String id; private String name; private int age; private Date time = new Date(); } 接口定义 package org.apache.dubbo; import java.util.ArrayList; import java.util.List; import java.util.Map; //import org.apache.dubbo.rpc.filter.GenericFilter; public interface UserProvider { User GetUser1(String userId); } 1.2 Go-Client 泛化调用 此处展示以 API 的形式构造泛化接口引用
// 初始化 Reference 配置 refConf := config.</description></item><item><title>负载均衡扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/load-balance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/load-balance/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 从多个服务提供方中选择一个进行调用
扩展接口 org.apache.dubbo.rpc.cluster.LoadBalance
扩展配置 &amp;lt;dubbo:protocol loadbalance=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置loadbalance时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider loadbalance=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.rpc.cluster.loadbalance.RandomLoadBalance org.apache.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance org.apache.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance org.apache.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance org.apache.dubbo.rpc.cluster.loadbalance.ShortestResponseLoadBalance 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxLoadBalance.java (实现LoadBalance接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.LoadBalance (纯文本文件，内容为：xxx=com.xxx.XxxLoadBalance) XxxLoadBalance.java：
package com.xxx; import org.apache.dubbo.rpc.cluster.LoadBalance; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.RpcException; public class XxxLoadBalance implements LoadBalance { public &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; select(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, Invocation invocation) throws RpcException { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.LoadBalance：
xxx=com.xxx.XxxLoadBalance</description></item><item><title>负载均衡扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/load-balance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/load-balance/</guid><description>扩展说明 从多个服务提供方中选择一个进行调用
扩展接口 org.apache.dubbo.rpc.cluster.LoadBalance
扩展配置 &amp;lt;dubbo:protocol loadbalance=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置loadbalance时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider loadbalance=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.rpc.cluster.loadbalance.RandomLoadBalance org.apache.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance org.apache.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance org.apache.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance org.apache.dubbo.rpc.cluster.loadbalance.ShortestResponseLoadBalance 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxLoadBalance.java (实现LoadBalance接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.LoadBalance (纯文本文件，内容为：xxx=com.xxx.XxxLoadBalance) XxxLoadBalance.java：
package com.xxx; import org.apache.dubbo.rpc.cluster.LoadBalance; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.RpcException; public class XxxLoadBalance implements LoadBalance { public &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; select(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, Invocation invocation) throws RpcException { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.LoadBalance：
xxx=com.xxx.XxxLoadBalance</description></item><item><title>负载均衡扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/load-balance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/load-balance/</guid><description>扩展说明 从多个服务提供方中选择一个进行调用
扩展接口 org.apache.dubbo.rpc.cluster.LoadBalance
扩展配置 &amp;lt;dubbo:protocol loadbalance=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置loadbalance时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider loadbalance=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.rpc.cluster.loadbalance.RandomLoadBalance org.apache.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance org.apache.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance org.apache.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance org.apache.dubbo.rpc.cluster.loadbalance.ShortestResponseLoadBalance 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxLoadBalance.java (实现LoadBalance接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.LoadBalance (纯文本文件，内容为：xxx=com.xxx.XxxLoadBalance) XxxLoadBalance.java：
package com.xxx; import org.apache.dubbo.rpc.cluster.LoadBalance; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.RpcException; public class XxxLoadBalance implements LoadBalance { public &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; select(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, Invocation invocation) throws RpcException { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.LoadBalance：
xxx=com.xxx.XxxLoadBalance</description></item><item><title>观测服务</title><link>https://dubbo.apache.org/zh-cn/overview/what/core-features/observability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/core-features/observability/</guid><description>Dubbo 内部维护了多个纬度的可观测指标，并且支持多种方式的可视化监测。可观测性指标从总体上来说分为三个度量纬度：
Admin Admin 控制台可视化展示了集群中的应用、服务、实例及依赖关系，支持流量治理规则下发，同时还提供如服务测试、mock、文档管理等提升研发测试效率的工具。
Metrics Dubbo 统计了一系列的流量指标如 QPS、RT、成功请求数、失败请求数等，还包括一系列的内部组件状态如线程池数、服务健康状态等。
Tracing Dubbo 与业界主流的链路追踪工作做了适配，包括 Skywalking、Zipkin、Jaeger 都支持 Dubbo 服务的链路追踪。
Logging Dubbo 支持多种日志框架适配。以 Java 体系为例，支持包括 Slf4j、Log4j2、Log4j、Logback、Jcl 等，用户可以基于业务需要选择合适的框架；同时 Dubbo 还支持 Access Log 记录请求踪迹。
Admin Admin 控制台可视化展示了集群中的应用、服务、实例及依赖关系，支持流量治理规则下发，同时还提供如服务测试、mock、文档管理等提升研发测试效率的工具
Admin 部署与效果演示 Metrics Dubbo 运行时统计了包括 qps、rt、调用总数、成功数、失败数，失败原因统计等在内的核心服务指标，同时，为了更好的监测服务运行状态，Dubbo 还提供了对核心组件状态的监控，如线程池数量、服务健康状态等。
可以通过 Grafana 可视化的查看 Metrics 指标
使用 Grafana 可视化展示 Metrics 指标 如何从 Prometheus 查询特定 Metrics 指标 Tracing 全链路追踪对于监测分布式系统运行状态具有非常重要的价值，Dubbo 通过 Filter 拦截器实现了请求运行时的埋点跟踪，通过将跟踪数据导出到一些主流实现如 Zipkin、Skywalking、Jaeger 等，可以实现全链路跟踪数据的分析与可视化展示。
未来我们计划支持通过 Dubbo Admin 等治理平台动态调整 Dubbo 的链路追踪采样率。
基于 Skywalking 实现全链路追踪 基于 Zipkin 实现全链路追踪 通过链路追踪关联日志系统 Logging 访问日志可以帮助分析系统的流量情况，在有些场景下，开启访问日志对于排查问题也非常有帮助。</description></item><item><title>集群</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/cluster/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/cluster/</guid><description>1.简介 为了避免单点故障，现在的应用通常至少会部署在两台服务器上。对于一些负载比较高的服务，会部署更多的服务器。这样，在同一环境下的服务提供者数量会大于1。对于服务消费者来说，同一环境下出现了多个服务提供者。这时会出现一个问题，服务消费者需要决定选择哪个服务提供者进行调用。另外服务调用失败时的处理措施也是需要考虑的，是重试呢，还是抛出异常，亦或是只打印异常等。为了处理这些问题，Dubbo 定义了集群接口 Cluster 以及 Cluster Invoker。集群 Cluster 用途是将多个服务提供者合并为一个 Cluster Invoker，并将这个 Invoker 暴露给服务消费者。这样一来，服务消费者只需通过这个 Invoker 进行远程调用即可，至于具体调用哪个服务提供者，以及调用失败后如何处理等问题，现在都交给集群模块去处理。集群模块是服务提供者和服务消费者的中间层，为服务消费者屏蔽了服务提供者的情况，这样服务消费者就可以专心处理远程调用相关事宜。比如发请求，接受服务提供者返回的数据等。这就是集群的作用。
Dubbo 提供了多种集群实现，包含但不限于 Failover Cluster、Failfast Cluster 和 Failsafe Cluster 等。每种集群实现类的用途不同，接下来会一一进行分析。
2. 集群容错 在对集群相关代码进行分析之前，这里有必要先来介绍一下集群容错的所有组件。包含 Cluster、Cluster Invoker、Directory、Router 和 LoadBalance 等。
集群工作过程可分为两个阶段，第一个阶段是在服务消费者初始化期间，集群 Cluster 实现类为服务消费者创建 Cluster Invoker 实例，即上图中的 merge 操作。第二个阶段是在服务消费者进行远程调用时。以 FailoverClusterInvoker 为例，该类型 Cluster Invoker 首先会调用 Directory 的 list 方法列举 Invoker 列表（可将 Invoker 简单理解为服务提供者）。Directory 的用途是保存 Invoker，可简单类比为 List&amp;lt;Invoker&amp;gt;。其实现类 RegistryDirectory 是一个动态服务目录，可感知注册中心配置的变化，它所持有的 Invoker 列表会随着注册中心内容的变化而变化。每次变化后，RegistryDirectory 会动态增删 Invoker，并调用 Router 的 route 方法进行路由，过滤掉不符合路由规则的 Invoker。当 FailoverClusterInvoker 拿到 Directory 返回的 Invoker 列表后，它会通过 LoadBalance 从 Invoker 列表中选择一个 Invoker。最后 FailoverClusterInvoker 会将参数传给 LoadBalance 选择出的 Invoker 实例的 invoke 方法，进行真正的远程调用。</description></item><item><title>基于权重值的比例流量转发</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/weight/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/weight/</guid><description>Dubbo 提供了基于权重的负载均衡算法，可以实现按比例的流量分布：权重高的提供者机器收到更多的请求流量，而权重低的机器收到相对更少的流量。
以基于权重的流量调度算法为基础，通过规则动态调整单个或一组机器的权重，可以在运行态改变请求流量的分布，实现动态的按比例的流量路由，这对于一些典型场景非常有用。
当某一组机器负载过高，通过动态调低权重可有效减少新请求流入，改善整体成功率的同时给高负载机器提供喘息之机。 刚刚发布的新版本服务，先通过赋予新版本低权重控制少量比例的流量进入，待验证运行稳定后恢复正常权重，并完全替换老版本。 服务多区域部署或非对等部署时，通过高、低权重的设置，控制不同部署区域的流量比例。 开始之前 部署 Shop 商城项目 部署并打开 Dubbo Admin 任务详情 示例项目中，我们发布了 Order 服务 v2 版本，并在 v2 版本中优化了下单体验：用户订单创建完成后，显示订单收货地址信息。
现在如果你体验疯狂下单 (不停的点击 &amp;ldquo;Buy Now&amp;rdquo;)，会发现 v1 与 v2 总体上是 50% 概率出现，说明两者目前具有相同的默认权重。但我们为了保证商城系统整体稳定性，接下来会先控制引导 20% 流量到 v2 版本，80% 流量依然访问 v1 版本。
实现 Order 服务 80% v1 、20% v2 的流量分布 在调整权重前，首先我们要知道 Dubbo 实例的权重 (weight) 都是绝对值，每个实例的默认权重 (weight) 是 100。举个例子，如果一个服务部署有两个实例：实例 A 权重值为 100，实例 B 权重值为 200，则 A 和 B 收到的流量分布为 1:2。
接下来，我们就开始调整订单服务访问 v1 和 v2 的流量比例，订单创建服务由 org.</description></item><item><title>设计实现的健壮性</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/principals/robustness/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/principals/robustness/</guid><description>Dubbo 作为远程服务暴露、调用和治理的解决方案，是应用运转的经络，其本身实现健壮性的重要程度是不言而喻的。
这里列出一些 Dubbo 用到的原则和方法。
日志 日志是发现问题、查看问题一个最常用的手段。日志质量往往被忽视，没有日志使用上的明确约定。重视 Log 的使用，提高 Log 的信息浓度。日志过多、过于混乱，会导致有用的信息被淹没。
要有效利用这个工具要注意：
严格约定WARN、ERROR级别记录的内容 WARN 表示可以恢复的问题，无需人工介入。 ERROR 表示需要人工介入问题。 有了这样的约定，监管系统发现日志文件的中出现 ERROR 字串就报警，又尽量减少了发生。过多的报警会让人疲倦，使人对报警失去警惕性，使 ERROR 日志失去意义。再辅以人工定期查看 WARN 级别信息，以评估系统的“亚健康”程度。
日志中，尽量多的收集关键信息 哪些是关键信息呢？
出问题时的现场信息，即排查问题要用到的信息。如服务调用失败时，要给出使用 Dubbo 的版本、服务提供者的 IP、使用的是哪个注册中心；调用的是哪个服务、哪个方法等等。这些信息如果不给出，那么事后人工收集的，问题过后现场可能已经不能复原，加大排查问题的难度。 如果可能，给出问题的原因和解决方法。这让维护和问题解决变得简单，而不是寻求精通者（往往是实现者）的帮助。 同一个或是一类问题不要重复记录多次 同一个或是一类异常日志连续出现几十遍的情况，还是常常能看到的。人眼很容易漏掉淹没在其中不一样的重要日志信息。要尽量避免这种情况。在可以预见会出现的情况，有必要加一些逻辑来避免。
如为一个问题准备一个标志，出问题后打日志后设置标志，避免重复打日志。问题恢复后清除标志。
虽然有点麻烦，但是这样做保证日志信息浓度，让监控更有效。
界限设置 资源是有限的，CPU、内存、IO 等等。不要因为外部的请求、数据不受限的而崩溃。
线程池(ExectorService)的大小和饱和策略 Server 端用于处理请求的 ExectorService 设置上限。ExecutorService 的任务等待队列使用有限队列，避免资源耗尽。当任务等待队列饱和时，选择一个合适的饱和策略。这样保证平滑劣化。
在 Dubbo 中，饱和策略是丢弃数据，等待结果也只是请求的超时。
达到饱和时，说明已经达到服务提供方的负荷上限，要在饱和策略的操作中日志记录这个问题，以发出监控警报。记得注意不要重复多次记录哦。（注意，缺省的饱和策略不会有这些附加的操作。）根据警报的频率，已经决定扩容调整等等，避免系统问题被忽略。
集合容量 如果确保进入集合的元素是可控的且是足够少，则可以放心使用。这是大部分的情况。如果不能保证，则使用有有界的集合。当到达界限时，选择一个合适的丢弃策略。
容错-重试-恢复 高可用组件要容忍其依赖组件的失败。
Dubbo 的服务注册中心 目前服务注册中心使用了数据库来保存服务提供者和消费者的信息。注册中心集群不同注册中心也通过数据库来进行同步数据，以感知其它注册中心上提供者的变化。注册中心会在内存中保存一份提供者和消费者数据，数据库不可用时，注册中心独立对外提供服务以保证正常运转，只是拿不到其它注册中心的数据。当数据库恢复时，重试逻辑会将内存中修改的数据写回数据库，并拿到数据库中新数据。
服务的消费者 服务消费者从注册中心拿到提供者列表后，会保存提供者列表到内存和磁盘文件中。这样注册中心宕机后消费者可以正常运转，甚至可以在注册中心宕机过程中重启消费者。消费者启动时，发现注册中心不可用，会读取保存在磁盘文件中提供者列表。重试逻辑保证注册中心恢复后，更新信息。
重试延迟策略 上一点的子问题。Dubbo 中碰到有两个相关的场景。
数据库上的活锁 注册中心会定时更新数据库一条记录的时间戳，这样集群中其它的注册中心感知它是存活。过期注册中心和它的相关数据 会被清除。数据库正常时，这个机制运行良好。但是数据库负荷高时，其上的每个操作都会很慢。这就出现：
A 注册中心认为 B 过期，删除 B 的数据。 B 发现自己的数据没有了，重新写入自己的数据的反复操作。这些反复的操作又加重了数据库的负荷，恶化问题。</description></item><item><title>性能采样命令</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/introduction/profiler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/introduction/profiler/</guid><description>性能采样功能可以对 Dubbo 处理链路上的各处耗时进行检测，在出现超时的时候 ( usageTime / timeout &amp;gt; profilerWarnPercent * 100 ) 通过日志记录调用的耗时。
此功能分为 simple profiler 和 detail profiler 两个模式，其中 simple profiler 模式默认开启，detail profiler 模式默认关闭。 detail profiler 相较 simple profiler 模式多采集了每个 filter 的处理耗时、协议上的具体耗时等。 在 simple profiler 模式下如果发现 Dubbo 框架内部存在耗时长的情况，可以开启 detail profiler 模式，以便更好地排查问题。
请求耗时采样
enableSimpleProfiler 命令 开启 simple profiler 模式，默认开启
dubbo&amp;gt;enableSimpleProfiler OK dubbo&amp;gt; disableSimpleProfiler 命令 关闭 simple profiler 模式，关闭后 detail profiler 也将不启用
dubbo&amp;gt;disableSimpleProfiler OK dubbo&amp;gt; enableDetailProfiler 命令 开启 detail profiler 模式，默认关闭，需要开启 simple profiler 模式才会真实开启</description></item><item><title>0-8 - 反射失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/8/</guid><description>可能的原因 在反射调用某方法时，未对当前方法设置正确的参数类型值，也就是参数类型不匹配。
排查和解决步骤 检查是否存在未正确设置相匹配的类型值。</description></item><item><title>1-8 - 销毁时注销（取消订阅）地址失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/8/</guid><description>可能的原因 可能是注册中心宕机导致造成的消费者注销或者取消订阅时出现错误。 可能是对应的 provider 未能成功发布。 排查和解决步骤 排查注册中心是否在正常运行。 排查 provider 是否成功发布。 排查 provider 的注册中心相关参数比如 registry config-center metadata-report是否配置正确。 另请参阅 配置项参考手册</description></item><item><title>2-8 - 提供方返回异常响应</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/8/</guid><description>可能的原因 提供方自身处理结果抛出异常。 排查和解决步骤 检查提供方程序是否正常。</description></item><item><title>3-8 - 代理失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/3/8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/3/8/</guid><description>生成动态代理失败。
可能的原因 存在动态类加载 类格式异常 排查和解决步骤 如果日志中提示 Fallback to use JDK proxy success， 则意味着 Dubbo 自动回落到 JDK 代理后成功创建动态代理了，如果程序正常运行，则可以忽略 如果日志中提示 Fallback to use JDK proxy is also failed， 请根据异常堆栈信息检查对应的类加载情况是否正常，可以通过 arthas 等工具辅助排查</description></item><item><title>4-8 - 关闭服务端时发生错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/8/</guid><description>可能的原因 与4-7相似，都是发生在close时。
排查和解决步骤 可通过一些第三方的工具或者jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>5-8 - 协议将使用随机可用端口</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/8/</guid><description>可能的原因 协议指定的端口被占用，随机选择端口进行启动。
排查和解决步骤 检查当前配置端口是否被其它应用程序占用。</description></item><item><title>6-8 - 返回数据解码失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/8/</guid><description>可能的原因 返回数据格式错误或解码失败
排查和解决步骤 可通过 debug/warn 日志模式，输出具体服务类名称和返回的消息及堆栈信息。</description></item><item><title>Kryo</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/dubbo/kryo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/dubbo/kryo/</guid><description>1 介绍 Kryo是一种非常成熟的序列化实现，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用。
2 使用方式 2.1 添加依赖 &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-serialization-kryo&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.esotericsoftware&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;kryo&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.4.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;de.javakaffee&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;kryo-serializers&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.45&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 2.2 配置启用 # application.yml (Spring Boot) dubbo: protocol: serialization: kryo 或
# dubbo.properties dubbo.protocol.serialization=kryo # or dubbo.consumer.serialization=kryo # or dubbo.reference.com.demo.DemoService.serialization=kryo 或
&amp;lt;dubbo:protocol serialization=&amp;#34;kryo&amp;#34; /&amp;gt; &amp;lt;!-- or --&amp;gt; &amp;lt;dubbo:consumer serialization=&amp;#34;kryo&amp;#34; /&amp;gt; &amp;lt;!-- or --&amp;gt; &amp;lt;dubbo:reference interface=&amp;#34;xxx&amp;#34; serialization=&amp;#34;kryo&amp;#34; /&amp;gt; 3 注册被序列化类 要让Kryo和FST完全发挥出高性能，最好将那些需要被序列化的类注册到dubbo系统中，实现如下
回调接口
public class SerializationOptimizerImpl implements SerializationOptimizer { public Collection&amp;lt;Class&amp;gt; getSerializableClasses() { List&amp;lt;Class&amp;gt; classes = new LinkedList&amp;lt;Class&amp;gt;(); classes.</description></item><item><title>Rmi协议</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/others/rmi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/others/rmi/</guid><description>特性说明 RMI 协议采用 JDK 标准的 java.rmi.* 实现，采用阻塞式短连接和 JDK 标准序列化方式。
连接个数：多连接 连接方式：短连接 传输协议：TCP 传输方式：同步传输 序列化：Java 标准二进制序列化 适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。 适用场景：常规远程服务方法调用，与原生RMI服务互操作 约束 参数及返回值需实现 Serializable 接口 dubbo 配置中的超时时间对 RMI 无效，需使用 java 启动参数设置：-Dsun.rmi.transport.tcp.responseTimeout=3000，参见下面的 RMI 配置 使用场景 是 Java 的一组拥护开发分布式应用程序的 API，实现了不同操作系统之间程序的方法调用。
使用方式 引入依赖 从 Dubbo 3 开始，RMI 协议已经不再内嵌在 Dubbo 中，需要单独引入独立的模块。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-rpc-rmi&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; java -Dsun.rmi.transport.tcp.responseTimeout=3000 更多 RMI 优化参数请查看 JDK 文档
接口说明 如果服务接口继承了 java.rmi.Remote 接口，可以和原生 RMI 互操作，即：
提供者用 Dubbo 的 RMI 协议暴露服务，消费者直接用标准 RMI 接口调用， 或者提供方用标准 RMI 暴露服务，消费方用 Dubbo 的 RMI 协议调用。 如果服务接口没有继承 java.</description></item><item><title>调用触发事件通知</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/events-notify/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/events-notify/</guid><description>特性说明 在调用之前、调用之后、出现异常时，会触发 oninvoke、onreturn、onthrow 三个事件，可以配置当事件发生时，通知哪个类的哪个方法。
使用场景 调用服务方法前我们可以记录开始时间，调用结束后统计整个调用耗费，发生异常时我们可以告警或打印错误日志或者调用服务前后记录请求日志、响应日志等。
参考用例 dubbo-samples-notify
使用方式 服务提供者与消费者共享服务接口 interface IDemoService { public Person get(int id); } 服务提供者实现 class NormalDemoService implements IDemoService { public Person get(int id) { return new Person(id, &amp;#34;charles`son&amp;#34;, 4); } } 服务提供者配置 &amp;lt;dubbo:application name=&amp;#34;rpc-callback-demo&amp;#34; /&amp;gt; &amp;lt;dubbo:registry address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;demoService&amp;#34; class=&amp;#34;org.apache.dubbo.callback.implicit.NormalDemoService&amp;#34; /&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;org.apache.dubbo.callback.implicit.IDemoService&amp;#34; ref=&amp;#34;demoService&amp;#34; version=&amp;#34;1.0.0&amp;#34; group=&amp;#34;cn&amp;#34;/&amp;gt; 服务消费者 Callback 接口 interface Notify { public void onreturn(Person msg, Integer id); public void onthrow(Throwable ex, Integer id); } 服务消费者 Callback 实现 class NotifyImpl implements Notify { public Map&amp;lt;Integer, Person&amp;gt; ret = new HashMap&amp;lt;Integer, Person&amp;gt;(); public Map&amp;lt;Integer, Throwable&amp;gt; errors = new HashMap&amp;lt;Integer, Throwable&amp;gt;(); public void onreturn(Person msg, Integer id) { System.</description></item><item><title>泛化调用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/sourcecode/generic-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/sourcecode/generic-2/</guid><description>1. Dubbogo 泛化调用 Java Server 使用 Triple 协议 + hessian2 序列化方案
可参考Dubbogo 3.0 泛化调用文档
1.1 Java-Server启动 传输结构定义 package org.apache.dubbo; import java.io.Serializable; import java.util.Date; public class User implements Serializable { private String id; private String name; private int age; private Date time = new Date(); } 接口定义 package org.apache.dubbo; import java.util.ArrayList; import java.util.List; import java.util.Map; //import org.apache.dubbo.rpc.filter.GenericFilter; public interface UserProvider { User GetUser1(String userId); } 1.2 Go-Client 泛化调用 此处展示以 API 的形式构造泛化接口引用</description></item><item><title>在大促之前对弱依赖调用进行服务降级</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/mock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/mock/</guid><description>由于微服务系统的分布式特性，一个服务往往需要依赖非常多的外部服务来实现某一项功能，因此，一个服务的稳定性不但取决于其自身，同时还取决于所有外部依赖的稳定性。我们可以根据这些依赖的重要程度将它们划分为强依赖和弱依赖：强依赖是指那些无论如何都要保证稳定性的服务，如果它们不可用则当前服务也就不可用；弱依赖项指当它们不可用之后当前服务仍能正常工作的依赖项，弱依赖不可用只是影响功能的部分完整性。
服务降级的核心目标就是针对这些弱依赖项。在弱依赖不可用或调用失败时，通过返回降级结果尽可能的维持功能完整性；另外，我们有时也会主动的屏蔽一些非关键弱依赖项的调用，比如在大促流量洪峰之前，通过预先设置一些有效的降级策略来短路部分依赖调用，来有效的提升流量高峰时期系统的整体效率和稳定性。
开始之前 部署 Shop 商城项目 部署并打开 Dubbo Admin 任务详情 正常情况下，商品详情页会展示来自顾客的商品评论信息。
评论信息的缺失在很多时候并不会影响用户浏览和购买商品，因此，我们定义评论信息属于商品详情页面的弱依赖。接下来，我们就模拟在大促前夕常用的一个策略，通过服务降级提前关闭商品详情页对于评论服务的调用（返回一些本地预先准备好的历史评论数据），来降低集群整体负载水位并提高响应速度。
通过降级规则短路 Comment 评论服务调用 评论数据由 Comment 应用的 org.apache.dubbo.samples.CommentService 服务提供，接下来我们就为 CommentService 配置降级规则。
操作步骤 打开 Dubbo Admin 控制台 在左侧导航栏选择【流量管控】&amp;gt;【服务降级】 点击 &amp;ldquo;创建&amp;rdquo;，输入服务 org.apache.dubbo.samples.CommentService 和降级规则。 等待降级规则推送完成之后，刷新商品详情页面，发现商品评论信息已经变为我们预先设置的 &amp;ldquo;Mock Comment&amp;rdquo;，因为商品详情页的 Comment 服务调用已经在本地短路，并没有真正的发送到后端服务提供者机器上。
再次刷新页面
规则详解 规则 key ：org.apache.dubbo.samples.CommentService
规则体
configVersion: v3.0 enabled: true configs: - side: consumer parameters: mock: force:return Mock Comment 清理 为了不影响其他任务效果，通过 Admin 删除或者禁用刚刚配置的降级规则。
其他事项 服务降级功能也可以用于开发测试环境，由于微服务分布式的特点，不同的服务或应用之间都有相互依赖关系，因此，一个服务或应用很难不依赖其他服务而独立部署工作。但测试环境下并不是所有服务都是随时就绪的状态，这对于微服务强调的服务独立演进是一个很大的障碍，通过服务降级这个功能，我们可以模拟或短路应用对其他服务的依赖，从而可以让应用按照自己预期的行为 Mock 外部服务调用的返回结果。具体可参见 Dubbo Admin 服务 Mock 特性的使用方式。
Dubbo 的降级规则用来设置发生降级时的行为和返回值，而对于何时应该执行限流降级动作，即限流降级时机的判断并没有过多涉猎，这一点 Dubbo 通过集成更专业的限流降级产品如 Sentinel 进行了补全，可以配合 Dubbo 降级规则一起使用，具体可参见 限流降级 文档。</description></item><item><title>负载均衡</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/loadbalance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/source/loadbalance/</guid><description>1.简介 LoadBalance 中文意思为负载均衡，它的职责是将网络请求，或者其他形式的负载“均摊”到不同的机器上。避免集群中部分服务器压力过大，而另一些服务器比较空闲的情况。通过负载均衡，可以让每台服务器获取到适合自己处理能力的负载。在为高负载服务器分流的同时，还可以避免资源浪费，一举两得。负载均衡可分为软件负载均衡和硬件负载均衡。在我们日常开发中，一般很难接触到硬件负载均衡。但软件负载均衡还是可以接触到的，比如 Nginx。在 Dubbo 中，也有负载均衡的概念和相应的实现。Dubbo 需要对服务消费者的调用请求进行分配，避免少数服务提供者负载过大。服务提供者负载过大，会导致部分请求超时。因此将负载均衡到每个服务提供者上，是非常必要的。Dubbo 提供了4种负载均衡实现，分别是基于权重随机算法的 RandomLoadBalance、基于最少活跃调用数算法的 LeastActiveLoadBalance、基于 hash 一致性的 ConsistentHashLoadBalance，以及基于加权轮询算法的 RoundRobinLoadBalance。这几个负载均衡算法代码不是很长，但是想看懂也不是很容易，需要大家对这几个算法的原理有一定了解才行。如果不是很了解，也没不用太担心。我们会在分析每个算法的源码之前，对算法原理进行简单的讲解，帮助大家建立初步的印象。
本系列文章在编写之初是基于 Dubbo 2.6.4 的，近期，Dubbo 2.6.5 发布了，其中就有针对对负载均衡部分的优化。因此我们在分析完 2.6.4 版本后的源码后，会另外分析 2.6.5 更新的部分。其他的就不多说了，进入正题吧。
2.源码分析 在 Dubbo 中，所有负载均衡实现类均继承自 AbstractLoadBalance，该类实现了 LoadBalance 接口，并封装了一些公共的逻辑。所以在分析负载均衡实现之前，先来看一下 AbstractLoadBalance 的逻辑。首先来看一下负载均衡的入口方法 select，如下：
@Override public &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; select(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, URL url, Invocation invocation) { if (invokers == null || invokers.isEmpty()) return null; // 如果 invokers 列表中仅有一个 Invoker，直接返回即可，无需进行负载均衡 if (invokers.size() == 1) return invokers.get(0); // 调用 doSelect 方法进行负载均衡，该方法为抽象方法，由子类实现 return doSelect(invokers, url, invocation); } protected abstract &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; doSelect(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, URL url, Invocation invocation); select 方法的逻辑比较简单，首先会检测 invokers 集合的合法性，然后再检测 invokers 集合元素数量。如果只包含一个 Invoker，直接返回该 Inovker 即可。如果包含多个 Invoker，此时需要通过负载均衡算法选择一个 Invoker。具体的负载均衡算法由子类实现，接下来章节会对这些子类一一进行详细分析。</description></item><item><title>合并结果扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/merger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/merger/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 合并返回结果，用于分组聚合。
扩展接口 org.apache.dubbo.rpc.cluster.Merger
扩展配置 &amp;lt;dubbo:method merger=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.rpc.cluster.merger.ArrayMerger org.apache.dubbo.rpc.cluster.merger.ListMerger org.apache.dubbo.rpc.cluster.merger.SetMerger org.apache.dubbo.rpc.cluster.merger.MapMerger org.apache.dubbo.rpc.cluster.merger.ByteArrayMerger org.apache.dubbo.rpc.cluster.merger.CharArrayMerger org.apache.dubbo.rpc.cluster.merger.ShortArrayMerger org.apache.dubbo.rpc.cluster.merger.IntArrayMerger org.apache.dubbo.rpc.cluster.merger.LongArrayMerger org.apache.dubbo.rpc.cluster.merger.FloatArrayMerger org.apache.dubbo.rpc.cluster.merger.DoubleArrayMerger org.apache.dubbo.rpc.cluster.merger.BooleanArrayMerger 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxMerger.java (实现Merger接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.Merger (纯文本文件，内容为：xxx=com.xxx.XxxMerger) XxxMerger.java：
package com.xxx; import org.apache.dubbo.rpc.cluster.Merger; public class XxxMerger&amp;lt;T&amp;gt; implements Merger&amp;lt;T&amp;gt; { public T merge(T... results) { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.Merger：
xxx=com.xxx.XxxMerger</description></item><item><title>合并结果扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/merger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/merger/</guid><description>扩展说明 合并返回结果，用于分组聚合。
扩展接口 org.apache.dubbo.rpc.cluster.Merger
扩展配置 &amp;lt;dubbo:method merger=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.rpc.cluster.merger.ArrayMerger org.apache.dubbo.rpc.cluster.merger.ListMerger org.apache.dubbo.rpc.cluster.merger.SetMerger org.apache.dubbo.rpc.cluster.merger.MapMerger org.apache.dubbo.rpc.cluster.merger.ByteArrayMerger org.apache.dubbo.rpc.cluster.merger.CharArrayMerger org.apache.dubbo.rpc.cluster.merger.ShortArrayMerger org.apache.dubbo.rpc.cluster.merger.IntArrayMerger org.apache.dubbo.rpc.cluster.merger.LongArrayMerger org.apache.dubbo.rpc.cluster.merger.FloatArrayMerger org.apache.dubbo.rpc.cluster.merger.DoubleArrayMerger org.apache.dubbo.rpc.cluster.merger.BooleanArrayMerger 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxMerger.java (实现Merger接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.Merger (纯文本文件，内容为：xxx=com.xxx.XxxMerger) XxxMerger.java：
package com.xxx; import org.apache.dubbo.rpc.cluster.Merger; public class XxxMerger&amp;lt;T&amp;gt; implements Merger&amp;lt;T&amp;gt; { public T merge(T... results) { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.Merger：
xxx=com.xxx.XxxMerger</description></item><item><title>合并结果扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/merger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/merger/</guid><description>扩展说明 合并返回结果，用于分组聚合。
扩展接口 org.apache.dubbo.rpc.cluster.Merger
扩展配置 &amp;lt;dubbo:method merger=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.rpc.cluster.merger.ArrayMerger org.apache.dubbo.rpc.cluster.merger.ListMerger org.apache.dubbo.rpc.cluster.merger.SetMerger org.apache.dubbo.rpc.cluster.merger.MapMerger org.apache.dubbo.rpc.cluster.merger.ByteArrayMerger org.apache.dubbo.rpc.cluster.merger.CharArrayMerger org.apache.dubbo.rpc.cluster.merger.ShortArrayMerger org.apache.dubbo.rpc.cluster.merger.IntArrayMerger org.apache.dubbo.rpc.cluster.merger.LongArrayMerger org.apache.dubbo.rpc.cluster.merger.FloatArrayMerger org.apache.dubbo.rpc.cluster.merger.DoubleArrayMerger org.apache.dubbo.rpc.cluster.merger.BooleanArrayMerger 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxMerger.java (实现Merger接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.Merger (纯文本文件，内容为：xxx=com.xxx.XxxMerger) XxxMerger.java：
package com.xxx; import org.apache.dubbo.rpc.cluster.Merger; public class XxxMerger&amp;lt;T&amp;gt; implements Merger&amp;lt;T&amp;gt; { public T merge(T... results) { // ... } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.Merger：
xxx=com.xxx.XxxMerger</description></item><item><title>集群容错</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/fault-tolerent-strategy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/fault-tolerent-strategy/</guid><description>背景 在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。
各节点关系：
这里的 Invoker 是 Provider 的一个可调用 Service 的抽象，Invoker 封装了 Provider 地址及 Service 接口信息 Directory 代表多个 Invoker，可以把它看成 List&amp;lt;Invoker&amp;gt; ，但与 List 不同的是，它的值可能是动态变化的，比如注册中心推送变更 Cluster 将 Directory 中的多个 Invoker 伪装成一个 Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个 Router 负责从多个 Invoker 中按路由规则选出子集，比如读写分离，应用隔离等 LoadBalance 负责从多个 Invoker 中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选 集群容错模式 可以自行扩展集群容错策略，参见：集群扩展
Failover Cluster 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=&amp;quot;2&amp;quot; 来设置重试次数(不含第一次)。
重试次数配置如下：
&amp;lt;dubbo:service retries=&amp;#34;2&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:reference retries=&amp;#34;2&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:reference&amp;gt; &amp;lt;dubbo:method name=&amp;#34;findFoo&amp;#34; retries=&amp;#34;2&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; 提示 该配置为缺省配置 Failfast Cluster 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。
Failsafe Cluster 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</description></item><item><title>路由状态命令</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/introduction/router-snapshot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/introduction/router-snapshot/</guid><description>Dubbo 的很多流量治理能力是基于 Router 进行实现的，在生产环境中，如果出现流量结果不符合预期的情况，可以通过路由状态命令来查看路由的状态，以此来定位可能存在的问题。
路由状态采集
getRouterSnapshot 命令 获取当前的每层路由的分组状态。（仅支持 StateRouter）
命令：getRouterSnapshot {serviceName}
serviceName 为需要采集的服务名，支持匹配
dubbo&amp;gt;getRouterSnapshot com.dubbo.dubbointegration.BackendService com.dubbo.dubbointegration.BackendService@2c2e824a [ All Invokers:2 ] [ Valid Invokers: 2 ] MockInvokersSelector Total: 2 [ Mocked -&amp;gt; Empty (Total: 0) ] [ Normal -&amp;gt; 172.18.111.187:20880,172.18.111.183:20880 (Total: 2) ] ↓ StandardMeshRuleRouter not support ↓ TagStateRouter not support ↓ ServiceStateRouter not support ↓ AppStateRouter not support ↓ TailStateRouter End dubbo&amp;gt; enableRouterSnapshot 命令 开启路由结果采集模式
命令：enableRouterSnapshot {serviceName}
serviceName 为需要采集的服务名，支持匹配
dubbo&amp;gt;enableRouterSnapshot com.</description></item><item><title>认证鉴权</title><link>https://dubbo.apache.org/zh-cn/overview/what/core-features/security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/core-features/security/</guid><description>Dubbo 提供了构建安全微服务通信体系 (零信任体系) 的完善机制，这包括：
避免通信过程中的中间人攻击，Dubbo 提供了身份认证 (Authentication) 和基于 TLS 的通信链路加密能力 控制服务间的访问鉴权 (Authorization)，Dubbo 提供了 mTLS 和权限检查机制 通过这篇文档，你将了解如果使用 Dubbo 的安全机制构建微服务零信任体系，实现身份认证、透明链路加密、鉴权、审计等能力。由于构建零信任是一套系统的工作，而 Dubbo 只是其中数据通信层的一环，因此你可能需要一系列基础设施的配合，包括证书生成、分发、安全策略管控等。
证书的生成和分发不在本文讨论范围，我们假设您已经有完善的基础设施解决了证书管理问题，因此，我们将更专注在讲解 Dubbo 体系的认证和鉴权机制与流程。 如果您并没有这些证书管理设施，我们推荐您使用服务网格架构 (具体请参见 Dubbo Mesh 服务网格 文档说明)，借助 Istio 等服务网格控制面的证书管理机制和安全策略，您可以很容易将 Dubbo 集群的认证和鉴权能力实施起来。
另外，以下默认讲的都是 Dubbo Proxyless Mesh 模式下的 Dubbo 数据面行为，对于部署 Envoy 的场景，由于 Dubbo 只是作为通信和编程 sdk，因此 Envoy 场景下认证鉴权能力请完全参考标准 Istio 文档即可。
架构 一套完整的零信任体系包含多个组成部分：
一个根证书机构 (CA) 来负责管理 key 和 certificate 一个安全策略的管理和分发中心，来负责将安全策略实时下发给数据面组件： 认证策略 鉴权策略 安全命名信息 (Secure Naming Information) 数据面组件 (Dubbo) 负责识别和执行身份认证、加密、策略解析等动作 一系列的工具和生态，配合完成安全审计、数据链路监控等工作 在服务网格 (Istio) 部署模式下，控制面通常负责安全策略、证书等的管理，控制面负责与基础设施如 Kubernetes API Server 等交互，将配置数据下发给 Dubbo 或者 Envoy 等数据面组件。但如我们前面提到的，我们假设控制面产品已经就绪，因此不会涉及控制面如何签发证书、定义认证鉴权策略的讨论，我们将专注在 Dubbo 作为数据面的职责及与控制面的交互流程上。</description></item><item><title>0-9 - 通知事件失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/9/</guid><description>可能的原因 自定义的监听器，在处理上产生了运行时异常。
排查和解决步骤 检查实现 org.apache.dubbo.rpc.ExporterListener 接口的业务类，实现方法可能存在代码逻辑错误。</description></item><item><title>1-9 - 读写注册中心服务缓存失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/9/</guid><description>可能的原因 多个 Dubbo 进程（或其他 Java 进程）使用了同一个缓存文件。 由于缓存文件所在目录的文件系统权限问题，导致读写失败。 dubbo.registry.file 的值输入错误。 不小心指定了两个注册中心使用同一文件存储。 提示： 如未指定 dubbo.registry.file，则注册中心服务缓存路径默认为 ~/.dubbo 目录 （其中 ~ 为用户的 HOME 目录）
排查和解决步骤 检查 dubbo.registry.file 的值有无拼写错误。 检查是否有其它进程使用了同一份缓存文件。 如果指定了 dubbo.registry.file，那么检查下它在文件系统的权限。 排查是否出现了“两个注册中心使用了同一文件存储” 这一情况，如果出现则调整。 另请参阅 注册中心的配置项参考手册</description></item><item><title>2-9 - 增加超时检查任务失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/9/</guid><description>可能的原因 Dubbo 框架会对请求调用增加一个超时检查任务，增加超时检查任务失败。 排查和解决步骤 该异常为 Dubbo 框架自身异常，请在社区提 Issue ，提供环境现场信息及复现步骤。</description></item><item><title>4-9 - 解析失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/9/</guid><description>可能的原因 一般为参数值不符合规则，在强转时发生错误。 如：
String timeoutString = httpMetadata.headers().getFirst(TripleHeaderEnum.SERVICE_TIMEOUT.getHeader()); Long timeout = Long.parseLong(timeoutString); Long timeout = GrpcUtils.parseTimeoutToMills(timeoutString); invocation.put(CommonConstants.TIMEOUT_KEY, timeout); 排查和解决步骤 根据堆栈信息提示的 key 名称进行相对应的配置修改到符合转换规则即可。</description></item><item><title>5-9 - 服务配置导出失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/9/</guid><description>可能的原因 配置中心的服务无法连接。 配置的协议、IP、端口不正确。 使用配置中心客户端版本与服务端版本冲突，无法建立有效连接。 排查和解决步骤 检查配置中心的服务状态是否正常。 检查配置的协议、IP、端口不正确。 检查使用的配置中心客户端版本与服务端版本是否兼容。</description></item><item><title>6-9 - 序列号ID存在重复</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/9/</guid><description>可能的原因 返回了一个空对象。 自定义序列号类，org.apache.dubbo.common.serialize.Serialization#getContentTypeId 与系统内置存在重复， 此时在加载时，以首个加载到的 SPI 实例为准。其他项将跳过。 排查和解决步骤 检查返回结果。 内置值可参考类 org.apache.dubbo.common.serialize.Constants</description></item><item><title>MessagePack</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/dubbo/msgpack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/dubbo/msgpack/</guid><description>1 介绍 MessagePack是一种计算机数据交换格式。它是一种二进制形式，用于表示简单的数据结构，如数组和关联数组。MessagePack 旨在尽可能紧凑和简单。
2 使用方式 2.1 添加依赖 &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-serialization-msgpack&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.msgpack&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;msgpack-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.9.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.msgpack&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-dataformat-msgpack&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.9.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 2.2 配置启用 # application.yml (Spring Boot) dubbo: protocol: serialization: msgpack 或
# dubbo.properties dubbo.protocol.serialization=msgpack # or dubbo.consumer.serialization=msgpack # or dubbo.reference.com.demo.DemoService.serialization=msgpack 或
&amp;lt;dubbo:protocol serialization=&amp;#34;msgpack&amp;#34; /&amp;gt; &amp;lt;!-- or --&amp;gt; &amp;lt;dubbo:consumer serialization=&amp;#34;msgpack&amp;#34; /&amp;gt; &amp;lt;!-- or --&amp;gt; &amp;lt;dubbo:reference interface=&amp;#34;xxx&amp;#34; serialization=&amp;#34;msgpack&amp;#34; /&amp;gt;</description></item><item><title>版本管理</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/release/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/release/</guid><description>新功能的开发 和 稳定性的提高 对产品都很重要。但是添加新功能会影响稳定性，Dubbo 使用如下的版本开发模式来保障两者。
2 个版本并行开发 BugFix 版本：低版本，比如 2.4.x。是 GA 版本，线上使用的版本，只会 BugFix，升级第三位版本号。 新功能版本：高版本，比如 2.5.x。加新功能的版本，会给对新功能有需求的应用试用。 2.5.x 的新功能基本稳定后，进入 2.5.x 试用阶段。找足够多的应用试用 2.5.x 版本。
在 2.5.x 够稳定后：
2.5.x 成为 GA 版本，只 BugFix，推广使用此版本。如果版本可用，可以推进应用在期望的时间点内升级到 GA 版本。 2.4.x 不再开发，应用碰到 Bug 让直接升级。（这个称为“夕阳条款”） 从 2.5.x 拉成分支 2.6.0，作为新功能开发版本。 优势 保证 GA 版本是稳定的！因为： 只会作 BugFix 成为 GA 版本前有试用阶段 新功能可以在高版本中快速响应，并让应用能试用新功能。 不会版本过多，导致开发和维护成本剧增 用户要配合的职责 由于开发只会 BugFix GA 版本，所以用户需要积极跟进升级到 GA 版本，以 Fix 发现的问题。
定期升级版本给用户带来了不安。这是一个假命题，说明如下：
GA 经过一个试用阶段保持稳定。 GA 版本有 Bug 会火速 Fix 相对出问题才升级到 GA 版本（可能跨了多个版本）定期升级平摊风险（类似小步快跑）。经历过周期长的大项目的同学会有这样的经历，三方库版本长时间不升级，结果出了问题不得不升级到新版本（跨了多个版本）风险巨大。</description></item><item><title>多协议</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/multi-protocols/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/multi-protocols/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo 允许配置多协议，在不同服务上支持不同协议或者同一服务上同时支持多种协议。
不同服务不同协议 不同服务在性能上适用不同协议进行传输，比如大数据用短连接协议，小数据大并发用长连接协议
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;dubbo:application name=&amp;#34;world&amp;#34; /&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;registry&amp;#34; address=&amp;#34;10.20.141.150:9090&amp;#34; username=&amp;#34;admin&amp;#34; password=&amp;#34;hello1234&amp;#34; /&amp;gt; &amp;lt;!-- 多协议配置 --&amp;gt; &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;20880&amp;#34; /&amp;gt; &amp;lt;dubbo:protocol name=&amp;#34;rmi&amp;#34; port=&amp;#34;1099&amp;#34; /&amp;gt; &amp;lt;!-- 使用dubbo协议暴露服务 --&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;com.alibaba.hello.api.HelloService&amp;#34; version=&amp;#34;1.0.0&amp;#34; ref=&amp;#34;helloService&amp;#34; protocol=&amp;#34;dubbo&amp;#34; /&amp;gt; &amp;lt;!-- 使用rmi协议暴露服务 --&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;com.alibaba.hello.api.DemoService&amp;#34; version=&amp;#34;1.0.0&amp;#34; ref=&amp;#34;demoService&amp;#34; protocol=&amp;#34;rmi&amp;#34; /&amp;gt; &amp;lt;/beans&amp;gt; 多协议暴露服务 需要与 http 客户端相互操作
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.</description></item><item><title>多协议</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/multi-protocols/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/multi-protocols/</guid><description>背景 Dubbo 允许配置多协议，在不同服务上支持不同协议或者同一服务上同时支持多种协议。
示例 不同服务不同协议 不同服务在性能上适用不同协议进行传输，比如大数据用短连接协议，小数据大并发用长连接协议
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;dubbo:application name=&amp;#34;world&amp;#34; /&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;registry&amp;#34; address=&amp;#34;10.20.141.150:9090&amp;#34; username=&amp;#34;admin&amp;#34; password=&amp;#34;hello1234&amp;#34; /&amp;gt; &amp;lt;!-- 多协议配置 --&amp;gt; &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;20880&amp;#34; /&amp;gt; &amp;lt;dubbo:protocol name=&amp;#34;rmi&amp;#34; port=&amp;#34;1099&amp;#34; /&amp;gt; &amp;lt;!-- 使用dubbo协议暴露服务 --&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;com.alibaba.hello.api.HelloService&amp;#34; version=&amp;#34;1.0.0&amp;#34; ref=&amp;#34;helloService&amp;#34; protocol=&amp;#34;dubbo&amp;#34; /&amp;gt; &amp;lt;!-- 使用rmi协议暴露服务 --&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;com.alibaba.hello.api.DemoService&amp;#34; version=&amp;#34;1.0.0&amp;#34; ref=&amp;#34;demoService&amp;#34; protocol=&amp;#34;rmi&amp;#34; /&amp;gt; &amp;lt;/beans&amp;gt; 多协议暴露服务 需要与 http 客户端相互操作
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.</description></item><item><title>泛化调用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/generic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/generic/</guid><description>注意 泛化调用适用于老版本 dubbo 通信协议，如果您使用的是 3.3 及之后版本的 triple 协议，请直接使用 triple 自带的 http application/json 能力直接发起服务调用，相关示例可参考 网关接入说明。 泛化调用（客户端泛化调用）是指在调用方没有服务提供方 API（SDK）的情况下，对服务方进行调用，并且可以正常拿到调用结果。调用方没有接口及模型类元，知道服务的接口的全限定类名和方法名的情况下，可以通过泛化调用调用对应接口。
使用场景 泛化调用可通过一个通用的 GenericService 接口对所有服务发起请求。典型使用场景如下：
网关服务：如果要搭建一个网关服务，那么服务网关要作为所有 RPC 服务的调用端。但是网关本身不应该依赖于服务提供方的接口 API（这样会导致每有一个新的服务发布，就需要修改网关的代码以及重新部署），所以需要泛化调用的支持。
测试平台：如果要搭建一个可以测试 RPC 调用的平台，用户输入分组名、接口、方法名等信息，就可以测试对应的 RPC 服务。那么由于同样的原因（即会导致每有一个新的服务发布，就需要修改网关的代码以及重新部署），所以平台本身不应该依赖于服务提供方的接口 API。所以需要泛化调用的支持。
使用方式 本示例的完整源码请参考 dubbo-samples-generic-call。
示例中有以下 Dubbo 服务定义和实现
服务接口定义：
public interface HelloService { String sayHello(String name); CompletableFuture&amp;lt;String&amp;gt; sayHelloAsync(String name); CompletableFuture&amp;lt;Person&amp;gt; sayHelloAsyncComplex(String name); CompletableFuture&amp;lt;GenericType&amp;lt;Person&amp;gt;&amp;gt; sayHelloAsyncGenericComplex(String name); } 服务具体实现并发布：
@DubboService public class HelloServiceImpl implements HelloService { @Override public String sayHello(String name) { return &amp;#34;sayHello: &amp;#34; + name; } @Override public CompletableFuture&amp;lt;String&amp;gt; sayHelloAsync(String name) { // .</description></item><item><title>服务端对客户端进行回调</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/callback-parameter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/callback-parameter/</guid><description>特性说明 参数回调方式与调用本地 callback 或 listener 相同，只需要在 Spring 的配置文件中声明哪个参数是 callback 类型即可。Dubbo 将基于长连接生成反向代理，这样就可以从服务器端调用客户端逻辑。可以参考 dubbo 项目中的示例代码。
使用场景 回调函数通知客户端执行结果，或发送通知，在方法执行时间比较长时，类似异步调用，审批工作流中回调客户端审批结果。
使用方式 服务接口示例 CallbackService.java
package com.callback; public interface CallbackService { void addListener(String key, CallbackListener listener); } CallbackListener.java
package com.callback; public interface CallbackListener { void changed(String msg); } 服务提供者接口实现示例 package com.callback.impl; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Map; import java.util.concurrent.ConcurrentHashMap; import com.callback.CallbackListener; import com.callback.CallbackService; public class CallbackServiceImpl implements CallbackService { private final Map&amp;lt;String, CallbackListener&amp;gt; listeners = new ConcurrentHashMap&amp;lt;String, CallbackListener&amp;gt;(); public CallbackServiceImpl() { Thread t = new Thread(new Runnable() { public void run() { while(true) { try { for(Map.</description></item><item><title>服务网格</title><link>https://dubbo.apache.org/zh-cn/overview/what/core-features/service-mesh/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/core-features/service-mesh/</guid><description>Dubbo Mesh 是 Dubbo 在云原生背景的微服务整体解决方案，它帮助开发者实现 Dubbo 服务与标准的 Kubernetes Native Service 体系的打通，让 Dubbo 应用能够无缝接入 Istio 等业界主流服务网格产品。
以下是 Dubbo Mesh 的部署架构图
控制面。Istio 作为统一控制面，为集群提供 Kubernetes 适配、服务发现、证书管理、可观测性、流量治理等能力。 数据面。Dubbo 应用实例作为数据面组件，支持两种部署模式 Proxy 模式。Dubbo 进程与 Envoy 部署在同一 pod，进出 Dubbo 的流量都经 Envoy 代理拦截，由 Envoy 执行流量管控。 Proxyless 模式。Dubbo 进程独立部署，进程间直接通信，通过 xDS 协议与控制面直接交互。 关于服务网格架构以及为何要接入 Istio 控制面，请参考 Istio 官网，本文不包含这部分通用内容的讲解，而是会侧重在 Dubbo Mesh 解决方案本身。
Dubbo Mesh Proxy Mesh 在 proxy 模式下，Dubbo 与 Envoy 等边车 (Proxy or Sidecar) 部署在一起
以上是 Dubbo Proxy Mesh 部署架构图
Dubbo 与 Envoy 部署在同一个 Pod 中，Istio 实现对流量和治理的统一管控。 Dubbo 只提供面向业务应用的编程 API、RPC 通信能力，其余流量管控能力如地址发现、负载均衡、路由寻址等都下沉到 Envoy，Envoy 拦截所有进出流量并完成路由寻址等服务治理工作。 控制面与 Envoy 之间通过图中虚线所示的 xDS 协议进行配置分发。 在 Proxy 模式下，Dubbo3 通信层选用 Triple、gRPC、REST 等基于 HTTP 的通信协议可以获得更好的网关穿透性与性能体验。</description></item><item><title>将流量点对点引导到一台机器 (如排查问题)</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/host/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/traffic-management/host/</guid><description>自动的地址发现和负载均衡机制有很多优势，它让我们构建可伸缩的分布式微服务系统成为可能，但这种动态的流量分配也带来很多复杂性。一个典型问题是我们无法再预测一次请求具体会落到那一台提供者机器上，但有时能预期或控制请求固定的发往某一台提供者机器在一些场景下会非常有用处，比如当开发者在测试甚至线上环境排查一些复杂问题时，如果能在某一台指定的机器上稳定复现问题现象，对于最终的问题排查肯定会带来很大帮助。
开始之前 部署 Shop 商城项目 部署并打开 Dubbo Admin 任务详情 本任务我们将以 User 服务作为示例，将商城中 Frontend 应用对用户详情方法的调用 UserService#getInfo 全部导流到一台固定实例上去。
将用户详情服务调用导流到一台固定机器 首先，确定部署 User 应用的实际机器列表
$ kubectl get pods -n dubbo-demo # list result here 为 org.apache.dubbo.samples.UserService 服务的 getInfo 方法调用设置条件路由规则，所有这个方法的调用全部转发到一台指定机器。
操作步骤 打开 Dubbo Admin 控制台 在左侧导航栏选择【服务治理】&amp;gt;【条件路由】 点击 &amp;ldquo;创建&amp;rdquo;，输入服务 org.apache.dubbo.samples.UserService 。 打开机器日志，刷新页面多触发机器用户详情服务调用，可以看到只有规则中指定的实例中在持续刷新以下日志：
Received getInfo request...... 规则详解 规则 key ：org.apache.dubbo.samples.UserService
规则体
configVersion: v3.0 enabled: true force: false conditions: - &amp;#39;method=getInfo =&amp;gt; host = {your ip address}&amp;#39; 替换 {your ip address} 为 User 实际的部署地址。</description></item><item><title>使用 Pixiu 暴露 Dubbo-go 服务</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/gateway/pixiu-nacos-triple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/gateway/pixiu-nacos-triple/</guid><description>Dubbo-go-pixiu 网关支持调用 GO/Java 的 Dubbo 集群。在 Dubbo-go 3.0 的场景下，我们可以通过 Pixiu 网关，在集群外以 HTTP 协议请求 pixiu 网关，在网关层进行协议转换，进一步调用集群内的Dubbo-go 服务。
用户调用 Dubbo-go 服务的 path 为http://$(app_name)/$(service_name)/$(method)
例如一个proto文件内有如下定义：
package org.apache.dubbo.quickstart.samples; service UserProvider { rpc SayHello (HelloRequest) returns (User) {} } message HelloRequest { string name = 1; } 并在dubbo-go 服务启动时在dubbogo.yml 内配置应用名为my-dubbogo-app:
dubbo: application: name: my-dubbogo-app pixiu 网关即可解析 path 为 http://my-dubbogo-app/org.apache.dubbo.quickstart.samples.UserProvider/SayHello 的路由，并转发至对应服务。来自外部HTTP 请求的 body 为 json 序列化的请求参数，例如 {&amp;ldquo;name&amp;rdquo;:&amp;ldquo;test&amp;rdquo;}。
我们目前推荐使用 Nacos 作为注册中心。
用户可以在自己的集群里部署我们的demo，集群最好拥有暴露 lb 类型 service 的能力，从而可以在公网访问至集群内的服务，您也可以直接集群内进行请求。针对您的集群，执行：
$ kubectl apply -f https://raw.</description></item><item><title>使用方法</title><link>https://dubbo.apache.org/zh-cn/docs/references/lifecycle/brief/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/lifecycle/brief/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Pod 的生命周期 与服务调度息息相关，通过对 Kubernetes 官方探针的实现，能够使 Dubbo 乃至整个应用的生命周期与 Pod 的生命周期对齐。
通过 Dubbo 的 SPI 机制，在内部实现多种“探针”，基于 Dubbo QOS 运维模块的 HTTP 服务，使容器探针能够获取到应用内对应探针的状态。另外，SPI 的实现机制也利于用户自行拓展内部“探针”，使整个应用的生命周期更有效的进行管控。
使用方法 参考配置（具体可以参考 dubbo-samples 中 Kubernetes 注册中心的配置文件）
livenessProbe: httpGet: path: /live port: 22222 initialDelaySeconds: 5 periodSeconds: 5 readinessProbe: httpGet: path: /ready port: 22222 initialDelaySeconds: 5 periodSeconds: 5 startupProbe: httpGet: path: /startup port: 22222 failureThreshold: 30 periodSeconds: 10 目前三种探针均有对应的接口，路径为 QOS 中的命令，端口信息请根据 QOS 配置进行对应修改（默认端口为 22222）。其他参数请参考官方文档说明。
注：为了使 Kubernetes 集群能够正常访问到探针，需要开启 QOS 允许远程访问，此操作有可能带来安全风险，请仔细评估后再打开。
实现细节 三种探针对应的 SPI 接口如下：</description></item><item><title>序列化安全审计</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/introduction/security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/introduction/security/</guid><description>Dubbo 支持通过 QoS 命令实时查看当前的配置信息以及可信/不可信类列表。目前共支持两个命令：serializeCheckStatus 查看当前配置信息，serializeWarnedClasses 查看实时的告警列表。
serializeCheckStatus 命令 通过控制台直接访问：
&amp;gt; telnet 127.0.0.1 22222 Trying 127.0.0.1... Connected to localhost. Escape character is &amp;#39;^]&amp;#39;. ___ __ __ ___ ___ ____ / _ \ / / / // _ ) / _ ) / __ \ / // // /_/ // _ |/ _ |/ /_/ / /____/ \____//____//____/ \____/ dubbo&amp;gt;serializeCheckStatus CheckStatus: WARN CheckSerializable: true AllowedPrefix: ... DisAllowedPrefix: ... dubbo&amp;gt; 通过 http 请求 json 格式结果：</description></item><item><title>注册中心扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/registry/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 负责服务的注册与发现。
扩展接口 org.apache.dubbo.registry.RegistryFactory org.apache.dubbo.registry.Registry 扩展配置 &amp;lt;!-- 定义注册中心 --&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;xxx1&amp;#34; address=&amp;#34;xxx://ip:port&amp;#34; /&amp;gt; &amp;lt;!-- 引用注册中心，如果没有配置registry属性，将在ApplicationContext中自动扫描registry配置 --&amp;gt; &amp;lt;dubbo:service registry=&amp;#34;xxx1&amp;#34; /&amp;gt; &amp;lt;!-- 引用注册中心缺省值，当&amp;lt;dubbo:service&amp;gt;没有配置registry属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider registry=&amp;#34;xxx1&amp;#34; /&amp;gt; 扩展契约 RegistryFactory.java：
public interface RegistryFactory { /** * 连接注册中心. * * 连接注册中心需处理契约：&amp;lt;br&amp;gt; * 1. 当设置check=false时表示不检查连接，否则在连接不上时抛出异常。&amp;lt;br&amp;gt; * 2. 支持URL上的username:password权限认证。&amp;lt;br&amp;gt; * 3. 支持backup=10.20.153.10备选注册中心集群地址。&amp;lt;br&amp;gt; * 4. 支持file=registry.cache本地磁盘文件缓存。&amp;lt;br&amp;gt; * 5. 支持timeout=1000请求超时设置。&amp;lt;br&amp;gt; * 6. 支持session=60000会话超时或过期设置。&amp;lt;br&amp;gt; * * @param url 注册中心地址，不允许为空 * @return 注册中心引用，总不返回空 */ Registry getRegistry(URL url); } RegistryService.</description></item><item><title>注册中心扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/registry/</guid><description>扩展说明 负责服务的注册与发现。
扩展接口 org.apache.dubbo.registry.RegistryFactory org.apache.dubbo.registry.Registry 扩展配置 &amp;lt;!-- 定义注册中心 --&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;xxx1&amp;#34; address=&amp;#34;xxx://ip:port&amp;#34; /&amp;gt; &amp;lt;!-- 引用注册中心，如果没有配置registry属性，将在ApplicationContext中自动扫描registry配置 --&amp;gt; &amp;lt;dubbo:service registry=&amp;#34;xxx1&amp;#34; /&amp;gt; &amp;lt;!-- 引用注册中心缺省值，当&amp;lt;dubbo:service&amp;gt;没有配置registry属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider registry=&amp;#34;xxx1&amp;#34; /&amp;gt; 扩展契约 RegistryFactory.java：
public interface RegistryFactory { /** * 连接注册中心. * * 连接注册中心需处理契约：&amp;lt;br&amp;gt; * 1. 当设置check=false时表示不检查连接，否则在连接不上时抛出异常。&amp;lt;br&amp;gt; * 2. 支持URL上的username:password权限认证。&amp;lt;br&amp;gt; * 3. 支持backup=10.20.153.10备选注册中心集群地址。&amp;lt;br&amp;gt; * 4. 支持file=registry.cache本地磁盘文件缓存。&amp;lt;br&amp;gt; * 5. 支持timeout=1000请求超时设置。&amp;lt;br&amp;gt; * 6. 支持session=60000会话超时或过期设置。&amp;lt;br&amp;gt; * * @param url 注册中心地址，不允许为空 * @return 注册中心引用，总不返回空 */ Registry getRegistry(URL url); } RegistryService.java：
public interface RegistryService { // Registry extends RegistryService /** * 注册服务.</description></item><item><title>注册中心扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/registry/</guid><description>扩展说明 负责服务的注册与发现。
扩展接口 org.apache.dubbo.registry.RegistryFactory org.apache.dubbo.registry.Registry 扩展配置 &amp;lt;!-- 定义注册中心 --&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;xxx1&amp;#34; address=&amp;#34;xxx://ip:port&amp;#34; /&amp;gt; &amp;lt;!-- 引用注册中心，如果没有配置registry属性，将在ApplicationContext中自动扫描registry配置 --&amp;gt; &amp;lt;dubbo:service registry=&amp;#34;xxx1&amp;#34; /&amp;gt; &amp;lt;!-- 引用注册中心缺省值，当&amp;lt;dubbo:service&amp;gt;没有配置registry属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider registry=&amp;#34;xxx1&amp;#34; /&amp;gt; 扩展契约 RegistryFactory.java：
public interface RegistryFactory { /** * 连接注册中心. * * 连接注册中心需处理契约：&amp;lt;br&amp;gt; * 1. 当设置check=false时表示不检查连接，否则在连接不上时抛出异常。&amp;lt;br&amp;gt; * 2. 支持URL上的username:password权限认证。&amp;lt;br&amp;gt; * 3. 支持backup=10.20.153.10备选注册中心集群地址。&amp;lt;br&amp;gt; * 4. 支持file=registry.cache本地磁盘文件缓存。&amp;lt;br&amp;gt; * 5. 支持timeout=1000请求超时设置。&amp;lt;br&amp;gt; * 6. 支持session=60000会话超时或过期设置。&amp;lt;br&amp;gt; * * @param url 注册中心地址，不允许为空 * @return 注册中心引用，总不返回空 */ Registry getRegistry(URL url); } RegistryService.java：
public interface RegistryService { // Registry extends RegistryService /** * 注册服务.</description></item><item><title>全国首个政企采购云平台：政采云的混合云跨网方案实践</title><link>https://dubbo.apache.org/zh-cn/blog/2023/03/22/%E5%85%A8%E5%9B%BD%E9%A6%96%E4%B8%AA%E6%94%BF%E4%BC%81%E9%87%87%E8%B4%AD%E4%BA%91%E5%B9%B3%E5%8F%B0%E6%94%BF%E9%87%87%E4%BA%91%E7%9A%84%E6%B7%B7%E5%90%88%E4%BA%91%E8%B7%A8%E7%BD%91%E6%96%B9%E6%A1%88%E5%AE%9E%E8%B7%B5/</link><pubDate>Wed, 22 Mar 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/03/22/%E5%85%A8%E5%9B%BD%E9%A6%96%E4%B8%AA%E6%94%BF%E4%BC%81%E9%87%87%E8%B4%AD%E4%BA%91%E5%B9%B3%E5%8F%B0%E6%94%BF%E9%87%87%E4%BA%91%E7%9A%84%E6%B7%B7%E5%90%88%E4%BA%91%E8%B7%A8%E7%BD%91%E6%96%B9%E6%A1%88%E5%AE%9E%E8%B7%B5/</guid><description>对云岛业务结构的公司来说，云平台属于公司内部、完全可控的局域网，而岛端则是有自己安全网络策略的独立内部网络。需要云岛通信时，会基于需求，按客户要求走流程开通一些端口，这个过程需要一定的成本且不完全可控。业务上，如果这种跨网需求增多，则会逐渐变成痛点。如果可以搭建一个透明的跨网传输网络，配合良好的顶层设计，就可以在业务支撑、安全管控和运维成本中寻求较好的平衡。
本文将介绍政采云基于 Dubbo 的跨网方案落地过程中面临的技术挑战、社区合作以及更深层次抽象的一些思考。在政采云这种政企业务场景中的数据跨网，与业界公有云、自建私有云的公司相比，既有共性又有自己的特点，希望能为大家提供新的思路或者启发。
前言 稳定、高效、可靠的基础设施是互联网企业应对业务高峰流量的底层基石。作为政采云的基础技术平台，基础平台部一直致力于通过业内前沿技术的落地，保障公司内部所有业务在线生产系统所依赖的基础技术平台能稳定、安全、低成本、可持续地运行与发展。
由于公司对 Dubbo 框架的重度使用，跨网数据传输系统一般基于 Dubbo 特性开发，在政采云内部就有多个版本的实现。
早在几年前，政采云就上线了基于 Dubbo Filter 转发的方案，它解决了岛到云的单向数据传输，安全认证等问题。另外，业务部门也有按照自己的需求，推出网状点对点的方案，实现了一定程度的透明传输。
结合前两年的探索实践以及业界相关领域技术的成熟度，2022年下半年，我们对各跨岛方案，进行了整合升级，也就是现在的高速公路方案，保障跨岛标准化同时，解决了之前方案实践过程中面临的很多业务痛点，包括：
单向传输：因为架构原因，如需双向需要对等重新部署一套，成本较大。
白名单开通成本高：点对点的网状架构，需要两两开通白名单，因为政企网络特殊性，开通流程复杂且慢。
平台维护成本高：业务各自一套数据传输平台，重复建设且运维成本高。
公共功能的缺失：核心功能，业务可以按需开发，但是数据审计、链路追踪、可观测性等公共特性，往往没有足够投入。
1. 跨网数据传输系统演进 1.1 历史架构 ​
自左向右、自下而上进行模块介绍：
业务Web：业务 Web 作为数据发送方，调本地	集群 Provider 时，携带跨岛信息过去（Dubbo 上下文）。
岛业务Center：本地虚拟Provider，通过Filter拦截跨岛请求，通过http传送到云平台 Dubbo 网关，返回数据后反序列化返回岛业务 web。
Dubbo网关：接收 Http 请求，通过泛化调用云端 Provider，处理数据后返回业务 Center。
云业务Center：普通 Dubbo Provider。
1.2 高速公路架构 ​
1.2.1 隧道机制
隧道技术是一种通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。
高速公路架构中，使用了隧道这个概念。两端（业务层）是 Dubbo 私有协议，跨网传输过程中，则使用了 http 协议，http 协议可以更好的被中间设备、网关识别转发。这个机制的最大便利在于对业务的低侵入性。对于业务集群的应用完全不需要修改。 除了路由标记，出口/入口 Dubbo 协议字节流没有任何业务外信息，所以可以路由任何 Dubbo 请求。
1.2.2 主要节点
客户端 Sdk：不改变用户使用 Dubbo 的方式，多种形式提供Dubbo的路由。
**Dubbo 出口网关：**代理 Dubbo 流量出口。</description></item><item><title>Dubbo Java 3.1.4 正式发布</title><link>https://dubbo.apache.org/zh-cn/blog/2022/12/01/dubbo-java-3.1.4-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</link><pubDate>Thu, 01 Dec 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/12/01/dubbo-java-3.1.4-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</guid><description>Dubbo 3.1.4 版本是目前 Dubbo 3 的最新稳定版本，我们建议所有的用户都升级到最新的稳定版本。
Dubbo 3.1.4 新特性 Dubbo QoS 支持指定白名单 IP 列表访问所有命令 Bugfix 修复在泛化调用时 Dubbo Metrics 采集方法名错误 修复使用 Zookeeper 作为元数据中心时，上报接口映射可能存在相互覆盖的问题 修复 timeout countdown 在 Triple 协议的支持 修复 timeout countdown 存在透传的问题 修复多注册中心请求时，由于没有可用的地址导致的 NPE 问题 修复 Mesh 模式下 Triple 获取 remoteApplicationName 为空的问题 修复 GraalVM Native Image 的支持 修复端口复用时无 SSL 连接导致的 NPE 异常 完善 JDK 编译器报错日志的输出格式 修复 MetadataReportConfig 部分配置时应用无法启动的问题 修复 dubbo.reference 作为默认参数在 3.x 版本中不生效的问题 完善 Zookeeper 连接失败的日志 修复 ReferenceConfig 中配置的 ClassLoader 可能被覆盖的问题 修复部分属性在应用级服务发现时被缓存在实例级的地址中导致方法级配置失效的问题 修复 Triple 协议 onError 异常的问题 FAQ 本次发布中有 3 个提交涉及异常日志 FAQ 的完善。关于错误码机制请参考官网错误码机制介绍一文。（https://cn.</description></item><item><title>聚焦稳定性，Dubbo Java 发版规划公布</title><link>https://dubbo.apache.org/zh-cn/blog/2022/10/22/%E8%81%9A%E7%84%A6%E7%A8%B3%E5%AE%9A%E6%80%A7dubbo-java-%E5%8F%91%E7%89%88%E8%A7%84%E5%88%92%E5%85%AC%E5%B8%83/</link><pubDate>Sat, 22 Oct 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/10/22/%E8%81%9A%E7%84%A6%E7%A8%B3%E5%AE%9A%E6%80%A7dubbo-java-%E5%8F%91%E7%89%88%E8%A7%84%E5%88%92%E5%85%AC%E5%B8%83/</guid><description>Dubbo 简介 Apache Dubbo 是一款 RPC 服务开发框架，用于解决微服务架构下的服务治理与通信问题，官方提供了 Java、Golang 等多语言 SDK 实现。使用 Dubbo 开发的微服务原生具备相互之间的远程地址发现与通信能力， 利用 Dubbo 提供的丰富服务治理特性，可以实现诸如服务发现、负载均衡、流量调度等服务治理诉求。Dubbo 被设计为高度可扩展，用户可以方便的实现流量拦截、选址的各种定制逻辑。
我应该如何选择版本？ 对于这个问题，一直以来 Dubbo 都没有很好地去回答。究其原因保证所有版本的稳定性是一件非常有挑战的事情。比如在 Dubbo 2.7 的一些版本中，出现了一些前后不兼容的问题，给一些用户升级带来了困扰。为此，很多用户从保障稳定性的视角出发，选择了更保守的策略，即生产环境采用被采用最多的版本，此后就不再更新，避免升级过程中出现意外。
但是这种方式无疑是有问题的，一方面这将导致永远无法用上社区新的功能，得到技术演进的红利；另一方面，对于安全漏洞和带来不稳定因素的 bug 等已知问题如果不升级永远会存在，久而久之将给应用带来巨大的风险，很有可能导致严重的安全生产事故。
因此，为了更好地回答这个问题，Dubbo 制定了未来的版本迭代规划，明确版本的稳定性维护机制，提升开发者使用 Dubbo 的信心。
现状 在此前，Dubbo 总共维护了 2.6.x、2.7.x 以及 3.x 三个大版本，其中 2.7.x 为捐献进入 Apache 基金会之后的版本。
2.6.x 在去年已经宣布生命周期结束（EOL）了，而 2.7.x 累计维护了四年的时间了。这四年的时间里，2.7.x 版本经历了多次大的修改，如 2.7.3 版本中对 Nacos 的注册方式进行了修改、2.7.6 版本中添加了应用级服务发现、2.7.9 版本中对应用级服务发现进行大的重构等。
这些修改都对 2.7.x 版本的稳定性带来了巨大的风险隐患，导致 2.7.x 中很多版本或多或少存在不同的问题，用户无法选择一个最稳定的版本进行使用。
因此，我们希望在 3.x 版本中将这种不稳定的情况通过发版机制给收敛掉，提高 Dubbo 版本的稳定性。
未来总体规划 在接下来，Dubbo 将以每 6 个月为一个周期，对每个版本包括了新功能合入、稳定性维护以及安全漏洞修复三个大方向的内容。
新功能合入是指将 Dubbo 开发过程中所有新的特性、性能优化、破坏性修改都会被合入的行为。由于新功能是需要一段时间迭代稳定的，所以新功能的合入会给对应版本带来不稳定因素，因此只能在每个版本最开始的时候进行。</description></item><item><title>Dubbo Java 3.0.2 发版公告</title><link>https://dubbo.apache.org/zh-cn/blog/2021/07/18/dubbo-java-3.0.2-%E5%8F%91%E7%89%88%E5%85%AC%E5%91%8A/</link><pubDate>Sun, 18 Jul 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/07/18/dubbo-java-3.0.2-%E5%8F%91%E7%89%88%E5%85%AC%E5%91%8A/</guid><description>新特性 支持通过 @DubboService 注解暴露泛化服务 元数据中心xml格式的配置支持 protocol 和 port 属性 兼容 curator5 以上的版本 点对点调用支持*通配符进行匹配, 一个提供者地址可对应多个接口 为应用级别的服务发现增加动态配置去进行规则覆盖 对提供者测的动态配置覆盖规则提供开关，可以使提供者无视动态配置，不重新暴露 支持 native image 提供取消执行 shutdown hook 的开关 支持 Kubernetes Mesh 的服务治理规则 Netty 连接支持 SSL 配置 Bug 修复 DubboBootStrap start 重复调用后，动态配置被覆盖 动态配置规则被删除后，依然生效 triple 协议在暴露时会抛出空指针异常 ConfigCenterConfig.setAddress 方法会覆盖掉 username 属性 DefaultFuture.closeChannel 会销毁掉消费端测的线程池 TripleClientHandler.writeRequest 抛出空指针异常 解析3.0迁移规则异常时会抛出空指针异常 Activated Extensions 的顺序性问题 URLAddress.parse 方法在解析 ipv6 地址时存在问题 用户自定义的参数在 properties 配置中不生效 同时使用 API 模式和 Spring 模式配置时属性，Config Id 存在覆盖问题 应用级别服务发现在启动时不生效 Nacos 注册中心无法动态感知提供者的数量变化 ${dubbo.application} 在 xml 文件中无法被 spring 的 placeholder 规则给解析替换 获取实例参数的顺序问题，先去获取了实例级别参数，再去获取接口级别参数 当 DubboConfigBeanInitializer 不存在时，注册应用启动监听器会抛出异常 Mock 时 参数中包含 &amp;lsquo;:&amp;rsquo; 或者 &amp;lsquo;=&amp;rsquo; 字符时，不生效 删除 Mesh 规则时空指针异常 优化 抓住 RemovalTask 的异常，保证信号量能够释放 通过 唯一 service name 检查 ReferenceConfig/ServiceConfig 是否重复 优化生成随机数的性能 如果用户使用接口级别去做服务发现，不发布应用与接口的映射数据到元数据中心 使用 StringBuilder#append(Char) 提升性能 保证 GRPC 编译的类文件中接口的顺序 优化 reference bean 的占位符解析 MergeableClusterInvoker 中使用 CompletableFuture#get(long, TimeUnit) 去提升性能 内置服务 MetadataService 不延迟暴露 优化 ConfigBean 和 Bootstrap 的启动逻辑 优化 Config 检查是否重复的逻辑 使用 Ring 数据结构去进行注册通知 优化动态配置的初始化逻辑 ConfigManager 使用 ConcurrentHashMap 去移除锁逻辑，提升 equals 和 toString 性能 优化 MetadataInfo equals 方法 以及 Instance Listener 优化异步 export/refer 逻辑 使用 TreeSet 数据结构保证应用级别服务发现时应用名称的顺序一致 RegistryNotifier 的第一个十次通知不延迟 dubbo-compile 编译使用新的格式生成 stub Mesh 服务治理规则在动态配置中心的分组和其他规则分组统一，由 DEFAULT_GROUP 改成 dubbo 使用 nacos 用作注册中心时，可以在注册中心地址中使用参数来改变在 nacos 中的分组 计算 ServiceInfo 的 reversion 时，移除运行时参数，避免生成多个 reversion Nacos 注册中心抛出异常时，将异常封装称 RpcException 抛出 禁止动态配置中心对一些权限参数进行动态修改 优化 Config Bean 的初始化流程，并兼容 spring 3.</description></item><item><title>0-10 - 当前调用不在支持</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/10/</guid><description>可能的原因 当前调用的方法可能已经被弃用或声明了 @Deprecated，不影响执行结果。
排查和解决步骤 请使用其它可替代的 API 方法。</description></item><item><title>1-10 - 读写注册中心服务缓存失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/10/</guid><description>可能的原因 多个 Dubbo 进程使用了同一个缓存文件。 在多注册中心的情况下，指定了多个注册中心使用同一文件存储。 排查和解决步骤 该错误常与 1-9 错误共同出现。检查是否有多个 Dubbo 进程使用了同一个缓存文件或者是否指定多个注册中心使用同一缓存文件。
另请参阅 注册中心的配置项参考手册</description></item><item><title>2-10 - 调用服务提供方失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/10/</guid><description>可能的原因 Dubbo 调用服务提供方失败，并开始重试。 Dubbo 重试调用服务提供方持续失败。 Dubbo 重试调用服务提供方达到上限。 排查和解决步骤 检查消费方提供方之间网络连接耗时等网络资源。 通过 telnet 等手段检查提供方对应端口是否能正常响应。 检查提供方程序是否运行正常。</description></item><item><title>升级与可能的兼容性问题总结</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/versions/version-270/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/versions/version-270/</guid><description>环境要求：需要Java 8及以上版本。
2.7.0版本在改造的过程中遵循了一个原则，即保持与低版本的兼容性，因此从功能层面来说它是与2.6.x及更低版本完全兼容的，而接下来将要提到的兼容性问题主要是包重命名带来的。另外，虽然功能用法保持向后兼容，但参考本文能帮助您尽快用到2.7.0版本的新特性。
升级步骤 升级pom到2.7.0（以all-in-one依赖为例）。 &amp;lt;properties&amp;gt; &amp;lt;dubbo.version&amp;gt;2.7.0&amp;lt;/dubbo.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-dependencies-bom&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${dubbo.version}&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${dubbo.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.netty&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;netty-all&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 如果升级依赖后出现API或SPI扩展相关的编译错误，请参考包兼容性问题
此时重新部署应用，所有默认行为和2.6.x保持一致，如果要用到2.7的新特性，则需要继续做以下配置（可选）：
简化的URL 配置元数据中心 使用外部化配置 服务治理规则 使用异步API 下面我们就对这几部分的配置分别做详细说明。
简化的URL &amp;lt;!-- simplified=&amp;#34;true&amp;#34;表示注册简化版的URL到Registry --&amp;gt; &amp;lt;dubbo:registry address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34; simplified=&amp;#34;true&amp;#34;/&amp;gt; dubbo.registry.simplified=true 建议将此配置集中管理，参考外部化配置。
URL简化只是剔除了一些纯粹的查询用的参数，并没有做大刀阔斧的服务发现模型改造，因此精简后的URL完全可以被2.6及以下版本的消费端实现服务发现与调用，同样2.7版本也可以发现和调用低版本的提供者。
配置元数据中心 &amp;lt;dubbo:metadata-report address=&amp;#34;redis://127.0.0.1:6379&amp;#34;/&amp;gt; dubbo.metadataReport.address=redis://127.0.0.1:6379 建议将此配置集中管理，参考外部化配置。 在此了解更多元数据中心设计目的与用途。
使用外部化配置 需要在项目启动前，使用[最新版本Dubbo-OPS](https://github.com/apache/dubbo-ops)完成外部化配置迁移，理论上配置中心支持所有本地dubbo.properties所支持的配置项。 以XML开发形式为例，假设我们本地有如下配置：
&amp;lt;dubbo:application name=&amp;#34;demo-provider&amp;#34;/&amp;gt; &amp;lt;dubbo:config-center address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; &amp;lt;dubbo:registry address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34; simplified=&amp;#34;true&amp;#34;/&amp;gt; &amp;lt;dubbo:metadata-report address=&amp;#34;redis://127.0.0.1:6379&amp;#34;/&amp;gt; &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;20880&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;demoService&amp;#34; class=&amp;#34;org.</description></item><item><title>4-10 - Triple 序列化结果失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/10/</guid><description>可能的原因 一般为内部错误。 见于三种log格式：
在序列化并且发送数据时发生异常，日志格式为 Serialize triple request failed, service=%s method=%s 接收到response的reset code时触发,日志格式为：Triple Client received remote reset errorCode=xxx 处理response时有异常情况时触发，日志格式为： Meet Exception on ClientResponseHandler, status code is:xxx 排查和解决步骤 针对第一种错误，是在调用{service}#{method}方法过程中出现的，具体对应到sendMessage，并且该日志与java.util.concurrent.ExecutionException: org.apache.dubbo.rpc.StatusRpcException: INTERNAL : Serialize request failed同时出现，排查{method}方法参数中自定义类是否实现序列化接口导致序列化失败
针对第二种错误，是Provider端处理发生错误，排查Provider端服务，排查方式参考第一种错误
针对第三种错误，仅单元测试使用到，目前用户侧不会出现
其次可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。
同时请在社区提交Issue，帮助我们更好的完善Triple 直接点击右上角 提交项目问题 按钮即可快速链接至Github页面</description></item><item><title>5-10 - 服务的注册接口应用程序映射失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/10/</guid><description>可能的原因 服务暴露的服务元数据与应用程序不匹配，或被篡改。
排查和解决步骤 检查配置中心的元数据内容是否与应用程序内的匹配。</description></item><item><title>6-10 - 超过有效载荷限制异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/10/</guid><description>可能的原因 默认 payload=8M,请检查各项配置
排查和解决步骤 各组件支持的具体配置项及含义请参考 配置项手册</description></item><item><title>Dubbo HttpFilter 介绍</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/httpfilter/dubbo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/httpfilter/dubbo/</guid><description>使用 HTTP 调用 Dubbo 定义Pixiu配置文件 static_resources: listeners: - name: &amp;#34;http-listener&amp;#34; protocol_type: &amp;#34;HTTP&amp;#34; address: socket_address: address: &amp;#34;0.0.0.0&amp;#34; port: 8888 filter_chains: filters: - name: dgp.filter.httpconnectionmanager config: route_config: routes: - match: prefix: &amp;#34;*&amp;#34; http_filters: - name: dgp.filter.http.dubboproxy config: dubboProxyConfig: auto_resolve: true registries: &amp;#34;zookeeper&amp;#34;: protocol: &amp;#34;zookeeper&amp;#34; timeout: &amp;#34;3s&amp;#34; address: &amp;#34;127.0.0.1:2181&amp;#34; username: &amp;#34;&amp;#34; password: &amp;#34;&amp;#34; timeout_config: connect_timeout: 5s request_timeout: 5s clusters: - name: &amp;#34;dubbo-server&amp;#34; lb_policy: &amp;#34;lb&amp;#34; endpoints: - id: 1 socket_address: address: 127.0.0.1 port: 20000 shutdown_config: timeout: &amp;#34;60s&amp;#34; step_timeout: &amp;#34;10s&amp;#34; reject_policy: &amp;#34;immediacy&amp;#34; 准备Dubbo服务 启动zookeeper,需要提前准备好docker和compose，如果本地有的话可以忽略 docker-compose.</description></item><item><title>Dubbo 集群中心 Adapter</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/adapter/dubbo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/adapter/dubbo/</guid><description/></item><item><title>Go 快速开始</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/quick-start/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
推荐使用 IDL 定义跨语言的服务与编码格式，以下展示的是 Golang 语言版本的服务定义与开发方式，如果你有遗留系统或无多语言开发需求，可参考以下使用方式。
快速开始 通过一个 hellowworld 例子带领大家快速上手Dubbo-go框架。
协议：Dubbo 编码：Hessian2
注册中心：Zookeeper
环境 Go编程环境 启动zookeeper服务，也可以使用远程实例 从服务端开始 第一步：编写 Provider 结构体和提供服务的方法 https://github.com/dubbogo/dubbo-samples/blob/master/golang/helloworld/dubbo/go-server/app/user.go
编写需要被编码的结构体，由于使用 Hessian2 作为编码协议，User 需要实现 JavaClassName 方法，它的返回值在dubbo中对应User类的类名。 type User struct { Id string Name string Age int32 Time time.Time } func (u User) JavaClassName() string { return &amp;#34;com.ikurento.user.User&amp;#34; } 编写业务逻辑，UserProvider 相当于dubbo中的一个服务实现。需要实现 Reference 方法，返回值是这个服务的唯一标识，对应dubbo的 beans 和 path 字段。 type UserProvider struct { } func (u *UserProvider) GetUser(ctx context.Context, req []interface{}) (*User, error) { println(&amp;#34;req:%#v&amp;#34;, req) rsp := User{&amp;#34;A001&amp;#34;, &amp;#34;hellowworld&amp;#34;, 18, time.</description></item><item><title>Go 语言定义服务</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/go-specific/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/go-specific/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。</description></item><item><title>Hessian协议</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/others/hessian/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/others/hessian/</guid><description>特性说明 Hessian 协议用于集成 Hessian 的服务，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。
Hessian 是 Caucho 开源的一个 RPC 框架，其通讯效率高于 WebService 和 Java 自带的序列化。
连接个数：多连接 连接方式：短连接 传输协议：HTTP 传输方式：同步传输 序列化：Hessian二进制序列化 适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。 适用场景：页面传输，文件传输，或与原生hessian服务互操作。 Dubbo 的 Hessian 协议可以和原生 Hessian 服务互操作，即：
提供者用 Dubbo 的 Hessian 协议暴露服务，消费者直接用标准 Hessian 接口调用， 或者提供方用标准 Hessian 暴露服务，消费方用 Dubbo 的 Hessian 协议调用。 约束 参数及返回值需实现 Serializable 接口。 参数及返回值不能自定义实现 List, Map, Number, Date, Calendar 等接口，只能用 JDK 自带的实现，因为 hessian 会做特殊处理，自定义实现类中的属性值都会丢失。 使用场景 hessian是一个轻量级的RPC服务，是基于Binary-RPC协议实现的，序列化与反序列化实例。
使用方式 依赖 从 Dubbo 3 开始，Hessian 协议已经不再内嵌在 Dubbo 中，需要单独引入独立的模块。</description></item><item><title>Http Listener 介绍</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/listener/http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/listener/http/</guid><description>Http Listener 是专门负载接收 HTTP 请求的 Listener，它可以设置 HTTP 监听的地址和端口。它可以通过如下配置进行引入。
static_resources: listeners: - name: &amp;#34;net/http&amp;#34; protocol_type: &amp;#34;HTTP&amp;#34; # 表明是引入 HTTP Listener address: socket_address: address: &amp;#34;0.0.0.0&amp;#34; # 地址 port: 8883 # 端口 Http Listener 的具体实现可以参考 pkg/listener/http。
有关 HTTP Listener 的案例，可以参考：
HTTP to Dubbo 请求的转换，案例 HTTP 请求代理，案例 目前也支持 HTTPS 协议。可以将 protocol_type 修改为 HTTPS。并且添加 domains 和 certs_dir 来指定域名和 cert 文件目录。
listeners: - name: &amp;#34;net/http&amp;#34; protocol_type: &amp;#34;HTTPS&amp;#34; address: socket_address: domains: - &amp;#34;sample.domain.com&amp;#34; - &amp;#34;sample.domain-1.com&amp;#34; - &amp;#34;sample.domain-2.com&amp;#34; certs_dir: $PROJECT_DIR/cert 具体案例可以查看 案例</description></item><item><title>Http NetWorkFilter 介绍</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/networkfilter/http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/networkfilter/http/</guid><description>Http NetWorkFilter 用来处理 HTTP 请求，它能接收来自 HTTP Listener 传递的 HTTP 请求，然后将其交给自身维护的 HTTP Filter 链进行处理，最后将响应返回给调用方。</description></item><item><title>Http Proxy 案例介绍</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/samples/http_proxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/samples/http_proxy/</guid><description>HTTP 代理 HTTP 代理案例展示了 Pixiu 接收外界 HTTP 请求然后转发给背后的 HTTP Server 的功能。
案例代码具体查看 /samples/http/simple。案例中的目录结构和作用如下所示：
- pixiu # pixiu 配置文件 - server # http server - test # client or unit test 我们来具体看一下有关 pixiu 的具体配置文件。
static_resources: listeners: - name: &amp;#34;net/http&amp;#34; protocol_type: &amp;#34;HTTP&amp;#34; # 使用 HTTP Listener address: socket_address: address: &amp;#34;0.0.0.0&amp;#34; # 监听地址设置为 0.0.0.0 port: 8888 # 端口设置为 8888 filter_chains: filters: - name: dgp.filter.httpconnectionmanager # NetworkFilter 设置为 httpconnectionmanager config: route_config: routes: - match: prefix: &amp;#34;/user&amp;#34; # 设置路由规则，将 /user 前缀的请求转发给名称为 user 的 cluster 集群 route: cluster: &amp;#34;user&amp;#34; cluster_not_found_response_code: 505 http_filters: - name: dgp.</description></item><item><title>HTTP to Dubbo 默认转换协议</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/appendix/http-to-dubbo-default-stragety/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/appendix/http-to-dubbo-default-stragety/</guid><description>背景 ​	通过 Http 提供一个统一的服务提供者视图，用户不用在乎后端Dubbo服务的版本差异，协议差异，通过简单地在Http请求中传递rpc调用的参数，完成一次Rpc调用，通过实现http调用后端dubbo服务，进一步简化后端服务设计的复杂性。
目的 ​	统一Http调用后端dubbo服务的形式，方便网关产品实现 Http 调用转 dubbo 调用的实现，Dubbo能和网关更好的融合。
Conception Dubbo RPC 调用的基本形式 希望通过提供Http调用Dubbo的方式简化 Consumer 的Rpc调用流程
网关会在整个服务调用的过程中承担更多的原本客户端的功能，比如负载均衡，服务治理，安全等能力，外部用户调用服务的时候将更多的关注与调用本身。
Http request 和 Http response 的格式 request的URL和Header中包含RPC调用的元信息，包含服务名，方法名，服务分组，服务版本，request 的 body 中包含请求的参数，参数是 json list 的格式, 如果没有参数则为 null
http response 中包含请求的处理状态，返回结果或者调用的错误类型以及错误具体信息，返回的body中只包含一个 json object，这个object中包含 code，result，error
通过 code 表示返回的具体状态，result 和 error 在返回中只会返回其中一个，分别是调用的返回结果，调用返回的错误信息。
Http request Http 请求的方法 只能为 POST 方法
Http 请求的 URL 格式：[http://host/ {service} / {method](http://host/service/method)} or [https://host/ {service} / {method](https://host/service/method)}
service 是调用的服务名，对应于Dubbo message body中的 service Name method 是调用的方法名，对应于Dubbo message body中的 method Name 服务名和方法名都应该和后端服务的声明一致</description></item><item><title>Java</title><link>https://dubbo.apache.org/zh-cn/download/java/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/download/java/</guid><description/></item><item><title>Java 语言定义服务</title><link>https://dubbo.apache.org/zh-cn/docs/languages/java/java-specific/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/java/java-specific/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
示例使用 Spring XML 配置方式进行演示。
除此之外，Dubbo Java 还提供了包括注解、API、配置文件、spring boot等多种启动与接入方式，具体可参见配置章节具体描述。
下载示例代码 示例代码在 dubbo-samples 中
下载源码 $ git clone -b master https://github.com/apache/dubbo-samples.git 进入示例目录 $ cd dubbo-samples/dubbo-samples-basic 快速运行示例 在 dubbo-samples-basic 目录
编译 Provider $ mvn clean package -Pprovider 运行 Provider $ java -jar ./target/provider.jar 编译 Consumer $ mvn clean package -Pconsumer 运行 consumer $ java -jar ./target/consumer.jar 详细解释 定义服务接口 DemoService.java
package org.apache.dubbo.samples.basic.api; public interface DemoService { String sayHello(String name); } 在服务提供方实现接口 DemoServiceImpl.java</description></item><item><title>Java 快速开始</title><link>https://dubbo.apache.org/zh-cn/docs/languages/java/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/java/quick-start/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
下载示例代码 示例代码在 dubbo-samples 中
下载源码 $ git clone -b master https://github.com/apache/dubbo-samples.git 进入示例目录 $ cd dubbo-samples/dubbo-samples-protobuf 快速运行示例 在 dubbo-samples-protobuf 目录
编译并打包示例项目 $ mvn clean package 运行 Provider $ java -jar ./protobuf-provider/target/protobuf-provider-1.0-SNAPSHOT.jar 运行 consumer $ java -jar ./protobuf-consumer/target/protobuf-consumer-1.0-SNAPSHOT.jar 输出以下结果 result: Hello Hello, response from provider: 30.225.20.43:20880 以上就是一个简单的 Dubbo 服务定义、服务调用流程
详细讲解 服务定义 syntax = &amp;#34;proto3&amp;#34;; option java_multiple_files = true; option java_package = &amp;#34;org.apache.dubbo.demo&amp;#34;; option java_outer_classname = &amp;#34;DemoServiceProto&amp;#34;; option objc_class_prefix = &amp;#34;DEMOSRV&amp;#34;; package demoservice; // The demo service definition.</description></item><item><title>多注册中心</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/multi-registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/multi-registry/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。另外，注册中心是支持自定义扩展的 1。
多注册中心注册 比如：中文站有些服务来不及在青岛部署，只在杭州部署，而青岛的其它应用需要引用此服务，就可以将服务同时注册到两个注册中心。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;dubbo:application name=&amp;#34;world&amp;#34; /&amp;gt; &amp;lt;!-- 多注册中心配置 --&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;hangzhouRegistry&amp;#34; address=&amp;#34;10.20.141.150:9090&amp;#34; /&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;qingdaoRegistry&amp;#34; address=&amp;#34;10.20.141.151:9010&amp;#34; default=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;!-- 向多个注册中心注册 --&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;com.alibaba.hello.api.HelloService&amp;#34; version=&amp;#34;1.0.0&amp;#34; ref=&amp;#34;helloService&amp;#34; registry=&amp;#34;hangzhouRegistry,qingdaoRegistry&amp;#34; /&amp;gt; &amp;lt;/beans&amp;gt; 不同服务使用不同注册中心 比如：CRM 有些服务是专门为国际站设计的，有些服务是专门为中文站设计的。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;dubbo:application name=&amp;#34;world&amp;#34; /&amp;gt; &amp;lt;!-- 多注册中心配置 --&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;chinaRegistry&amp;#34; address=&amp;#34;10.20.141.150:9090&amp;#34; /&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;intlRegistry&amp;#34; address=&amp;#34;10.20.154.177:9010&amp;#34; default=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;!</description></item><item><title>多注册中心</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/multi-registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/multi-registry/</guid><description>背景 Dubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。另外，注册中心是支持自定义扩展的 1。
示例 多注册中心注册 比如：中文站有些服务来不及在青岛部署，只在杭州部署，而青岛的其它应用需要引用此服务，就可以将服务同时注册到两个注册中心。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;dubbo:application name=&amp;#34;world&amp;#34; /&amp;gt; &amp;lt;!-- 多注册中心配置 --&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;hangzhouRegistry&amp;#34; address=&amp;#34;10.20.141.150:9090&amp;#34; /&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;qingdaoRegistry&amp;#34; address=&amp;#34;10.20.141.151:9010&amp;#34; default=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;!-- 向多个注册中心注册 --&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;com.alibaba.hello.api.HelloService&amp;#34; version=&amp;#34;1.0.0&amp;#34; ref=&amp;#34;helloService&amp;#34; registry=&amp;#34;hangzhouRegistry,qingdaoRegistry&amp;#34; /&amp;gt; &amp;lt;/beans&amp;gt; 不同服务使用不同注册中心 比如：CRM 有些服务是专门为国际站设计的，有些服务是专门为中文站设计的。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;dubbo:application name=&amp;#34;world&amp;#34; /&amp;gt; &amp;lt;!-- 多注册中心配置 --&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;chinaRegistry&amp;#34; address=&amp;#34;10.20.141.150:9090&amp;#34; /&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;intlRegistry&amp;#34; address=&amp;#34;10.20.154.177:9010&amp;#34; default=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;!</description></item><item><title>服务讲解（本地伪装）</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/local-mock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/local-mock/</guid><description>特性说明 在 Dubbo3 中有一种机制可以实现轻量级的服务降级，也就是本地伪装。
Mock 是 Stub 的一个子集，便于服务提供方在客户端执行容错逻辑，因经常需要在出现 RpcException (比如网络失败，超时等)时进行容错，而在出现业务异常(比如登录用户名密码错误)时不需要容错， 如果用 Stub，可能就需要捕获并依赖 RpcException 类，而用 Mock 就可以不依赖 RpcException，因为它的约定就是只有出现 RpcException 时才执行。
使用场景 本地伪装常被用于服务降级。比如某验权服务，当服务提供方全部挂掉后，假如此时服务消费方发起了一次远程调用，那么本次调用将会失败并抛出一个 RpcException 异常。为了避免出现这种直接抛出异常的情况出现，那么客户端就可以利用本地伪装来提供 Mock 数据返回授权失败。
其他使用场景包括：
某服务或接口负荷超出最大承载能力范围，需要进行降级应急处理，避免系统崩溃 调用的某非关键服务或接口暂时不可用时，返回模拟数据或空，业务还能继续可用 降级非核心业务的服务或接口，腾出系统资源，尽量保证核心业务的正常运行 某上游基础服务超时或不可用时，执行能快速响应的降级预案，避免服务整体雪崩 使用方式 完整示例源码请参见 dubbo-samples-mock
开启 Mock 配置 在 Spring XML 配置文件中按以下方式配置：
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; mock=&amp;#34;true&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; mock=&amp;#34;com.foo.BarServiceMock&amp;#34; /&amp;gt; 在工程中提供 Mock 实现 [^2]： 在 interface 旁放一个 Mock 实现，它实现 BarService 接口，并有一个无参构造函数。同时，如果没有在配置文件中显式指定 Mock 类的时候，那么需要保证 Mock 类的全限定类名是 原全限定类名+Mock 的形式，例如 com.foo.BarServiceMock，否则将会 Mock 失败。
package com.</description></item><item><title>配置概述</title><link>https://dubbo.apache.org/zh-cn/docs/references/configuration/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/configuration/overview/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
本文主要介绍Dubbo配置概况，包括配置组件、配置来源、配置方式及配置加载流程。
配置组件 Dubbo框架的配置项比较繁多，为了更好地管理各种配置，将其按照用途划分为不同的组件，最终所有配置项都会汇聚到URL中，传递给后续处理模块。
常用配置组件如下：
application: Dubbo应用配置 registry: 注册中心 protocol: 服务提供者RPC协议 config-center: 配置中心 metadata-report: 元数据中心 service: 服务提供者配置 reference: 远程服务引用配置 provider: service的默认配置或分组配置 consumer: reference的默认配置或分组配置 module: 模块配置 monitor: 监控配置 metrics: 指标配置 ssl: SSL/TLS配置 consumer 与 reference的关系 reference可以指定具体的consumer，如果没有指定consumer则会自动使用全局默认的consumer配置。
consumer的属性是reference属性的默认值，可以体现在两个地方：
在刷新属性(属性覆盖)时，先提取其consumer的属性，然后提取reference自身的属性覆盖上去，叠加后的属性集合作为配置来源之一。 在组装reference的URL参数时，先附加其consumer的属性，然后附加reference自身的属性。 可以将consumer组件理解为reference组件的虚拟分组，根据需要可以定义多个不同的consumer，不同的consumer设置特定的默认值， 然后在reference中指定consumer或者将&amp;lt;dubbo:reference /&amp;gt; 标签嵌套在&amp;lt;dubbo:consumer /&amp;gt;标签之中。
provider 与 service的关系 service可以指定具体的provider，如果没有指定则会自动使用全局默认的provider配置。 provider的属性是service属性的默认值，覆盖规则类似上面的consumer与reference，也可以将provider理解为service的虚拟分组。
配置来源 从Dubbo支持的配置来源说起，默认有6种配置来源：
JVM System Properties，JVM -D 参数 System environment，JVM进程的环境变量 Externalized Configuration，外部化配置，从配置中心读取 Application Configuration，应用的属性配置，从Spring应用的Environment中提取&amp;quot;dubbo&amp;quot;打头的属性集 API / XML /注解等编程接口采集的配置可以被理解成配置来源的一种，是直接面向用户编程的配置采集方式 从classpath读取配置文件 dubbo.properties 覆盖关系 下图展示了配置覆盖关系的优先级，从上到下优先级依次降低：</description></item><item><title>监控中心扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/monitor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/monitor/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 负责服务调用次和调用时间的监控。
扩展接口 org.apache.dubbo.monitor.MonitorFactory org.apache.dubbo.monitor.Monitor 扩展配置 &amp;lt;!-- 定义监控中心 --&amp;gt; &amp;lt;dubbo:monitor address=&amp;#34;xxx://ip:port&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.monitor.support.dubbo.DubboMonitorFactory
扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxMonitorFactoryjava (实现MonitorFactory接口) |-XxxMonitor.java (实现Monitor接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.monitor.MonitorFactory (纯文本文件，内容为：xxx=com.xxx.XxxMonitorFactory) XxxMonitorFactory.java：
package com.xxx; import org.apache.dubbo.monitor.MonitorFactory; import org.apache.dubbo.monitor.Monitor; import org.apache.dubbo.common.URL; public class XxxMonitorFactory implements MonitorFactory { public Monitor getMonitor(URL url) { return new XxxMonitor(url); } } XxxMonitor.java：
package com.xxx; import org.apache.dubbo.monitor.Monitor; public class XxxMonitor implements Monitor { public void count(URL statistics) { // .</description></item><item><title>监控中心扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/monitor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/monitor/</guid><description>扩展说明 负责服务调用次和调用时间的监控。
扩展接口 org.apache.dubbo.monitor.MonitorFactory org.apache.dubbo.monitor.Monitor 扩展配置 &amp;lt;!-- 定义监控中心 --&amp;gt; &amp;lt;dubbo:monitor address=&amp;#34;xxx://ip:port&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.monitor.support.dubbo.DubboMonitorFactory
扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxMonitorFactoryjava (实现MonitorFactory接口) |-XxxMonitor.java (实现Monitor接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.monitor.MonitorFactory (纯文本文件，内容为：xxx=com.xxx.XxxMonitorFactory) XxxMonitorFactory.java：
package com.xxx; import org.apache.dubbo.monitor.MonitorFactory; import org.apache.dubbo.monitor.Monitor; import org.apache.dubbo.common.URL; public class XxxMonitorFactory implements MonitorFactory { public Monitor getMonitor(URL url) { return new XxxMonitor(url); } } XxxMonitor.java：
package com.xxx; import org.apache.dubbo.monitor.Monitor; public class XxxMonitor implements Monitor { public void count(URL statistics) { // .</description></item><item><title>监控中心扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/monitor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/monitor/</guid><description>扩展说明 负责服务调用次和调用时间的监控。
扩展接口 org.apache.dubbo.monitor.MonitorFactory org.apache.dubbo.monitor.Monitor 扩展配置 &amp;lt;!-- 定义监控中心 --&amp;gt; &amp;lt;dubbo:monitor address=&amp;#34;xxx://ip:port&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.monitor.support.dubbo.DubboMonitorFactory
扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxMonitorFactoryjava (实现MonitorFactory接口) |-XxxMonitor.java (实现Monitor接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.monitor.MonitorFactory (纯文本文件，内容为：xxx=com.xxx.XxxMonitorFactory) XxxMonitorFactory.java：
package com.xxx; import org.apache.dubbo.monitor.MonitorFactory; import org.apache.dubbo.monitor.Monitor; import org.apache.dubbo.common.URL; public class XxxMonitorFactory implements MonitorFactory { public Monitor getMonitor(URL url) { return new XxxMonitor(url); } } XxxMonitor.java：
package com.xxx; import org.apache.dubbo.monitor.Monitor; public class XxxMonitor implements Monitor { public void count(URL statistics) { // .</description></item><item><title>快速开始</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/quickstart/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/quickstart/</guid><description>让我们从将 HTTP 请求转换为 Dubbo2 请求的案例来快速展示 Pixiu 的能力。
用例 Pixiu 将 Client 的 HTTP 请求转换为 Dubbo2 请求，然后转发给背后的 Dubbo Server，然后将 Dubbo Server 的响应转换为 HTTP 响应，最后返回给 Client。
架构图 案例 案例路径请查看 /samples/dubbogo/simple/resolve
Dubbo Server 实现和启动 Dubbo Server 提供用户增删改查的相关接口，其具体的代码实现见案例路径下的 server
Dubbo Server 的配置如下所示，注册了 Dubbo2 协议的 interface com.dubbogo.pixiu.UserService。
dubbo: registries: zk: protocol: zookeeper timeout: 3s address: 127.0.0.1:2181 protocols: dubbo: name: dubbo port: 20000 provider: registry-ids: zk services: UserProvider: group: test version: 1.0.0 cluster: test_dubbo serialization: hessian2 interface: com.</description></item><item><title>默认监控指标命令</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/introduction/default_metrics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/introduction/default_metrics/</guid><description>查询所有监控指标 命令：metrics_default
示例：
&amp;gt; telnet 127.0.0.1 22222 &amp;gt; metrics_default 输出：
Trying 127.0.0.1... Connected to localhost. Escape character is &amp;#39;^]&amp;#39;. ___ __ __ ___ ___ ____ / _ \ / / / // _ ) / _ ) / __ \ / // // /_/ // _ |/ _ |/ /_/ / /____/ \____//____//____/ \____/ dubbo&amp;gt;metrics_default dubbo.registry.directory.num.disable.total{application.module.id=1.1,application.name=dubbo-springboot-demo-provider,application.version=,git.commit.id=,hostname=hujundeMacBook-Pro.local,interface=dubbo-springboot-demo-provider/org.apache.dubbo.metrics.service.MetricsService:1.0.0,ip=10.224.214.80,} 0.0 dubbo.register.rt.milliseconds.max{application.module.id=1.1,application.name=dubbo-springboot-demo-provider,application.version=,git.commit.id=,hostname=hujundeMacBook-Pro.local,ip=10.224.214.80,} 153.0 根据关键词查询监控指标 命令：metrics_default {applicationName} {keyword}
applicationName: 应用名称
keyword: 关键词
示例：
&amp;gt; telnet 127.</description></item><item><title>使用 Nacos 作为注册中心</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/nacos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/nacos/</guid><description>1. 准备工作 dubbo-go cli 工具和依赖工具已安装 创建一个新的 demo 应用 2. 使用 grpc_cli 工具进行 Dubbo 服务调试 2.1 开启服务端 示例：user.go:
func (u *UserProvider) GetUser(ctx context.Context, userStruct *CallUserStruct) (*User, error) { fmt.Printf(&amp;#34;=======================\nreq:%#v\n&amp;#34;, userStruct) rsp := User{&amp;#34;A002&amp;#34;, &amp;#34;Alex Stocks&amp;#34;, 18, userStruct.SubInfo} fmt.Printf(&amp;#34;=======================\nrsp:%#v\n&amp;#34;, rsp) return &amp;amp;rsp, nil } 服务端开启一个服务，名为GetUser，传入一个CallUserStruct的参数，返回一个User参数
CallUserStruct参数定义：
type CallUserStruct struct { ID string Male bool SubInfo SubInfo // 嵌套子结构 } func (cs CallUserStruct) JavaClassName() string { return &amp;#34;com.ikurento.user.CallUserStruct&amp;#34; } type SubInfo struct { SubID string SubMale bool SubAge int } func (s SubInfo) JavaClassName() string { return &amp;#34;com.</description></item><item><title>使用 Nacos 作为注册中心</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/service-discovery/nacos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/service-discovery/nacos/</guid><description>This example shows dubbo-go&amp;rsquo;s service discovery feature with Nacos as registry.
使用方式 通过以下方式指定注册中心地址：
ins, _ := dubbo.NewInstance( dubbo.WithName(&amp;#34;dubbo_registry_nacos_server&amp;#34;), dubbo.WithRegistry( registry.WithNacos(), registry.WithAddress(&amp;#34;127.0.0.1:8848&amp;#34;), ), dubbo.WithProtocol( protocol.WithTriple(), protocol.WithPort(20000), ), ) srv, err := ins.NewServer() How to run Start Nacos server Follow this instruction to install and start Nacos server.
Run server $ go run ./go-server/cmd/server.go test rpc server work as expected:
$ curl \ --header &amp;#34;Content-Type: application/json&amp;#34; \ --data &amp;#39;{&amp;#34;name&amp;#34;: &amp;#34;Dubbo&amp;#34;}&amp;#39; \ http://localhost:20000/greet.GreetService/Greet Open https://localhost:8848/nacos/ with browser, check url address successfully registered into Nacos.</description></item><item><title>微服务生态</title><link>https://dubbo.apache.org/zh-cn/overview/what/core-features/ecosystem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/core-features/ecosystem/</guid><description>Dubbo 社区和众多优秀的开源项目一起围绕 Dubbo 建立了丰富的微服务生态支持，这让开发者从选型 Dubbo 作为开发框架的第一天，就无需担心后续的服务治理诉求，Dubbo 对每一个常见问题均提供了生产级的解决方案。
以下表格为基于最新 Dubbo Java 3.2.x 版本统计的生态组件支持情况，后续将根据开发进展持续更新。同时每个语言支持的组件完善度会有一定差异，具体请参见各个 语言参考手册 内的详细说明
功能 组件列表 组件列表 组件列表 组件列表 组件列表 服务发现 Zookeeper Nacos Kubernetes Service DNS【开发中】 更多 动态配置 Zookeeper Nacos Apollo Kubernetes【开发中】 更多 元数据管理 Zookeeper Nacos Redis Kubernetes【开发中】 更多 RPC 协议 HTTP/2 (Triple) TCP HTTP/REST【Alpha】 gRPC 更多 可视化观测平台 Admin Grafana Prometheus - - 全链路追踪 Zipkin Skywalking OpenTelemetry - - 限流降级 Sentinel Resilience4j Hystrix - - 分布式事务 Seata - - - - 网关 Higress APISIX Shenyu Envoy - 服务网格 Istio【开发中】 Aeraka OpenSergo【开发中】 Proxyless【Alpha】 更多 微服务生态示例架构</description></item><item><title>稳定性</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/quality/stability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/quality/stability/</guid><description>欢迎认领补充此文档。</description></item><item><title>性能</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/quality/performance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/quality/performance/</guid><description>欢迎认领补充此文档。</description></item><item><title>0-11 - 服务停止失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/11/</guid><description>可能的原因 连接没有及时关闭或内存不足，导致服务在停止时会出现一些异常。
排查和解决步骤 在响应内容完成后进行关闭连接。</description></item><item><title>1-11 - 注册服务实例创建失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/11/</guid><description>可能的原因 可能是 Registry 的 SPI/IOC 配置出错导致。
排查和解决步骤 该错误为 Dubbo 内部错误，如果您遇到可以在 github 创建 Issue 并提供错误信息以及复现步骤，我们将协助您解决问题。
另请参阅 Dubbo社区</description></item><item><title>2-11 - 标签路由规则不合法</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/11/</guid><description>可能的原因 用户配置的标签路由规则不合法。 用户配置的标签路由地址不合法。 排查和解决步骤 参照社区标签路由配置规范，检查标签路由配置。</description></item><item><title>4-11 - 发起请求失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/11/</guid><description>可能的原因 服务方已关闭。 调用方的 IP 不在服务方的白名单内。 请求具体的地址服务不存在。 排查和解决步骤 检查服务方启动运行情况。 检查或使用第三方工具，测试网络环境是否可正常连接。 根据堆栈的 serviceName, 在管理平台里查看或模拟调用，看是否正常。</description></item><item><title>5-11 - 注册实例错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/11/</guid><description>可能的原因 配置中心的服务无法连接。 配置的协议、IP、端口不正确。 使用配置中心客户端版本与服务端版本冲突，无法建立有效连接。 排查和解决步骤 检查配置中心的服务状态是否正常。 检查配置的协议、IP、端口不正确。 检查使用的配置中心客户端版本与服务端版本是否兼容。</description></item><item><title>6-11 - 字符集不被支持</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/11/</guid><description>可能的原因 默认 UTF-8 字符集
排查和解决步骤 结果会最终以 UTF-8 字符集进行处理。</description></item><item><title>使用 IDL 开发服务</title><link>https://dubbo.apache.org/zh-cn/docs/references/protobuf/idl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/protobuf/idl/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
定义服务 插件支持</description></item><item><title>在线运维命令参考手册</title><link>https://dubbo.apache.org/zh-cn/docs/references/qos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/qos/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
dubbo 2.5.8 新版本增加了 QOS 模块，提供了新的 telnet 命令支持。
端口 新版本的 telnet 端口 与 dubbo 协议的端口是不同的端口，默认为 22222，可通过配置文件dubbo.properties 修改:
dubbo.application.qos-port=33333 或者通过设置 JVM 参数:
-Ddubbo.application.qos-port=33333 安全 默认情况下，dubbo 接收任何主机发起的命令，可通过配置文件dubbo.properties 修改:
dubbo.application.qos-accept-foreign-ip=false 或者通过设置 JVM 参数:
-Ddubbo.application.qos-accept-foreign-ip=false 拒绝远端主机发出的命令，只允许服务本机执行
telnet 与 http 协议 telnet 模块现在同时支持 http 协议和 telnet 协议，方便各种情况的使用
示例如下：
➜ ~ telnet localhost 22222 Trying ::1... telnet: connect to address ::1: Connection refused Trying 127.0.0.1... Connected to localhost. Escape character is &amp;#39;^]&amp;#39;. ████████▄ ███ █▄ ▀█████████▄ ▀█████████▄ ▄██████▄ ███ ▀███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ▄███▄▄▄██▀ ▄███▄▄▄██▀ ███ ███ ███ ███ ███ ███ ▀▀███▀▀▀██▄ ▀▀███▀▀▀██▄ ███ ███ ███ ███ ███ ███ ███ ██▄ ███ ██▄ ███ ███ ███ ▄███ ███ ███ ███ ███ ███ ███ ███ ███ ████████▀ ████████▀ ▄█████████▀ ▄█████████▀ ▀██████▀ dubbo&amp;gt;ls As Provider side: +----------------------------------+---+ | Provider Service Name |PUB| +----------------------------------+---+ |org.</description></item><item><title>在线运维命令参考手册</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/qos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/qos/</guid><description>dubbo 2.5.8 新版本增加了 QOS 模块，提供了新的 telnet 命令支持。
端口 新版本的 telnet 端口 与 dubbo 协议的端口是不同的端口，默认为 22222，可通过配置文件dubbo.properties 修改:
dubbo.application.qos.port=33333 或者通过设置 JVM 参数:
-Ddubbo.application.qos.port=33333 安全 默认情况下，dubbo 接收任何主机发起的命令，可通过配置文件dubbo.properties 修改:
dubbo.application.qos.accept.foreign.ip=false 或者通过设置 JVM 参数:
-Ddubbo.application.qos.accept.foreign.ip=false 拒绝远端主机发出的命令，只允许服务本机执行
telnet 与 http 协议 telnet 模块现在同时支持 http 协议和 telnet 协议，方便各种情况的使用
示例如下：
➜ ~ telnet localhost 22222 Trying ::1... telnet: connect to address ::1: Connection refused Trying 127.0.0.1... Connected to localhost. Escape character is &amp;#39;^]&amp;#39;. ████████▄ ███ █▄ ▀█████████▄ ▀█████████▄ ▄██████▄ ███ ▀███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ▄███▄▄▄██▀ ▄███▄▄▄██▀ ███ ███ ███ ███ ███ ███ ▀▀███▀▀▀██▄ ▀▀███▀▀▀██▄ ███ ███ ███ ███ ███ ███ ███ ██▄ ███ ██▄ ███ ███ ███ ▄███ ███ ███ ███ ███ ███ ███ ███ ███ ████████▀ ████████▀ ▄█████████▀ ▄█████████▀ ▀██████▀ dubbo&amp;gt;ls As Provider side: +----------------------------------+---+ | Provider Service Name |PUB| +----------------------------------+---+ |org.</description></item><item><title>Telnet 命令参考手册</title><link>https://dubbo.apache.org/zh-cn/docs/references/telnet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/telnet/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
从 2.0.5 版本开始，dubbo 开始支持通过 telnet 命令来进行服务治理。
使用 telnet localhost 20880 或者：
echo status | nc -i 1 localhost 20880 status命令所检查的资源也可以扩展，参见：扩展参考手册。
命令 以下展示了 dubbo 内建的 telnet 命令的说明和用法，此外，telnet 命令还支持用户自行扩展，参见：Telnet 命令扩展。
ls ls: 显示服务列表 ls -l: 显示服务详细信息列表 ls XxxService: 显示服务的方法列表 ls -l XxxService: 显示服务的方法详细信息列表 ps ps: 显示服务端口列表 ps -l: 显示服务地址列表 ps 20880: 显示端口上的连接信息 ps -l 20880: 显示端口上的连接详细信息 cd cd XxxService: 改变缺省服务，当设置了缺省服务，凡是需要输入服务名作为参数的命令，都可以省略服务参数 cd /: 取消缺省服务 pwd pwd: 显示当前缺省服务
trace trace XxxService: 跟踪 1 次服务任意方法的调用情况 trace XxxService 10: 跟踪 10 次服务任意方法的调用情况 trace XxxService xxxMethod: 跟踪 1 次服务方法的调用情况 trace XxxService xxxMethod 10: 跟踪 10 次服务方法的调用情况 count count XxxService: 统计 1 次服务任意方法的调用情况 count XxxService 10: 统计 10 次服务任意方法的调用情况 count XxxService xxxMethod: 统计 1 次服务方法的调用情况 count XxxService xxxMethod 10: 统计 10 次服务方法的调用情况 invoke invoke XxxService.</description></item><item><title>Telnet 命令参考手册</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/telnet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/telnet/</guid><description>从 2.0.5 版本开始，dubbo 开始支持通过 telnet 命令来进行服务治理。
使用 telnet localhost 20880 或者：
echo status | nc -i 1 localhost 20880 status命令所检查的资源也可以扩展，参见：扩展参考手册。
命令 以下展示了 dubbo 内建的 telnet 命令的说明和用法，此外，telnet 命令还支持用户自行扩展，参见：Telnet 命令扩展。
ls ls: 显示服务列表 ls -l: 显示服务详细信息列表 ls XxxService: 显示服务的方法列表 ls -l XxxService: 显示服务的方法详细信息列表 ps ps: 显示服务端口列表 ps -l: 显示服务地址列表 ps 20880: 显示端口上的连接信息 ps -l 20880: 显示端口上的连接详细信息 cd cd XxxService: 改变缺省服务，当设置了缺省服务，凡是需要输入服务名作为参数的命令，都可以省略服务参数 cd /: 取消缺省服务 pwd pwd: 显示当前缺省服务
trace trace XxxService: 跟踪 1 次服务任意方法的调用情况 trace XxxService 10: 跟踪 10 次服务任意方法的调用情况 trace XxxService xxxMethod: 跟踪 1 次服务方法的调用情况 trace XxxService xxxMethod 10: 跟踪 10 次服务方法的调用情况 count count XxxService: 统计 1 次服务任意方法的调用情况 count XxxService 10: 统计 10 次服务任意方法的调用情况 count XxxService xxxMethod: 统计 1 次服务方法的调用情况 count XxxService xxxMethod 10: 统计 10 次服务方法的调用情况 invoke invoke XxxService.</description></item><item><title>Webservice协议</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/others/webservice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/protocol/others/webservice/</guid><description>特性说明 基于 WebService 的远程调用协议，基于 Apache CXF 的 frontend-simple 和 transports-http 实现。2.3.0 以上版本支持。
CXF 是 Apache 开源的一个 RPC 框架，由 Xfire 和 Celtix 合并而来。
连接个数：多连接 连接方式：短连接 传输协议：HTTP 传输方式：同步传输 序列化：SOAP 文本序列化 适用场景：系统集成，跨语言调用 可以和原生 WebService 服务互操作，即：
提供者用 Dubbo 的 WebService 协议暴露服务，消费者直接用标准 WebService 接口调用， 或者提供方用标准 WebService 暴露服务，消费方用 Dubbo 的 WebService 协议调用。 约束 参数及返回值需实现 Serializable 接口 参数尽量使用基本类型和 POJO 使用场景 发布一个服务（对内/对外），不考虑客户端类型，不考虑性能，建议使用webservice。服务端已经确定使用webservice，客户端不能选择，必须使用webservice。
使用方式 依赖 从 Dubbo 3 开始，Webservice 协议已经不再内嵌在 Dubbo 中，需要单独引入独立的模块。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-rpc-webservice&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.cxf&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;cxf-rt-frontend-simple&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.</description></item><item><title>本地存根</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/local-stub/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/local-stub/</guid><description>特性说明： 远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑。
使用场景 做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub 1，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。
使用方式 完整示例源码请参见 dubbo-samples-stub
spring 配置文件配置 &amp;lt;dubbo:consumer interface=&amp;#34;com.foo.BarService&amp;#34; stub=&amp;#34;true&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:consumer interface=&amp;#34;com.foo.BarService&amp;#34; stub=&amp;#34;com.foo.BarServiceStub&amp;#34; /&amp;gt; 提供 Stub 的实现 2 package com.foo; public class BarServiceStub implements BarService { private final BarSer vice barService; // 构造函数传入真正的远程代理对象 public BarServiceStub(BarService barService){ this.barService = barService; } public String sayHello(String name) { // 此代码在客户端执行, 你可以在客户端做ThreadLocal本地缓存，或预先验证参数是否合法，等等 try { return barService.</description></item><item><title>服务分组</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/service-group/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/service-group/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
当一个接口有多种实现时，可以用 group 区分。
服务 &amp;lt;dubbo:service group=&amp;#34;feedback&amp;#34; interface=&amp;#34;com.xxx.IndexService&amp;#34; /&amp;gt; &amp;lt;dubbo:service group=&amp;#34;member&amp;#34; interface=&amp;#34;com.xxx.IndexService&amp;#34; /&amp;gt; 引用 &amp;lt;dubbo:reference id=&amp;#34;feedbackIndexService&amp;#34; group=&amp;#34;feedback&amp;#34; interface=&amp;#34;com.xxx.IndexService&amp;#34; /&amp;gt; &amp;lt;dubbo:reference id=&amp;#34;memberIndexService&amp;#34; group=&amp;#34;member&amp;#34; interface=&amp;#34;com.xxx.IndexService&amp;#34; /&amp;gt; 任意组：
&amp;lt;dubbo:reference id=&amp;#34;barService&amp;#34; interface=&amp;#34;com.foo.BarService&amp;#34; group=&amp;#34;*&amp;#34; /&amp;gt; 提示 2.2.0 以上版本支持，总是只调一个可用组的实现</description></item><item><title>服务分组</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/service-group/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/service-group/</guid><description>背景 当一个接口有多种实现时，可以用 group 区分。
示例 服务 &amp;lt;dubbo:service group=&amp;#34;feedback&amp;#34; interface=&amp;#34;com.xxx.IndexService&amp;#34; /&amp;gt; &amp;lt;dubbo:service group=&amp;#34;member&amp;#34; interface=&amp;#34;com.xxx.IndexService&amp;#34; /&amp;gt; 引用 &amp;lt;dubbo:reference id=&amp;#34;feedbackIndexService&amp;#34; group=&amp;#34;feedback&amp;#34; interface=&amp;#34;com.xxx.IndexService&amp;#34; /&amp;gt; &amp;lt;dubbo:reference id=&amp;#34;memberIndexService&amp;#34; group=&amp;#34;member&amp;#34; interface=&amp;#34;com.xxx.IndexService&amp;#34; /&amp;gt; 任意组：
&amp;lt;dubbo:reference id=&amp;#34;barService&amp;#34; interface=&amp;#34;com.foo.BarService&amp;#34; group=&amp;#34;*&amp;#34; /&amp;gt; 提示 2.2.0 以上版本支持，总是只调一个可用组的实现</description></item><item><title>更多高级功能</title><link>https://dubbo.apache.org/zh-cn/overview/what/core-features/more/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/core-features/more/</guid><description>作为一款与应用开发紧密相关的微服务框架，同时旨在为微服务集群提供企业级服务治理能力，Dubbo 还提供了很多高级功能，涵盖服务调用行为控制、服务诊断与调优、服务治理等。
多种语言 sdk 在功能实现、配置方式上会略有差异，具体功能列表和使用方式可参考如下文档：
Java Golang 控制服务调用行为 服务版本 服务分组 分组聚合 异步调用 异步执行 流式通信 响应式编程 泛化调用 泛化实现 调用链路传递隐式参数 RPC调用上下文 调用触发事件通知 服务端对客户端进行回调 只订阅 只注册 运行时动态指定 IP 调用 直连提供者 启动时检查 本地调用 参数校验 本地伪装 本地存根 回声测试 调用信息记录 延迟暴露 集群容错 服务降级 诊断与调优 端口协议复用 线程池隔离 多协议 多注册中心 请求耗时采样 线程模型 服务引用配置对象缓存 路由状态采集 负载均衡 注册信息简化 调用结果缓存 并发控制 连接控制 延迟连接 粘滞连接 支持 Graal VM 导出线程堆栈 Kryo 和 FST 序列化 自定义服务容器 优雅停机 主机地址自定义暴露 一致性哈希选址 日志框架适配及运行时管理 Kubernetes 生命周期探针</description></item><item><title>检查列表</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/checklist/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/checklist/</guid><description>发布前 checklist jira ticket 过一遍 svn change list ticket 关联 code test code find bugs 修复时 checklist 修复代码前先建 ticket 修复代码前先写测试用例 需要伙伴检查 test code(正常流程/异常流程) 讲一遍逻辑 契约文档化 以上内容都写到ticket的评论上 代码注释写清楚，用中文无妨 每个版本要有 owner，确保 scope 和 check Partner Check Partner 以用户的方式运行一下功能 Partner 发现问题、添加测试（集成测试）直到不再复现；Owner 完成实现。（保证两方在Partner Check上的时间投入） Owner 向 Partner 讲述一遍实现。</description></item><item><title>静态服务</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/static-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/static-service/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
有时候希望人工管理服务提供者的上线和下线，此时需将注册中心标识为非动态管理模式。
&amp;lt;dubbo:registry address=&amp;#34;10.20.141.150:9090&amp;#34; dynamic=&amp;#34;false&amp;#34; /&amp;gt; 或者
&amp;lt;dubbo:registry address=&amp;#34;10.20.141.150:9090?dynamic=false&amp;#34; /&amp;gt; 服务提供者初次注册时为禁用状态，需人工启用。断线时，将不会被自动删除，需人工禁用。
如果是一个第三方服务提供者，比如 memcached，可以直接向注册中心写入提供者地址信息，消费者正常使用 1：
RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(&amp;#34;zookeeper://10.20.153.10:2181&amp;#34;)); registry.register(URL.valueOf(&amp;#34;memcached://10.20.153.11/com.foo.BarService?category=providers&amp;amp;dynamic=false&amp;amp;application=foo&amp;#34;)); 通常由脚本监控中心页面等调用&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>静态服务</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/static-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/static-service/</guid><description>背景 有时候希望人工管理服务提供者的上线和下线，此时需将注册中心标识为非动态管理模式。
示例 &amp;lt;dubbo:registry address=&amp;#34;10.20.141.150:9090&amp;#34; dynamic=&amp;#34;false&amp;#34; /&amp;gt; 或者
&amp;lt;dubbo:registry address=&amp;#34;10.20.141.150:9090?dynamic=false&amp;#34; /&amp;gt; 服务提供者初次注册时为禁用状态，需人工启用。断线时，将不会被自动删除，需人工禁用。
如果是一个第三方服务提供者，比如 memcached，可以直接向注册中心写入提供者地址信息，消费者正常使用 1：
RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(&amp;#34;zookeeper://10.20.153.10:2181&amp;#34;)); registry.register(URL.valueOf(&amp;#34;memcached://10.20.153.11/com.foo.BarService?category=providers&amp;amp;dynamic=false&amp;amp;application=foo&amp;#34;)); 通常由脚本监控中心页面等调用&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>扩展点加载扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/extension-factory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/extension-factory/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 扩展点本身的加载容器，可从不同容器加载扩展点。
扩展接口 org.apache.dubbo.common.extension.ExtensionFactory
扩展配置 &amp;lt;dubbo:application compiler=&amp;#34;jdk&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.common.extension.factory.SpiExtensionFactory org.apache.dubbo.config.spring.extension.SpringExtensionFactory 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxExtensionFactory.java (实现ExtensionFactory接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.extension.ExtensionFactory (纯文本文件，内容为：xxx=com.xxx.XxxExtensionFactory) XxxExtensionFactory.java：
package com.xxx; import org.apache.dubbo.common.extension.ExtensionFactory; public class XxxExtensionFactory implements ExtensionFactory { public Object getExtension(Class&amp;lt;?&amp;gt; type, String name) { // ... } } META-INF/dubbo/org.apache.dubbo.common.extension.ExtensionFactory：
xxx=com.xxx.XxxExtensionFactory</description></item><item><title>扩展点加载扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/extension-factory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/extension-factory/</guid><description>扩展说明 扩展点本身的加载容器，可从不同容器加载扩展点。
扩展接口 org.apache.dubbo.common.extension.ExtensionFactory
扩展配置 &amp;lt;dubbo:application compiler=&amp;#34;jdk&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.common.extension.factory.SpiExtensionFactory org.apache.dubbo.config.spring.extension.SpringExtensionFactory 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxExtensionFactory.java (实现ExtensionFactory接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.extension.ExtensionFactory (纯文本文件，内容为：xxx=com.xxx.XxxExtensionFactory) XxxExtensionFactory.java：
package com.xxx; import org.apache.dubbo.common.extension.ExtensionFactory; public class XxxExtensionFactory implements ExtensionFactory { public Object getExtension(Class&amp;lt;?&amp;gt; type, String name) { // ... } } META-INF/dubbo/org.apache.dubbo.common.extension.ExtensionFactory：
xxx=com.xxx.XxxExtensionFactory</description></item><item><title>扩展点加载扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/extension-factory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/extension-factory/</guid><description>扩展说明 扩展点本身的加载容器，可从不同容器加载扩展点。
扩展接口 org.apache.dubbo.common.extension.ExtensionFactory
扩展配置 &amp;lt;dubbo:application compiler=&amp;#34;jdk&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.common.extension.factory.SpiExtensionFactory org.apache.dubbo.config.spring.extension.SpringExtensionFactory 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxExtensionFactory.java (实现ExtensionFactory接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.extension.ExtensionFactory (纯文本文件，内容为：xxx=com.xxx.XxxExtensionFactory) XxxExtensionFactory.java：
package com.xxx; import org.apache.dubbo.common.extension.ExtensionFactory; public class XxxExtensionFactory implements ExtensionFactory { public Object getExtension(Class&amp;lt;?&amp;gt; type, String name) { // ... } } META-INF/dubbo/org.apache.dubbo.common.extension.ExtensionFactory：
xxx=com.xxx.XxxExtensionFactory</description></item><item><title>使用 Zookeeper 作为注册中心</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/service-discovery/zookeeper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/service-discovery/zookeeper/</guid><description>This example shows dubbo-go&amp;rsquo;s service discovery feature with Zookeeper as registry.
使用方式 通过以下方式指定注册中心地址：
ins, _ := dubbo.NewInstance( dubbo.WithName(&amp;#34;dubbo_registry_nacos_server&amp;#34;), dubbo.WithRegistry( registry.WithZookeeper(), registry.WithAddress(&amp;#34;127.0.0.1:2181&amp;#34;), ), dubbo.WithProtocol( protocol.WithTriple(), protocol.WithPort(20000), ), ) srv, err := ins.NewServer() How to run Start Zookeeper server This example relies on zookeeper as registry, follow the steps below to start a zookeeper server first.
Start zookeeper with docker, run docker run --rm -p 2181:2181 zookeeper or make -f $DUBBO_GO_SAMPLES_ROOT_PATH/build/Makefile docker-up. Download and start zookeeper locally on your machine.</description></item><item><title>0-12 - 未知异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/12/</guid><description>未知异常，一般为API使用或配置异常
可能的原因 转码异常、不支持的加解密方法等等
排查和解决步骤 可根据堆栈信息，进行业务代码行定位。</description></item><item><title>1-12 - “注册服务” 的实例均已销毁</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/12/</guid><description>可能的原因 在 Dubbo 优雅停机的过程中，通过调用 AbstractRegistryFactory 的 destroyAll 进行解注册。
销毁 Registryprotocol 的 unexport 的过程中，会通过 AbstractRegistryFactory 的 getRegistry 来试图获得已经被销毁的 registry ，这导致了 “注册服务” 的实例均已销毁。
排查和解决步骤 另请参阅 配置项参考手册</description></item><item><title>2-12 - 标签路由获取提供方应用名为空</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/12/</guid><description>可能的原因 标签路由从推送提供方地址列表中获取提供方应用名为空。 排查和解决步骤 该异常为 Dubbo 框架自身异常，请在社区提 Issue ，提供环境现场信息及复现步骤。</description></item><item><title>4-12 - 创建Triple流失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/12/</guid><description>可能的原因 一般为内部错误。
排查和解决步骤 可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。
同时请在社区提交Issue。</description></item><item><title>5-12 - 刷新实例和元数据错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/12/</guid><description>可能的原因 配置中心的服务无法连接。 配置的协议、IP、端口不正确。 使用配置中心客户端版本与服务端版本冲突，无法建立有效连接。 排查和解决步骤 检查配置中心的服务状态是否正常。 检查配置的协议、IP、端口不正确。 检查使用的配置中心客户端版本与服务端版本是否兼容。</description></item><item><title>6-12 - ZK客户端销毁时发生错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/12/</guid><description>可能的原因 客户端与服务端连接已被拒绝 客户端在销毁时，可能服务端正在进行选举或者其他操作，导致发生的异常。
排查和解决步骤 关闭方法，可针对堆栈信息进行查询。一般可不处理。</description></item><item><title>Maven 插件参考手册</title><link>https://dubbo.apache.org/zh-cn/docs/references/maven/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/maven/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
启动一个简易注册中心 以指定的 9099 端口启动一个简易注册中心 1：
mvn dubbo:registry -Dport=9099 生成 demo 服务提供者应用 生成指定接口和版本的服务提供者应用：
mvn dubbo:create -Dapplication=xxx -Dpackage=com.alibaba.xxx -Dservice=XxxService,YyyService -Dversion=1.0.0 如果端口不指定，默认端口为 9090&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>Maven 插件参考手册</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/maven/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/references/maven/</guid><description>启动一个简易注册中心 以指定的 9099 端口启动一个简易注册中心 1：
mvn dubbo:registry -Dport=9099 生成 demo 服务提供者应用 生成指定接口和版本的服务提供者应用 2：
mvn dubbo:create -Dapplication=xxx -Dpackage=com.alibaba.xxx -Dservice=XxxService,YyyService -Dversion=1.0.0 如果端口不指定，默认端口为 9090&amp;#160;&amp;#x21a9;&amp;#xfe0e;
参见 容器扩展&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>Triple 协议</title><link>https://dubbo.apache.org/zh-cn/docs/references/protocols/tri/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/protocols/tri/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Triple 协议是 Dubbo3 的主力协议，完整兼容 gRPC over HTTP/2，并在协议层面扩展了负载均衡和流量控制相关机制。本文档旨在指导用户正确的使用 Triple 协议。
在开始前，需要决定服务使用的序列化方式，如果为新服务，推荐使用 protobuf 作为默认序列化，在性能和跨语言上的效果都会更好。如果是原有服务想进行协议升级，Triple 协议也已经支持其他序列化方式，如 Hessian / JSON 等
Protobuf 编写 IDL 文件
syntax = &amp;#34;proto3&amp;#34;; option java_multiple_files = true; option java_package = &amp;#34;org.apache.dubbo.hello&amp;#34;; option java_outer_classname = &amp;#34;HelloWorldProto&amp;#34;; option objc_class_prefix = &amp;#34;HLW&amp;#34;; package helloworld; // The request message containing the user&amp;#39;s name. message HelloRequest { string name = 1; } // The response message containing the greetings message HelloReply { string message = 1; } 添加编译 protobuf 的 extension 和 plugin (以 maven 为例)</description></item><item><title>编码约定</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/coding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/coding/</guid><description>代码风格 Dubbo 的源代码和 JavaDoc 遵循以下的规范：
Code Conventions for the Java Programming Language How to Write Doc Comments for the Javadoc Tool 异常和日志 尽可能携带完整的上下文信息，比如出错原因，出错的机器地址，调用对方的地址，连的注册中心地址，使用 Dubbo 的版本等。 尽量将直接原因写在最前面，所有上下文信息，在原因后用键值对显示。 抛出异常的地方不用打印日志，由最终处理异常者决定打印日志的级别，吃掉异常必需打印日志。 打印 ERROR 日志表示需要报警，打印 WARN 日志表示可以自动恢复，打印 INFO 表示正常信息或完全不影响运行。 建议应用方在监控中心配置 ERROR 日志实时报警，WARN 日志每周汇总发送通知。 RpcException 是 Dubbo 对外的唯一异常类型，所有内部异常，如果要抛出给用户，必须转为 RpcException。 RpcException 不能有子类型，所有类型信息用 ErrorCode 标识，以便保持兼容。 配置和 URL 配置对象属性首字母小写，多个单词用驼峰命名 1。 配置属性全部用小写，多个单词用&amp;quot;-&amp;ldquo;号分隔 2。 URL参数全部用小写，多个单词用&amp;rdquo;.&amp;ldquo;号分隔 3。 尽可能用 URL 传参，不要自定义 Map 或其它上下文格式，配置信息也转成 URL 格式使用。 尽量减少 URL 嵌套，保持 URL 的简洁性。 单元和集成测试 单元测试统一用 JUnit 和 EasyMock，集成测试用 TestNG，数据库测试用 DBUnit。 保持单元测试用例的运行速度，不要将性能和大的集成用例放在单元测试中。 保持单元测试的每个用例都用 try.</description></item><item><title>Liveness 存活探针</title><link>https://dubbo.apache.org/zh-cn/docs/references/lifecycle/liveness/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/lifecycle/liveness/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 拓展应用存活的检测点。
扩展接口 org.apache.dubbo.qos.probe.LivenessProbe
扩展配置 Dubbo QOS live 命令自动发现
已知扩展 暂无默认实现
扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxLivenessProbe.java (实现LivenessProbe接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.qos.probe.LivenessProbe (纯文本文件，内容为：xxx=com.xxx.XxxLivenessProbe) XxxLivenessProbe.java：
package com.xxx; public class XxxLivenessProbe implements LivenessProbe { public boolean check() { // ... } } META-INF/dubbo/org.apache.dubbo.qos.probe.LivenessProbe：
xxx=com.xxx.XxxLivenessProbe</description></item><item><title>Liveness 存活探针</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/liveness/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/liveness/</guid><description>扩展说明 拓展应用存活的检测点。
扩展接口 org.apache.dubbo.qos.probe.LivenessProbe
扩展配置 Dubbo QOS live 命令自动发现
已知扩展 暂无默认实现
扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxLivenessProbe.java (实现LivenessProbe接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.qos.probe.LivenessProbe (纯文本文件，内容为：xxx=com.xxx.XxxLivenessProbe) XxxLivenessProbe.java：
package com.xxx; public class XxxLivenessProbe implements LivenessProbe { public boolean check() { // ... } } META-INF/dubbo/org.apache.dubbo.qos.probe.LivenessProbe：
xxx=com.xxx.XxxLivenessProbe</description></item><item><title>动态代理扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/proxy-factory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/proxy-factory/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 将 Invoker 接口转换成业务接口。
扩展接口 org.apache.dubbo.rpc.ProxyFactory
扩展配置 &amp;lt;dubbo:protocol proxy=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值配置，当&amp;lt;dubbo:protocol&amp;gt;没有配置proxy属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider proxy=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.rpc.proxy.JdkProxyFactory org.apache.dubbo.rpc.proxy.JavassistProxyFactory 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxProxyFactory.java (实现ProxyFactory接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.ProxyFactory (纯文本文件，内容为：xxx=com.xxx.XxxProxyFactory) XxxProxyFactory.java：
package com.xxx; import org.apache.dubbo.rpc.ProxyFactory; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.RpcException; public class XxxProxyFactory implements ProxyFactory { public &amp;lt;T&amp;gt; T getProxy(Invoker&amp;lt;T&amp;gt; invoker) throws RpcException { // ... } public &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; getInvoker(T proxy, Class&amp;lt;T&amp;gt; type, URL url) throws RpcException { // .</description></item><item><title>动态代理扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/proxy-factory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/proxy-factory/</guid><description>扩展说明 将 Invoker 接口转换成业务接口。
扩展接口 org.apache.dubbo.rpc.ProxyFactory
扩展配置 &amp;lt;dubbo:protocol proxy=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值配置，当&amp;lt;dubbo:protocol&amp;gt;没有配置proxy属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider proxy=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.rpc.proxy.JdkProxyFactory org.apache.dubbo.rpc.proxy.JavassistProxyFactory 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxProxyFactory.java (实现ProxyFactory接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.ProxyFactory (纯文本文件，内容为：xxx=com.xxx.XxxProxyFactory) XxxProxyFactory.java：
package com.xxx; import org.apache.dubbo.rpc.ProxyFactory; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.RpcException; public class XxxProxyFactory implements ProxyFactory { public &amp;lt;T&amp;gt; T getProxy(Invoker&amp;lt;T&amp;gt; invoker) throws RpcException { // ... } public &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; getInvoker(T proxy, Class&amp;lt;T&amp;gt; type, URL url) throws RpcException { // .</description></item><item><title>动态代理扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/proxy-factory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/proxy-factory/</guid><description>扩展说明 将 Invoker 接口转换成业务接口。
扩展接口 org.apache.dubbo.rpc.ProxyFactory
扩展配置 &amp;lt;dubbo:protocol proxy=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值配置，当&amp;lt;dubbo:protocol&amp;gt;没有配置proxy属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider proxy=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.rpc.proxy.JdkProxyFactory org.apache.dubbo.rpc.proxy.JavassistProxyFactory 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxProxyFactory.java (实现ProxyFactory接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.ProxyFactory (纯文本文件，内容为：xxx=com.xxx.XxxProxyFactory) XxxProxyFactory.java：
package com.xxx; import org.apache.dubbo.rpc.ProxyFactory; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.RpcException; public class XxxProxyFactory implements ProxyFactory { public &amp;lt;T&amp;gt; T getProxy(Invoker&amp;lt;T&amp;gt; invoker) throws RpcException { // ... } public &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; getInvoker(T proxy, Class&amp;lt;T&amp;gt; type, URL url) throws RpcException { // .</description></item><item><title>多版本</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/multi-versions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/multi-versions/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。
可以按照以下的步骤进行版本迁移：
在低压力时间段，先升级一半提供者为新版本 再将所有消费者升级为新版本 然后将剩下的一半提供者升级为新版本 老版本服务提供者配置：
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; version=&amp;#34;1.0.0&amp;#34; /&amp;gt; 新版本服务提供者配置：
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; version=&amp;#34;2.0.0&amp;#34; /&amp;gt; 老版本服务消费者配置：
&amp;lt;dubbo:reference id=&amp;#34;barService&amp;#34; interface=&amp;#34;com.foo.BarService&amp;#34; version=&amp;#34;1.0.0&amp;#34; /&amp;gt; 新版本服务消费者配置：
&amp;lt;dubbo:reference id=&amp;#34;barService&amp;#34; interface=&amp;#34;com.foo.BarService&amp;#34; version=&amp;#34;2.0.0&amp;#34; /&amp;gt; 如果不需要区分版本，可以按照以下的方式配置 [^1]：
提示 2.2.0 以上版本支持 &amp;lt;dubbo:reference id=&amp;#34;barService&amp;#34; interface=&amp;#34;com.foo.BarService&amp;#34; version=&amp;#34;*&amp;#34; /&amp;gt;</description></item><item><title>多版本</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/multi-versions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/multi-versions/</guid><description>背景 当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。
可以按照以下的步骤进行版本迁移：
在低压力时间段，先升级一半提供者为新版本 再将所有消费者升级为新版本 然后将剩下的一半提供者升级为新版本 示例 老版本服务提供者配置：
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; version=&amp;#34;1.0.0&amp;#34; /&amp;gt; 新版本服务提供者配置：
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; version=&amp;#34;2.0.0&amp;#34; /&amp;gt; 老版本服务消费者配置：
&amp;lt;dubbo:reference id=&amp;#34;barService&amp;#34; interface=&amp;#34;com.foo.BarService&amp;#34; version=&amp;#34;1.0.0&amp;#34; /&amp;gt; 新版本服务消费者配置：
&amp;lt;dubbo:reference id=&amp;#34;barService&amp;#34; interface=&amp;#34;com.foo.BarService&amp;#34; version=&amp;#34;2.0.0&amp;#34; /&amp;gt; 如果不需要区分版本，可以按照以下的方式配置 [^1]：
提示 2.2.0 以上版本支持 &amp;lt;dubbo:reference id=&amp;#34;barService&amp;#34; interface=&amp;#34;com.foo.BarService&amp;#34; version=&amp;#34;*&amp;#34; /&amp;gt;</description></item><item><title>坏味道</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/code-smell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/code-smell/</guid><description>URL 转换 1. 点对点暴露和引用服务 直接暴露服务：
EXPORT(dubbo://provider-address/com.xxx.XxxService?version=1.0.0&amp;#34;) 点对点直连服务：
REFER(dubbo://provider-address/com.xxx.XxxService?version=1.0.0) 2. 通过注册中心暴露服务 向注册中心暴露服务：
EXPORT(registry://registry-address/org.apache.dubbo.registry.RegistrySerevice?registry=dubbo&amp;amp;export=ENCODE(dubbo://provider-address/com.xxx.XxxService?version=1.0.0)) 获取注册中心：
url.setProtocol(url.getParameter(&amp;#34;registry&amp;#34;, &amp;#34;dubbo&amp;#34;)) GETREGISTRY(dubbo://registry-address/org.apache.dubbo.registry.RegistrySerevice) 注册服务地址：
url.getParameterAndDecoded(&amp;#34;export&amp;#34;)) REGISTER(dubbo://provider-address/com.xxx.XxxService?version=1.0.0) 3. 通过注册中心引用服务 从注册中心订阅服务：
REFER(registry://registry-address/org.apache.dubbo.registry.RegistrySerevice?registry=dubbo&amp;amp;refer=ENCODE(version=1.0.0)) 获取注册中心：
url.setProtocol(url.getParameter(&amp;#34;registry&amp;#34;, &amp;#34;dubbo&amp;#34;)) GETREGISTRY(dubbo://registry-address/org.apache.dubbo.registry.RegistrySerevice) 订阅服务地址：
url.addParameters(url.getParameterAndDecoded(&amp;#34;refer&amp;#34;)) SUBSCRIBE(dubbo://registry-address/com.xxx.XxxService?version=1.0.0) 通知服务地址：
url.addParameters(url.getParameterAndDecoded(&amp;#34;refer&amp;#34;)) NOTIFY(dubbo://provider-address/com.xxx.XxxService?version=1.0.0) 4. 注册中心推送路由规则 注册中心路由规则推送：
NOTIFY(route://registry-address/com.xxx.XxxService?router=script&amp;amp;type=js&amp;amp;rule=ENCODE(function{...})) 获取路由器：
url.setProtocol(url.getParameter(&amp;#34;router&amp;#34;, &amp;#34;script&amp;#34;)) GETROUTE(script://registry-address/com.xxx.XxxService?type=js&amp;amp;rule=ENCODE(function{...})) 5. 从文件加载路由规则 从文件加载路由规则：
GETROUTE(file://path/file.js?router=script) 获取路由器：
url.setProtocol(url.getParameter(&amp;#34;router&amp;#34;, &amp;#34;script&amp;#34;)).addParameter(&amp;#34;type&amp;#34;, SUFFIX(file)).addParameter(&amp;#34;rule&amp;#34;, READ(file)) GETROUTE(script://path/file.js?type=js&amp;amp;rule=ENCODE(function{...})) 调用参数 path 服务路径 group 服务分组 version 服务版本 dubbo 使用的 dubbo 版本 token 验证令牌 timeout 调用超时 扩展点的加载 1. 自适应扩展点 ExtensionLoader 加载扩展点时，会检查扩展点的属性（通过set方法判断），如该属性是扩展点类型，则会注入扩展点对象。因为注入时不能确定使用哪个扩展点（在使用时确定），所以注入的是一个自适应扩展（一个代理）。自适应扩展点调用时，选取一个真正的扩展点，并代理到其上完成调用。Dubbo 是根据调用方法参数（上面有调用哪个扩展点的信息）来选取一个真正的扩展点。</description></item><item><title>Readiness 就绪探针</title><link>https://dubbo.apache.org/zh-cn/docs/references/lifecycle/readiness/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/lifecycle/readiness/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 拓展应用就绪的检测点。
扩展接口 org.apache.dubbo.qos.probe.ReadinessProbe
扩展配置 Dubbo QOS ready 命令自动发现
已知扩展 org.apache.dubbo.qos.probe.impl.BootstrapReadinessProbe org.apache.dubbo.qos.probe.impl.ProviderReadinessProbe 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxReadinessProbe.java (实现ReadinessProbe接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.qos.probe.ReadinessProbe (纯文本文件，内容为：xxx=com.xxx.XxxReadinessProbe) XxxReadinessProbe.java：
package com.xxx; public class XxxReadinessProbe implements ReadinessProbe { public boolean check() { // ... } } META-INF/dubbo/org.apache.dubbo.qos.probe.ReadinessProbe：
xxx=com.xxx.XxxReadinessProbe</description></item><item><title>Readiness 就绪探针</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/readiness/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/readiness/</guid><description>扩展说明 拓展应用就绪的检测点。
扩展接口 org.apache.dubbo.qos.probe.ReadinessProbe
扩展配置 Dubbo QOS ready 命令自动发现
已知扩展 org.apache.dubbo.qos.probe.impl.BootstrapReadinessProbe org.apache.dubbo.qos.probe.impl.ProviderReadinessProbe 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxReadinessProbe.java (实现ReadinessProbe接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.qos.probe.ReadinessProbe (纯文本文件，内容为：xxx=com.xxx.XxxReadinessProbe) XxxReadinessProbe.java：
package com.xxx; public class XxxReadinessProbe implements ReadinessProbe { public boolean check() { // ... } } META-INF/dubbo/org.apache.dubbo.qos.probe.ReadinessProbe：
xxx=com.xxx.XxxReadinessProbe</description></item><item><title>Startup 启动探针</title><link>https://dubbo.apache.org/zh-cn/docs/references/lifecycle/startup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/lifecycle/startup/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 拓展应用启动的检测点。
扩展接口 org.apache.dubbo.qos.probe.StartupProbe
扩展配置 Dubbo QOS startup 命令自动发现
已知扩展 org.apache.dubbo.qos.probe.impl.BootstrapLivenessProbe 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxStartupProbe.java (实现StartupProbe接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.qos.probe.StartupProbe (纯文本文件，内容为：xxx=com.xxx.XxxStartupProbe) XxxStartupProbee.java：
package com.xxx; public class XxxStartupProbe implements StartupProbe { public boolean check() { // ... } } META-INF/dubbo/org.apache.dubbo.qos.probe.StartupProbe：
xxx=com.xxx.XxxStartupProbe</description></item><item><title>Startup 启动探针</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/startup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/startup/</guid><description>扩展说明 拓展应用启动的检测点。
扩展接口 org.apache.dubbo.qos.probe.StartupProbe
扩展配置 Dubbo QOS startup 命令自动发现
已知扩展 org.apache.dubbo.qos.probe.impl.BootstrapLivenessProbe 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxStartupProbe.java (实现StartupProbe接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.qos.probe.StartupProbe (纯文本文件，内容为：xxx=com.xxx.XxxStartupProbe) XxxStartupProbee.java：
package com.xxx; public class XxxStartupProbe implements StartupProbe { public boolean check() { // ... } } META-INF/dubbo/org.apache.dubbo.qos.probe.StartupProbe：
xxx=com.xxx.XxxStartupProbe</description></item><item><title>0-13 - 指标收集器发生异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/13/</guid><description>可能的原因 指标数据在推送过程中发生错误，推送的服务器连接不上或一些配置错误，目前支持 Prometheus。
排查和解决步骤 请参考配置项参考手册配置项参考手册。</description></item><item><title>1-13 - 执行重试任务失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/13/</guid><description>可能的原因 注册中心离线。 排查和解决步骤 检查注册中心是否正常工作。 检查注册中心所在服务器及其网络是否正常工作。</description></item><item><title>2-13 - 接收加载mesh的路由规则失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/13/</guid><description>可能的原因 mesh 路由配置的规则不合法，加载异常。 排查和解决步骤 检查 mesh 路由规则配置。mesh示例。</description></item><item><title>4-13 - 服务端超时</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/13/</guid><description>可能的原因 服务端逻辑处理相对耗时。 服务端负载请求过高，无法响应。 当前的超时参数设置阈值与现实情况相差较大。 排查和解决步骤 根据接口名称查看是否存在耗时处理情况。 可监控服务器状态，及服务端调用的服务调用情况。 尝试将超时参数调大一些。</description></item><item><title>5-13 - 无法销毁模型</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/13/</guid><description>可能的原因 自定义销毁方法，业务处理上存在异常。
排查和解决步骤 检查自定义销毁方法，业务处理逻辑是否存在运行时异常。</description></item><item><title>6-13 - 流关闭异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/13/</guid><description>可能的原因 当前流已关闭 Stream is closed 或流关闭时，其他线程正在读取。
排查和解决步骤 一般为代码关闭流的顺序上发生了颠倒。</description></item><item><title>技术兼容性测试</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/tck/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/tck/</guid><description>Dubbo 的协议，通讯，序列化，注册中心，负载均策等扩展点，都有多种可选策略，以应对不同应用场景，而我们的测试用例很分散，当用户自己需要加一种新的实现时，总是不确定能否满足扩展点的完整契约。
所以，我们需要对核心扩展点写 TCK (Technology Compatibility Kit)，用户增加一种扩展实现，只需通过 TCK，即可确保与框架的其它部分兼容运行，可以有效提高整体健壮性，也方便第三方扩展者接入，加速开源社区的成熟。
开源社区的行知同学已着手研究这一块，他的初步想法是借鉴 JBoss 的 CDI-TCK，做一个 Dubbo 的 TCK 基础框架，在此之上实现 Dubbo 的扩展点 TCK 用例。
参见：http://docs.jboss.org/cdi/tck/reference/1.0.1-Final/html/introduction.html
如果大家有兴趣，也可以一起研究，和行知一块讨论。
Protocol TCK TODO
Registry TCK TODO</description></item><item><title>编译器扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/compiler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/compiler/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 Java 代码编译器，用于动态生成字节码，加速调用。
扩展接口 org.apache.dubbo.common.compiler.Compiler
扩展配置 自动加载
已知扩展 org.apache.dubbo.common.compiler.support.JdkCompiler org.apache.dubbo.common.compiler.support.JavassistCompiler 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxCompiler.java (实现Compiler接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.compiler.Compiler (纯文本文件，内容为：xxx=com.xxx.XxxCompiler) XxxCompiler.java：
package com.xxx; import org.apache.dubbo.common.compiler.Compiler; public class XxxCompiler implements Compiler { public Object getExtension(Class&amp;lt;?&amp;gt; type, String name) { // ... } } META-INF/dubbo/org.apache.dubbo.common.compiler.Compiler：
xxx=com.xxx.XxxCompiler</description></item><item><title>编译器扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/compiler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/compiler/</guid><description>扩展说明 Java 代码编译器，用于动态生成字节码，加速调用。
扩展接口 org.apache.dubbo.common.compiler.Compiler
扩展配置 自动加载
已知扩展 org.apache.dubbo.common.compiler.support.JdkCompiler org.apache.dubbo.common.compiler.support.JavassistCompiler 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxCompiler.java (实现Compiler接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.compiler.Compiler (纯文本文件，内容为：xxx=com.xxx.XxxCompiler) XxxCompiler.java：
package com.xxx; import org.apache.dubbo.common.compiler.Compiler; public class XxxCompiler implements Compiler { public Object getExtension(Class&amp;lt;?&amp;gt; type, String name) { // ... } } META-INF/dubbo/org.apache.dubbo.common.compiler.Compiler：
xxx=com.xxx.XxxCompiler</description></item><item><title>编译器扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/compiler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/compiler/</guid><description>扩展说明 Java 代码编译器，用于动态生成字节码，加速调用。
扩展接口 org.apache.dubbo.common.compiler.Compiler
扩展配置 自动加载
已知扩展 org.apache.dubbo.common.compiler.support.JdkCompiler org.apache.dubbo.common.compiler.support.JavassistCompiler 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxCompiler.java (实现Compiler接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.compiler.Compiler (纯文本文件，内容为：xxx=com.xxx.XxxCompiler) XxxCompiler.java：
package com.xxx; import org.apache.dubbo.common.compiler.Compiler; public class XxxCompiler implements Compiler { public Object getExtension(Class&amp;lt;?&amp;gt; type, String name) { // ... } } META-INF/dubbo/org.apache.dubbo.common.compiler.Compiler：
xxx=com.xxx.XxxCompiler</description></item><item><title>分组聚合</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/group-merger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/group-merger/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
通过分组对结果进行聚合并返回聚合后的结果，比如菜单服务，用group区分同一接口的多种实现，现在消费方需从每种group中调用一次并返回结果，对结果进行合并之后返回，这样就可以实现聚合菜单项。
相关代码可以参考 dubbo 项目中的示例
配置 搜索所有分组
&amp;lt;dubbo:reference interface=&amp;#34;com.xxx.MenuService&amp;#34; group=&amp;#34;*&amp;#34; merger=&amp;#34;true&amp;#34; /&amp;gt; 合并指定分组
&amp;lt;dubbo:reference interface=&amp;#34;com.xxx.MenuService&amp;#34; group=&amp;#34;aaa,bbb&amp;#34; merger=&amp;#34;true&amp;#34; /&amp;gt; 指定方法合并结果，其它未指定的方法，将只调用一个 Group
&amp;lt;dubbo:reference interface=&amp;#34;com.xxx.MenuService&amp;#34; group=&amp;#34;*&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;getMenuItems&amp;#34; merger=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; 某个方法不合并结果，其它都合并结果
&amp;lt;dubbo:reference interface=&amp;#34;com.xxx.MenuService&amp;#34; group=&amp;#34;*&amp;#34; merger=&amp;#34;true&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;getMenuItems&amp;#34; merger=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; 指定合并策略，缺省根据返回值类型自动匹配，如果同一类型有两个合并器时，需指定合并器的名称
提示 参见：合并结果扩展 &amp;lt;dubbo:reference interface=&amp;#34;com.xxx.MenuService&amp;#34; group=&amp;#34;*&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;getMenuItems&amp;#34; merger=&amp;#34;mymerge&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; 指定合并方法，将调用返回结果的指定方法进行合并，合并方法的参数类型必须是返回结果类型本身
&amp;lt;dubbo:reference interface=&amp;#34;com.xxx.MenuService&amp;#34; group=&amp;#34;*&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;getMenuItems&amp;#34; merger=&amp;#34;.addAll&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; 提示 从 2.1.0 版本开始支持</description></item><item><title>分组聚合</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/group-merger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/group-merger/</guid><description>背景 通过分组对结果进行聚合并返回聚合后的结果，比如菜单服务，用group区分同一接口的多种实现，现在消费方需从每种group中调用一次并返回结果，对结果进行合并之后返回，这样就可以实现聚合菜单项。
相关代码可以参考 dubbo 项目中的示例
示例 搜索所有分组
&amp;lt;dubbo:reference interface=&amp;#34;com.xxx.MenuService&amp;#34; group=&amp;#34;*&amp;#34; merger=&amp;#34;true&amp;#34; /&amp;gt; 合并指定分组
&amp;lt;dubbo:reference interface=&amp;#34;com.xxx.MenuService&amp;#34; group=&amp;#34;aaa,bbb&amp;#34; merger=&amp;#34;true&amp;#34; /&amp;gt; 指定方法合并结果，其它未指定的方法，将只调用一个 Group
&amp;lt;dubbo:reference interface=&amp;#34;com.xxx.MenuService&amp;#34; group=&amp;#34;*&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;getMenuItems&amp;#34; merger=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; 某个方法不合并结果，其它都合并结果
&amp;lt;dubbo:reference interface=&amp;#34;com.xxx.MenuService&amp;#34; group=&amp;#34;*&amp;#34; merger=&amp;#34;true&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;getMenuItems&amp;#34; merger=&amp;#34;false&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; 指定合并策略，缺省根据返回值类型自动匹配，如果同一类型有两个合并器时，需指定合并器的名称
提示 参见：合并结果扩展 &amp;lt;dubbo:reference interface=&amp;#34;com.xxx.MenuService&amp;#34; group=&amp;#34;*&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;getMenuItems&amp;#34; merger=&amp;#34;mymerge&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; 指定合并方法，将调用返回结果的指定方法进行合并，合并方法的参数类型必须是返回结果类型本身
&amp;lt;dubbo:reference interface=&amp;#34;com.xxx.MenuService&amp;#34; group=&amp;#34;*&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;getMenuItems&amp;#34; merger=&amp;#34;.addAll&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; 提示 从 2.1.0 版本开始支持</description></item><item><title>服务化最佳实践</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/best-practice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/best-practice/</guid><description>分包 建议将服务接口、服务模型、服务异常等均放在 API 包中，因为服务模型和异常也是 API 的一部分，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。
如果需要，也可以考虑在 API 包中放置一份 Spring 的引用配置，这样使用方只需在 Spring 加载过程中引用此配置即可。配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。
粒度 服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。
服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。
不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。
版本 每个接口都应定义版本号，为后续不兼容升级提供可能，如： &amp;lt;dubbo:service interface=&amp;quot;com.xxx.XxxService&amp;quot; version=&amp;quot;1.0&amp;quot; /&amp;gt;。
建议使用两位版本号，因为第三位版本号通常表示兼容升级，只有不兼容时才需要变更服务版本。
当不兼容时，先升级一半提供者为新版本，再将消费者全部升为新版本，然后将剩下的一半提供者升为新版本。
兼容性 服务接口增加方法，或服务模型增加字段，可向后兼容，删除方法或删除字段，将不兼容，枚举类型新增字段也不兼容，需通过变更版本号升级。
各协议的兼容性不同，参见：服务协议
枚举值 如果是完备集，可以用 Enum，比如：ENABLE, DISABLE。
如果是业务种类，以后明显会有类型增加，不建议用 Enum，可以用 String 代替。
如果是在返回值中用了 Enum，并新增了 Enum 值，建议先升级服务消费方，这样服务提供方不会返回新值。
如果是在传入参数中用了 Enum，并新增了 Enum 值，建议先升级服务提供方，这样服务消费方不会传入新值。
序列化 服务参数及返回值建议使用 POJO 对象，即通过 setter, getter 方法表示属性的对象。
服务参数及返回值不建议使用接口，因为数据模型抽象的意义不大，并且序列化需要接口实现类的元信息，并不能起到隐藏实现的意图。
服务参数及返回值都必须是传值调用，而不能是传引用调用，消费方和提供方的参数或返回值引用并不是同一个，只是值相同，Dubbo 不支持引用远程对象。
异常 建议使用异常汇报错误，而不是返回错误码，异常信息能携带更多信息，并且语义更友好。
如果担心性能问题，在必要时，可以通过 override 掉异常类的 fillInStackTrace() 方法为空方法，使其不拷贝栈信息。
查询方法不建议抛出 checked 异常，否则调用方在查询时将过多的 try...catch，并且不能进行有效处理。
服务提供方不应将 DAO 或 SQL 等异常抛给消费方，应在服务实现中对消费方不关心的异常进行包装，否则可能出现消费方无法反序列化相应异常。</description></item><item><title>配置中心扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/config-center/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/config-center/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
设计目的 配置中心的核心功能是作为 Key-Value 存储，Dubbo 框架告知配置中心其关心的 key，配置中心返回该key对应的 value 值。
按照应用场景划分，配置中心在 Dubbo 框架中主要承担以下职责：
作为外部化配置中心，即存储 dubbo.properties 配置文件，此时，key 值通常为文件名如 dubbo.properties，value 则为配置文件内容。 存储单个配置项，如各种开关项、常量值等。 存储服务治理规则，此时key通常按照 &amp;ldquo;服务名+规则类型&amp;rdquo; 的格式来组织，而 value 则为具体的治理规则。 为了进一步实现对 key-value 的分组管理，Dubbo 的配置中心还加入了 namespace、group 的概念，这些概念在很多专业的第三方配置中心中都有体现，通常情况下，namespace 用来隔离不同的租户，group 用来对同一租户的key集合做分组。
当前，Dubbo 配置中心实现了对 Zookeeper、Nacos、Etcd、Consul、Apollo 的对接，接下来我们具体看一下 Dubbo 抽象的配置中心是怎么映射到具体的第三方实现中的。
扩展接口 org.apache.dubbo.configcenter.DynamicConfigurationFactory org.apache.dubbo.configcenter.DynamicConfiguration 已知扩展 org.apache.dubbo.configcenter.support.zookeeper.ZookeeperDynamicConfigurationFactory org.apache.dubbo.configcenter.support.nacos.NacosDynamicConfigurationFactory org.apache.dubbo.configcenter.support.etcd.EtcdDynamicConfigurationFactory org.apache.dubbo.configcenter.consul.ConsulDynamicConfigurationFactory org.apache.dubbo.configcenter.support.apollo.ApolloDynamicConfigurationFactory org.apache.dubbo.common.config.configcenter.file.FileSystemDynamicConfigurationFactory 实现原理 Zookeeper zookeeper提供了一个树状的存储模型，其实现原理如下：
namespace, group, key 等分别对应不同层级的 ZNode 节点，而 value 则作为根 ZNode 节点的值存储。
外部化配置中心 dubbo.properties
上图展示了两个不同作用域的 dubbo.properties 文件在 zookeeper 中的存储结构：
命名空间namespace都为：dubbo 分组 group：全局级别为 dubbo，所有应用共享；应用级别为应用名 demo-provider，只对该应用生效 key：dubbo.</description></item><item><title>配置中心扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/config-center/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/config-center/</guid><description>设计目的 配置中心的核心功能是作为 Key-Value 存储，Dubbo 框架告知配置中心其关心的 key，配置中心返回该key对应的 value 值。
按照应用场景划分，配置中心在 Dubbo 框架中主要承担以下职责：
作为外部化配置中心，即存储 dubbo.properties 配置文件，此时，key 值通常为文件名如 dubbo.properties，value 则为配置文件内容。 存储单个配置项，如各种开关项、常量值等。 存储服务治理规则，此时key通常按照 &amp;ldquo;服务名+规则类型&amp;rdquo; 的格式来组织，而 value 则为具体的治理规则。 为了进一步实现对 key-value 的分组管理，Dubbo 的配置中心还加入了 namespace、group 的概念，这些概念在很多专业的第三方配置中心中都有体现，通常情况下，namespace 用来隔离不同的租户，group 用来对同一租户的key集合做分组。
当前，Dubbo 配置中心实现了对 Zookeeper、Nacos、Etcd、Consul、Apollo 的对接，接下来我们具体看一下 Dubbo 抽象的配置中心是怎么映射到具体的第三方实现中的。
扩展接口 org.apache.dubbo.configcenter.DynamicConfigurationFactory org.apache.dubbo.configcenter.DynamicConfiguration 已知扩展 org.apache.dubbo.configcenter.support.zookeeper.ZookeeperDynamicConfigurationFactory org.apache.dubbo.configcenter.support.nacos.NacosDynamicConfigurationFactory org.apache.dubbo.configcenter.support.etcd.EtcdDynamicConfigurationFactory org.apache.dubbo.configcenter.consul.ConsulDynamicConfigurationFactory org.apache.dubbo.configcenter.support.apollo.ApolloDynamicConfigurationFactory org.apache.dubbo.common.config.configcenter.file.FileSystemDynamicConfigurationFactory 实现原理 Zookeeper zookeeper提供了一个树状的存储模型，其实现原理如下：
namespace, group, key 等分别对应不同层级的 ZNode 节点，而 value 则作为根 ZNode 节点的值存储。
外部化配置中心 dubbo.properties
上图展示了两个不同作用域的 dubbo.properties 文件在 zookeeper 中的存储结构：
命名空间namespace都为：dubbo 分组 group：全局级别为 dubbo，所有应用共享；应用级别为应用名 demo-provider，只对该应用生效 key：dubbo.</description></item><item><title>配置中心扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/config-center/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/config-center/</guid><description>设计目的 配置中心的核心功能是作为 Key-Value 存储，Dubbo 框架告知配置中心其关心的 key，配置中心返回该key对应的 value 值。
按照应用场景划分，配置中心在 Dubbo 框架中主要承担以下职责：
作为外部化配置中心，即存储 dubbo.properties 配置文件，此时，key 值通常为文件名如 dubbo.properties，value 则为配置文件内容。 存储单个配置项，如各种开关项、常量值等。 存储服务治理规则，此时key通常按照 &amp;ldquo;服务名+规则类型&amp;rdquo; 的格式来组织，而 value 则为具体的治理规则。 为了进一步实现对 key-value 的分组管理，Dubbo 的配置中心还加入了 namespace、group 的概念，这些概念在很多专业的第三方配置中心中都有体现，通常情况下，namespace 用来隔离不同的租户，group 用来对同一租户的key集合做分组。
当前，Dubbo 配置中心实现了对 Zookeeper、Nacos、Etcd、Consul、Apollo 的对接，接下来我们具体看一下 Dubbo 抽象的配置中心是怎么映射到具体的第三方实现中的。
扩展接口 org.apache.dubbo.configcenter.DynamicConfigurationFactory org.apache.dubbo.configcenter.DynamicConfiguration 已知扩展 org.apache.dubbo.configcenter.support.zookeeper.ZookeeperDynamicConfigurationFactory org.apache.dubbo.configcenter.support.nacos.NacosDynamicConfigurationFactory org.apache.dubbo.configcenter.support.etcd.EtcdDynamicConfigurationFactory org.apache.dubbo.configcenter.consul.ConsulDynamicConfigurationFactory org.apache.dubbo.configcenter.support.apollo.ApolloDynamicConfigurationFactory org.apache.dubbo.common.config.configcenter.file.FileSystemDynamicConfigurationFactory 实现原理 Zookeeper zookeeper提供了一个树状的存储模型，其实现原理如下：
namespace, group, key 等分别对应不同层级的 ZNode 节点，而 value 则作为根 ZNode 节点的值存储。
外部化配置中心 dubbo.properties
上图展示了两个不同作用域的 dubbo.properties 文件在 zookeeper 中的存储结构：
命名空间namespace都为：dubbo 分组 group：全局级别为 dubbo，所有应用共享；应用级别为应用名 demo-provider，只对该应用生效 key：dubbo.</description></item><item><title>元数据中心扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/metadata-report/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/metadata-report/</guid><description>设计目的 请参见 元数据中心手册
扩展接口 org.apache.dubbo.metadata.store.MetadataReportFactory org.apache.dubbo.metadata.store.MetadataReport 已知扩展 实现原理 SPI定义 参考：org.apache.dubbo.metadata.store.MetadataReportFactory，org.apache.dubbo.metadata.store.MetadataReport
@SPI(&amp;#34;redis&amp;#34;) public interface MetadataReportFactory { @Adaptive({&amp;#34;protocol&amp;#34;}) MetadataReport getMetadataReport(URL url); } 自定义元数据的存储 下面以Redis存储为例进行说明。
新建一个project，需要支持以下修改：
扩展AbstractMetadataReport public class RedisMetadataReport extends AbstractMetadataReport { private final static Logger logger = LoggerFactory.getLogger(RedisMetadataReport.class); final JedisPool pool; public RedisMetadataReport(URL url) { super(url); pool = new JedisPool(new JedisPoolConfig(), url.getHost(), url.getPort()); } @Override protected void doStoreProviderMetadata(ProviderMetadataIdentifier providerMetadataIdentifier, String serviceDefinitions) { this.storeMetadata(providerMetadataIdentifier, serviceDefinitions); } @Override protected void doStoreConsumerMetadata(ConsumerMetadataIdentifier consumerMetadataIdentifier, String value) { this.</description></item><item><title>0-14 - 监控异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/14/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/14/</guid><description>用来统计 RPC 调用次数和调用耗时时间，扩展接口为 MonitorFactory，对应的实现类为 DubboMonitorFactroy。
可能的原因 用户可以实现该层的 MonitorFactory 扩展接口，实现自定义监控统计策略。 在自定义监控统计策略的实现类，发生了业务运行时异常。
排查和解决步骤 检查 org.apache.dubbo.monitor.MonitorFactory 接口的业务类，实现方法可能存在代码逻辑错误。</description></item><item><title>1-14 - 动态配置识别失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/14/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/14/</guid><description>可能的原因 在使用 dubbo admin 的服务治理功能进行动态配置时，配置文件的内容或者格式不正确会导致无法解析动态配置的内容，产生 1-14 错误。
排查和解决步骤 请检查动态配置文件的内容或者格式是否正确。
另请参阅 配置项参考手册</description></item><item><title>2-14 - 脚本路由执行失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/14/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/14/</guid><description>可能的原因 脚本路由规则不合法，导致规则解析失败。 Dubbo 框架执行脚本失败。 排查和解决步骤 检查脚本是否按照规范编写。</description></item><item><title>4-14 - 响应结果失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/14/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/14/</guid><description>可能的原因 服务端管道可能因网络原因暂时断开。 当前使用版本较低或可检查当前的参数配置，是否启用 send.reconnect=true, 高版本默认为 true。 排查和解决步骤 检查直连网络是否通畅，有无丢包现象。 检查上述参数值，或尝试使用高版本。</description></item><item><title>5-14 - 模型启动错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/14/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/14/</guid><description>可能的原因 服务在等待发布或订阅时，连接被断开。 网络连接超时。 排查和解决步骤 检查应用服务器与配置中心的连接是否正常。 检查网络连接是否存在超时等。</description></item><item><title>6-14 - 服务端响应失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/14/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/14/</guid><description>可能的原因 在服务端与客户端交互发生数据时，客户端异常关闭。
排查和解决步骤 客户端异常终止或服务器宕机。</description></item><item><title>参数验证</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/parameter-validation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/parameter-validation/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
参数验证功能是基于 JSR303 实现的，用户只需标识 JSR303 标准的验证 annotation，并通过声明 filter 来实现验证。
Maven 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.validation&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;validation-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0.GA&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hibernate-validator&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.2.0.Final&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 示例 参数标注示例 import java.io.Serializable; import java.util.Date; import javax.validation.constraints.Future; import javax.validation.constraints.Max; import javax.validation.constraints.Min; import javax.validation.constraints.NotNull; import javax.validation.constraints.Past; import javax.validation.constraints.Pattern; import javax.validation.constraints.Size; public class ValidationParameter implements Serializable { private static final long serialVersionUID = 7158911668568000392L; @NotNull // 不允许为空 @Size(min = 1, max = 20) // 长度或大小范围 private String name; @NotNull(groups = ValidationService.</description></item><item><title>参数验证</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/parameter-validation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/parameter-validation/</guid><description>背景 参数验证功能是基于 JSR303 实现的，用户只需标识 JSR303 标准的验证 annotation，并通过声明 filter 来实现验证。
示例 Maven 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.validation&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;validation-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0.GA&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hibernate-validator&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.2.0.Final&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 参数标注示例 import java.io.Serializable; import java.util.Date; import javax.validation.constraints.Future; import javax.validation.constraints.Max; import javax.validation.constraints.Min; import javax.validation.constraints.NotNull; import javax.validation.constraints.Past; import javax.validation.constraints.Pattern; import javax.validation.constraints.Size; public class ValidationParameter implements Serializable { private static final long serialVersionUID = 7158911668568000392L; @NotNull // 不允许为空 @Size(min = 1, max = 20) // 长度或大小范围 private String name; @NotNull(groups = ValidationService.</description></item><item><title>推荐用法</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/recommend/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/recommend/</guid><description>在 Provider 端尽量多配置 Consumer 端属性 原因如下：
作为服务的提供方，比服务消费方更清楚服务的性能参数，如调用的超时时间、合理的重试次数等 在 Provider 端配置后，Consumer 端不配置则会使用 Provider 端的配置，即 Provider 端的配置可以作为 Consumer 的缺省值 1。否则，Consumer 会使用 Consumer 端的全局设置，这对于 Provider 是不可控的，并且往往是不合理的 Provider 端尽量多配置 Consumer 端的属性，让 Provider 的实现者一开始就思考 Provider 端的服务特点和服务质量等问题。
示例：
&amp;lt;dubbo:service interface=&amp;#34;com.alibaba.hello.api.HelloService&amp;#34; version=&amp;#34;1.0.0&amp;#34; ref=&amp;#34;helloService&amp;#34; timeout=&amp;#34;300&amp;#34; retries=&amp;#34;2&amp;#34; loadbalance=&amp;#34;random&amp;#34; actives=&amp;#34;0&amp;#34; /&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;com.alibaba.hello.api.WorldService&amp;#34; version=&amp;#34;1.0.0&amp;#34; ref=&amp;#34;helloService&amp;#34; timeout=&amp;#34;300&amp;#34; retries=&amp;#34;2&amp;#34; loadbalance=&amp;#34;random&amp;#34; actives=&amp;#34;0&amp;#34; &amp;gt; &amp;lt;dubbo:method name=&amp;#34;findAllPerson&amp;#34; timeout=&amp;#34;10000&amp;#34; retries=&amp;#34;9&amp;#34; loadbalance=&amp;#34;leastactive&amp;#34; actives=&amp;#34;5&amp;#34; /&amp;gt; &amp;lt;dubbo:service/&amp;gt; 建议在 Provider 端配置的 Consumer 端属性有：
timeout：方法调用的超时时间 retries：失败重试次数，缺省是 2 2 loadbalance：负载均衡算法 3，缺省是随机 random。还可以配置轮询 roundrobin、最不活跃优先 4 leastactive 和一致性哈希 consistenthash 等 actives：消费者端的最大并发调用限制，即当 Consumer 对一个服务的并发调用到上限后，新调用会阻塞直到超时，在方法上配置 dubbo:method 则针对该方法进行并发限制，在接口上配置 dubbo:service，则针对该服务进行并发限制 详细配置说明请参考：Dubbo配置参考手册</description></item><item><title>消息派发扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/dispatcher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/dispatcher/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 通道信息派发器，用于指定线程池模型。
扩展接口 org.apache.dubbo.remoting.Dispatcher
扩展配置 &amp;lt;dubbo:protocol dispatcher=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置dispatcher属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider dispatcher=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.remoting.transport.dispatcher.all.AllDispatcher org.apache.dubbo.remoting.transport.dispatcher.direct.DirectDispatcher org.apache.dubbo.remoting.transport.dispatcher.message.MessageOnlyDispatcher org.apache.dubbo.remoting.transport.dispatcher.execution.ExecutionDispatcher org.apache.dubbo.remoting.transport.dispatcher.connection.ConnectionOrderedDispatcher 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxDispatcher.java (实现Dispatcher接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.Dispatcher (纯文本文件，内容为：xxx=com.xxx.XxxDispatcher) XxxDispatcher.java：
package com.xxx; import org.apache.dubbo.remoting.Dispatcher; public class XxxDispatcher implements Dispatcher { public Group lookup(URL url) { // ... } } META-INF/dubbo/org.apache.dubbo.remoting.Dispatcher：
xxx=com.xxx.XxxDispatcher</description></item><item><title>消息派发扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/dispatcher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/dispatcher/</guid><description>扩展说明 通道信息派发器，用于指定线程池模型。
扩展接口 org.apache.dubbo.remoting.Dispatcher
扩展配置 &amp;lt;dubbo:protocol dispatcher=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置dispatcher属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider dispatcher=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.remoting.transport.dispatcher.all.AllDispatcher org.apache.dubbo.remoting.transport.dispatcher.direct.DirectDispatcher org.apache.dubbo.remoting.transport.dispatcher.message.MessageOnlyDispatcher org.apache.dubbo.remoting.transport.dispatcher.execution.ExecutionDispatcher org.apache.dubbo.remoting.transport.dispatcher.connection.ConnectionOrderedDispatcher 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxDispatcher.java (实现Dispatcher接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.Dispatcher (纯文本文件，内容为：xxx=com.xxx.XxxDispatcher) XxxDispatcher.java：
package com.xxx; import org.apache.dubbo.remoting.Dispatcher; public class XxxDispatcher implements Dispatcher { public Group lookup(URL url) { // ... } } META-INF/dubbo/org.apache.dubbo.remoting.Dispatcher：
xxx=com.xxx.XxxDispatcher</description></item><item><title>消息派发扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/dispatcher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/dispatcher/</guid><description>扩展说明 通道信息派发器，用于指定线程池模型。
扩展接口 org.apache.dubbo.remoting.Dispatcher
扩展配置 &amp;lt;dubbo:protocol dispatcher=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置dispatcher属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider dispatcher=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.remoting.transport.dispatcher.all.AllDispatcher org.apache.dubbo.remoting.transport.dispatcher.direct.DirectDispatcher org.apache.dubbo.remoting.transport.dispatcher.message.MessageOnlyDispatcher org.apache.dubbo.remoting.transport.dispatcher.execution.ExecutionDispatcher org.apache.dubbo.remoting.transport.dispatcher.connection.ConnectionOrderedDispatcher 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxDispatcher.java (实现Dispatcher接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.Dispatcher (纯文本文件，内容为：xxx=com.xxx.XxxDispatcher) XxxDispatcher.java：
package com.xxx; import org.apache.dubbo.remoting.Dispatcher; public class XxxDispatcher implements Dispatcher { public Group lookup(URL url) { // ... } } META-INF/dubbo/org.apache.dubbo.remoting.Dispatcher：
xxx=com.xxx.XxxDispatcher</description></item><item><title>0-15 - 加载扩展类时发生异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/15/</guid><description>可能的原因 clazz 类并没有实现当前扩展点的接口类。 扩展名可能是个接口或者不存在。 排查和解决步骤 检查扩展类声明，并没有与之相匹配的扩展实现类。 扩展实现类需实现扩展点接口类以及方法。</description></item><item><title>1-15 - 销毁服务失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/15/</guid><description>可能的原因 在 RegistryDirectory 中销毁所有的 invoker 时抛出异常则可能触发 1-15 错误。
排查和解决步骤 该错误为 Dubbo 内部错误，如果您遇到可以在 github 创建 Issue 并提供错误信息以及复现步骤，我们将协助您解决问题。
另请参阅 Dubbo 社区</description></item><item><title>2-15 - 路由规则解析失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/15/</guid><description>可能的原因 用户配置的路由规则不合法。 排查和解决步骤 排查配置的路由规则。</description></item><item><title>4-15 - 客户端流监听器</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/15/</guid><description>可能的原因 当收到服务端的响应之后，客户端流监听器会输出此信息，用于提醒。
排查和解决步骤</description></item><item><title>5-15 - 模型引用错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/15/</guid><description>可能的原因 Dubbo 核心处理类的方法被错误使用或被篡改。
排查和解决步骤 检查应用程序上是否存在错误使用或反编译修改情况。</description></item><item><title>6-15 - 跳过未读完的流数据</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/15/</guid><description>可能的原因 解码时，如流中还有未读数据时会跳过未读完的流
排查和解决步骤 解码时会把数据全部一次性读取</description></item><item><title>JSON泛化调用</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/generic-invoke-with-json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/generic-invoke-with-json/</guid><description>背景 提示 支持版本：2.7.12 之后 对于Dubbo泛化调用，提供一种新的方式：直接传递字符串来完成一次调用。即用户可以直接传递参数对象的json字符串来完成一次Dubbo泛化调用。
示例 通过API方式使用json泛化调用 对于以下provider：
public User setUser(User user) { return user; } 用到的实体类：
@Data public class User { String name; int age; } 进行一次泛化调用：
public class GenericInvoke { public static void main(String[] args) { ApplicationConfig app = new ApplicationConfig(&amp;#34;ConsumerTest&amp;#34;); RegistryConfig reg = new RegistryConfig(&amp;#34;nacos://localhost:8848&amp;#34;); DubboBootstrap bootstrap = DubboBootstrap.getInstance(); bootstrap.application(app); bootstrap.registry(reg); bootstrap.start(); try { // 引用远程服务 ReferenceConfig&amp;lt;GenericService&amp;gt; reference = new ReferenceConfig&amp;lt;&amp;gt;(); // 弱类型接口名 reference.setInterface(&amp;#34;com.xxx.api.service.TestService&amp;#34;); reference.setGroup(&amp;#34;dev&amp;#34;); reference.setVersion(&amp;#34;1.0&amp;#34;); reference.setRetries(0); // RpcContext中设置generic=gson RpcContext.</description></item><item><title>msgpack序列化</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/msgpack-serialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/msgpack-serialization/</guid><description>背景 MessagePack是一种高效的二进制序列化格式。它允许您在多种语言(如JSON)之间交换数据。但它更快更小。短整型被编码成一个字节，而典型的短字符串除了字符串本身只需要一个额外的字节。
提示 支持版本：2.7.12 之后 示例 provider与consumer引入msgpack依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.msgpack&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;msgpack-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.8.22&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.msgpack&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-dataformat-msgpack&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.8.22&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; provider示例demo dubbo 配置类增加如下协议配置：
... @Bean public ProtocolConfig msgpackProtocol(){ ProtocolConfig protocolConfig = new ProtocolConfig(); protocolConfig.setName(&amp;#34;dubbo&amp;#34;); protocolConfig.setId(&amp;#34;msgpack&amp;#34;); protocolConfig.setSerialization(&amp;#34;msgpack&amp;#34;); return protocolConfig; } dubbo provider:
dubbo provider 接口实现的@Service注解添加:protocol = {&amp;ldquo;msgpackProtocol&amp;rdquo;}协议声明。
dubbo provider 接口:
public interface MsgpackService { int tint(int i); long tlong(long i); List&amp;lt;String&amp;gt; tlist(List&amp;lt;String&amp;gt; l); String multiParams(String str, int i, MyParam myParam); } dubbo provider 接口实现:</description></item><item><title>provider超时打断</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/provider-timeout-release/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/provider-timeout-release/</guid><description>背景 支持provider根据超时时间进行业务打断
适用场景：对于一个provider，如果某个操作执行超时，则打断(释放)该执行线程，而不是仅仅打印超时日志。
提示 支持版本：2.7.12 之后 核心处理逻辑 public class AllChannelHandler2 extends AllChannelHandler { public static final Timer TIME_OUT_TIMER = new HashedWheelTimer( new NamedThreadFactory(&amp;#34;dubbo-server-future-timeout&amp;#34;, true), 30, TimeUnit.MILLISECONDS); public AllChannelHandler2(ChannelHandler handler, URL url) { super(handler, url); } @Override public void received(Channel channel, Object message) throws RemotingException { ExecutorService executor = getPreferredExecutorService(message); try { Future&amp;lt;?&amp;gt; future = executor.submit(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message)); long timeout = this.url.getParameter(&amp;#34;timeout&amp;#34;, 1000) + 90; TIME_OUT_TIMER.newTimeout(t -&amp;gt; { if (!</description></item><item><title>动态路由</title><link>https://dubbo.apache.org/zh-cn/docs/examples/routing/dynamic-rule-deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/examples/routing/dynamic-rule-deployment/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
apiVersion: service.dubbo.apache.org/v1alpha1 kind: VirtualService metadata: name: demo/StandardRouter spec: hosts: - demo dubbo: - services: - exact: com.taobao.hsf.demoservice:1.0.0 routedetail: - name: sayHello-route match: - method: name_match: exact: &amp;#34;s-method&amp;#34; argc: 5 args: - index: 2 type: double num_value: oneof: - range: start: 100.1 - index: 1 type: string str_value: oneof: - regex: &amp;#34;*abc*&amp;#34; - exact: parameter-1 - index: 3 type: bool - index: 4 type: int num_value: oneof: - range: start: 1 end: 100 - sourcelables: sigma.</description></item><item><title>结果缓存</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/result-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/result-cache/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
结果缓存，用于加速热门数据的访问速度，Dubbo 提供声明式缓存，以减少用户加缓存的工作量。
缓存类型 lru 基于最近最少使用原则删除多余缓存，保持最热的数据被缓存。 threadlocal 当前线程缓存，比如一个页面渲染，用到很多 portal，每个 portal 都要去查用户信息，通过线程缓存，可以减少这种多余访问。 jcache 与 JSR107 集成，可以桥接各种缓存实现。 缓存类型可扩展，参见：缓存扩展
配置 &amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; cache=&amp;#34;lru&amp;#34; /&amp;gt; 或：
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;findBar&amp;#34; cache=&amp;#34;lru&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; 提示 2.1.0 以上版本支持。
示例代码</description></item><item><title>结果缓存</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/result-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/result-cache/</guid><description>背景 结果缓存，用于加速热门数据的访问速度，Dubbo 提供声明式缓存，以减少用户加缓存的工作量。
缓存类型 lru 基于最近最少使用原则删除多余缓存，保持最热的数据被缓存。 threadlocal 当前线程缓存，比如一个页面渲染，用到很多 portal，每个 portal 都要去查用户信息，通过线程缓存，可以减少这种多余访问。 jcache 与 JSR107 集成，可以桥接各种缓存实现。 缓存类型可扩展，参见：缓存扩展
示例 &amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; cache=&amp;#34;lru&amp;#34; /&amp;gt; 或：
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;findBar&amp;#34; cache=&amp;#34;lru&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; 提示 2.1.0 以上版本支持。
示例代码</description></item><item><title>容量规划</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/capacity-plan/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/capacity-plan/</guid><description>以下数据供参考：
使用 Dubbo 的会员服务项目 每天接收 4 亿次远程调用 使用 12 台网站标配机器提供服务（8 核 CPU，8G 内存） 平均负载在 1 以下（对于 8 核 CPU 负载很低） 平均响应时间 2.3 到 2.5 毫秒，网络开销约占 1.5 到 1.6 毫秒（和数据包大小有关） 使用 Dubbo 的产品授权服务项目 每天接收 3 亿次远程调用 使用 8 台网站标配机器提供服务（8 核CPU，8G 内存） 平均负载在 1 以下（对于 8 核 CPU 负载很低） 平均响应时间 1.4 到 2.8 毫秒，网络开销约占 1.0 到 1.1 毫秒（和数据包大小有关）</description></item><item><title>收集Dubbo广播响应</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/broadcast-resp-collect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/broadcast-resp-collect/</guid><description>背景 适用场景：对于一个dubbo消费者，广播调用多个dubbo 提供者，该消费者可以收集所有服务提供者的响应结果。
提示 支持版本：2.7.12 之后 示例 consumer demo @Reference引入服务提供者，其中，令cluster=&amp;ldquo;broadcast2&amp;rdquo;，代表进行一个收集响应结果的广播调用。
广播调用所有服务提供者，逐个调用，并且可以完整的返回所有服务提供者的执行结果(正确或异常)，并将所有服务提供者的响应结果存于RpcContext。
@RestController public class TestServiceConsumer { @Reference(interfaceClass = DubboHealthService.class,cluster = &amp;#34;broadcast2&amp;#34;) private DubboHealthService dubboHealthService; @GetMapping(&amp;#34;/health&amp;#34;) public String broadCast(){ try{ dubboHealthService.health(); }catch (Exception e){ Map&amp;lt;String, String&amp;gt; m = RpcContext.getServerContext().getAttachments(); return m.toString()+&amp;#34;|&amp;#34;+&amp;#34;fail&amp;#34;; } Map&amp;lt;String, String&amp;gt; m = RpcContext.getServerContext().getAttachments(); return m.toString()+&amp;#34;|&amp;#34;+&amp;#34;success&amp;#34;; } } provider demo @Service public class DubboHealthServiceImpl implements DubboHealthService { @Override public String health() { // int i = 1/0; return &amp;#34;i am provider2&amp;#34;; } } 执行结果 所有provider全部成功：</description></item><item><title>线程池扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/threadpool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/threadpool/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 服务提供方线程池实现策略，当服务器收到一个请求时，需要在线程池中创建一个线程去执行服务提供方业务逻辑。
扩展接口 org.apache.dubbo.common.threadpool.ThreadPool
扩展配置 &amp;lt;dubbo:protocol threadpool=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置threadpool时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider threadpool=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.common.threadpool.FixedThreadPool org.apache.dubbo.common.threadpool.CachedThreadPool 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxThreadPool.java (实现ThreadPool接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.threadpool.ThreadPool (纯文本文件，内容为：xxx=com.xxx.XxxThreadPool) XxxThreadPool.java：
package com.xxx; import org.apache.dubbo.common.threadpool.ThreadPool; import java.util.concurrent.Executor; public class XxxThreadPool implements ThreadPool { public Executor getExecutor() { // ... } } META-INF/dubbo/org.apache.dubbo.common.threadpool.ThreadPool：
xxx=com.xxx.XxxThreadPool</description></item><item><title>线程池扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/threadpool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/threadpool/</guid><description>扩展说明 服务提供方线程池实现策略，当服务器收到一个请求时，需要在线程池中创建一个线程去执行服务提供方业务逻辑。
扩展接口 org.apache.dubbo.common.threadpool.ThreadPool
扩展配置 &amp;lt;dubbo:protocol threadpool=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置threadpool时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider threadpool=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.common.threadpool.FixedThreadPool org.apache.dubbo.common.threadpool.CachedThreadPool 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxThreadPool.java (实现ThreadPool接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.threadpool.ThreadPool (纯文本文件，内容为：xxx=com.xxx.XxxThreadPool) XxxThreadPool.java：
package com.xxx; import org.apache.dubbo.common.threadpool.ThreadPool; import java.util.concurrent.Executor; public class XxxThreadPool implements ThreadPool { public Executor getExecutor() { // ... } } META-INF/dubbo/org.apache.dubbo.common.threadpool.ThreadPool：
xxx=com.xxx.XxxThreadPool</description></item><item><title>线程池扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/threadpool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/threadpool/</guid><description>扩展说明 服务提供方线程池实现策略，当服务器收到一个请求时，需要在线程池中创建一个线程去执行服务提供方业务逻辑。
扩展接口 org.apache.dubbo.common.threadpool.ThreadPool
扩展配置 &amp;lt;dubbo:protocol threadpool=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置threadpool时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider threadpool=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.common.threadpool.FixedThreadPool org.apache.dubbo.common.threadpool.CachedThreadPool 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxThreadPool.java (实现ThreadPool接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.threadpool.ThreadPool (纯文本文件，内容为：xxx=com.xxx.XxxThreadPool) XxxThreadPool.java：
package com.xxx; import org.apache.dubbo.common.threadpool.ThreadPool; import java.util.concurrent.Executor; public class XxxThreadPool implements ThreadPool { public Executor getExecutor() { // ... } } META-INF/dubbo/org.apache.dubbo.common.threadpool.ThreadPool：
xxx=com.xxx.XxxThreadPool</description></item><item><title>指定Ip Port调用Provider</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/invoke-with-specified-ip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/invoke-with-specified-ip/</guid><description>背景 当多个Provider注册到注册中心时，可以通过在RpcContext中动态的指定其中一个实例的Ip，Port进行Dubbo调用。
提示 支持版本：2.7.12 之后 示例 provider demo 假定提供2个provider注册于注册中心，分别为10.220.47.253:20880;10.220.47.253:20881;
// 10.220.47.253:20880 @Service(interfaceClass = TestService.class) public class TestServiceImpl implements TestService { @Override public String sayHello(String name) { return &amp;#34;Hello &amp;#34;+name+&amp;#34; i am provider1&amp;#34;; } } // 10.220.47.253:20881 @Service(interfaceClass = TestService.class) public class TestServiceImpl implements TestService { @Override public String sayHello(String name) { return &amp;#34;Hello &amp;#34;+name+&amp;#34; i am provider2&amp;#34;; } } consumer demo @DubboReference引入provider，其中设定parameters = {&amp;ldquo;router&amp;rdquo;,&amp;ldquo;address&amp;rdquo;},指定address路由方式。
对于要调用的实例，指定Ip，Port构造Address对象，并设置RpcContext键为&amp;quot;address&amp;quot;，value为该对象。
// 需要依赖的class import org.apache.dubbo.rpc.RpcContext; import org.</description></item><item><title>0-16 - 没有可用的执行器</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/16/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/16/</guid><description>可能的原因 内部执行器不可用，此时返回空。
排查和解决步骤 不需要进行干预，dubbo 内部会执行createExecutorIfAbsent 方法构建一个新的执行器。</description></item><item><title>1-16 - 存在不支持的类别</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/16/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/16/</guid><description>可能的原因 当注册中心的发生变化时，会 notify 对应的 listener。在 notify 的时候如果 category 非法，则会产生存在不支持的类别。
排查和解决步骤 该错误为 Dubbo 内部错误，如果您遇到可以在 github 创建 Issue 并提供错误信息以及复现步骤，我们将协助您解决问题。
另请参阅 Dubbo社区</description></item><item><title>2-16 - 请求重试多次失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/16/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/16/</guid><description>可能的原因 提供方异常，导致消费方重试多次失败。
排查和解决步骤 排查提供方健康状况。</description></item><item><title>4-16 - 服务已关闭</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/16/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/16/</guid><description>可能的原因 在错误的状态下继续调用 org.apache.dubbo.rpc.protocol.tri.service.TriHealthImpl#enterTerminalState 或者 org.apache.dubbo.rpc.protocol.ReferenceCountInvokerWrapper#invoke，在调用时已经是 terminal 或 destory状态。
排查和解决步骤 多次调用上述方法会进行提醒。一般仅用于单元测试。</description></item><item><title>5-16 - 无法找到任何有效的协议</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/16/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/16/</guid><description>可能的原因 配置的协议不支持。
排查和解决步骤 目前支持的协议有 dubbo、rmi、hessian、http、webservice、thrift、redis 等。
另请参阅 配置项参考手册</description></item><item><title>6-16 - 重连时发生异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/16/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/6/16/</guid><description>可能的原因 每次发生重连时提示，网络不稳定造成的延迟重连。
排查和解决步骤 检查是否有网络丢包情况。</description></item><item><title>权重路由</title><link>https://dubbo.apache.org/zh-cn/docs/examples/routing/weight-rule-deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/examples/routing/weight-rule-deployment/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
apiVersion: service.dubbo.apache.org/v1alpha1 kind: VirtualService metadata: name: reviews-route spec: hosts: - reviews.prod.svc.cluster.local dubbo: - name: weightRoute routedetail: - name: weght route: - destination: host: reviews.prod.svc.cluster.local subset: v1 weight: 60 - destination: host: reviews.prod.svc.cluster.local subset: v2 weight: 40 --- apiVersion: service.dubbo.apache.org/v1alpha1 kind: DestinationRule metadata: name: reviews-route spec: host: reviews.prod.svc.cluster.local subsets: - name: v1 labels: version: v1 - name: v2 labels: version: v2</description></item><item><title>使用泛化调用</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/generic-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/generic-reference/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
泛化接口调用方式主要用于客户端没有 API 接口及模型类元的情况，参数及返回值中的所有 POJO 均用 Map 表示，通常用于框架集成，比如：实现一个通用的服务测试框架，可通过 GenericService 调用所有服务实现。
通过 Spring 使用泛化调用 在 Spring 配置申明 generic=&amp;quot;true&amp;quot;：
&amp;lt;dubbo:reference id=&amp;#34;barService&amp;#34; interface=&amp;#34;com.foo.BarService&amp;#34; generic=&amp;#34;true&amp;#34; /&amp;gt; 在 Java 代码获取 barService 并开始泛化调用：
GenericService barService = (GenericService) applicationContext.getBean(&amp;#34;barService&amp;#34;); Object result = barService.$invoke(&amp;#34;sayHello&amp;#34;, new String[] { &amp;#34;java.lang.String&amp;#34; }, new Object[] { &amp;#34;World&amp;#34; }); 通过 API 方式使用泛化调用 import org.apache.dubbo.rpc.service.GenericService; ... // 引用远程服务 // 该实例很重量，里面封装了所有与注册中心及服务提供方连接，请缓存 ReferenceConfig&amp;lt;GenericService&amp;gt; reference = new ReferenceConfig&amp;lt;GenericService&amp;gt;(); // 弱类型接口名 reference.setInterface(&amp;#34;com.xxx.XxxService&amp;#34;); reference.setVersion(&amp;#34;1.0.0&amp;#34;); // 声明为泛化接口 reference.setGeneric(true); // 用org.</description></item><item><title>使用泛化调用</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/generic-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/generic-reference/</guid><description>背景 泛化接口调用方式主要用于客户端没有 API 接口及模型类元的情况，参数及返回值中的所有 POJO 均用 Map 表示，通常用于框架集成，比如：实现一个通用的服务测试框架，可通过 GenericService 调用所有服务实现。
示例 通过 Spring 使用泛化调用 在 Spring 配置申明 generic=&amp;quot;true&amp;quot;：
&amp;lt;dubbo:reference id=&amp;#34;barService&amp;#34; interface=&amp;#34;com.foo.BarService&amp;#34; generic=&amp;#34;true&amp;#34; /&amp;gt; 在 Java 代码获取 barService 并开始泛化调用：
GenericService barService = (GenericService) applicationContext.getBean(&amp;#34;barService&amp;#34;); Object result = barService.$invoke(&amp;#34;sayHello&amp;#34;, new String[] { &amp;#34;java.lang.String&amp;#34; }, new Object[] { &amp;#34;World&amp;#34; }); 通过 API 方式使用泛化调用 import org.apache.dubbo.rpc.service.GenericService; ... // 引用远程服务 // 该实例很重量，里面封装了所有与注册中心及服务提供方连接，请缓存 ReferenceConfig&amp;lt;GenericService&amp;gt; reference = new ReferenceConfig&amp;lt;GenericService&amp;gt;(); // 弱类型接口名 reference.setInterface(&amp;#34;com.xxx.XxxService&amp;#34;); reference.setVersion(&amp;#34;1.0.0&amp;#34;); // 声明为泛化接口 reference.setGeneric(true); // 用org.</description></item><item><title>性能测试报告</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/perf-test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/perf-test/</guid><description>测试说明 本次性能测试，测试了 dubbo 2.0 所有支持的协议在不同大小和数据类型下的表现，并与 dubbo 1.0 进行了对比。 整体性能相比 1.0 有了提升，平均提升 10%，使用 dubbo 2.0 新增的 dubbo 序列化还能获得 10%~50% 的性能提升，详见下面的性能数据。 稳定性测试中由于将底层通信框架从 mina 换成 netty，old 区对象的增长大大减少，50 小时运行，增长不到 200m，无 fullgc。 存在的问题：在 50k 数据的时候 2.0 性能不如 1.0，怀疑可能是缓冲区设置的问题，下版本会进一步确认。 测试环境 硬件部署与参数调整 机型 CPU 内存 网络 磁盘 内核 Tecal BH620 model name : Intel(R) Xeon(R) CPU E5520 @ 2.27GHz cache size : 8192 KB processor_count : 16 Total System Memory: 6G Hardware Memory Info: Size: 4096MB eth0: Link is up at 1000 Mbps, full duplex.</description></item><item><title>序列化扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/serialize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/serialize/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 将对象转成字节流，用于网络传输，以及将字节流转为对象，用于在收到字节流数据后还原成对象。
扩展接口 org.apache.dubbo.common.serialize.Serialization org.apache.dubbo.common.serialize.ObjectInput org.apache.dubbo.common.serialize.ObjectOutput 扩展配置 &amp;lt;!-- 协议的序列化方式 --&amp;gt; &amp;lt;dubbo:protocol serialization=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置serialization时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider serialization=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.common.serialize.dubbo.DubboSerialization org.apache.dubbo.common.serialize.hessian.Hessian2Serialization org.apache.dubbo.common.serialize.java.JavaSerialization org.apache.dubbo.common.serialize.java.CompactedJavaSerialization 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxSerialization.java (实现Serialization接口) |-XxxObjectInput.java (实现ObjectInput接口) |-XxxObjectOutput.java (实现ObjectOutput接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.serialize.Serialization (纯文本文件，内容为：xxx=com.xxx.XxxSerialization) XxxSerialization.java：
package com.xxx; import org.apache.dubbo.common.serialize.Serialization; import org.apache.dubbo.common.serialize.ObjectInput; import org.apache.dubbo.common.serialize.ObjectOutput; public class XxxSerialization implements Serialization { public ObjectOutput serialize(Parameters parameters, OutputStream output) throws IOException { return new XxxObjectOutput(output); } public ObjectInput deserialize(Parameters parameters, InputStream input) throws IOException { return new XxxObjectInput(input); } } META-INF/dubbo/org.</description></item><item><title>序列化扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/serialize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/serialize/</guid><description>扩展说明 将对象转成字节流，用于网络传输，以及将字节流转为对象，用于在收到字节流数据后还原成对象。
扩展接口 org.apache.dubbo.common.serialize.Serialization org.apache.dubbo.common.serialize.ObjectInput org.apache.dubbo.common.serialize.ObjectOutput 扩展配置 &amp;lt;!-- 协议的序列化方式 --&amp;gt; &amp;lt;dubbo:protocol serialization=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置serialization时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider serialization=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.common.serialize.dubbo.DubboSerialization org.apache.dubbo.common.serialize.hessian.Hessian2Serialization org.apache.dubbo.common.serialize.java.JavaSerialization org.apache.dubbo.common.serialize.java.CompactedJavaSerialization 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxSerialization.java (实现Serialization接口) |-XxxObjectInput.java (实现ObjectInput接口) |-XxxObjectOutput.java (实现ObjectOutput接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.serialize.Serialization (纯文本文件，内容为：xxx=com.xxx.XxxSerialization) XxxSerialization.java：
package com.xxx; import org.apache.dubbo.common.serialize.Serialization; import org.apache.dubbo.common.serialize.ObjectInput; import org.apache.dubbo.common.serialize.ObjectOutput; public class XxxSerialization implements Serialization { public ObjectOutput serialize(Parameters parameters, OutputStream output) throws IOException { return new XxxObjectOutput(output); } public ObjectInput deserialize(Parameters parameters, InputStream input) throws IOException { return new XxxObjectInput(input); } } META-INF/dubbo/org.</description></item><item><title>序列化扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/serialize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/serialize/</guid><description>扩展说明 将对象转成字节流，用于网络传输，以及将字节流转为对象，用于在收到字节流数据后还原成对象。
扩展接口 org.apache.dubbo.common.serialize.Serialization org.apache.dubbo.common.serialize.ObjectInput org.apache.dubbo.common.serialize.ObjectOutput 扩展配置 &amp;lt;!-- 协议的序列化方式 --&amp;gt; &amp;lt;dubbo:protocol serialization=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置serialization时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider serialization=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.common.serialize.dubbo.DubboSerialization org.apache.dubbo.common.serialize.hessian.Hessian2Serialization org.apache.dubbo.common.serialize.java.JavaSerialization org.apache.dubbo.common.serialize.java.CompactedJavaSerialization 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxSerialization.java (实现Serialization接口) |-XxxObjectInput.java (实现ObjectInput接口) |-XxxObjectOutput.java (实现ObjectOutput接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.serialize.Serialization (纯文本文件，内容为：xxx=com.xxx.XxxSerialization) XxxSerialization.java：
package com.xxx; import org.apache.dubbo.common.serialize.Serialization; import org.apache.dubbo.common.serialize.ObjectInput; import org.apache.dubbo.common.serialize.ObjectOutput; public class XxxSerialization implements Serialization { public ObjectOutput serialize(Parameters parameters, OutputStream output) throws IOException { return new XxxObjectOutput(output); } public ObjectInput deserialize(Parameters parameters, InputStream input) throws IOException { return new XxxObjectInput(input); } } META-INF/dubbo/org.</description></item><item><title>0-17 - 执行器在关闭时发生未知异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/17/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/17/</guid><description>可能的原因 可能使用了自定义的执行器，在编写销毁方法时，产生了异常。
排查和解决步骤 检查是否自定义实现 org.apache.dubbo.common.threadpool.manager.ExecutorRepository,检查自定义的 shutdown 方法。</description></item><item><title>1-17 - metadata Server 失效</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/17/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/17/</guid><description>可能的原因 可能是 metadata 的相关参数配置出现问题，特别是 metadataServiceProtocol 和 metadataServicePort.
排查和解决步骤 查看是否和未提供 metadata service 端口同时出现，如果同时出现优先尝试解决未提供 metadata service 端口。(1-18 FAQ) 排查 metadataServicePort 端口号是否存在冲突问题。Provider 和 Consumer 所配置端口同时存在冲突，会产生 metadata Server 失效。 另请参阅 配置项参考手册</description></item><item><title>2-17 - mock请求失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/17/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/17/</guid><description>可能的原因 配置了强制 mock，提示性日志。 执行 mock 请求异常。 排查和解决步骤 检查是否配置了强制 mock。 检查 mock 响应是否正常。</description></item><item><title>4-17 - 关闭所有调用程序时发生错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/17/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/17/</guid><description>可能的原因 一般为内部错误。
排查和解决步骤 可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。
同时请在社区提交issue.</description></item><item><title>5-17 - 参数值格式错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/17/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/17/</guid><description>可能的原因 属性配置值长度过长，一般设置在 200 个字符以内。 属性配置值格式错误，目前支持数字、 -、 _ 等 排查和解决步骤 检查属性配置值内容是否过长，具体参考提示信息进行修改。 检查属性配置值内容是否包含特殊字符，如 @#$%^&amp;amp; 等，具体请参考提示信息进行修改。</description></item><item><title>Protobuf</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/protobuf-idl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/protobuf-idl/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
当前 Dubbo 的服务定义和具体的编程语言绑定，没有提供一种语言中立的服务描述格式，比如 Java 就是定义 Interface 接口，到了其他语言又得重新以另外的格式定义一遍。 2.7.5 版本通过支持 Protobuf IDL 实现了语言中立的服务定义。
日后，不论我们使用什么语言版本来开发 Dubbo 服务，都可以直接使用 IDL 定义如下服务，具体请参见示例
syntax = &amp;#34;proto3&amp;#34;; option java_multiple_files = true; option java_package = &amp;#34;org.apache.dubbo.demo&amp;#34;; option java_outer_classname = &amp;#34;DemoServiceProto&amp;#34;; option objc_class_prefix = &amp;#34;DEMOSRV&amp;#34;; package demoservice; // The demo service definition. service DemoService { rpc SayHello (HelloRequest) returns (HelloReply) {} } // The request message containing the user&amp;#39;s name. message HelloRequest { string name = 1; } // The response message containing the greetings message HelloReply { string message = 1; }</description></item><item><title>Protobuf</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/protobuf-idl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/protobuf-idl/</guid><description>背景 当前 Dubbo 的服务定义和具体的编程语言绑定，没有提供一种语言中立的服务描述格式，比如 Java 就是定义 Interface 接口，到了其他语言又得重新以另外的格式定义一遍。 2.7.5 版本通过支持 Protobuf IDL 实现了语言中立的服务定义。
日后，不论我们使用什么语言版本来开发 Dubbo 服务，都可以直接使用 IDL 定义如下服务，具体请参见示例
示例 syntax = &amp;#34;proto3&amp;#34;; option java_multiple_files = true; option java_package = &amp;#34;org.apache.dubbo.demo&amp;#34;; option java_outer_classname = &amp;#34;DemoServiceProto&amp;#34;; option objc_class_prefix = &amp;#34;DEMOSRV&amp;#34;; package demoservice; // The demo service definition. service DemoService { rpc SayHello (HelloRequest) returns (HelloReply) {} } // The request message containing the user&amp;#39;s name. message HelloRequest { string name = 1; } // The response message containing the greetings message HelloReply { string message = 1; }</description></item><item><title>GoogleProtobuf 对象泛化调用</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/pb-generic-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/pb-generic-reference/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
泛化接口调用方式主要用于客户端没有 API 接口及模型类元的情况，参考 泛化调用。 一般泛化调用只能用于生成的服务参数为POJO的情况，而 GoogleProtobuf 的对象是基于 Builder 生成的非正常POJO，可以通过 protobuf-json 泛化调用。
GoogleProtobuf 序列化相关的Demo可以参考 protobuf-demo
通过Spring对Google Protobuf对象泛化调用 在 Spring 中配置声明 generic = &amp;ldquo;protobuf-json&amp;rdquo;
&amp;lt;dubbo:reference id=&amp;#34;barService&amp;#34; interface=&amp;#34;com.foo.BarService&amp;#34; generic=&amp;#34;protobuf-json&amp;#34; /&amp;gt; 在 Java 代码获取 barService 并开始泛化调用：
GenericService barService = (GenericService) applicationContext.getBean(&amp;#34;barService&amp;#34;); Object result = barService.$invoke(&amp;#34;sayHello&amp;#34;,new String[]{&amp;#34;org.apache.dubbo.protobuf.GooglePbBasic$CDubboGooglePBRequestType&amp;#34;}, new Object[]{&amp;#34;{\&amp;#34;double\&amp;#34;:0.0,\&amp;#34;float\&amp;#34;:0.0,\&amp;#34;bytesType\&amp;#34;:\&amp;#34;Base64String\&amp;#34;,\&amp;#34;int32\&amp;#34;:0}&amp;#34;}); 通过 API 方式对 Google Protobuf 对象泛化调用 ReferenceConfig&amp;lt;GenericService&amp;gt; reference = new ReferenceConfig&amp;lt;GenericService&amp;gt;(); // 弱类型接口名 reference.setInterface(GenericService.class.getName()); reference.setInterface(&amp;#34;com.xxx.XxxService&amp;#34;); // 声明为Protobuf-json reference.setGeneric(Constants.GENERIC_SERIALIZATION_PROTOBUF); GenericService genericService = reference.get(); Map&amp;lt;String, Object&amp;gt; person = new HashMap&amp;lt;String, Object&amp;gt;(); person.</description></item><item><title>GoogleProtobuf 对象泛化调用</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/pb-generic-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/pb-generic-reference/</guid><description>背景 泛化接口调用方式主要用于客户端没有 API 接口及模型类元的情况，参考 泛化调用。 一般泛化调用只能用于生成的服务参数为POJO的情况，而 GoogleProtobuf 的对象是基于 Builder 生成的非正常POJO，可以通过 protobuf-json 泛化调用。
GoogleProtobuf 序列化相关的Demo可以参考 protobuf-demo
示例 通过Spring对Google Protobuf对象泛化调用 在 Spring 中配置声明 generic = &amp;ldquo;protobuf-json&amp;rdquo;
&amp;lt;dubbo:reference id=&amp;#34;barService&amp;#34; interface=&amp;#34;com.foo.BarService&amp;#34; generic=&amp;#34;protobuf-json&amp;#34; /&amp;gt; 在 Java 代码获取 barService 并开始泛化调用：
GenericService barService = (GenericService) applicationContext.getBean(&amp;#34;barService&amp;#34;); Object result = barService.$invoke(&amp;#34;sayHello&amp;#34;,new String[]{&amp;#34;org.apache.dubbo.protobuf.GooglePbBasic$CDubboGooglePBRequestType&amp;#34;}, new Object[]{&amp;#34;{\&amp;#34;double\&amp;#34;:0.0,\&amp;#34;float\&amp;#34;:0.0,\&amp;#34;bytesType\&amp;#34;:\&amp;#34;Base64String\&amp;#34;,\&amp;#34;int32\&amp;#34;:0}&amp;#34;}); 通过 API 方式对 Google Protobuf 对象泛化调用 ReferenceConfig&amp;lt;GenericService&amp;gt; reference = new ReferenceConfig&amp;lt;GenericService&amp;gt;(); // 弱类型接口名 reference.setInterface(GenericService.class.getName()); reference.setInterface(&amp;#34;com.xxx.XxxService&amp;#34;); // 声明为Protobuf-json reference.setGeneric(Constants.GENERIC_SERIALIZATION_PROTOBUF); GenericService genericService = reference.get(); Map&amp;lt;String, Object&amp;gt; person = new HashMap&amp;lt;String, Object&amp;gt;(); person.</description></item><item><title>测试覆盖率报告</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/coveragence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/coveragence/</guid><description> v2.0 Codecov报表 , 从 2017-12-29 后开始统计 测试覆盖率为 : , 可以从 https://codecov.io/gh/apache/dubbo 页面得到覆盖率报表 v1.0 基于 2.0.12 版本，统计于 2012-02-03</description></item><item><title>实现泛化调用</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/generic-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/generic-service/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
泛接口实现方式主要用于服务器端没有 API 接口及模型类元的情况，参数及返回值中的所有 POJO 均用 Map 表示，通常用于框架集成，比如：实现一个通用的远程服务 Mock 框架，可通过实现 GenericService 接口处理所有服务请求。
在 Java 代码中实现 GenericService 接口：
package com.foo; public class MyGenericService implements GenericService { public Object $invoke(String methodName, String[] parameterTypes, Object[] args) throws GenericException { if (&amp;#34;sayHello&amp;#34;.equals(methodName)) { return &amp;#34;Welcome &amp;#34; + args[0]; } } } 通过 Spring 暴露泛化实现 在 Spring 配置申明服务的实现：
&amp;lt;bean id=&amp;#34;genericService&amp;#34; class=&amp;#34;com.foo.MyGenericService&amp;#34; /&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; ref=&amp;#34;genericService&amp;#34; /&amp;gt; 通过 API 方式暴露泛化实现 ... // 用org.apache.dubbo.rpc.service.GenericService可以替代所有接口实现 GenericService xxxService = new XxxGenericService(); // 该实例很重量，里面封装了所有与注册中心及服务提供方连接，请缓存 ServiceConfig&amp;lt;GenericService&amp;gt; service = new ServiceConfig&amp;lt;GenericService&amp;gt;(); // 弱类型接口名 service.</description></item><item><title>实现泛化调用</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/generic-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/generic-service/</guid><description>背景 泛接口实现方式主要用于服务器端没有 API 接口及模型类元的情况，参数及返回值中的所有 POJO 均用 Map 表示，通常用于框架集成，比如：实现一个通用的远程服务 Mock 框架，可通过实现 GenericService 接口处理所有服务请求。
在 Java 代码中实现 GenericService 接口：
package com.foo; public class MyGenericService implements GenericService { public Object $invoke(String methodName, String[] parameterTypes, Object[] args) throws GenericException { if (&amp;#34;sayHello&amp;#34;.equals(methodName)) { return &amp;#34;Welcome &amp;#34; + args[0]; } } } 示例 通过 Spring 暴露泛化实现 在 Spring 配置申明服务的实现：
&amp;lt;bean id=&amp;#34;genericService&amp;#34; class=&amp;#34;com.foo.MyGenericService&amp;#34; /&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; ref=&amp;#34;genericService&amp;#34; /&amp;gt; 通过 API 方式暴露泛化实现 ... // 用org.apache.dubbo.rpc.service.GenericService可以替代所有接口实现 GenericService xxxService = new XxxGenericService(); // 该实例很重量，里面封装了所有与注册中心及服务提供方连接，请缓存 ServiceConfig&amp;lt;GenericService&amp;gt; service = new ServiceConfig&amp;lt;GenericService&amp;gt;(); // 弱类型接口名 service.</description></item><item><title>网络传输扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/remoting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/remoting/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 远程通讯的服务器及客户端传输实现。
扩展接口 org.apache.dubbo.remoting.Transporter org.apache.dubbo.remoting.Server org.apache.dubbo.remoting.Client 扩展配置 &amp;lt;!-- 服务器和客户端使用相同的传输实现 --&amp;gt; &amp;lt;dubbo:protocol transporter=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 服务器和客户端使用不同的传输实现 --&amp;gt; &amp;lt;dubbo:protocol server=&amp;#34;xxx&amp;#34; client=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置transporter/server/client属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider transporter=&amp;#34;xxx&amp;#34; server=&amp;#34;xxx&amp;#34; client=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.remoting.transport.transporter.netty.NettyTransporter org.apache.dubbo.remoting.transport.transporter.mina.MinaTransporter org.apache.dubbo.remoting.transport.transporter.grizzly.GrizzlyTransporter 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxTransporter.java (实现Transporter接口) |-XxxServer.java (实现Server接口) |-XxxClient.java (实现Client接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.Transporter (纯文本文件，内容为：xxx=com.xxx.XxxTransporter) XxxTransporter.java：
package com.xxx; import org.apache.dubbo.remoting.Transporter; public class XxxTransporter implements Transporter { public Server bind(URL url, ChannelHandler handler) throws RemotingException { return new XxxServer(url, handler); } public Client connect(URL url, ChannelHandler handler) throws RemotingException { return new XxxClient(url, handler); } } XxxServer.</description></item><item><title>网络传输扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/remoting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/remoting/</guid><description>扩展说明 远程通讯的服务器及客户端传输实现。
扩展接口 org.apache.dubbo.remoting.Transporter org.apache.dubbo.remoting.Server org.apache.dubbo.remoting.Client 扩展配置 &amp;lt;!-- 服务器和客户端使用相同的传输实现 --&amp;gt; &amp;lt;dubbo:protocol transporter=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 服务器和客户端使用不同的传输实现 --&amp;gt; &amp;lt;dubbo:protocol server=&amp;#34;xxx&amp;#34; client=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置transporter/server/client属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider transporter=&amp;#34;xxx&amp;#34; server=&amp;#34;xxx&amp;#34; client=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.remoting.transport.transporter.netty.NettyTransporter org.apache.dubbo.remoting.transport.transporter.mina.MinaTransporter org.apache.dubbo.remoting.transport.transporter.grizzly.GrizzlyTransporter 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxTransporter.java (实现Transporter接口) |-XxxServer.java (实现Server接口) |-XxxClient.java (实现Client接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.Transporter (纯文本文件，内容为：xxx=com.xxx.XxxTransporter) XxxTransporter.java：
package com.xxx; import org.apache.dubbo.remoting.Transporter; public class XxxTransporter implements Transporter { public Server bind(URL url, ChannelHandler handler) throws RemotingException { return new XxxServer(url, handler); } public Client connect(URL url, ChannelHandler handler) throws RemotingException { return new XxxClient(url, handler); } } XxxServer.</description></item><item><title>网络传输扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/remoting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/remoting/</guid><description>扩展说明 远程通讯的服务器及客户端传输实现。
扩展接口 org.apache.dubbo.remoting.Transporter org.apache.dubbo.remoting.Server org.apache.dubbo.remoting.Client 扩展配置 &amp;lt;!-- 服务器和客户端使用相同的传输实现 --&amp;gt; &amp;lt;dubbo:protocol transporter=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 服务器和客户端使用不同的传输实现 --&amp;gt; &amp;lt;dubbo:protocol server=&amp;#34;xxx&amp;#34; client=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置transporter/server/client属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider transporter=&amp;#34;xxx&amp;#34; server=&amp;#34;xxx&amp;#34; client=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.remoting.transport.transporter.netty.NettyTransporter org.apache.dubbo.remoting.transport.transporter.mina.MinaTransporter org.apache.dubbo.remoting.transport.transporter.grizzly.GrizzlyTransporter 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxTransporter.java (实现Transporter接口) |-XxxServer.java (实现Server接口) |-XxxClient.java (实现Client接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.Transporter (纯文本文件，内容为：xxx=com.xxx.XxxTransporter) XxxTransporter.java：
package com.xxx; import org.apache.dubbo.remoting.Transporter; public class XxxTransporter implements Transporter { public Server bind(URL url, ChannelHandler handler) throws RemotingException { return new XxxServer(url, handler); } public Client connect(URL url, ChannelHandler handler) throws RemotingException { return new XxxClient(url, handler); } } XxxServer.</description></item><item><title>0-18 - 线程池执行器被错误使用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/18/</guid><description>可能的原因 自定义设置了线程数量，系统内部发生了未知异常。
排查和解决步骤 可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>1-18 - 未提供 metadata service 端口</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/18/</guid><description>可能的原因 可能是由于metadataType为 local 模式，且 metadataServicePort 配置出错。
排查和解决步骤 1.检查 Provider 侧的 metadataType 属性值。 2.检查 Provider 侧的 metadataServicePort 配置是否正确，特别注意是否和其他应用端口存在冲突。
另请参阅 配置项参考手册</description></item><item><title>2-18 - mesh路由规则未被监听</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/18/</guid><description>可能的原因 mesh 下发了路由规则，但是该规则未被监听。
排查和解决步骤 检查 mesh 路由规则配置是否符合规范。</description></item><item><title>4-18 - 无法从调用中获取服务模型</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/18/</guid><description>可能的原因 当前仅用于单元测试场景，服务模型默认会进行初始化。
排查和解决步骤</description></item><item><title>5-18 - 通知注册事件失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/18/</guid><description>可能的原因 通知已发送，业务处理逻辑上出现意外错误。 配置中心无法连接，超时错误。 排查和解决步骤 检查自定义业务逻辑实现,是否存在运行时异常。 检查配置中心是否能够正常连接。</description></item><item><title>回声测试</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/echo-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/echo-service/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
回声测试用于检测服务是否可用，回声测试按照正常请求流程执行，能够测试整个调用是否通畅，可用于监控。
所有服务自动实现 EchoService 接口，只需将任意服务引用强制转型为 EchoService，即可使用。
Spring 配置：
&amp;lt;dubbo:reference id=&amp;#34;memberService&amp;#34; interface=&amp;#34;com.xxx.MemberService&amp;#34; /&amp;gt; 代码：
// 远程服务引用 MemberService memberService = ctx.getBean(&amp;#34;memberService&amp;#34;); EchoService echoService = (EchoService) memberService; // 强制转型为EchoService // 回声测试可用性 String status = echoService.$echo(&amp;#34;OK&amp;#34;); assert(status.equals(&amp;#34;OK&amp;#34;));</description></item><item><title>回声测试</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/echo-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/echo-service/</guid><description>背景 回声测试用于检测服务是否可用，回声测试按照正常请求流程执行，能够测试整个调用是否通畅，可用于监控。
所有服务自动实现 EchoService 接口，只需将任意服务引用强制转型为 EchoService，即可使用。
示例 Spring 配置：
&amp;lt;dubbo:reference id=&amp;#34;memberService&amp;#34; interface=&amp;#34;com.xxx.MemberService&amp;#34; /&amp;gt; 代码：
// 远程服务引用 MemberService memberService = ctx.getBean(&amp;#34;memberService&amp;#34;); EchoService echoService = (EchoService) memberService; // 强制转型为EchoService // 回声测试可用性 String status = echoService.$echo(&amp;#34;OK&amp;#34;); assert(status.equals(&amp;#34;OK&amp;#34;));</description></item><item><title>基准测试工具包</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/benchmark-tool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/benchmark-tool/</guid><description>下载源码： git clone https://github.com/apache/dubbo.git 编译benchmark: cd dubbo/dubbo-test/dubbo-test-benchmark; mvn clean install 解压 benchmark压缩包： dubbo/dubbo-test/dubbo-test-benchmark/target/dubbo-test-benchmark-2.6.2-SNAPSHOT.tar.gz 阅读ReadMe.txt（内容如下，请以压缩包内的为准）
新建一个benchmark工程，如demo.benchmark
导入自己服务的接口api包和dubbo.benchmark.jar(解压dubbo.benchmark.tar.gz，在lib目录下)
新建一个类，实现AbstractClientRunnable
实现父类的构造函数 实现invoke方法，通过serviceFactory创建本地接口代理，并实现自己的业务逻辑，如下 public Object invoke(ServiceFactory serviceFactory) { DemoService demoService = (DemoService) serviceFactory.get(DemoService.class); return demoService.sendRequest(&amp;#34;hello&amp;#34;); } 将自己的benchmark工程打成jar包,如demo.benchmark.jar
将demo.benchmark.jar 和服务的api包放到dubbo.benchmark/lib目录下
配置dubbo.properties
运行run.bat(windows)或run.sh(linux)
如想测试dubbo的不同版本，直接替换lib下的dubbo的jar包即可。</description></item><item><title>使用案例</title><link>https://dubbo.apache.org/zh-cn/docs/examples/routing/demo-rule-deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/examples/routing/demo-rule-deployment/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
应用服务 com.taobao.hsf.DemoService:1.0.0 服务地址 10.0.0.1:12200?_p=hessian2&amp;amp;APP=demo&amp;amp;st=na61&amp;amp;v=2.0&amp;amp;_TIMEOUT=3000&amp;amp;_ih2=y&amp;amp;mg=demohost&amp;amp;_CONNECTTIMEOUT=1000&amp;amp;_SERIALIZETYPE=hessian&amp;amp;ut=CENTER 10.0.0.2:12200?_p=hessian2&amp;amp;APP=demo&amp;amp;st=na62&amp;amp;v=2.0&amp;amp;_TIMEOUT=3000&amp;amp;_ih2=y&amp;amp;mg=demohost&amp;amp;_CONNECTTIMEOUT=1000&amp;amp;_SERIALIZETYPE=hessian&amp;amp;ut=CENTER 10.0.0.3:12200?_p=hessian2&amp;amp;APP=demo&amp;amp;st=na610&amp;amp;v=2.0&amp;amp;_TIMEOUT=3000&amp;amp;_ih2=y&amp;amp;mg=demohost&amp;amp;_CONNECTTIMEOUT=1000&amp;amp;_SERIALIZETYPE=hessian&amp;amp;ut=CENTER 10.0.0.4:12200?_p=hessian2&amp;amp;APP=demo&amp;amp;st=na620&amp;amp;v=2.0&amp;amp;_TIMEOUT=3000&amp;amp;_ih2=y&amp;amp;mg=demohost&amp;amp;_CONNECTTIMEOUT=1000&amp;amp;_SERIALIZETYPE=hessian&amp;amp;ut=CENTER 10.0.0.4:12200?_p=hessian2&amp;amp;APP=demo&amp;amp;st=et12&amp;amp;v=2.0&amp;amp;_TIMEOUT=3000&amp;amp;_ih2=y&amp;amp;mg=demohost&amp;amp;_CONNECTTIMEOUT=1000&amp;amp;_SERIALIZETYPE=hessian&amp;amp;ut=UNSH 10.0.0.5:12200?_p=hessian2&amp;amp;APP=demo&amp;amp;st=et12&amp;amp;v=2.0&amp;amp;_TIMEOUT=3000&amp;amp;_ih2=y&amp;amp;mg=demohost&amp;amp;_CONNECTTIMEOUT=1000&amp;amp;_SERIALIZETYPE=hessian&amp;amp;ut=UNSH 10.0.0.6:12200?_p=hessian2&amp;amp;APP=demo&amp;amp;st=SA128&amp;amp;v=2.0&amp;amp;_TIMEOUT=3000&amp;amp;_ih2=y&amp;amp;mg=demohost&amp;amp;_CONNECTTIMEOUT=1000&amp;amp;_SERIALIZETYPE=hessian&amp;amp;ut=UNSZ 10.0.0.7:12200?_p=hessian2&amp;amp;APP=demo&amp;amp;st=SA128&amp;amp;v=2.0&amp;amp;_TIMEOUT=3000&amp;amp;_ih2=y&amp;amp;mg=demohost&amp;amp;_CONNECTTIMEOUT=1000&amp;amp;_SERIALIZETYPE=hessian&amp;amp;ut=UNSZ 10.0.0.8:12200?_p=hessian2&amp;amp;APP=demo&amp;amp;st=na62&amp;amp;v=2.0&amp;amp;_TIMEOUT=3000&amp;amp;_ih2=y&amp;amp;mg=demohost&amp;amp;_CONNECTTIMEOUT=1000&amp;amp;_SERIALIZETYPE=hessian&amp;amp;ut=UNZBMIX 10.0.0.9:12200?_p=hessian2&amp;amp;APP=demo&amp;amp;st=na62&amp;amp;v=2.0&amp;amp;_TIMEOUT=3000&amp;amp;_ih2=y&amp;amp;mg=demohost&amp;amp;_CONNECTTIMEOUT=1000&amp;amp;_SERIALIZETYPE=hessian&amp;amp;ut=UNZBMIX 10.0.0.10:12200?_p=hessian2&amp;amp;APP=demo&amp;amp;st=na62&amp;amp;v=2.0&amp;amp;_TIMEOUT=3000&amp;amp;_ih2=y&amp;amp;mg=demohost&amp;amp;_CONNECTTIMEOUT=1000&amp;amp;_SERIALIZETYPE=hessian&amp;amp;ut=UNZBMIX 路由规则 apiVersion: service.dubbo.apache.org/v1alpha1 kind: VirtualService metadata: name: demo/UnitRouter spec: hosts: - demo dubbo: - name: UnitServiceRoute services: - exact: com.taobao.hsf.DemoService:1.0.0 routedetail: - name: center-env match: - context: hsfcontext: user_unit: exact: CENTER route: - destination: host: demo subset: CENTER fallback: // 单元化没有 fallback,直接报错 - name: unsh-env match: - context: hsfcontext: user_unit: exact: UNSH route: - destination: host: demo subset: UNSH - name: unsz-env match: - context: hsfcontext: user_unit: exact: UNSZ route: - destination: host: demo subset: UNSZ - name: zbmix-env match: - context: hsfcontext: user_unit: exact: ZBMIX route: - destination: host: demo subset: ZBMIX ---- apiVersion: service.</description></item><item><title>信息交换扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/exchanger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/exchanger/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 基于传输层之上，实现 Request-Response 信息交换语义。
扩展接口 org.apache.dubbo.remoting.exchange.Exchanger org.apache.dubbo.remoting.exchange.ExchangeServer org.apache.dubbo.remoting.exchange.ExchangeClient 扩展配置 &amp;lt;dubbo:protocol exchanger=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置exchanger属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider exchanger=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.remoting.exchange.exchanger.HeaderExchanger
扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxExchanger.java (实现Exchanger接口) |-XxxExchangeServer.java (实现ExchangeServer接口) |-XxxExchangeClient.java (实现ExchangeClient接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.exchange.Exchanger (纯文本文件，内容为：xxx=com.xxx.XxxExchanger) XxxExchanger.java：
package com.xxx; import org.apache.dubbo.remoting.exchange.Exchanger; public class XxxExchanger implements Exchanger { public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException { return new XxxExchangeServer(url, handler); } public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException { return new XxxExchangeClient(url, handler); } } XxxExchangeServer.</description></item><item><title>信息交换扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/exchanger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/exchanger/</guid><description>扩展说明 基于传输层之上，实现 Request-Response 信息交换语义。
扩展接口 org.apache.dubbo.remoting.exchange.Exchanger org.apache.dubbo.remoting.exchange.ExchangeServer org.apache.dubbo.remoting.exchange.ExchangeClient 扩展配置 &amp;lt;dubbo:protocol exchanger=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置exchanger属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider exchanger=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.remoting.exchange.exchanger.HeaderExchanger
扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxExchanger.java (实现Exchanger接口) |-XxxExchangeServer.java (实现ExchangeServer接口) |-XxxExchangeClient.java (实现ExchangeClient接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.exchange.Exchanger (纯文本文件，内容为：xxx=com.xxx.XxxExchanger) XxxExchanger.java：
package com.xxx; import org.apache.dubbo.remoting.exchange.Exchanger; public class XxxExchanger implements Exchanger { public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException { return new XxxExchangeServer(url, handler); } public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException { return new XxxExchangeClient(url, handler); } } XxxExchangeServer.</description></item><item><title>信息交换扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/exchanger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/exchanger/</guid><description>扩展说明 基于传输层之上，实现 Request-Response 信息交换语义。
扩展接口 org.apache.dubbo.remoting.exchange.Exchanger org.apache.dubbo.remoting.exchange.ExchangeServer org.apache.dubbo.remoting.exchange.ExchangeClient 扩展配置 &amp;lt;dubbo:protocol exchanger=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置exchanger属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider exchanger=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.remoting.exchange.exchanger.HeaderExchanger
扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxExchanger.java (实现Exchanger接口) |-XxxExchangeServer.java (实现ExchangeServer接口) |-XxxExchangeClient.java (实现ExchangeClient接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.exchange.Exchanger (纯文本文件，内容为：xxx=com.xxx.XxxExchanger) XxxExchanger.java：
package com.xxx; import org.apache.dubbo.remoting.exchange.Exchanger; public class XxxExchanger implements Exchanger { public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException { return new XxxExchangeServer(url, handler); } public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException { return new XxxExchangeClient(url, handler); } } XxxExchangeServer.</description></item><item><title>0-19 - 处理任务时发生异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/19/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/19/</guid><description>可能的原因 自定义业务类处理逻辑不当。
排查和解决步骤 可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>1-19 - K8S监听异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/19/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/19/</guid><description>可能的原因 K8S 自定义的资源类型，配置被修改或已被容器移除。 K8S 容器与服务已断开连接。 排查和解决步骤 检查自定义的资源类型，配置是否正确。语法或可请参考 K8S 的官方文档。 检查网络是否正常或端口映射是否正确。</description></item><item><title>2-19 - 异步请求失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/19/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/19/</guid><description>可能的原因 提供方异常，导致消费方异步请求失败。 网络异常，导致消费方异步请求失败。 排查和解决步骤 排查提供方健康状况。 排查网络状况。</description></item><item><title>4-19 - 参数值有出错的可能</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/19/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/19/</guid><description>可能的原因 这个错误码提示参数值可能不再正确。
目前出现在同一个协议同时监听多个端口下。由于设计限制，单个协议只能监听一个端口，否则端口配置会被覆盖掉。
排查和解决步骤 调整协议和端口的监听关系。
该错误码的意义已经调整。对于 Dubbo 3.1.4、3.2.0-beta.3 及其之前的版本的该错误码的出错，请参考错误码 0-2。</description></item><item><title>开发 REST 应用</title><link>https://dubbo.apache.org/zh-cn/docs/references/lifecycle/rest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/lifecycle/rest/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
作者：沈理
文档版权：Apache 2.0许可证 署名-禁止演绎
本文篇幅较长，因为REST本身涉及面较多。另外，本文参照 Spring 等的文档风格，不仅仅局限于框架用法的阐述，同时也努力呈现框架的设计理念和优良应用的架构思想。 对于想粗略了解 dubbo 和 REST 的人，只需浏览 概述 至 标准Java REST API：JAX-RS简介 几节即可。
目录 概述 REST的优点 应用场景 快速入门 标准Java REST API：JAX-RS简介 REST服务提供端详解 HTTP POST/GET的实现 Annotation放在接口类还是实现类 JSON、XML等多数据格式的支持 中文字符支持 XML数据格式的额外要求 定制序列化 配置REST Server的实现 获取上下文（Context）信息 配置端口号和Context Path 配置线程数和IO线程数 配置长连接 配置最大的HTTP连接数 配置每个消费端的超时时间和HTTP连接数 GZIP数据压缩 用Annotation取代部分Spring XML配置 添加自定义的Filter、Interceptor等 添加自定义的Exception处理 配置HTTP日志输出 输入参数的校验 是否应该透明发布REST服务 Dubbo的REST提供端在被调用时使用header REST服务消费端详解 场景1：非dubbo的消费端调用dubbo的REST服务 场景2：dubbo消费端调用dubbo的REST服务 场景3：dubbo的消费端调用非dubbo的REST服务 Dubbo的消费端在调用REST服务时配置自定义header Dubbo中JAX-RS的限制 REST常见问题解答（REST FAQ） Dubbo REST的服务能和Dubbo注册中心、监控中心集成吗？ Dubbo REST中如何实现负载均衡和容错（failover）？ JAX-RS中重载的方法能够映射到同一URL地址吗？ JAX-RS中作POST的方法能够接收多个参数吗？ Dubbo当前体系可能的不足之处（与REST相关的） RpcContext的侵入性 Protocol配置的局限性 XML命名不符合spring规范 REST最佳实践 性能基准测试 测试环境 测试脚本 测试结果 扩展讨论 REST与Thrift、Protobuf等的对比 REST与传统WebServices的对比 JAX-RS与Spring MVC的对比 未来 概述 dubbo支持多种远程调用方式，例如dubbo RPC（二进制序列化 + tcp协议）、http invoker（二进制序列化 + http协议，至少在开源版本没发现对文本序列化的支持）、hessian（二进制序列化 + http协议）、WebServices （文本序列化 + http协议）等等，但缺乏对当今特别流行的REST风格远程调用（文本序列化 + http协议）的支持。</description></item><item><title>开发 REST 应用</title><link>https://dubbo.apache.org/zh-cn/docs/references/protocols/rest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/protocols/rest/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
作者：沈理
文档版权：Apache 2.0许可证 署名-禁止演绎
本文篇幅较长，因为REST本身涉及面较多。另外，本文参照 Spring 等的文档风格，不仅仅局限于框架用法的阐述，同时也努力呈现框架的设计理念和优良应用的架构思想。 对于想粗略了解 dubbo 和 REST 的人，只需浏览 概述 至 标准Java REST API：JAX-RS简介 几节即可。
目录 概述 REST的优点 应用场景 快速入门 标准Java REST API：JAX-RS简介 REST服务提供端详解 HTTP POST/GET的实现 Annotation放在接口类还是实现类 JSON、XML等多数据格式的支持 中文字符支持 XML数据格式的额外要求 定制序列化 配置REST Server的实现 获取上下文（Context）信息 配置端口号和Context Path 配置线程数和IO线程数 配置长连接 配置最大的HTTP连接数 配置每个消费端的超时时间和HTTP连接数 GZIP数据压缩 用Annotation取代部分Spring XML配置 添加自定义的Filter、Interceptor等 添加自定义的Exception处理 配置HTTP日志输出 输入参数的校验 是否应该透明发布REST服务 Dubbo的REST提供端在被调用时使用header REST服务消费端详解 场景1：非dubbo的消费端调用dubbo的REST服务 场景2：dubbo消费端调用dubbo的REST服务 场景3：dubbo的消费端调用非dubbo的REST服务 Dubbo的消费端在调用REST服务时配置自定义header Dubbo中JAX-RS的限制 REST常见问题解答（REST FAQ） Dubbo REST的服务能和Dubbo注册中心、监控中心集成吗？ Dubbo REST中如何实现负载均衡和容错（failover）？ JAX-RS中重载的方法能够映射到同一URL地址吗？ JAX-RS中作POST的方法能够接收多个参数吗？ Dubbo当前体系可能的不足之处（与REST相关的） RpcContext的侵入性 Protocol配置的局限性 XML命名不符合spring规范 REST最佳实践 性能基准测试 测试环境 测试脚本 测试结果 扩展讨论 REST与Thrift、Protobuf等的对比 REST与传统WebServices的对比 JAX-RS与Spring MVC的对比 未来 概述 dubbo支持多种远程调用方式，例如dubbo RPC（二进制序列化 + tcp协议）、http invoker（二进制序列化 + http协议，至少在开源版本没发现对文本序列化的支持）、hessian（二进制序列化 + http协议）、WebServices （文本序列化 + http协议）等等，但缺乏对当今特别流行的REST风格远程调用（文本序列化 + http协议）的支持。</description></item><item><title>开发 REST 应用</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/rest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/rest/</guid><description>作者：沈理
文档版权：Apache 2.0许可证 署名-禁止演绎
本文篇幅较长，因为REST本身涉及面较多。另外，本文参照 Spring 等的文档风格，不仅仅局限于框架用法的阐述，同时也努力呈现框架的设计理念和优良应用的架构思想。 对于想粗略了解 dubbo 和 REST 的人，只需浏览 概述 至 标准Java REST API：JAX-RS简介 几节即可。
目录 概述 REST的优点 应用场景 快速入门 标准Java REST API：JAX-RS简介 REST服务提供端详解 HTTP POST/GET的实现 Annotation放在接口类还是实现类 JSON、XML等多数据格式的支持 中文字符支持 XML数据格式的额外要求 定制序列化 配置REST Server的实现 获取上下文（Context）信息 配置端口号和Context Path 配置线程数和IO线程数 配置长连接 配置最大的HTTP连接数 配置每个消费端的超时时间和HTTP连接数 GZIP数据压缩 用Annotation取代部分Spring XML配置 添加自定义的Filter、Interceptor等 添加自定义的Exception处理 配置HTTP日志输出 输入参数的校验 是否应该透明发布REST服务 Dubbo的REST提供端在被调用时使用header REST服务消费端详解 场景1：非dubbo的消费端调用dubbo的REST服务 场景2：dubbo消费端调用dubbo的REST服务 场景3：dubbo的消费端调用非dubbo的REST服务 Dubbo的消费端在调用REST服务时配置自定义header Dubbo中JAX-RS的限制 REST常见问题解答（REST FAQ） Dubbo REST的服务能和Dubbo注册中心、监控中心集成吗？ Dubbo REST中如何实现负载均衡和容错（failover）？ JAX-RS中重载的方法能够映射到同一URL地址吗？ JAX-RS中作POST的方法能够接收多个参数吗？ Dubbo当前体系可能的不足之处（与REST相关的） RpcContext的侵入性 Protocol配置的局限性 XML命名不符合spring规范 REST最佳实践 性能基准测试 测试环境 测试脚本 测试结果 扩展讨论 REST与Thrift、Protobuf等的对比 REST与传统WebServices的对比 JAX-RS与Spring MVC的对比 未来 概述 dubbo支持多种远程调用方式，例如dubbo RPC（二进制序列化 + tcp协议）、http invoker（二进制序列化 + http协议，至少在开源版本没发现对文本序列化的支持）、hessian（二进制序列化 + http协议）、WebServices （文本序列化 + http协议）等等，但缺乏对当今特别流行的REST风格远程调用（文本序列化 + http协议）的支持。</description></item><item><title>对等网络节点组网器扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/page/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/page/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
页面扩展 扩展说明 对等网络节点组网器。
扩展接口 org.apache.dubbo.container.page.PageHandler
扩展配置 &amp;lt;dubbo:protocol page=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置page属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider page=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.container.page.pages.HomePageHandler org.apache.dubbo.container.page.pages.StatusPageHandler org.apache.dubbo.container.page.pages.LogPageHandler org.apache.dubbo.container.page.pages.SystemPageHandler 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxPageHandler.java (实现PageHandler接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.container.page.PageHandler (纯文本文件，内容为：xxx=com.xxx.XxxPageHandler) XxxPageHandler.java：
package com.xxx; import org.apache.dubbo.container.page.PageHandler; public class XxxPageHandler implements PageHandler { public Group lookup(URL url) { // ... } } META-INF/dubbo/org.apache.dubbo.container.page.PageHandler：
xxx=com.xxx.XxxPageHandler</description></item><item><title>对等网络节点组网器扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/page/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/page/</guid><description>扩展说明 对等网络节点组网器。
扩展接口 org.apache.dubbo.container.page.PageHandler
扩展配置 &amp;lt;dubbo:protocol page=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置page属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider page=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.container.page.pages.HomePageHandler org.apache.dubbo.container.page.pages.StatusPageHandler org.apache.dubbo.container.page.pages.LogPageHandler org.apache.dubbo.container.page.pages.SystemPageHandler 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxPageHandler.java (实现PageHandler接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.container.page.PageHandler (纯文本文件，内容为：xxx=com.xxx.XxxPageHandler) XxxPageHandler.java：
package com.xxx; import org.apache.dubbo.container.page.PageHandler; public class XxxPageHandler implements PageHandler { public Group lookup(URL url) { // ... } } META-INF/dubbo/org.apache.dubbo.container.page.PageHandler：
xxx=com.xxx.XxxPageHandler</description></item><item><title>上下文信息</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/context/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
上下文中存放的是当前调用过程中所需的环境信息。所有配置信息都将转换为 URL 的参数，参见 schema 配置参考手册 中的对应URL参数一列。
RpcContext 是一个 ThreadLocal 的临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。比如：A 调 B，B 再调 C，则 B 机器上，在 B 调 C 之前，RpcContext 记录的是 A 调 B 的信息，在 B 调 C 之后，RpcContext 记录的是 B 调 C 的信息。
服务消费方 // 远程调用 xxxService.xxx(); // 本端是否为消费端，这里会返回true boolean isConsumerSide = RpcContext.getContext().isConsumerSide(); // 获取最后一次调用的提供方IP地址 String serverIP = RpcContext.getContext().getRemoteHost(); // 获取当前服务配置信息，所有配置信息都将转换为URL的参数 String application = RpcContext.getContext().getUrl().getParameter(&amp;#34;application&amp;#34;); // 注意：每发起RPC调用，上下文状态会变化 yyyService.yyy(); 服务提供方 public class XxxServiceImpl implements XxxService { public void xxx() { // 本端是否为提供端，这里会返回true boolean isProviderSide = RpcContext.</description></item><item><title>上下文信息</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/context/</guid><description>背景 上下文中存放的是当前调用过程中所需的环境信息。所有配置信息都将转换为 URL 的参数，参见 schema 配置参考手册 中的对应URL参数一列。
RpcContext 是一个 ThreadLocal 的临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。比如：A 调 B，B 再调 C，则 B 机器上，在 B 调 C 之前，RpcContext 记录的是 A 调 B 的信息，在 B 调 C 之后，RpcContext 记录的是 B 调 C 的信息。
示例 服务消费方 // 远程调用 xxxService.xxx(); // 本端是否为消费端，这里会返回true boolean isConsumerSide = RpcContext.getContext().isConsumerSide(); // 获取最后一次调用的提供方IP地址 String serverIP = RpcContext.getContext().getRemoteHost(); // 获取当前服务配置信息，所有配置信息都将转换为URL的参数 String application = RpcContext.getContext().getUrl().getParameter(&amp;#34;application&amp;#34;); // 注意：每发起RPC调用，上下文状态会变化 yyyService.yyy(); 服务提供方 public class XxxServiceImpl implements XxxService { public void xxx() { // 本端是否为提供端，这里会返回true boolean isProviderSide = RpcContext.</description></item><item><title>组网扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/networker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/networker/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 对等网络节点组网器。
扩展接口 org.apache.dubbo.remoting.p2p.Networker
扩展配置 &amp;lt;dubbo:protocol networker=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置networker属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider networker=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.remoting.p2p.support.MulticastNetworker org.apache.dubbo.remoting.p2p.support.FileNetworker 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxNetworker.java (实现Networker接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.p2p.Networker (纯文本文件，内容为：xxx=com.xxx.XxxNetworker) XxxNetworker.java：
package com.xxx; import org.apache.dubbo.remoting.p2p.Networker; public class XxxNetworker implements Networker { public Group lookup(URL url) { // ... } } META-INF/dubbo/org.apache.dubbo.remoting.p2p.Networker：
xxx=com.xxx.XxxNetworker</description></item><item><title>组网扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/networker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/networker/</guid><description>扩展说明 对等网络节点组网器。
扩展接口 org.apache.dubbo.remoting.p2p.Networker
扩展配置 &amp;lt;dubbo:protocol networker=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置networker属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider networker=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.remoting.p2p.support.MulticastNetworker org.apache.dubbo.remoting.p2p.support.FileNetworker 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxNetworker.java (实现Networker接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.p2p.Networker (纯文本文件，内容为：xxx=com.xxx.XxxNetworker) XxxNetworker.java：
package com.xxx; import org.apache.dubbo.remoting.p2p.Networker; public class XxxNetworker implements Networker { public Group lookup(URL url) { // ... } } META-INF/dubbo/org.apache.dubbo.remoting.p2p.Networker：
xxx=com.xxx.XxxNetworker</description></item><item><title>组网扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/networker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/networker/</guid><description>扩展说明 对等网络节点组网器。
扩展接口 org.apache.dubbo.remoting.p2p.Networker
扩展配置 &amp;lt;dubbo:protocol networker=&amp;#34;xxx&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置networker属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider networker=&amp;#34;xxx&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.remoting.p2p.support.MulticastNetworker org.apache.dubbo.remoting.p2p.support.FileNetworker 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxNetworker.java (实现Networker接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.p2p.Networker (纯文本文件，内容为：xxx=com.xxx.XxxNetworker) XxxNetworker.java：
package com.xxx; import org.apache.dubbo.remoting.p2p.Networker; public class XxxNetworker implements Networker { public Group lookup(URL url) { // ... } } META-INF/dubbo/org.apache.dubbo.remoting.p2p.Networker：
xxx=com.xxx.XxxNetworker</description></item><item><title>Dubbo Java 3.1.3 正式发布</title><link>https://dubbo.apache.org/zh-cn/blog/2022/07/18/dubbo-java-3.1.3-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</link><pubDate>Mon, 18 Jul 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/07/18/dubbo-java-3.1.3-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</guid><description>Dubbo 3.1.3 修改内容 修复本地调用的过程中 Filter 顺序异常的问题 支持导入协议配置项到 MetadataService 支持在发布 MetadataService 时自动选择可用端口 完善错误码内容 泛化调用下支持一致性哈希负载均衡 修复泛化调用时反序列化异常的问题 修复由于 JVM Methods 顺序不一致导致的应用级元数据无法复用的问题 默认关闭端口复用能力，修复 remoting 组建找不到 SPI 的问题 修复由于引用计数异常导致的 safe gard 问题 删除 Nacos 注册中心组建中使用的 guava 依赖 修复接口级使用 Nacos 注册中心时由于地址聚合导致的无法下线的问题 多个代码质量优化提交 新贡献者 @zhangzq7 在 #10847 中提交了第一个贡献 @akaakking 在 #10799 中提交了第一个贡献 @wxbty 在 #10921 中提交了第一个贡献 @haoxz11 在 #10937 中提交了第一个贡献 新贡献者 @weixsun 在 #10941 中提交了第一个贡献 未来的版本规划 3.0、3.1、3.2 有什么区别？未来会怎么发展？发版周期是怎么样的？更多的版本迭代规划也将在近期推出，欢迎关注 Apache Dubbo 官方公众号获取最新的信息。</description></item><item><title>0-20 - 存储堆栈信息时发生异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/20/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/20/</guid><description>可能的原因 JVM设置了参数 -XX:+DisableAttachMechanism 设置了系统不存在的堆栈转储路径，不存在情况，系统会尝试进行创建，创建时发生了 SecurityException, 可能是没有权限。 排查和解决步骤 检查 JVM 是否设置了如上参数。 检查当前启动服务的账号，是否有权限进行创建文件夹。</description></item><item><title>1-20 - K8S Pod不存在</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/20/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/20/</guid><description>可能的原因 控制器 Pending Pod 可能不存在或已被容器移除。 排查和解决步骤 可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>2-20 - 获取分组结果合并时失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/20/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/2/20/</guid><description>可能的原因 获取分组结果合并时失败。
排查和解决步骤 返回结果时，可能出现业务逻辑上的运行时异常，可根据控制台指定的代码行数进行回溯定位。</description></item><item><title>4-20 - 数据解码失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/20/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/20/</guid><description>可能的原因 只发生在解码阶段，可能服务方和调用方的dubbo版本不匹配。
排查和解决步骤 检查当前使用的 dubbo 版本，尽量保持一致或向下兼容的高版本。</description></item><item><title>5-20 - 停止 dubbo 模块时发生错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/20/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/20/</guid><description>可能的原因 自定义实现销毁方法，可能存在业务逻辑运行时异常。 未优雅停止服务，可能存在业务逻辑未处理完成情况。 排查和解决步骤 检查自定义实现销毁方法，业务逻辑。 检查停止服务时，是否存在耗时的业务处理逻辑。</description></item><item><title>API 配置</title><link>https://dubbo.apache.org/zh-cn/docs/references/configuration/api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/configuration/api/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
通过API编码方式组装配置，启动Dubbo，发布及订阅服务。此方式可以支持动态创建ReferenceConfig/ServiceConfig，结合泛化调用可以满足API Gateway或测试平台的需要。
API 属性与XML配置项一一对应，各属性含义请参见：XML配置参考手册，比如：ApplicationConfig.setName(&amp;quot;xxx&amp;quot;) 对应 &amp;lt;dubbo:application name=&amp;quot;xxx&amp;quot; /&amp;gt;
API使用范围说明：API 仅用于 OpenAPI, ESB, Test, Mock, Gateway 等系统集成，普通服务提供方或消费方，请采用XML 配置 或 注解配置 或 属性配置 方式使用 Dubbo
参考API示例
服务提供者 通过ServiceConfig暴露服务接口，发布服务接口到注册中心。
注意：为了更好支持Dubbo3的应用级服务发现，推荐使用新的DubboBootstrap API。
import org.apache.dubbo.config.ApplicationConfig; import org.apache.dubbo.config.RegistryConfig; import org.apache.dubbo.config.ProviderConfig; import org.apache.dubbo.config.ServiceConfig; import com.xxx.DemoService; import com.xxx.DemoServiceImpl; public class DemoProvider { public static void main(String[] args) { // 服务实现 DemoService demoService = new DemoServiceImpl(); // 当前应用配置 ApplicationConfig application = new ApplicationConfig(); application.setName(&amp;#34;demo-provider&amp;#34;); // 连接注册中心配置 RegistryConfig registry = new RegistryConfig(); registry.</description></item><item><title>Go</title><link>https://dubbo.apache.org/zh-cn/download/go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/download/go/</guid><description/></item><item><title>Grpc NetWorkFilter 介绍</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/networkfilter/grpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/networkfilter/grpc/</guid><description>使用 grpc 调用服务提供程序 下面的文档符合代码
定义Pixiu配置文件 static_resources: listeners: - name: &amp;#34;net/http&amp;#34; protocol_type: &amp;#34;HTTP&amp;#34; address: socket_address: address: &amp;#34;0.0.0.0&amp;#34; port: 8881 filter_chains: filters: - name: dgp.filter.httpconnectionmanager config: route_config: routes: - match: prefix: &amp;#34;/api/v1&amp;#34; route: cluster: &amp;#34;test-grpc&amp;#34; cluster_not_found_response_code: 505 http_filters: - name: dgp.filter.http.grpcproxy config: path: /mnt/d/WorkSpace/GoLandProjects/dubbo-go-pixiu/samples/http/grpc/proto - name: dgp.filter.http.response config: server_name: &amp;#34;test-http-grpc&amp;#34; generate_request_id: false config: idle_timeout: 5s read_timeout: 5s write_timeout: 5s clusters: - name: &amp;#34;test-grpc&amp;#34; lb_policy: &amp;#34;RoundRobin&amp;#34; endpoints: - socket_address: address: 127.0.0.1 port: 50001 protocol_type: &amp;#34;GRPC&amp;#34; timeout_config: connect_timeout: &amp;#34;5s&amp;#34; request_timeout: &amp;#34;10s&amp;#34; shutdown_config: timeout: &amp;#34;60s&amp;#34; step_timeout: &amp;#34;10s&amp;#34; reject_policy: &amp;#34;immediacy&amp;#34; Grpc 服务器在“集群”中定义</description></item><item><title>Http to Dubbo 案例介绍</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/samples/http_to_dubbo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/samples/http_to_dubbo/</guid><description>欢迎认领补充此文档。</description></item><item><title>Http2 Listener 介绍</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/listener/http2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/listener/http2/</guid><description>欢迎认领补充此文档。</description></item><item><title>RateLimiter 介绍</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/httpfilter/ratelimit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/httpfilter/ratelimit/</guid><description>欢迎认领补充此文档。</description></item><item><title>Spring Cloud 集群中心 Adapter</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/adapter/springcloud/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/adapter/springcloud/</guid><description/></item><item><title>Telnet 命令扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/telnet-handler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/telnet-handler/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 所有服务器均支持 telnet 访问，用于人工干预。
扩展接口 org.apache.dubbo.remoting.telnet.TelnetHandler
扩展配置 &amp;lt;dubbo:protocol telnet=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置telnet属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider telnet=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.remoting.telnet.support.ClearTelnetHandler org.apache.dubbo.remoting.telnet.support.ExitTelnetHandler org.apache.dubbo.remoting.telnet.support.HelpTelnetHandler org.apache.dubbo.remoting.telnet.support.StatusTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.ListTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.ChangeTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.CurrentTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.InvokeTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.TraceTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.CountTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.PortTelnetHandler 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxTelnetHandler.java (实现TelnetHandler接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.telnet.TelnetHandler (纯文本文件，内容为：xxx=com.xxx.XxxTelnetHandler) XxxTelnetHandler.java：
package com.xxx; import org.apache.dubbo.remoting.telnet.TelnetHandler; @Help(parameter=&amp;#34;...&amp;#34;, summary=&amp;#34;...&amp;#34;, detail=&amp;#34;...&amp;#34;) public class XxxTelnetHandler implements TelnetHandler { public String telnet(Channel channel, String message) throws RemotingException { // ... } } META-INF/dubbo/org.</description></item><item><title>Telnet 命令扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/telnet-handler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/telnet-handler/</guid><description>扩展说明 所有服务器均支持 telnet 访问，用于人工干预。
扩展接口 org.apache.dubbo.remoting.telnet.TelnetHandler
扩展配置 &amp;lt;dubbo:protocol telnet=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置telnet属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider telnet=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.remoting.telnet.support.ClearTelnetHandler org.apache.dubbo.remoting.telnet.support.ExitTelnetHandler org.apache.dubbo.remoting.telnet.support.HelpTelnetHandler org.apache.dubbo.remoting.telnet.support.StatusTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.ListTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.ChangeTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.CurrentTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.InvokeTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.TraceTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.CountTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.PortTelnetHandler 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxTelnetHandler.java (实现TelnetHandler接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.telnet.TelnetHandler (纯文本文件，内容为：xxx=com.xxx.XxxTelnetHandler) XxxTelnetHandler.java：
package com.xxx; import org.apache.dubbo.remoting.telnet.TelnetHandler; @Help(parameter=&amp;#34;...&amp;#34;, summary=&amp;#34;...&amp;#34;, detail=&amp;#34;...&amp;#34;) public class XxxTelnetHandler implements TelnetHandler { public String telnet(Channel channel, String message) throws RemotingException { // ... } } META-INF/dubbo/org.</description></item><item><title>Telnet 命令扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/telnet-handler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/telnet-handler/</guid><description>扩展说明 所有服务器均支持 telnet 访问，用于人工干预。
扩展接口 org.apache.dubbo.remoting.telnet.TelnetHandler
扩展配置 &amp;lt;dubbo:protocol telnet=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置telnet属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider telnet=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.remoting.telnet.support.ClearTelnetHandler org.apache.dubbo.remoting.telnet.support.ExitTelnetHandler org.apache.dubbo.remoting.telnet.support.HelpTelnetHandler org.apache.dubbo.remoting.telnet.support.StatusTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.ListTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.ChangeTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.CurrentTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.InvokeTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.TraceTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.CountTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.PortTelnetHandler 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxTelnetHandler.java (实现TelnetHandler接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.telnet.TelnetHandler (纯文本文件，内容为：xxx=com.xxx.XxxTelnetHandler) XxxTelnetHandler.java：
package com.xxx; import org.apache.dubbo.remoting.telnet.TelnetHandler; @Help(parameter=&amp;#34;...&amp;#34;, summary=&amp;#34;...&amp;#34;, detail=&amp;#34;...&amp;#34;) public class XxxTelnetHandler implements TelnetHandler { public String telnet(Channel channel, String message) throws RemotingException { // ... } } META-INF/dubbo/org.</description></item><item><title>简单监控</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/simple-monitor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/simple-monitor/</guid><description>Warning 监控中心也是一个标准的 Dubbo 服务，可以通过注册中心发现，也可以直连。 暴露一个简单监控中心服务到注册中心: (如果是用安装包，不需要自己写这个配置，如果是自己实现监控中心，则需要)
&amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;!-- 当前应用信息配置 --&amp;gt; &amp;lt;dubbo:application name=&amp;#34;simple-monitor&amp;#34; /&amp;gt; &amp;lt;!-- 连接注册中心配置 --&amp;gt; &amp;lt;dubbo:registry address=&amp;#34;127.0.0.1:9090&amp;#34; /&amp;gt; &amp;lt;!-- 暴露服务协议配置 --&amp;gt; &amp;lt;dubbo:protocol port=&amp;#34;7070&amp;#34; /&amp;gt; &amp;lt;!-- 暴露服务配置 --&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;org.apache.dubbo.monitor.MonitorService&amp;#34; ref=&amp;#34;monitorService&amp;#34; /&amp;gt; &amp;lt;bean id=&amp;#34;monitorService&amp;#34; class=&amp;#34;org.apache.dubbo.monitor.simple.SimpleMonitorService&amp;#34; /&amp;gt; &amp;lt;/beans&amp;gt; 通过注册中心发现监控中心服务:
&amp;lt;dubbo:monitor protocol=&amp;#34;registry&amp;#34; /&amp;gt; 或者在 dubbo.properties 配置：
dubbo.monitor.protocol=registry 暴露一个简单监控中心服务，但不注册到注册中心: (如果是用安装包，不需要自己写这个配置，如果是自己实现监控中心，则需要)
&amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;!-- 当前应用信息配置 --&amp;gt; &amp;lt;dubbo:application name=&amp;#34;simple-monitor&amp;#34; /&amp;gt; &amp;lt;!-- 暴露服务协议配置 --&amp;gt; &amp;lt;dubbo:protocol port=&amp;#34;7070&amp;#34; /&amp;gt; &amp;lt;!</description></item><item><title>蓝绿部署</title><link>https://dubbo.apache.org/zh-cn/docs/examples/routing/blue-green-deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/examples/routing/blue-green-deployment/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
场景描述 描述当前IDC、服务部署、服务信息、希望实现的效果等相关情况
操作工艺 步骤1
路由配置 验证方案 步骤2
路由配置 验证方案</description></item><item><title>启动和配置</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/configurations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/configurations/</guid><description>Pixiu 启动命令 Pixiu 分为两个形态 Gateway 和 Sidecar，目前 Pixiu 可执行程序的命令如下所示，其中 pixiu 是可执行文件名称。注意，-c 后是本地配置文件的绝对路径。
pixiu gateway start -c /config/conf.yaml 配置详解 Pixiu 接受 yaml 格式的文件作为其主配置文件，其中对 Pixiu 的各类组件进行配置。我们以快速开始中的配置文件为例，详细讲解其中的组成部分，并且列出可能的扩展。
static_resources: listeners: - name: &amp;#34;net/http&amp;#34; protocol_type: &amp;#34;HTTP&amp;#34; address: socket_address: address: &amp;#34;0.0.0.0&amp;#34; port: 8883 filter_chains: filters: - name: dgp.filter.httpconnectionmanager config: route_config: routes: - match: prefix: &amp;#34;*&amp;#34; http_filters: - name: dgp.filter.http.dubboproxy config: dubboProxyConfig: auto_resolve: true registries: &amp;#34;zookeeper&amp;#34;: protocol: &amp;#34;zookeeper&amp;#34; timeout: &amp;#34;3s&amp;#34; address: &amp;#34;127.0.0.1:2181&amp;#34; username: &amp;#34;&amp;#34; password: &amp;#34;&amp;#34; 首先，类似 envoy的配置，static_resources 表示如下都是静态配置。在静态配置中包括 Listener，NetworkFilter，Route，HttpFilter等组件，它们之间并不是完全独立的。</description></item><item><title>隐式参数</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/attachment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/attachment/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
可以通过 RpcContext 上的 setAttachment 和 getAttachment 在服务消费方和提供方之间进行参数的隐式传递。
注意 path, group, version, dubbo, token, timeout 几个 key 是保留字段，请使用其它值。 在服务消费方端设置隐式参数 setAttachment 设置的 KV 对，在完成下面一次远程调用会被清空，即多次远程调用要多次设置。
RpcContext.getContext().setAttachment(&amp;#34;index&amp;#34;, &amp;#34;1&amp;#34;); // 隐式传参，后面的远程调用都会隐式将这些参数发送到服务器端，类似cookie，用于框架集成，不建议常规业务使用 xxxService.xxx(); // 远程调用 // ... 在服务提供方端获取隐式参数 public class XxxServiceImpl implements XxxService { public void xxx() { // 获取客户端隐式传入的参数，用于框架集成，不建议常规业务使用 String index = RpcContext.getContext().getAttachment(&amp;#34;index&amp;#34;); } }</description></item><item><title>隐式参数</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/attachment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/attachment/</guid><description>背景 可以通过 RpcContext 上的 setAttachment 和 getAttachment 在服务消费方和提供方之间进行参数的隐式传递。
注意 path, group, version, dubbo, token, timeout 几个 key 是保留字段，请使用其它值。 示例 在服务消费方端设置隐式参数 setAttachment 设置的 KV 对，在完成下面一次远程调用会被清空，即多次远程调用要多次设置。
RpcContext.getContext().setAttachment(&amp;#34;index&amp;#34;, &amp;#34;1&amp;#34;); // 隐式传参，后面的远程调用都会隐式将这些参数发送到服务器端，类似cookie，用于框架集成，不建议常规业务使用 xxxService.xxx(); // 远程调用 // ... 在服务提供方端获取隐式参数 public class XxxServiceImpl implements XxxService { public void xxx() { // 获取客户端隐式传入的参数，用于框架集成，不建议常规业务使用 String index = RpcContext.getContext().getAttachment(&amp;#34;index&amp;#34;); } }</description></item><item><title>0-21 - 构建的实例过多</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/21/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/21/</guid><description>可能的原因 一般指 org.apache.dubbo.common.timer.HashedWheelTimer 创建的实例过多。
排查和解决步骤 不影响实例的构建，可能存在内存泄露的风险。</description></item><item><title>1-21 - K8S 无可用服务</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/21/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/21/</guid><description>可能的原因 当前服务未正确加载。 配置的Pod确实不存在当前实例服务。 排查和解决步骤 可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>4-21 - 检测到不安全的序列化数据</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/21/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/4/21/</guid><description>可能的原因 当前服务端可能受到攻击或者是 Dubbo 内置的类检查逻辑没有扫描到您所定义的类。
排查和解决步骤 如果请求源是攻击源，请及时进行安全加固。 如果请求源是预期的，请在 security/serialize.allowlist 资源文件中声明您所使用的类名，Dubbo 将自动将其加载到安全列表中。请参考 类检查机制 一文。 当前 Dubbo 可以工作在监控模式和限制模式下。监控模式只打印日志，不进行拦截；限制模型将进行拦截。</description></item><item><title>5-21 - 服务销毁时发生异常错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/21/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/21/</guid><description>可能的原因 服务发现实例已销毁完成
当前方法在 3.1 版本已停止使用
排查和解决步骤</description></item><item><title>异步调用</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/async-call/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/async-call/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
从 2.7.0 开始，Dubbo 的所有异步编程接口开始以 CompletableFuture 为基础
基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小。
使用 CompletableFuture 签名的接口 需要服务提供者事先定义 CompletableFuture 签名的服务，具体参见服务端异步执行接口定义：
public interface AsyncService { CompletableFuture&amp;lt;String&amp;gt; sayHello(String name); } 注意接口的返回类型是 CompletableFuture&amp;lt;String&amp;gt;。
XML引用服务：
&amp;lt;dubbo:reference id=&amp;#34;asyncService&amp;#34; timeout=&amp;#34;10000&amp;#34; interface=&amp;#34;com.alibaba.dubbo.samples.async.api.AsyncService&amp;#34;/&amp;gt; 调用远程服务：
// 调用直接返回CompletableFuture CompletableFuture&amp;lt;String&amp;gt; future = asyncService.sayHello(&amp;#34;async call request&amp;#34;); // 增加回调 future.whenComplete((v, t) -&amp;gt; { if (t != null) { t.printStackTrace(); } else { System.out.println(&amp;#34;Response: &amp;#34; + v); } }); // 早于结果输出 System.out.println(&amp;#34;Executed before response return.&amp;#34;); 使用 RpcContext 在 consumer.</description></item><item><title>异步调用</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/async-call/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/async-call/</guid><description>背景 从 2.7.0 开始，Dubbo 的所有异步编程接口开始以 CompletableFuture 为基础
基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小。
示例 使用 CompletableFuture 签名的接口 需要服务提供者事先定义 CompletableFuture 签名的服务，具体参见服务端异步执行接口定义：
public interface AsyncService { CompletableFuture&amp;lt;String&amp;gt; sayHello(String name); } 注意接口的返回类型是 CompletableFuture&amp;lt;String&amp;gt;。
XML引用服务：
&amp;lt;dubbo:reference id=&amp;#34;asyncService&amp;#34; timeout=&amp;#34;10000&amp;#34; interface=&amp;#34;com.alibaba.dubbo.samples.async.api.AsyncService&amp;#34;/&amp;gt; 调用远程服务：
// 调用直接返回CompletableFuture CompletableFuture&amp;lt;String&amp;gt; future = asyncService.sayHello(&amp;#34;async call request&amp;#34;); // 增加回调 future.whenComplete((v, t) -&amp;gt; { if (t != null) { t.printStackTrace(); } else { System.out.println(&amp;#34;Response: &amp;#34; + v); } }); // 早于结果输出 System.out.println(&amp;#34;Executed before response return.&amp;#34;); 使用 RpcContext 在 consumer.</description></item><item><title>异步执行</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/async-execute-on-provider/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/async-execute-on-provider/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Provider端异步执行将阻塞的业务从Dubbo内部线程池切换到业务自定义线程，避免Dubbo线程池的过度占用，有助于避免不同服务间的互相影响。异步执行无异于节省资源或提升RPC响应性能，因为如果业务执行需要阻塞，则始终还是要有线程来负责执行。
注意 Provider 端异步执行和 Consumer 端异步调用是相互独立的，你可以任意正交组合两端配置
Consumer同步 - Provider同步 Consumer异步 - Provider同步 Consumer同步 - Provider异步 Consumer异步 - Provider异步 定义 CompletableFuture 签名的接口 服务接口定义：
public interface AsyncService { CompletableFuture&amp;lt;String&amp;gt; sayHello(String name); } 服务实现：
public class AsyncServiceImpl implements AsyncService { @Override public CompletableFuture&amp;lt;String&amp;gt; sayHello(String name) { RpcContext savedContext = RpcContext.getContext(); // 建议为supplyAsync提供自定义线程池，避免使用JDK公用线程池 return CompletableFuture.supplyAsync(() -&amp;gt; { System.out.println(savedContext.getAttachment(&amp;#34;consumer-key1&amp;#34;)); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } return &amp;#34;async response from provider.</description></item><item><title>异步执行</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/async-execute-on-provider/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/async-execute-on-provider/</guid><description>背景 Provider端异步执行将阻塞的业务从Dubbo内部线程池切换到业务自定义线程，避免Dubbo线程池的过度占用，有助于避免不同服务间的互相影响。异步执行无异于节省资源或提升RPC响应性能，因为如果业务执行需要阻塞，则始终还是要有线程来负责执行。
注意 Provider 端异步执行和 Consumer 端异步调用是相互独立的，你可以任意正交组合两端配置
Consumer同步 - Provider同步 Consumer异步 - Provider同步 Consumer同步 - Provider异步 Consumer异步 - Provider异步 示例 定义 CompletableFuture 签名的接口 服务接口定义：
public interface AsyncService { CompletableFuture&amp;lt;String&amp;gt; sayHello(String name); } 服务实现：
public class AsyncServiceImpl implements AsyncService { @Override public CompletableFuture&amp;lt;String&amp;gt; sayHello(String name) { RpcContext savedContext = RpcContext.getContext(); // 建议为supplyAsync提供自定义线程池，避免使用JDK公用线程池 return CompletableFuture.supplyAsync(() -&amp;gt; { System.out.println(savedContext.getAttachment(&amp;#34;consumer-key1&amp;#34;)); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } return &amp;#34;async response from provider.</description></item><item><title>状态检查扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/status-checker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/status-checker/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 检查服务依赖各种资源的状态，此状态检查可同时用于 telnet 的 status 命令和 hosting 的 status 页面。
扩展接口 org.apache.dubbo.common.status.StatusChecker
扩展配置 &amp;lt;dubbo:protocol status=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置status属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider status=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.common.status.support.MemoryStatusChecker org.apache.dubbo.common.status.support.LoadStatusChecker org.apache.dubbo.rpc.dubbo.status.ServerStatusChecker org.apache.dubbo.rpc.dubbo.status.ThreadPoolStatusChecker org.apache.dubbo.registry.directory.RegistryStatusChecker org.apache.dubbo.rpc.config.spring.status.SpringStatusChecker org.apache.dubbo.rpc.config.spring.status.DataSourceStatusChecker 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxStatusChecker.java (实现StatusChecker接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.status.StatusChecker (纯文本文件，内容为：xxx=com.xxx.XxxStatusChecker) XxxStatusChecker.java：
package com.xxx; import org.apache.dubbo.common.status.StatusChecker; public class XxxStatusChecker implements StatusChecker { public Status check() { // ... } } META-INF/dubbo/org.apache.dubbo.common.status.StatusChecker：
xxx=com.xxx.XxxStatusChecker</description></item><item><title>状态检查扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/status-checker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/status-checker/</guid><description>扩展说明 检查服务依赖各种资源的状态，此状态检查可同时用于 telnet 的 status 命令和 hosting 的 status 页面。
扩展接口 org.apache.dubbo.common.status.StatusChecker
扩展配置 &amp;lt;dubbo:protocol status=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置status属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider status=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.common.status.support.MemoryStatusChecker org.apache.dubbo.common.status.support.LoadStatusChecker org.apache.dubbo.rpc.dubbo.status.ServerStatusChecker org.apache.dubbo.rpc.dubbo.status.ThreadPoolStatusChecker org.apache.dubbo.registry.directory.RegistryStatusChecker org.apache.dubbo.rpc.config.spring.status.SpringStatusChecker org.apache.dubbo.rpc.config.spring.status.DataSourceStatusChecker 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxStatusChecker.java (实现StatusChecker接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.status.StatusChecker (纯文本文件，内容为：xxx=com.xxx.XxxStatusChecker) XxxStatusChecker.java：
package com.xxx; import org.apache.dubbo.common.status.StatusChecker; public class XxxStatusChecker implements StatusChecker { public Status check() { // ... } } META-INF/dubbo/org.apache.dubbo.common.status.StatusChecker：
xxx=com.xxx.XxxStatusChecker</description></item><item><title>状态检查扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/status-checker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/status-checker/</guid><description>扩展说明 检查服务依赖各种资源的状态，此状态检查可同时用于 telnet 的 status 命令和 hosting 的 status 页面。
扩展接口 org.apache.dubbo.common.status.StatusChecker
扩展配置 &amp;lt;dubbo:protocol status=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置status属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider status=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.common.status.support.MemoryStatusChecker org.apache.dubbo.common.status.support.LoadStatusChecker org.apache.dubbo.rpc.dubbo.status.ServerStatusChecker org.apache.dubbo.rpc.dubbo.status.ThreadPoolStatusChecker org.apache.dubbo.registry.directory.RegistryStatusChecker org.apache.dubbo.rpc.config.spring.status.SpringStatusChecker org.apache.dubbo.rpc.config.spring.status.DataSourceStatusChecker 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxStatusChecker.java (实现StatusChecker接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.status.StatusChecker (纯文本文件，内容为：xxx=com.xxx.XxxStatusChecker) XxxStatusChecker.java：
package com.xxx; import org.apache.dubbo.common.status.StatusChecker; public class XxxStatusChecker implements StatusChecker { public Status check() { // ... } } META-INF/dubbo/org.apache.dubbo.common.status.StatusChecker：
xxx=com.xxx.XxxStatusChecker</description></item><item><title>0-22 - 输入输出流异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/22/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/22/</guid><description>可能的原因 读取不再可用的本地文件。 尝试读取/写入文件但没有权限。 尝试写入文件但磁盘空间不再可用。 排查和解决步骤 检查本地文件是否存在。 检查文件权限。 检查磁盘空间。 可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>1-22 - K8S 配置地址错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/22/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/22/</guid><description>可能的原因 K8S url 配置错误，无法正常访问。
排查和解决步骤 检查 K8S url 配置信息，确保端口映射也可正常访问。</description></item><item><title>5-22 - 注册中心在初始化时发生错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/22/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/22/</guid><description>可能的原因 注册中心的地址配置错误。 配置的地址信息无法通过网络正常连接。 配置中心客户端的版本与实际服务端的版本不符，存在兼容性异常。 排查和解决步骤 检查配置地址是否正确。 检查网络是否通畅并可通过第三方客户端进行连接。 检查是否存在兼容性匹配问题，可参考第三方网站进行版本适配。</description></item><item><title>本地调用</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/local-call/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/local-call/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
本地调用使用了 injvm 协议，是一个伪协议，它不开启端口，不发起远程调用，只在 JVM 内直接关联，但执行 Dubbo 的 Filter 链。
配置 定义 injvm 协议
&amp;lt;dubbo:protocol name=&amp;#34;injvm&amp;#34; /&amp;gt; 设置默认协议
&amp;lt;dubbo:provider protocol=&amp;#34;injvm&amp;#34; /&amp;gt; 设置服务协议
&amp;lt;dubbo:service protocol=&amp;#34;injvm&amp;#34; /&amp;gt; 优先使用 injvm
&amp;lt;dubbo:consumer injvm=&amp;#34;true&amp;#34; .../&amp;gt; &amp;lt;dubbo:provider injvm=&amp;#34;true&amp;#34; .../&amp;gt; 或
&amp;lt;dubbo:reference injvm=&amp;#34;true&amp;#34; .../&amp;gt; &amp;lt;dubbo:service injvm=&amp;#34;true&amp;#34; .../&amp;gt; 注意 Dubbo 从 2.2.0 每个服务默认都会在本地暴露，无需进行任何配置即可进行本地引用，如果不希望服务进行远程暴露，只需要在 provider 将 protocol 设置成 injvm 即可 自动暴露、引用本地服务 从 2.2.0 开始，每个服务默认都会在本地暴露。在引用服务的时候，默认优先引用本地服务。如果希望引用远程服务可以使用一下配置强制引用远程服务。
&amp;lt;dubbo:reference ... scope=&amp;#34;remote&amp;#34; /&amp;gt;</description></item><item><title>本地调用</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/local-call/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/local-call/</guid><description>背景 本地调用使用了 injvm 协议，是一个伪协议，它不开启端口，不发起远程调用，只在 JVM 内直接关联，但执行 Dubbo 的 Filter 链。
示例 定义 injvm 协议
&amp;lt;dubbo:protocol name=&amp;#34;injvm&amp;#34; /&amp;gt; 设置默认协议
&amp;lt;dubbo:provider protocol=&amp;#34;injvm&amp;#34; /&amp;gt; 设置服务协议
&amp;lt;dubbo:service protocol=&amp;#34;injvm&amp;#34; /&amp;gt; 优先使用 injvm
&amp;lt;dubbo:consumer injvm=&amp;#34;true&amp;#34; .../&amp;gt; &amp;lt;dubbo:provider injvm=&amp;#34;true&amp;#34; .../&amp;gt; 或
&amp;lt;dubbo:reference injvm=&amp;#34;true&amp;#34; .../&amp;gt; &amp;lt;dubbo:service injvm=&amp;#34;true&amp;#34; .../&amp;gt; 注意 Dubbo 从 2.2.0 每个服务默认都会在本地暴露，无需进行任何配置即可进行本地引用，如果不希望服务进行远程暴露，只需要在 provider 将 protocol 设置成 injvm 即可 自动暴露、引用本地服务 从 2.2.0 开始，每个服务默认都会在本地暴露。在引用服务的时候，默认优先引用本地服务。如果希望引用远程服务可以使用一下配置强制引用远程服务。
&amp;lt;dubbo:reference ... scope=&amp;#34;remote&amp;#34; /&amp;gt;</description></item><item><title>本地调用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/local-call/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/local-call/</guid><description>特性说明 本地调用使用了 injvm 协议，是一个伪协议，它不开启端口，不发起远程调用，只在 JVM 内直接关联，但执行 Dubbo 的 Filter 链。
使用场景 当我们需要调用远程服务时，远程服务并没有开发完成，使用 injvm 协议在本地实现类似服务，调用此服务时可以调用我们本地的实现服务。
使用方式 定义 injvm 协议 &amp;lt;dubbo:protocol name=&amp;#34;injvm&amp;#34; /&amp;gt; 设置默认协议 &amp;lt;dubbo:provider protocol=&amp;#34;injvm&amp;#34; /&amp;gt; 设置服务协议 &amp;lt;dubbo:service protocol=&amp;#34;injvm&amp;#34; /&amp;gt; 优先使用 injvm &amp;lt;dubbo:consumer injvm=&amp;#34;true&amp;#34; .../&amp;gt; &amp;lt;dubbo:provider injvm=&amp;#34;true&amp;#34; .../&amp;gt; 或
&amp;lt;dubbo:reference injvm=&amp;#34;true&amp;#34; .../&amp;gt; &amp;lt;dubbo:service injvm=&amp;#34;true&amp;#34; .../&amp;gt; 注意 Dubbo 从 2.2.0 每个服务默认都会在本地暴露，无需进行任何配置即可进行本地引用，如果不希望服务进行远程暴露，只需要在 provider 将 protocol 设置成 injvm 即可。 自动暴露 从 2.2.0 开始，每个服务默认都会在本地暴露。在引用服务的时候，默认优先引用本地服务。如果希望引用远程服务可以使用一下配置强制引用远程服务。
&amp;lt;dubbo:reference ... scope=&amp;#34;remote&amp;#34; /&amp;gt; 动态配置调用行为 从3.2开始，Dubbo提供api可以让用户在使用中动态地去配置单一次调用时为本地调用或者远程调用，当没配置的时候将默认优先引用本地服务
配置单一次调用为远程调用
RpcContext.getServiceContext().setLocalInvoke(false); 配置单一次调用为本地调用
RpcContext.getServiceContext().setLocalInvoke(true);</description></item><item><title>容器扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/container/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/container/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 服务容器扩展，用于自定义加载内容。
扩展接口 org.apache.dubbo.container.Container
扩展配置 java org.apache.dubbo.container.Main spring jetty log4j 已知扩展 org.apache.dubbo.container.spring.SpringContainer org.apache.dubbo.container.spring.JettyContainer org.apache.dubbo.container.spring.Log4jContainer 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxContainer.java (实现Container接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.container.Container (纯文本文件，内容为：xxx=com.xxx.XxxContainer) XxxContainer.java：
package com.xxx; org.apache.dubbo.container.Container; public class XxxContainer implements Container { public Status start() { // ... } public Status stop() { // ... } } META-INF/dubbo/org.apache.dubbo.container.Container：
xxx=com.xxx.XxxContainer</description></item><item><title>容器扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/container/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/container/</guid><description>扩展说明 服务容器扩展，用于自定义加载内容。
扩展接口 org.apache.dubbo.container.Container
扩展配置 java org.apache.dubbo.container.Main spring jetty log4j 已知扩展 org.apache.dubbo.container.spring.SpringContainer org.apache.dubbo.container.spring.JettyContainer org.apache.dubbo.container.spring.Log4jContainer 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxContainer.java (实现Container接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.container.Container (纯文本文件，内容为：xxx=com.xxx.XxxContainer) XxxContainer.java：
package com.xxx; org.apache.dubbo.container.Container; public class XxxContainer implements Container { public Status start() { // ... } public Status stop() { // ... } } META-INF/dubbo/org.apache.dubbo.container.Container：
xxx=com.xxx.XxxContainer</description></item><item><title>容器扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/container/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/container/</guid><description>扩展说明 服务容器扩展，用于自定义加载内容。
扩展接口 org.apache.dubbo.container.Container
扩展配置 java org.apache.dubbo.container.Main spring jetty log4j 已知扩展 org.apache.dubbo.container.spring.SpringContainer org.apache.dubbo.container.spring.JettyContainer org.apache.dubbo.container.spring.Log4jContainer 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxContainer.java (实现Container接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.container.Container (纯文本文件，内容为：xxx=com.xxx.XxxContainer) XxxContainer.java：
package com.xxx; org.apache.dubbo.container.Container; public class XxxContainer implements Container { public Status start() { // ... } public Status stop() { // ... } } META-INF/dubbo/org.apache.dubbo.container.Container：
xxx=com.xxx.XxxContainer</description></item><item><title>0-23 - 序列化数据转换异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/23/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/23/</guid><description>可能的原因 待序列化数据中存在循环引用，导致堆栈溢出。 引用的 jar 包版本低或存在兼容性问题。 排查和解决步骤 如使用 FastJson，去掉 SerializerFeature.DisableCircularReferenceDetec 检查下或升级版本进行尝试。 可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>5-23 - 等待导出/引用服务发生异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/23/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/23/</guid><description>可能的原因 导出/引用服务时，注册中心异常停止或无法对外提供正常服务。
排查和解决步骤 检查注册中心的是否可正常连接，并检查当前客户端版本是否与服务端兼容匹配。
导出/引用单方法内都对异常做了处理，理论上此异常不会被抛出。</description></item><item><title>参数回调</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/callback-parameter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/callback-parameter/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
参数回调方式与调用本地 callback 或 listener 相同，只需要在 Spring 的配置文件中声明哪个参数是 callback 类型即可。Dubbo 将基于长连接生成反向代理，这样就可以从服务器端调用客户端逻辑。可以参考 dubbo 项目中的示例代码。
服务接口示例 CallbackService.java package com.callback; public interface CallbackService { void addListener(String key, CallbackListener listener); } CallbackListener.java package com.callback; public interface CallbackListener { void changed(String msg); } 服务提供者接口实现示例 package com.callback.impl; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Map; import java.util.concurrent.ConcurrentHashMap; import com.callback.CallbackListener; import com.callback.CallbackService; public class CallbackServiceImpl implements CallbackService { private final Map&amp;lt;String, CallbackListener&amp;gt; listeners = new ConcurrentHashMap&amp;lt;String, CallbackListener&amp;gt;(); public CallbackServiceImpl() { Thread t = new Thread(new Runnable() { public void run() { while(true) { try { for(Map.</description></item><item><title>参数回调</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/callback-parameter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/callback-parameter/</guid><description>背景 参数回调方式与调用本地 callback 或 listener 相同，只需要在 Spring 的配置文件中声明哪个参数是 callback 类型即可。Dubbo 将基于长连接生成反向代理，这样就可以从服务器端调用客户端逻辑。可以参考 dubbo 项目中的示例代码。
示例 服务接口示例 CallbackService.java
package com.callback; public interface CallbackService { void addListener(String key, CallbackListener listener); } CallbackListener.java
package com.callback; public interface CallbackListener { void changed(String msg); } 服务提供者接口实现示例 package com.callback.impl; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Map; import java.util.concurrent.ConcurrentHashMap; import com.callback.CallbackListener; import com.callback.CallbackService; public class CallbackServiceImpl implements CallbackService { private final Map&amp;lt;String, CallbackListener&amp;gt; listeners = new ConcurrentHashMap&amp;lt;String, CallbackListener&amp;gt;(); public CallbackServiceImpl() { Thread t = new Thread(new Runnable() { public void run() { while(true) { try { for(Map.</description></item><item><title>服务鉴权</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/auth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/auth/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
服务鉴权 类似支付之类的对安全性敏感的业务可能会有限制匿名调用的需求。在加固安全性方面，2.7.5 引入了基于AK/SK机制的认证鉴权机制，并且引入了鉴权服务中心，主要原理是消费端在请求需要鉴权的服务时，会通过SK、请求元数据、时间戳、参数等信息来生成对应的请求签名，通过Dubbo的Attahcment机制携带到对端进行验签，验签通过才进行业务逻辑处理。如下图所示：
具体的接入方式也并不复杂：
使用者需要在微服务站点上填写自己的应用信息，并为该应用生成唯一的证书凭证。
之后在管理站点上提交工单，申请某个敏感业务服务的使用权限，并由对应业务管理者进行审批，审批通过之后，会生成对应的AK/SK到鉴权服务中心。
导入该证书到对应的应用下，并且进行配置。配置方式也十分简单，以注解方式为例：
服务提供端，只需要设置service.auth为true，表示该服务的调用需要鉴权认证通过。param.sign为true表示需要对参数也进行校验。
@Service(parameters = {&amp;#34;service.auth&amp;#34;,&amp;#34;true&amp;#34;,&amp;#34;param.sign&amp;#34;,&amp;#34;true&amp;#34;}) public class AuthDemoServiceImpl implements AuthService { } 服务消费端，只需要配置好对应的证书等信息即可，之后会自动地在对这些需要认证的接口发起调用前进行签名操作，通过与鉴权服务的交互，用户无需在代码中配置AK/SK这些敏感信息，并且在不重启应用的情况下刷新AK/SK，达到权限动态下发的目的。
该方案目前已经提交给Dubbo开源社区，并且完成了基本框架的合并，除了AK/SK的鉴权方式之外，通过SPI机制支持用户可定制化的鉴权认证以及适配公司内部基础设施的密钥存储。</description></item><item><title>0-24 - 覆盖字段值异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/24/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/24/</guid><description>可能的原因 实体类未设置 setter/getter 方法。 可能存在嵌套的属性。 排查和解决步骤 检查实体类并设置 setter/getter 方法。 根据堆栈信息，检查是否使用嵌套注解。</description></item><item><title>5-24 - 异步等待引用服务发生异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/24/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/24/</guid><description>可能的原因 注册中心异常停止或无法对外提供正常服务。
排查和解决步骤 检查注册中心的是否可正常连接，并检查当前客户端版本是否与服务端兼容匹配。</description></item><item><title>缓存扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/cache/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 用请求参数作为 key，缓存返回结果。
扩展接口 org.apache.dubbo.cache.CacheFactory
扩展配置 &amp;lt;dubbo:service cache=&amp;#34;lru&amp;#34; /&amp;gt; &amp;lt;!-- 方法级缓存 --&amp;gt; &amp;lt;dubbo:service&amp;gt;&amp;lt;dubbo:method cache=&amp;#34;lru&amp;#34; /&amp;gt;&amp;lt;/dubbo:service&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:service&amp;gt;没有配置cache属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider cache=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.cache.support.lru.LruCacheFactory org.apache.dubbo.cache.support.threadlocal.ThreadLocalCacheFactory org.apache.dubbo.cache.support.jcache.JCacheFactory 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxCacheFactory.java (实现CacheFactory接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.cache.CacheFactory (纯文本文件，内容为：xxx=com.xxx.XxxCacheFactory) XxxCacheFactory.java：
package com.xxx; import org.apache.dubbo.cache.CacheFactory; public class XxxCacheFactory implements CacheFactory { public Cache getCache(URL url, String name) { return new XxxCache(url, name); } } XxxCache.java：
package com.xxx; import org.</description></item><item><title>缓存扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/cache/</guid><description>扩展说明 用请求参数作为 key，缓存返回结果。
扩展接口 org.apache.dubbo.cache.CacheFactory
扩展配置 &amp;lt;dubbo:service cache=&amp;#34;lru&amp;#34; /&amp;gt; &amp;lt;!-- 方法级缓存 --&amp;gt; &amp;lt;dubbo:service&amp;gt;&amp;lt;dubbo:method cache=&amp;#34;lru&amp;#34; /&amp;gt;&amp;lt;/dubbo:service&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:service&amp;gt;没有配置cache属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider cache=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.cache.support.lru.LruCacheFactory org.apache.dubbo.cache.support.threadlocal.ThreadLocalCacheFactory org.apache.dubbo.cache.support.jcache.JCacheFactory 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxCacheFactory.java (实现CacheFactory接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.cache.CacheFactory (纯文本文件，内容为：xxx=com.xxx.XxxCacheFactory) XxxCacheFactory.java：
package com.xxx; import org.apache.dubbo.cache.CacheFactory; public class XxxCacheFactory implements CacheFactory { public Cache getCache(URL url, String name) { return new XxxCache(url, name); } } XxxCache.java：
package com.xxx; import org.apache.dubbo.cache.Cache; public class XxxCache implements Cache { public Cache(URL url, String name) { // .</description></item><item><title>缓存扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/cache/</guid><description>扩展说明 用请求参数作为 key，缓存返回结果。
扩展接口 org.apache.dubbo.cache.CacheFactory
扩展配置 &amp;lt;dubbo:service cache=&amp;#34;lru&amp;#34; /&amp;gt; &amp;lt;!-- 方法级缓存 --&amp;gt; &amp;lt;dubbo:service&amp;gt;&amp;lt;dubbo:method cache=&amp;#34;lru&amp;#34; /&amp;gt;&amp;lt;/dubbo:service&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:service&amp;gt;没有配置cache属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider cache=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.cache.support.lru.LruCacheFactory org.apache.dubbo.cache.support.threadlocal.ThreadLocalCacheFactory org.apache.dubbo.cache.support.jcache.JCacheFactory 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxCacheFactory.java (实现CacheFactory接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.cache.CacheFactory (纯文本文件，内容为：xxx=com.xxx.XxxCacheFactory) XxxCacheFactory.java：
package com.xxx; import org.apache.dubbo.cache.CacheFactory; public class XxxCacheFactory implements CacheFactory { public Cache getCache(URL url, String name) { return new XxxCache(url, name); } } XxxCache.java：
package com.xxx; import org.apache.dubbo.cache.Cache; public class XxxCache implements Cache { public Cache(URL url, String name) { // .</description></item><item><title>事件通知</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/events-notify/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/events-notify/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
在调用之前、调用之后、出现异常时，会触发 oninvoke、onreturn、onthrow 三个事件，可以配置当事件发生时，通知哪个类的哪个方法。
提示 支持版本：2.0.7 之后 服务提供者与消费者共享服务接口 interface IDemoService { public Person get(int id); } 服务提供者实现 class NormalDemoService implements IDemoService { public Person get(int id) { return new Person(id, &amp;#34;charles`son&amp;#34;, 4); } } 服务提供者配置 &amp;lt;dubbo:application name=&amp;#34;rpc-callback-demo&amp;#34; /&amp;gt; &amp;lt;dubbo:registry address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;demoService&amp;#34; class=&amp;#34;org.apache.dubbo.callback.implicit.NormalDemoService&amp;#34; /&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;org.apache.dubbo.callback.implicit.IDemoService&amp;#34; ref=&amp;#34;demoService&amp;#34; version=&amp;#34;1.0.0&amp;#34; group=&amp;#34;cn&amp;#34;/&amp;gt; 服务消费者 Callback 接口 interface Notify { public void onreturn(Person msg, Integer id); public void onthrow(Throwable ex, Integer id); } 服务消费者 Callback 实现 class NotifyImpl implements Notify { public Map&amp;lt;Integer, Person&amp;gt; ret = new HashMap&amp;lt;Integer, Person&amp;gt;(); public Map&amp;lt;Integer, Throwable&amp;gt; errors = new HashMap&amp;lt;Integer, Throwable&amp;gt;(); public void onreturn(Person msg, Integer id) { System.</description></item><item><title>事件通知</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/events-notify/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/events-notify/</guid><description>背景 在调用之前、调用之后、出现异常时，会触发 oninvoke、onreturn、onthrow 三个事件，可以配置当事件发生时，通知哪个类的哪个方法。
提示 支持版本：2.0.7 之后 示例 服务提供者与消费者共享服务接口 interface IDemoService { public Person get(int id); } 服务提供者实现 class NormalDemoService implements IDemoService { public Person get(int id) { return new Person(id, &amp;#34;charles`son&amp;#34;, 4); } } 服务提供者配置 &amp;lt;dubbo:application name=&amp;#34;rpc-callback-demo&amp;#34; /&amp;gt; &amp;lt;dubbo:registry address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;demoService&amp;#34; class=&amp;#34;org.apache.dubbo.callback.implicit.NormalDemoService&amp;#34; /&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;org.apache.dubbo.callback.implicit.IDemoService&amp;#34; ref=&amp;#34;demoService&amp;#34; version=&amp;#34;1.0.0&amp;#34; group=&amp;#34;cn&amp;#34;/&amp;gt; 服务消费者 Callback 接口 interface Notify { public void onreturn(Person msg, Integer id); public void onthrow(Throwable ex, Integer id); } 服务消费者 Callback 实现 class NotifyImpl implements Notify { public Map&amp;lt;Integer, Person&amp;gt; ret = new HashMap&amp;lt;Integer, Person&amp;gt;(); public Map&amp;lt;Integer, Throwable&amp;gt; errors = new HashMap&amp;lt;Integer, Throwable&amp;gt;(); public void onreturn(Person msg, Integer id) { System.</description></item><item><title>0-25 - 加载映射错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/25/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/25/</guid><description>可能的原因 文件访问权限不足
排查和解决步骤 检查文件权限。 可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>5-25 - 自定义实现发生未定义异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/25/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/25/</guid><description>可能的原因 自定义实现的 org.apache.dubbo.rpc.Protocol 协议，在方法调用 destory 时发生业务逻辑异常。
排查和解决步骤 检查自定义实现类代码的 destory 方法。</description></item><item><title>本地存根</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/local-stub/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/local-stub/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，比如：做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub 1，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。
在 spring 配置文件中按以下方式配置：
&amp;lt;dubbo:consumer interface=&amp;#34;com.foo.BarService&amp;#34; stub=&amp;#34;true&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:consumer interface=&amp;#34;com.foo.BarService&amp;#34; stub=&amp;#34;com.foo.BarServiceStub&amp;#34; /&amp;gt; 提供 Stub 的实现 2：
package com.foo; public class BarServiceStub implements BarService { private final BarService barService; // 构造函数传入真正的远程代理对象 public BarServiceStub(BarService barService){ this.barService = barService; } public String sayHello(String name) { // 此代码在客户端执行, 你可以在客户端做ThreadLocal本地缓存，或预先验证参数是否合法，等等 try { return barService.sayHello(name); } catch (Exception e) { // 你可以容错，可以做任何AOP拦截事项 return &amp;#34;容错数据&amp;#34;; } } } Stub 必须有可传入 Proxy 的构造函数。&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>本地存根</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/local-stub/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/local-stub/</guid><description>背景 远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，比如：做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub 1，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。
示例 在 spring 配置文件中按以下方式配置：
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; stub=&amp;#34;true&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; stub=&amp;#34;com.foo.BarServiceStub&amp;#34; /&amp;gt; 提供 Stub 的实现 2：
package com.foo; public class BarServiceStub implements BarService { private final BarService barService; // 构造函数传入真正的远程代理对象 public BarServiceStub(BarService barService){ this.barService = barService; } public String sayHello(String name) { // 此代码在客户端执行, 你可以在客户端做ThreadLocal本地缓存，或预先验证参数是否合法，等等 try { return barService.sayHello(name); } catch (Exception e) { // 你可以容错，可以做任何AOP拦截事项 return &amp;#34;容错数据&amp;#34;; } } } Stub 必须有可传入 Proxy 的构造函数。&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>验证扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/validation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/validation/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 参数验证扩展点。
扩展接口 org.apache.dubbo.validation.Validation
扩展配置 &amp;lt;dubbo:service validation=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:service&amp;gt;没有配置validation属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider validation=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.validation.support.jvalidation.JValidation
扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxValidation.java (实现Validation接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.validation.Validation (纯文本文件，内容为：xxx=com.xxx.XxxValidation) XxxValidation.java：
package com.xxx; import org.apache.dubbo.validation.Validation; public class XxxValidation implements Validation { public Object getValidator(URL url) { // ... } } XxxValidator.java：
package com.xxx; import org.apache.dubbo.validation.Validator; public class XxxValidator implements Validator { public XxxValidator(URL url) { // ... } public void validate(Invocation invocation) throws Exception { // .</description></item><item><title>验证扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/validation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/validation/</guid><description>扩展说明 参数验证扩展点。
扩展接口 org.apache.dubbo.validation.Validation
扩展配置 &amp;lt;dubbo:service validation=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:service&amp;gt;没有配置validation属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider validation=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.validation.support.jvalidation.JValidation
扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxValidation.java (实现Validation接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.validation.Validation (纯文本文件，内容为：xxx=com.xxx.XxxValidation) XxxValidation.java：
package com.xxx; import org.apache.dubbo.validation.Validation; public class XxxValidation implements Validation { public Object getValidator(URL url) { // ... } } XxxValidator.java：
package com.xxx; import org.apache.dubbo.validation.Validator; public class XxxValidator implements Validator { public XxxValidator(URL url) { // ... } public void validate(Invocation invocation) throws Exception { // .</description></item><item><title>验证扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/validation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/validation/</guid><description>扩展说明 参数验证扩展点。
扩展接口 org.apache.dubbo.validation.Validation
扩展配置 &amp;lt;dubbo:service validation=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:service&amp;gt;没有配置validation属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider validation=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.validation.support.jvalidation.JValidation
扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxValidation.java (实现Validation接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.validation.Validation (纯文本文件，内容为：xxx=com.xxx.XxxValidation) XxxValidation.java：
package com.xxx; import org.apache.dubbo.validation.Validation; public class XxxValidation implements Validation { public Object getValidator(URL url) { // ... } } XxxValidator.java：
package com.xxx; import org.apache.dubbo.validation.Validator; public class XxxValidator implements Validator { public XxxValidator(URL url) { // ... } public void validate(Invocation invocation) throws Exception { // .</description></item><item><title>0-26 - 元数据发布服务时的警告信息</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/26/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/26/</guid><description>可能的原因 元数据在存储接口与应用的映射关系时，显示的提醒类消息。
排查和解决步骤 一般可根据堆栈信息进行分析，也可不处理。</description></item><item><title>1-26 - xDS 证书生成失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/26/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/26/</guid><description>可能的原因 系统可能不支持算法 secp256r1 和 RSA 生成证书。
排查和解决步骤 检测操作系统是否支持 secp256r1 和 RSA 算法。需下载对于的 dll 文件或 lib</description></item><item><title>5-26 - 元数据已导出</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/26/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/26/</guid><description>可能的原因 元数据在当前 JVM 已被导出。
排查和解决步骤</description></item><item><title>本地伪装</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/local-mock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/local-mock/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
本地伪装 1 通常用于服务降级，比如某验权服务，当服务提供方全部挂掉后，客户端不抛出异常，而是通过 Mock 数据返回授权失败。
在 spring 配置文件中按以下方式配置：
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; mock=&amp;#34;true&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; mock=&amp;#34;com.foo.BarServiceMock&amp;#34; /&amp;gt; 在工程中提供 Mock 实现 2：
package com.foo; public class BarServiceMock implements BarService { public String sayHello(String name) { // 你可以伪造容错数据，此方法只在出现RpcException时被执行 return &amp;#34;容错数据&amp;#34;; } } 如果服务的消费方经常需要 try-catch 捕获异常，如：
Offer offer = null; try { offer = offerService.findOffer(offerId); } catch (RpcException e) { logger.error(e); } 请考虑改为 Mock 实现，并在 Mock 实现中 return null。如果只是想简单的忽略异常，在 2.0.11 以上版本可用：</description></item><item><title>本地伪装</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/local-mock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/local-mock/</guid><description>背景 本地伪装 1 通常用于服务降级，比如某验权服务，当服务提供方全部挂掉后，客户端不抛出异常，而是通过 Mock 数据返回授权失败。
示例 在 spring 配置文件中按以下方式配置：
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; mock=&amp;#34;true&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; mock=&amp;#34;com.foo.BarServiceMock&amp;#34; /&amp;gt; 在工程中提供 Mock 实现 2：
package com.foo; public class BarServiceMock implements BarService { public String sayHello(String name) { // 你可以伪造容错数据，此方法只在出现RpcException时被执行 return &amp;#34;容错数据&amp;#34;; } } 如果服务的消费方经常需要 try-catch 捕获异常，如：
Offer offer = null; try { offer = offerService.findOffer(offerId); } catch (RpcException e) { logger.error(e); } 请考虑改为 Mock 实现，并在 Mock 实现中 return null。如果只是想简单的忽略异常，在 2.0.11 以上版本可用：</description></item><item><title>日志适配扩展</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/logger-adapter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/logger-adapter/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
扩展说明 日志输出适配扩展点。
扩展接口 org.apache.dubbo.common.logger.LoggerAdapter
扩展配置 &amp;lt;dubbo:application logger=&amp;#34;xxx&amp;#34; /&amp;gt; 或者：
-Ddubbo:application.logger=xxx 已知扩展 org.apache.dubbo.common.logger.slf4j.Slf4jLoggerAdapter org.apache.dubbo.common.logger.jcl.JclLoggerAdapter org.apache.dubbo.common.logger.log4j.Log4jLoggerAdapter org.apache.dubbo.common.logger.log4j2.Log4j2LoggerAdapter org.apache.dubbo.common.logger.jdk.JdkLoggerAdapter 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxLoggerAdapter.java (实现LoggerAdapter接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.logger.LoggerAdapter (纯文本文件，内容为：xxx=com.xxx.XxxLoggerAdapter) XxxLoggerAdapter.java：
package com.xxx; import org.apache.dubbo.common.logger.LoggerAdapter; public class XxxLoggerAdapter implements LoggerAdapter { public Logger getLogger(URL url) { // ... } } XxxLogger.java：
package com.xxx; import org.apache.dubbo.common.logger.Logger; public class XxxLogger implements Logger { public XxxLogger(URL url) { // ... } public void info(String msg) { // .</description></item><item><title>日志适配扩展</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/logger-adapter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/logger-adapter/</guid><description>扩展说明 日志输出适配扩展点。
扩展接口 org.apache.dubbo.common.logger.LoggerAdapter
扩展配置 &amp;lt;dubbo:application logger=&amp;#34;xxx&amp;#34; /&amp;gt; 或者：
-Ddubbo:application.logger=xxx 已知扩展 org.apache.dubbo.common.logger.slf4j.Slf4jLoggerAdapter org.apache.dubbo.common.logger.jcl.JclLoggerAdapter org.apache.dubbo.common.logger.log4j.Log4jLoggerAdapter org.apache.dubbo.common.logger.log4j2.Log4j2LoggerAdapter org.apache.dubbo.common.logger.jdk.JdkLoggerAdapter 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxLoggerAdapter.java (实现LoggerAdapter接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.logger.LoggerAdapter (纯文本文件，内容为：xxx=com.xxx.XxxLoggerAdapter) XxxLoggerAdapter.java：
package com.xxx; import org.apache.dubbo.common.logger.LoggerAdapter; public class XxxLoggerAdapter implements LoggerAdapter { public Logger getLogger(URL url) { // ... } } XxxLogger.java：
package com.xxx; import org.apache.dubbo.common.logger.Logger; public class XxxLogger implements Logger { public XxxLogger(URL url) { // ... } public void info(String msg) { // .</description></item><item><title>日志适配扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/logger-adapter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/logger-adapter/</guid><description>扩展说明 日志输出适配扩展点。
扩展接口 org.apache.dubbo.common.logger.LoggerAdapter
扩展配置 &amp;lt;dubbo:application logger=&amp;#34;xxx&amp;#34; /&amp;gt; 或者：
-Ddubbo:application.logger=xxx 已知扩展 org.apache.dubbo.common.logger.slf4j.Slf4jLoggerAdapter org.apache.dubbo.common.logger.jcl.JclLoggerAdapter org.apache.dubbo.common.logger.log4j.Log4jLoggerAdapter org.apache.dubbo.common.logger.log4j2.Log4j2LoggerAdapter org.apache.dubbo.common.logger.jdk.JdkLoggerAdapter 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxLoggerAdapter.java (实现LoggerAdapter接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.logger.LoggerAdapter (纯文本文件，内容为：xxx=com.xxx.XxxLoggerAdapter) XxxLoggerAdapter.java：
package com.xxx; import org.apache.dubbo.common.logger.LoggerAdapter; public class XxxLoggerAdapter implements LoggerAdapter { public Logger getLogger(URL url) { // ... } } XxxLogger.java：
package com.xxx; import org.apache.dubbo.common.logger.Logger; public class XxxLogger implements Logger { public XxxLogger(URL url) { // ... } public void info(String msg) { // .</description></item><item><title>0-27 - 线程池隔离配置异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/27/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/27/</guid><description>可能的原因 未开启应用的线程池隔离能力，但是却在 ServiceConfig 中配置了隔离的线程池信息。
排查和解决步骤 配置开启应用的线程池隔离能力：dubbo.application.executor-management-mode=isolation</description></item><item><title>1-27 - K8S监听异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/27/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/27/</guid><description>可能的原因 系统可能不支持算法 secp256r1 和 RSA 生成证书。
排查和解决步骤 检测操作系统是否支持 secp256r1 和 RSA 算法。需下载对于的 dll 文件或 lib</description></item><item><title>5-27 - 内部类API被错误使用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/27/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/27/</guid><description>可能的原因 org.apache.dubbo.config.ReferenceConfig 和 org.apache.dubbo.common.config.ReferenceCache 或被定义为非单例模式。
排查和解决步骤 检查自定义注解或配置，将核心应用类定以了为非单例模式，检查 scope 配置。</description></item><item><title>QoS匿名访问权限验证扩展</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/qos-permission/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/spi/description/qos-permission/</guid><description>扩展说明 QoS匿名访问权限验证扩展点。
扩展接口 org.apache.dubbo.qos.permission.PermissionChecker
扩展配置 Dubbo QoS dubbo.application.qos-anonymous-access-permission-level 匿名访问权限校验。
默认实现 org.apache.dubbo.qos.permission.DefaultAnonymousAccessPermissionChecker
扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxPermissionChecker.java (实现PermissionChecker接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.qos.permission.PermissionChecker` (纯文本文件，内容为：qosPermissionChecker=com.xxx.XxxPermissionChecker) XxxPermissionChecker.java：
package com.xxx.qos.permission; import org.apache.dubbo.qos.permission.PermissionChecker; public class XxxAnonymousAccessPermissionChecker implements PermissionChecker { @Override public boolean access(CommandContext commandContext, PermissionLevel defaultCmdRequiredPermissionLevel) { // ... } } META-INF/dubbo/org.apache.dubbo.qos.permission.PermissionChecker：
qosPermissionChecker=com.xxx.XxxPermissionChecker</description></item><item><title>延迟暴露</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/delay-publish/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/delay-publish/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
如果你的服务需要预热时间，比如初始化缓存，等待相关资源就位等，可以使用 delay 进行延迟暴露。我们在 Dubbo 2.6.5 版本中对服务延迟暴露逻辑进行了细微的调整，将需要延迟暴露（delay &amp;gt; 0）服务的倒计时动作推迟到了 Spring 初始化完成后进行。你在使用 Dubbo 的过程中，并不会感知到此变化，因此请放心使用。
Dubbo 2.6.5 之前版本 延迟到 Spring 初始化完成后，再暴露服务1
&amp;lt;dubbo:service delay=&amp;#34;-1&amp;#34; /&amp;gt; 延迟 5 秒暴露服务
&amp;lt;dubbo:service delay=&amp;#34;5000&amp;#34; /&amp;gt; Dubbo 2.6.5 及以后版本 所有服务都将在 Spring 初始化完成后进行暴露，如果你不需要延迟暴露服务，无需配置 delay。
延迟 5 秒暴露服务
&amp;lt;dubbo:service delay=&amp;#34;5000&amp;#34; /&amp;gt; Spring 2.x 初始化死锁问题 触发条件 在 Spring 解析到 &amp;lt;dubbo:service /&amp;gt; 时，就已经向外暴露了服务，而 Spring 还在接着初始化其它 Bean。如果这时有请求进来，并且服务的实现类里有调用 applicationContext.getBean() 的用法。
请求线程的 applicationContext.getBean() 调用，先同步 singletonObjects 判断 Bean 是否存在，不存在就同步 beanDefinitionMap 进行初始化，并再次同步 singletonObjects 写入 Bean 实例缓存。</description></item><item><title>延迟暴露</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/delay-publish/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/delay-publish/</guid><description>背景 如果你的服务需要预热时间，比如初始化缓存，等待相关资源就位等，可以使用 delay 进行延迟暴露。我们在 Dubbo 2.6.5 版本中对服务延迟暴露逻辑进行了细微的调整，将需要延迟暴露（delay &amp;gt; 0）服务的倒计时动作推迟到了 Spring 初始化完成后进行。你在使用 Dubbo 的过程中，并不会感知到此变化，因此请放心使用。
示例 Dubbo 2.6.5 之前版本 延迟到 Spring 初始化完成后，再暴露服务1
&amp;lt;dubbo:service delay=&amp;#34;-1&amp;#34; /&amp;gt; 延迟 5 秒暴露服务
&amp;lt;dubbo:service delay=&amp;#34;5000&amp;#34; /&amp;gt; Dubbo 2.6.5 及以后版本 所有服务都将在 Spring 初始化完成后进行暴露，如果你不需要延迟暴露服务，无需配置 delay。
延迟 5 秒暴露服务
&amp;lt;dubbo:service delay=&amp;#34;5000&amp;#34; /&amp;gt; Spring 2.x 初始化死锁问题 触发条件 在 Spring 解析到 &amp;lt;dubbo:service /&amp;gt; 时，就已经向外暴露了服务，而 Spring 还在接着初始化其它 Bean。如果这时有请求进来，并且服务的实现类里有调用 applicationContext.getBean() 的用法。
请求线程的 applicationContext.getBean() 调用，先同步 singletonObjects 判断 Bean 是否存在，不存在就同步 beanDefinitionMap 进行初始化，并再次同步 singletonObjects 写入 Bean 实例缓存。</description></item><item><title>0-28 - 操作了可能会引起危险的行为</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/28/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/28/</guid><description>可能的原因 你执行了以下操作之一：
尝试或已经调整了 accesslog 的输出位置 排查和解决步骤 请检查应用配置中的 accesslog.fixed.path=true 开关是否处于开启状态，如未开启则可忽略；如果当前是开启状态，则请确认是否 acesslog 路径切换的行为是否为可信任的人所执行，以避免可能的安全风险。</description></item><item><title>1-28 - xDS 存根错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/28/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/28/</guid><description>可能的原因 当前 pod 或已宕机。
排查和解决步骤 可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>5-28 - 未发现可用注解</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/28/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/28/</guid><description>可能的原因 扫描包配置下未发现可靠注解。主要为 @DubboService 或 @Service
排查和解决步骤 检查当前使用的版本，2.7.7 之前将扫描 @Service 注解，之后为 @DubboService</description></item><item><title>并发控制</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/concurrency-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/concurrency-control/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
配置样例 样例 1 限制 com.foo.BarService 的每个方法，服务器端并发执行（或占用线程池线程数）不能超过 10 个：
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; executes=&amp;#34;10&amp;#34; /&amp;gt; 样例 2 限制 com.foo.BarService 的 sayHello 方法，服务器端并发执行（或占用线程池线程数）不能超过 10 个：
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;sayHello&amp;#34; executes=&amp;#34;10&amp;#34; /&amp;gt; &amp;lt;/dubbo:service&amp;gt; 样例 3 限制 com.foo.BarService 的每个方法，每客户端并发执行（或占用连接的请求数）不能超过 10 个：
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; actives=&amp;#34;10&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; actives=&amp;#34;10&amp;#34; /&amp;gt; 样例 4 限制 com.foo.BarService 的 sayHello 方法，每客户端并发执行（或占用连接的请求数）不能超过 10 个：
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;sayHello&amp;#34; actives=&amp;#34;10&amp;#34; /&amp;gt; &amp;lt;/dubbo:service&amp;gt; 或
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;sayHello&amp;#34; actives=&amp;#34;10&amp;#34; /&amp;gt; &amp;lt;/dubbo:service&amp;gt; 如果 &amp;lt;dubbo:service&amp;gt; 和 &amp;lt;dubbo:reference&amp;gt; 都配了actives，&amp;lt;dubbo:reference&amp;gt; 优先，参见：配置的覆盖策略。</description></item><item><title>并发控制</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/concurrency-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/concurrency-control/</guid><description>背景 多种并发控制功能，帮助用户管理其应用程序和服务。
示例 样例 1 限制 com.foo.BarService 的每个方法，服务器端并发执行（或占用线程池线程数）不能超过 10 个：
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; executes=&amp;#34;10&amp;#34; /&amp;gt; 样例 2 限制 com.foo.BarService 的 sayHello 方法，服务器端并发执行（或占用线程池线程数）不能超过 10 个：
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;sayHello&amp;#34; executes=&amp;#34;10&amp;#34; /&amp;gt; &amp;lt;/dubbo:service&amp;gt; 样例 3 限制 com.foo.BarService 的每个方法，每客户端并发执行（或占用连接的请求数）不能超过 10 个：
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; actives=&amp;#34;10&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; actives=&amp;#34;10&amp;#34; /&amp;gt; 样例 4 限制 com.foo.BarService 的 sayHello 方法，每客户端并发执行（或占用连接的请求数）不能超过 10 个：
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;sayHello&amp;#34; actives=&amp;#34;10&amp;#34; /&amp;gt; &amp;lt;/dubbo:service&amp;gt; 或
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;sayHello&amp;#34; actives=&amp;#34;10&amp;#34; /&amp;gt; &amp;lt;/dubbo:service&amp;gt; 如果 &amp;lt;dubbo:service&amp;gt; 和 &amp;lt;dubbo:reference&amp;gt; 都配了actives，&amp;lt;dubbo:reference&amp;gt; 优先，参见：配置的覆盖策略。</description></item><item><title>并发控制</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/concurrency-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/concurrency-control/</guid><description>功能说明 多种并发控制功能，帮助用户管理其应用程序和服务。
使用场景 限制从同一客户端到同一服务的并发请求数，防止恶意请求使服务器过载，确保服务的稳定性，并防止使用过多资源。
控制某些服务的最大并发请求数，确保其他服务的资源可用性。系统过载和确保系统稳定性。
允许在需求增加时更平滑地扩展服务。
确保服务在高峰使用时间保持可靠和稳定。
这种方式要求用户准确的预先评估系统能处理的并发数，而准确的评估系统处理能力并不是一件容易的事情，因此 Dubbo 还提供了自适应限流模式，根据系统负载自动识别系统健康程度并进行限流保护，可以在此 查看使用文档。
使用方式 样例一 限制 com.foo.BarService 的每个方法，服务器端并发执行（或占用线程池线程数）不能超过 10 个
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; executes=&amp;#34;10&amp;#34; /&amp;gt; 样例二 限制 com.foo.BarService 的 sayHello 方法，服务器端并发执行（或占用线程池线程数）不能超过 10 个
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;sayHello&amp;#34; executes=&amp;#34;10&amp;#34; /&amp;gt; &amp;lt;/dubbo:service&amp;gt; 样例三 限制 com.foo.BarService 的每个方法，每客户端并发执行（或占用连接的请求数）不能超过 10 个
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; actives=&amp;#34;10&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; actives=&amp;#34;10&amp;#34; /&amp;gt; 样例四 限制 com.foo.BarService 的 sayHello 方法，每客户端并发执行（或占用连接的请求数）不能超过 10 个
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;sayHello&amp;#34; actives=&amp;#34;10&amp;#34; /&amp;gt; &amp;lt;/dubbo:service&amp;gt; 或
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;sayHello&amp;#34; actives=&amp;#34;10&amp;#34; /&amp;gt; &amp;lt;/dubbo:service&amp;gt; 如果 &amp;lt;dubbo:service&amp;gt; 和 &amp;lt;dubbo:reference&amp;gt; 都配了actives，&amp;lt;dubbo:reference&amp;gt; 优先，参见：配置的覆盖策略。</description></item><item><title>0-29 - 未找到Tracer依赖</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/29/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/29/</guid><description>可能的原因 你已在配置文件中开启了tracing，但未找到Tracer依赖。
目前Tracer支持两种，OpenTelemetry和Brave。
排查和解决步骤 选择一个Tracer依赖到你的项目中：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.micrometer&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;micrometer-tracing-bridge-otel&amp;lt;/artifactId&amp;gt; &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.micrometer&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;micrometer-tracing-bridge-brave&amp;lt;/artifactId&amp;gt; &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt; &amp;lt;/dependency&amp;gt;</description></item><item><title>1-29 - xDS 读取文件失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/29/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/29/</guid><description>可能的原因 网络断开或目标文件此时已损坏。
排查和解决步骤 网络是否正常。 可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>5-29 - 扫描包未配置</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/29/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/29/</guid><description>可能的原因 @EnableDubbo.scanBasePackages 注解参数值未配置。
排查和解决步骤 @EnableDubbo.scanBasePackages 配置即可。</description></item><item><title>连接控制</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/config-connections/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/config-connections/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
服务端连接控制 限制服务器端接受的连接不能超过 10 个 1：
&amp;lt;dubbo:provider protocol=&amp;#34;dubbo&amp;#34; accepts=&amp;#34;10&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; accepts=&amp;#34;10&amp;#34; /&amp;gt; 客户端连接控制 限制客户端服务使用连接不能超过 10 个 2：
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; connections=&amp;#34;10&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; connections=&amp;#34;10&amp;#34; /&amp;gt; 如果 &amp;lt;dubbo:service&amp;gt; 和 &amp;lt;dubbo:reference&amp;gt; 都配了 connections，&amp;lt;dubbo:reference&amp;gt; 优先，参见：配置的覆盖策略
因为连接在 Server上，所以配置在 Provider 上&amp;#160;&amp;#x21a9;&amp;#xfe0e;
如果是长连接，比如 Dubbo 协议，connections 表示该服务对每个提供者建立的长连接数&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>连接控制</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/config-connections/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/config-connections/</guid><description>背景 连接控制功能可以使用户能够控制和管理进出服务器连接数，限制连接数并设置超时，以确保 Dubbo 系统的稳定性和性能，还允许用户根据 IP 地址、端口和协议配置不同级别的访问控制，保护系统免受恶意流量的影响，并降低服务中断的风险，此外提供了一种监视当前流量和连接状态的方法
示例 服务端连接控制 限制服务器端接受的连接不能超过 10 个 1：
&amp;lt;dubbo:provider protocol=&amp;#34;dubbo&amp;#34; accepts=&amp;#34;10&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; accepts=&amp;#34;10&amp;#34; /&amp;gt; 客户端连接控制 限制客户端服务使用连接不能超过 10 个 2：
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; connections=&amp;#34;10&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; connections=&amp;#34;10&amp;#34; /&amp;gt; 如果 &amp;lt;dubbo:service&amp;gt; 和 &amp;lt;dubbo:reference&amp;gt; 都配了 connections，&amp;lt;dubbo:reference&amp;gt; 优先，参见：配置的覆盖策略
因为连接在 Server上，所以配置在 Provider 上&amp;#160;&amp;#x21a9;&amp;#xfe0e;
如果是长连接，比如 Dubbo 协议，connections 表示该服务对每个提供者建立的长连接数&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>连接控制</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/config-connections/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/config-connections/</guid><description>功能说明 连接控制功能可以使用户能够控制和管理进出服务器连接数，限制连接数并设置超时，以确保 Dubbo 系统的稳定性和性能，还允许用户根据 IP 地址、端口和协议配置不同级别的访问控制，保护系统免受恶意流量的影响，并降低服务中断的风险，此外提供了一种监视当前流量和连接状态的方法。
使用场景 服务器过载时减少连接数：当服务器过载时，使用 Dubbo 通过设置最大连接限制来减少连接数减少服务器上的负载并防止其崩溃。 减少服务器受到攻击时的连接数：Dubbo 可以限制服务器受到攻击的连接数防止恶意连接充斥服务器并导致服务器崩溃。 限制特定服务的连接数：Dubbo 可以限制特定服务连接数防止服务过载过多的请求并确保及时响应所有请求。 限制来自单个IP地址的连接数：Dubbo 可以限制来自单个地址的连接数降低来自单个IP地址的恶意活动的风险。 使用方式 服务端连接控制 限制服务器端接受的连接不能超过 10 个 1：
&amp;lt;dubbo:provider protocol=&amp;#34;dubbo&amp;#34; accepts=&amp;#34;10&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; accepts=&amp;#34;10&amp;#34; /&amp;gt; 客户端连接控制 限制客户端服务使用连接不能超过 10 个 2：
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.BarService&amp;#34; connections=&amp;#34;10&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; connections=&amp;#34;10&amp;#34; /&amp;gt; 如果 &amp;lt;dubbo:service&amp;gt; 和 &amp;lt;dubbo:reference&amp;gt; 都配了 connections，&amp;lt;dubbo:reference&amp;gt; 优先，参见：配置的覆盖策略
功能说明 允许消费者在提供者接收请求之前向提供者发送请求，消费者等待提供者准备就绪，然后将发送消费者者的请求，当消费者需要连接到提供者，提供者尚未准备好接受请求时，确保在正确的时间发送请求，防止消费者被速度慢或不可用的提供程序阻止。
使用场景 粘滞连接用于有状态服务，尽可能让客户端总是向同一提供者发起调用，除非该提供者挂了，再连另一台。
粘滞连接将自动开启 延迟连接，以减少长连接数。
使用方式 &amp;lt;dubbo:reference id=&amp;#34;xxxService&amp;#34; interface=&amp;#34;com.xxx.XxxService&amp;#34; sticky=&amp;#34;true&amp;#34; /&amp;gt; Dubbo 支持方法级别的粘滞连接，如果你想进行更细粒度的控制，还可以这样配置。
&amp;lt;dubbo:reference id=&amp;#34;xxxService&amp;#34; interface=&amp;#34;com.xxx.XxxService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;sayHello&amp;#34; sticky=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; 功能说明 当消费者请求服务时，实际使用服务时才建立真正的连接，避免不必要的连接来减少延迟并提高系统稳定性。</description></item><item><title>Dubbo Java 3.2.0-beta.3 正式发布</title><link>https://dubbo.apache.org/zh-cn/blog/2022/12/18/dubbo-java-3.2.0-beta.3-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</link><pubDate>Sun, 18 Dec 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/12/18/dubbo-java-3.2.0-beta.3-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</guid><description>Dubbo 3.2.0-beta.3 版本是目前 Dubbo 3 的最新特性版本，包括了如 Spring Boot 3、JDK 17、服务粒度的线程池隔离等新特性的支持，欢迎大家尝鲜使用。
Dubbo 3.2.0-beta.3 注：Dubbo 3.2.0-beta.3 的代码基础和 Dubbo 3.1.4 完全一致，因此在 Dubbo 3.1.4 中包括的所有修改内容，在 Dubbo 3.2.0-beta.3 中也同样存在，后续说明中对于重复的内容讲不再赘述。
新特性 支持使用 jackson 作为Dubbo 内部的 JSON 序列化方式 优化 Dubbo Logger 的选择逻辑，在存在多种日志框架的情况下会尝试读取其配置，选择一个有效的日志框架，解决在 SpringBoot 等场景下 Dubbo 日志不输出的问题。 Triple 协议支持客户端流控 支持发布 Dubbo Metrics 数据到 Spring Boot 的 Endpoints 上 支持可选关闭线程池满时的线程 Dump 以及支持配置 Dump 的结果输出路径 xDS 实现支持路由规则的解析 支持 Dubbo QoS 命令安全性分级，默认对外暴露存活检测的端口，支持 Kubernetes 的原生接入 支持基于 P2C 的自适应负载均衡 Bugfix 修复默认 Metadata 缓存未开启的问题 修复 Metrics 指标资源路径错误的问题 完善线程池隔离的配置，默认采用共享线程池，避免创建过多的线程 完善 prefer-serialization 的选择逻辑，提供向前兼容的能力 修复 Triple 协议传输时未携带版本号导致版本调用错误的问题 完善 GraalVM Native Image 的支持 性能优化 优化在连接数高时由于获取 channels 数量导致的资源占用问题 代码优化 本次发布中有 5 个提交涉及代码质量的优化。</description></item><item><title>1-30 - xDS 请求失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/30/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/30/</guid><description>可能的原因 版本可能不一致或不兼容。 读取数据时超时。 参数配置有问题。 排查和解决步骤 可根据第三方官网介绍进行适配。 确认是否是超时时间设置过短或服务端存在问题。 检测端口的映射关系是否正确。</description></item><item><title>5-30 - 声明bean定义重复</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/30/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/30/</guid><description>可能的原因 声明的对象 id 或名称重复。
排查和解决步骤 根据控制台输出的全限定类名称,名称修改唯一即可。</description></item><item><title>Ab测试</title><link>https://dubbo.apache.org/zh-cn/docs/examples/routing/ab-testing-deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/examples/routing/ab-testing-deployment/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
场景描述 描述当前IDC、服务部署、服务信息、希望实现的效果等相关情况
操作工艺 步骤1
路由配置 验证方案 步骤2
路由配置 验证方案</description></item><item><title>Dubbo NetWorkFilter 介绍</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/networkfilter/dubbo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/networkfilter/dubbo/</guid><description>欢迎认领补充此文档。</description></item><item><title>Https 案例介绍</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/samples/https/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/samples/https/</guid><description>欢迎认领补充此文档。</description></item><item><title>Rust</title><link>https://dubbo.apache.org/zh-cn/download/rust/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/download/rust/</guid><description/></item><item><title>TCP Listener 介绍</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/listener/tcp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/listener/tcp/</guid><description>欢迎认领补充此文档。</description></item><item><title>VirtualService</title><link>https://dubbo.apache.org/zh-cn/docs/references/routers/virtualservice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/routers/virtualservice/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
VirtualService VirtualService是用来处理入站流量的规则，也就是说用来描述哪些入站流量适用于该路由规则。
使用示例 apiVersion: service.dubbo.apache.org/v1alpha1 kind: VirtualService metadata: name: demo/StandardRouter spec: hosts: dubbo: 属性说明 Field Type Description Required name string 应以 应用名/Router类型的方式来命名。name属性一经定义Router类型就确定下来了 YES hosts string[] 一般指应用名 NO dubbo DubboRoute[] dubbo 路由规则，顺序执行，符合条件立即返回 NO Router类型如下： name Description StandardRouter 完全使用标准 VirtualService 描述的 Router 待补充 待补充 DubboRoute DubboRoute是VirtualService中的属性，用来描述路由策略的边界。
使用示例 apiVersion: service.dubbo.apache.org/v1alpha1 kind: VirtualService metadata: name: demo/StandardRouter spec: hosts: dubbo: #DubboRoute - name: service: fault: mirror: retries: timeout: routedetail: 属性说明 Field Type Description Required name string 规则的名字，方便识别规则用意 NO services StringMatch[] 规则生效的服务名列表，可使用具体的服务名，也可以使用正则 * 的方式进行匹配；默认不配置，则代表所有的服务都生效 fault dubboFaultInject[] 故障注入(未实现) NO mirror Destination 镜像流量(未实现) NO retries DubboRetry[] 重试相关(未实现) NO timeout DubboTimeout[] 超时相关(未实现) NO routedetail DubboRouteDetail[] 具体的流量规则，顺序执行，符合条件立即返回 YES DubboRouteDetail DubboRouteDetail用来描述详细的路由规则</description></item><item><title>XML 配置</title><link>https://dubbo.apache.org/zh-cn/docs/references/configuration/xml/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/configuration/xml/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
有关 XML 的详细配置项，请参见：XML配置参考手册。如果不想使用 Spring 配置，而希望通过 API 的方式进行调用，请参见：API配置。想知道如何使用配置，请参见：快速启动。
请在此查看文档描述的完整示例
provider.xml 示例 &amp;lt;beans xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;dubbo:application name=&amp;#34;demo-provider&amp;#34;/&amp;gt; &amp;lt;dubbo:registry address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;20890&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;demoService&amp;#34; class=&amp;#34;org.apache.dubbo.samples.basic.impl.DemoServiceImpl&amp;#34;/&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;org.apache.dubbo.samples.basic.api.DemoService&amp;#34; ref=&amp;#34;demoService&amp;#34;/&amp;gt; &amp;lt;/beans&amp;gt; consumer.xml示例 &amp;lt;beans xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;dubbo:application name=&amp;#34;demo-consumer&amp;#34;/&amp;gt; &amp;lt;dubbo:registry group=&amp;#34;aaa&amp;#34; address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; &amp;lt;dubbo:reference id=&amp;#34;demoService&amp;#34; check=&amp;#34;false&amp;#34; interface=&amp;#34;org.apache.dubbo.samples.basic.api.DemoService&amp;#34;/&amp;gt; &amp;lt;/beans&amp;gt; 所有标签都支持自定义参数，用于不同扩展点实现的特殊配置，如：
&amp;lt;dubbo:protocol name=&amp;#34;jms&amp;#34;&amp;gt; &amp;lt;dubbo:parameter key=&amp;#34;queue&amp;#34; value=&amp;#34;your_queue&amp;#34; /&amp;gt; &amp;lt;/dubbo:protocol&amp;gt; 或： 1
&amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xmlns:p=&amp;#34;http://www.springframework.org/schema/p&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.</description></item><item><title>部署操作</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/deployment/</guid><description>一、Docker镜像部署 注：首先确认本机已经安装好docker并且启动
1、从docker hub 拉取 pixiu 镜像 docker pull phial3/dubbo-go-pixiu:latest
2、按照需求准备pixiu配置 pixiu配置参数详解 准备 log.yml 和 conf.yaml 配置文件，将这两个配置文件在pixiu启动的时候挂在到本地
3、启动 pixiu 前台启动：，可方便查看服务信息运行是否正常
docker run --name dubbo-go-pixiu -p 8883:8883 \ -v /yourpath/conf.yaml:/etc/pixiu/conf.yaml \ -v /yourpath/log.yml:/etc/pixiu/log.yml \ apache/dubbo-go-pixiu:latest 后台启动：
docker run -itd --name dubbo-go-pixiu -p 8883:8883 \ -v /yourpath/conf.yaml:/etc/pixiu/conf.yaml \ -v /yourpath/log.yml:/etc/pixiu/log.yml \ apache/dubbo-go-pixiu:latest 注：
(1) --name命令后面的dubbo-go-pixiu为你的pixiu实例的名称，可自行修改
(2)命令中的/yourpath/**路径为你本地存放pixiu配置文件的绝对路径
4、查看 pixiu 实例 docker ps | grep dubbo-go-pixiu 正在运行的pixiu实例
docker exec -it dubbo-go-pixiu /bin/bash 进入pixiu
5、停止pixiu docker stop dubbo-go-pixiu 停止pixiu</description></item><item><title>断路器介绍</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/httpfilter/hystrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/httpfilter/hystrix/</guid><description>欢迎认领补充此文档。</description></item><item><title>应用级服务发现</title><link>https://dubbo.apache.org/zh-cn/docs/examples/service-discovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/examples/service-discovery/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
应用级服务发现简介 社区版本 Dubbo 从 2.7.5 版本开始，新引入了一种基于应用粒度的服务发现机制，这是我们为 Dubbo 适配云原生基础设施的一步重要探索，也是 Dubbo 迈出的重要一步。 简单来说，以前 Dubbo 是将接口的信息全部注册到注册中心，而一个应用实例一般会存在多个接口，这样一来注册的数据量就要大很多，而且有冗余。 全新的应用级服务发现机制是同一个应用实例仅在注册中心注册一条数据，注册中心的数据只与实例数量相关，大大降低了注册中心数据的存储与推送压力。
应用级服务发现的优势 从适配云原生以及可扩展性来看，Dubbo3 引入的应用级服务发现主要有以下优势
适配云原生微服务变革。云原生时代的基础设施能力不断向上释放，像 Kubernetes 等平台都集成了微服务概念抽象，Dubbo3 的应用级服务发现是适配各种微服务体系的通用模型。 提升性能与可伸缩性。支持超大规模集群的服务治理一直以来都是 Dubbo 的优势，通过引入应用级服务发现模型，从本质上解决了注册中心地址数据的存储与推送压力，相应的 Consumer 侧的地址计算压力也成数量级下降；集群规模也开始变得可预测、可评估（与 RPC 接口数量无关，只与实例部署规模相关）。 这样设计的全新的服务发现模型，在架构兼容性、可伸缩性上都给 Dubbo3 带来了更大的优势。
在架构兼容性上，Dubbo3 复用下层基础设施的服务抽象能力成为了可能；另一方面，如 Spring Cloud 等业界其它微服务解决方案也沿用这种模型， 在打通了地址发现之后，使得用户探索用 Dubbo 连接异构的微服务体系成为了一种可能。
接口粒度 VS 应用粒度 简单来说，以前 Dubbo2 是将接口的信息全部注册到注册中心，而一个应用实例一般会存在多个接口，这样一来注册的数据量就要大很多，而且有冗余。 应用级服务发现的机制是同一个应用实例仅在注册中心注册一条数据，对于注册中心、订阅方的存储压力都是一个极大的释放。 更重要的是，地址发现容量彻底与业务 RPC 定义解耦开来，整个集群的容量评估对运维来说将变得更加透明：部署多少台机器就会有多大负载， 不会像 Dubbo2 一样， 因为业务 RPC 重构就会影响到整个集群服务发现的稳定性。
假设应用 dubbo-application 部署了 3 个实例（instance1, instance2, instance3），并且对外提供了 3 个接口（sayHello, echo, getVersion）分别设置了不同的超时时间。 分别在 Dubbo2 和 Dubbo3 的服务发现机制下，注册到注册中心的数据是截然不同的。</description></item><item><title>延迟连接</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/lazy-connect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/lazy-connect/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
延迟连接用于减少长连接数。当有调用发起时，再创建长连接。
&amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; lazy=&amp;#34;true&amp;#34; /&amp;gt; 提示 该配置只对使用长连接的 dubbo 协议生效。</description></item><item><title>延迟连接</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/lazy-connect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/lazy-connect/</guid><description>背景 延迟连接用于减少长连接数。当有调用发起时，再创建长连接。
示例 &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; lazy=&amp;#34;true&amp;#34; /&amp;gt; 提示 该配置只对使用长连接的 dubbo 协议生效。</description></item><item><title>1-31 - xDS 响应失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/31/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/31/</guid><description>可能的原因 客户端服务已断开与服务端的连接。 服务端不可用或已脱机。 排查和解决步骤 排查服务端是否已脱机或客户端的网络断开。 排查服务端服务是否正常，并可通过网络进行接口请求。</description></item><item><title>5-31 - 状态检查错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/31/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/31/</guid><description>可能的原因 当前运行的服务器状态，系统 CPU 使用率过高或内存等指标太低
排查和解决步骤 检查当前服务器的内存使用状态，及 CPU 使用率等其他指标，可能存在宕机的危险。</description></item><item><title>粘滞连接</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/stickiness/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/stickiness/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
粘滞连接用于有状态服务，尽可能让客户端总是向同一提供者发起调用，除非该提供者挂了，再连另一台。
粘滞连接将自动开启延迟连接，以减少长连接数。
&amp;lt;dubbo:reference id=&amp;#34;xxxService&amp;#34; interface=&amp;#34;com.xxx.XxxService&amp;#34; sticky=&amp;#34;true&amp;#34; /&amp;gt; Dubbo 支持方法级别的粘滞连接，如果你想进行更细粒度的控制，还可以这样配置。
&amp;lt;dubbo:reference id=&amp;#34;xxxService&amp;#34; interface=&amp;#34;com.xxx.XxxService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;sayHello&amp;#34; sticky=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt;</description></item><item><title>粘滞连接</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/stickiness/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/stickiness/</guid><description>背景 粘滞连接用于有状态服务，尽可能让客户端总是向同一提供者发起调用，除非该提供者挂了，再连另一台。
粘滞连接将自动开启延迟连接，以减少长连接数。
示例 &amp;lt;dubbo:reference id=&amp;#34;xxxService&amp;#34; interface=&amp;#34;com.xxx.XxxService&amp;#34; sticky=&amp;#34;true&amp;#34; /&amp;gt; Dubbo 支持方法级别的粘滞连接，如果你想进行更细粒度的控制，还可以这样配置。
&amp;lt;dubbo:reference id=&amp;#34;xxxService&amp;#34; interface=&amp;#34;com.xxx.XxxService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;sayHello&amp;#34; sticky=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt;</description></item><item><title>1-32 - xDS Channel 初始化失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/32/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/32/</guid><description>可能的原因 版本可能不一致或不兼容。 读取数据时超时。 参数配置有问题。 排查和解决步骤 可根据第三方官网介绍进行适配。 确认是否是超时时间设置过短或服务端存在问题。 检测端口的映射关系是否正确。</description></item><item><title>5-32 - Apollo 断开连接时发生错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/32/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/32/</guid><description>可能的原因 Apollo 配置中心可能已关闭或者网络已断开。
排查和解决步骤 检查 Apollo 服务端服务状态，及网络间是否可正常通信。</description></item><item><title>TLS</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/tls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/tls/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
2.7.5 版本在传输链路的安全性上做了很多工作，对于内置的 Dubbo Netty Server 和新引入的 gRPC 协议都提供了基于 TLS 的安全链路传输机制。
TLS 的配置都有统一的入口，如下所示：
Provider 端 SslConfig sslConfig = new SslConfig(); sslConfig.setServerKeyCertChainPath(&amp;#34;path to cert&amp;#34;); sslConfig.setServerPrivateKeyPath(args[1]); // 如果开启双向 cert 认证 if (mutualTls) { sslConfig.setServerTrustCertCollectionPath(args[2]); } ProtocolConfig protocolConfig = new ProtocolConfig(&amp;#34;dubbo/grpc&amp;#34;); protocolConfig.setSslEnabled(true); Consumer 端 if (!mutualTls) {} sslConfig.setClientTrustCertCollectionPath(args[0]); } else { sslConfig.setClientTrustCertCollectionPath(args[0]); sslConfig.setClientKeyCertChainPath(args[1]); sslConfig.setClientPrivateKeyPath(args[2]); } 为尽可能保证应用启动的灵活性，TLS Cert 的指定还能通过 -D 参数或环境变量等方式来在启动阶段根据部署环境动态指定，具体请参见 Dubbo 配置读取规则与 TLS 示例
提示 参考 Dubbo 配置读取规则，TLS 示例
如果要使用的是 gRPC 协议，在开启 TLS 时会使用到协议协商机制，因此必须使用支持 ALPN 机制的 Provider，推荐使用的是 netty-tcnative，具体可参见 gRPC Java 社区的总结</description></item><item><title>TLS</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/tls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/tls/</guid><description>背景 2.7.5 版本在传输链路的安全性上做了很多工作，对于内置的 Dubbo Netty Server 和新引入的 gRPC 协议都提供了基于 TLS 的安全链路传输机制。
TLS 的配置都有统一的入口，如下所示：
示例 Provider 端 SslConfig sslConfig = new SslConfig(); sslConfig.setServerKeyCertChainPath(&amp;#34;path to cert&amp;#34;); sslConfig.setServerPrivateKeyPath(args[1]); // 如果开启双向 cert 认证 if (mutualTls) { sslConfig.setServerTrustCertCollectionPath(args[2]); } ProtocolConfig protocolConfig = new ProtocolConfig(&amp;#34;dubbo/grpc&amp;#34;); protocolConfig.setSslEnabled(true); Consumer 端 if (!mutualTls) {} sslConfig.setClientTrustCertCollectionPath(args[0]); } else { sslConfig.setClientTrustCertCollectionPath(args[0]); sslConfig.setClientKeyCertChainPath(args[1]); sslConfig.setClientPrivateKeyPath(args[2]); } 为尽可能保证应用启动的灵活性，TLS Cert 的指定还能通过 -D 参数或环境变量等方式来在启动阶段根据部署环境动态指定，具体请参见 Dubbo 配置读取规则与 TLS 示例
提示 参考 Dubbo 配置读取规则，TLS 示例
如果要使用的是 gRPC 协议，在开启 TLS 时会使用到协议协商机制，因此必须使用支持 ALPN 机制的 Provider，推荐使用的是 netty-tcnative，具体可参见 gRPC Java 社区的总结</description></item><item><title>令牌验证</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/token-authorization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/token-authorization/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
通过令牌验证在注册中心控制权限，以决定要不要下发令牌给消费者，可以防止消费者绕过注册中心访问提供者，另外通过注册中心可灵活改变授权方式，而不需修改或升级提供者
可以全局设置开启令牌验证：
&amp;lt;!--随机token令牌，使用UUID生成--&amp;gt; &amp;lt;dubbo:provider token=&amp;#34;true&amp;#34; /&amp;gt; 或
&amp;lt;!--固定token令牌，相当于密码--&amp;gt; &amp;lt;dubbo:provider token=&amp;#34;123456&amp;#34; /&amp;gt; 也可在服务级别设置：
&amp;lt;!--随机token令牌，使用UUID生成--&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; token=&amp;#34;true&amp;#34; /&amp;gt; 或
&amp;lt;!--固定token令牌，相当于密码--&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; token=&amp;#34;123456&amp;#34; /&amp;gt;</description></item><item><title>令牌验证</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/token-authorization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/token-authorization/</guid><description>背景 通过令牌验证在注册中心控制权限，以决定要不要下发令牌给消费者，可以防止消费者绕过注册中心访问提供者，另外通过注册中心可灵活改变授权方式，而不需修改或升级提供者
示例 可以全局设置开启令牌验证：
&amp;lt;!--随机token令牌，使用UUID生成--&amp;gt; &amp;lt;dubbo:provider token=&amp;#34;true&amp;#34; /&amp;gt; 或
&amp;lt;!--固定token令牌，相当于密码--&amp;gt; &amp;lt;dubbo:provider token=&amp;#34;123456&amp;#34; /&amp;gt; 也可在服务级别设置：
&amp;lt;!--随机token令牌，使用UUID生成--&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; token=&amp;#34;true&amp;#34; /&amp;gt; 或
&amp;lt;!--固定token令牌，相当于密码--&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;com.foo.BarService&amp;#34; token=&amp;#34;123456&amp;#34; /&amp;gt;</description></item><item><title>1-33 - xDS 服务发现初始化失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/33/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/33/</guid><description>可能的原因 xDS 模式下的注册中心，地址配置错误。 防火墙及第三方防护软件，导致无法对外提供连接。 排查和解决步骤 检查 xDS 配置是否正确，检查 Istio 状态是否正常。 检查防火墙配置或使用 cmd 的 ping 命令进行基本检测。</description></item><item><title>5-33 - Apollo 配置更新事件发生异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/33/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/33/</guid><description>可能的原因 Apollo 配置 API 使用错误。
排查和解决步骤 请参考动态配置中心使用文档中关于 Apollo 部分的描述。</description></item><item><title>路由规则</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/routing-rule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/routing-rule/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
路由规则在发起一次RPC调用前起到过滤目标服务器地址的作用，过滤后的地址列表，将作为消费端最终发起RPC调用的备选地址。
条件路由。支持以服务或 Consumer 应用为粒度配置路由规则。 标签路由。以 Provider 应用为粒度配置路由规则。 后续我们计划在 2.6.x 版本的基础上继续增强脚本路由功能。
条件路由 您可以随时在服务治理控制台 Dubbo-Admin 写入路由规则
简介 应用粒度
# app1的消费者只能消费所有端口为20880的服务实例 # app2的消费者只能消费所有端口为20881的服务实例 --- scope: application force: true runtime: true enabled: true key: governance-conditionrouter-consumer conditions: - application=app1 =&amp;gt; address=*:20880 - application=app2 =&amp;gt; address=*:20881 ... 服务粒度
# DemoService的sayHello方法只能消费所有端口为20880的服务实例 # DemoService的sayHi方法只能消费所有端口为20881的服务实例 --- scope: service force: true runtime: true enabled: true key: org.apache.dubbo.samples.governance.api.DemoService conditions: - method=sayHello =&amp;gt; address=*:20880 - method=sayHi =&amp;gt; address=*:20881 ... 规则详解 各字段含义 scope表示路由规则的作用粒度，scope的取值会决定key的取值。必填。 service 服务粒度 application 应用粒度 Key明确规则体作用在哪个服务或应用。必填。 scope=service时，key取值为[{group}:]{service}[:{version}]的组合 scope=application时，key取值为application名称 enabled=true 当前路由规则是否生效，可不填，缺省生效。 force=false 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为 false。 runtime=false 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。如果用了参数路由，必须设为 true，需要注意设置会影响调用的性能，可不填，缺省为 false。 priority=1 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为 0。 conditions 定义具体的路由规则内容。必填。 Conditions规则体 `conditions`部分是规则的主体，由1到任意多条规则组成，下面我们就每个规则的配置语法做详细说明： 格式 =&amp;gt; 之前的为消费者匹配条件，所有参数和消费者的 URL 进行对比，当消费者满足匹配条件时，对该消费者执行后面的过滤规则。 =&amp;gt; 之后为提供者地址列表的过滤条件，所有参数和提供者的 URL 进行对比，消费者最终只拿到过滤后的地址列表。 如果匹配条件为空，表示对所有消费方应用，如：=&amp;gt; host !</description></item><item><title>路由规则</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/routing-rule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/routing-rule/</guid><description>背景 路由规则在发起一次RPC调用前起到过滤目标服务器地址的作用，过滤后的地址列表，将作为消费端最终发起RPC调用的备选地址。
条件路由。支持以服务或 Consumer 应用为粒度配置路由规则。 标签路由。以 Provider 应用为粒度配置路由规则。 后续我们计划在 2.6.x 版本的基础上继续增强脚本路由功能。
示例 条件路由 您可以随时在服务治理控制台 Dubbo-Admin 写入路由规则
简介 应用粒度
# app1的消费者只能消费所有端口为20880的服务实例 # app2的消费者只能消费所有端口为20881的服务实例 --- scope: application force: true runtime: true enabled: true key: governance-conditionrouter-consumer conditions: - application=app1 =&amp;gt; address=*:20880 - application=app2 =&amp;gt; address=*:20881 ... 服务粒度
# DemoService的sayHello方法只能消费所有端口为20880的服务实例 # DemoService的sayHi方法只能消费所有端口为20881的服务实例 --- scope: service force: true runtime: true enabled: true key: org.apache.dubbo.samples.governance.api.DemoService conditions: - method=sayHello =&amp;gt; address=*:20880 - method=sayHi =&amp;gt; address=*:20881 ... 规则详解 各字段含义 scope表示路由规则的作用粒度，scope的取值会决定key的取值。必填。 service 服务粒度 application 应用粒度 Key明确规则体作用在哪个服务或应用。必填。 scope=service时，key取值为[{group}:]{service}[:{version}]的组合 scope=application时，key取值为application名称 enabled=true 当前路由规则是否生效，可不填，缺省生效。 force=false 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为 false。 runtime=false 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。如果用了参数路由，必须设为 true，需要注意设置会影响调用的性能，可不填，缺省为 false。 priority=1 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为 0。 conditions 定义具体的路由规则内容。必填。 Conditions规则体 `conditions`部分是规则的主体，由1到任意多条规则组成，下面我们就每个规则的配置语法做详细说明： 格式 =&amp;gt; 之前的为消费者匹配条件，所有参数和消费者的 URL 进行对比，当消费者满足匹配条件时，对该消费者执行后面的过滤规则。 =&amp;gt; 之后为提供者地址列表的过滤条件，所有参数和提供者的 URL 进行对比，消费者最终只拿到过滤后的地址列表。 如果匹配条件为空，表示对所有消费方应用，如：=&amp;gt; host !</description></item><item><title>1-34 - xDS 解析发生错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/34/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/34/</guid><description>可能的原因 xDS 协议内容存在错误。
排查和解决步骤 可根据堆栈打印的 Endpoints List 进行原因定位。</description></item><item><title>5-34 - NACOS 发生错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/34/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/34/</guid><description>可能的原因 NACOS 配置 API 使用错误。
排查和解决步骤 请参考动态配置中心使用文档中关于 NACOS 部分的描述。</description></item><item><title>旧路由规则</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/routing-rule-deprecated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/routing-rule-deprecated/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
路由规则 1 决定一次 dubbo 服务调用的目标服务器，分为条件路由规则和脚本路由规则，并且支持可扩展 2。
写入路由规则 向注册中心写入路由规则的操作通常由监控中心或治理中心的页面完成
RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(&amp;#34;zookeeper://10.20.153.10:2181&amp;#34;)); registry.register(URL.valueOf(&amp;#34;route://0.0.0.0/com.foo.BarService?category=routers&amp;amp;dynamic=false&amp;amp;rule=&amp;#34; + URL.encode(&amp;#34;host = 10.20.153.10 =&amp;gt; host = 10.20.153.11&amp;#34;))); 其中：
route:// 表示路由规则的类型，支持条件路由规则和脚本路由规则，可扩展，必填。 0.0.0.0 表示对所有 IP 地址生效，如果只想对某个 IP 的生效，请填入具体 IP，必填。 com.foo.BarService 表示只对指定服务生效，必填。 group=foo 对指定服务的指定group生效，不填表示对未配置group的指定服务生效 version=1.0对指定服务的指定version生效，不填表示对未配置version的指定服务生效 category=routers 表示该数据为动态配置类型，必填。 dynamic=false 表示该数据为持久数据，当注册方退出时，数据依然保存在注册中心，必填。 enabled=true 覆盖规则是否生效，可不填，缺省生效。 force=false 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为 false。 runtime=false 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。如果用了参数路由，必须设为 true，需要注意设置会影响调用的性能，可不填，缺省为 false。 priority=1 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为 0。 rule=URL.encode(&amp;quot;host = 10.20.153.10 =&amp;gt; host = 10.20.153.11&amp;quot;) 表示路由规则的内容，必填。 条件路由规则 基于条件表达式的路由规则，如：host = 10.20.153.10 =&amp;gt; host = 10.</description></item><item><title>旧路由规则</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/routing-rule-deprecated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/routing-rule-deprecated/</guid><description>背景 根据服务方法名称、参数和返回值来定义路由规则。
示例 路由规则 1 决定一次 dubbo 服务调用的目标服务器，分为条件路由规则和脚本路由规则，并且支持可扩展 2。
写入路由规则 向注册中心写入路由规则的操作通常由监控中心或治理中心的页面完成
RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(&amp;#34;zookeeper://10.20.153.10:2181&amp;#34;)); registry.register(URL.valueOf(&amp;#34;route://0.0.0.0/com.foo.BarService?category=routers&amp;amp;dynamic=false&amp;amp;rule=&amp;#34; + URL.encode(&amp;#34;host = 10.20.153.10 =&amp;gt; host = 10.20.153.11&amp;#34;))); 其中：
route:// 表示路由规则的类型，支持条件路由规则和脚本路由规则，可扩展，必填。 0.0.0.0 表示对所有 IP 地址生效，如果只想对某个 IP 的生效，请填入具体 IP，必填。 com.foo.BarService 表示只对指定服务生效，必填。 group=foo 对指定服务的指定group生效，不填表示对未配置group的指定服务生效 version=1.0对指定服务的指定version生效，不填表示对未配置version的指定服务生效 category=routers 表示该数据为动态配置类型，必填。 dynamic=false 表示该数据为持久数据，当注册方退出时，数据依然保存在注册中心，必填。 enabled=true 覆盖规则是否生效，可不填，缺省生效。 force=false 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为 false。 runtime=false 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。如果用了参数路由，必须设为 true，需要注意设置会影响调用的性能，可不填，缺省为 false。 priority=1 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为 0。 rule=URL.encode(&amp;quot;host = 10.20.153.10 =&amp;gt; host = 10.20.153.11&amp;quot;) 表示路由规则的内容，必填。 条件路由规则 基于条件表达式的路由规则，如：host = 10.</description></item><item><title>配置规则</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/config-rule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/config-rule/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
提示 本文描述的是新版本规则配置，而不是老版本配置规则 覆盖规则是 Dubbo 设计的在无需重启应用的情况下，动态调整 RPC 调用行为的一种能力。2.7.0 版本开始，支持从服务和应用两个粒度来调整动态配置。
概览 请在服务治理控制台查看或修改覆盖规则。
应用粒度
# 将应用demo（key:demo）在20880端口上提供（side:provider）的所有服务（scope:application）的权重修改为1000（weight:1000）。 --- configVersion: v2.7 scope: application key: demo enabled: true configs: - addresses: [&amp;#34;0.0.0.0:20880&amp;#34;] side: provider parameters: weight: 1000 ... 服务粒度
# 所有消费（side:consumer）DemoService服务（key:org.apache.dubbo.samples.governance.api.DemoService）的应用实例（addresses:[0.0.0.0]），超时时间修改为6000ms --- configVersion: v2.7 scope: service key: org.apache.dubbo.samples.governance.api.DemoService enabled: true configs: - addresses: [0.0.0.0] side: consumer parameters: timeout: 6000 ... 规则详解 配置模板 --- configVersion: v2.7 scope: application/service key: app-name/group+service+version enabled: true configs: - addresses: [&amp;#34;0.</description></item><item><title>配置规则</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/config-rule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/config-rule/</guid><description>背景 提示 本文描述的是新版本规则配置，而不是老版本配置规则 覆盖规则是 Dubbo 设计的在无需重启应用的情况下，动态调整 RPC 调用行为的一种能力。2.7.0 版本开始，支持从服务和应用两个粒度来调整动态配置。
示例 请在服务治理控制台查看或修改覆盖规则。
应用粒度 # 将应用demo（key:demo）在20880端口上提供（side:provider）的所有服务（scope:application）的权重修改为1000（weight:1000）。 --- configVersion: v2.7 scope: application key: demo enabled: true configs: - addresses: [&amp;#34;0.0.0.0:20880&amp;#34;] side: provider parameters: weight: 1000 ... 服务粒度 # 所有消费（side:consumer）DemoService服务（key:org.apache.dubbo.samples.governance.api.DemoService）的应用实例（addresses:[0.0.0.0]），超时时间修改为6000ms --- configVersion: v2.7 scope: service key: org.apache.dubbo.samples.governance.api.DemoService enabled: true configs: - addresses: [0.0.0.0] side: consumer parameters: timeout: 6000 ... 规则详解 配置模板 --- configVersion: v2.7 scope: application/service key: app-name/group+service+version enabled: true configs: - addresses: [&amp;#34;0.0.0.0&amp;#34;] providerAddresses: [&amp;#34;1.</description></item><item><title>1-35 - ZK 异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/35/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/35/</guid><description>可能的原因 ZK 无法连接里或连接超时。 ZNode 在创建时已存在。 排查和解决步骤 检查 ZK 配置 IP 和 端口号是否正确。可使用第三方工具 ZooInspector 进行连接测试。 根据堆栈提醒 ZNode 信息进行判断，是否可清理当前节点。</description></item><item><title>5-35 - 容器初始化失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/35/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/35/</guid><description>可能的原因 未定义接口的 org.apache.dubbo.container.Container SPI 实现。
附：目前在org.apache.dubbo.container.Main 类中测试使用。
排查和解决步骤</description></item><item><title>服务降级</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/service-downgrade/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/service-downgrade/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。
向注册中心写入动态配置覆盖规则：
RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(&amp;#34;zookeeper://10.20.153.10:2181&amp;#34;)); registry.register(URL.valueOf(&amp;#34;override://0.0.0.0/com.foo.BarService?category=configurators&amp;amp;dynamic=false&amp;amp;application=foo&amp;amp;mock=force:return+null&amp;#34;)); 其中：
mock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。 还可以改为 mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。 提示 2.2.0 以上版本支持</description></item><item><title>服务降级</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/service-downgrade/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/service-downgrade/</guid><description>背景 可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。
示例 向注册中心写入动态配置覆盖规则：
RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(&amp;#34;zookeeper://10.20.153.10:2181&amp;#34;)); registry.register(URL.valueOf(&amp;#34;override://0.0.0.0/com.foo.BarService?category=configurators&amp;amp;dynamic=false&amp;amp;application=foo&amp;amp;mock=force:return+null&amp;#34;)); 其中：
mock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。 还可以改为 mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。 提示 2.2.0 以上版本支持</description></item><item><title>旧配置规则</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/config-rule-deprecated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/config-rule-deprecated/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
向注册中心写入动态配置覆盖规则。该功能通常由监控中心或治理中心的页面完成。
RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(&amp;#34;zookeeper://10.20.153.10:2181&amp;#34;)); registry.register(URL.valueOf(&amp;#34;override://0.0.0.0/com.foo.BarService?category=configurators&amp;amp;dynamic=false&amp;amp;application=foo&amp;amp;timeout=1000&amp;#34;)); 其中：
override:// 表示数据采用覆盖方式，支持 override 和 absent，可扩展，必填。 0.0.0.0 表示对所有 IP 地址生效，如果只想覆盖某个 IP 的数据，请填入具体 IP，必填。 com.foo.BarService 表示只对指定服务生效，必填。 category=configurators 表示该数据为动态配置类型，必填。 dynamic=false 表示该数据为持久数据，当注册方退出时，数据依然保存在注册中心，必填。 enabled=true 覆盖规则是否生效，可不填，缺省生效。 application=foo 表示只对指定应用生效，可不填，表示对所有应用生效。 timeout=1000 表示将满足以上条件的 timeout 参数的值覆盖为 1000。如果想覆盖其它参数，直接加在 override 的 URL 参数上。 示例：
禁用提供者：(通常用于临时踢除某台提供者机器，相似的，禁止消费者访问请使用路由规则)
override://10.20.153.10/com.foo.BarService?category=configurators&amp;amp;dynamic=false&amp;amp;disbaled=true 调整权重：(通常用于容量评估，缺省权重为 100)
override://10.20.153.10/com.foo.BarService?category=configurators&amp;amp;dynamic=false&amp;amp;weight=200 调整负载均衡策略：(缺省负载均衡策略为 random)
override://10.20.153.10/com.foo.BarService?category=configurators&amp;amp;dynamic=false&amp;amp;loadbalance=leastactive 服务降级：(通常用于临时屏蔽某个出错的非关键服务)
override://0.0.0.0/com.foo.BarService?category=configurators&amp;amp;dynamic=false&amp;amp;application=foo&amp;amp;mock=force:return+null 提示 2.2.0 以上版本支持</description></item><item><title>旧配置规则</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/config-rule-deprecated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/config-rule-deprecated/</guid><description>背景 向注册中心写入动态配置覆盖规则。该功能通常由监控中心或治理中心的页面完成。
示例 RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(&amp;#34;zookeeper://10.20.153.10:2181&amp;#34;)); registry.register(URL.valueOf(&amp;#34;override://0.0.0.0/com.foo.BarService?category=configurators&amp;amp;dynamic=false&amp;amp;application=foo&amp;amp;timeout=1000&amp;#34;)); 其中：
override:// 表示数据采用覆盖方式，支持 override 和 absent，可扩展，必填。 0.0.0.0 表示对所有 IP 地址生效，如果只想覆盖某个 IP 的数据，请填入具体 IP，必填。 com.foo.BarService 表示只对指定服务生效，必填。 category=configurators 表示该数据为动态配置类型，必填。 dynamic=false 表示该数据为持久数据，当注册方退出时，数据依然保存在注册中心，必填。 enabled=true 覆盖规则是否生效，可不填，缺省生效。 application=foo 表示只对指定应用生效，可不填，表示对所有应用生效。 timeout=1000 表示将满足以上条件的 timeout 参数的值覆盖为 1000。如果想覆盖其它参数，直接加在 override 的 URL 参数上。 示例：
禁用提供者：(通常用于临时踢除某台提供者机器，相似的，禁止消费者访问请使用路由规则)
override://10.20.153.10/com.foo.BarService?category=configurators&amp;amp;dynamic=false&amp;amp;disbaled=true 调整权重：(通常用于容量评估，缺省权重为 100)
override://10.20.153.10/com.foo.BarService?category=configurators&amp;amp;dynamic=false&amp;amp;weight=200 调整负载均衡策略：(缺省负载均衡策略为 random)
override://10.20.153.10/com.foo.BarService?category=configurators&amp;amp;dynamic=false&amp;amp;loadbalance=leastactive 服务降级：(通常用于临时屏蔽某个出错的非关键服务)
override://0.0.0.0/com.foo.BarService?category=configurators&amp;amp;dynamic=false&amp;amp;application=foo&amp;amp;mock=force:return+null 提示 2.2.0 以上版本支持</description></item><item><title>消费端线程池模型</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/consumer-threadpool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/consumer-threadpool/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
2.7.5 版本对整个调用链路做了全面的优化，根据压测结果显示，总体 QPS 性能提升将近 30%，同时也减少了调用过程中的内存分配开销。其中一个值得提及的设计点是 2.7.5 引入了 Servicerepository 的概念，在服务注册阶段提前生成 ServiceDescriptor 和 MethodDescriptor，以减少 RPC 调用阶段计算 Service 原信息带来的资源消耗。
消费端线程池模型优化 对 2.7.5 版本之前的 Dubbo 应用，尤其是一些消费端应用，当面临需要消费大量服务且并发数比较大的大流量场景时（典型如网关类场景），经常会出现消费端线程数分配过多的问题，具体问题讨论可参见 Need a limited Threadpool in consumer side #2013
改进后的消费端线程池模型，通过复用业务端被阻塞的线程，很好的解决了这个问题。
老的线程池模型 我们重点关注 Consumer 部分：
业务线程发出请求，拿到一个 Future 实例。 业务线程紧接着调用 future.get 阻塞等待业务结果返回。 当业务数据返回后，交由独立的 Consumer 端线程池进行反序列化等处理，并调用 future.set 将反序列化后的业务结果置回。 业务线程拿到结果直接返回 2.7.5 版本引入的线程池模型
业务线程发出请求，拿到一个 Future 实例。 在调用 future.get() 之前，先调用 ThreadlessExecutor.wait()，wait 会使业务线程在一个阻塞队列上等待，直到队列中被加入元素。 当业务数据返回后，生成一个 Runnable Task 并放入 ThreadlessExecutor 队列 业务线程将 Task 取出并在本线程中执行：反序列化业务数据并 set 到 Future。 业务线程拿到结果直接返回 这样，相比于老的线程池模型，由业务线程自己负责监测并解析返回结果，免去了额外的消费端线程池开销。</description></item><item><title>消费端线程池模型</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/consumer-threadpool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/consumer-threadpool/</guid><description>背景 2.7.5 版本对整个调用链路做了全面的优化，根据压测结果显示，总体 QPS 性能提升将近 30%，同时也减少了调用过程中的内存分配开销。其中一个值得提及的设计点是 2.7.5 引入了 Servicerepository 的概念，在服务注册阶段提前生成 ServiceDescriptor 和 MethodDescriptor，以减少 RPC 调用阶段计算 Service 原信息带来的资源消耗。
示例 消费端线程池模型优化 对 2.7.5 版本之前的 Dubbo 应用，尤其是一些消费端应用，当面临需要消费大量服务且并发数比较大的大流量场景时（典型如网关类场景），经常会出现消费端线程数分配过多的问题，具体问题讨论可参见 Need a limited Threadpool in consumer side #2013
改进后的消费端线程池模型，通过复用业务端被阻塞的线程，很好的解决了这个问题。
老的线程池模型 我们重点关注 Consumer 部分：
业务线程发出请求，拿到一个 Future 实例。 业务线程紧接着调用 future.get 阻塞等待业务结果返回。 当业务数据返回后，交由独立的 Consumer 端线程池进行反序列化等处理，并调用 future.set 将反序列化后的业务结果置回。 业务线程拿到结果直接返回 2.7.5 版本引入的线程池模型 业务线程发出请求，拿到一个 Future 实例。 在调用 future.get() 之前，先调用 ThreadlessExecutor.wait()，wait 会使业务线程在一个阻塞队列上等待，直到队列中被加入元素。 当业务数据返回后，生成一个 Runnable Task 并放入 ThreadlessExecutor 队列 业务线程将 Task 取出并在本线程中执行：反序列化业务数据并 set 到 Future。 业务线程拿到结果直接返回 这样，相比于老的线程池模型，由业务线程自己负责监测并解析返回结果，免去了额外的消费端线程池开销。</description></item><item><title>1-36 - 未知异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/36/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/36/</guid><description>可能的原因 该错误码的意义已经调整。对于 Dubbo 3.1.4、3.2.0-beta.3 及其之前的版本的该错误码的出错，请参考错误码 99-0。
排查和解决步骤 （该错误码目前空缺）</description></item><item><title>5-36 - 过滤器校验时发生错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/36/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/36/</guid><description>可能的原因 自定义过滤器扩展类中重写的 invoke 方法，发生业务代码异常。
排查和解决步骤 使用 ps -eaf |grep &amp;lt;错误服务&amp;gt; 可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>优雅停机</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/graceful-shutdown/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/graceful-shutdown/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果用户使用 kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。
原理 服务提供方
停止时，先标记为不接收新请求，新请求过来时直接报错，让客户端重试其它机器。 然后，检测线程池中的线程是否正在运行，如果有，等待所有线程执行完成，除非超时，则强制关闭。 服务消费方
停止时，不再发起新的调用请求，所有新的调用在客户端即报错。 然后，检测有没有请求的响应还没有返回，等待响应返回，除非超时，则强制关闭。 设置方式 设置优雅停机超时时间，缺省超时时间是 10 秒，如果超时则强制关闭。
# dubbo.properties dubbo.service.shutdown.wait=15000 如果 ShutdownHook 不能生效，可以自行调用：
DubboShutdownHook.destroyAll(); 建议 使用 tomcat 等容器部署的场景，建议通过扩展 ContextListener 等自行调用以下代码实现优雅停机</description></item><item><title>优雅停机</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/graceful-shutdown/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/graceful-shutdown/</guid><description>背景 Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果用户使用 kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。
示例 服务提供方
停止时，先标记为不接收新请求，新请求过来时直接报错，让客户端重试其它机器。 然后，检测线程池中的线程是否正在运行，如果有，等待所有线程执行完成，除非超时，则强制关闭。 服务消费方
停止时，不再发起新的调用请求，所有新的调用在客户端即报错。 然后，检测有没有请求的响应还没有返回，等待响应返回，除非超时，则强制关闭。 设置方式 设置优雅停机超时时间，缺省超时时间是 10 秒，如果超时则强制关闭。
# dubbo.properties dubbo.service.shutdown.wait=15000 如果 ShutdownHook 不能生效，可以自行调用：
DubboShutdownHook.destroyAll(); 建议 使用 tomcat 等容器部署的场景，建议通过扩展 ContextListener 等自行调用以下代码实现优雅停机</description></item><item><title>1-37 - Nacos 异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/37/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/37/</guid><description>可能的原因 Nacos 配置信息未正确配置。
排查和解决步骤 检查配置 Nacos 的 ip 和端口号是否正确，如果开启了 Nacos 的安全认证，检查用户名和密码配置是否正确。</description></item><item><title>5-37 - 动态配置监听处理发生错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/37/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/37/</guid><description>文件发生变化时，监听事件处理失败
可能的原因 文件权限发生变化或目录权限发生变化。
排查和解决步骤 可根据控制台的堆栈信息，进行代码定位。</description></item><item><title>主机绑定</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/hostname-binding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/hostname-binding/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
查找顺序 缺省主机 IP 查找顺序：
通过 LocalHost.getLocalHost() 获取本机地址。 如果是 127.* 等 loopback 地址，则扫描各网卡，获取网卡 IP。 主机配置 注册的地址如果获取不正确，比如需要注册公网地址，可以：
可以在 /etc/hosts 中加入：机器名 公网 IP，比如：
test1 205.182.23.201 在 dubbo.xml 中加入主机地址的配置：
&amp;lt;dubbo:protocol host=&amp;#34;205.182.23.201&amp;#34;&amp;gt; 或在 dubbo.properties 中加入主机地址的配置：
dubbo.protocol.host=205.182.23.201 端口配置 缺省主机端口与协议相关：
协议 端口 dubbo 20880 rmi 1099 http 80 hessian 80 webservice 80 memcached 11211 redis 6379 可以按照下面的方式配置端口：
在 dubbo.xml 中加入主机地址的配置：
&amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;20880&amp;#34;&amp;gt; 或在 dubbo.properties 中加入主机地址的配置：
dubbo.protocol.dubbo.port=20880</description></item><item><title>主机绑定</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/hostname-binding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/hostname-binding/</guid><description>背景 服务提供者绑定到机器上特定网络接口或 IP 地址的过程，决定了服务提供商将使用哪个网络接口或 IP 地址来侦听来自消费者的传入请求。
示例 查找顺序 缺省主机 IP 查找顺序：
通过 LocalHost.getLocalHost() 获取本机地址。 如果是 127.* 等 loopback 地址，则扫描各网卡，获取网卡 IP。 主机配置 注册的地址如果获取不正确，比如需要注册公网地址，可以：
可以在 /etc/hosts 中加入：机器名 公网 IP，比如：
test1 205.182.23.201 在 dubbo.xml 中加入主机地址的配置：
&amp;lt;dubbo:protocol host=&amp;#34;205.182.23.201&amp;#34;&amp;gt; 或在 dubbo.properties 中加入主机地址的配置：
dubbo.protocol.host=205.182.23.201 端口配置 缺省主机端口与协议相关：
协议 端口 dubbo 20880 rmi 1099 http 80 hessian 80 webservice 80 memcached 11211 redis 6379 可以按照下面的方式配置端口：
在 dubbo.xml 中加入主机地址的配置：
&amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;20880&amp;#34;&amp;gt; 或在 dubbo.properties 中加入主机地址的配置：
dubbo.protocol.dubbo.port=20880</description></item><item><title>主机配置</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/set-host/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/set-host/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
背景 在 Dubbo 中， Provider 启动时主要做两个事情，一是启动 server，二是向注册中心注册服务。启动 server 时需要绑定 socket，向注册中心注册服务时也需要发送 socket 唯一标识服务地址。
dubbo中不设置host时默认host是什么? 那在dubbo中如何指定服务的host,我们是否可以用hostname或domain代替IP地址作为host? 在使用docker时,有时需要设置端口映射,此时,启动server时绑定的socket和向注册中心注册的socket使用不同的端口号,此时又该如何设置? dubbo 中不设置 host 时默认 host 是什么 一般的 dubbo 协议配置如下:
... &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;20890&amp;#34; /&amp;gt; ... 可以看到,只配置了端口号,没有配置 host，此时设置的 host 又是什么呢?
查看代码发现,在 org.apache.dubbo.config.ServiceConfig#findConfigedHosts() 中,通过 InetAddress.getLocalHost().getHostAddress() 获取默认 host。其返回值如下：
未联网时，返回 127.0.0.1 在阿里云服务器中，返回私有地址,如: 172.18.46.234 在本机测试时，返回公有地址，如: 30.5.10.11 那在 dubbo 中如何指定服务的 socket? 除此之外,可以通过 dubbo.protocol 或 dubbo.provider 的 host 属性对 host 进行配置,支持IP地址和域名,如下:
... &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;20890&amp;#34; host=&amp;#34;www.example.com&amp;#34;/&amp;gt; ... 在使用 docker 时，有时需要设置端口映射，此时，启动 server 时绑定的 socket 和向注册中心注册的 socket 使用不同的端口号，此时又该如何设置？ 见 dubbo 通过环境变量设置 host</description></item><item><title>主机配置</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/set-host/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/set-host/</guid><description>背景 在 Dubbo 中， Provider 启动时主要做两个事情，一是启动 server，二是向注册中心注册服务。启动 server 时需要绑定 socket，向注册中心注册服务时也需要发送 socket 唯一标识服务地址。
dubbo中不设置host时默认host是什么? 那在dubbo中如何指定服务的host,我们是否可以用hostname或domain代替IP地址作为host? 在使用docker时,有时需要设置端口映射,此时,启动server时绑定的socket和向注册中心注册的socket使用不同的端口号,此时又该如何设置? 示例 dubbo 中不设置 host 时默认 host 是什么 一般的 dubbo 协议配置如下:
... &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;20890&amp;#34; /&amp;gt; ... 可以看到,只配置了端口号,没有配置 host，此时设置的 host 又是什么呢?
查看代码发现,在 org.apache.dubbo.config.ServiceConfig#findConfigedHosts() 中,通过 InetAddress.getLocalHost().getHostAddress() 获取默认 host。其返回值如下：
未联网时，返回 127.0.0.1 在阿里云服务器中，返回私有地址,如: 172.18.46.234 在本机测试时，返回公有地址，如: 30.5.10.11 那在 dubbo 中如何指定服务的 socket? 除此之外,可以通过 dubbo.protocol 或 dubbo.provider 的 host 属性对 host 进行配置,支持IP地址和域名,如下:
... &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;20890&amp;#34; host=&amp;#34;www.example.com&amp;#34;/&amp;gt; ... 在使用 docker 时，有时需要设置端口映射，此时，启动 server 时绑定的 socket 和向注册中心注册的 socket 使用不同的端口号，此时又该如何设置？ 见 dubbo 通过环境变量设置 host</description></item><item><title>注册信息简化</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/simplify-registry-data/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/simplify-registry-data/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
背景 Dubbo provider 中的服务配置项有接近 30 个配置项。 排除注册中心服务治理需要之外，很大一部分配置项是 provider 自己使用，不需要透传给消费者。这部分数据不需要进入注册中心，而只需要以 key-value 形式持久化存储。
Dubbo consumer 中的配置项也有 20+个配置项。在注册中心之中，服务消费者列表中只需要关注 application，version，group，ip，dubbo 版本等少量配置，其他配置也可以以 key-value 形式持久化存储。
这些数据是以服务为维度注册进入注册中心，导致了数据量的膨胀，进而引发注册中心(如 zookeeper)的网络开销增大，性能降低。
现有功能 sample 当前现状一个简单展示。通过这个展示，分析下为什么需要做简化配置。
参考 sample 子工程： dubbo-samples-simplified-registry/dubbo-samples-simplified-registry-nosimple （跑 sample 前，先跑下 ZKClean 进行配置项清理）
dubbo-provider.xml配置
&amp;lt;dubbo:application name=&amp;#34;simplified-registry-nosimple-provider&amp;#34;/&amp;gt; &amp;lt;dubbo:registry address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;demoService&amp;#34; class=&amp;#34;org.apache.dubbo.samples.simplified.registry.nosimple.impl.DemoServiceImpl&amp;#34;/&amp;gt; &amp;lt;dubbo:service async=&amp;#34;true&amp;#34; interface=&amp;#34;org.apache.dubbo.samples.simplified.registry.nosimple.api.DemoService&amp;#34; version=&amp;#34;1.2.3&amp;#34; group=&amp;#34;dubbo-simple&amp;#34; ref=&amp;#34;demoService&amp;#34; executes=&amp;#34;4500&amp;#34; retries=&amp;#34;7&amp;#34; owner=&amp;#34;vict&amp;#34; timeout=&amp;#34;5300&amp;#34;/&amp;gt; 启动 provider 的 main 方法之后，查看 zookeeper 的叶子节点（路径为：/dubbo/org.apache.dubbo.samples.simplified.registry.nosimple.api.DemoService/providers 目录下）的内容如下：
dubbo%3A%2F%2F30.5.124.158%3A20880%2Forg.apache.dubbo.samples.simplified.registry.nosimple.api.DemoService %3Fanyhost%3Dtrue%26application%3Dsimplified-registry-xml-provider%26async%3Dtrue%26dubbo%3D 2.0.2%26**executes**%3D4500%26generic%3Dfalse%26group%3Ddubbo-simple%26interface%3D org.apache.dubbo.samples.simplified.registry.nosimple.api.DemoService%26methods%3D sayHello%26**owner**%3Dvict%26pid%3D2767%26**retries**%3D7%26revision%3D1.2.3%26side%3D provider%26**timeout**%3D5300%26timestamp%3D1542361152795%26valid%3Dtrue%26version%3D1.2.3 从加粗字体中能看到有：executes, retries, owner, timeout。但是这些字段不是每个都需要传递给 dubbo ops 或者 dubbo consumer。 同样的，consumer 也有这个问题，可以在例子中启动 Consumer 的 main 方法进行查看。</description></item><item><title>注册信息简化</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/simplify-registry-data/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/simplify-registry-data/</guid><description>背景 Dubbo provider 中的服务配置项有接近 30 个配置项。 排除注册中心服务治理需要之外，很大一部分配置项是 provider 自己使用，不需要透传给消费者。这部分数据不需要进入注册中心，而只需要以 key-value 形式持久化存储。
Dubbo consumer 中的配置项也有 20+个配置项。在注册中心之中，服务消费者列表中只需要关注 application，version，group，ip，dubbo 版本等少量配置，其他配置也可以以 key-value 形式持久化存储。
这些数据是以服务为维度注册进入注册中心，导致了数据量的膨胀，进而引发注册中心(如 zookeeper)的网络开销增大，性能降低。
现有功能 sample 当前现状一个简单展示。通过这个展示，分析下为什么需要做简化配置。
参考 sample 子工程： dubbo-samples-simplified-registry/dubbo-samples-simplified-registry-nosimple （跑 sample 前，先跑下 ZKClean 进行配置项清理）
dubbo-provider.xml配置
&amp;lt;dubbo:application name=&amp;#34;simplified-registry-nosimple-provider&amp;#34;/&amp;gt; &amp;lt;dubbo:registry address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;demoService&amp;#34; class=&amp;#34;org.apache.dubbo.samples.simplified.registry.nosimple.impl.DemoServiceImpl&amp;#34;/&amp;gt; &amp;lt;dubbo:service async=&amp;#34;true&amp;#34; interface=&amp;#34;org.apache.dubbo.samples.simplified.registry.nosimple.api.DemoService&amp;#34; version=&amp;#34;1.2.3&amp;#34; group=&amp;#34;dubbo-simple&amp;#34; ref=&amp;#34;demoService&amp;#34; executes=&amp;#34;4500&amp;#34; retries=&amp;#34;7&amp;#34; owner=&amp;#34;vict&amp;#34; timeout=&amp;#34;5300&amp;#34;/&amp;gt; 启动 provider 的 main 方法之后，查看 zookeeper 的叶子节点（路径为：/dubbo/org.apache.dubbo.samples.simplified.registry.nosimple.api.DemoService/providers 目录下）的内容如下：
dubbo%3A%2F%2F30.5.124.158%3A20880%2Forg.apache.dubbo.samples.simplified.registry.nosimple.api.DemoService %3Fanyhost%3Dtrue%26application%3Dsimplified-registry-xml-provider%26async%3Dtrue%26dubbo%3D 2.0.2%26**executes**%3D4500%26generic%3Dfalse%26group%3Ddubbo-simple%26interface%3D org.apache.dubbo.samples.simplified.registry.nosimple.api.DemoService%26methods%3D sayHello%26**owner**%3Dvict%26pid%3D2767%26**retries**%3D7%26revision%3D1.2.3%26side%3D provider%26**timeout**%3D5300%26timestamp%3D1542361152795%26valid%3Dtrue%26version%3D1.2.3 从加粗字体中能看到有：executes, retries, owner, timeout。但是这些字段不是每个都需要传递给 dubbo ops 或者 dubbo consumer。 同样的，consumer 也有这个问题，可以在例子中启动 Consumer 的 main 方法进行查看。</description></item><item><title>1-38 - Socket 连接异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/38/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/38/</guid><description>可能的原因 连接被拒绝。 连接已经关闭。 排查和解决步骤 可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>5-38 - 配置参数未定义</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/38/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/38/</guid><description>可能的原因 配置参数未定义
排查和解决步骤 多为测试用例中使用，可根据提示明细，进行参数的设置。</description></item><item><title>日志适配</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/logger-strategy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/logger-strategy/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
自 2.2.1 开始，dubbo 开始内置 log4j、slf4j、jcl、jdk 这些日志框架的适配[1]，也可以通过以下方式显式配置日志输出策略：
命令行
java -Ddubbo.application.logger=log4j 在 dubbo.properties 中指定
dubbo.application.logger=log4j 在 dubbo.xml 中配置
&amp;lt;dubbo:application logger=&amp;#34;log4j&amp;#34; /&amp;gt; [1]: 自定义扩展可以参考 日志适配扩展</description></item><item><title>日志适配</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/logger-strategy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/logger-strategy/</guid><description>自 2.2.1 开始，dubbo 开始内置 log4j、slf4j、jcl、jdk 这些日志框架的适配[1]，也可以通过以下方式显式配置日志输出策略：
命令行
java -Ddubbo.application.logger=log4j 在 dubbo.properties 中指定
dubbo.application.logger=log4j 在 dubbo.xml 中配置
&amp;lt;dubbo:application logger=&amp;#34;log4j&amp;#34; /&amp;gt; [1]: 自定义扩展可以参考 日志适配扩展</description></item><item><title>1-39 - 获取元数据失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/39/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/39/</guid><description>可能的原因 元数据中心已与应用服务断开连接。 元数据中心的数据或已被修改。 排查和解决步骤 检查网络通信是否正常，可使用一些简单的 cmd 命令进行检测，如 ping 等。 通过第三方工具进行连接，以及内容的查看。</description></item><item><title>5-39 - Dubbo配置bean初始化器发生错误</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/39/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/39/</guid><description>可能的原因 源代码或被修改
排查和解决步骤 检查业务代码未对核心类进行源码修改或加载的顺序修改。 如：org.apache.dubbo.config.spring.context.DubboConfigBeanInitializer</description></item><item><title>访问日志</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/accesslog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/accesslog/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
如果你想记录每一次请求信息，可开启访问日志，类似于apache的访问日志。注意：此日志量比较大，请注意磁盘容量。
将访问日志输出到当前应用的log4j日志：
&amp;lt;dubbo:protocol accesslog=&amp;#34;true&amp;#34; /&amp;gt; 将访问日志输出到指定文件：
&amp;lt;dubbo:protocol accesslog=&amp;#34;http://10.20.160.198/wiki/display/dubbo/foo/bar.log&amp;#34; /&amp;gt;</description></item><item><title>访问日志</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/accesslog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/accesslog/</guid><description>如果你想记录每一次请求信息，可开启访问日志，类似于apache的访问日志。注意：此日志量比较大，请注意磁盘容量。
将访问日志输出到当前应用的log4j日志：
&amp;lt;dubbo:protocol accesslog=&amp;#34;true&amp;#34; /&amp;gt; 将访问日志输出到指定文件：
&amp;lt;dubbo:protocol accesslog=&amp;#34;http://10.20.160.198/wiki/display/dubbo/foo/bar.log&amp;#34; /&amp;gt;</description></item><item><title>Dubbo 3.2.0-beta.2 正式发布</title><link>https://dubbo.apache.org/zh-cn/blog/2022/11/18/dubbo-3.2.0-beta.2-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</link><pubDate>Fri, 18 Nov 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/11/18/dubbo-3.2.0-beta.2-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</guid><description>Dubbo 3.2.0-beta.2 修改内容 切换到在用户线程序列化，提升协议性能 支持 Netty3 的端口复用 修复存在多个用户配置的 providedBy 时不生效的问题 支持 istio 的 first-party-jwt 能力 删除 fastjson 和 gson 的传递依赖 支持可选 appResponse 不透传的能力 切换到 Fastjson2 为默认序列化依赖 完善注册中心推送的日志 修复路由刷新时机早于服务目录刷新时机的问题 关闭地址推空保护 更新支持 GraalVM Native 的 SPI 生成代码 支持使用 plain text 模式传输 xds 通道 支持 Nacos 批量注册，修复多注册覆盖的问题 支持 Spring Framework 6 and Spring Boot 3 多个代码质量优化提交 前述 Dubbo 3.1.3 的所有修改内容 新贡献者 @weixsun 在 #10941 中提交了第一个贡献 未来的版本规划 3.0、3.1、3.2 有什么区别？未来会怎么发展？发版周期是怎么样的？更多的版本迭代规划也将在近期推出，欢迎关注 Apache Dubbo 官方公众号获取最新的信息。</description></item><item><title>1-40 - 路由等待时间过长</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/40/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/40/</guid><description>可能的原因 路由计算的时间过长，导致地址通知无法等待到一个合适的时间进行地址更新。
排查和解决步骤 检查应用 QPS，如果 QPS 非常高，这个是预期的日志 检查自定义路由的实现，排查是否有异常实现，例如死锁、死循环等 可通过一些第三方的工具或者 jstack [PID] &amp;gt; jstack.log 分析堆栈信息，进行定位。</description></item><item><title>5-40 - Dubbo配置bean未找到</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/40/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/40/</guid><description>可能的原因 源代码或被修改
排查和解决步骤 检查业务代码未对核心类进行源码修改或加载的顺序修改。 如：org.apache.dubbo.config.spring.context.DubboConfigBeanInitializer</description></item><item><title>DestinationRule</title><link>https://dubbo.apache.org/zh-cn/docs/references/routers/destination-rule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/routers/destination-rule/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
DestinationRule DestinationRule用来处理目标地址的规则，与DestinationRule相关的ServiceEntry, WorkloadEntry等定义与开源保持一致
使用示例 apiVersion: service.dubbo.apache.org/v1alpha1 kind: DestinationRule metadata: name: demo-route spec: host: demo subsets: trafficPolicy: 属性说明 Field Type Description Required name string 规则的名字，方便识别规则用意 YES host string 注册中心里面对应的key值，现在是接口名 YES trafficPolicy TrafficPolicy 流量策略 NO subsets Subset[] 服务的单一版本或多版本的命名 YES Subset Subset应用服务的命名，可以是单个也可以是多个版本
使用示例 apiVersion: service.dubbo.apache.org/v1alpha1 kind: DestinationRule metadata: name: demo-route spec: subsets: #Subnet[] - name: labels: 属性说明 Field Type Description Required name string 服务版本名称 YES labels map&amp;lt;string, string&amp;gt; 打在服务身上的标签 YES TrafficPolicy TrafficPolicy表示负载均衡策略</description></item><item><title>Node.js</title><link>https://dubbo.apache.org/zh-cn/download/nodejs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/download/nodejs/</guid><description/></item><item><title>Triple Listener 介绍</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/listener/triple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/user/listener/triple/</guid><description>欢迎认领补充此文档。</description></item><item><title>服务容器</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/service-container/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/service-container/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
服务容器是一个 standalone 的启动程序，因为后台服务不需要 Tomcat 或 JBoss 等 Web 容器的功能，如果硬要用 Web 容器去加载服务提供方，增加复杂性，也浪费资源。
服务容器只是一个简单的 Main 方法，并加载一个简单的 Spring 容器，用于暴露服务。
服务容器的加载内容可以扩展，内置了 spring, jetty, log4j 等加载，可通过容器扩展点进行扩展。配置配在 java 命令的 -D 参数或者 dubbo.properties 中。
容器类型 Spring Container 自动加载 META-INF/spring 目录下的所有 Spring 配置。
配置 spring 配置加载位置：
dubbo.spring.config=classpath*:META-INF/spring/*.xml Jetty Container 启动一个内嵌 Jetty，用于汇报状态。 配置： dubbo.jetty.port=8080：配置 jetty 启动端口 dubbo.jetty.directory=/foo/bar：配置可通过 jetty 直接访问的目录，用于存放静态文件 dubbo.jetty.page=log,status,system：配置显示的页面，缺省加载所有页面 Log4j Container 自动配置 log4j 的配置，在多进程启动时，自动给日志文件按进程分目录。 配置： dubbo.log4j.file=/foo/bar.log：配置日志文件路径 dubbo.log4j.level=WARN：配置日志级别 dubbo.log4j.subdirectory=20880：配置日志子目录，用于多进程启动，避免冲突 容器启动 缺省只加载 spring
java org.apache.dubbo.container.Main 通过 main 函数参数传入要加载的容器</description></item><item><title>服务容器</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/service-container/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/service-container/</guid><description>服务容器是一个 standalone 的启动程序，因为后台服务不需要 Tomcat 或 JBoss 等 Web 容器的功能，如果硬要用 Web 容器去加载服务提供方，增加复杂性，也浪费资源。
服务容器只是一个简单的 Main 方法，并加载一个简单的 Spring 容器，用于暴露服务。
服务容器的加载内容可以扩展，内置了 spring, jetty, log4j 等加载，可通过容器扩展点进行扩展。配置配在 java 命令的 -D 参数或者 dubbo.properties 中。
容器类型 Spring Container 自动加载 META-INF/spring 目录下的所有 Spring 配置。
配置 spring 配置加载位置：
dubbo.spring.config=classpath*:META-INF/spring/*.xml Jetty Container 启动一个内嵌 Jetty，用于汇报状态。 配置： dubbo.jetty.port=8080：配置 jetty 启动端口 dubbo.jetty.directory=/foo/bar：配置可通过 jetty 直接访问的目录，用于存放静态文件 dubbo.jetty.page=log,status,system：配置显示的页面，缺省加载所有页面 Log4j Container 自动配置 log4j 的配置，在多进程启动时，自动给日志文件按进程分目录。 配置： dubbo.log4j.file=/foo/bar.log：配置日志文件路径 dubbo.log4j.level=WARN：配置日志级别 dubbo.log4j.subdirectory=20880：配置日志子目录，用于多进程启动，避免冲突 容器启动 缺省只加载 spring
java org.apache.dubbo.container.Main 通过 main 函数参数传入要加载的容器
java org.apache.dubbo.container.Main spring jetty log4j 通过 JVM 启动参数传入要加载的容器</description></item><item><title>金丝雀部署</title><link>https://dubbo.apache.org/zh-cn/docs/examples/routing/canary-deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/examples/routing/canary-deployment/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
场景描述 描述当前IDC、服务部署、服务信息、希望实现的效果等相关情况
操作工艺 步骤1
路由配置 验证方案 步骤2
路由配置 验证方案</description></item><item><title>Dubbo AOT -- 如何使用 GraalVM Native Image 实现 Dubbo 应用静态化</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/graalvm/support-graalvm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/graalvm/support-graalvm/</guid><description>在 Dubbo 3.3.0 版本中，我们正式发布了 Dubbo AOT 静态化解决方案。本文档将介绍将介绍如何借助 Dubbo AOT 技术将应用接入 GraalVM Native Image，将应用编译为 Native 二进制包的流程以及目前支持的组件。
Dubbo GraalVM 适配文档可能更新滞后 由于 Dubbo AOT 技术发展迅速，本文档内容可能无法总是保持及时更新，请结合以下内容了解最新内容与使用方式：
示例项目源码 博客文章与演讲 关于 GraalVm 的更多信息可以阅读 https://www.graalvm.org/docs/getting-started/container-images/ 此文档。
使用场景 本机映像编译：将应用程序预编译为本机映像，缩短启动时间并减少内存使用。
语言互操作：GraalVM 能够用多种语言编写代码，在同一应用程序中进行互操作。
优化：GraalVM 为用 Java、JavaScript 和其他语言编写的应用程序提供优化，提高 Dubbo 应用程序的性能。
Polyglot 调试：GraalVM 能够在同一会话中调试用多种语言编写的代码，对复杂 Dubbo 应用程序中的问题进行故障排除时非常有用。
Java 运行时：可以在 GraalVM 上运行，提供更快、更高效的 Java 运行时环境。
开发微服务：可以与 GraalVM 结合，创建高性能、低资源利用率的微服务。
使用方式 在编译我们的dubbo项目之前，需要确保我们正基于graalVm的环境。
第一步：安装GraalVM 在Graalvm官网根据自己的系统选取对应Graalvm版本：https://www.graalvm.org/downloads/ 根据官方文档安装native-image：https://www.graalvm.org/latest/reference-manual/native-image/#install-native-image 第二步：配置profiles 其中包括maven-compiler-plugin、spring-boot-maven-plugin、native-maven-plugin、dubbo-maven-plugin，修改dubbo-maven-plugin中的mainClass为所需的启动类全路径。（其中API使用方式无需添加spring-boot-maven-plugin依赖。）
&amp;lt;profiles&amp;gt; &amp;lt;profile&amp;gt; &amp;lt;id&amp;gt;native&amp;lt;/id&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;release&amp;gt;17&amp;lt;/release&amp;gt; &amp;lt;fork&amp;gt;true&amp;lt;/fork&amp;gt; &amp;lt;verbose&amp;gt;true&amp;lt;/verbose&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.</description></item><item><title>注解配置</title><link>https://dubbo.apache.org/zh-cn/docs/references/configuration/annotation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/configuration/annotation/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
提示 需要 2.6.3 及以上版本支持。 点此查看 完整示例 服务提供方 Service注解暴露服务 @Service public class AnnotationServiceImpl implements AnnotationService { @Override public String sayHello(String name) { return &amp;#34;annotation: hello, &amp;#34; + name; } } 增加应用共享配置 # dubbo-provider.properties dubbo.application.name=annotation-provider dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.protocol.name=dubbo dubbo.protocol.port=20880 指定Spring扫描路径 @Configuration @EnableDubbo(scanBasePackages = &amp;#34;org.apache.dubbo.samples.simple.annotation.impl&amp;#34;) @PropertySource(&amp;#34;classpath:/spring/dubbo-provider.properties&amp;#34;) static public class ProviderConfiguration { } 服务消费方 Reference注解引用服务 @Component(&amp;#34;annotationAction&amp;#34;) public class AnnotationAction { @Reference private AnnotationService annotationService; public String doSayHello(String name) { return annotationService.sayHello(name); } } 增加应用共享配置 # dubbo-consumer.</description></item><item><title>1-41 - Istio 异常</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/41/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/41/</guid><description>可能的原因 获取 istio 的配置文件失败
排查和解决步骤 检查应用是否部署在 Kubernetes Pod 环境中，目前暂不支持 VM 部署。</description></item><item><title>5-41 - SSL证书读取失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/41/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/41/</guid><description>可能的原因 SSL 证书配置异常
排查和解决步骤 检查 SSL 证书的配置，查看对应文件是否存在</description></item><item><title>ReferenceConfig 缓存</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/reference-config-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/reference-config-cache/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
ReferenceConfig 实例很重，封装了与注册中心的连接以及与提供者的连接，需要缓存。否则重复生成 ReferenceConfig 可能造成性能问题并且会有内存和连接泄漏。在 API 方式编程时，容易忽略此问题。
因此，自 2.4.0 版本开始， dubbo 提供了简单的工具类 ReferenceConfigCache用于缓存 ReferenceConfig 实例。
使用方式如下：
ReferenceConfig&amp;lt;XxxService&amp;gt; reference = new ReferenceConfig&amp;lt;XxxService&amp;gt;(); reference.setInterface(XxxService.class); reference.setVersion(&amp;#34;1.0.0&amp;#34;); ...... ReferenceConfigCache cache = ReferenceConfigCache.getCache(); // cache.get方法中会缓存 Reference对象，并且调用ReferenceConfig.get方法启动ReferenceConfig XxxService xxxService = cache.get(reference); // 注意！ Cache会持有ReferenceConfig，不要在外部再调用ReferenceConfig的destroy方法，导致Cache内的ReferenceConfig失效！ // 使用xxxService对象 xxxService.sayHello(); 消除 Cache 中的 ReferenceConfig，将销毁 ReferenceConfig 并释放对应的资源。
ReferenceConfigCache cache = ReferenceConfigCache.getCache(); cache.destroy(reference); 缺省 ReferenceConfigCache 把相同服务 Group、接口、版本的 ReferenceConfig 认为是相同，缓存一份。即以服务 Group、接口、版本为缓存的 Key。
可以修改这个策略，在 ReferenceConfigCache.getCache 时，传一个 KeyGenerator。详见 ReferenceConfigCache 类的方法。
KeyGenerator keyGenerator = new .</description></item><item><title>ReferenceConfig 缓存</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/reference-config-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/reference-config-cache/</guid><description>ReferenceConfig 实例很重，封装了与注册中心的连接以及与提供者的连接，需要缓存。否则重复生成 ReferenceConfig 可能造成性能问题并且会有内存和连接泄漏。在 API 方式编程时，容易忽略此问题。
因此，自 2.4.0 版本开始， dubbo 提供了简单的工具类 ReferenceConfigCache用于缓存 ReferenceConfig 实例。
使用方式如下：
ReferenceConfig&amp;lt;XxxService&amp;gt; reference = new ReferenceConfig&amp;lt;XxxService&amp;gt;(); reference.setInterface(XxxService.class); reference.setVersion(&amp;#34;1.0.0&amp;#34;); ...... ReferenceConfigCache cache = ReferenceConfigCache.getCache(); // cache.get方法中会缓存 Reference对象，并且调用ReferenceConfig.get方法启动ReferenceConfig XxxService xxxService = cache.get(reference); // 注意！ Cache会持有ReferenceConfig，不要在外部再调用ReferenceConfig的destroy方法，导致Cache内的ReferenceConfig失效！ // 使用xxxService对象 xxxService.sayHello(); 消除 Cache 中的 ReferenceConfig，将销毁 ReferenceConfig 并释放对应的资源。
ReferenceConfigCache cache = ReferenceConfigCache.getCache(); cache.destroy(reference); 缺省 ReferenceConfigCache 把相同服务 Group、接口、版本的 ReferenceConfig 认为是相同，缓存一份。即以服务 Group、接口、版本为缓存的 Key。
可以修改这个策略，在 ReferenceConfigCache.getCache 时，传一个 KeyGenerator。详见 ReferenceConfigCache 类的方法。
KeyGenerator keyGenerator = new ... ReferenceConfigCache cache = ReferenceConfigCache.</description></item><item><title>只注册</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/registry-only/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/registry-only/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
如果有两个镜像环境，两个注册中心，有一个服务只在其中一个注册中心有部署，另一个注册中心还没来得及部署，而两个注册中心的其它应用都需要依赖此服务。这个时候，可以让服务提供者方只注册服务到另一注册中心，而不从另一注册中心订阅服务。
禁用订阅配置
&amp;lt;dubbo:registry id=&amp;#34;hzRegistry&amp;#34; address=&amp;#34;10.20.153.10:9090&amp;#34; /&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;qdRegistry&amp;#34; address=&amp;#34;10.20.141.150:9090&amp;#34; subscribe=&amp;#34;false&amp;#34; /&amp;gt; 或者
&amp;lt;dubbo:registry id=&amp;#34;hzRegistry&amp;#34; address=&amp;#34;10.20.153.10:9090&amp;#34; /&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;qdRegistry&amp;#34; address=&amp;#34;10.20.141.150:9090?subscribe=false&amp;#34; /&amp;gt;</description></item><item><title>只注册</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/registry-only/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/registry-only/</guid><description>如果有两个镜像环境，两个注册中心，有一个服务只在其中一个注册中心有部署，另一个注册中心还没来得及部署，而两个注册中心的其它应用都需要依赖此服务。这个时候，可以让服务提供者方只注册服务到另一注册中心，而不从另一注册中心订阅服务。
禁用订阅配置
&amp;lt;dubbo:registry id=&amp;#34;hzRegistry&amp;#34; address=&amp;#34;10.20.153.10:9090&amp;#34; /&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;qdRegistry&amp;#34; address=&amp;#34;10.20.141.150:9090&amp;#34; subscribe=&amp;#34;false&amp;#34; /&amp;gt; 或者
&amp;lt;dubbo:registry id=&amp;#34;hzRegistry&amp;#34; address=&amp;#34;10.20.153.10:9090&amp;#34; /&amp;gt; &amp;lt;dubbo:registry id=&amp;#34;qdRegistry&amp;#34; address=&amp;#34;10.20.141.150:9090?subscribe=false&amp;#34; /&amp;gt;</description></item><item><title>1-42 - Nacos 存在低版本服务</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/42/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/1/42/</guid><description>可能的原因 Nacos 注册中心订阅到了老版本的服务，通常是服务端 Dubbo 版本低于 2.7.3 导致的。
排查和解决步骤 升级服务端到最新稳定版本。</description></item><item><title>5-42 - Dubbo 证书签发失败</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/42/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/42/</guid><description>可能的原因 Dubbo 请求远程 CA 签发证书失败
排查和解决步骤 检查 CA 连接配置 检查 CA 运行状态 检查 CA 日志</description></item><item><title>分布式事务</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/distributed-transaction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/distributed-transaction/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
分布式事务基于 JTA/XA 规范实现。
两阶段提交：
在 Dubbo 中，可以采用 seata 来完成对分布式事务的支持。</description></item><item><title>分布式事务</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/distributed-transaction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/distributed-transaction/</guid><description>分布式事务基于 JTA/XA 规范实现。
两阶段提交：
在 Dubbo 中，可以采用 seata 来完成对分布式事务的支持。</description></item><item><title>使用 Seata 支持分布式事务</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/trasaction/distributed-transaction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/trasaction/distributed-transaction/</guid><description>本示例演示如何使用 Apache Seata 实现 Dubbo 分布式事务功能，保证数据一致性。
Apache Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。 在Dubbo中集成Seata实现分布式事务非常方便，只需简单几步即可完成，本文将通过一个示例带你快速体验，示例总体架构图如下：
开始前，请先完成以下内容:
下载示例源码
git clone --depth=1 https://github.com/apache/dubbo-samples.git 进入示例源码目录：
cd dubbo-samples/2-advanced/dubbo-samples-seata 下载最新版的seata-server二进制包至本地。
步骤 1：建立数据库并初始化相关测试数据 本文将使用MySQL 5.7 (更多支持的数据库可在文末查看附录)。 进入dubbo-samples-seata的script目录，找到dubbo_biz.sql和undo_log.sql两个数据库脚本文件，内容如下: undo_log.sql是Seata AT 模式需要 UNDO_LOG 表
-- for AT mode you must to init this sql for you business database. the seata server not need it. CREATE TABLE IF NOT EXISTS `undo_log` ( `branch_id` BIGINT NOT NULL COMMENT &amp;#39;branch transaction id&amp;#39;, `xid` VARCHAR(128) NOT NULL COMMENT &amp;#39;global transaction id&amp;#39;, `context` VARCHAR(128) NOT NULL COMMENT &amp;#39;undo_log context,such as serialization&amp;#39;, `rollback_info` LONGBLOB NOT NULL COMMENT &amp;#39;rollback info&amp;#39;, `log_status` INT(11) NOT NULL COMMENT &amp;#39;0:normal status,1:defense status&amp;#39;, `log_created` DATETIME(6) NOT NULL COMMENT &amp;#39;create datetime&amp;#39;, `log_modified` DATETIME(6) NOT NULL COMMENT &amp;#39;modify datetime&amp;#39;, UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`) ) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8mb4 COMMENT =&amp;#39;AT transaction mode undo table&amp;#39;; ALTER TABLE `undo_log` ADD INDEX `ix_log_created` (`log_created`); dubbo_biz.</description></item><item><title>应用级服务发现地址迁移规则说明</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/migration-invoker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/migration-invoker/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
状态模型 在 Dubbo 3 之前地址注册模型是以接口级粒度注册到注册中心的，而 Dubbo 3 全新的应用级注册模型注册到注册中心的粒度是应用级的。从注册中心的实现上来说是几乎不一样的，这导致了对于从接口级注册模型获取到的 invokers 是无法与从应用级注册模型获取到的 invokers 进行合并的。为了帮助用户从接口级往应用级迁移，Dubbo 3 设计了 Migration 机制，基于三个状态的切换实现实际调用中地址模型的切换。
当前共存在三种状态，FORCE_INTERFACE（强制接口级），APPLICATION_FIRST（应用级优先）、FORCE_APPLICATION（强制应用级）。
FORCE_INTERFACE：只启用兼容模式下接口级服务发现的注册中心逻辑，调用流量 100% 走原有流程 APPLICATION_FIRST：开启接口级、应用级双订阅，运行时根据阈值和灰度流量比例动态决定调用流量走向 FORCE_APPLICATION：只启用新模式下应用级服务发现的注册中心逻辑，调用流量 100% 走应用级订阅的地址
规则体说明 规则采用 yaml 格式配置，具体配置下参考如下：
key: 消费者应用名（必填） step: 状态名（必填） threshold: 决策阈值（默认1.0） proportion: 灰度比例（默认100） delay: 延迟决策时间（默认0） force: 强制切换（默认 false） interfaces: 接口粒度配置（可选） - serviceKey: 接口名（接口 + : + 版本号）（必填） threshold: 决策阈值 proportion: 灰度比例 delay: 延迟决策时间 force: 强制切换 step: 状态名（必填） - serviceKey: 接口名（接口 + : + 版本号） step: 状态名 applications: 应用粒度配置（可选） - serviceKey: 应用名（消费的上游应用名）（必填） threshold: 决策阈值 proportion: 灰度比例 delay: 延迟决策时间 force: 强制切换 step: 状态名（必填） key: 消费者应用名 step: 状态名（FORCE_INTERFACE、APPLICATION_FIRST、FORCE_APPLICATION） threshold: 决策阈值（浮点数，具体含义参考后文） proportion: 灰度比例（0～100，决定调用次数比例） delay: 延迟决策时间（延迟决策的时间，实际等待时间为 1～2 倍 delay 时间，取决于注册中心第一次通知的时间，对于目前 Dubbo 的注册中心实现次配置项保留 0 即可） force: 强制切换（对于 FORCE_INTERFACE、FORCE_APPLICATION 是否不考虑决策直接切换，可能导致无地址调用失败问题） interfaces: 接口粒度配置 参考配置示例如下：</description></item><item><title>5-43 - Dubbo 证书签发连接不安全</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/43/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/5/43/</guid><description>可能的原因 Dubbo 与远程 CA 的连接不安全
排查和解决步骤 检查 Dubbo 进程是否已经正确配置了 CA 证书信息以及 OIDC（OpenID Connect）的 Token 获取方式</description></item><item><title>导出线程堆栈</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/dump/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/dump/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
当业务线程池满时，我们需要知道线程都在等待哪些资源、条件，以找到系统的瓶颈点或异常点。dubbo 通过 Jstack 自动导出线程堆栈来保留现场，方便排查问题。
默认策略:
导出路径，user.home标识的用户主目录 导出间隔，最短间隔允许每隔10分钟导出一次 指定导出路径：
# dubbo.properties dubbo.application.dump.directory=/tmp &amp;lt;dubbo:application ...&amp;gt; &amp;lt;dubbo:parameter key=&amp;#34;dump.directory&amp;#34; value=&amp;#34;/tmp&amp;#34; /&amp;gt; &amp;lt;/dubbo:application&amp;gt;</description></item><item><title>导出线程堆栈</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/dump/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/dump/</guid><description>当业务线程池满时，我们需要知道线程都在等待哪些资源、条件，以找到系统的瓶颈点或异常点。dubbo 通过 Jstack 自动导出线程堆栈来保留现场，方便排查问题。
默认策略:
导出路径，user.home标识的用户主目录 导出间隔，最短间隔允许每隔10分钟导出一次 指定导出路径：
# dubbo.properties dubbo.application.dump.directory=/tmp &amp;lt;dubbo:application ...&amp;gt; &amp;lt;dubbo:parameter key=&amp;#34;dump.directory&amp;#34; value=&amp;#34;/tmp&amp;#34; /&amp;gt; &amp;lt;/dubbo:application&amp;gt;</description></item><item><title>Kryo 和 FST 序列化</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/serialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/serialization/</guid><description>启用 Kryo 和 FST 使用 Kryo 和 FST 非常简单，只需要在 dubbo RPC 的 XML 配置中添加一个属性即可：
&amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; serialization=&amp;#34;kryo&amp;#34;/&amp;gt; &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; serialization=&amp;#34;fst&amp;#34;/&amp;gt; 注册被序列化类 要让 Kryo 和 FST 完全发挥出高性能，最好将那些需要被序列化的类注册到 dubbo 系统中，例如，我们可以实现如下回调接口：
public class SerializationOptimizerImpl implements SerializationOptimizer { public Collection&amp;lt;Class&amp;gt; getSerializableClasses() { List&amp;lt;Class&amp;gt; classes = new LinkedList&amp;lt;Class&amp;gt;(); classes.add(BidRequest.class); classes.add(BidResponse.class); classes.add(Device.class); classes.add(Geo.class); classes.add(Impression.class); classes.add(SeatBid.class); return classes; } } 然后在 XML 配置中添加：
&amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; serialization=&amp;#34;kryo&amp;#34; optimizer=&amp;#34;org.apache.dubbo.demo.SerializationOptimizerImpl&amp;#34;/&amp;gt; 在注册这些类后，序列化的性能可能被大大提升，特别针对小数量的嵌套对象的时候。
当然，在对一个类做序列化的时候，可能还级联引用到很多类，比如Java集合类。针对这种情况，我们已经自动将JDK中的常用类进行了注册，所以你不需要重复注册它们（当然你重复注册了也没有任何影响），包括：
GregorianCalendar InvocationHandler BigDecimal BigInteger Pattern BitSet URI UUID HashMap ArrayList LinkedList HashSet TreeSet Hashtable Date Calendar ConcurrentHashMap SimpleDateFormat Vector BitSet StringBuffer StringBuilder Object Object[] String[] byte[] char[] int[] float[] double[] 由于注册被序列化的类仅仅是出于性能优化的目的，所以即使你忘记注册某些类也没有关系。事实上，即使不注册任何类，Kryo和FST的性能依然普遍优于 hessian 和 dubbo 序列化。</description></item><item><title>Netty4 支持</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/netty4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/netty4/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo 2.5.6 版本新增了对 netty4 通信模块的支持，启用方式如下
provider 端：
&amp;lt;dubbo:protocol server=&amp;#34;netty4&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:provider server=&amp;#34;netty4&amp;#34; /&amp;gt; consumer 端：
&amp;lt;dubbo:consumer client=&amp;#34;netty4&amp;#34; /&amp;gt; 注意 provider 端如需不同的协议使用不同的通信层框架，请配置多个 protocol 分别设置 consumer 端请使用如下形式： &amp;lt;dubbo:consumer client=&amp;#34;netty&amp;#34;&amp;gt; &amp;lt;dubbo:reference /&amp;gt; &amp;lt;/dubbo:consumer&amp;gt; &amp;lt;dubbo:consumer client=&amp;#34;netty4&amp;#34;&amp;gt; &amp;lt;dubbo:reference /&amp;gt; &amp;lt;/dubbo:consumer&amp;gt; 接下来我们会继续完善： 性能测试指标及与 netty3 版本的性能测试对比，我们会提供一份参考数据</description></item><item><title>Netty4 支持</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/netty4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/netty4/</guid><description>Dubbo 2.5.6 版本新增了对 netty4 通信模块的支持，启用方式如下
provider 端：
&amp;lt;dubbo:protocol server=&amp;#34;netty4&amp;#34; /&amp;gt; 或
&amp;lt;dubbo:provider server=&amp;#34;netty4&amp;#34; /&amp;gt; consumer 端：
&amp;lt;dubbo:consumer client=&amp;#34;netty4&amp;#34; /&amp;gt; 注意 provider 端如需不同的协议使用不同的通信层框架，请配置多个 protocol 分别设置 consumer 端请使用如下形式： &amp;lt;dubbo:consumer client=&amp;#34;netty&amp;#34;&amp;gt; &amp;lt;dubbo:reference /&amp;gt; &amp;lt;/dubbo:consumer&amp;gt; &amp;lt;dubbo:consumer client=&amp;#34;netty4&amp;#34;&amp;gt; &amp;lt;dubbo:reference /&amp;gt; &amp;lt;/dubbo:consumer&amp;gt; 接下来我们会继续完善： 性能测试指标及与 netty3 版本的性能测试对比，我们会提供一份参考数据</description></item><item><title>Kryo 和 FST 序列化</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/serialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/serialization/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
目录 序列化漫谈 启用Kryo和FST 注册被序列化类 无参构造函数和Serializable接口 序列化性能分析与测试 测试环境 测试脚本 Dubbo RPC中不同序列化生成字节大小比较 Dubbo RPC中不同序列化响应时间和吞吐量对比 未来 序列化漫谈 dubbo RPC是dubbo体系中最核心的一种高性能、高吞吐量的远程调用方式，我喜欢称之为多路复用的TCP长连接调用，简单的说：
长连接：避免了每次调用新建TCP连接，提高了调用的响应速度 多路复用：单个TCP连接可交替传输多个请求和响应的消息，降低了连接的等待闲置时间，从而减少了同样并发数下的网络连接数，提高了系统吞吐量。 dubbo RPC主要用于两个dubbo系统之间作远程调用，特别适合高并发、小数据的互联网场景。
而序列化对于远程调用的响应速度、吞吐量、网络带宽消耗等同样也起着至关重要的作用，是我们提升分布式系统性能的最关键因素之一。
在dubbo RPC中，同时支持多种序列化方式，例如：
dubbo序列化：阿里尚未开发成熟的高效java序列化实现，阿里不建议在生产环境使用它 hessian2序列化：hessian是一种跨语言的高效二进制序列化方式。但这里实际不是原生的hessian2序列化，而是阿里修改过的hessian lite，它是dubbo RPC默认启用的序列化方式 json序列化：目前有两种实现，一种是采用的阿里的fastjson库，另一种是采用dubbo中自己实现的简单json库，但其实现都不是特别成熟，而且json这种文本序列化性能一般不如上面两种二进制序列化。 java序列化：主要是采用JDK自带的Java序列化实现，性能很不理想。 在通常情况下，这四种主要序列化方式的性能从上到下依次递减。对于dubbo RPC这种追求高性能的远程调用方式来说，实际上只有1、2两种高效序列化方式比较般配，而第1个dubbo序列化由于还不成熟，所以实际只剩下2可用，所以dubbo RPC默认采用hessian2序列化。
但hessian是一个比较老的序列化实现了，而且它是跨语言的，所以不是单独针对java进行优化的。而dubbo RPC实际上完全是一种Java to Java的远程调用，其实没有必要采用跨语言的序列化方式（当然肯定也不排斥跨语言的序列化）。
最近几年，各种新的高效序列化方式层出不穷，不断刷新序列化性能的上限，最典型的包括：
专门针对Java语言的：Kryo，FST等等 跨语言的：Protostuff，ProtoBuf，Thrift，Avro，MsgPack等等 这些序列化方式的性能多数都显著优于hessian2（甚至包括尚未成熟的dubbo序列化）。
有鉴于此，我们为dubbo引入Kryo和FST这两种高效Java序列化实现，来逐步取代hessian2。
其中，Kryo是一种非常成熟的序列化实现，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用。而FST是一种较新的序列化实现，目前还缺乏足够多的成熟使用案例，但我认为它还是非常有前途的。
在面向生产环境的应用中，我建议目前更优先选择Kryo。
启用Kryo和FST 使用Kryo和FST非常简单，只需要在dubbo RPC的XML配置中添加一个属性即可：
&amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; serialization=&amp;#34;kryo&amp;#34;/&amp;gt; &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; serialization=&amp;#34;fst&amp;#34;/&amp;gt; 注册被序列化类 要让Kryo和FST完全发挥出高性能，最好将那些需要被序列化的类注册到dubbo系统中，例如，我们可以实现如下回调接口：
public class SerializationOptimizerImpl implements SerializationOptimizer { public Collection&amp;lt;Class&amp;gt; getSerializableClasses() { List&amp;lt;Class&amp;gt; classes = new LinkedList&amp;lt;Class&amp;gt;(); classes.</description></item><item><title>Kryo 和 FST 序列化</title><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/serialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/serialization/</guid><description>目录 序列化漫谈 启用Kryo和FST 注册被序列化类 无参构造函数和Serializable接口 序列化性能分析与测试 测试环境 测试脚本 Dubbo RPC中不同序列化生成字节大小比较 Dubbo RPC中不同序列化响应时间和吞吐量对比 未来 序列化漫谈 dubbo RPC是dubbo体系中最核心的一种高性能、高吞吐量的远程调用方式，我喜欢称之为多路复用的TCP长连接调用，简单的说：
长连接：避免了每次调用新建TCP连接，提高了调用的响应速度 多路复用：单个TCP连接可交替传输多个请求和响应的消息，降低了连接的等待闲置时间，从而减少了同样并发数下的网络连接数，提高了系统吞吐量。 dubbo RPC主要用于两个dubbo系统之间作远程调用，特别适合高并发、小数据的互联网场景。
而序列化对于远程调用的响应速度、吞吐量、网络带宽消耗等同样也起着至关重要的作用，是我们提升分布式系统性能的最关键因素之一。
在dubbo RPC中，同时支持多种序列化方式，例如：
dubbo序列化：阿里尚未开发成熟的高效java序列化实现，阿里不建议在生产环境使用它 hessian2序列化：hessian是一种跨语言的高效二进制序列化方式。但这里实际不是原生的hessian2序列化，而是阿里修改过的hessian lite，它是dubbo RPC默认启用的序列化方式 json序列化：目前有两种实现，一种是采用的阿里的fastjson库，另一种是采用dubbo中自己实现的简单json库，但其实现都不是特别成熟，而且json这种文本序列化性能一般不如上面两种二进制序列化。 java序列化：主要是采用JDK自带的Java序列化实现，性能很不理想。 在通常情况下，这四种主要序列化方式的性能从上到下依次递减。对于dubbo RPC这种追求高性能的远程调用方式来说，实际上只有1、2两种高效序列化方式比较般配，而第1个dubbo序列化由于还不成熟，所以实际只剩下2可用，所以dubbo RPC默认采用hessian2序列化。
但hessian是一个比较老的序列化实现了，而且它是跨语言的，所以不是单独针对java进行优化的。而dubbo RPC实际上完全是一种Java to Java的远程调用，其实没有必要采用跨语言的序列化方式（当然肯定也不排斥跨语言的序列化）。
最近几年，各种新的高效序列化方式层出不穷，不断刷新序列化性能的上限，最典型的包括：
专门针对Java语言的：Kryo，FST等等 跨语言的：Protostuff，ProtoBuf，Thrift，Avro，MsgPack等等 这些序列化方式的性能多数都显著优于hessian2（甚至包括尚未成熟的dubbo序列化）。
有鉴于此，我们为dubbo引入Kryo和FST这两种高效Java序列化实现，来逐步取代hessian2。
其中，Kryo是一种非常成熟的序列化实现，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用。而FST是一种较新的序列化实现，目前还缺乏足够多的成熟使用案例，但我认为它还是非常有前途的。
在面向生产环境的应用中，我建议目前更优先选择Kryo。
启用Kryo和FST 使用Kryo和FST非常简单，只需要在dubbo RPC的XML配置中添加一个属性即可：
&amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; serialization=&amp;#34;kryo&amp;#34;/&amp;gt; &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; serialization=&amp;#34;fst&amp;#34;/&amp;gt; 注册被序列化类 要让Kryo和FST完全发挥出高性能，最好将那些需要被序列化的类注册到dubbo系统中，例如，我们可以实现如下回调接口：
public class SerializationOptimizerImpl implements SerializationOptimizer { public Collection&amp;lt;Class&amp;gt; getSerializableClasses() { List&amp;lt;Class&amp;gt; classes = new LinkedList&amp;lt;Class&amp;gt;(); classes.add(BidRequest.class); classes.</description></item><item><title>Dubbo Java 2.7.14 发版公告</title><link>https://dubbo.apache.org/zh-cn/blog/2020/05/18/dubbo-java-2.7.14-%E5%8F%91%E7%89%88%E5%85%AC%E5%91%8A/</link><pubDate>Mon, 18 May 2020 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2020/05/18/dubbo-java-2.7.14-%E5%8F%91%E7%89%88%E5%85%AC%E5%91%8A/</guid><description>变动项 为 ServiceDiscovery 增加动态配置中心的覆盖规则。（#8389） 修复当 mock 参数中包含 &amp;lsquo;:&amp;rsquo; 或者 &amp;lsquo;=&amp;rsquo; 符号时无法正常使用的问题。（#8379） 修复 zone 参数对 ZoneAwareClusterInvoker 配置无法生效的问题。（#8521） 为序列化白名单检查增加开关，默认为 true。（#8537） 修复当请求超时时序列化检查的空指针异常。（#8587） 修复 NetUtils.ignoreNetworkInterface 无法处理网卡中包含 &amp;lsquo;(&amp;rsquo; 符号的问题。（#8629） 统一获取本地地址的方式。（#8679） 修复当重试参数为0，依旧会重试1次的问题。（#8743） 当清除未使用的 invoker 时，立即关闭客户端。（#8756） 修复 destroy 方法以及 doOverrideIfNecessary 中的异常。（#8683） DefaultFuture.closeChannel 根据日志级别选择是否打印请求的详细数据。（#8778） 使用 MapUtils 替换 AttachmentsAdapter（#8772） Maven依赖变化 netty4: 4.1.51.Final -&amp;gt; 4.1.66.Final netty4_ssl: 2.0.39.Final -&amp;gt; 2.0.40.Final http_client: 4.5.3 -&amp;gt; 4.5.13 jetty: 9.4.11.v20180605 -&amp;gt; 9.4.43.v20210629 apollo_client: 1.1.1 -&amp;gt; 1.8.0 tomcat_embed: 8.5.31-&amp;gt; 9.0.48 commons_io: 2.6 -&amp;gt; 2.7 curator: 5.0.0 -&amp;gt; 5.</description></item><item><title>Admin</title><link>https://dubbo.apache.org/zh-cn/download/admin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/download/admin/</guid><description/></item><item><title>Mesh 路由规则</title><link>https://dubbo.apache.org/zh-cn/overview/what/core-features/traffic/mesh-rule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/what/core-features/traffic/mesh-rule/</guid><description>Dubbo Mesh 路由规则是基于 Istio 的 VirtualService、DestinationRule 改造而来，总体思路和格式可以参考 Istio 流量管控规则参考手册：Istio VirtualService 和 Istio DestinationRule
本文描述了 Dubbo Mesh 路由规则的设计原理，以及它和 Istio 规则的差异等。参考链接：https://www.yuque.com/docs/share/c132d5db-0dcb-487f-8833-7c7732964bd4?#。
基本思想 基于路由链，采用Pipeline的处理方式，如下图所示：
可以把路由链的逻辑简单的理解为 target = rn(&amp;hellip;r3(r2(r1(src))))。对于每一个 router 内部的逻辑，可以抽象为输入地址 addrs-in 与 router 中按全量地址 addrs-all 实现切分好的 n 个互不相交的地址池 addrs-pool-1 &amp;hellip; addrs-pool-n 按实现定义好的规则取交集作为输出 addrs-out。以此类推，完成整个路由链的计算。
另外一方面，如果 router(n) 需要执行 fallback 逻辑的时候，那么需要经过 router(n) 就应该决定好 fallback 逻辑
fallback 处理原则 由于多个 router 之间多个条件组件之后，很容易出现地址被筛选为空的情况，那么我们需要针对这情况进行 fallback 处理，保证业务在正确性的前提下，能够顺利找到有效地址。
首先我们看一下以下规则
apiVersion: service.dubbo.apache.org/v1alpha1 kind: VirtualService metadata: name: demo-route spec: hosts: - demo // 统一定义为应用名 dubbo: - service: - exact: com.</description></item><item><title>安装 Dubbo Admin 及服务治理组件</title><link>https://dubbo.apache.org/zh-cn/overview/reference/setup/install/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/setup/install/</guid><description>Dubboctl 安装 Download 下载 Dubbo Admin 发行版本
curl -L https://dubbo.apache.org/installer.sh | VERSION=0.1.0 sh - # Admin 要组织好发行版本 将 dubboctl 放入可执行路径
ln -s dubbo-admin-0.1.0/bin/dubboctl /usr/local/bin/dubboctl Install 安装过程会依次：
安装 Admin 自定义的一些资源 拉起 Admin、Nacos、Zookeeper 等不同的组件服务 dubboctl install # 使用默认 manifests 安装 # or dubboctl manifests| kubectl apply -f - dubboctl install --set profile=minimal # 指定不同的 profile，即安装组件的组合 dubboctl install --set admin.nacos.enabled=true, admin.nacos.namespace=test # 指定不同的覆盖参数 检查安装效果
kubectl get pod -n dubbo-system 打开 Admin 控制台 kubectl port-forward svc/dubbo-admin -n dubbo-system 38080:38080 打开浏览器，访问： http://127.</description></item><item><title>调用结果缓存</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/result-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/result-cache/</guid><description>功能说明 Dubbo支持了服务端结果缓存和客户端结果缓存。
缓存类型 目前Dubbo3.0版本及高于其的版本都支持以下几种内置的缓存策略：
lru 基于最近最少使用原则删除多余缓存，保持最热的数据被缓存。 lfu基于淘汰使用频次最低的原则来实现缓存策略。 expiring基于过期时间原则来实现缓存策略。 threadlocal 当前线程缓存，比如一个页面渲染，用到很多 portal，每个 portal 都要去查用户信息，通过线程缓存，可以减少这种多余访问。 jcache 与 JSR107 集成，可以桥接各种缓存实现。 缓存类型可扩展 缓存扩展
关于 示例代码
使用场景 结果缓存，用于加速热门数据的访问速度，Dubbo 提供声明式缓存，以减少用户加缓存的工作量。
使用方式 客户端缓存 Dubbo中对RPC调用结果缓存支持接口粒度和方法粒度的配置控制。
接口粒度
xml配置方式：
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.DemoService&amp;#34; cache=&amp;#34;lru&amp;#34; /&amp;gt; 注解配置方式：
@DubboReference(cache = &amp;#34;lru&amp;#34;) private DemoService demoService; 方法粒度
&amp;lt;dubbo:reference interface=&amp;#34;com.foo.DemoService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;sayHello&amp;#34; cache=&amp;#34;lru&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; 注解配置方式：
@DubboReference(methods = {@Method(name=&amp;#34;sayHello&amp;#34;,cache = &amp;#34;lru&amp;#34;)}) private DemoService demoService; 服务端缓存 接口粒度
xml配置方式：
&amp;lt;bean id=&amp;#34;demoService&amp;#34; class=&amp;#34;org.apache.dubbo.demo.provider.DemoServiceImpl&amp;#34;/&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;com.foo.DemoService&amp;#34; ref=&amp;#34;demoService&amp;#34; cache=&amp;#34;lru&amp;#34; /&amp;gt; 注解配置方式：
@DubboService(cache = &amp;#34;lru&amp;#34;) public class DemoServiceImpl implements DemoService { private static final Logger logger = LoggerFactory.</description></item><item><title>动态修改运行态配置项</title><link>https://dubbo.apache.org/zh-cn/docs/examples/configuration-override/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/examples/configuration-override/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。</description></item><item><title>服务引用配置对象缓存</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/reference-config-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/reference-config-cache/</guid><description>功能说明 ReferenceConfig 实例很重，封装了与注册中心的连接以及与提供者的连接，需要缓存。否则重复生成 ReferenceConfig 可能造成性能问题并且会有内存和连接泄漏。在 API 方式编程时，容易忽略此问题。
因此，自 2.4.0 版本开始， dubbo 提供了简单的工具类 ReferenceConfigCache用于缓存 ReferenceConfig 实例。
使用场景 网关等存在动态创建订阅的场景，由于 ReferenceConfig 本身很重，会创建特别多的中间对象，而 proxy 本身是可以复用的，所以通过 ReferenceConfigCache 可以缓存这部分的属性。
使用方式 消除并销毁 消除 Cache 中的 ReferenceConfig，将销毁 ReferenceConfig 并释放对应的资源。
ReferenceConfig&amp;lt;XxxService&amp;gt; reference = new ReferenceConfig&amp;lt;XxxService&amp;gt;(); reference.setInterface(XxxService.class); reference.setVersion(&amp;#34;1.0.0&amp;#34;); ...... ReferenceConfigCache cache = ReferenceConfigCache.getCache(); // cache.get方法中会缓存 Reference对象，并且调用ReferenceConfig.get方法启动ReferenceConfig XxxService xxxService = cache.get(reference); // 注意！ Cache会持有ReferenceConfig，不要在外部再调用ReferenceConfig的destroy方法，导致Cache内的ReferenceConfig失效！ // 使用xxxService对象 xxxService.sayHello(); ReferenceConfigCache cache = ReferenceConfigCache.getCache(); cache.destroy(reference); 缺省 ReferenceConfigCache 把相同服务 Group、接口、版本的 ReferenceConfig 认为是相同，缓存一份。即以服务 Group、接口、版本为缓存的 Key。
修改策略 可以修改这个策略，在 ReferenceConfigCache.</description></item><item><title>路由状态采集</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/router-snapshot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/router-snapshot/</guid><description>功能说明 路由状态收集功能可用于识别可能影响服务性能的任何潜在问题，识别可能阻碍服务尽可能高效使用的任何潜在瓶颈或问题，确保服务平稳运行，用户在尝试访问服务时不会遇到任何问题，允许用户检查路由的状态是启用还是禁用，确保仅使用授权的服务，并且访问仅限于具有适当授权的人员。
使用场景 Dubbo 的很多流量治理能力是基于 Router 进行实现的，在生产环境中，如果出现流量结果不符合预期的情况，可以通过路由状态命令来查看路由的状态，以此来定位可能存在的问题。
使用方式 查看路由缓存状态 Dubbo 在收到地址变更的时候，会将地址信息推送给所有的 Router，这些 Router 可以在此阶段提前计算路由的分组，缓存起来，以避免在调用时需要遍历所有的提供者计算分组参数。 在 Dubbo 3 中引入的 StateRouter 提供了通过 qos 命令工具实时获取每个路由的状态的能力。
运维人员可以通过 getRouterSnapshot 命令获取路由的状态。具体命令使用方式可以参考 getRouterSnapshot 命令 文档。
注：此功能仅支持 StateRoute，且 StateRouter 需要基于 AbstractStateRouter 实现 doBuildSnapshot 接口。
查看实际请求的路由计算结果 Dubbo 3 中默认在路由筛选后为空的时候打印路由计算的节点状态。运维人员可以通过日志判断每个路由的计算结果是否符合预期。
日志格式 No provider available after route for the service 服务 from registry 注册中心地址 on the consumer 消费端IP using the dubbo version 3.0.7. Router snapshot is below: [ Parent (Input: 当前节点输入地址数) (Current Node Output: 当前节点计算结果数) (Chain Node Output: 当前节点和后级节点交集结果数) ] Input: 输入的地址示例（显示最多 5 个） -&amp;gt; Chain Node Output: 当前节点输出的地址示例（显示最多 5 个） [ 路由名称 (Input: 当前节点输入地址数) (Current Node Output: 当前节点计算结果数) (Chain Node Output: 当前节点和后级节点交集结果数) Router message: 路由日志 ] Current Node Output: 当前节点输出的地址示例（显示最多 5 个） [ 路由名称 (Input: 当前节点输入地址数) (Current Node Output: 当前节点计算结果数) (Chain Node Output: 当前节点和后级节点交集结果数) Router message: 路由日志 ] Current Node Output: 当前输入的地址示例（显示最多 5 个） 注意： 路由日志需要依赖路由实现判断 needToPrintMessage 参数，并在需要时写入 messageHolder 路由日志 由于多级路由结果是结果取交集的，所以当前节点计算结果数可能和后级取交后为空 日志示例 [19/07/22 07:42:46:046 CST] main WARN cluster.</description></item><item><title>属性配置</title><link>https://dubbo.apache.org/zh-cn/docs/references/configuration/properties/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/configuration/properties/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo属性配置有两个职责：
定义配置：根据属性创建配置组件实例，类似SpringBoot的@ConfigurationProperties的作用。 属性覆盖：覆盖已存在的配置组件实例的属性值，类似Spring PropertyOverrideConfigurer 的作用。 一个属性配置的例子 dubbo-spring-boot-samples
## application.properties # Spring boot application spring.application.name=dubbo-externalized-configuration-provider-sample # Base packages to scan Dubbo Component: @com.alibaba.dubbo.config.annotation.Service dubbo.scan.base-packages=com.alibaba.boot.dubbo.demo.provider.service # Dubbo Application ## The default value of dubbo.application.name is ${spring.application.name} ## dubbo.application.name=${spring.application.name} # Dubbo Protocol dubbo.protocol.name=dubbo dubbo.protocol.port=12345 ## Dubbo Registry dubbo.registry.address=N/A ## service default version dubbo.provider.version=1.0.0 配置来源 从Dubbo支持的配置来源说起，默认有6种配置来源：
JVM System Properties，JVM -D 参数 System environment，JVM进程的环境变量 Externalized Configuration，外部化配置，从配置中心读取 Application Configuration，应用的属性配置，从Spring应用的Environment中提取&amp;quot;dubbo&amp;quot;打头的属性集 API / XML /注解等编程接口采集的配置可以被理解成配置来源的一种，是直接面向用户编程的配置采集方式 从classpath读取配置文件 dubbo.</description></item><item><title>Dubbo Go 1.5.1</title><link>https://dubbo.apache.org/zh-cn/blog/1/01/01/dubbo-go-1.5.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/1/01/01/dubbo-go-1.5.1/</guid><description>近期我们发布了 dubbo-go v1.5.1，虽然是 v1.5 的一个子版本，但相比于 v1.5.0， 社区还是投入了很大人力添加了如下重大改进。
1 应用维度注册模型 在新模型 release 后，我们发现 Provider 每个 URL 发布元数据都会注册 ServiceInstance，影响性能需要优化。
我们的优化方案是：
去除 ServiceDiscoveryRegistry 中注册 ServiceInstance 的代码，在 config_loader 中的loadProviderConfig 方法的最后注册 ServiceInstance
具体步骤：
获取所有注册的 Registry，过滤出 ServiceDiscoveryRegistry，拿取所有 ServiceDiscovery。 创建 ServiceInstance。 每个 ServiceDiscovery 注册 ServiceInstance。 保证 Provider 在注册成功之后，才暴露元数据信息。
2 支持基于 Seata 的事务 基于 Seata 扩展实现。通过增加过滤器，在服务端接收 xid 并结合 seata-golang 达到支持分布式事务的目的。 从而使 Dubbo-go 在分布式场景下，让用户有更多的选择，能适应更多的个性化场景。
我们在 dubbo-samples 中给出了 事务测试用例 。
3 多注册中心集群负载均衡 对于多注册中心订阅的场景，选址时的多了一层注册中心集群间的负载均衡：
在 Cluster Invoker 这一级，我们支持的选址策略有：
指定优先级 同 zone 优先 权重轮询 4 传输链路安全性 该版本在传输链路的安全性上做了尝试，对于内置的 Dubbo getty Server 提供了基于 TLS 的安全链路传输机制。</description></item><item><title>SPI Extensions</title><link>https://dubbo.apache.org/zh-cn/download/spi-extensions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/download/spi-extensions/</guid><description>验证 可以按照这里的步骤, 利用KEYS文件来验证下载。
GitHub: https://github.com/apache/dubbo-spi-extensions 发布说明: https://github.com/apache/dubbo-spi-extensions/releases
Dubbo SPI Extensions 1.0.3 (2022-11-28) Source Release source | asc | sha512 Maven Release &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo.extensions&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;${component_name}&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${component_version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; Included Components dubbo-cluster-extensions dubbo-cluster-broadcast-1:1.0.1 dubbo-cluster-loadbalance-peakewma:1.0.1 dubbo-cluster-specify-address-dubbo3:1.0.1 dubbo-cluster-specify-address-dubbo2:1.0.1 dubbo-filter-extensions dubbo-filter-seata:1.0.1 dubbo-configcenter-extensions dubbo-configcenter-consul:1.0.1 dubbo-configcenter-etcd:1.0.1 dubbo-metadata-report-extensions dubbo-metadata-report-consul:1.0.1 dubbo-remoting-extensions dubbo-remoting-etcd3:1.0.1 dubbo-metadata-report-etcd:1.0.1 dubbo-remoting-quic:1.0.1 dubbo-remoting-grizzly:1.0.1 dubbo-remoting-mina:1.0.1 dubbo-remoting-p2p:1.0.1 dubbo-registry-extensions dubbo-registry-dns:1.0.1 dubbo-registry-consul:1.0.1 dubbo-registry-etcd3:1.0.1 dubbo-remoting-redis:1.0.1 dubbo-registry-redis:1.0.1 dubbo-registry-sofa:1.0.1 dubbo-registry-nameservice:1.0.0 dubbo-rpc-extensions dubbo-rpc-native-thrift:1.0.1 dubbo-rpc-http:1.0.1 dubbo-rpc-webservice:1.0.1 dubbo-rpc-rmi:1.0.1 dubbo-rpc-hessian:1.0.1 dubbo-rpc-memcached:1.0.1 dubbo-rpc-redis:1.0.1 dubbo-rpc-rocketmq:1.0.0 dubbo-serialization-extensions dubbo-serialization-native-hessian:1.0.1 dubbo-serialization-protostuff dubbo-serialization-protobuf:1.0.1 dubbo-serialization-kryo:1.0.1 dubbo-serialization-gson:1.0.1 dubbo-serialization-fst:1.</description></item><item><title>外部化配置</title><link>https://dubbo.apache.org/zh-cn/docs/references/configuration/external-config/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/configuration/external-config/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
外部化配置 外部化配置目的之一是实现配置的集中式管理，这部分业界已经有很多成熟的专业配置系统如 Apollo, Nacos 等，Dubbo 所做的主要是保证能配合这些系统正常工作。
外部化配置和其他本地配置在内容和格式上并无区别，可以简单理解为 dubbo.properties 的外部化存储，配置中心更适合将一些公共配置如注册中心、元数据中心配置等抽取以便做集中管理。
# 将注册中心地址、元数据中心地址等配置集中管理，可以做到统一环境、减少开发侧感知。 dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.registry.simplified=true dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 dubbo.protocol.name=dubbo dubbo.protocol.port=20880 dubbo.application.qos.port=33333 优先级
外部化配置默认较本地配置有更高的优先级，因此这里配置的内容会覆盖本地配置值，关于 各配置形式间的覆盖关系 有单独一章说明。
作用域
外部化配置有全局和应用两个级别，全局配置是所有应用共享的，应用级配置是由每个应用自己维护且只对自身可见的。当前已支持的扩展实现有Zookeeper、Apollo、Nacos。
配置中心 从配置中心读取外部化配置，可以按照下面的方法指定配置中心：
&amp;lt;dubbo:config-center address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; 或者
dubbo.config-center.address=zookeeper://127.0.0.1:2181 或者
ConfigCenterConfig configCenter = new ConfigCenterConfig(); configCenter.setAddress(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;); Zookeeper &amp;lt;dubbo:config-center address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; 默认所有的配置都存储在 /dubbo/config 节点，具体节点结构图如下：
namespace，用于不同配置的环境隔离。 config，Dubbo约定的固定节点，不可更改，所有配置和服务治理规则都存储在此节点下。 dubbo/application，分别用来隔离全局配置、应用级别配置：dubbo是默认group值，application对应应用名 dubbo.properties，此节点的node value存储具体配置内容 Apollo &amp;lt;dubbo:config-center protocol=&amp;#34;apollo&amp;#34; address=&amp;#34;127.0.0.1:2181&amp;#34;/&amp;gt; Apollo中的一个核心概念是命名空间 - namespace（和上面zookeeper的namespace概念不同），在这里全局和应用级别配置就是通过命名空间来区分的。
默认情况下，Dubbo会从名叫dubbo（由于 Apollo 不支持特殊后缀 .properties ）的命名空间中读取全局配置（&amp;lt;dubbo:config-center namespace=&amp;quot;your namespace&amp;quot;&amp;gt;）
由于 Apollo 也默认将会在 dubbo namespace 中存储服务治理规则（如路由规则），建议通过单独配置 group 将服务治理和配置文件托管分离开，以 XML 配置方式为例：</description></item><item><title>Dubbo Go Hessian2 v1.7.0</title><link>https://dubbo.apache.org/zh-cn/blog/1/01/01/dubbo-go-hessian2-v1.7.0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/1/01/01/dubbo-go-hessian2-v1.7.0/</guid><description>Dubbo-go-hessian2 v1.7.0已发布，详见 https://github.com/apache/dubbo-go-hessian2/releases/tag/v1.7.0， 以下对这次更新内容进行详细整理。
另外v1.6.3 将 attachment 类型由 map[string]stiring 改为map[string]interface{} 导致版本不兼容问题，这部分已还原，后续的计划是将dubbo协议的request/response对象整体迁移到dubbogo项目中进行迭代修改， hessian2中将不再改动到request/response对象。
1. New Features 1.1 add GetStackTrace method into Throwabler and its implements. #207 go语言client请求java语言服务时，如果java语言抛出了异常，异常对应的堆栈信息是被保存在StackTraceElement中。
这个异常信息在日志中最好能被打印出来，以方便客户端排查问题，所以在Throwabler和对应子类中增加了StackTraceElement的获取。
注：其实还有一种更好的方法，所有的具体的异常类型都包含java_exception/exception.go的Throwable struct。这样只需要在Throwable中增加GetStackTrace方法就可以了。但是这种方式需要更多的测试验证，改动的逻辑相对会复杂一些。但是代码会更整洁。 这里先不用这种方法。
1.2 catch user defined exceptions. #208 golang中增加一个java中Exception对象的序列化输出方法：
func JavaException() []byte { e := hessian.NewEncoder() exception := java_exception.NewException(&amp;#34;java_exception&amp;#34;) e.Encode(exception) return e.Buffer() } 在output/output.go 提供调用入口:添加如下函数初始化声明
func init() { funcMap[&amp;#34;JavaException&amp;#34;] = testfuncs.JavaException } java代码中增加调用go方法序列化结果:
说明: Assert.assertEquals 不能直接比较Exception对象是否相等
/** * test java java.lang.Exception object and go java_exception Exception struct */ @Test public void testException() { Exception exception = new Exception(&amp;#34;java_exception&amp;#34;); Object javaException = GoTestUtil.</description></item><item><title>Pixiu</title><link>https://dubbo.apache.org/zh-cn/download/pixiu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/download/pixiu/</guid><description/></item><item><title>自动加载环境变量</title><link>https://dubbo.apache.org/zh-cn/docs/references/configuration/environment-variables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/configuration/environment-variables/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
从 2.7.3 版本开始，Dubbo 会自动从约定 key 中读取配置，并将配置以 Key-Value 的形式写入到URL中。
支持的 key 有以下两个：
dubbo.labels，指定一些列配置到 URL 中的键值对，通常通过 JVM -D 或系统环境变量指定。
增加以下配置：
# JVM -Ddubbo.labels = &amp;#34;tag1=value1; tag2=value2&amp;#34; # 环境变量 DUBBO_LABELS = &amp;#34;tag1=value1; tag2=value2&amp;#34; 最终生成的 URL 会包含 tag1、tag2 两个 key: dubbo://xxx?tag1=value1&amp;amp;tag2=value2
dubbo.env.keys，指定环境变量 key 值，Dubbo 会尝试从环境变量加载每个 key
# JVM -Ddubbo.env.keys = &amp;#34;DUBBO_TAG1, DUBBO_TAG2&amp;#34; # 环境变量 DUBBO_ENV_KEYS = &amp;#34;DUBBO_TAG1, DUBBO_TAG2&amp;#34; 最终生成的 URL 会包含 DUBBO_TAG1、DUBBO_TAG2 两个 key: dubbo://xxx?DUBBO_TAG1=value1&amp;amp;DUBBO_TAG2=value2</description></item><item><title>Log4j 漏洞影响</title><link>https://dubbo.apache.org/zh-cn/overview/notices/log4j/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/notices/log4j/</guid><description>最近，主流日志组件 log4j2 爆出安全漏洞 CVE-2021-44228。
以下是漏洞 CVE-2021-44228 对 Apache Dubbo 框架的影响总结及用户应对指南。
Dubbo 影响范围 该漏洞对 Dubbo 框架使用安全并无影响。
Dubbo 本身不强依赖 log4j2 框架，也不会通过依赖传递将 log4j2 带到业务工程中去，因此，正在使用 Dubbo 2.7.x、3.0.x 等版本的用户均无需强制升级 Dubbo 版本。
以下是 Dubbo 各组件对 log4j2 的依赖分析，涉及 dubbo-common、dubbo-spring-boot-starter、dubbo-spring-boot-actuator：
dubbo-common 包含对 log4j-core 的可选依赖，请检查项目自身是否启用了 log4j 依赖，如启用则对应升级即可。 [INFO] --- maven-dependency-plugin:3.1.2:tree (default-cli) @ dubbo-common --- [INFO] org.apache.dubbo:dubbo-common:jar:2.7.14-SNAPSHOT [INFO] +- org.apache.logging.log4j:log4j-api:jar:2.11.1:provided [INFO] \- org.apache.logging.log4j:log4j-core:jar:2.11.1:provided dubbo-spring-boot-starter 通过 spring-boot 组件传递了 log4j-api 依赖，log4j-api 本身并无安全问题，升级 log4j-core 组件时注意与 log4j-api 的兼容性 [INFO] --- maven-dependency-plugin:3.1.2:tree (default-cli) @ dubbo-spring-boot-starter --- [INFO] org.</description></item><item><title>0-99 - 调用了过时 (Deprecated) 的方法</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/0/99/</guid><description>可能的原因 用户调用了过时 (Deprecated) 的方法。
排查和解决步骤 检查用户代码有没有调用了什么在目前所用的版本声明为 @Deprecated 的方法，如果有则按照其对应方法替代，如无则忽略即可。</description></item><item><title>Protobuf与Interface对比</title><link>https://dubbo.apache.org/zh-cn/docs/advanced/protobufinterface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/advanced/protobufinterface/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Protobuf与Interface这2种IDL的差异 1. 数据类型 1.1. 基本类型 ptoto类型 java类型 double double float float int32 int int64 long uint32 int[注] uint64 long[注] sint32 int sint64 long fixed32 int[注] fixed64 long[注] sfixed32 int sfixed64 long bool boolean string String bytes ByteString [注]在Java中，无符号的32位和64位整数使用它们的有符号对数来表示，顶部位只存储在符号位中。
1.2. 复合类型 1.2.1. 枚举 原始pb代码 enum TrafficLightColor { TRAFFIC_LIGHT_COLOR_INVALID = 0; TRAFFIC_LIGHT_COLOR_UNSET = 1; TRAFFIC_LIGHT_COLOR_GREEN = 2; TRAFFIC_LIGHT_COLOR_YELLOW = 3; TRAFFIC_LIGHT_COLOR_RED = 4; } 生成的java代码 枚举是常量，因此采用大写
1.2.2. 数组 原始pb代码 message VipIDToRidReq { repeated uint32 vipID = 1; } 生成的java代码 底层实际上是1个ArrayList</description></item><item><title>参数校验</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/parameter-validation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/parameter-validation/</guid><description>特性说明 参数验证功能是基于 JSR303 实现的，用户只需标识 JSR303 标准的验证 annotation，并通过声明 filter 来实现验证。
Maven 依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.validation&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;validation-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0.GA&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hibernate-validator&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.2.0.Final&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 使用场景 服务端在向外提供接口服务时，解决各种接口参数校验问题。
参考用例 https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-validation
使用方式 参数标注示例 import java.io.Serializable; import java.util.Date; import javax.validation.constraints.Future; import javax.validation.constraints.Max; import javax.validation.constraints.Min; import javax.validation.constraints.NotNull; import javax.validation.constraints.Past; import javax.validation.constraints.Pattern; import javax.validation.constraints.Size; public class ValidationParameter implements Serializable { private static final long serialVersionUID = 7158911668568000392L; @NotNull // 不允许为空 @Size(min = 1, max = 20) // 长度或大小范围 private String name; @NotNull(groups = ValidationService.</description></item><item><title>多注册中心</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/service-discovery/multi_registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/service-discovery/multi_registry/</guid><description>一个 Dubbo 应用可以配置的多个接口维度的注册中心，多注册中心可用于集群隔离、迁移等多种场景，关于这部分更详细的说明可参考 Dubbo Java 多注册中心说明。
API配置方式 ins, _ := dubbo.NewInstance( dubbo.WithRegistry( registryWithID(&amp;#34;nacos&amp;#34;), registry.WithNacos(), registry.WithAddress(&amp;#34;127.0.0.1:8848&amp;#34;), ), dubbo.WithRegistry( registryWithID(&amp;#34;zookeeper&amp;#34;), registry.WithZookeeper(), registry.WithAddress(&amp;#34;127.0.0.1:2181&amp;#34;), ), ) 指定某个 server 下的服务注册到哪个注册中心：
// 指定 server 下的服务注册到 zookeeper 注册中心 srv, _ := ins.NewServer(server.WithServerRegistryIDs([]string{&amp;#34;zookeeper&amp;#34;})) // 指定 server 下的服务注册到 nacos 注册中心 srv2, _ := ins.NewServer(server.WithServerRegistryIDs([]string{&amp;#34;nacos&amp;#34;})) 指定某个特定服务注册到哪个注册中心：
srv, _ := ins.NewServer() greet.RegisterGreetServiceHandler(srv, &amp;amp;GreetTripleServer{}, server.WithRegistryIDs([]string{&amp;#34;zookeeper&amp;#34;})) 以上使用方式对 client 侧类似。
YAML配置方式 修改服务端配置 go-server/conf/dubbogo.yaml， 同时将服务注册在两个注册中心上。
dubbo: registries: zookeeper: # 指定 zookeeper 注册中心 protocol: zookeeper address: 127.</description></item><item><title>服务鉴权</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/auth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/auth/</guid><description>特性说明 类似支付之类的对安全性敏感的业务可能会有限制匿名调用的需求。在加固安全性方面，2.7.5 引入了基于 AK/SK 机制的认证鉴权机制，并且引入了鉴权服务中心，主要原理是消费端在请求需要鉴权的服务时，会通过 SK、请求元数据、时间戳、参数等信息来生成对应的请求签名，通过 Dubbo 的 Attahcment 机制携带到对端进行验签，验签通过才进行业务逻辑处理。如下图所示：
使用场景 部署新服务时，使用身份验证来确保只部署正确的服务,如果部署了未经授权的服务，则使用身份验证来拒绝访问并防止使用未经授权服务。
使用方式 接入方式 使用者需要在微服务站点上填写自己的应用信息，并为该应用生成唯一的证书凭证。
之后在管理站点上提交工单，申请某个敏感业务服务的使用权限，并由对应业务管理者进行审批，审批通过之后，会生成对应的 AK/SK 到鉴权服务中心。
导入该证书到对应的应用下，并且进行配置。配置方式也十分简单，以注解方式为例：
服务提供端 只需要设置 service.auth 为 true，表示该服务的调用需要鉴权认证通过。param.sign 为 true 表示需要对参数也进行校验。
@Service(parameters = {&amp;#34;service.auth&amp;#34;,&amp;#34;true&amp;#34;,&amp;#34;param.sign&amp;#34;,&amp;#34;true&amp;#34;}) public class AuthDemoServiceImpl implements AuthService { } 服务消费端 只需要配置好对应的证书等信息即可，之后会自动地在对这些需要认证的接口发起调用前进行签名操作，通过与鉴权服务的交互，用户无需在代码中配置 AK/SK 这些敏感信息，并且在不重启应用的情况下刷新 AK/SK，达到权限动态下发的目的。
该方案目前已经提交给 Dubbo 开源社区，并且完成了基本框架的合并，除了 AK/SK 的鉴权方式之外，通过 SPI 机制支持用户可定制化的鉴权认证以及适配公司内部基础设施的密钥存储。</description></item><item><title>Dubbo 3 中的三层配置隔离</title><link>https://dubbo.apache.org/zh-cn/blog/1/01/01/dubbo-3-%E4%B8%AD%E7%9A%84%E4%B8%89%E5%B1%82%E9%85%8D%E7%BD%AE%E9%9A%94%E7%A6%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/1/01/01/dubbo-3-%E4%B8%AD%E7%9A%84%E4%B8%89%E5%B1%82%E9%85%8D%E7%BD%AE%E9%9A%94%E7%A6%BB/</guid><description>Models提供的隔离 Dubbo目前提供了三个级别上的隔离：JVM级别、应用级别、服务(模块)级别，从而实现各个级别上的生命周期及配置信息的单独管理。这三个层次上的隔离由 FrameworkModel、ApplicationModel 和 ModuleModel 及它们对应的 Config 来完成。
FrameworkModel ：Dubbo 框架的顶级模型，表示 Dubbo 框架的全局运行环境，适配多应用混合部署的场景，降低资源成本。
如：假设我们有一个在线教育平台，平台下有多个租户，而我们希望使这些租户的服务部署在同一个 JVM 上以节省资源，但它们之间可能使用不同的注册中心、监控设施、协议等，因此我们可以为每个租户分配一个 FrameWorkModel 实例来实现这种隔离。
FrameworkModel负责管理整个Dubbo框架的各种全局配置、元数据以及默认配置。
ApplicationModel ：应用程序级别模型，表示一个 Dubbo 应用（通常为一个 SpringApplication）。适配单JVM多应用场景，通常结合热发布使用，降低热发布对整个应用的影响范围。
如，以上的在线教育平台有多个子系统，如课程管理、学生管理，而每个子系统都是独立的 Spring 应用，在同个 JVM 中运行，共享一个 FrameworkModel，也会共享 Framework 级别的默认配置和资源：
//课程管理应用 @SpringBootApplication public class ClassApplication { private static ApplicationModel classAppModel; public static void main(String[] args) { classAppModel .getApplicationConfigManager() .addRegistry(new RegistryConfig(REGISTRY_URL_CLASS)); //...其它设置 SpringApplication.run(ClassApplication.class, args); } public static void setApplicationModel(ApplicationModel classAppModel){ this.classAppModel = classAppModel; } } //学生管理应用 @SpringBootApplication public class StudentApplication { private static ApplicationModel studentAppModel; public static void main(String[] args) { studentAppModel .</description></item><item><title>响应式编程</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/reactive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/framework/more/reactive/</guid><description>过时风险提醒 请注意，本文档描述的 Reactive 响应式使用方法可能存在过时的情况，请随时参考 apache/dubbo-samples 中的最新 reactive 示例了解用法。 特性说明 此特性基于 Triple 协议和 Project Reactor 实现，3.1.0 版本以上支持。用户仅需编写 IDL 文件，并指定 protobuf 插件的相应 Generator，即可生成并使用支持响应式API的 Stub 代码。
有四种调用模式，分别是 OneToOne、OneToMany、ManyToOne、ManyToMany，分别对应 Unary调用、服务端流、客户端流、双向流。在 Reactor 的实现中，One 对应 Mono，Many 对应 Flux。
Reactive Stream 提供了一套标准的异步流处理 API， 在能够让应用写出事件驱动的程序的同时，也通过 BackPressure 的方式保证了节点的稳定。Triple 协议在通信协议层面为 Dubbo 框架增加了流式场景的支持，在此基础上能够实现上层包括大文件传输和推送机制的业务需求。
Dubbo + Reactive Stream Stub 的组合模式可以给用户带来最方便的流式使用方式以及全链路异步性能提升。
参考用例 https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-triple-reactor
使用场景 系统需要处理大量并发请求而不会使任何服务器过载。大量用户提供实时数据的系统，希望确保系统能够处理负载而不会崩溃或变慢。
使用方式 Triple 使用及配置可参考 IDL 方式使用 Triple，并确保 Dubbo 版本 &amp;gt;= 3.1.0。
添加必要的依赖 若要使用 Reactor Triple，需要额外添加如下依赖。
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.reactivestreams&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;reactive-streams&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.</description></item><item><title>如果从接口级服务发现平滑迁移到应用级服务发现</title><link>https://dubbo.apache.org/zh-cn/blog/2024/05/13/%E5%A6%82%E6%9E%9C%E4%BB%8E%E6%8E%A5%E5%8F%A3%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%B9%B3%E6%BB%91%E8%BF%81%E7%A7%BB%E5%88%B0%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</link><pubDate>Mon, 13 May 2024 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2024/05/13/%E5%A6%82%E6%9E%9C%E4%BB%8E%E6%8E%A5%E5%8F%A3%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%B9%B3%E6%BB%91%E8%BF%81%E7%A7%BB%E5%88%B0%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</guid><description>总体上来说，在地址注册与发现环节，3.x 是完全兼容 2.x 版本的，这意味着，用户可以选择将集群内任意数量的应用或机器升级到 3.x，同时在这个过程中保持与 2.x 版本的互操作性。
如关心迁移背后工作原理，请参考 迁移规则详情与工作原理
1 快速升级步骤 简单的修改 pom.xml 到最新版本就可以完成升级，如果要迁移到应用级地址，只需要调整开关控制 3.x 版本的默认行为。
升级 Provider 应用到最新 3.x 版本依赖，配置双注册开关dubbo.application.register-mode=all（建议通过全局配置中心设置，默认已自动开启），完成应用发布。 升级 Consumer 应用到最新 3.x 版本依赖，配置双订阅开关dubbo.application.service-discovery.migration=APPLICATION_FIRST（建议通过全局配置中心设置，默认已自动开启），完成应用发布。 在确认 Provider 的上有 Consumer 全部完成应用级地址迁移后，Provider 切到应用级地址单注册。完成升级 以下是关于迁移流程的详细描述。
2 Provider 端升级过程详解 在不改变任何 Dubbo 配置的情况下，可以将一个应用或实例升级到 3.x 版本，升级后的 Dubbo 实例会默保保证与 2.x 版本的兼容性，即会正常注册 2.x 格式的地址到注册中心，因此升级后的实例仍会对整个集群仍保持可见状态。
同时新的地址发现模型（注册应用级别的地址）也将会自动注册。
全局开关 应用配置（可以通过配置文件或者 -D 指定）dubbo.application.register-mode 为 instance（只注册应用级）、all（接口级+应用级均注册）开启全局的注册开关，配置此开关后，默认会向所有的注册中心中注册应用级的地址，供消费端服务发现使用。
# 双注册 dubbo.application.register-mode=all # 仅应用级注册 dubbo.application.register-mode=instance 通过 -D 参数，可以指定 provider 启动时的注册行为
-Ddubbo.application.register-mode=all # 可选值 interface、instance、all，默认是 all，即接口级地址、应用级地址都注册 另外，可以在配置中心修改全局默认行为，来控制所有 3.</description></item><item><title>使用 Apache APISIX 代理 Dubbo 服务 (dubbo 协议)</title><link>https://dubbo.apache.org/zh-cn/blog/2024/04/25/%E4%BD%BF%E7%94%A8-apache-apisix-%E4%BB%A3%E7%90%86-dubbo-%E6%9C%8D%E5%8A%A1-dubbo-%E5%8D%8F%E8%AE%AE/</link><pubDate>Thu, 25 Apr 2024 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2024/04/25/%E4%BD%BF%E7%94%A8-apache-apisix-%E4%BB%A3%E7%90%86-dubbo-%E6%9C%8D%E5%8A%A1-dubbo-%E5%8D%8F%E8%AE%AE/</guid><description>注意 本文仅适用于 dubbo 协议通信场景。如果您是 Dubbo3 用户，建议您使用 triple 协议，可参见 使用 Apache APISIX 代理 Dubbo 服务（triple协议） 学习具体示例。 Apache APISIX 是 Apache 软件基金会的顶级开源项目，也是当前最活跃的开源网关项目。作为一个动态、实时、高性能的开源 API 网关，Apache APISIX 提供了负载均衡、动态上游、灰度发布、服务熔断、身份认证、可观测性等丰富的流量管理功能。
Apache APISIX 基于开源项目 tengine/mod_dubbo 模块为 Apache Dubbo 服务配备了HTTP 网关能力。通过 dubbo-proxy 插件，可以轻松地将 Dubbo Service 发布为 HTTP 服务。
入门篇 安装 APISIX 本文档使用 Docker 安装 APISIX。确保本地先安装 Docker 和 Docker Compose。
首先，下载 apisix-docker 仓库。
$ git clone https://github.com/apache/apisix-docker.git $ cd apisix-docker/example 由于本示例要接入到 Nacos 注册中心，因此 apisix-docker/example 目录下安装用的 docker-compose.yaml，添加如下内容：
nacos: image: nacos/nacos-server:v2.</description></item><item><title>如何通过 Higress 网关代理 Dubbo 服务</title><link>https://dubbo.apache.org/zh-cn/blog/2024/04/01/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-higress-%E7%BD%91%E5%85%B3%E4%BB%A3%E7%90%86-dubbo-%E6%9C%8D%E5%8A%A1/</link><pubDate>Mon, 01 Apr 2024 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2024/04/01/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-higress-%E7%BD%91%E5%85%B3%E4%BB%A3%E7%90%86-dubbo-%E6%9C%8D%E5%8A%A1/</guid><description>注意 本文仅适用于 dubbo 协议通信场景。如果您是 Dubbo3 用户，建议您使用 triple 协议，具体可参见 使用 Apache APISIX 代理 Dubbo 服务（triple协议） 学习具体示例。 Higress提供了从HTTP协议到Dubbo协议进行转换的功能，用户通过配置协议转换，可以将一个Dubbo服务以HTTP接口暴露出来，从而用HTTP请求实现对Dubbo接口的调用。本文将通过一个示例来介绍如何用Higress配置HTTP到Dubbo的协议转换。该示例会引导您轻松地部署一个Nacos server和一个Dubbo服务，然后通过Ingress将HTTP请求转发到注册在Nacos上的Dubbo服务，并通过Higress的协议转换能力完成对Dubbo服务的HTTP调用。
以下是一个使用 Higress + dubbo协议 + Nacos注册中心 的完整示例：dubbo-samples-gateway-higress-dubbo。
前提条件 已安装Higress，并开启了对Istio CRD的支持，参考Higress安装部署文档。 部署Nacos和Dubbo服务 首先在K8s集群中apply以下资源，以部署一个Nacos注册中心，同时通过K8s service将这个Nacos server暴露出来。
# Nacos Server配置 apiVersion: apps/v1 kind: Deployment metadata: name: nacos-server spec: replicas: 1 selector: matchLabels: app: nacos-server template: metadata: labels: app: nacos-server spec: containers: - env: - name: MODE value: standalone image: nacos/nacos-server:v2.2.0 imagePullPolicy: Always name: nacos-server ports: - containerPort: 8848 name: server dnsPolicy: ClusterFirst restartPolicy: Always # Nacos Server Service配置 --- apiVersion: v1 kind: Service metadata: name: nacos-server spec: ports: - port: 8848 name: server protocol: TCP targetPort: 8848 selector: app: nacos-server type: ClusterIP 在 K8s 集群中 apply 以下资源，以部署一个Dubbo服务，该 Dubbo 服务将注册到上述的 Naocs 中（你可以选择重新打包，我们接下来直接使用社区提前准备好的镜像包）。</description></item><item><title>Apache Dubbo 下一代云原生微服务挑战赛启动报名！五大赛题50万奖金池等你来战</title><link>https://dubbo.apache.org/zh-cn/blog/2024/01/18/apache-dubbo-%E4%B8%8B%E4%B8%80%E4%BB%A3%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8C%91%E6%88%98%E8%B5%9B%E5%90%AF%E5%8A%A8%E6%8A%A5%E5%90%8D%E4%BA%94%E5%A4%A7%E8%B5%9B%E9%A2%9850%E4%B8%87%E5%A5%96%E9%87%91%E6%B1%A0%E7%AD%89%E4%BD%A0%E6%9D%A5%E6%88%98/</link><pubDate>Thu, 18 Jan 2024 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2024/01/18/apache-dubbo-%E4%B8%8B%E4%B8%80%E4%BB%A3%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8C%91%E6%88%98%E8%B5%9B%E5%90%AF%E5%8A%A8%E6%8A%A5%E5%90%8D%E4%BA%94%E5%A4%A7%E8%B5%9B%E9%A2%9850%E4%B8%87%E5%A5%96%E9%87%91%E6%B1%A0%E7%AD%89%E4%BD%A0%E6%9D%A5%E6%88%98/</guid><description>本文带来本赛题详细解读，开放原子开源基金会官方报名渠道 及更多详情请查看文章最后链接与二维码。
赛题解读 我们期待参赛团队在高性能 Triple(HTTP/3) 协议设计、完善的 Benchmark 验收体系、零信任解决方案、Service Mesh架构 等方向持续探索，共同定义下一代云原生微服务体系，为开源社区和企业用户在性能、安全等方面带来收益。
本赛事一共包含五道赛题：
基于 HTTP/3 的高性能传输协议(Java) 自动化的 Dubbo 框架与协议性能基准 Benchmark 机制与平台(语言不限) 设计并实现一套零信任安全机制（含 Java/Golang SDK 适配与证书管理） 面向云原生的下一代微服务集群监测机制，涵盖Kubernetes、Nacos 等(Golang) 一种跨集群Kubernetes、传统VM微服务集群的互通方案与实现(Golang) 1 基于HTTP/3 的高性能传输协议(Java) 1.1 赛题背景与目标 本赛题的主要目标是将 Dubbo 中的 triple 协议适配到 HTTP/3 之上，兑现 triple 协议规范中的所有核心能力。
关于 Dubbo3 triple 协议使用的相关示例请参考（请注意阅读 README 中链接指向的其他相关示例）：https://github.com/apache/dubbo-samples/tree/master/1-basic，通过运行示例，可以了解当前 triple 协议的功能。
以下是 Triple 协议规范：https://cn.dubbo.apache.org/zh-cn/overview/reference/protocols/triple-spec/
1.2 赛题说明 请基于 Apache Dubbo Java 实现的 3.3 分支进行开发，代码仓库链接如下： https://github.com/apache/dubbo/tree/3.3
triple 协议相关实现源码：
https://github.com/apache/dubbo/tree/3.2/dubbo-rpc/dubbo-rpc-triple https://github.com/apache/dubbo/tree/3.3/dubbo-remoting/dubbo-remoting-http12 开发者可根据自己的理解修改 Dubbo源码实现，比如在 remoting 层做 http3 适配，赛题实现不受限制，可以依赖如 Netty 等任意网络库或框架。</description></item><item><title>通过模板生成项目脚手架</title><link>https://dubbo.apache.org/zh-cn/blog/2023/12/31/%E9%80%9A%E8%BF%87%E6%A8%A1%E6%9D%BF%E7%94%9F%E6%88%90%E9%A1%B9%E7%9B%AE%E8%84%9A%E6%89%8B%E6%9E%B6/</link><pubDate>Sun, 31 Dec 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/12/31/%E9%80%9A%E8%BF%87%E6%A8%A1%E6%9D%BF%E7%94%9F%E6%88%90%E9%A1%B9%E7%9B%AE%E8%84%9A%E6%89%8B%E6%9E%B6/</guid><description>Dubbo Initializer 可用来快速生成 Java 项目脚手架，帮助简化微服务项目搭建、基本配置、组件依赖管理等。
Initializer 仍在持续更新中，更多 Dubbo Feature 的支持将会陆续发布。
选择 Dubbo 版本 Initializer 将使用 dubbo-spring-boot-starter 创建 Spring Boot 项目，因此我们首先需要选择 Dubbo 与 Spring Boot 的版本。
录入项目基本信息 接下来，填入项目基本信息，包括项目坐标、项目名称、包名、JDK 版本等。
选择项目结构 有两种项目结构可共选择，分别是 单模块 和 多模块，在这个示例中我们选择 单模块。
单模块，所有组件代码存放在一个 module 中，特点是结构简单。 多模块，生成的项目有 API、Service 两个模块，其中 API 用于存放 Dubbo 服务定义，Service 用于存放服务实现或调用逻辑。通常多模块更有利于服务定义的单独管理与发布。 选择依赖组件 我们为模板默认选择如下几个依赖组件：
Dubbo 组件 Java Interface 注册中心，zookeeper 协议 TCP 常用微服务组件 Web Mybatis 模版引擎 基于以上选项，生成的项目将以 Zookeeper 为注册中心，以高性能 Dubbo2 TCP 协议为 RPC 通信协议，并且增加了 Web、Mybatis 等组件依赖和示例。
注意：上面选中的 Dubbo 组件也都是默认选项，即在不手动添加任何依赖的情况下，打开页面后直接点击代码生成，生成的代码即包含以上 Dubbo 组件。</description></item><item><title>使用 Resilience4j 断路器、限流器、重试、隔离机制保护 Dubbo 应用</title><link>https://dubbo.apache.org/zh-cn/blog/2023/12/14/%E4%BD%BF%E7%94%A8-resilience4j-%E6%96%AD%E8%B7%AF%E5%99%A8%E9%99%90%E6%B5%81%E5%99%A8%E9%87%8D%E8%AF%95%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6%E4%BF%9D%E6%8A%A4-dubbo-%E5%BA%94%E7%94%A8/</link><pubDate>Thu, 14 Dec 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/12/14/%E4%BD%BF%E7%94%A8-resilience4j-%E6%96%AD%E8%B7%AF%E5%99%A8%E9%99%90%E6%B5%81%E5%99%A8%E9%87%8D%E8%AF%95%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6%E4%BF%9D%E6%8A%A4-dubbo-%E5%BA%94%E7%94%A8/</guid><description>Resilience4j 提供了一组高阶函数（装饰器），包括断路器，限流器，重试，隔离，可以对任何的函数式接口，lambda表达式，或方法的引用进行增强，并且这些装饰器可以进行叠加。这样做的好处是，你可以根据需要选择特定的装饰器进行组合。
关于 Resilience4j 与 Dubbo 集成的使用示例请参见 dubbo-samples-resilience4j</description></item><item><title>使用 Hystrix 对 Dubbo 服务进行熔断限流保护</title><link>https://dubbo.apache.org/zh-cn/blog/2023/12/14/%E4%BD%BF%E7%94%A8-hystrix-%E5%AF%B9-dubbo-%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8C%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E4%BF%9D%E6%8A%A4/</link><pubDate>Thu, 14 Dec 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/12/14/%E4%BD%BF%E7%94%A8-hystrix-%E5%AF%B9-dubbo-%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8C%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E4%BF%9D%E6%8A%A4/</guid><description>背景 Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能。
本文介绍在spring应用里，怎么把 Dubbo 和 Hystrix 结合起来使用。
https://github.com/Netflix/Hystrix https://github.com/apache/dubbo Spring Boot应用 Demo 地址： https://github.com/dubbo/dubbo-samples/tree/master/4-governance/dubbo-samples-spring-boot-hystrix
生成dubbo集成spring boot的应用 对于不熟悉dubbo 集成spring boot应用的同学，可以在这里直接生成dubbo + spring boot的工程： http://start.dubbo.apache.org/bootstrap.html/
配置spring-cloud-starter-netflix-hystrix spring boot官方提供了对hystrix的集成，直接在pom.xml里加入依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.4.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 然后在Application类上增加@EnableHystrix来启用hystrix starter：
@SpringBootApplication @EnableHystrix public class ProviderApplication { 配置Provider端 在Dubbo的Provider上增加@HystrixCommand配置，这样子调用就会经过Hystrix代理。
@Service(version = &amp;#34;1.0.0&amp;#34;) public class HelloServiceImpl implements HelloService { @HystrixCommand(commandProperties = { @HystrixProperty(name = &amp;#34;circuitBreaker.requestVolumeThreshold&amp;#34;, value = &amp;#34;10&amp;#34;), @HystrixProperty(name = &amp;#34;execution.isolation.thread.timeoutInMilliseconds&amp;#34;, value = &amp;#34;2000&amp;#34;) }) @Override public String sayHello(String name) { // System.</description></item><item><title>IntelliJ IDEA❤️Apache Dubbo，IDEA官方插件正式发布！</title><link>https://dubbo.apache.org/zh-cn/blog/2023/10/23/intellij-idea%EF%B8%8Fapache-dubboidea%E5%AE%98%E6%96%B9%E6%8F%92%E4%BB%B6%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</link><pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/10/23/intellij-idea%EF%B8%8Fapache-dubboidea%E5%AE%98%E6%96%B9%E6%8F%92%E4%BB%B6%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</guid><description>最受欢迎的 Java 集成开发环境 IntelliJ IDEA 与开源微服务框架 Apache Dubbo 社区强强合作，给广大微服务开发者带来了福音。与 IntelliJ IDEA 2023.2 版本一起，Jetbrains 官方发布了一款全新插件 - Apache Dubbo in Spring Framework。
这款插件可以帮助开发者解决 Dubbo 项目初始化问题，同时方便识别项目开发过程中的 Dubbo 服务及其依赖关系，基于 Apache Dubbo 的微服务开发将变得非常简单。
安装插件 在安装 Apache Dubbo 插件之前，请确保您使用的 IntelliJ IDEA 为 2023.2 及以上版本。 有两种方式可以完成 Apache Dubbo 插件的安装
方式一 使用浏览器打开插件 Apache Dubbo in Spring Framework 官方地址，在页面右上角，点击 “Install to IntelliJ IDEA 2023.2” 按钮即可完成插件安装。 方式二 打开 Preferences -&amp;gt; Plugins，输入 &amp;lsquo;Apache Dubbo&amp;rsquo; 搜索插件，安装即可。 使用插件新建应用 插件安装完成，接下来，我们看一下如何使用插件创建和开发 Apache Dubbo 微服务应用。
打开弹窗 通过 &amp;ldquo;File -&amp;gt; New -&amp;gt; Project&amp;rdquo; 打开新建项目对话框，在对话框中，可以看到 Apache Dubbo 插件已经出现在左侧模版列表中，点击选中即可。 根据应用需要，录入项目名称、保存路径、坐标、JDK版本等信息了，录入完毕之后，点击 &amp;ldquo;Next&amp;rdquo; 进入下一步。</description></item><item><title>Apache Dubbo 首个 Node.js 3.0-alpha 版本正式发布</title><link>https://dubbo.apache.org/zh-cn/blog/2023/10/07/apache-dubbo-%E9%A6%96%E4%B8%AA-node.js-3.0-alpha-%E7%89%88%E6%9C%AC%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</link><pubDate>Sat, 07 Oct 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/10/07/apache-dubbo-%E9%A6%96%E4%B8%AA-node.js-3.0-alpha-%E7%89%88%E6%9C%AC%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</guid><description>关于 Apache Dubbo3 Apache Dubbo 是一款易用、高性能的 WEB 和 RPC 框架，同时为构建企业级微服务提供服务发现、流量治理、可观测、认证鉴权等能力、工具与最佳实践。经过近几年发展，Dubbo3 已在阿里巴巴集团各条业务线实现全面推广，成功取代运行多年的 HSF 框架；同时 Dubbo3 的多语言体系也有了快速发展，目前涵盖的多语言体系有：
apache/dubbo (java) apache/dubbo-go apache/dubbo-js (web、node.js) apache/dubbo-rust 基于 Dubbo3 定义的 Triple 协议，你可以轻松编写浏览器、移动端、gRPC 兼容的 RPC 服务，并让这些服务同时运行在 HTTP/1 和 HTTP/2 上。Dubbo Node.js SDK 支持使用 IDL 或编程语言特有的方式定义服务，并提供一套轻量的 API 来发布或调用这些服务。
关于 Dubbo3 Node.js 首个发布版 Dubbo-js 项目于 9 月份刚刚发布了支持 Dubbo3 协议的首个 alpha 版本，该项目是 Dubbo3 的 Typescript 版本实现，提供了 Web、Node.js 两种发布包。其中，Web 框架能让开发者直接在浏览器页面访问后端服务，Node.js 则进一步丰富了后端微服务技术栈的选择。当前 Node.js 版本主要是实现了 Triple 协议的完整支持，接下来的版本中，社区将继续完善地址发现、负载均衡等服务治理能力。目前 dubbo-js 项目快速发展中，对参与 apache/dubbo-js 项目感兴趣的开发者，欢迎搜索钉钉群：29775027779 加入开发者群组。
Node.js 微服务开发完整示例 本示例基于最新发布的 Node.</description></item><item><title>Apache Dubbo 云原生可观测性的探索与实践</title><link>https://dubbo.apache.org/zh-cn/blog/2023/10/07/apache-dubbo-%E4%BA%91%E5%8E%9F%E7%94%9F%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5/</link><pubDate>Sat, 07 Oct 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/10/07/apache-dubbo-%E4%BA%91%E5%8E%9F%E7%94%9F%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5/</guid><description>摘要：本文整理自平安壹钱包中间件资深工程师、Apache Dubbo committer宋小生在 Community Over Code 2023 大会上的分享。本篇内容主要分为五个部分：
一、可观测性建设 二、多维指标体系 三、链路追踪门面 四、日志管理分析 五、稳定性的实践 一、可观测性建设 首先介绍一下云原生升级的挑战。目前大部分公司里基本上都有CICD、OPS来帮助开发、测试、运维提升开发的效率与质量，也会有容器化来帮助提升产线运维的效率与质量。但在云原生时代，大规模容器的频繁变更会带来很多稳定性的问题。这些稳定性问题，包含了很多我们可以提前规避掉的已知的异常，也包含了很多我们无法避免的异常，比如网络故障、机器宕机等系统无法提前测出来的问题。
如果我们能提前发现这些问题，其实是可以规避掉很多风险的。所以我们通过可观测系统及时的感知到了这些问题，高效的分析异常，快速的恢复系统。因此可以判定，在云原生时代，可观测系统的建设是非常重要的。
Dubbo作为微服务RPG的框架，直接建设一个大而全的可观测性系统或者平台是不现实的，而且它的定位也不是很符合。可观测性系统更强调关联性，通过单维度或者多维度进行系统的观测与问题的诊断。
首先看一下可度量系统的健康状态的指标。Dubbo通过采集系统内部的Dubbo指标的同时，把指标内部的数据暴露给外部的监控系统。这些监控指标中间包含了很多的应用信息、主机信息、Dubbo服务标签信息等等。当我们发现问题的时候，可以通过这些标签信息关联到全链路系统。之后全链路系统可以做到请求级或者应用级的系统性能分析或者系统异常诊断。
Dubbo侧通过适配各大厂商门面的形式，只需进行非常简易的依赖就引入或者配置就可以直接把数据导出到各大全链路平台。无论企业使用哪个流行平台，在后期升级Dubbo后都可以直接把链路导出去。
另外，链路系统还包含全链路的Traceid或者局部的磁盘ID。通过全链路的ID，我们可以在链路系统直接跳转到日志平台。在日志平台里包含非常详细的日志上下文，这些日志上下文可以提供非常精确的异常问题诊断。
Dubbo也提供了非常详细的错误码机制和专家建议的形式，在官网上通过日志的形式可以直接通过错误码的形式直接导航到官网上的帮助文档。
二、多维指标体系 Dubbo在多维度指标体系实践的时候，我们主要从两个维度来看它。
第一个是纵向的维度。Dubbo指标在采集的时候有一个接入导出的流程。Dubbo为用户和开发者提供了简单易用的接入门面。接入后服务在运行过程中通过指标器进行指标的采集。Dubbo中提供了非常多的指标采集器，包括聚合和非聚合的指标采集等等。
然后采集的指标会通过变量值临时存储在内存里，之后会有部分指标（QPS等带有滑动窗口的最小值、最大值的聚合指标）进行聚合计算，最后这些指标会导出到外部系统。我们支持在Dubbo QPS服务质量中进行指标导出，或者把指标导出到Prometheus，或者http直接访问也可以进行指标的查询。
第二个是横向的维度。Dubbo指标采集覆盖了非常容易出现异常的地方。比如Dubbo 3提供了三大中心，包括注册中心、元数据中心、配置中心，存在外部网络交互的地方是非常容易出现问题的。
另外一个比较关键的是RPC电路上的采集，比如请求相应的时间、异常、nity网络、IO的指标等等。此外还有一些关于Dubbo线程池的指标采集。
前面说的是比较大面上的指标采集，具体Dubbo的采集需要哪些指标我们也调研了很多比较流行的方法论。
图中第一张图是谷歌SRE书的四大黄金指标。它是谷歌总结大规模的分布式服务监控总结出来的，它可以进行请求级别的服务质量的衡量，主要包含延迟、流量、错误以及饱和度。 图中第二张图是RED 方法。它更侧重于请求，从外部视角来查看服务的健康状态，主要包含速率、错误与持续时间。 图中第三张图是USE 方法。它更侧重于系统内部的资源使用情况，包含利用率、饱和度与错误。 可以看到，以上三个指标的方法论中都包含的指标是错误，错误也是每个开发者比较关注的。
然后我们进行了指标的系统完善。在Dubbo 3.2版本中，多维度指标体系已经完成，而且也在快速持续的版本迭代中。在这个版本中我们只需要引入一个快速集成的Spring Boot中的Starter包就可以实现指标的自动采集。之后我们通过Dubbo的QPS服务质量端口可以直接访问到。如果是本机可以通过浏览器，如果是服务器可以通过科尔命令访问52端口，后面加一个Metric路径，这样就可以看到非常详细的默认指标的导出。
可以看到这些指标有Dubbo前缀，类型是Dubbo的不同模块，比如消费者提供的请求级别，三大注册中心一起线程。
下面是Dubbo当前指标的行为，比如响应时间最后会加一些单位，这个格式参考的是Prometheus的官方格式。
多维度指标体系有些人可能会直接复用Spring Boot默认的manager管理端口，Dubbo也适配了一下Spring Boot Actuator的扩展。
操作和刚刚一样，只是引入Spring Boot Starter包。后面也无需做任何其他的配置，就可以在Spring端口里看到详细的指标了。包括Spring Boot内置的jvm指标、Dubbo指标等等。
指标体系接入之后，我们如果直接通过命令行访问只能看到一些瞬时的数据，但在监控指标体系我们其实更关注的是多维度的向量数据。如果我们把这些数据看作是一个点其实是比较难看出问题的，所以我们需要把这些数据存储起来，看作是一个实际化的向量数据。
Dubbo默认提供对Prometheus采集的介入。Prometheus作为指标存储与监控一体的监控系统，提供了很多的服务发现模型。比如我们直接把服务部署在K8s上，可以直接基于K8s标签的服务发现机制进行指标采集。如果公司有自建的cmdb系统，可以自己扩展http接口进行指标采集。此外,文件或者静态的服务发现机制只要能发现Dubbo服务的IP和服务接口，也可以进行指标采集。采集到的指标会自动存储在Prometheus的实际数据库里。
上图是我们通过Prometheus的查询框查询出来的响应时间的最新指标。
Prometheus的指标更侧重于存储与报警，如果我们想更直观的体现还需要接入Grafana。Grafana的目标是为企业提供简易接入的监控面板，上图是一个简易的全局大盘。
我们通过应用级别的筛选/机器IP维度的查询/服务接口的维度，查询服务的健康状态。可以看到，这些指标基本上都是基于前面总结的方法论实现的。比如QPS、请求数量、成功率、失败率、请求的时延等等。
此外，还有一些应用信息的指标，比如升级Dubbo 3时，想看到哪些应用已经升级到新的版本，就可以看到新的应用的版本号，也会有应用信息的实例IP分布，还有一些现成资源。
三、链路追踪门面 刚才说的指标比较抽象，它更利于帮助我们发现问题，接下来进行一些简单问题的诊断。微服务系统往往是多个系统之间有关联关系，所以服务之间的诊断更依赖于全链路系统。
全链路系统Dubbo，当时考虑使用Agent的方式，这种方式对于用户接入是非常方便的，在代理层直接注入一些指标采集的方式即可。如果用这种方式在企业里做全链路的覆盖是非常方便的，但如果Dubbo只做Dubbo的指标采集，风险会比较大。因为Agent接入后会进行字节码修改等不兼容的问题，有些时候很难在前期发现。
另外，Dubbo也调研了一些开源的链路追踪门面。Dubbo选择通过原生内置门面的形式，让专业的事情交给专业人做。Dubbo通过适配各大厂商的全链路追踪系统，快速适配接入的用户，只需增加少量的配置就可以实现链路数据的导出。
在链路追踪门面的选型方面，我们参考了业界比较流行的几个链路，从中挑选了两个进行选型，分别是OpenTelemetry和Micrometer。
OpenTelemetry，大家应该非常熟悉，它支持多语言，规范标准统一的API，支持大部分流行的第三方厂商的全链路追踪系统，是CNCF孵化的项目之一，很多中间件应用都已经接入了这种规范。
Micrometer，大家可能对的印象是指标采集的接入。它的缺点是只能支持Java，但它在语言方面，它是Spring Boot 3默认的指标采集，链路采集默认支持micrometer-tracing的功能。此外，Micrometer它还可以通过桥接包直接转化为open的协议，间接也支持各种第三方的采集。并且Micrometer自身也通过调节机制调节了很多的全链路厂商。
我们为了和前面使用到的指标采集进行统一，使用Micrometer后无需额外引入第三方的依赖，只需使用Micrometer Tracing的桥接包，就可以快速的接入。
上图是链路追踪系统的简单结构。Dubbo的边路采集主要采集rpc请求的链路。在消费者发起请求的时候，如果存在链路ID就直接复用，没有的话会产生链路ID，然后把她们上报给采集器。同样消费者也会通过rpc的上下文把链路数据透传给提供端。提供端拿到这个链路数据后，会对它进行父子关系的关联。最后把这些链路数据上报采集器。
采集器在前面的时候主要是内存级别的操作，对系统的损耗比较小。后面将进行异步的导出，和前面指标体系是一样的。内存级的同步采集，异步的把数据导出到第三方的链路系统。
链路系统接入也比较简单，主要是引入Spring Boot Starter的依赖包，进行一些比较简单的配置，包括不同厂商的导出地址等等。</description></item><item><title>OpenSergo &amp; Dubbo 微服务治理最佳实践</title><link>https://dubbo.apache.org/zh-cn/blog/2023/10/07/opensergo-dubbo-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link><pubDate>Sat, 07 Oct 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/10/07/opensergo-dubbo-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid><description>摘要：本文整理自阿里云 MSE 研发工程师何家欢的分享。本篇内容主要分为四个部分：
一、Why 微服务治理？ 二、OpenSergo：服务治理控制面与标准规范 三、OpenSergo &amp;amp; Dubbo 最佳实践 四、OpenSergo 的未来之路 一、Why 微服务治理？ 现代的微服务架构里，我们通过将系统分解成一系列的服务并通过远程过程调用联接在一起，在带来一些优势的同时也为我们带来了一些挑战。
如上图所示，可以看到一个词云，这些都是目前微服务架构在生产上所遇到的挑战。比如，最常见的流量激增的场景，近一年内AIGC突然爆火，相关网站/服务都存在过因为激增流量导致服务不可用的情况，可能会让我们错过一个最佳的增长窗口。
再比如缺乏容错机制，某视频网站的某个服务异常，随调用链扩散，导致全站入口不可用，影响千万用户，产生实质性的经济损失。这些生产故障频频发生，也是在提醒我们稳定性是用好微服务的重大挑战之一。
为了保障微服务的稳定性，我们就需要做一些架构的演进。
我们先看一下左侧的微服务3大件，这个大家已经很熟悉了，通过这三者的配合，我们的应用就能够正常使用了，但是距离生产可用其实还有很大一段距离，各个企业和社区为了消除这其中的gap都有一些探索和实践，比如Dubbo社区在Dubbo3中引入一系列诸如流量管理、高可用性的能力来保障微服务的稳定性，这些措施可以统称为微服务治理。
所以其实大家已经意识到，从把微服务跑起来到真的生产可用，微服务治理是必不可少的一环。但微服务治理要做些什么，如何去做其实都还比较模糊。
从软件生命周期的角度，我们可以把微服务治理分成三个域，开发态与测试态、变更态、运行态。
在这三个域中都面临着很多挑战，对于这些挑战大家也有着一些探索和实践，比如对于发布有损的问题，我们可以通过无损上下线来解决，变更的影响面通过灰度来控制，对于不确定流量使用流控、热点防护，不稳定调用使用熔断与隔离。
可以看到在各个域中都有一些成熟的方案和效果很好的实践。但是不管是阿里还是其他公司，在体系化落地微服务治理时都会遇到很多问题。
二、OpenSergo：服务治理控制面与标准规范 首先我们涉及的组件有很多，在微服务架构中，往往会涉及很多组件，它们需要有Dubbo这样的调用框架，nacos这样注册中心，snetinel、hystrix这样的稳定性中间件等等，因此也没办法进行统一治理，管控成本就非常高。
其次时概念不统一，比如在envoy中的隔离与 sentinel中的隔离完全不是一个意思，envoy的隔离是摘除不健康实例，sentinel的隔离是并发控制，这就会使开发者理解成本很高。
同时各个企业社区都有自己的最佳实践，这也就导致大家能力上是不对齐的，没有统一的标准。
还有配置不统一的问题相信大家都很有体感，比如sentinel、hystrix、istio都有熔断的能力，但是配置却各有差别，需要开发者分别学习，还要注意不混淆，不利于理解，也不利于统一管控。
可以发现由于这些问题，我们在落地体系化微服务治理时会有很大的阻力，我们需要的是一个统一的治理界面来让我们更好地做微服务治理，因此我们提出了OpenSergo这个项目。
而OpenSergo期望提出一套开放通用的、面向云原生架构的微服务治理解决方案及标准规范，来助力保障微服务高可用，上图的四个部分就是OpenSergo社区的愿景。
OpenSergo社区会基于业界微服务治理场景与实践抽象成规范，通过这种方式去解决前面提到的概念、配置、能力不统一的问题，并用统一的管控面去承载，降低使用和维护成本。
同时在纵向上，我们针对链路上的每一环进行抽象，覆盖完整的场景，在横向上，无论是Java生态，Go生态或是其他语言，无论是传统微服务还是Mesh架构，都会纳入到这套统一的体系中。
但是OpenSergo作为一个开放标准，仅凭借阿里是不够的，所以我们联合了多家公司以及社区比如bilibili、中国移动、字节跳动的cloudwego社区等，共同建设这套开放标准，希望能够真正解决微服务稳定性的风险。
接下来简单介绍一下OpenSergo的架构体系，前面也介绍了OpenSergo社区会基于场景抽象出OpenSergo的Spec，但这只是第一步，为了承载这些标准规范我们就需要一个控制面，社区在一开始的演进中选择从0开始开发一个控制面来做治理规则的管控、监听与下发。
但是随着社区的演进，我们发现基于Istion去扩展，成本更低，也能够复用更多的能力，因此在后续的演进中我们会选择结合Istio扩展控制面与决策中心实现治理规则统一管控、治理策略预计算。
在有了控制面后我们还需要数据面来进行具体治理能力的实现，它可以是像sentinel这样的中间件，也可以是框架本身。控制面与数据面之间的通讯在初始的架构中是基于grpc构建的链路，但在确定了后续演进方向会基于istio扩展后，社区选择拥抱xds，尽可能服用它的链路，对于一些无法承载的我们再使用自身的grpc链路。
前面也提到社区控制面的后续演进是基于Istio扩展的，Istio本身也有一些流量治能力，并有着一定的普及度。但是Istio主要关注流量管理，让流量到达该去的地方而不是微服务治理治理，所以在微服务稳定性的场景下，Istio所提供的这些能力是不足以满足我们的需求的。
因此我们在Istio的基础上，基于微服务稳定性的一些场景，比如前面提到的变更态稳定性、运行时稳定性去抽象、制定了满足需求的规范标准，希望能够更加贴合微服务场景。所以整体上我们在微服务治理领域会是Istio的超集，而不是互斥关系。
接下来我们一起看一下OpenSergo的标准规范是如何解决前面所提到的这些场景。
首先我们聊一下流量路由，它的主要作用是将符合一定特征的流量路由到指定的workload上，一般大家会用这种能力来实现灰度、同AZ路由等方案。
基于 Istio VirtualService/DestinationRule 的格式社区定义了流量路由spec，但我们在调研以及实践的过程中发现，它并不能很好的满足微服务场景下的需求。所以为了更贴近微服务的场景去扩展去做了扩展。比如我们增加了路由失败后的处理逻辑，这在微服务架构中是很常见的需求。
又由于Istio主要关注的是HTTP请求，它的CRD不能够很好地承载像Dubbo这样的RPC调用，所以我们为此增加了更多RPC模型的支持。后续我们也会探索与社区标准结合的方案，使我们的Spec更加通用与标准。
前面所提到的灰度，在阿里集团内部数年的安全生产实践中，与可监控、可回滚一起被定义为安全变更的三板斧，其中灰度是控制变更影响面，保障变更稳定性的必不可少的能力。
为了实现灰度，我们通常有几种方案，第一种是物理隔离，我们通过部署两套一样的环境来实现灰度，但是这种方案的部署和维护成本都很高。
为了提高资源利用率，便产生了第二种方案，流量灰度。我们不部署独立的环境，而是在流量的每一跳进行流量的特征匹配，并且由此决定去往灰度实例还是base实例，这种方案相较与前者更加灵活高效，可以通过前面提到的流量路由能力来实现。但是需要我们在每一跳都配置路由规则，相对比较繁琐。
并且由于有些信息在后续链路是获取不到的，比如uid，导致这个方案的实施有一定的困难。于是便产生了第三种方案，全链路灰度，我们通过在流量入口处进行流量匹配并打上标签，标签会自动沿着调用链路透传，后续链路根据标签来进行路由。通过这种方式，我们就能够更简洁地去定义灰度。Opensergo针对这种场景抽象了对应的CRD。
我们将这个CRD称之为TrafficLane也就是泳道，我觉得还是比较形象的，大家看一下上边的图片，橙色的是正常的流量走向，灰色的是灰度流量的走向，就像是将一个池子分成了多个泳道。
泳道的CRD有三个部分组成，也比较好理解，首先我们需要去匹配灰度流量，所以就要去定义匹配的条件，然后定义为这些流量打上什么标签，最后再定义这个标签以什么方式去透传。
通过这样的CRD我们就定义了一条灰度泳道。但是如果只是定义是不足以实现全路灰度的，我们还需要借助OpenSergo体系全链路全方位框架的一个支持，才能让标签在这些框架中自动的透传，这些框架也能通过标签进行路由。其中流量染色和标签透传会借助标准的trcae体系去实现，比如OT。
上图右侧是一个CRD的例子，大家可以简单看一下。
接下来我们一起看一下运行态稳定性的场景。
我们主要提两个场景，第一个是流量激增的场景，比如双十一的秒杀活动，一开始流量是稳定的情况下，系统也处于稳态。但是当流量激增的时候，系统就会开始往不稳定的方向发展，异常调用也会激增，最后就会变成不可用的状态。对于这类场景，我们可以用流量控制的能力拒绝超出容量的请求，或是通过流量平滑的能力削峰填谷，让流量处于比较平稳的状态，避免服务的不可用。
第二个是不稳定调用导致服务不可用的场景，比如我们调用一些第三方服务经常会出现不稳定的情况，这里的不稳定主要指异常或是慢调用。以dubbo为例，当服务提供方出现慢调用的时候，会导致服务消费方的线程堆积，影响到其他的正常调用甚至是整个服务的稳定性，并且这种风险会沿着调用链反向传递、扩散最终影响整个系统的稳定性。这时我们可以通过并发控制或是熔断保护来限制慢调用对资源的占用，保障系统的整体稳定性。
针对前面提到的这些场景，OpenSergo也制定了相关的CRD。在业界的实践中sentinel是一个成熟的流量防护方案，在阿里内部积累了大量的流量防护相关的场景和实践，2018年开源依赖在业界进一步丰富了这些积累，我们从这些积累中抽象出了一套流量防护的规范标准。
那么一条流量防护的规则应该包含哪些内容，大家可以简单想一下。
首先我们要确定的是要针对怎样的流量，我们可以按接口去划，也可以按请求中的特征去划。确定了目标之后，我们就需要定义要采取怎样的治理策略。这里的策略包括了刚才提到的这些策略，以及更高阶的比如自身过载保护等策略。
最后由于限流本身是有损的，但是我们不希望这种有损传递到用户侧，因此我们需要为不同的规则配置不同行为，从而使得在用户侧的表现是比较友好的，比如最基本的对于抢购场景的限流，我们可以返回一个排队中，请稍后的提示。
上图右侧是一个CRD的示例，流量目标为接口名为/foo的请求，策略为阈值为10的全局限流，fallback为特定的返回体。
通过这样的CRD配置，不管是Dubbo框架还是其他框架，我们都能很方便的使用流量防护的能力。
三、OpenSergo &amp;amp; Dubbo 最佳实践 对于框架开发者来说想要接入到OpenSergo的体系中其实有两种方式
一种是通过对接OpenSergo体系的数据面来接入，框架开发者只需要实现对接Sentinel的适配模块就可以完成对接工作。而对于有特殊要求或是更贴近特定场景的框架，也可以自行对接OpenSergo的标准，来接入OpenSergo体系。
对于用户来说，不管是哪一种方式，都只需要简单地引入一些依赖，就可以无感地获取OpenSergo定义的微服务治理能力，并能在统一的控制面管控这些框架的微服务治理能力，大大提高使用微服务治理的体验与效率。讲完了接入的方式，我们再一起来看下实现的效果。</description></item><item><title>Seata 微服务架构下的一站式分布式事务解决方案</title><link>https://dubbo.apache.org/zh-cn/blog/2023/10/07/seata-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E4%B8%80%E7%AB%99%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link><pubDate>Sat, 07 Oct 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/10/07/seata-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E4%B8%80%E7%AB%99%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid><description>摘要：本文整理自阿里云分布式事务产品负责人、Seata 开源项目创始人、微服务开源治理负责人季敏的分享。本篇内容主要分为三个部分：
一、微服务架构下数据一致性的挑战 二、分布式事务Seata的架构演进 三、如何基于Seata扩展RPC和数据库 一、微服务架构下数据一致性的挑战 在2019年，我们基于Dubbo Ecosystem Meetup，收集了2000多份关于&amp;quot;在微服务架构，哪些核心问题是开发者最关注的？&amp;ldquo;的调研问卷。最终分布式事务占比最大，有54%。
但在Seata出现之前，大家都说分布式事务能避就避，因为消息最终一致性去解释了问题。但Seata开源之后，这些问题都迎刃而解。比如无损上下限，到底是说服务的可用性还是其他的。对于我来说，我觉得它最终关注的是数据的问题。因为无论前端的业务怎么去交互，最终都会沉淀到数据。如果业务的数据不一致，前面是什么架构，都意义不太大，所以我认为数据是企业的核心资产。
那么到底哪些场景会遇到分布式事务的问题呢？
第一个场景，在拆分成微服务架构之后，不同的服务可能由不同的团队负责上下游的协调联动。比如C服务发布的时候，并不会通知A服务和B服务，这个时候就会遇到上下线带来的数据一致性的问题。
第二个场景，不可靠、不稳定的基础设施，会导致网络或者个别主机的宕机。
第三个场景，timeup是分布式架构里比较难解的状态，因为一旦出现服务调用的timeup，这个服务的业务逻辑到底是执行了，还是没有执行timeup的服务怎么实现数据的密度，都是比较尖锐的问题。
第四个场景，业务里除了会涉及到数据库，还会涉及第三方的组件。比如缓存、Redis，我们的库存会先经过Redis这样的组件，那么如何实现它的一致性也是个问题。
第五个场景，我们在上下游做业务的时候，你传给我一些参数，但这些参数本身可能是非法的。那么我就需要把你的下服务也回关掉，而不是只有我这一个服务去做拒绝。
所以分布式事务的场景主要包括了跨库、跨服务、资源的多样性。异常上主要包括业务异常、系统异常。
那么分布式事务是不是微服务架构独有的问题呢？其实不是，它在单体应用里也有类似的问题，只不过在微服务架构里它的问题更凸显。
在单体架构下存在哪些分布事务的场景呢？比如一个单体应用要去修改多个数据库或者多模块的，整体而言，单体数据库它完成的是ServerSission下边的一个本地事务。只要跨了这个本地事务，其他的都是分布式事务，即使微服务都去修改同一个数据库。这样其实你的数据库的本身也不是能反序列化传递到另外一个服务的，这些问题都会涉及到分布式事物的问题。
整体看起来，分布式事物涉及到了分布式架构和单体架构中非常广泛的应用。
市面上的分布式事务方案有以下六类：
XA模式，它的问题是吞吐量和性能要差一点，在一致性上是最高水准。 TCC模式和SAGA模式，可以归结为是一个业务层面的分布式事务，因为他不会拦截数据。比如TCC模式可能有cc接口，至于这个接口怎么回滚，怎么正向的，在框架层面完全不用管。这可能是你里边逻辑本身不是对等的，也不是框架已经参与的，所以更多的是把接口暴露给了业务实现。 消息最终一致性，它最大的优点是实现异步化的解耦，结合消息的削峰填补的特点。但它本身存在着一些问题，对消息来说，他更多的是做一个单项的通知。这个通知可能对于一些消息消费来说，即使业务失败了，它也没法去回滚。 比如现金红包的业务，我首先要将红包转到我的账户，然后再从我的账户转到我的银行卡。可能消息消费的时候我这个账户已经注销掉了，那么你的消息消费就会一直处在失败的状态。对于这类问题，不可能再把上游消息的发送给关掉，所以它更多的是单项通知的场景。
定时任务补偿，它的学习成本低，但实践成本高。尤其是微服务的链路有多翘的节点，需要业务逻辑写的非常周全。 AT模式，它综合了一致性性能，主要的特点是简单无侵入，强一致，学习成本低。缺点是需要遵守一定的开发规约，并且它不是对所有的SQL类型都支持，它有一定限制。从业务场景上来说适应的是一个通用的场景，但它并不适应于热点数据类型的高并发场景，比如SKU的库存的部件。因为在这个模式它有一个应用层的分支锁，需要对相同的数据做一个排队的等待。 二、分布式事务Seata的架构演进 Seata在阿里内部的代号叫TXC，在蚂蚁叫DTX。它起源于集团的五彩石项目，五彩石的项目是当初集团内在做去IOE，从单体架构引进到分布式架构。在分布式架构必然会涉及到很多的中间价，TXC承担的主要的角色做服务一致性的保证。
我们和集团内的三大件都做了深度的集成，包括服务调用框架HSF，也就是对外开源的Dubbo；数据库有分库分表的TDDL组件；异步消息的MetaQ组件。在集团内也有广泛的使用，日均百亿级别调用，标准3节点集群吞吐达近10w TPS。
我们的SLA会分为几个SLA，一个是可用性的SLA服务，另外一个是性能的SLA服务。因为对于分配事物来说，除了要保证一致性，也要保证性能的吞吐量。所以我们规定比如每一次的RT额外的开销不能超过XX。目前能达到毫秒级的事务处理，能保证在稳定性上全年无故障。
最开始我们在做分布式事务实现的时候，我们也去考虑我们的分布式事务应该是在哪层面去实现？
从应用架构的视角，分为这么几层，一个是最上层的应用开发框架，可能每一套公司都有自己的开发框架，比如像ddt的开发框架或者club的体系等等。再下一层是服务调用框架，类似于Apache Dubbo主要承担，也在国内使用的非常广泛。再下一层是数据中间件，这层主要包括ORM框架、事务、同步、对账。再下一层是跟数据库连接，这一层类似于JDBC、Java去连数据库。
我们去做了一个简单的对比，到底是在哪层实现分布式事务，是在DB层、数据中间件层还是应用框架层？
在应用框架层，它去实现一致性相对来说比较弱，因为你会掺杂很多复杂的、不可控的因素，会把服务调用的因素给牵扯进去。比如服务调用的超时，这就是为什么我们现在有的像TCC模式它会有一些密等、放悬挂那些问题。都是因为融入了RPC的因素，持续的不确性导致的一些问题。
在数据中间件层，它的一致性比应用框架要好一些，它主要的问题是他不是在DB层实现的，所以我是有办法绕过中间件直接去修改DB的，这时候就会存在事物并发时序的问题。最好的一致性是在DB层去实现数据一致性，但这一层数据一致性主要是数据库的厂商，但是也是参差不齐。比如Msever，他在5.7.7版本才把差异完善起来，在之前的版本它对差异回滚一直是有问题的。
但它只能局限在数据库的scope，如果我要去更大的scope，从应用架构层可能要跨服务，跨服务这一层它就管不了，只能管我自己数据库。所以他最终还是需要有一个第三方的去协调跨服务的数据一致性。最终我们把这一层AT差异模式是把它做到了数据库中间件这层，JDBC server这层我们做到了应用开发框架这层。
所以它不仅实现了一整套的集团生产体系，还包括了我们对分布式事务编程模型的定义，运维安全。因为要涉及到数据，会有数据的敏感以及性能和观测高可用等等。
在理论模型上我们当时还是比较匮乏的，我们做了一些对差异以及Spring事物模型的延展。我们延展了已有的模型，而不是新造一条。这于开发者来说，学习成本会更低。
此外，我们还做了一些定义，包括怎么定义一致性，是定义多节点的一致性，还是业务应用架构数据的一致性，以及这套架构里的角色模型设计的事物动作和隔离。
什么是分布式事务的模型定义？举个例子，我去做银行转账的时候，我给你转100块钱，恰好这个时候出现了网络超时，那么这100块钱到底有没有扣。如果不确定就可能出现资损的问题，甚至可能影响企业的商誉。
我们都在谈分布式架构，但从整个应用的视角，并不是所有东西都是分布式的。比如我们从一个应用的架构的层面去看数据库，包括今天称之为分布数据库。从整个应用层面，它我们看它是一个集成式的数据的存储。它的内部实现可能是分布式的，包括分布式的链路数据。
因为在分布式的应用架构里，每个业务的节点都只掌握了部分的信息。如果做一些问题的排查，必然需要一个集成式的东西。对于分布式事务它的核心工作是做分布式协调，所以他要掌握全局的信息。
这就是为什么我们有了Transaction Coordinator。对他来说，他要有一个上帝视角，充当第三方的协调器。而真正做事的是Resource Manager，你可以认为它是数据库的灵魂，我们需要把它作为Pro。
真正随着业务应用去做事务的动作是Transaction Manager，它会随着业务的执行链路进行，到底直接事务的边界是怎么样的，以及分布式事务的动作是怎么样的。
2019年1月Seata开始开源了，我们主打的特点特色是AT 模式，因为是组装，我们从0.1版本就把AT模式给开源出去了。0.4版本我们纳入了TCC的模式，因为AT模式它需要适配不同的数据库。而在现有阶段我们不能满足对所有数据库的支持以及缓存资源，这就需要应用TCC模式去做补充。你可以用TCC模式做一些我们没实现的数据库以及缓存的结构。
在0.9版本，我们纳入Saga的事务模式，它主要解决长事务方解决方案。比如一个事务非常长，且还有微服务的编排工作。在1.1版本，我们纳入了XA的事务模式，因为有的客户已经应用了Seata的AT模式，但他还有一些老的特别事务。他希望应用Seata统一的一套解决方案，解决不同业务常用的分支事务，所以我们把XA的事务模式也纳入进来了。
最终从整个架构上来说，我们是打造了一站式的分布式事务的解决方案。针对不同的业务场景，Seata都能做事务。如上图所示，目前市面上没有一只分布事务的模式，能解决不同业务场景的问题。主要强调几个问题，分布式事务可能有同步的分布式事物，有异步的分布式事务，以及对分布式事务的一致性的要求也不高。有强一致性，最终一致性，弱一致性。
另外，对于事物执行时间的长短也有要求。比如有长事务、短事务以及性能吞吐量等等。所以我们纳入了现在的四种事务模式，它们从改造成本、性能隔离性上各有所长，这里就不展开介绍了。
三、如何基于Seata扩展RPC和数据库 首先看一下Seata开源社区这几年的发展。目前Seata已经具备了AT、TCC、Saga、XA四种事务模式，而且对于市面上主流的关系数据库，RPC框架做了广泛的支持，同时被许多第三方社区做了主动和被动集成。已经和三十多个社区做了集成，这些集成都放在我们的扩展机制里边。
目前多语言体系也做起来了，除了最开始的Java，Go语言支持的也非常成熟，欢迎大家去使用我们的Go版本，给我们提更多宝贵的建议。另外，我们还建建设了多语言版本，包括PHP、Python等等。
目前 Seata 开源产品已被上千家企业在业务系统中应用，金融企业纷纷试点。我们都知道金融类的业务对分布式事务是强需求，而且它的业务场景非常严苛。像中信银行、光大银行、农行我们也做了一些社区上的合作，改造一些他们的核心账务系统，用Seata保证他们账务体系的数据一致性。
目前Seata社区的Star数已经到达了24k，contributor有300+。并且Seata社区是非常开放的，现在整个Seata的框架代码有70%来自创始团队之外的外部贡献者，所以欢迎大家积极的参与到我们Seata社区里。
接下来介绍一些Seata比较典型的企业案例。
第一个案例，中航信航旅纵横项目。中航信是Seata 最早的天使用户，用的是Seata 0.2版本。如果大家出差比较频繁，应该会用到它们的APP，航旅纵横。它解决机票和优惠券业务的数据一致性问题。虽然在早期的版本中陪我们踩了不少坑，但最终还是应用起来。
第二个案例，滴滴出行二轮车事业部。它在Seata 0.6.1版本就将 Seata 引入到了二轮车事业部的各个业务中，包括市面上大家看到青桔单车，还有他们内部的资产管理。</description></item><item><title>Web 浏览器页面也能访问dubbo、grpc微服务？Dubbo-js alpha版本正式发布</title><link>https://dubbo.apache.org/zh-cn/blog/2023/10/07/web-%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E4%B9%9F%E8%83%BD%E8%AE%BF%E9%97%AEdubbogrpc%E5%BE%AE%E6%9C%8D%E5%8A%A1dubbo-js-alpha%E7%89%88%E6%9C%AC%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</link><pubDate>Sat, 07 Oct 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/10/07/web-%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E4%B9%9F%E8%83%BD%E8%AE%BF%E9%97%AEdubbogrpc%E5%BE%AE%E6%9C%8D%E5%8A%A1dubbo-js-alpha%E7%89%88%E6%9C%AC%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</guid><description>基于 Dubbo3 定义的 Triple 协议，你可以轻松编写浏览器、gRPC 兼容的 RPC 服务，并让这些服务同时运行在 HTTP/1 和 HTTP/2 上。Dubbo TypeScript SDK 支持使用 IDL 或编程语言特有的方式定义服务，并提供一套轻量的 APl 来发布或调用这些服务。
Dubbo-js 已于 9 月份发布支持 Dubbo3 协议的首个 alpha 版本，它的发布将有机会彻底改变微服务前后端的架构与通信模式，让你能直接在浏览器页面或web服务器中访问后端 Dubbo RPC 服务。目前项目快速发展中，对参与 apache/dubbo-js 项目感兴趣的开发者，欢迎搜索钉钉群：29775027779 加入开发者群组。
浏览器 Web 应用示例 本示例演示了如何使用 dubbo-js 开发运行在浏览器上的 web 应用程序，web 页面将调用 dubbo node.js 开发的后端服务并生成页面内容。本示例演示基于 IDL 和非 IDL 两种编码模式。
IDL 模式 前置条件 首先，我们将使用 Vite 来生成我们的前端项目模板，它内置了我们稍后需要的所有功能支持。
npm create vite@latest -- dubbo-web-example --template react-ts cd dubbo-web-example npm install 因为使用 Protocol Buffer 的原因，我们首先需要安装相关的代码生成工具，这包括 @bufbuild/protoc-gen-es、@bufbuild/protobuf、@apachedubbo/protoc-gen-apache-dubbo-es、@apachedubbo/dubbo。</description></item><item><title>基于 Triple 实现 Web 移动端后端全面打通</title><link>https://dubbo.apache.org/zh-cn/blog/2023/10/07/%E5%9F%BA%E4%BA%8E-triple-%E5%AE%9E%E7%8E%B0-web-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%90%8E%E7%AB%AF%E5%85%A8%E9%9D%A2%E6%89%93%E9%80%9A/</link><pubDate>Sat, 07 Oct 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/10/07/%E5%9F%BA%E4%BA%8E-triple-%E5%AE%9E%E7%8E%B0-web-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%90%8E%E7%AB%AF%E5%85%A8%E9%9D%A2%E6%89%93%E9%80%9A/</guid><description>摘要：本文整理自陌陌研发工程师、Apache Dubbo PMC陈有为在 Community Over Code 2023 大会上的分享，本篇内容主要分为四个部分：
一、RPC 协议开发微服务 二、全新升级的 Triple 协议 三、Triple 协议开发微服务 四、Dubbo 为 Triple 协议带来治理能力 一、RPC 协议开发微服务 在我们正常开发微服务的时候，传统RPC服务可能在最底层。上层可能是浏览器、移动端、外界的服务器、自己的测试、curl等等。我们可能会通过Tomcat这种外部服务器去组装我们的RPC层，也就是BFF。或者我们没有BFF，我们的RPC就是对外提供服务。但因为浏览器要访问，所以我们需要有一个网关，比如说Apisix或者ShenYu等HTTP网关。
上图展示的是我们的流程，但是存在一些问题。
如果我们的服务是非常轻的，我们只需要一个转发层，我们是不是很麻烦。无论是配网关还是起一个webserver去转发，肯定都很麻烦。
此外，RPC服务大部分都是基于二进制的，而二进制正常在本地是没法测试的。因此我们的公司内都可能就会开发一种后台或者中间的Process让我们去测试。但这个的前提是你至少得把它部署到测试环境，所以还是没法在本地测试。
总体来说，这两个问题的易用性比较低，且开发成本相对较高，因为要做一些重复劳动。
二、全新升级的 Triple 协议 基于上边的两个问题，我们来介绍一下Triple协议。
先来说一下上一代协议，它产出的原因是什么。我们应该都知道Dubbo原来是Dubbo协议，它是基于tcp的，它有一个包。因为它的包的设计，导致了网关无法做一些特殊规则判断、过滤等操作。但也不是绝对的，如果你愿意牺牲性能把包完全解出来，组装回去再透传还是可以做到的，但一般大家都不太能接受。
所以我们就在想能不能把原数据和真正的包分开。现在我们有现成的HTTP，又有一个业界主流的gRPC，所以我们的目标就是兼容gRPC。因为gRPC目前都是用IDL，而IDL有一个问题，尤其在Java侧。因为大家都是写一些接口，定义一些包去实现，这样就会非常麻烦。Go侧就还好，因为大家已经习惯了这种开发模式。
所以我们开发了Triple协议，首先它兼容了gRPC，所以我们能实现和gRPC的完全互通。其次，我们兼容了自己定义接口的方法。虽然会损失一定的性能，但提升了一些易用性。而且RPC一般不是业务的瓶颈，大多数瓶颈还是在DB。
但还有个问题，虽然我们兼容了gRPC，但gRPC是基于TPC的，所以如果前端或者其他第三方系统只有HTTP，它还是接受不了我们的系统。
基于此，我们想推出一个全新的Triple协议。为了解决上述的所有问题，我们参考了gRPC、gRPC Web、通用HTTP等多种协议，做到浏览器访问，支持Streaming，还支持同时运行在 HTTP/1、HTTP/2 协议上。因为目前HTTP/3还没有大规模推广，未来也会支持HTTP/3。
最终的设计实现是完全基于HTTP的，且对人类、开发调试友好。我们可以通过简单的浏览器访问或者curl访问，尤其是对unary RPC。此外，我们和gRPC是完全互通的，用HTTP的业务不用担心兼容性的问题，也不用担心签协议的问题。为了稳定性，我们只会采用业界流行的网络库，比如Java的netty、Go的基础的net包。
虽然Triple协议和gRPC协议都基于HTTP，但gRPC是基于HTTP/2的，而Triple是基于HTTP/1和HTTP/2的。
我们在进入gRPC的同时，我们为了易用性扩展了一些功能。比如请求里我们支持application Json，curl访问，此外上一版的协议，为了支持传统定义接口的方式，我们有一个二次序列化的过程。我们想在这里通过一个特殊的tag来决定我们的body的结构，解决二次序列化的问题。同时这个东西是可以扩展的，理论上HTTP的所有future我们在Triple协议上都可以实现，也可以拓展。
用了Triple协议之后，我们的开发流程也发生了改变。如果你不需要进行组装，或者没有外层的代理，可能你的接入流程就是从外部的请求浏览器、对方的服务器、curl、自己测试等直接到了server。
和其他的gRPC的通信也是没有问题的，流程就相当于少了一层。对于大多数用户，如果你不需要这个场景，其实是有很大的好处。
Triple协议因为最开始兼容gRPC，那个时候只基于HTTP/2，HTTP/2有Streaming的能力，所以它天然支持Streaming。但这里比较特殊的是，我们新版的协议在HTTP/1也支持了Stream，但仅支持了Server Stream。也就是客户端发一个，服务端发好几个回去，这个HTTP/1的Server Push实现的。
Client Stream和Bi Stream就没什么可说的了。但有一个特别的是，在Java侧没有Bi Stream，从编码上就没有，但从实现上是有的。
三、Triple 协议开发微服务 目前Triple协议比较灵活的支持两种定义方式，分别是IDL定义和直接定义。直接定义支持同步、异步、手写。还有比较极端一点的，比如在自己定义接口的时候用IDL生成probuff的类，我们不定义它的service，只用它的接口也是没问题的，它会自动识别接口使用pb还是不使用pb。
Server就是把它的务实现一下。上图是一个例子，我就直接拿了API的组装方式，真正的业务上可能是注解或者XML的方式。
因为我们支持了HTTP这个标准的协议，理论上我们的测试就会变得很简单。
因为我们支持gRPC，所以我们可以用gRPC curl去调用我们的服务。但前提是你得有反射服务，然后手动开启一下，它不是默认开启的。然后它就可以通过反射拿到接口的源数据，通过Json转成pb格式发过去。或者我们直接用Application Json的方式直接调过去。这里有一点比较特别的是在HTTP/1下我们也可以用Sream。
另外，因为我们支持HTTP，理论上所有第三方的HTTP客户端都是可以调用的。然后我们的admin也可以进行测试，前提是你得把它注册上。
调用端不管是POJO还是IDL，它们都没有本质的区别。
现在我们有了Triple协议，但如果这个协议没有承载方也是行不通的。因此我们还得有一个框架，有一些服务治理才是我们的微服务。所以服务治理也是微服务中不可或缺的一部分。
四、Dubbo 为 Triple 协议带来治理能力 Triple的定位只是Dubbo里的其中一个协议，当然你也可以为了兼容性，用原来的Dubbo协议或者其他的协议。而且我们支持在同一个端口上开多个协议，可以按需选择。
同时Dubbo 为 Triple 提供了多语言的实现。目前会在Rust、Go、Java、JS、node、Python这几部分实现官方的实现。这样用户就不用自己根据实验协议的spec去实现了。如果你有一些定制需求，比如内部的一些框架，你根据spec实现也是可以的。</description></item><item><title>启动速度提升10倍：Apache Dubbo 静态化 GraalVM Native Image 深度解析</title><link>https://dubbo.apache.org/zh-cn/blog/2023/10/07/%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E6%8F%90%E5%8D%8710%E5%80%8Dapache-dubbo-%E9%9D%99%E6%80%81%E5%8C%96-graalvm-native-image-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</link><pubDate>Sat, 07 Oct 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/10/07/%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E6%8F%90%E5%8D%8710%E5%80%8Dapache-dubbo-%E9%9D%99%E6%80%81%E5%8C%96-graalvm-native-image-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</guid><description>摘要：本文整理自杭州有赞科技有限公司中间件技术专家、Apache Dubbo PMC华钟明在 Community Over Code 2023 大会上的分享。本篇内容主要分为五个部分：
一、GraalVM 直面Java应用在云时代的挑战 二、Dubbo 享受 AOT 带来的技术红利 三、Dubbo Native Image 的实践和示例 四、Dubbo 集成 Native Image 的原理和思考 五、Dubbo 在 Native Image 技术的未来规划 一、GraalVM 直面Java应用在云时代的挑战 云计算时代比较显著的特点包括：
基于云计算的基础设施，Java应用能够在云计算的基础设施上快速、轻松、高效的做到弹性。 基于容器化技术，系统资源切分的更加细，资源的利用率也更高了。 基于云计算的开发平台，让应用部署的更加容易，更加敏捷。 那么在云计算时代，Java应用存在哪些问题呢？
冷启动速度较慢。 应用预热时间过长，无法立即达到性能峰值。 内存、CPU等系统资源占用高。 Java构建的应用程序繁重，执行还需要具备JDK环境。 在Serverless场景上，Java的问题会尤为突出，因为Serverless不仅能简化开发场景和开发体验，还能做到极致的弹性，甚至是秒级的弹性。
上图是Datalog统计的Fast和AWS两个产品。Java语言虽然更流行，但相较于Python和Node.JS，它的占比还是比较低的。Java本身在Serverless层面，比如在做容器的调度、镜像的下载的时候，启动时间、冷启动的时间、预热时间等等，都会影响Serverless场景下它弹性扩容的时间。
下面介绍一下GraalVM，它是可以把Java应用提前编译到独立的二进制包内，这些二进制包相对于跑在JVM上它可以更小，更快的启动，不需要预热就能够达到极限的峰值，还可以减少内存和CPU的占比。
可以看到它的介绍和Java语言的应用所涉及到的问题都一一对应。GraalVM应该算是JDK的&amp;quot;超集&amp;quot;，除了包含完整的JDK发行版本外，还有GraalVM Compiler、Native image、Truffle等，甚至还涉及到多语言汇编的能力。
总结一下，GraalVM本身涉及两部分，JIT和AOT。
JIT，是在编译后的class文件、字节码文件，它会在运行时把它翻译成机器码。 AOT， 它和JIT的区别是，它在编译期就能把字节码直接转化为机器码，无需在运行时再去处理。所以它的CPU和内存会相对更低。 上图左侧是一张Java生命周期的全景图。可以看到，它从JVM的启动，再到Java的main函数的启动，再到Java的应用预热，再到它的稳定期，最后到达效果，这是Java完整的生命周期的呈现。
而AOT的区别在于，它没有红色的VM。另外，JIT相对于AOT而言是没有的，也没有浅绿色的解释器。所以AOT对于JIT来说，只有内加载，GC以及它能够瞬间达到应用的稳定期。
根据右侧的图可以看出：
AOT的启动耗时相对较低，内存损耗和它打出来的二进制包相对较小。 JIT因为有及时编译的效果，所以现在极限的分值比AOT要好，比如它的极限吞吐量比AOT好。 二、Dubbo 享受 AOT 带来的技术红利 多产物形态 我们在编码之后，Soft Code的产物形态新增了。
第一种是我们传统认知上的Jar包形态，比如mvn、clean、package。第二种是Docker Image，它能轻松的帮我们直接打到镜像里面去，不用写dockerfile等文件。第三种是我们集成GraalVM后新产生的一种Native可执行文件的形态。这种形态无需JDK的环境就能启动，它能像GO一样把二进制文件直接启动。
启动耗时大幅降低 上图的跑分都是基于4c16g的micro24的系统上跑出来的。左边和右边的区别是，左边的Provider端提供了一个Dubbo服务跑出来的，右边是提供了一个调用者的身份跑分出来的。从左边这张图可以看到，Native的可视性文件比Jar包方式的启动耗时降低了12倍+，在客户端应用，它的启动耗时降低了11倍+。所以在刚刚提到的Serverless场景上，它能提供一个非常好的启动速度。在扩容的时候能够达到秒级，甚至达到毫秒级。
启动后立即达到性能峰值 上图也是跑分跑出来的数据，可以看到Consumer和Provider端通过静态化执行文件执行后，比都为Jar包的情况，第一次调用的耗时降低6倍。这第一次调用代表的是预热的时长，以及第一次需要解析的类，包括资源的情况等等。这让我们在Serverless场景下能够瞬间达到性能峰值。
内存损耗大幅降低 上面有左右两张图，在Dubbo应用的基础上，它的内存损耗也降低大概3.5倍。Native静态化执行文件可以做到60M的内存占比，在客户端它的内存损耗也大概降低了4倍。
这是Dubbo在Native Image技术场景中做的努力：</description></item><item><title>手把手教你部署Dubbo应用到Kubernetes – Apache Dubbo Kubernetes 最佳实践</title><link>https://dubbo.apache.org/zh-cn/blog/2023/10/07/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%83%A8%E7%BD%B2dubbo%E5%BA%94%E7%94%A8%E5%88%B0kubernetes-apache-dubbo-kubernetes-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link><pubDate>Sat, 07 Oct 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/10/07/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%83%A8%E7%BD%B2dubbo%E5%BA%94%E7%94%A8%E5%88%B0kubernetes-apache-dubbo-kubernetes-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid><description>精进云原生 – Dubbo Kubernetes 最佳实践
摘要：本文整理自阿里云研发工程师、Apache Dubbo PMC江河清的分享。本篇内容主要分为六个部分：
一、使用 Dubbo Starter 初始化项目 二、开发微服务之协议选型 三、基于 Kubernetes 快速初始化环境 四、快速部署应用到 Kubernetes 集群中 五、云原生微服务可观测最佳实践 六、在 Kubernetes 中管理微服务应用 上图是从 Istio 借鉴的一个demo，它包含了四个组件，分别是Product Page、Reviews、Details、Ratings，它就是一个全链路的串联，实现了整体的微服务架构，它的功能可以实现我们简单的调用。
一、使用 Dubbo Starter 初始化项目 首先介绍一下Starter的功能。对于很多开发来说，在Java体系下创建出新的应用，无外乎就是用IDE创建一个新的项目，或者用maven的artifact，或者基于Spring的Initializer。
上图使我们基于Spring的Initializer建立了我们自己的初始化项目的工程。我们点击最上面的网址就能直接看到这个页面了，你需要输入对应的group和artifact。然后选择你希望用到的组件，比如Nacos、Prometheus的组件等等。
除此之外，我们在IDE里提供了一个Dubbo的插件。这个插件可以通过上图的方式进行安装，或者如果你的仓库里已经用到了Dubbo的配置，它会提示你可以直接安装。安装完成后在右边就会有一个对应的初始化的项目了。
上图是一个示例，它在这里建立了一个Dubbo的项目，然后你需要在这里选中所需要的组件信息，最后点击创建，之后它就会帮你在本地直接创建出一个全新的项目，然后你就可以在这个模版上开发了。
二、开发微服务之协议选型 我们会用到最新的Triple协议，它整体支持兼容gRPC、HTTP/1、HTTP/2。
这里主要想和大家分享的点是，我们基于curl访问的能力，比如POSTMAN、HttpClient都是支持的。
下面来看一下我们的项目，这是刚才建立的一个项目，我现在把应用启动起来，配置一些注册中心的地址，这就是一个标准的Spring的启动的流程。这里定义了一个接口，这个接口返回了一个&amp;quot;hello&amp;quot;的内容信息。然后我用一个简单的命令，就可以直接返回我的hello world的结果了。这样对我们本身的测试来说有很大的帮助，也就是本地启动之后，就可以直接测试接口。
三、基于 Kubernetes 快速初始化环境 假设我们已经把前面四个应用的代码全部开发完成了，接下来我要把它部署到K8s环境上。部署之前有一个非常重要的步骤，需要先初始化环境。比如Nacos、ZK、Skywalking、Zipkin、Prometheus等组件，我们都需要将它们安装上去，因为它们是应用前置依赖的各种组件。这些组件的安装流程都很复杂，那么我们如何简化这个流程呢？
Dubbo提供了一个命令，这个命令可以一键帮你在K8s体系下拉起上图左边的所有组件。
这里有一个简单的例子，拉起来之后，它会把所有的组件都会帮你拉起来。这里埋一个点，这里的Prometheus我们后面还会继续使用。整个Nacos的地址，Zookeeper的地址都会直接提供给你。
这也是一个的例子。执行一个简单的命令，然后本地会把kubectl的配置都准备好，它就会自动的帮你把组件都创建起来。也就是我们一键就可以获取到所有service的部署。
四、快速部署应用到 Kubernetes 集群中 部署应用有三个重要的点，分别是应用容器化、无状态部署、生命周期对齐。
首先介绍一下应用容器化。想要将应用容器化，首先需要建一个dockerfile，引入一个jdk的包，把启动命令和启动脚本拉进去。然后还要写一个Java的编译的脚本，把Java编译的jar包结果拉进去。这个过程非常复杂，所以我们可以用一下Jib的插件。这个插件是maven的一个plugin，我只需要把这些配进去，指定成我的Image就足够了。
可以看到，我只需要把我的pom里添加一个对应的配置项依赖，通过一键maven的编译模式，它就可以在maven打包的过程中帮你构建完镜像，然后直接推送到远端仓库。这一切都只需要这一个命令就可以完成，而且一次性配置之后，未来你所有的镜像更新都可以自动化的去做，不需要再去写繁琐的dockerfile。
其次介绍一下无状态部署。刚才我们把镜像打出来了，这只是第一步，紧接着我们要让镜像run起来。我们可以基于K8s的deployment的模式，它是从K8s的官网上直接拉下来的。拉下来之后我们可以指定对应的应用名、镜像信息等等，这是K8s无法绕过去的，相对于说它需要配置这样的一个demo，当然也会有云厂商平台提供一个可视化的界面给你，它的底层配置的就是这样的一个yarml。
这是一个简单的例子，把deployment配置完之后，指定了刚才的镜像。同时我声明了一个service，这个service非常重要，它后面会作为from_end应用入口的配置，但它是一个Ingress网关。可以看到apply镜像之后，我们就可以在K8s体系上把这个环境run起来了。
这里做一个简单的测试，我引入一个curl的容器，同样我们可以用刚才curl的命令访问我新部署好的容器节点，可以看到它返回了hello world的数据信息。
综上，我们通过deployment的部署，可以在K8s上把容器run起来，同时它还可以对外提供服务，对外提供的服务我可以通过下面curl的命令进行调用。
最后介绍一下生命周期对齐。整体部署上了之后，大家都会进行多Pod部署，所以就会涉及到分批的行为。如果现在分了两批，且我希望我的业务中间是不中断的，这个时候就需要让K8s帮我们进行分批处理。因为K8s只知道进程起来了，所以我们需要让K8s感知到这个应用当前的状态是否startup了。然后还需要让K8s知道是否ready，以及是否存活。这是K8s提供的流程，那么怎么和Dubbo的流程相匹配呢？
上图右侧有一些Dubbo原生提供的ports信息，我们会对外发布这样的Dubbo的状态信息，可以让你和K8s的生命周期完整的对齐。
上图是一个例子。在整个应用启动的时候，这里sleep了20秒，然后配置了对应的Pro信息。
我们简单推测一下，我在前面设置了等待20秒，那么我的应用肯定要超过20秒才能起来。因为修改了代码，所以这里需要重新编译一下，用一键maven的编译模式直接推上去。接下来要把deployment apply进去，进去之后Pod的状态全都是not ready的，都是零的状态。
因为前面sleep了20秒的时候，Dubbo还没启动完，所以都是not ready的状态。我们等sleep的阶段过了，它就会变成ready的状态，然后再进行分批这就是生命周期对齐的过程。
所以K8s知道应用什么时候启动成功了，什么时候启动失败了，才能进行更好的调度。
五、云原生微服务可观测最佳实践 部署上去之后，我们还会涉及到整个应用的可观测。因为我们的应用可能部署了非常多节点，我需要感知应用的状态。
可观测体系包括Metrics体系和Tracing体系。Metrics体系包括几个指标，比如谷歌的四个环境指标，延迟、流量等等。对应到Dubbo，会提供QPS、RT等等指标，它都是在这样体系下的Metrics的最佳实践。</description></item><item><title>微服务最佳实践，零改造实现 Spring Cloud &amp; Apache Dubbo 互通</title><link>https://dubbo.apache.org/zh-cn/blog/2023/10/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E9%9B%B6%E6%94%B9%E9%80%A0%E5%AE%9E%E7%8E%B0-spring-cloud-apache-dubbo-%E4%BA%92%E9%80%9A/</link><pubDate>Sat, 07 Oct 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/10/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E9%9B%B6%E6%94%B9%E9%80%A0%E5%AE%9E%E7%8E%B0-spring-cloud-apache-dubbo-%E4%BA%92%E9%80%9A/</guid><description>本文以实际项目和代码为示例，一步一步演示如何以最低成本实现 Apache Dubbo 体系与 Spring Cloud 体系的互通，进而实现不同微服务体系的混合部署、迁移等，帮助您解决实际架构及业务问题。
背景与目标 如果你在微服务开发过程中正面临以下一些业务场景需要解决，那么这篇文章可以帮到您：
您已经有一套基于 Dubbo 构建的微服务应用，这时你需要将部分服务通过 REST HTTP 的形式（非接口、方法模式）发布出去，供一些标准的 HTTP 端调用（如 Spring Cloud 客户端），整个过程最好是不用改代码，直接为写好的 Dubbo 服务加一些配置、注解就能实现。 您已经有一套基于 Spring Cloud 构建的微服务体系，而后又构建了一套 Dubbo 体系的微服务，你想两套体系共存，因此现在两边都需要调用到对方发布的服务。也就是 Dubbo 应用作为消费方要调用到 Spring Cloud 发布的 HTTP 接口，Dubbo 应用作为提供方还能发布 HTTP 接口给 Spring Cloud 调用 出于一些历史原因，你正规划从一个微服务体系迁移到另外一个微服务体系，前提条件是要保证中间过程的平滑迁移。 对于以上几个场景，我们都可以借助 Dubbo3 内置的 REST 编程范式支持实现，这让 Dubbo 既可以作为消费方调用 HTTP 接口的服务，又可以作为提供方对外发布 REST 风格的 HTTP 服务，同时整个编码过程支持业界常用的 REST 编程范式（如 JAX-RS、Spring MVC 等），因此可以做到基本不改动任何代码的情况下实现 Dubbo 与 Spring Cloud 体系的互相调用。
关于这一部分更多的设计与理论阐述请参见这里的 博客文章。 关于 Dubbo REST 的更多配置方式请参见 rest 使用参考手册 示例一：Dubbo 调用 Spring Cloud 在已经有一套 Spring Cloud 微服务体系的情况下，演示如何使用 Dubbo 调用 Spring Cloud 服务（包含自动的地址发现与协议传输）。在注册中心方面，本示例使用 Nacos 作为注册中心，对于 Zookeeper、Consul 等两种体系都支持的注册中心同样适用。</description></item><item><title>政采云基于Dubbo的混合云数据跨网实践</title><link>https://dubbo.apache.org/zh-cn/blog/2023/10/07/%E6%94%BF%E9%87%87%E4%BA%91%E5%9F%BA%E4%BA%8Edubbo%E7%9A%84%E6%B7%B7%E5%90%88%E4%BA%91%E6%95%B0%E6%8D%AE%E8%B7%A8%E7%BD%91%E5%AE%9E%E8%B7%B5/</link><pubDate>Sat, 07 Oct 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/10/07/%E6%94%BF%E9%87%87%E4%BA%91%E5%9F%BA%E4%BA%8Edubbo%E7%9A%84%E6%B7%B7%E5%90%88%E4%BA%91%E6%95%B0%E6%8D%AE%E8%B7%A8%E7%BD%91%E5%AE%9E%E8%B7%B5/</guid><description>摘要：本文整理自政采云资深开发工程师王晓彬的分享。本篇内容主要分为四个部分：
一、项目背景 二、为什么叫高速公路 三、修路实践 四、未来规划 一、项目背景 我们有一个云岛业务叫政采云，它是政府的购物网站，类似于淘宝。政府采购会在政采云上做企业采购、政府采购的业务。
云岛中的&amp;quot;云&amp;quot;是指我们的云平台，云平台是我们公司自己部署的一套购物网站，它对应的是一套微服务框架。而&amp;quot;岛&amp;quot;是指，比如安徽或者山西它们都有自己的局域网，如果我们在它们那里也部署一套这个框架，就叫&amp;quot;岛&amp;quot;。我们的云主要是给浙江省和相关的区划用的。
我们的云和岛之间存在数据传输的问题，举个例子，比如我现在收到一个政府的公告，而这个公告肯定是全国性的。所以我可能会在云平台的管理平台上去录公告，再把它推送出去，这个时候云和岛之间就存在了一些数据的跨网。
云岛网络 对我们云平台来说，这个局域网是我们公司内部完全可控的。比如你要开个端口，很快就能开起来。导端它可能是局域网或者是私有网络，比如我们之前做了一个浙商银行的项目，它是完全隔离的一个岛。他们的安全策略和开端口的东西都是他们自己定义的，这就是我们云岛的业务结构。
混合云岛网络 上图是大概的数据链路图。云平台下面有分支机构、分公司，它们会对应一套业务的系统。政务云是我刚才说的省级（安徽省）或者市级（无锡市）对应的区块，隔离的政务云。私有部署是银行、国企、军队、政企等典型的混合云的网络架构。
混合云岛网络的特点 我们混合云网络架构的特点包括：
平台的一致性。我们部署在公有云、云平台、政务云、私有云上的那一套的代码是一样的。我们把一套代码部署在不同的地方就变成了多个平台。 网络连接与能力复用。我们会依赖一些第三方的能力，比如短信，但私有云上它的网络管控比较严，所以和第三方互通端口或者网络的流程就会比较复杂。这个时候我们希望去复用我们云平台的能力，这个时候他们之间又有一些数据的交互。 跨域访问迁移。 统一的平台管理。像我刚才举的例子，如果要发公告，我们希望可以在一个平台上就可以管理起来。而不是浙江发一条，安徽发一条，那样维护的成本也会比较高。 政企网络痛点 很多公司都会和政府打交道，政企网络有以下几个特点：
网络复杂。比如银行的网络，它们的安全性和内部的东西很复杂，流程的开通也比较多，需要你要经常去跑，跑完了之后发现有新的问题，又要去跑。
安全要求高。比如在开通端口的时候，我们需要去传数据，如果里面的那些序列化的协议不符合它们的规范，它们就会拿掉。这个时候给我们的业务其实是超时的，或者是那种通用的异常。而我们并不知道发生了什么，这就会带来未知的风险。
业务驱动运维。我们有了业务才会去部署，才会去做事情。我们就会多次、重复的投入，这就会导致人力、时间成本会比较高，私有部署的时候会更多。
现有方案 基于以上的痛点，我们做了两个方案。
第一个方案，基于Dubbo Filter的单向方案。这个方案的历史比较久一些，它有两个特点。
第一个特点，单向传输。它是从&amp;quot;岛&amp;quot;到&amp;quot;云&amp;quot;只有一个方向，它基于Dubbo Filter的原因是，我们公司内部的微服务都是通过Dubbo来调用的，所以我们是强依赖的来Dubbo的。所以做数据跨网的方案肯定会基于Dubbo的特性来做。
第二个特点，在本地部署业务的provider过滤器是运维上的负担。当导端需要把数据同步给云端的时候，也就是从岛端的业务Web传输到云端的业务provider。这个时候我必须在导端也部署一套业务的provider才可以。部署它的原因是它要拦截这个请求，然后把这个请求转发给部署在云平台的Dubbo网关。
但这个时候就会给我们带来负担。如果导端本来就有数据的入库就还好，因为provider本来就存在，但一些业务只是做跨网用的，没有本地的入库，那么这个时候业务的provider就是多余的了。
第二个方案，网状点对点方案。因为岛和岛之间需要网络互通，所以就会单独开通这个点和你需要传输的点之间的端口。开通之后我们就可以调用了，调用的形式可以用Dubbo。
这个方案有一个很明显的缺陷，线特别多，所以点和点之间开通的复杂度也很高，对后面的扩展可能也非常不利。
以上方案存在的问题包括单向传输、白名单开通成本高、平台维护成本高、公共功能的缺失。
基于以上的问题，我们做了一个新的方案，叫高速公路。
二、为什么叫高速公路 为什么叫告诉公路呢？主要因为我们想要达到的效果是：
只建一次，可复用。比如北京到上海的高速公路，它只要够宽，一条就够了。如果你是从上海到北京或者从杭州到北京，是可以复用的，不用单独再修建一条。
隧道机制。因为高速公路修建的地方不一定都在平原，可能会在河、海、山等等附近。如果我们在高速公路下面搭建一条隧道，这个时候对于司机来说就是无感的。我们的目的是一样的，如果你觉得政企网络很复杂，那么我们就帮你把它屏蔽掉，这样你也是无感的了。
考虑传输性能。如果每个业务部门都自己搭建一套传输链路，那么传输性能只要能承载自己的业务就够了，因为不一定要给别人用，或者给别人用了也是小范围的。但如果搭建的是一条可复用的链路，就必须考虑传输的性能了。
三、修路实践 接下来介绍一下我们在修建高速公路的时候遇到的一些问题以及具体的做法。我们在客户端接入上遇到了以下问题：
第一个问题，强依赖Dubbo。
第二个问题，透明传输，不改变使用Dubbo的方式。也就是我不需要自己写一些注解代替Dubbo，或者写一些API调用Dubbo。因为写了之后，一些新人可能并不能理解或者不能习惯，也不知道里面有什么坑。所以我们用原始的Dubbo来做可能会对用户更加无感。
第三个问题，接入灵活，支持多种形态。虽然我们强依赖Dubbo必须支持Dubbo，但我们也需要支持其他的形式，比如HTTP。但在接入之前，我们需要考虑接入灵活性的问题。
下面我们先介绍一下Dubbo的方式。Dubbo的客观接入主要有以下三种方式：
第一种，注解方式。使用@DubboReference提供的通用parameters参数，设置路由目标，可以达到方法粒度的路由。路由信息写在中间parameters那里，parameters是Dubbo给我们提供的通用参数的传递。
如果是正常的，我写了这个信息，Dubbo是不做任何处理的，因为这个东西对它来说没有含义。但因为你引入了高速公路的SDK，所以在你写了这个东西之后，我们就会去解析，拦截Dubbo的请求，把parameters里的参数抓起来做一些路由处理，这种形式其实没有改变Dubbo的使用方式。
第二种，配置中心指定。比如我们用的是阿波罗的配置中心，它完全可以把接入方式替换掉，parameters的信息在配置中心配置也可以，只要SDK可以支持就好。这种方式其实代码是完全侵入的，就是跟跨网之前和跨网之后没有任何区别。但最后发现我们的业务并不喜欢这种方式，首先因为阿波罗大家不喜欢用，其次不好理解。如果是一个新人看这个代码，他就会认为是在调本地的接口。
第三种，线程指定。当你在线程里指定了路由信息，下面再去调用的时候，这次调用就会走你的路由。如果再调用一次，它就会调回本地。因为基于线程的形式，在Dubbo的扩展里，它会在调用完成之后把线程信息清理掉。所以需要注意一下，如果你想多次调用，就需要写多次。如果不想写多次，你可以用上面这种方式，你只要在当前的been里，都是路由到上海。
接下来介绍一下高速公路的架构，刚才介绍点对点的方式，它的缺点是开通白名单比较复杂。现在我们的高速公路架构是一个新型的架构，所以它开通白名单的复杂度会低一点。
如上图所示，比如最左边的节点是上海，最上边的节点是安徽，我想从安徽到上海，这个时候中心网关就需要开通一个白名单。开完之后，这条链路就可以直接过去了。可以看到一共就六条线，所以它的复杂度也就下来了。
18:30上图是高速公路里最核心的架构图。
比如山西集群的APP1调APP2的时候，我想去调上海APP2，如果你什么都不做，它默认调的就是山西集群的APP2。如果你在APP调用的时候加了一些路由信息，放在山西集群APP1里的SDK就会把它的流量切走，切到山西集群的Dubbo网关。
之后Dubbo网关会通过HTTP的协议走统一网关，再通过HTTP的协议到上海集群的Dubbo网关。在这里会把路由信息拿到，包括调用的Service、方法、版本号、参数等等。然后通过泛化的形式调上海集群的APP1，最后返回，完成这次跨网的调用。
那么为什么要有Dubbo Proxy这个角色呢？为什么不直接从APP1切到统一网关？少一个步骤不好么？涉及到的原因有以下三点：
虽然这个图上只画了一个APP1，但实际上山西集群里的调用非常多。如果几百个应用都直接到统一网关，网关就需要建立很多的长链接，而统一网关的资源是有限的。
因为安全性的问题，可能每次调用都要走一下白名单来保证安全。这个时候如果加了一个Dubbo Proxy，就可以去收敛IP。岛内不用和Dubbo Proxy交互，因为它们是同一个环境，不用考虑安全的问题。当Dubbo Proxy请求到网关之后，因为网关和统一网关之间只有一条链接，所以IP是收敛的。
还有一个是功能的收敛，当后面要做升级的时候，如果更新SDK，就需要每个应用都升级，这就需要推动业务做升级，做起来会比较痛苦。所以我们希望把升级功能全放在一个应用里，对业务功能无感，连升级SDK都不需要。当然因为SDK就做了一件事情，就是切换路由，基本不需要更新。
所以对于业务来说，它也解放了。我把它理解成是一个功能上的收益。这个模式叫分布式运行时，在现在也比较流行。我们可以把它理解成Dapper，把一些比较麻烦的操作放到公共的服务里，留给业务的SDK是很纯粹的。
另外，为什么要用HTTP协议呢？它也并不是很高效的协议。而Dubbo协议中的Dubbo2其实也是比较惊艳的，除了一些模糊全部都是数据。这样的话其实我们后面是可以考虑把HTTP升级掉，让它的性能更快一点。
现在用HTTP协议的原因是，它是一个标准的协议，中间可能会通过很多设备，虽然我们这里只画了一个。HTTP协议是没有任何障碍的，如果用Dubbo协议，还需要一个个打通。
为了实现这个架构，Dubbo本身并不能直接用。因为Dubbo没有提供跨网的特性，所以我们需要从Dubbo层面解决我们碰到的问题。
在动态IP切换方面，其实Dubbo是支持的，但因为这个特性比较新，所以也会出现一些问题。它的支持程度是部分支持，比如在最开始的时候Dubbo2不支持，Dubbo3支持。此外，还会有一些bug。
在404扩展方面，对于HTTP来说，你要调一个接口，但这个接口不存在，就会返回给前端一个404的报错。比如当我们把流量从APP1切到Dubbo Proxy的时候，Dubbo Proxy其实是Dubbo的一个应用，它引入了一个Dubbo的jar包，它是Dubbo的一个空应用。这个流量到Dubbo的网关后，它不能识别，它的功能是要把它转发出去。这个时候我们就需要加入这个扩展。</description></item><item><title>CoC Asia 2023 大会精彩回顾</title><link>https://dubbo.apache.org/zh-cn/blog/2023/08/25/coc-asia-2023-%E5%A4%A7%E4%BC%9A%E7%B2%BE%E5%BD%A9%E5%9B%9E%E9%A1%BE/</link><pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/08/25/coc-asia-2023-%E5%A4%A7%E4%BC%9A%E7%B2%BE%E5%BD%A9%E5%9B%9E%E9%A1%BE/</guid><description>以下包含本期演讲的完成文字稿内容与现场精彩瞬间，更多 ppt、视频录像可关注 &amp;ldquo;apachedubbo&amp;rdquo; 微信公众号获取。
基于 Triple 协议实现 Web、移动端、后端微服务全面打通 手把手教你部署 Dubbo 应用到 Kubernetes - Apache Dubbo &amp;amp; Kubernetes最佳实践 Apache Dubbo 云原生可观测性的探索与实践 Opensergo &amp;amp; Dubbo 微服务治理最佳实践 Seata 微服务架构下的一站式分布式事务解决方案 启动速度提升 10 倍：Apache Dubbo-静态化 GraalVM Native Image 深度解析 政采云基于 Dubbo 的混合云数据跨网实践 工商银行分布式建设及转型实践 Apache Dubbo 社区骨干成员及 Apache Board Member, Justin Mclean 合影
Apache Dubbo 社区骨干与 Apache Member 交流合影
华钟明，Apache Dubbo PMC Member，杭州有赞科技有限公司中间件技术专家，《Apache Dubbo 静态化 GraalVM Native Image 解决方案与实践》
宋小生，Apache Dubbo Committer，平安壹钱包中间件资深工程师，《Apache Dubbo 云原生可观测性探索与实践》
陈有为，Apache Dubbo PMC Member，陌陌研发工程师，《基于 Triple 协议实现WEB、移动端、后端服务全面打通》</description></item><item><title>Dubbo 微服务专题论坛 - 8月19日北京ApacheCon大会不见不散</title><link>https://dubbo.apache.org/zh-cn/blog/2023/08/07/dubbo-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%93%E9%A2%98%E8%AE%BA%E5%9D%9B-8%E6%9C%8819%E6%97%A5%E5%8C%97%E4%BA%ACapachecon%E5%A4%A7%E4%BC%9A%E4%B8%8D%E8%A7%81%E4%B8%8D%E6%95%A3/</link><pubDate>Mon, 07 Aug 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/08/07/dubbo-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%93%E9%A2%98%E8%AE%BA%E5%9D%9B-8%E6%9C%8819%E6%97%A5%E5%8C%97%E4%BA%ACapachecon%E5%A4%A7%E4%BC%9A%E4%B8%8D%E8%A7%81%E4%B8%8D%E6%95%A3/</guid><description>Dubbo 微服务专题论坛将于8月19日下午在北京丽亭华苑酒店举行，作为本次 CommunityOverCode Asia 2023（原 ApacheCon Asia）大会上的重磅议题，我们将以 Apache Dubbo 为中心展开，给大家带来开源微服务技术方向发展、云原生微服务选型、企业实践分享等精彩内容！
打开 官网购票链接，输入 cocasia 优惠码可八折购票！
作为 Apache 软件基金会（ASF）的官方全球系列大会，每年的 CommunityOverCode Asia 都吸引着来自全球各个层次的参与者、社区共同探索 &amp;ldquo;明天的技术&amp;rdquo;。8 月 18 日至 20 日，即将强势来袭的 CommunityOverCode Asia 2023 上，大家可以近距离感受来自 Apache 项目的最新发展和新兴创新。</description></item><item><title>GLCC x Apache Dubbo编程夏令营报名启动</title><link>https://dubbo.apache.org/zh-cn/blog/2023/07/05/glcc-x-apache-dubbo%E7%BC%96%E7%A8%8B%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%8A%A5%E5%90%8D%E5%90%AF%E5%8A%A8/</link><pubDate>Wed, 05 Jul 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/07/05/glcc-x-apache-dubbo%E7%BC%96%E7%A8%8B%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%8A%A5%E5%90%8D%E5%90%AF%E5%8A%A8/</guid><description>背景介绍 GitLink编程夏令营（GLCC），是在CCF中国计算机学会指导下，由CCF开源发展委员会（CCF ODC）举办的面向全国高校学生的暑期编程活动。活动将覆盖近千所高校，并联合各大开源基金会、开源企业、开源社区、开源专家，旨在鼓励青年学生通过参加真实的开源软件开发，提升自身技术能力，为开源社区输送优秀人才。为青年学生提供开放友好的交流平台，希望进一步推动国内开源社区的繁荣发展。
报名方式 此次报名仅限 GLCC “无奖金项目”。具体请在此查看 项目详情与报名方式。
Apache Dubbo 项目报名截止日期：2023-07-30
如有更多问题，请扫描官方公众号咨询：</description></item><item><title>走向 Native 化：Spring&amp;Dubbo AOT 技术示例与原理讲解</title><link>https://dubbo.apache.org/zh-cn/blog/2023/06/28/%E8%B5%B0%E5%90%91-native-%E5%8C%96springdubbo-aot-%E6%8A%80%E6%9C%AF%E7%A4%BA%E4%BE%8B%E4%B8%8E%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3/</link><pubDate>Wed, 28 Jun 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/06/28/%E8%B5%B0%E5%90%91-native-%E5%8C%96springdubbo-aot-%E6%8A%80%E6%9C%AF%E7%A4%BA%E4%BE%8B%E4%B8%8E%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3/</guid><description>Java 应用在云计算时代面临“冷启动”慢、内存占用高、预热时间长等问题，无法很好的适应 Serverless 等云上部署模式，GraalVM 通过静态编译、打包等技术在很大程度上解决了这些问题，同时针对 GraalVM 的一些使用限制，Spring 和 Dubbo 等主流框架也都提供了相应的 AOT 解决方案。
本文我们将详细分析 Java 应用在云时代面临的挑战，GraalVM Native Image 是如何解决这些问题，GraalVM 的基本概念与工作原理，最后我们通过一个 Spring6 + Dubbo3 的微服务应用示例演示了如何将一个普通微服务应用进行静态化打包。
本文主要分为以下四个部分展开
首先我们会先看一下在云计算快速发展的当下，云上应用应该具备的特点，Java 应用在云上所面临的挑战有哪些。 其次，我会介绍一下 GraalVM，什么是 Native Image，如何通过 GraalVM 对 Java 应用进行静态化打出 Native Image 可执行的二进制程序。 第三部分，我们知道 GraalVM 的使用是有一定限制的，比如 Java 的反射等动态特性是不被支持的，因此我们需要提供特殊的 Metadata 配置来绕过这些限制，在这一部分我们会讲解如何加入引入 AOT Processing 来实现自动化的 Metadata 配置，包括 Spring6 框架中 AOT 处理、Dubbo3 框架的 AOT 处理等。 最后，我们将通过一个 Spring6+Dubbo3 的应用示例，来演示如何将这么一个 Java 应用进行静态化打包。 Java 应用在云时代所面临的挑战 首先，我们先看一下云计算时代的应用特点，以及 Java 在云时代所面临的挑战。从各个统计机构给出的数据来看，Java 语言仍然是当今最受开发者欢迎的编程语言之一，仅次于一些脚本开发语言。使用 Java 语言可以非常高效的开发业务应用，丰富的生态使得 Java 具有非常高的开发和运行效率，有无数的应用基于 Java 语言开发。</description></item><item><title>[Google Paper] 面向云时代的应用开发新模式</title><link>https://dubbo.apache.org/zh-cn/blog/2023/05/26/google-paper-%E9%9D%A2%E5%90%91%E4%BA%91%E6%97%B6%E4%BB%A3%E7%9A%84%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%96%B0%E6%A8%A1%E5%BC%8F/</link><pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/05/26/google-paper-%E9%9D%A2%E5%90%91%E4%BA%91%E6%97%B6%E4%BB%A3%E7%9A%84%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%96%B0%E6%A8%A1%E5%BC%8F/</guid><description>本文翻译自发表在以下地址的论文：https://serviceweaver.dev/assets/docs/hotos23_vision_paper.pdf
原文作者(Authors): Sanjay Ghemawat, Robert Grandl, Srdjan Petrovic, Michael Whittaker, Parveen Patel, Ivan Posva, Amin Vahdat
转载或发布请遵循原文许可： Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for thirdparty components of this work must be honored.</description></item><item><title>Apache Dubbo 开源之夏 2023，贡献社区赢取 12000 奖金</title><link>https://dubbo.apache.org/zh-cn/blog/2023/05/15/apache-dubbo-%E5%BC%80%E6%BA%90%E4%B9%8B%E5%A4%8F-2023%E8%B4%A1%E7%8C%AE%E7%A4%BE%E5%8C%BA%E8%B5%A2%E5%8F%96-12000-%E5%A5%96%E9%87%91/</link><pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/05/15/apache-dubbo-%E5%BC%80%E6%BA%90%E4%B9%8B%E5%A4%8F-2023%E8%B4%A1%E7%8C%AE%E7%A4%BE%E5%8C%BA%E8%B5%A2%E5%8F%96-12000-%E5%A5%96%E9%87%91/</guid><description>欢迎在校同学们参与Apache Dubbo开源之夏，社区导师手把手让你的代码被社会广泛复用，来赚取最高12000奖金，可推荐入职/实习你心意公司，又拿钱又成长又有价值，你还等什么呢？报名马上截止，快来参与Apache Dubbo开源之夏。
OSPP 开源之夏是什么？ 开源之夏是由“开源软件供应链点亮计划”发起并长期支持的一项暑期开源活动，旨在鼓励在校学生积极参与开源软件的开发维护，促进优秀开源软件社区的蓬勃发展，培养和发掘更多优秀的开发者。 活动联合国内外各大开源社区，针对重要开源软件的开发与维护提供项目任务，并面向全球高校学生开放报名。 学生可在本活动中自主选择感兴趣的项目任务进行申请，并在中选后获得该开源项目资深维护者（社区导师）亲自指导的机会，完成项目并贡献给社区后，参与学生还将获得开源之夏活动奖金和结项证书。
Apache Dubbo 项目简介 Apache Dubbo 是国内最具影响力的开源软件项目之一，由阿里巴巴贡献开源，是支撑阿里双十一百万集群、万亿次服务调用的核心框架，目前 Dubbo 已捐献给享誉世界的 Apache 软件基金会 (ASF)。
参与Apache Dubbo开源之夏条件 本活动面向年满 18 周岁在校学生。 暑期即将毕业的学生，只要在申请时学生证处在有效期内，就可以提交申请。 海外学生可提供录取通知书、学生卡、在读证明等文件用于证明学生身份。 参与Apache Dubbo开源之夏，你能获得什么？ **【你的代码被社会广泛复用】**你的代码可能会运行在上万家企业核心业务逻辑中，帮助企业解决问题。 **【赢得最高12000奖金】**奖金总额根据项目难度分为进阶 12000 元、基础 8000 元（注：奖金数额为税前人民币金额） **【社区核心人员辅导快速成长】**只要你报名被选中，每个题目的导师会精心手把手教你融入社区，帮助你完成题目的设计以及最终的落地。 **【推荐入职/实习】**在本次编程之夏项目中表现优秀同学，可推荐入职/实习 你心意的公司工作。 **【额外获得社区礼包】**所有参与本次编程之夏项目的同学，均可获得Apache Dubbo社区大礼包。 百分百有奖品拿哦，现在唯一的问题是时间不多了，赶紧上车报名，截止报名时间是6月4日，6个核心题目，快点来报名参与Apache Dubbo编程之夏吧。
课题&amp;amp;报名方式 点开Apache Dubbo开源之夏的链接 选择你喜欢的题目：
IDL 管理平台 API 管理平台 基于 Kubernetes 的集成测试体系建设 服务 JSON 序列化兼容性校验 将 Dubbo 工程结构重构为 Gradle 项目 自动化性能测试方案 移除对 jprotoc 的依赖 Node.js HTTP/2 协议实现 实现 Dubbo Rust 的路由模块 具体流程请参考 学生指南。</description></item><item><title>引言</title><link>https://dubbo.apache.org/zh-cn/blog/2023/04/28/%E5%BC%95%E8%A8%80/</link><pubDate>Fri, 28 Apr 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/04/28/%E5%BC%95%E8%A8%80/</guid><description>引言 服务指标统计体系是 Dubbo 可观测能力的重要组成部分。 dubbo-metrics 指标模块旨在将 dubbo 内部零散的 Metrics 相关类综合到一个单独的模块中，提供一套更加完善、全面、可拓展、解耦合的指标采样-统计-导出解决方案。
dubbo-metrics 模块包括：
dubbo-metrics-api 公用接口包 dubbo-metrics-prometheus 普罗米修斯适配包 dubbo-metrics-metadata 元数据中心指标监控包 dubbo-metrics-registry 注册中心指标监控包 dubbo-metrics-config-center 配置中心指标监控包 dubbo-metrics-default 接口默认实现包，提供dubbo内部核心指标的监控功能 在设计上，dubbo-metrics 深入应用事件驱动编程思想，总体体现出下图的事件处理链路：
在拓展上，dubbo-metrics 抽象了一套指标导出接口与抽象实现，可实现兼容多种指标统计监控中心，默认提供了普罗米修斯实现。</description></item><item><title>1-指标样本的收集与存储</title><link>https://dubbo.apache.org/zh-cn/blog/2023/04/28/1-%E6%8C%87%E6%A0%87%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%94%B6%E9%9B%86%E4%B8%8E%E5%AD%98%E5%82%A8/</link><pubDate>Fri, 28 Apr 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/04/28/1-%E6%8C%87%E6%A0%87%E6%A0%B7%E6%9C%AC%E7%9A%84%E6%94%B6%E9%9B%86%E4%B8%8E%E5%AD%98%E5%82%A8/</guid><description>一、指标样本的收集与存储 指标样本收集 指标收集器（Collector）是指标对外导出的入口。最终导出到指标统计中心的指标采样实际均直接来源于各个指标采样器。因此，我们将从各个收集器实现开始，分析 dubbo-metrics 模块是如何工作的。
指标收集操作定义在 MetricsCollector （指标采集器，SPI）接口中，可以通过它的实现收集某一类的指标样本（MetricSample）。它主要有以下实现，对应着不同类型的指标：
ConfigCenterMetricsCollector 配置中心操作相关指标收集器 ，收集配置信息的变化次数 MetadataMetricsCollector 元数据中心操作相关指标收集器，收集提供者、消费者对元数据中心操作（推送数据、拉取数据）情况的计数、耗时统计。 RegistryMetricsCollector 注册中心相关操作指标收集器，收集应用级、接口级服务注册成功、失败、耗时的相关计数。 DefaultMetricsCollector 默认指标收集器，内置多种采样器来完成不同类型的内部指标采样。 HistogramMetricsCollector 直方图指标收集器，利用 micrometer API 处理直方图类型的指标，它的实现较为特殊。 配置中心 、元数据、服务注册及默认指标收集器均实现自混合指标收集器（CombMetricsCollector）。混合指标收集器实现了 ApplicationMetricsCollector 、ServiceMetricsCollector 、MethodMetricsCollector 三个接口（定义按应用名收集、按应用名-服务名收集和按应用-方法名收集指标的操作），因此它们可以进行应用、服务和方法三个层面的指标收集工作。
默认指标收集器的特点是通过内部的指标采样器（MetricsSampler）完成指标事件的处理操作，而不是其它收集器的指标监听器（MetricsListener）
直方图指标收集器则负责收集直方图类型的指标。它利用直方图度量寄存器（HistogramMetricRegister）借助 micrometer API 完成直方图样本的采集。直方图类型包括百分位数、服务水平目标、最小预期值、最大预期值、统计数据分布有效期等。
Collector的继承关系：
可以看出，每个指标收集器都具有来自 MetricsListener 的监听指标事件的能力。为什么指标收集器本身需要监听指标事件？ 在后文中，我们将讨论指标收集器是如何利用内置的子转发器（SubDispatcher）转发指标事件，并完成计数处理的。
指标样本存储 前文中，我们了解了指标收集的入口是指标收集器（Collector）。那么各个收集器从哪里收集指标样本？
对于配置中心、元数据中心、 注册中心的指标收集器：
它们分别负责采集三大中心模块的指标，均继承于混合数据收集器（CombMetricsCollector），而混合数据收集器中实现了 export 方法 。
混合数据收集器内部有一个基本数据聚合器（BaseStatComposite），它实现了 MetricsExport 接口，该接口定义了指标导出操作，混合数据收集器则利用它的 export 方法导出指标。
基本数据聚合器是一个抽象类，内有三个属性：ApplicationStatComposite 、ServiceStatComposite 和 RtStatComposite 。它们的作用：
ApplicationStatComposite 应用数据聚合器，应用程序级别相关事件的计数 ，根据指标Key（ MetricsKey ）和应用名统计指标，提供计数递增操作 ServiceStatComposite 服务数据聚合器，服务级别相关事件的计数，根据指标Key、应用名和服务名统计指标，提供计数递增操作 MethodStatComposite 方法数据聚合器，方法级别相关事件的计数，存储各方法RPC调用相关计数。 RtStatComposite，Rt（Response Time，响应时间）数据聚合器，包括应用级别和服务级别。根据应用名、服务名、注册的指标名及相应相应时间统计指标，提供添加操作。 对于以上四个聚合器，他们的职责就是存储某一类型的采样样本。
基本数据聚合器 （BaseStatComposite） 对这三个子聚合器的操作进行了简单整合，统一提供给外界。而混合指标收集器（CombMetricsCollector） 也基本保留了内部基本数据聚合器的所有操作，将其封装为 increment、setNum、addRt 三个方法（及它们的重载，分别收集应用级数据和服务级数据）向上提供。外部组件可以直接调用这些收集器完成指标更新操作。</description></item><item><title>2-指标收集器的指标采集流程</title><link>https://dubbo.apache.org/zh-cn/blog/2023/04/28/2-%E6%8C%87%E6%A0%87%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E6%8C%87%E6%A0%87%E9%87%87%E9%9B%86%E6%B5%81%E7%A8%8B/</link><pubDate>Fri, 28 Apr 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/04/28/2-%E6%8C%87%E6%A0%87%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E6%8C%87%E6%A0%87%E9%87%87%E9%9B%86%E6%B5%81%E7%A8%8B/</guid><description>二、指标收集器的指标采集流程 在前文中，我们了解了指标收集器（Collector）最终收集的数据只有三个来源：
实现自混合指标收集器（CombMetricsCollector） 的元数据指标收集器（MetadataMetricsCollector）和注册中心指标收集器（RegistryMetricsCollector），它们的样本均存储在内置的基本数据聚合器中。具体来说，是基本数据聚合器下的四个子数据聚合器中：
DefaultMetricsCollector 默认指标收集器，它的样本不仅来自于指标事件，还来自其下采样器（Sampler） 中，用于Dubbo核心模块的采样。
HistogramMetricsCollector 直方图指标收集器，由于采样数据的特殊性，它的样本直接以 Map 存储在内部。
接下来，我们需要明确它们存储的指标是如何添加进去的。
1，服务治理模块的指标采集流程 通过之前的分析，我们知道服务治理模块的指标采集器均实现自混合指标收集器（CombMetricsCollector）。它对基本数据聚合器（BaseStatComposite） 的大部分方法做了封装。基本数据聚合器又封装了四个负责存储不同类型指标采样的子聚合器。
这四个子聚合器包括：
ApplicationStatComposite ServiceStatComposite MethodStatComposite RtStatComposite 实际上，元数据、注册中心指标收集器更新、添加指标的操作都是通过混合指标收集器暴露的方法进行。而具体的，是通过 setNum、increment、addRt 这三个方法（及它们的重载）进行操作。
//CombMetricsCollector ... private final BaseStatComposite stats; ... @Override public void setNum(MetricsKey metricsKey, String applicationName, String serviceKey, int num) { this.stats.setServiceKey(metricsKey, applicationName, serviceKey, num); } @Override public void increment(String applicationName, MetricsKey metricsKey) { this.stats.incrementApp(metricsKey, applicationName, SELF_INCREMENT_SIZE); } public void increment(String applicationName, String serviceKey, MetricsKey metricsKey, int size) { this.</description></item><item><title>3-指标监听注册梳理</title><link>https://dubbo.apache.org/zh-cn/blog/2023/04/28/3-%E6%8C%87%E6%A0%87%E7%9B%91%E5%90%AC%E6%B3%A8%E5%86%8C%E6%A2%B3%E7%90%86/</link><pubDate>Fri, 28 Apr 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/04/28/3-%E6%8C%87%E6%A0%87%E7%9B%91%E5%90%AC%E6%B3%A8%E5%86%8C%E6%A2%B3%E7%90%86/</guid><description>三、指标监听注册梳理 在前一章中，我们了解了不同收集器中的指标样本是如何被监听器添加进去的。接下来，我们将归纳指标监听器 的创建位置，及它们对应统计的指标。
通过之前的分析，我们已经知道指标 注册事件多播器（RegistryMetricsEventMulticaster）中定义了并绑定了服务注册相关的指标。这种绑定操作同样存在于其它几个简单指标事件多播器（SimpleMetricsEventMulticaster）的几个实现中。
转发器注册 RegistrySubDispatcher （服务注册指标转发器）注册了服务注册相关指标：
应用级实例注册成功/失败/总数计数 （APPLICATION_REGISTER_&amp;hellip;) 应用级服务接口订阅成功/失败/总数计数 （APPLICATION_SUBSCRIBE_&amp;hellip;) 服务级注册成功/失败/总数计数 （SERVICE_REGISTER_&amp;hellip;） 特殊的 APPLICATION_NOTIFY_FINISH 和 APPLICATION_DIRECTORY_POST （应用服务目录变化次数） MetadataSubDispatcher（元数据指标转发器）注册应用元数据相关指标
应用推送元数据相关计数 （APPLICATION_PUSH_&amp;hellip;)
应用订阅元数据相关计数 （APPLICAITON_SUBSCRIBE_&amp;hellip;）
服务订阅元数据相关计数 （SERVICE_SUBSCRIBE_&amp;hellip;）
ConfigCenterSubDispatcher (配置中心指标转发器) 注册配置中心配置更新次数指标
配置中心推送新配置次数 （CONFIGCENTER_METRIC_TOTAL） DefaultSubDispatcher (默认转发器) 注册核心RPC调用次数指标
请求次数 （METRIC_REQUESTS） 请求成功次数（METRIC_REQUESTS_SUCCEED） 请求失败次数（METRIC_REQUEST_BUSINESS_FAILED） MetricsDispatcher
MetricsDispatcher 较为特殊，它负责 ApplicationModel 下所有 MetricsCollector（前文中提到的指标收集器） 的初始化注册工作，并将它们添加到自己的监听器列表中。
public class MetricsDispatcher extends SimpleMetricsEventMulticaster { @SuppressWarnings({&amp;#34;rawtypes&amp;#34;}) public MetricsDispatcher(ApplicationModel applicationModel) { ScopeBeanFactory beanFactory = applicationModel.getBeanFactory(); ExtensionLoader&amp;lt;MetricsCollector&amp;gt; extensionLoader = applicationModel.getExtensionLoader(MetricsCollector.class); if (extensionLoader != null) { List&amp;lt;MetricsCollector&amp;gt; customizeCollectors = extensionLoader .</description></item><item><title>4-指标转换与导出</title><link>https://dubbo.apache.org/zh-cn/blog/2023/04/28/4-%E6%8C%87%E6%A0%87%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%AF%BC%E5%87%BA/</link><pubDate>Fri, 28 Apr 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/04/28/4-%E6%8C%87%E6%A0%87%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%AF%BC%E5%87%BA/</guid><description>四、指标转换与导出 本章主要梳理指标收集完成后，向外部收集器导出的流程。
通过之前的分析，我们知道不同类型指标的收集分别由各个 Collector 实现进行。它们底层的 MetricsCollector 接口定义了指标导出的操作。
@SPI public interface MetricsCollector&amp;lt;E extends TimeCounterEvent&amp;gt; extends MetricsLifeListener&amp;lt;E&amp;gt; { default boolean isCollectEnabled() { return false; } /** * Collect metrics as {@link MetricSample} * * @return List of MetricSample */ List&amp;lt;MetricSample&amp;gt; collect(); } 而指标报告器 (MetricsReporter) 的实现会定时调用Collector 的 collect 方法，更新并导出指标数据。
public interface MetricsReporter { //初始化 void init(); //刷新统计数据，定时调用collect() void refreshData(); //获取指标数据 String getResponse(); //获取带指标名的指标样本（单个指标） default String getResponseWithName(String metricsName) { return null; } } 指标报告器有两个实现：DefaultMetricsReporter 和 PrometheusMetricsReporter，它们都实现自 AbstractMetricsRepoter，并使用它的指标刷新逻辑 (refreshData方法)。</description></item><item><title>精进云原生 - Dubbo 3.2 正式发布</title><link>https://dubbo.apache.org/zh-cn/blog/2023/04/15/%E7%B2%BE%E8%BF%9B%E4%BA%91%E5%8E%9F%E7%94%9F-dubbo-3.2-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</link><pubDate>Sat, 15 Apr 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/04/15/%E7%B2%BE%E8%BF%9B%E4%BA%91%E5%8E%9F%E7%94%9F-dubbo-3.2-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</guid><description>背景介绍 Apache Dubbo 是一款 RPC 服务开发框架，用于解决微服务架构下的服务治理与通信问题，官方提供了 Java、Golang 等多语言 SDK 实现。使用 Dubbo 开发的微服务原生具备相互之间的远程地址发现与通信能力， 利用 Dubbo 提供的丰富服务治理特性，可以实现诸如服务发现、负载均衡、流量调度等服务治理诉求。Dubbo 被设计为高度可扩展，用户可以方便的实现流量拦截、选址的各种定制逻辑。
Rest 协议支持 1. Why Rest？ 随着移动互联网的普及，越来越多的应用程序需要与不同的系统进行集成。而这些系统可能使用不同的通信协议，这就需要应用程序能够灵活地适应各种协议。Rest 协议正是一种非常灵活的协议，它使用 HTTP 进行通信，可以与几乎任何系统进行集成。
在过去，RPC框架通常使用二进制协议进行通信，这种协议非常高效，但不够灵活。相比之下，Rest协议使用HTTP进行通信，更方便与其他系统集成，也更容易与现代化的Web和移动应用程序集成。
除了灵活性，Rest协议还具有易读性和易用性。使用Rest协议，开发人员可以使用通用的HTTP工具（例如cURL或Postman）测试和调试服务，而不需要特定的工具。此外，由于Rest协议使用标准的HTTP方法（例如GET、POST、PUT和DELETE），因此开发人员可以更容易地理解和使用服务。
2. How To？ 在之前的 Dubbo 版本中，也提供了 Rest 协议的支持，但存在以下问题：
仅支持 JAX-RS 注解域，相较于采用度更高的 Spring Web 注解，复杂度更高
需要依赖众多外部组件，如 Resteasy、tomcat、jetty 等，才能正常工作，极大地增加了使用成本。
因此，在 Dubbo 3.2 版本中，我们引入了 Spring Web 注解域的支持以及 Rest 协议的原生支持，无需依赖任何外部组件。
最直观的区别是，如果你升级到了 Dubbo 3.2，通过 Spring Web 发布的服务也可以直接通过 Dubbo 来发布。这一切只需要将 @Controller 注解改成 @DubboService 注解即可。
此外，对于原来使用 Spring Boot 或者 Spring Cloud 作为服务拆分的用户，也可以基于本功能平滑地迁移到 Dubbo 上来，以极低的成本获得 Dubbo 强大的能力。</description></item><item><title>2022 年度总结与 2023 新年规划</title><link>https://dubbo.apache.org/zh-cn/blog/2023/02/23/2022-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8E-2023-%E6%96%B0%E5%B9%B4%E8%A7%84%E5%88%92/</link><pubDate>Thu, 23 Feb 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/02/23/2022-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8E-2023-%E6%96%B0%E5%B9%B4%E8%A7%84%E5%88%92/</guid><description>
2022 年度总结 1 Dubbo 开源 12 周年 50k+ star，30k fork，1000+ Contributor
2 Dubbo3 里程碑 实现规模化生产检验 阿里巴巴核心微服务集群实现从 HSF 到 Dubbo3 的全面升级，顺利支撑双十一、双十二万亿级服务调用
发力多语言生态 具备生产可用条件 Java、Go
从孵化走向成熟 Rust、Node.js、Python
3 核心技术 应用级服务发现 HTTP/2 协议 流量管控升级 可观测性 自适应负载均衡 Proxyless Mesh Spring Boot3 &amp;amp; Spring6
4 新晋 Committers&amp;amp;PMC 本年度社区共发展 Committer 13 位，PMC 4 位
2023 新年规划 官网与文档体验全面提升 Go、Node.js、Rust 等多语言体系建设 全面提升整体可观测性 Dubbo Admin 一站式服务运维管控平台 Dubbo Mesh 走向成熟 提升 HTTP 开发体验，补全 Web 互通 打造 gRPC over Dubbo 最佳实践 完善的认证鉴权体系</description></item><item><title>一文帮你快速了解 Dubbo 核心能力</title><link>https://dubbo.apache.org/zh-cn/blog/2023/02/23/%E4%B8%80%E6%96%87%E5%B8%AE%E4%BD%A0%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3-dubbo-%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B/</link><pubDate>Thu, 23 Feb 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/02/23/%E4%B8%80%E6%96%87%E5%B8%AE%E4%BD%A0%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3-dubbo-%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B/</guid><description>Dubbo 简介 一句话定义 Apache Dubbo 是一款微服务开发框架，它帮助解决微服务开发中的通信问题，同时为构建企业级微服务的提供服务治理能力，Dubbo 不绑定编程语言，我们的目标是为所有主流语言提供对等的微服务开发体验。 基本架构 Dubbo 从架构图上分为数据面和控制面。在数据面，使用 Dubbo 开发的微服务进程间基于 RPC 协议通信。DubboAdmin 控制面作为服务治理的抽象入口，由一系列可选的服务治理组件构成，负责 Dubbo集群的服务发现、流量管控策略、可视化监测。
行业应用 Dubbo 设计用于解决阿里巴巴内部大规模 微服务集群实践难题，当前已被广泛应用于几乎所有行业的微服务实践中。
以阿里巴巴为例，在 2021 年，阿里巴巴基于内部多年 HSF 框架实践积累，面向云原生架构设计了下一代微服务框架 Dubbo3，用于解决性能、治理升级、服务网格等一系列问题；截止目前，阿里巴巴已全面完成从 HSF到 Dubbo3 的迁移，核心业务都跑在开源 Dubbo3 之上。
Dubbo 到底提供了哪些核心能力？ 提供微服务抽象与框架 首先，Dubbo 作为服务开发框架解决了业务应用中微服务定义、暴露、通信与治理的问题，为业务应用开发定义了一套微服务编程范式。 具体来说，Dubbo 为业务应用提供了微服务开发API、RPC 协议、服务治理三大核心能力，让开发者真正的专注业务逻辑开发。
Dubbo 不是应用框架的替代者，它可以很好的工作在每种语言的主流编程框架之上，以 Java 为例，Dubbo 可以很好的与 Spring 协作，并在此基础上提供服务定义、微服务编程、服务发现、负载均衡、流量管控等能力。
提供灵活的通信协议切换能力 在通信方面，Dubbo 区别于其他 RPC 框架的是它不绑定特定协议，你可以在底层选用 HTTP./2、TCP、gRPC、REST、Hessian 等任意通信协议，同时享受统一的 API、以及对等的服务治理能力。
一切皆可扩展 Dubbo 的另一个优势在于其可扩展性设计，从流量管控、协议编码、诊断调优、再到服务治理，你都可以去扩展，满足企业级微服务开发与运维的所有诉求。
丰富的生态 基于扩展能力 Dubbo 官方提供了丰富的生态适配，涵盖了所有主流的开源微服务组件。
服务网格 对于服务网格架构，Dubbo也可以轻松接入原生 Istio 体系； 在数据面支持与 Envoy 部署的 Proxy 模式，也支持无 Envoy 的 Proxyless 模式，提供更灵活的数据面选择。</description></item><item><title>指标埋点</title><link>https://dubbo.apache.org/zh-cn/blog/2023/02/20/%E6%8C%87%E6%A0%87%E5%9F%8B%E7%82%B9/</link><pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/02/20/%E6%8C%87%E6%A0%87%E5%9F%8B%E7%82%B9/</guid><description>概述 1. 指标接入说明 2. 指标体系设计 Dubbo的指标体系，总共涉及三块，指标收集、本地聚合、指标推送
指标收集：将Dubbo内部需要监控的指标推送至统一的Collector中进行存储 本地聚合：指标收集获取的均为基础指标，而一些分位数指标则需通过本地聚合计算得出 指标推送：收集和聚合后的指标通过一定的方式推送至第三方服务器，目前只涉及Prometheus 3. 结构设计 移除原来与 Metrics 相关的类 创建新模块 dubbo-metrics/dubbo-metrics-api、dubbo-metrics/dubbo-metrics-prometheus，MetricsConfig 作为该模块的配置类 使用micrometer，在Collector中使用基本类型代表指标，如Long、Double等，并在dubbo-metrics-api中引入micrometer，由micrometer对内部指标进行转换 4. 数据流转 5. 目标 指标接口将提供一个 MetricsService，该 Service 不仅提供柔性服务所的接口级数据，也提供所有指标的查询方式，其中方法级指标的查询的接口可按如下方式声明
public interface MetricsService { /** * Default {@link MetricsService} extension name. */ String DEFAULT_EXTENSION_NAME = &amp;#34;default&amp;#34;; /** * The contract version of {@link MetricsService}, the future update must make sure compatible. */ String VERSION = &amp;#34;1.0.0&amp;#34;; /** * Get metrics by prefixes * * @param categories categories * @return metrics - key=MetricCategory value=MetricsEntityList */ Map&amp;lt;MetricsCategory, List&amp;lt;MetricsEntity&amp;gt;&amp;gt; getMetricsByCategories(List&amp;lt;MetricsCategory&amp;gt; categories); /** * Get metrics by interface and prefixes * * @param serviceUniqueName serviceUniqueName (eg.</description></item><item><title>Dubbo 在 Proxyless Mesh 模式下的探索与改进</title><link>https://dubbo.apache.org/zh-cn/blog/2023/02/02/dubbo-%E5%9C%A8-proxyless-mesh-%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E6%94%B9%E8%BF%9B/</link><pubDate>Thu, 02 Feb 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/02/02/dubbo-%E5%9C%A8-proxyless-mesh-%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E6%94%B9%E8%BF%9B/</guid><description>一、背景 随着 Docker 和 Kubernetes 的出现，一个庞大的单体应用可以被拆分成多个独立部署的微服务，并被打包运行于对应的容器中。不同应用之间相互通信，以共同完成某一功能模块。微服务架构与容器化部署带来的好处是显而易见的，它降低了服务间的耦合性，利于开发和维护，能更有效地利用计算资源。当然，微服务架构也存在相应的缺点：
强依赖于 SDK，业务模块与治理模块耦合较为严重。 除了相关依赖，往往还需要在业务代码中嵌入SDK代码或配置。 统一治理难。每次框架升级都需要修改 SDK 版本，并重新进行回归测试，确认功能正常后再对每一台机器重新部署上线。不同服务引用的 SDK 版本不统一、能力参差不齐，增大了统一治理的难度。 缺少一套统一解决方案。目前市场不存在一整套功能完善、无死角的微服务治理与解决方案。在实际生产环境往往还需要引入多个治理组件来完成像灰度发布、故障注入等功能。 为解决这些痛点，Service Mesh诞生了。以经典的 Sidecar 模式为例，它通过在业务 Pod 中注入 Sidecar 容器，对代理流量实施治理和管控，将框架的治理能力下层到 Sidecar 容器中，与业务系统解耦，从而轻松实现多语言、多协议的统一流量管控、监控等需求。通过剥离SDK能力并拆解为独立进程，从而解决了强依赖于SDK的问题，从而使开发人员可以更加专注于业务本身，实现了基础框架能力的下沉，如下图所示（源自dubbo官网）： 经典的 Sidecar Mesh 部署架构有很多优势，如减少SDK耦合、业务侵入小等，但增加了一层代理，也带来了一些额外的问题，比如:
Sidecar 代理会损耗一部分性能，当网络结构层级比较复杂时尤其明显，对性能要求很高的业务造成了一定的困扰。 架构更加复杂，对运维人员要求高。 对部署环境有一定的要求，需要其能支持 Sidecar 代理的运行。 为解决这些痛点，Proxyless Service Mesh 模式诞生了。传统服务网格通过代理的方式拦截所有的业务网络流量，代理需要感知到控制平面下发的配置资源，从而按照要求控制网络流量的走向。以istio为例，Proxyless 模式是指应用直接与负责控制平面的 istiod 进程通信，istiod 进程通过监听并获取 Kubernetes 的资源，例如 Service、Endpoint 等，并将这些资源统一通过 xDS 协议下发到不同的 RPC 框架，由 RPC 框架进行请求转发，从而实现服务发现和服务治理等能力。 Dubbo 社区是国内最早开始对 Proxyless Service Mesh 模式进行探索的社区，这是由于相比于 Service Mesh，Proxyless 模式落地成本较低，对于中小企业来说是一个较好的选择。Dubbo 在 3.1 版本中通过对 xDS 协议进行解析，新增了对 Proxyless 的支持。xDS 是一类发现服务的总称，应用通过 xDS API 可以动态获取 Listener(监听器)、Route(路由)、Cluster(集群)、Endpoint(集群成员) 以及 Secret(证书)配置。</description></item><item><title>Dubbo 3.1.5、3.2.0-beta.4 正式发布</title><link>https://dubbo.apache.org/zh-cn/blog/2023/01/30/dubbo-3.1.53.2.0-beta.4-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</link><pubDate>Mon, 30 Jan 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/01/30/dubbo-3.1.53.2.0-beta.4-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</guid><description>Dubbo 3.1.5 版本是目前 Dubbo 3 的最新稳定版本，我们建议所有的用户都升级到最新的稳定版本。Dubbo 3.2.0-beta.4 版本是目前 Dubbo 3 的最新特性版本，包括了如 Spring Boot 3、JDK 17、服务粒度的线程池隔离等新特性的支持，欢迎大家尝鲜使用。
Dubbo 3.1.5 新特性 Dubbo QoS 支持记录请求的记录，便于进行审计 支持在服务映射失败以后定时进行重试，降低由于元数据中心抖动带来的影响 支持在初始化 Nacos Client 的时候进行健康检查，如果失败则在一定次数限制下进行重试，降低由于 Nacos 性能问题带来的稳定性影响 支持序列化类检查机制，默认开启日志告警模式 Bugfix 修复资源加载器的日志级别 修复 Dubbo 配置类对 Scope Model 进行懒加载，避免触发非预期的默认模块初始化 修复 ReferenceConfig 中获取 ClassLoader 的逻辑 修复 Metadata Service 在获取订阅服务列表时出现 NPE 的问题 修复对接 Spring Cloud Rest 模式的时候 Metadata 配置覆盖的问题 修复 Spring 懒加载时可能出现死锁的问题 修复端口重复的无效日志 修复 Active Limit Filter 不生效的问题 修复服务映射时 Nacos CAS 检查写入无效的问题 修复 Zookeeper 注册中心对接的应用级服务发现在服务发布的时候出现单节点服务找不到的问题 修复服务映射在冲突以后未等待导致的冲突率高的问题 修复应用级服务发现下节点更新失败的问题 修复应用级配置覆盖不生效的问题 修复在应用级地址刷新之后原 Revision 的元数据无法获取的问题 修复 Zookeeper 注册中心在应用级服务发现下退订阅后无法重订阅的问题 兼容 Nacos 在频繁刷新时最终一致性错误的问题 关闭 Nacos 本地缓存获取的开关 修复 Triple 传递大写 Attachment 无效的问题 修复 Triple 处理特定类反序列化错误的问题 修复 Protobuf 依赖不存在时抛出非预期异常的问题 修复 CountDown 功能无效的问题 修复 Triple 在反序列化时类加载器未切换的问题 FAQ 本次发布中有 5 个提交涉及异常日志 FAQ 的完善。关于错误码机制请参考官网错误码机制介绍一文。</description></item><item><title>Dubbo3 应用级服务发现设计</title><link>https://dubbo.apache.org/zh-cn/blog/2023/01/30/dubbo3-%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E8%AE%BE%E8%AE%A1/</link><pubDate>Mon, 30 Jan 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/01/30/dubbo3-%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E8%AE%BE%E8%AE%A1/</guid><description>Objective 显著降低服务发现过程的资源消耗，包括提升注册中心容量上限、降低消费端地址解析资源占用等，使得 Dubbo3 框架能够支持更大规模集群的服务治理，实现无限水平扩容。 适配底层基础设施服务发现模型，如 Kubernetes、Service Mesh 等。 Background 我们从 Dubbo 最经典的工作原理图说起，Dubbo 从设计之初就内置了服务地址发现的能力，Provider 注册地址到注册中心，Consumer 通过订阅实时获取注册中心的地址更新，在收到地址列表后，consumer 基于特定的负载均衡策略发起对 provider 的 RPC 调用。
在这个过程中：
每个 Provider 通过特定的 key 向注册中心注册本机可访问地址； 注册中心通过这个 key 对 provider 实例地址进行聚合； Consumer 通过同样的 key 从注册中心订阅，以便及时收到聚合后的地址列表； 这里，我们对接口级地址发现的内部数据结构进行详细分析。
首先，看右下角 provider 实例内部的数据与行为。Provider 部署的应用中通常会有多个 Service，也就是 Dubbo2 中的服务，每个 service 都可能会有其独有的配置，我们所讲的 service 服务发布的过程，其实就是基于这个服务配置生成地址 URL 的过程，生成的地址数据如图所示；同样的，其他服务也都会生成地址。
然后，看一下注册中心的地址数据存储结构，注册中心以 service 服务名为数据划分依据，将一个服务下的所有地址数据都作为子节点进行聚合，子节点的内容就是实际可访问的ip地址，也就是我们 Dubbo 中 URL，格式就是刚才 provider 实例生成的。
这里把 URL 地址数据划分成了几份：
首先是实例可访问地址，主要信息包含 ip port，是消费端将基于这条数据生成 tcp 网络链接，作为后续 RPC 数据的传输载体 其次是 RPC 元数据，元数据用于定义和描述一次 RPC 请求，一方面表明这条地址数据是与某条具体的 RPC 服务有关的，它的版本号、分组以及方法相关信息，另一方面表明 下一部分是 RPC 配置数据，部分配置用于控制 RPC 调用的行为，还有一部分配置用于同步 Provider 进程实例的状态，典型的如超时时间、数据编码的序列化方式等。 最后一部分是自定义的元数据，这部分内容区别于以上框架预定义的各项配置，给了用户更大的灵活性，用户可任意扩展并添加自定义元数据，以进一步丰富实例状态。 结合以上两页对于 Dubbo2 接口级地址模型的分析，以及最开始的 Dubbo 基本原理图，我们可以得出这么几条结论：</description></item><item><title>启发式流控制</title><link>https://dubbo.apache.org/zh-cn/blog/2023/01/30/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%B5%81%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 30 Jan 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/01/30/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%B5%81%E6%8E%A7%E5%88%B6/</guid><description>整体介绍 本文所说的柔性服务主要是指consumer端的负载均衡和provider端的限流两个功能。在之前的dubbo版本中，
负载均衡部分更多的考虑的是公平性原则，即consumer端尽可能平等的从provider中作出选择，在某些情况下表现并不够理想。 限流部分只提供了静态的限流方案，需要用户对provider端设置静态的最大并发值，然而该值的合理选取对用户来讲并不容易。 我们针对这些存在的问题进行了改进。
负载均衡 使用介绍 在原本的dubbo版本中，有五种负载均衡的方案供选择，他们分别是 Random、ShortestResponse、RoundRobin、LeastActive 和 ConsistentHash。其中除 ShortestResponse 和 LeastActive 外，其他的几种方案主要是考虑选择时的公平性和稳定性。
对于 ShortestResponse 来说，其设计目的是从所有备选的 provider 中选择 response 时间最短的以提高系统整体的吞吐量。然而存在两个问题：
在大多数的场景下，不同provider的response时长没有非常明显的区别，此时该算法会退化为随机选择。 response的时间长短有时也并不能代表机器的吞吐能力。对于 LeastActive 来说，其认为应该将流量尽可能分配到当前并发处理任务较少的机器上。但是其同样存在和 ShortestResponse 类似的问题，即这并不能单独代表机器的吞吐能力。 基于以上分析，我们提出了两种新的负载均衡算法。一种是同样基于公平性考虑的单纯 P2C 算法，另一种是基于自适应的方法 adaptive，其试图自适应的衡量 provider 端机器的吞吐能力，然后将流量尽可能分配到吞吐能力高的机器上，以提高系统整体的性能。
总体效果 对于负载均衡部分的有效性实验在两个不同的情况下进行的，分别是提供端机器配置比较均衡和提供端机器配置差距较大的情况。
使用方法 使用方法与原本的负载均衡方法相同。只需要在consumer端将&amp;quot;loadbalance&amp;quot;设置为&amp;quot;p2c&amp;quot;或者&amp;quot;adaptive&amp;quot;即可。
代码结构 负载均衡部分的算法实现只需要在原本负载均衡框架内继承 LoadBalance接口即可。
原理介绍 P2C算法 Power of Two Choice算法简单但是经典，主要思路如下：
对于每次调用，从可用的provider列表中做两次随机选择，选出两个节点providerA和providerB。 比较providerA和providerB两个节点，选择其“当前正在处理的连接数”较小的那个节点。 adaptive算法 代码的github地址
相关指标 cpuLoad 。该指标在provider端机器获得，并通过invocation的attachment传递给consumer端。
rt rt为一次rpc调用所用的时间，单位为毫秒。
timeout timeout为本次rpc调用超时剩余的时间，单位为毫秒。
weight weight是设置的服务权重。
currentProviderTime provider端在计算cpuLoad时的时间，单位是毫秒
currentTime currentTime为最后一次计算load时的时间，初始化为currentProviderTime，单位是毫秒。
multiple lastLatency beta 平滑参数，默认为0.5
ewma lastLatency的平滑值</description></item><item><title>Dubbo 连接异构微服务体系 - 多协议&amp;多注册中心</title><link>https://dubbo.apache.org/zh-cn/blog/2023/01/05/dubbo-%E8%BF%9E%E6%8E%A5%E5%BC%82%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BD%93%E7%B3%BB-%E5%A4%9A%E5%8D%8F%E8%AE%AE%E5%A4%9A%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</link><pubDate>Thu, 05 Jan 2023 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2023/01/05/dubbo-%E8%BF%9E%E6%8E%A5%E5%BC%82%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BD%93%E7%B3%BB-%E5%A4%9A%E5%8D%8F%E8%AE%AE%E5%A4%9A%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</guid><description>从编程开发的角度来说，Dubbo 首先是一款 RPC 服务框架，它最大的优势在于提供了面向接口代理的服务编程模型，对开发者屏蔽了底层的远程通信细节。同时 Dubbo 也是一款服务治理框架，它为分布式部署的微服务提供了服务发现、流量调度等服务治理解决方案。
在这篇文章中，我们将以以上基础能力为背景，尝试突破 Dubbo 体系自身，探索如何利用 Dubbo 对多协议、多服务发现模型的支持，来实现异构微服务体系间的互联互通。在实际业务场景中，这可以用来解决异构技术体系共存场景下的通信问题，帮助公司实现在异构技术体系间作平滑迁移，解决大规模跨区域、多集群部署场景的地址发现及流量调度等问题。
面向接口代理的透明服务开发框架 我们还是从 Dubbo 是一个微服务开发框架 这个大家熟知的概念开始。就像 Spring 是开发 Java 应用的基础框架一样，我们经常会选用 Dubbo 作为开发微服务业的基础框架。 Dubbo 框架的最大优势我认为就在其面向接口的编程模型，使得开发远程服务调用就像开发本地服务一样（以 Java 语言为例）：
服务定义 public interface GreetingsService { String sayHi(String name); } 消费方调用服务 // 和调用本地服务一样，完全透明。 @Reference private GreetingService greetingService; public void doSayHello(String name) { greetingService.sayHi(&amp;#34;Hello world!&amp;#34;); } 下图是 Dubbo 的基本工作原理图，服务提供者与服务消费者之间通过注册中心协调地址，通过约定的协议实现数据交换。
同构/异构微服务体系面临的问题 关于 Dubbo 协议本身及其服务治理相关功能细节并不是本文的重点，我们今天将从一个更高的层次，来看看公司内部构建微服务体系所面的挑战，以及 Dubbo 能为架构选型和迁移等提供哪些解决思路。
一个公司内部的微服务可能都是基于某一个相同的服务框架开发的，比如说 Dubbo，对于这样的架构，我们称之为是同构的微服务体系；而有些公司的微服务可能是使用多个不同的服务框架所建设，我们称之为异构的微服务体系，多个不同技术栈微服务体系的共存在大型组织内还是非常普遍的，造成这种局面可能有很多原因。比如，可能是遗留系统带来的，也可能是公司正在做技术栈迁移，或者就是不同业务部门为了满足各自特殊需求而做的独立选型（这也意味着异构微服务体系的长期共存）。
1. 异构微服务体系共存
我们很容易想到的一个挑战是：**不同的体系间通常是使用不同的 RPC 通信协议、部署独立的注册中心集群，面对这种多协议、多注册中心集群的场景，要如何实现相互之间透明的地址发现和透明的 RPC 调用？**如果我们什么都不做，那么每个微服务体系就只能感知到自己体系内的服务状态，流量也在各自的体系内封闭。而要做到从体系 A 平滑的迁移到体系 B，或者想长期的保持公司内部多个体系的共存，则解决不同体系间的互联互通，实现流量的透明调度将是非常重要的环节。</description></item><item><title>Dubbo 3 之 Triple 流控反压原理解析</title><link>https://dubbo.apache.org/zh-cn/blog/2022/12/28/dubbo-3-%E4%B9%8B-triple-%E6%B5%81%E6%8E%A7%E5%8F%8D%E5%8E%8B%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</link><pubDate>Wed, 28 Dec 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/12/28/dubbo-3-%E4%B9%8B-triple-%E6%B5%81%E6%8E%A7%E5%8F%8D%E5%8E%8B%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</guid><description>Triple 是 Dubbo 3 提出的基于 HTTP2 的开放协议， 旨在解决 Dubbo 2 私有协议带来的互通性问题。 Triple 基于 HTTP/2 定制自己的流控，支持通过特定的异常通知客户端业务层服务端负载高情况， 保护了服务端被大流量击垮，提高系统高可用能力。
一、流控反压现状 客户端和服务器端在接收数据的时候有一个缓冲区来临时存储数据， 但是缓冲区的大小是有限制的，所以有可能会出现缓冲区溢出的情况， HTTP 通过流控保护数据溢出丢失风险。
1、HTTP/1 流控 在 HTTP/1.1 中，流量的控制依赖的是底层TCP协议，在客户端和服务器端建立连接的时候， 会使用系统默认的设置来建立缓冲区。在数据进行通信的时候，会告诉对方它的接收窗口的大小， 这个接收窗口就是缓冲区中剩余的可用空间。如果接收窗口大小为零，则说明接收方缓冲区已满， 则发送方将不再发送数据，直到客户端清除其内部缓冲区，然后请求恢复数据传输。
2、HTTP/2 流控 HTTP/2 使用了多路复用机制，一个TCP连接可以有多个 HTTP/2 连接， 故在 HTTP/2 中，有更加精细的流控制机制，允许服务端实现自己数据流和连接级的流控制。 服务端与客户端第一次连接时，会通过发送 HTTP/2 SettingsFrame设置初始化的流控窗口大小， 用于 Stream 级别流控，默认为 65,535 字节。 定好流控窗口后，每次客户端发送数据就会减少流控窗口的大小， 服务端收到数据后会发送窗口更新包（WINDOW_UPDATE frame）通知客户端更新窗口。 客户端收到窗口更新包后就会增加对应值的流控窗口，从而达到动态控制的目的。
二、Triple流控反压 Netty 基于 HTTP/2 实现了基础的流控，当服务端负载过高，客户端发送窗口为 0 时， 新增请求就无法被发送出去，会在缓存到客户端待发送请求队列中，缓存数据过大， 就会造成客户端内存溢出，影响业务程序。
Triple 基于 Netty 实现了 HTTP/2 协议，通过 HTTP/2 FlowController接口统一封装， 在实现分为进站（inbound）和出站（outbound）两个维度的实现。 Triple 在 inbound 流量上使用了 Netty 的默认流控实现， 在 outbound 上实现了自己流控，基于服务端负载， 将服务端流量压力透传到客户端业务层，实现客户端的业务反压，暂停业务继续发送请求， 保护服务端不被大流量击垮。</description></item><item><title>Triple 协议支持 Java 异常回传的设计与实现</title><link>https://dubbo.apache.org/zh-cn/blog/2022/12/19/triple-%E5%8D%8F%E8%AE%AE%E6%94%AF%E6%8C%81-java-%E5%BC%82%E5%B8%B8%E5%9B%9E%E4%BC%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link><pubDate>Mon, 19 Dec 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/12/19/triple-%E5%8D%8F%E8%AE%AE%E6%94%AF%E6%8C%81-java-%E5%BC%82%E5%B8%B8%E5%9B%9E%E4%BC%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid><description>背景 在一些业务场景, 往往需要自定义异常来满足特定的业务, 主流用法是在catch里抛出异常, 例如：
public void deal() { try{ //doSomething ... } catch(IGreeterException e) { ... throw e; } } 或者通过ExceptionBuilder，把相关的异常对象返回给consumer：
provider.send(new ExceptionBuilders.IGreeterExceptionBuilder() .setDescription(&amp;#39;异常描述信息&amp;#39;); 在抛出异常后, 通过捕获和instanceof来判断特定的异常, 然后做相应的业务处理，例如：
try { greeterProxy.echo(REQUEST_MSG); } catch (IGreeterException e) { //做相应的处理 ... } 在 Dubbo 2.x 版本，可以通过上述方法来捕获 Provider 端的异常。 而随着云原生时代的到来， Dubbo 也开启了 3.0 的里程碑。
Dubbo 3.0 的一个很重要的目标就是全面拥抱云原生， 在 3.0 的许多特性中，很重要的一个改动就是支持新的一代Rpc协议Triple。
Triple 协议基于 HTTP 2.0 进行构建，对网关的穿透性强，兼容 gRPC， 提供 Request Response、Request Streaming、Response Streaming、 Bi-directional Streaming 等通信模型； 从 Triple 协议开始，Dubbo 还支持基于 IDL 的服务定义。</description></item><item><title>Apache Dubbo 多语言体系再添新员：首个 Rust 语言版本正式发布</title><link>https://dubbo.apache.org/zh-cn/blog/2022/10/23/apache-dubbo-%E5%A4%9A%E8%AF%AD%E8%A8%80%E4%BD%93%E7%B3%BB%E5%86%8D%E6%B7%BB%E6%96%B0%E5%91%98%E9%A6%96%E4%B8%AA-rust-%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</link><pubDate>Sun, 23 Oct 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/10/23/apache-dubbo-%E5%A4%9A%E8%AF%AD%E8%A8%80%E4%BD%93%E7%B3%BB%E5%86%8D%E6%B7%BB%E6%96%B0%E5%91%98%E9%A6%96%E4%B8%AA-rust-%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</guid><description>Dubbo Rust 定位为 Dubbo 多语言体系的重要实现，提供高性能、易用、可扩展的 RPC 框架，同时通过接入 Dubbo Mesh 体系提供丰富的服务治理能力。本文主要为大家介绍 Dubbo Rust 项目基本情况，通过一个示例快速体验 Rust 首个正式版本特性，并给出了 Dubbo Rust 社区的近期规划，适合于关注或正在采用 Rust 语言的开发者与企业用户阅读。
1 Dubbo Rust 简介 Dubbo 作为 Apache 基金会最活跃的明星项目之一，同时也是国内最受欢迎的开源微服务框架，在易用性、高性能通信、服务治理等方面有着非常大的优势，通过 Dubbo3、Dubbo Mesh 等提供了云原生友好的开发与部署模式。与此同时，Dubbo 的多语言体系也得到了快速发展，长期以来提供的有 Java、Golang 两种语言实现，Rust、Node、Python、C++ 等语言实现的支持也已在社区正式启动。
Dubbo 官网 https://dubbo.apache.org/ Dubbo Java https://github.com/apache/dubbo/ Dubbo Golang https://github.com/apache/dubbo-go/ Dubbo Rust https://github.com/apache/dubbo-rust/ Dubbo Rust 目标是对齐 Dubbo3 的所有核心功能设计，包括基于 HTTP/2 的高性能通信、用户友好的微服务开发编程模式、通过接入DubboMesh提供丰富的服务治理能力等，相比于其他语言实现，Dubbo Rust 将很好的利用 Rust 语言极致性能、安全和指令级掌控能力的特点。 对于微服务框架，主流的编程语言都有对应的实现，而 Dubbo Rust 将很好的填补 Rust 领域的空白：
Golang：在微服务框架领域已经占据着很重要的地位；开源社区出现了dubbo-go、gRPC、go-micro、go-zero等多个微服务框架 Java：国内用户量最大的编程语言，Spring Cloud、Dubbo等优秀的微服务框架已经非常流行 C/C++：brpc、grpc 等微服务框架 Rust：目前没有很完善的微服务框架 依托 Dubbo 庞大的用户群，以及 Dubbo 体系下的 Mesh 服务治理整体方案规划。Dubbo Rust 可以轻松地融入到现有的云原生研发体系中，不会增加使用者的研发负担。下图是社区推出的 Dubbo Mesh 架构设计。</description></item><item><title>Proxyless Mesh在Dubbo中的实践</title><link>https://dubbo.apache.org/zh-cn/blog/2022/09/05/proxyless-mesh%E5%9C%A8dubbo%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/</link><pubDate>Mon, 05 Sep 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/09/05/proxyless-mesh%E5%9C%A8dubbo%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/</guid><description>背景 随着 Dubbo 3.1 的 release，Dubbo 在云原生的路上又迈出了重要的一步。在这个版本中添加了 Proxyless Mesh 的新特性，Dubbo Proxyless Mesh 直接实现 xDS 协议解析， 实现 Dubbo 与 Control Plane 的直接通信，进而实现控制面对流量管控、服务治理、可观测性、安全等的统一管控，规避 Sidecar 模式带来的性能损耗与部署架构复杂性。
什么是Service Mesh Service Mesh 又译作 “服务网格”，作为服务间通信的基础设施层。Buoyant 公司的 CEO Willian Morgan 在他的这篇文章 WHAT’S A Service Mesh? AND WHY DO I NEED ONE? 中解释了什么是 Service Mesh，为什么云原生应用需要 Service Mesh。
下面是 Willian Morgan 对 Service Mesh 的解释。
A Service Mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable delivery of requests through the complex topology of services that comprise a modern, cloud native application.</description></item><item><title>22-Dubbo3消费者自动感应决策应用级服务发现原理</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/22/22-dubbo3%E6%B6%88%E8%B4%B9%E8%80%85%E8%87%AA%E5%8A%A8%E6%84%9F%E5%BA%94%E5%86%B3%E7%AD%96%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 22 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/22/22-dubbo3%E6%B6%88%E8%B4%B9%E8%80%85%E8%87%AA%E5%8A%A8%E6%84%9F%E5%BA%94%E5%86%B3%E7%AD%96%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>22-Dubbo3消费者自动感应决策应用级服务发现原理 22.1 简介 这里要说的内容对Dubbo2迁移到Dubbo3的应用比较有帮助，消费者应用级服务发现做了一些自动决策的逻辑来决定当前消费者是应用级发现还是接口级服务发现，这里与前面说的提供者双注册的原理是对等的，提供者默认同时进行应用级注册和接口级注册，消费者对提供者注册的数据来决定使用应用级发现或者接口级发现。这些都是默认的行为，当然对于消费者来说还可以自定义其他的迁移规则，具体的需要我们详细来看逻辑。
如果说对于迁移过程比较感兴趣可以直接去官网看文档相对来说还是比较清晰:https://dubbo.apache.org/zh-cn/docs/migration/migration-service-discovery/
这里再借官网的图来用用，迁移过程主要如下所示： 第一个图是提供者双注册的图： 第二个图是消费者订阅决策的图： 第三个图就是精确到消费者订阅的代码层的逻辑了，消费者服务间调用通过一个Invoker类型对象来进行对象，如下图所示消费者代理对象通过创建一个迁移容错的调用器对象来对应用级或者接口级订阅进行适配如下所示 第二个图和第三个图是重点要关注的这一个文章的内容主要就是说这里的逻辑。
关于代码位置如果不知道是如何调用到这一块逻辑的可以查看博文《21-Dubbo3消费者引用服务入口》
这里直接将代码位置定位到：RegistryProtocol类型的interceptInvoker方法中： 如下所示：
RegistryProtocol类型的interceptInvoker方法
protected &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; interceptInvoker(ClusterInvoker&amp;lt;T&amp;gt; invoker, URL url, URL consumerUrl) { //目前存在的扩展类型为RegistryProtocolListener监听器的实现类型MigrationRuleListener List&amp;lt;RegistryProtocolListener&amp;gt; listeners = findRegistryProtocolListeners(url); if (CollectionUtils.isEmpty(listeners)) { return invoker; } for (RegistryProtocolListener listener : listeners) { listener.onRefer(this, invoker, consumerUrl, url); } return invoker; } 该方法尝试加载所有RegistryProtocolListener定义，这些定义通过与定义的交互来控制调用器的行为，然后使用这些侦听器更改MigrationInvoker的状态和行为。当前可用的监听器是MigrationRuleListener，用于通过动态变化的规则控制迁移行为。
22.2 MigrationRuleListener 类型的onRefer方法 直接来看代码：
@Override public void onRefer(RegistryProtocol registryProtocol, ClusterInvoker&amp;lt;?&amp;gt; invoker, URL consumerUrl, URL registryURL) { //创建一个对应invoker对象的MigrationRuleHandler类型对象 然后将其存放在缓存Map&amp;lt;MigrationInvoker, MigrationRuleHandler&amp;gt;类型对象handles中 MigrationRuleHandler&amp;lt;?&amp;gt; migrationRuleHandler = handlers.</description></item><item><title>21-Dubbo3消费者引用服务入口</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/21/21-dubbo3%E6%B6%88%E8%B4%B9%E8%80%85%E5%BC%95%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%85%A5%E5%8F%A3/</link><pubDate>Sun, 21 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/21/21-dubbo3%E6%B6%88%E8%B4%B9%E8%80%85%E5%BC%95%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%85%A5%E5%8F%A3/</guid><description>21-Dubbo3消费者引用服务入口 21.1 简介 前面我们通过Demo说了一个服务引用配置的创建。另外也在前面的文章说了服务提供者的启动完整过程，不过在说服务提供者启动的过程中并未提到服务消费者是如何发现服务，如果调用服务的，这里先就不再说关于服务消费者启动的一个细节了，直接来看前面未提到的服务消费者是如何引用到服务提供者提供的服务的。 先来回顾下样例代码：
public class ConsumerApplication { public static void main(String[] args) { runWithBootstrap(); } private static void runWithBootstrap() { ReferenceConfig&amp;lt;DemoService&amp;gt; reference = new ReferenceConfig&amp;lt;&amp;gt;(); reference.setInterface(DemoService.class); reference.setGeneric(&amp;#34;true&amp;#34;); reference.setProtocol(&amp;#34;&amp;#34;); DubboBootstrap bootstrap = DubboBootstrap.getInstance(); ApplicationConfig applicationConfig = new ApplicationConfig(&amp;#34;dubbo-demo-api-consumer&amp;#34;); applicationConfig.setQosEnable(false); applicationConfig.setQosPort(-1); bootstrap.application(applicationConfig) .registry(new RegistryConfig(&amp;#34;zookeeper://8.131.79.126:2181&amp;#34;)) .protocol(new ProtocolConfig(CommonConstants.DUBBO, -1)) .reference(reference) .start(); DemoService demoService = bootstrap.getCache().get(reference); String message = demoService.sayHello(&amp;#34;dubbo&amp;#34;); System.out.println(message); // generic invoke GenericService genericService = (GenericService) demoService; Object genericInvokeResult = genericService.$invoke(&amp;#34;sayHello&amp;#34;, new String[]{String.</description></item><item><title>20-Dubbo3服务引用配置ReferenceConfig</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/20/20-dubbo3%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8%E9%85%8D%E7%BD%AEreferenceconfig/</link><pubDate>Sat, 20 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/20/20-dubbo3%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8%E9%85%8D%E7%BD%AEreferenceconfig/</guid><description>20-Dubbo3服务引用配置ReferenceConfig 20.1 简介 前面简单介绍了一下消费者的例子，消费者创建的第一步就是先进行消费者信息的配置对应类型为ReferenceConfig，这里详细来看ReferenceConfig包含哪些信息？先简单了解下消费者配置的类型关系如下图所示：引用配置与服务配置类型都是通过继承接口配置来扩展的，在分析生产者的时候详细介绍过服务相关的配置，这里来详细看消费者引用者的相关配置信息. 前面例子说了消费者配置对象的创建主要是通过如下代码：
ReferenceConfig&amp;lt;DemoService&amp;gt; reference = new ReferenceConfig&amp;lt;&amp;gt;(); 这个配置类型的对象创建过程并没有太多的逻辑这里主要来说下各种配置信息： 服务消费者引用服务配置。对应的配置类： org.apache.dubbo.config.ReferenceConfig
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 id string 必填 配置关联 服务引用BeanId 1.0.0以上版本 interface class 必填 服务发现 服务接口名 1.0.0以上版本 version version string 可选 服务发现 服务版本，与服务提供者的版本一致 1.0.0以上版本 group group string 可选 服务发现 服务分组，当一个接口有多个实现，可以用分组区分，必需和服务提供方一致 1.0.7以上版本 timeout timeout long 可选 缺省使用dubbo:consumer的timeout 性能调优 服务方法调用超时时间(毫秒) 1.0.5以上版本 retries retries int 可选 缺省使用dubbo:consumer的retries 性能调优 远程服务调用重试次数，不包括第一次调用，不需要重试请设为0 2.0.0以上版本 connections connections int 可选 缺省使用dubbo:consumer的connections 性能调优 对每个提供者的最大连接数，rmi、http、hessian等短连接协议表示限制连接数，dubbo等长连接协表示建立的长连接个数 2.</description></item><item><title>19 重新来过从一个服务消费者的Demo说起</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/19/19-%E9%87%8D%E6%96%B0%E6%9D%A5%E8%BF%87%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84demo%E8%AF%B4%E8%B5%B7/</link><pubDate>Fri, 19 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/19/19-%E9%87%8D%E6%96%B0%E6%9D%A5%E8%BF%87%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84demo%E8%AF%B4%E8%B5%B7/</guid><description>19 重新来过从一个服务消费者的Demo说起 为了更方便了解原理,我们先来编写一个Demo,从例子中来看源码实现:，前面说了提供者现在已经有服务注册上去了，那接下来我们编写一个消费者的例子来进行服务发现与服务RPC调用。
19.1 启动Zookeeper 为了Demo可以正常启动,需要我们先在本地启动一个Zookeeper如下图所示: 19.2 服务消费者 接下来给大家贴一下示例源码,这个源码来源于Dubbo源码目录的	dubbo-demo/dubbo-demo-api 目录下面的dubbo-demo-api-consumer子项目,这里我做了删减,方便看核心代码: 首先我们定义一个服务接口如下所示:
import java.util.concurrent.CompletableFuture; public interface DemoService { /** * 同步处理的服务方法 * @param name * @return */ String sayHello(String name); /** * 用于异步处理的服务方法 * @param name * @return */ default CompletableFuture&amp;lt;String&amp;gt; sayHelloAsync(String name) { return CompletableFuture.completedFuture(sayHello(name)); } } 服务实现类如下: import org.apache.dubbo.rpc.RpcContext; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.util.concurrent.CompletableFuture; public class DemoServiceImpl implements DemoService { private static final Logger logger = LoggerFactory.getLogger(DemoServiceImpl.class); @Override public String sayHello(String name) { logger.</description></item><item><title>18-Dubbo3元数据服务MetadataService的导出</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/18/18-dubbo3%E5%85%83%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1metadataservice%E7%9A%84%E5%AF%BC%E5%87%BA/</link><pubDate>Thu, 18 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/18/18-dubbo3%E5%85%83%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1metadataservice%E7%9A%84%E5%AF%BC%E5%87%BA/</guid><description>18-Dubbo3元数据服务MetadataService的导出 18.1 简介 MetadataService 此服务用于公开Dubbo进程内的元数据信息。典型用途包括：
使用者查询提供者的元数据信息，以列出接口和每个接口的配置 控制台（dubbo admin）查询特定进程的元数据，或聚合所有进程的数据。在Dubbo2.x的时候，所有的服务数据都是以接口的形式注册在注册中心. Dubbo3将部分数据抽象为元数据的形式来将数据存放在元数据中心，然后元数据由服务提供者提供给消费者而不是再由注册中心进行推送，如下图所示：
引入 MetadataService 元数据服务服务的好处 • 由中心化推送转向点对点拉取（Consumer - Proroder） • 易于扩展更多的参数 • 更多的数据量 • 对外暴露更多的治理数据
18.2 MetadataService的导出过程 了解元数据的到处过程，这个就要继续前面博客往后的代码了前面博客说了一个服务发布之后的服务信息的双注册数据，这里继续看下导出服务之后的代码： 先来简单回顾下模块发布的启动生命周期方法：
DefaultModuleDeployer类型的start方法：
@Override public synchronized Future start() throws IllegalStateException { ... try { ... onModuleStarting(); // initialize applicationDeployer.initialize(); initialize(); // export services exportServices(); // prepare application instance // exclude internal module to avoid wait itself if (moduleModel != moduleModel.getApplicationModel().getInternalModule()) { applicationDeployer.prepareInternalModule(); } // refer services referServices(); // if no async export/refer services, just set started if (asyncExportingFutures.</description></item><item><title>17-Dubbo服务提供者的双注册原理</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/17/17-dubbo%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E7%9A%84%E5%8F%8C%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86/</link><pubDate>Wed, 17 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/17/17-dubbo%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E7%9A%84%E5%8F%8C%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86/</guid><description>17-Dubbo服务提供者的双注册原理 17.1 简介 上个博客《15-Dubbo的三大中心之元数据中心源码解析》导出服务端的时候多次提到了元数据中心，注册信息的注册。 Dubbo3出来时间不太长，对于现在的用户来说大部分使用的仍旧是Dubbo2.x， Dubbo3 比较有特色也是会直接使用到的功能就是应用级服务发现：
应用级服务发现 从服务/接口粒度到应用粒度的升级，使得 Dubbo 在集群可伸缩性、连接异构微服务体系上更具优势。应用粒度能以更低的资源消耗支持超百万实例规模集群程； 实现与 Spring Cloud、Kubernetes Service 等异构微服务体系的互联互通。 对于直接使用Dubbo3的用户还好，可以仅仅开启应用级注册，但是对于Dubbo2.x的用户升级到Dubbo3的用户来说前期都是要开启双注册来慢慢迁移的，既注册传统的接口信息到注册中心，又注册应用信息到注册中心，同时注册应用与接口关系的元数据信息。 关于双注册与服务迁移的过程的使用可以参考官网： 应用级地址发现迁移指南
关于官网提供者双注册的图我这里贴一下，方便了解： 17.2 双注册配置的读取 17.2.1 注册中心地址作为元数据中心 这个配置的解析过程在前面的博客介绍元数据中心的时候很详细的说了相关链接：15-Dubbo的三大中心之元数据中心源码解析
对应代码位于：DefaultApplicationDeployer类型的startMetadataCenter()方法
private void startMetadataCenter() { //如果未配置元数据中心的地址等配置则使用注册中心的地址等配置做为元数据中心的配置 useRegistryAsMetadataCenterIfNecessary(); //...省略掉其他代码防止受到干扰 } 具体逻辑是这个方法： useRegistryAsMetadataCenterIfNecessary
private void useRegistryAsMetadataCenterIfNecessary() { //配置缓存中查询元数据配置 Collection&amp;lt;MetadataReportConfig&amp;gt; metadataConfigs = configManager.getMetadataConfigs(); //...省略掉空判断 //查询是否有注册中心设置了默认配置isDefault 设置为true的注册中心则为默认注册中心列表,如果没有注册中心设置为默认注册中心,则获取所有未设置默认配置的注册中心列表 List&amp;lt;RegistryConfig&amp;gt; defaultRegistries = configManager.getDefaultRegistries(); if (defaultRegistries.size() &amp;gt; 0) { //多注册中心遍历 defaultRegistries .stream() //筛选符合条件的注册中心 (筛选逻辑就是查看是否有对应协议的扩展支持) .filter(this::isUsedRegistryAsMetadataCenter) //注册中心配置映射为元数据中心 映射就是获取需要的配置 .map(this::registryAsMetadataCenter) //将元数据中心配置存储在配置缓存中方便后续使用 .forEach(metadataReportConfig -&amp;gt; { //.</description></item><item><title>16-模块发布器发布服务全过程</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/16/16-%E6%A8%A1%E5%9D%97%E5%8F%91%E5%B8%83%E5%99%A8%E5%8F%91%E5%B8%83%E6%9C%8D%E5%8A%A1%E5%85%A8%E8%BF%87%E7%A8%8B/</link><pubDate>Tue, 16 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/16/16-%E6%A8%A1%E5%9D%97%E5%8F%91%E5%B8%83%E5%99%A8%E5%8F%91%E5%B8%83%E6%9C%8D%E5%8A%A1%E5%85%A8%E8%BF%87%E7%A8%8B/</guid><description>16-模块发布器发布服务全过程 16.1 简介 Dubbo做为服务治理框架,比较核心的就是服务相关的概念,这里我先贴个找到的关于Dubbo工作原理的架构图: 如果按完整服务启动与订阅的顺序我们可以归结为以下6点:
导出服务(提供者) 服务提供方通过指定端口对外暴露服务 注册服务(提供者) 提供方向注册中心注册自己的信息 (服务发现)-订阅服务(消费者) 服务调用方通过注册中心订阅自己感兴趣的服务 (服务发现)-服务推送(消费者) 注册中心向调用方推送地址列表 调用服务(消费者调用提供者) 调用方选择一个地址发起RPC调用 监控服务 服务提供方和调用方的统计数据由监控模块收集展示 上面的完整的服务启动订阅与调用流程不仅仅适用于Dubbo 同样也适用于其他服务治理与发现的模型, 一般服务发现与服务调用的思路就是这样的,我们将以上内容扩展,暴漏服务可以使用http,tcp,udp等各种协议,注册服务可以注册到Redis,Dns,Etcd,Zookeeper等注册中心中,订阅服务可以主动去注册中心查询服务列表,服务发现可以让注册中心将服务数据动态推送给消费者.Dubbo其实就是基于这种简单的服务模型来扩展出各种功能的支持,来满足服务治理的各种场景,了解了这里可能各位同学就想着自行开发一个简单的微服务框架了。
回到主题,从以上的服务完整发布调用流程可以看到,所有的功能都是由导出服务(提供者)开始的,只有提供者先提供了服务才可以有真正的服务让消费者调用。
之前的博客内容 链接:&amp;laquo;12-全局视野来看Dubbo3.0.8的服务启动生命周期&amp;raquo; 我们了解了 DefaultModuleDeployer模块器启动的流程,其中在start代码的模版方法中开始了导出服务的功能,这里我们来详细看下服务发布的全过程:
入口代码: DefaultModuleDeployer的发布服务方法
private void exportServices() { //从配置管缓存中查询缓存的所有的服务配置然后逐个服务发布 for (ServiceConfigBase sc : configManager.getServices()) { exportServiceInternal(sc); } } 16.2 导出服务的入口 入口代码: DefaultModuleDeployer的发布服务方法
private void exportServices() { //从配置管缓存中查询缓存的所有的服务配置然后逐个服务发布 for (ServiceConfigBase sc : configManager.getServices()) { exportServiceInternal(sc); } } 主要流程为遍历初始化的服务配置列表然后逐个服务开始到处 内部导出服务代码: exportServiceInternal方法:
private void exportServiceInternal(ServiceConfigBase sc) { ServiceConfig&amp;lt;?&amp;gt; serviceConfig = (ServiceConfig&amp;lt;?</description></item><item><title>15-Dubbo的三大中心之元数据中心源码解析</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/15/15-dubbo%E7%9A%84%E4%B8%89%E5%A4%A7%E4%B8%AD%E5%BF%83%E4%B9%8B%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 15 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/15/15-dubbo%E7%9A%84%E4%B8%89%E5%A4%A7%E4%B8%AD%E5%BF%83%E4%B9%8B%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>15-Dubbo的三大中心之元数据中心源码解析 15.1 简介 关于元数据中心的概念对于大部分用户来说是比较陌生的,配置中心的话我们还好理解,对于元数据中心是什么,我们来看下我从官网拷贝过来的一段文字:
元数据中心在2.7.x版本开始支持，随着应用级别的服务注册和服务发现在Dubbo中落地，元数据中心也变的越来越重要。在以下几种情况下会需要部署元数据中心：
对于一个原先采用老版本Dubbo搭建的应用服务，在迁移到Dubbo 3时，Dubbo 3 会需要一个元数据中心来维护RPC服务与应用的映射关系（即接口与应用的映射关系），因为如果采用了应用级别的服务发现和服务注册，在注册中心中将采用“应用 —— 实例列表”结构的数据组织形式，不再是以往的“接口 —— 实例列表”结构的数据组织形式，而以往用接口级别的服务注册和服务发现的应用服务在迁移到应用级别时，得不到接口与应用之间的对应关系，从而无法从注册中心得到实例列表信息，所以Dubbo为了兼容这种场景，在Provider端启动时，会往元数据中心存储接口与应用的映射关系。 为了让注册中心更加聚焦与地址的发现和推送能力，减轻注册中心的负担，元数据中心承载了所有的服务元数据、大量接口/方法级别配置信息等，无论是接口粒度还是应用粒度的服务发现和注册，元数据中心都起到了重要的作用。 如果有以上两种需求，都可以选择部署元数据中心，并通过Dubbo的配置来集成该元数据中心。 元数据中心并不依赖于注册中心和配置中心，用户可以自由选择是否集成和部署元数据中心，如下图所示：
该图中不配备配置中心，意味着可以不需要全局管理配置的能力。该图中不配备注册中心，意味着可能采用了Dubbo mesh的方案，也可能不需要进行服务注册，仅仅接收直连模式的服务调用。 官网参考文章地址:
部署架构（注册中心 配置中心 元数据中心 元数据参考手册 综上所述可以用几句话概括下:
元数据中心来维护RPC服务与应用的映射关系（即接口与应用的映射关系）来兼容接口与应用之间的对应关系 让注册中心更加聚焦与地址的发现和推送能力 元数据中心的启动是在DefaultApplicationDeployer中的初始化方法 initialize() 中:如下所示
这里只看下 startMetadataCenter();方法即可
@Override public void initialize() { if (initialized) { return; } // Ensure that the initialization is completed when concurrent calls synchronized (startLock) { if (initialized) { return; } // register shutdown hook registerShutdownHook(); startConfigCenter(); loadApplicationConfigs(); initModuleDeployers(); // @since 2.7.8 startMetadataCenter(); initialized = true; if (logger.</description></item><item><title>14-Dubbo配置加载全解析</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/14/14-dubbo%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%A7%A3%E6%9E%90/</link><pubDate>Sun, 14 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/14/14-dubbo%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%A7%A3%E6%9E%90/</guid><description>14-Dubbo配置加载全解析 14.1 回到启动器的初始化过程 在应用程序启动的时候会调用发布器的启动方法 ,然后调用初始化方法,在发布器DefaultApplicationDeployer中的初始化方法initialize() 如下:
@Override public void initialize() { if (initialized) { return; } // Ensure that the initialization is completed when concurrent calls synchronized (startLock) { if (initialized) { return; } // register shutdown hook registerShutdownHook(); startConfigCenter(); loadApplicationConfigs(); initModuleDeployers(); // @since 2.7.8 startMetadataCenter(); initialized = true; if (logger.isInfoEnabled()) { logger.info(getIdentifier() + &amp;#34; has been initialized!&amp;#34;); } } } 初始化过程中会先启动配置中心配置信息处理,然后 调用加载初始化应用程序配置方法loadApplicationConfigs();进行配置加载 关于配置的官方文档链接为 配置概述
Dubbo框架的配置项比较繁多，为了更好地管理各种配置，将其按照用途划分为不同的组件，最终所有配置项都会汇聚到URL中，传递给后续处理模块。
常用配置组件如下：
application: Dubbo应用配置 registry: 注册中心 protocol: 服务提供者RPC协议 config-center: 配置中心 metadata-report: 元数据中心 service: 服务提供者配置 reference: 远程服务引用配置 provider: service的默认配置或分组配置 consumer: reference的默认配置或分组配置 module: 模块配置 monitor: 监控配置 metrics: 指标配置 ssl: SSL/TLS配置 配置还有几个比较重要的点:</description></item><item><title>13-Dubbo的三大中心之配置中心</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/13/13-dubbo%E7%9A%84%E4%B8%89%E5%A4%A7%E4%B8%AD%E5%BF%83%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</link><pubDate>Sat, 13 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/13/13-dubbo%E7%9A%84%E4%B8%89%E5%A4%A7%E4%B8%AD%E5%BF%83%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</guid><description>13-Dubbo的三大中心之配置中心 13.1 配置中心简介 百度了一段不错的文字来介绍配置中心，我看了下肯定比我写的好多了，那我就直接拷贝过来一起看：
对于传统的单体应用而言，常使用配置文件来管理所有配置，比如SpringBoot的application.yml文件，但是在微服务架构中全部手动修改的话很麻烦而且不易维护。微服务的配置管理一般有以下需求：
集中配置管理，一个微服务架构中可能有成百上千个微服务，所以集中配置管理是很重要的。 不同环境不同配置，比如数据源配置在不同环境（开发，生产，测试）中是不同的。 运行期间可动态调整。例如，可根据各个微服务的负载情况，动态调整数据源连接池大小等。 配置修改后可自动更新。如配置内容发生变化，微服务可以自动更新配置。 综上所述对于微服务架构而言，一套统一的，通用的管理配置机制是不可缺少的主要组成部分。常见的做法就是通过配置服务器进行管理。
不过对于来看这个文章的小伙伴应该大部分对配置中心都会比较了解，分布式配置中心实现简单一点就是借助Zookeeper来协助存储，变更推送，不过为了实现各种不同的业务需求，市面上已经有很多很可靠的配置中心可用了，比如我从其他地方拷贝过来的图（虽然不是最新的但是可以供大家参考下）：
每个配置中心都有自己的实现，如果对配置中心感兴趣的小伙伴可以自行去对应开源项目官网查看，我们这里来看Dubbo对配置中心的支持
多配置中心： Dubbo支持多配置中心，来 保证其中一个配置中心集群出现不可用时能够切换到另一个配置中心集群 ，保证能够正常从配置中心获取全局的配置、路由规则等信息。这也能够满足配置中心在部署上适应各类高可用的部署架构模式。-来自官网
做中间件可能考虑更多的的不仅仅是性能，还要过多的考虑高可用，高可用怎么做呢，其实就是失效转移，主备切换，降级，降级再降级这些理论的运用，多多考虑某一个服务挂了怎么办，Dubbo的多配置中心支持增加了复杂性，不过降低了服务不可用的风险，有一定的人手的公司还是值得做的。
关于Dubbo的配置中心这里我来贴个官网的图: 关于官网的介绍可以自行去官网看详细内容: 部署架构(注册中心、配置中心、元数据中心
13.2 启动配置中心 在上一个博客中说到了《12-全局视野来看Dubbo3.0.8的服务启动生命周期》Dubbo应用的启动过程DefaultApplicationDeployer的initialize()方法的全生命周期，在初始化方法中通过调用startConfigCenter();方法来启动配置中心的加载。后面就来详细看下：
DefaultApplicationDeployer类型的startConfigCenter()代码如下：
private void startConfigCenter() { // load application config //加载应用程序配置 （配置可能有多个地方可以配置需要遵循Dubbo约定的优先级进行设置，也可能是多应用，多注册中心这样的配置） configManager.loadConfigsOfTypeFromProps(ApplicationConfig.class); // try set model name if (StringUtils.isBlank(applicationModel.getModelName())) { //设置一下模块名字和模块描述（我们再Debug里面经常会看到这个描述信息 toString直接返回了Dubbo为我们改造的对象信息） applicationModel.setModelName(applicationModel.tryGetApplicationName()); } // load config centers //加载配置中心配置 //配置可能有多个地方可以配置需要遵循Dubbo约定的优先级进行设置，也可能是多应用，多注册中心这样的配置） configManager.loadConfigsOfTypeFromProps(ConfigCenterConfig.class); //出于兼容性目的，如果没有明确指定配置中心，并且registryConfig的UseAConfigCenter为null或true，请使用registry作为默认配置中心 useRegistryAsConfigCenterIfNecessary(); // check Config Center //配置管理器中获取配置中心 Collection&amp;lt;ConfigCenterConfig&amp;gt; configCenters = configManager.getConfigCenters(); //配置中心配置不为空则刷新配置中心配置将其放入配置管理器中 //下面开始刷新配置中心配置,如果配置中心配置为空则执行空刷新 if (CollectionUtils.isEmpty(configCenters)) { //配置中心不存在的配置刷新 ConfigCenterConfig configCenterConfig = new ConfigCenterConfig(); configCenterConfig.</description></item><item><title>12 全局视野来看Dubbo3的服务启动生命周期</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/12/12-%E5%85%A8%E5%B1%80%E8%A7%86%E9%87%8E%E6%9D%A5%E7%9C%8Bdubbo3%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link><pubDate>Fri, 12 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/12/12-%E5%85%A8%E5%B1%80%E8%A7%86%E9%87%8E%E6%9D%A5%E7%9C%8Bdubbo3%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid><description>12 全局视野来看Dubbo3的服务启动生命周期 12.1 启动方法简介 在说启动方法之前先把视野拉回第一章《1-从一个服务提供者的Demo说起》我们的Demo代码,下面只贴一下核心代码:
public class Application { public static void main(String[] args) throws Exception { startWithBootstrap(); } private static void startWithBootstrap() { //前面的文章都在说这个服务配置对象的创建,中间又说了分层域模型,扩展加载机制 ServiceConfig&amp;lt;DemoServiceImpl&amp;gt; service = new ServiceConfig&amp;lt;&amp;gt;(); //为服务配置下服务接口和服务实现,下面两行用来初始化对象就不详细说了 service.setInterface(DemoService.class); service.setRef(new DemoServiceImpl()); //这一个篇章主要说这里: DubboBootstrap bootstrap = DubboBootstrap.getInstance(); //初始化应用配置 bootstrap.application(new ApplicationConfig(&amp;#34;dubbo-demo-api-provider&amp;#34;)) //初始化注册中心配置 .registry(new RegistryConfig(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;)) //初始化协议配置 .protocol(new ProtocolConfig(CommonConstants.DUBBO, -1)) //初始化服务配置 .service(service) //启动 .start() .await(); } } 前面我们介绍了Dubbo启动器DubboBootstrap类型对象的创建,又介绍了为DubboBootstrap启动器初始化各种配置信息,这一个博客就开始到了分析启动方法的位置了,Dubbo启动器借助Deployer发布器来启动和发布服务,发布器的启动过程包含了启动配置中心,加载配置,启动元数据中心,启动服务等操作都是比较重要又比较复杂的过程,这里我们先来看下启动过程的生命周期来为后面的内容做好铺垫。
12.2 启动器启动方法的调用逻辑start() 这里我们就直接来看DubboBootstrap的start()方法:
public DubboBootstrap start() { //调用重载的方法进行启动参数代表是否等待启动结束 this.start(true); return this; } 我们再来看重载的start方法:</description></item><item><title>11-Dubbo启动器DubboBootstrap添加协议配置信息ProtocolConfig</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/11/11-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E6%B7%BB%E5%8A%A0%E5%8D%8F%E8%AE%AE%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AFprotocolconfig/</link><pubDate>Thu, 11 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/11/11-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E6%B7%BB%E5%8A%A0%E5%8D%8F%E8%AE%AE%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AFprotocolconfig/</guid><description>11-Dubbo启动器DubboBootstrap添加协议配置信息ProtocolConfig 11.1 简介 先贴个代码用来参考:
DubboBootstrap bootstrap = DubboBootstrap.getInstance(); bootstrap.application(new ApplicationConfig(&amp;#34;dubbo-demo-api-provider&amp;#34;)) .registry(new RegistryConfig(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;)) .protocol(new ProtocolConfig(CommonConstants.DUBBO, -1)) .service(service) .start() .await(); 上个博客我们说了 RegistryConfig对象的创建,启动器对象在启动之前是要初始化一些配置信息的,这里我们来看这一行代码协议配置信息:
.protocol(new ProtocolConfig(CommonConstants.DUBBO, -1)) 11.2 协议的配置相关 下面的配置来源于官网
服务提供者协议配置。对应的配置类： org.apache.dubbo.config.ProtocolConfig。同时，如果需要支持多协议，可以声明多个 dubbo:protocol 标签，并在 dubbo:service 中通过 protocol 属性指定使用的协议。
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 id string 可选 dubbo 配置关联 协议BeanId，可以在&amp;lt;dubbo:service protocol=&amp;quot;&amp;quot;&amp;gt;中引用此ID，如果ID不填，缺省和name属性值一样，重复则在name后加序号。 2.0.5以上版本 name string 必填 dubbo 性能调优 协议名称 2.0.5以上版本 port int 可选 dubbo协议缺省端口为20880，rmi协议缺省端口为1099，http和hessian协议缺省端口为80；如果没有配置port，则自动采用默认端口，如果配置为**-1**，则会分配一个没有被占用的端口。Dubbo 2.4.0+，分配的端口在协议缺省端口的基础上增长，确保端口段可控。 服务发现 服务端口 2.0.5以上版本 host string 可选 自动查找本机IP 服务发现 -服务主机名，多网卡选择或指定VIP及域名时使用，为空则自动查找本机IP，-建议不要配置，让Dubbo自动获取本机IP 2.</description></item><item><title>10-Dubbo启动器DubboBootstrap添加注册中心配置信息RegistryConfig</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/10/10-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E6%B7%BB%E5%8A%A0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AFregistryconfig/</link><pubDate>Wed, 10 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/10/10-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E6%B7%BB%E5%8A%A0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AFregistryconfig/</guid><description>10-Dubbo启动器DubboBootstrap添加注册中心配置信息RegistryConfig 10.1 简介 先贴个代码用来参考:
DubboBootstrap bootstrap = DubboBootstrap.getInstance(); bootstrap.application(new ApplicationConfig(&amp;#34;dubbo-demo-api-provider&amp;#34;)) .registry(new RegistryConfig(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;)) .protocol(new ProtocolConfig(CommonConstants.DUBBO, -1)) .service(service) .start() .await(); 上个博客我们说了启动器ApplicationConfig对象的创建,启动器对象在启动之前是要初始化一些配置信息的,这里我们来看这一行代码注册中心配置信息:
registry(new RegistryConfig(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;)) 10.2 注册中心的配置相关 下面的配置来源于官网
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 id string 可选 配置关联 注册中心引用BeanId，可以在&amp;lt;dubbo:service registry=&amp;quot;&amp;quot;&amp;gt;或&amp;lt;dubbo:reference registry=&amp;quot;&amp;quot;&amp;gt;中引用此ID 1.0.16以上版本 address host:port string 必填 服务发现 注册中心服务器地址，如果地址没有端口缺省为9090，同一集群内的多个地址用逗号分隔，如：ip:port,ip:port，不同集群的注册中心，请配置多个dubbo:registry标签 1.0.16以上版本 protocol string 可选 dubbo 服务发现 注册中心地址协议，支持dubbo, multicast, zookeeper, redis, consul(2.7.1), sofa(2.7.2), etcd(2.7.2), nacos(2.7.2)等协议 2.0.0以上版本 port int 可选 9090 服务发现 注册中心缺省端口，当address没有带端口时使用此端口做为缺省值 2.0.0以上版本 username string 可选 服务治理 登录注册中心用户名，如果注册中心不需要验证可不填 2.</description></item><item><title>9-Dubbo启动器DubboBootstrap添加应用程序的配置信息ApplicationConfig</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/09/9-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E6%B7%BB%E5%8A%A0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AFapplicationconfig/</link><pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/09/9-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E6%B7%BB%E5%8A%A0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AFapplicationconfig/</guid><description>9-Dubbo启动器DubboBootstrap添加应用程序的配置信息ApplicationConfig 9.1 简介 先贴个代码用来参考:
DubboBootstrap bootstrap = DubboBootstrap.getInstance(); bootstrap.application(new ApplicationConfig(&amp;#34;dubbo-demo-api-provider&amp;#34;)) .registry(new RegistryConfig(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;)) .protocol(new ProtocolConfig(CommonConstants.DUBBO, -1)) .service(service) .start() .await(); 上个博客我们说了启动器对象的创建,启动器对象在启动之前是要初始化一些配置信息的,这里我们来看这一行代码:
bootstrap.application(new ApplicationConfig(&amp;#34;dubbo-demo-api-provider&amp;#34;)) 9.2 应用程序ApplicationConfig的配置信息 ApplicationConfig的构造器比较简单就是为他的成员变量name赋值来标识这个应用程序的名字 下面我们直接参考下官网的配置表格:
属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性 name application string 必填 服务治理 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样，此参数不是匹配条件，你当前项目叫什么名字就填什么，和提供者消费者角色无关，比如：kylin应用调用了morgan应用的服务，则kylin项目配成kylin，morgan项目配成morgan，可能kylin也提供其它服务给别人使用，但kylin项目永远配成kylin，这样注册中心将显示kylin依赖于morgan 1.0.16以上版本 version application.version string 可选 服务治理 当前应用的版本 2.2.0以上版本 owner owner string 可选 服务治理 应用负责人，用于服务治理，请填写负责人公司邮箱前缀 2.0.5以上版本 organization organization string 可选 服务治理 组织名称(BU或部门)，用于注册中心区分服务来源，此配置项建议不要使用autoconfig，直接写死在配置中，比如china,intl,itu,crm,asc,dw,aliexpress等 2.0.0以上版本 architecture architecture string 可选 服务治理 用于服务分层对应的架构。如，intl、china。不同的架构使用不同的分层。 2.0.7以上版本 environment environment string 可选 服务治理 应用环境，如：develop/test/product，不同环境使用不同的缺省值，以及作为只用于开发测试功能的限制条件 2.</description></item><item><title>8-Dubbo启动器DubboBootstrap借助双重校验锁的单例模式进行对象的初始化</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/08/8-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E5%80%9F%E5%8A%A9%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</link><pubDate>Mon, 08 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/08/8-dubbo%E5%90%AF%E5%8A%A8%E5%99%A8dubbobootstrap%E5%80%9F%E5%8A%A9%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</guid><description>8-Dubbo启动器DubboBootstrap借助双重校验锁的单例模式进行对象的初始化 8.1 启动器简介 在说启动器之前先把视野拉回第一章《1-从一个服务提供者的Demo说起》我们的Demo代码,下面只贴一下核心代码:
public class Application { public static void main(String[] args) throws Exception { startWithBootstrap(); } private static void startWithBootstrap() { //前面的文章都在说这个服务配置对象的创建,中间又说了分层域模型,扩展加载机制 ServiceConfig&amp;lt;DemoServiceImpl&amp;gt; service = new ServiceConfig&amp;lt;&amp;gt;(); //为服务配置下服务接口和服务实现,下面两行用来初始化对象就不详细说了 service.setInterface(DemoService.class); service.setRef(new DemoServiceImpl()); //这一个篇章主要说这里: DubboBootstrap bootstrap = DubboBootstrap.getInstance(); bootstrap.application(new ApplicationConfig(&amp;#34;dubbo-demo-api-provider&amp;#34;)) .registry(new RegistryConfig(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;)) .protocol(new ProtocolConfig(CommonConstants.DUBBO, -1)) .service(service) .start() .await(); } } Dubbo3 往云原生的方向走自然要针对云原生应用的应用启动,应用运行,应用发布等信息做一些建模,这个DubboBootstrap就是用来启动Dubbo服务的.类似于Netty的Bootstrap类型和ServerBootstrap启动器
8.2 双重校验锁的单例模式创建启动器对象的 Dubbo的bootstrap类为啥要用单例模式:
通过调用静态方法getInstance()获取单例实例。之所以设计为单例，是因为Dubbo中的一些类（如ExtensionLoader）只为每个进程设计一个实例。
下面就来直接看代码吧,代码胜千言: 对象的调用代码如下:
DubboBootstrap bootstrap = DubboBootstrap.getInstance(); DubboBootstrap获取对象的getInstance()方法:
public static DubboBootstrap getInstance() { //双重校验锁第一次判断空 if (instance == null) { //为空都进行排队 synchronized (DubboBootstrap.</description></item><item><title>7-Dubbo的SPI扩展机制之自动激活扩展Activate源码解析</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/07/7-dubbo%E7%9A%84spi%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%BF%80%E6%B4%BB%E6%89%A9%E5%B1%95activate%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Sun, 07 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/07/7-dubbo%E7%9A%84spi%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%BF%80%E6%B4%BB%E6%89%A9%E5%B1%95activate%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>7-Dubbo的SPI扩展机制之自动激活扩展Activate源码解析 7.1 Activate扩展的说明 此注解对于使用给定条件自动激活某些扩展非常有用，例如：@Activate可用于在有多个实现时加载某些筛选器扩展。
group() 指定组条件。框架SPI定义了有效的组值。 value() 指定URL条件中的参数键。 SPI提供程序可以调用ExtensionLoader。getActivateExtension(URL、String、String)方法以查找具有给定条件的所有已激活扩展。
比如后面我们会说到的过滤器扩展对象的获取,如下通过调用getActivateExtension方法的代码:
List&amp;lt;Filter&amp;gt; filters; filters = ScopeModelUtil.getExtensionLoader(Filter.class, moduleModels.get(0)).getActivateExtension(url, key, group); 7.2 获取自动激活扩展的源码 前面我们看了激活扩展是通过调用getActivateExtension方法来获取对象的,那接下来就来看下这个方法做了什么操作:
/** * @param url 服务的url * @param key 用于获取扩展点名称的url参数键 比如监听器:exporter.listener,过滤器:params-filter,telnet处理器:telnet */ public List&amp;lt;T&amp;gt; getActivateExtension(URL url, String key) { return getActivateExtension(url, key, null); } 继续调用重载的方法
/** * * * @param url 服务的url * @param key 用于获取扩展点名称的url参数键 比如监听器:exporter.listener,过滤器:params-filter,telnet处理器:telnet * @param group group 用于筛选的分组,比如过滤器中使用此参数来区分消费者使用这个过滤器还是提供者使用这个过滤器他们的group参数分表为consumer,provider * @return 已激活的扩展列表。 */ public List&amp;lt;T&amp;gt; getActivateExtension(URL url, String key, String group) { //从参数中获取url指定的值 String value = url.</description></item><item><title>06-Dubbo的SPI扩展机制之普通扩展对象的创建与Wrapper机制的源码解析</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/06/06-dubbo%E7%9A%84spi%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%99%AE%E9%80%9A%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8Ewrapper%E6%9C%BA%E5%88%B6%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Sat, 06 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/06/06-dubbo%E7%9A%84spi%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%99%AE%E9%80%9A%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8Ewrapper%E6%9C%BA%E5%88%B6%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>6 Dubbo的SPI扩展机制之普通扩展对象的创建与Wrapper机制的源码解析 6.1 普通扩展对象的加载与创建 这里我们要分析的是ExtensionLoader类型的getExtension(String name)方法, 有了前面自适应扩展的铺垫,这里就更容易来看了getExtension是根据扩展名字获取具体扩展的通用方法,我们来根据某个类型来获取扩展的时候就是走的这里,比如在这个博客开头的介绍:
ApplicationModel中获取配置管理器对象 configManager = (ConfigManager) this.getExtensionLoader(ApplicationExt.class) .getExtension(ConfigManager.NAME); 6.1.1 getExtension方法源码 先来看下getExtension方法的源码,根据扩展名字查询扩展对象
public T getExtension(String name) { //这里并不能看到什么,只多传了个参数wrap为true调用另外一个重载的方法 T extension = getExtension(name, true); if (extension == null) { throw new IllegalArgumentException(&amp;#34;Not find extension: &amp;#34; + name); } return extension; } public T getExtension(String name, boolean wrap) { //检查扩展加载器是否已被销毁 checkDestroyed(); if (StringUtils.isEmpty(name)) { throw new IllegalArgumentException(&amp;#34;Extension name == null&amp;#34;); } //扩展名字为true则加载默认扩展 if (&amp;#34;true&amp;#34;.equals(name)) { return getDefaultExtension(); } //非wrap类型则将缓存的扩展名字key加上_origin后缀 //wrap是aop机制 俗称切面,这个origin在aop里面可以称为切点,下面的wrap扩展可以称为增强通知的类型,普通扩展和wrap扩展的扩展名字是一样的 String cacheKey = name; if (!</description></item><item><title>05-自适应扩展对象的创建getAdaptiveExtension方法</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/05/05-%E8%87%AA%E9%80%82%E5%BA%94%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BAgetadaptiveextension%E6%96%B9%E6%B3%95/</link><pubDate>Fri, 05 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/05/05-%E8%87%AA%E9%80%82%E5%BA%94%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BAgetadaptiveextension%E6%96%B9%E6%B3%95/</guid><description>5 自适应扩展对象的创建getAdaptiveExtension方法 自适应扩展又称为动态扩展,可以在运行时生成扩展对象
ExtensionLoader中的getAdaptiveExtension()方法,这个方法也是我们看到的第一个获取扩展对象的方法. ,这个方法可以帮助我们通过SPI机制从扩展文件中找到需要的扩展类型并创建它的对象, 自适应扩展:如果对设计模式比较了解的可能会联想到适配器模式,自适应扩展其实就是适配器模式的思路,自适应扩展有两种策略:
一种是我们自己实现自适应扩展:然后使用@Adaptive修饰这个时候适配器的逻辑由我们自己实现,当扩展加载器去查找具体的扩展的时候可以通过找到我们这个对应的适配器扩展,然后适配器扩展帮忙去查询真正的扩展,这个比如我们下面要举的扩展注入器的例子,具体扩展通过扩展注入器适配器,注入器适配器来查询具体的注入器扩展实现来帮忙查找扩展。
还有一种方式是我们未实现这个自适应扩展,Dubbo在运行时通过字节码动态代理的方式在运行时生成一个适配器,使用这个适配器映射到具体的扩展. 第二种情况往往用在比如 Protocol、Cluster、LoadBalance 等。有时，有些拓展并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载。(如果还不了解可以考虑看下@Adaptive注解加载方法上面的时候扩展是如何加载的)
public T getAdaptiveExtension() { //检查当前扩展加载器是否已经被销毁 checkDestroyed(); //从自适应扩展缓存中查询扩展对象如果存在就直接返回,这个自适应扩展类型只会有一个扩展实现类型如果是多个的话根据是否可以覆盖参数决定扩展实现类是否可以相互覆盖 Object instance = cachedAdaptiveInstance.get(); //这个if判断不太优雅 容易多层嵌套,上面instance不为空就可以直接返回了 if (instance == null) { //创建异常则抛出异常直接返回(多线程场景下可能第一个线程异常了第二个线程进来之后走到这里) if (createAdaptiveInstanceError != null) { throw new IllegalStateException(&amp;#34;Failed to create adaptive instance: &amp;#34; + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError); } //加锁排队 (单例模式创建对象的思想 双重校验锁) synchronized (cachedAdaptiveInstance) { //加锁的时候对象都是空的,进来之后先判断下防止重复创建 instance = cachedAdaptiveInstance.get(); //只有第一个进来锁的对象为空开始创建扩展对象 if (instance == null) { try { //根据SPI机制获取类型,创建对象 instance = createAdaptiveExtension(); //存入缓存 cachedAdaptiveInstance.</description></item><item><title>04-Dubbo的扩展机制</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/04/04-dubbo%E7%9A%84%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/</link><pubDate>Thu, 04 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/04/04-dubbo%E7%9A%84%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/</guid><description>4-Dubbo的扩展机制 4.1 回顾我们前面使用到扩展场景 在上一章中我们初始化应用模型对象的时候,了解到有几个地方用到了扩展机制来创建对象,这一章我们会详细来讲一下这个扩展对象的加载过程,这里我们先来回顾下哪些地方用到了扩展机制:
// 使用扩展机制获取TypeBuilder Set&amp;lt;TypeBuilder&amp;gt; tbs = model.getExtensionLoader(TypeBuilder.class).getSupportedExtensionInstances(); //获取域模型初始化器ScopeModelInitializer扩展对象,执行初始化方法 ExtensionLoader&amp;lt;ScopeModelInitializer&amp;gt; initializerExtensionLoader = this.getExtensionLoader(ScopeModelInitializer.class); Set&amp;lt;ScopeModelInitializer&amp;gt; initializers = initializerExtensionLoader.getSupportedExtensionInstances(); // OrderedPropertiesConfiguration 中获取有序配置提供器对象 ExtensionLoader&amp;lt;OrderedPropertiesProvider&amp;gt; propertiesProviderExtensionLoader = moduleModel.getExtensionLoader(OrderedPropertiesProvider.class); // ApplicationModel中获取配置管理器对象 configManager = (ConfigManager) this.getExtensionLoader(ApplicationExt.class) .getExtension(ConfigManager.NAME); //ModuleModel中获取模块扩展对象 Set&amp;lt;ModuleExt&amp;gt; exts = this.getExtensionLoader(ModuleExt.class).getSupportedExtensionInstances(); // ApplicationModel中获Environment对象 environment = (Environment) this.getExtensionLoader(ApplicationExt.class) .getExtension(Environment.NAME); // ApplicationModel中获取应用初始化监听器ApplicationInitListener扩展对象 ExtensionLoader&amp;lt;ApplicationInitListener&amp;gt; extensionLoader = this.getExtensionLoader(ApplicationInitListener.class); Set&amp;lt;String&amp;gt; listenerNames = extensionLoader.getSupportedExtensions(); //ScopeModel中创建扩展访问器: this.extensionDirector = new ExtensionDirector(parent != null ? parent.getExtensionDirector() : null, scope, this); 有了以上的应用场景我们可以来看下扩展机制了
4.2 为什么要用到扩展机制?</description></item><item><title>03-框架,应用程序,模块领域模型Model对象的初始化</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/03/03-%E6%A1%86%E6%9E%B6%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8Bmodel%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</link><pubDate>Wed, 03 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/03/03-%E6%A1%86%E6%9E%B6%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8Bmodel%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</guid><description>3-框架,应用程序,模块领域模型Model对象的初始化 在上一章中我们详细看了服务配置ServiceConfig类型的初始化，不过我们跳过了AbstractMethodConfig的构造器中创建模块模型对象的过程，那这一章我们就来看下模块模型对象的初始化过程:
public AbstractMethodConfig() { super(ApplicationModel.defaultModel().getDefaultModule()); } 那为什么会在Dubbo3的新版本中加入这个域模型呢，主要有如下原因 之前dubbo都是只有一个作用域的，通过静态类 属性共享 增加域模型是为了:
让Dubbo支持多应用的部署，这块一些大企业有诉求 从架构设计上，解决静态属性资源共享、清理的问题 分层模型将应用的管理和服务的管理分开 可能比较抽象，可以具体点来看。Dubbo3中在启动时候需要启动配置中心、元数据中心，这个配置中心和元数据中心可以归应用模型来管理。Dubbo作为RPC框架又需要启动服务和引用服务，服务级别的管理就交给了这个模块模型来管理。分层次的管理方便我们理解和处理逻辑，父子级别的模型又方便了数据传递。
了解过JVM类加载机制的同学应该就比较清楚JVM类加载过程中的数据访问模型。子类加载器先交给父类加载器查找，找不到再从子类加载器中查找。Dubbo的分层模型类似这样一种机制，这一章先来简单了解下，后面用到时候具体细说。
3.1 模型对象的关系 为了不增加复杂性，我们这里仅仅列出模型对象类型类型之间的继承关系如下所示: 图3.1 模型对象的继承关系 模型对象一共有4个，公共的属性和操作放在了域模型类型中，下面我们来详细说下这几个模型类型:
ExtensionAccessor 扩展的统一访问器
用于获取扩展加载管理器ExtensionDirector对象 获取扩展对象ExtensionLoader 根据扩展名字获取具体扩展对象 获取自适应扩展对象 获取默认扩展对象 ScopeModel 模型对象的公共抽象父类型
内部id用于表示模型树的层次结构 公共模型名称，可以被用户设置 描述信息 类加载器管理 父模型管理parent 当前模型的所属域ExtensionScope有:FRAMEWORK(框架)，APPLICATION(应用)，MODULE(模块)，SELF(自给自足，为每个作用域创建一个实例，用于特殊的SPI扩展，如ExtensionInjector) 具体的扩展加载程序管理器对象的管理:ExtensionDirector 域Bean工厂管理，一个内部共享的Bean工厂ScopeBeanFactory 等等 FrameworkModel dubbo框架模型，可与多个应用程序共享
FrameworkModel实例对象集合，allInstances 所有ApplicationModel实例对象集合，applicationModels 发布的ApplicationModel实例对象集合pubApplicationModels 框架的服务存储库FrameworkServiceRepository类型对象(数据存储在内存中) 内部的应用程序模型对象internalApplicationModel ApplicationModel 表示正在使用Dubbo的应用程序，并存储基本元数据信息，以便在RPC调用过程中使用。 ApplicationModel包括许多关于发布服务的ProviderModel和许多关于订阅服务的Consumer Model。
ExtensionLoader、DubboBootstrap和这个类目前被设计为单例或静态（本身完全静态或使用一些静态字段）。因此，从它们返回的实例属于流程范围。如果想在一个进程中支持多个dubbo服务器，可能需要重构这三个类。 所有ModuleModel实例对象集合moduleModels 发布的ModuleModel实例对象集合pubModuleModels 环境信息Environment实例对象environment 配置管理ConfigManager实例对象configManager 服务存储库ServiceRepository实例对象serviceRepository 应用程序部署器ApplicationDeployer实例对象deployer 所属框架FrameworkModel实例对象frameworkModel 内部的模块模型ModuleModel实例对象internalModule 默认的模块模型ModuleModel实例对象defaultModule ModuleModel 服务模块的模型
所属应用程序模型ApplicationModel实例对象applicationModel 模块环境信息ModuleEnvironment实例对象moduleEnvironment 模块服务存储库ModuleServiceRepository实例对象serviceRepository 模块的服务配置管理ModuleConfigManager实例对象moduleConfigManager 模块部署器ModuleDeployer实例对象deployer用于导出和引用服务 了解了这几个模型对象的关系我们可以了解到这几个模型对象的管理层级从框架到应用程序，然后到模块的管理(FrameworkModel-&amp;gt;ApplicationModel-&amp;gt;ModuleModel)，他们主要用来针对框架，应用程序，模块的存储，发布管理，，配置管理
看来Dubbo3 针对应用服务治理与运维这一块也是在努力尝试.</description></item><item><title>02-启动服务前服务配置ServiceConfig类型是如何初始化的?</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/02/02-%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%89%8D%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AEserviceconfig%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84/</link><pubDate>Tue, 02 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/02/02-%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%89%8D%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AEserviceconfig%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84/</guid><description>2-启动服务前服务配置ServiceConfig类型是如何初始化的? 2.1 示例源码回顾: 为了方便我们理解记忆,这里先来回顾下上一章我们说的示例代码,如下所示:
public class Application { public static void main(String[] args) throws Exception { startWithBootstrap(); } private static void startWithBootstrap() { ServiceConfig&amp;lt;DemoServiceImpl&amp;gt; service = new ServiceConfig&amp;lt;&amp;gt;(); service.setInterface(DemoService.class); service.setRef(new DemoServiceImpl()); DubboBootstrap bootstrap = DubboBootstrap.getInstance(); bootstrap.application(new ApplicationConfig(&amp;#34;dubbo-demo-api-provider&amp;#34;)) .registry(new RegistryConfig(&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;)) .protocol(new ProtocolConfig(CommonConstants.DUBBO, -1)) .service(service) .start() .await(); } } 上面这几行代码虽然看似简单,仅仅几行的启动,但是完全掌握也得下一翻大功夫,接下来我们重点看启动代码中的第一行,创建一个服务配置对象:
ServiceConfig&amp;lt;DemoServiceImpl&amp;gt; service = new ServiceConfig&amp;lt;&amp;gt;(); 2.2 了解一下服务配置的建模 下面是一个简单的UML继承关系图,当然这个图很是简单的,这里仅仅列出了当前服务提供者的相关服务配置继承关系, 服务提供者独有的配置标注颜色为蓝色,一些可能与服务引用配置所共有的父类型我们用红色背景,当然这里为了简便起见不会提起服务引用相关的配置类型,这里列举了如下服务提供者类型,他们各司其职: 图2.1 服务引用类继承关系UML AbstractConfig 抽象的配置类型,也是最顶层的服务配置类型,封装着解析配置的实用方法和公共方法,比如服务id的设置,服务标签名字的处理,服务参数的添加,属性的提取等等 AbstractMethodConfig 抽象的方法配置,同样这个类型也是见名知意,服务方法的相关配置处理,这个类型主要用于对服务方法的一些配置信息建模比如服务方法的调用超时时间,重试次数,最大并发调用数,负载均衡策略,是否异步调用,是否确认异步发送等等配置信息. AbstractInterfaceConfig 抽象的接口配置,与前面介绍的方法配置类似,这个类型是对服务接口的建模,主要的配置信息有暴漏服务的接口名字,服务接口的版本号,客户/提供方将引用的远程服务分组,服务元数据,服务接口的本地impl类名,服务监控配置,对于生成动态代理的策略，可以选择两种策略：jdk和javassist,容错类型等等配置 AbstractServiceConfig 抽象的服务配置,这个就与我们的服务提供者有了具体的关系了,主要记录了一些服务提供者的公共配置,如服务版本,服务分组,服务延迟注册毫秒数,是否暴漏服务,服务权重,是否为动态服务,服务协议类型,是否注册等等. ServiceConfigBase 服务的基础配置类,这个类型仍旧是个抽象的类型提取了一些基础的配置:导出服务的接口类,服务名称,接口实现的引用类型,提供者配置,是否是通用服务GenericService ServiceConfig 服务配置实现类, 上面的类型都是抽象类型不能做为具体存在的事物,这个类型是我们出现的第一个服务配置实现类型,服务配置实现类已经从父类型中继承了这么多的属性,这里主要为实现服务提供了一些配置如服务的协议配置,服务的代理工厂JavassistProxyFactory是将生成导出服务代理的ProxyFactory实现，是其默认实现,服务提供者模型,是否导出服务,导出的服务列表,服务监听器等等.</description></item><item><title>01 从一个服务提供者的Demo说起</title><link>https://dubbo.apache.org/zh-cn/blog/2022/08/01/01-%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E7%9A%84demo%E8%AF%B4%E8%B5%B7/</link><pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/08/01/01-%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E7%9A%84demo%E8%AF%B4%E8%B5%B7/</guid><description>1 从一个服务提供者的Demo说起 为了更方便了解原理,我们先来编写一个Demo,从例子中来看源码实现:
1.1 启动Zookeeper 为了Demo可以正常启动,需要我们先在本地启动一个Zookeeper如下图所示: 1.2 服务提供者 接下来给大家贴一下示例源码,这个源码来源于Dubbo源码目录的	dubbo-demo/dubbo-demo-api 目录下面的dubbo-demo-api-provider子项目,这里我做了删减,方便看核心代码: 首先我们定义一个服务接口如下所示:
import java.util.concurrent.CompletableFuture; public interface DemoService { /** * 同步处理的服务方法 * @param name * @return */ String sayHello(String name); /** * 用于异步处理的服务方法 * @param name * @return */ default CompletableFuture&amp;lt;String&amp;gt; sayHelloAsync(String name) { return CompletableFuture.completedFuture(sayHello(name)); } } 服务实现类如下: import org.apache.dubbo.rpc.RpcContext; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.util.concurrent.CompletableFuture; public class DemoServiceImpl implements DemoService { private static final Logger logger = LoggerFactory.getLogger(DemoServiceImpl.class); @Override public String sayHello(String name) { logger.</description></item><item><title>Rest 协议</title><link>https://dubbo.apache.org/zh-cn/blog/2022/07/26/rest-%E5%8D%8F%E8%AE%AE/</link><pubDate>Tue, 26 Jul 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/07/26/rest-%E5%8D%8F%E8%AE%AE/</guid><description>Dubbo RestProtocol 设计文档 原版本dubbo rest consumer
restClient支持 依赖resteasy 不支持spring mvc provider(较重)
依赖web container (tomcat,jetty，)servlet 模式，jaxrs netty server
改版dubbo rest 方向：
更加轻量，具有dubbo风格的rest，微服务体系互通（Springcloud Alibaba）
1.注解解析
2.报文编解码
3.restClient
4.restServer(netty)
支持程度：
content-type text json xml form(后续会扩展)
注解
param,header,body,pathvariable （spring mvc &amp;amp; resteasy）
Http 协议报文 POST /test/path? HTTP/1.1 Host: localhost:8080 Connection: keep-alive Content-type: application/json {&amp;quot;name&amp;quot;:&amp;quot;dubbo&amp;quot;,&amp;quot;age&amp;quot;:10,&amp;quot;address&amp;quot;:&amp;quot;hangzhou&amp;quot;} dubbo http(header) // service key header path: com.demo.TestInterface group: demo port: 80 version: 1.0.0 // 保证长连接 Keep-Alive,Connection: keep-alive Keep-alive: 60 // RPCContext Attachment userId: 123456 目前支持粒度： 数据位置 content-type spring注解 resteasy注解 body 无要求 ReuqestBody 无注解即为body querystring(?</description></item><item><title>浅析 Dubbo 3.0 中接口级地址推送性能的优化</title><link>https://dubbo.apache.org/zh-cn/blog/2022/06/23/%E6%B5%85%E6%9E%90-dubbo-3.0-%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%BA%A7%E5%9C%B0%E5%9D%80%E6%8E%A8%E9%80%81%E6%80%A7%E8%83%BD%E7%9A%84%E4%BC%98%E5%8C%96/</link><pubDate>Thu, 23 Jun 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/06/23/%E6%B5%85%E6%9E%90-dubbo-3.0-%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%BA%A7%E5%9C%B0%E5%9D%80%E6%8E%A8%E9%80%81%E6%80%A7%E8%83%BD%E7%9A%84%E4%BC%98%E5%8C%96/</guid><description>URL 简介 在阐述地址推送性能的具体优化之前，我们有必要先了解一下与之息息相关的内容 &amp;mdash; URL。
定义 在不谈及 dubbo 时，我们大多数人对 URL 这个概念并不会感到陌生。统一资源定位器 (RFC1738――Uniform Resource Locators (URL))应该是最广为人知的一个 RFC 规范，它的定义也非常简单。
因特网上的可用资源可以用简单字符串来表示，该文档就是描述了这种字符串的语法和语 义。而这些字符串则被称为：“统一资源定位器”（URL）
一个标准的 URL 格式至多可以包含如下的几个部分
protocol://username:password@host:port/path?key=value&amp;amp;key=value 一些典型 URL
http://www.facebook.com/friends?param1=value1&amp;amp;amp;param2=value2 https://username:password@10.20.130.230:8080/list?version=1.0.0 ftp://username:password@192.168.1.7:21/1/read.txt 当然，也有一些不太符合常规的 URL，也被归类到了 URL 之中
192.168.1.3:20880 url protocol = null, url host = 192.168.1.3, port = 20880, url path = null file:///home/user1/router.js?type=script url protocol = file, url host = null, url path = home/user1/router.js file://home/user1/router.js?type=script&amp;lt;br&amp;gt; url protocol = file, url host = home, url path = user1/router.</description></item><item><title>如何通过 Apache ShenYu 网关代理 Dubbo 服务</title><link>https://dubbo.apache.org/zh-cn/blog/2022/05/04/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-apache-shenyu-%E7%BD%91%E5%85%B3%E4%BB%A3%E7%90%86-dubbo-%E6%9C%8D%E5%8A%A1/</link><pubDate>Wed, 04 May 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/05/04/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-apache-shenyu-%E7%BD%91%E5%85%B3%E4%BB%A3%E7%90%86-dubbo-%E6%9C%8D%E5%8A%A1/</guid><description>1. 介绍 Apache ShenYu Apache ShenYu(Incubating) 是一个异步的，高性能的，跨语言的，响应式的 API 网关。兼容各种主流框架体系，支持热插拔，用户可以定制化开发，满足用户各种场景的现状和未来需求，经历过大规模场景的锤炼。
2021年5月，ShenYu捐献给 Apache 软件基金会，Apache 基金会全票通过，顺利进入孵化器。
Apache Dubbo Apache Dubbo 是一款微服务开发框架，它提供了 RPC 通信 与 微服务治理 两大关键能力。这意味着，使用 Dubbo 开发的微服务，将具备相互之间的远程发现与通信能力， 同时利用 Dubbo 提供的丰富服务治理能力，可以实现诸如服务发现、负载均衡、流量调度等服务治理诉求。同时 Dubbo 是高度可扩展的，用户几乎可以在任意功能点去定制自己的实现，以改变框架的默认行为来满足自己的业务需求。
2. Dubbo快速开始 本小节介绍如何将Dubbo服务接入到ShenYu网关，您可以直接在工程下找到本小节的示例代码 。
2.1 启动shenyu-admin shenyu-admin是Apache ShenYu后台管理系统， 启动的方式有多种，本文通过 [本地部署](https://shenyu.apache.org/zh/docs/deployment/deployment-local) 的方式启动。启动成功后，需要在基础配置-&amp;gt;插件管理中，把dubbo 插件设置为开启，并设置你的注册地址，请确保注册中心已经开启。
2.2 启动shenyu网关 在这里通过 源码 的方式启动，直接运行shenyu-bootstrap中的ShenyuBootstrapApplication。
在启动前，请确保网关已经引入相关依赖。如果客户端是apache dubbo，注册中心使用zookeeper，请参考如下配置：
&amp;lt;!-- apache shenyu apache dubbo plugin start--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shenyu&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shenyu-spring-boot-starter-plugin-apache-dubbo&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${project.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.7.5&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- Dubbo zookeeper registry dependency start --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description></item><item><title>谈谈Pixiu的Filter</title><link>https://dubbo.apache.org/zh-cn/blog/2022/02/19/%E8%B0%88%E8%B0%88pixiu%E7%9A%84filter/</link><pubDate>Sat, 19 Feb 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/02/19/%E8%B0%88%E8%B0%88pixiu%E7%9A%84filter/</guid><description>Filter的生命周期 Pixiu作为一个面向云原生的gateway，通过简单的配置即可代理Http to Dubbo 2、Tripe甚至是Spring Cloud的请求。那Filter是怎样运行的呢？
首先Filter Plugin向Filter Manager注册自己**，然后Filter Manager根据配置创建好Filter Factory并持有它们，等待请求来临时，Manager创建一个一次性的用于此次请求的Filter Chain，然后利用Factory创建好Decode/Encode Filter并把它们加入链中，然后按照顺序去运行Decode Filter，然后去请求Upstream**，拿到Response再反向运行Encode Filter，让Filter可以访问到Response。
几个关键的概念：
Filter Manager
Filter的Manger。。。
// FilterManager manage filters type FilterManager struct { filters map[string]HttpFilterFactory filtersArray []*HttpFilterFactory } Filter Plugin：定义了Filter的（唯一的）名字和描述如何去创建一个Filter Factory。
其实结合Filter Factory的定义，可以认为Plugin是Filter Factory的Factory
// HttpFilterPlugin describe plugin HttpFilterPlugin interface { // Kind returns the unique kind name to represent itself. Kind() string // CreateFilterFactory return the filter factory CreateFilterFactory() (HttpFilterFactory, error) } Filter Factory：定义了Filter自身的配置，并且在请求来临时创建真实的Filter并把它添加到FilterChain中
Config() 的目的是能让Filter Manager能够有机会把配置交给Factory（此时golang泛型还没有落地） Apply() 在配置被注入到Factory后，有机会对config做一些检查和提前做一些初始化的工作 PrepareFilterChain() 创建Filter并加入Filter Chain // HttpFilterFactory describe http filter HttpFilterFactory interface { // Config Expose the config so that Filter Manger can inject it, so it must be a pointer Config() interface{} // Apply After the config is injected, check it or make it to default Apply() error // PrepareFilterChain create filter and append it to FilterChain // // Be Careful !</description></item><item><title>Dubbo 跨语言调用神兽：dubbo-go-pixiu</title><link>https://dubbo.apache.org/zh-cn/blog/2021/08/25/dubbo-%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8%E7%A5%9E%E5%85%BDdubbo-go-pixiu/</link><pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/08/25/dubbo-%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8%E7%A5%9E%E5%85%BDdubbo-go-pixiu/</guid><description>Pixiu 是什么 在回答 Pixiu 是什么之前，我们简单解释一下 Dubbo 是什么。Dubbo 是一个开源的高性能 RPC 框架，有着丰富的服务治理能力以及优秀的扩展能力。Dubbo 更扩展出 Dubbo-go【1】，为用户提供了 Golang 的 Dubbo 解决方案，打通了两种语言之间的隔阂，使 Dubbo 更加贴近云原生。
Dubbo-go 作为 Golang 服务，实现与 Dubbo 服务之间的相互调用。然而，在日常使用场景中，用户往往有把 Dubbo 服务以 RESTful 风格向外暴露的需求同时也要兼顾内部 Dubbo 调用。为了解决这种场景，作为 Dubbo API 网关的 Pixiu【2】 (中文: 貔貅， 曾用名 dubbo-go-proxy) 便应运而生。之所以采用 Pixiu 这个名称，是因为 Java 同类产品 Zuul 的意象是一个西方怪兽，Pixiu 作为一个国产产品，就用了我们中国的一个类似的神兽貔貅作为项目名称。也同时表达了 Dubbo 社区希望扩展出一整套云原生生态链的决心。
目前 Dubbo 多语言生态，发展最好的自然是 Java，其次是 Golang，其他语言都差强人意。dubbo-go-pixiu 项目是一个基于 dubbo-go 发展起来的项目，目前接口协议层支持的是七层的 HTTP 请求调用，计划在未来的 0.5 版本中支持 gRPC 请求调用，其另外一个使命是作为一种新的 dubbo 多语言解决方案。
为什么使用 Pixiu Pixiu 是基于 Dubbogo 的云原生、高性能、可扩展的微服务 API 网关。作为一款网关产品，Pixiu 帮助用户轻松创建、发布、维护、监控和保护任意规模的 API ，接受和处理成千上万个并发 API 调用，包括流量管理、 CORS 支持、授权和访问控制、限制、监控，以及 API 版本管理。除此以外，作为 Dubbo 的衍生产品，Pixiu 可以帮助 Dubbo 用户进行协议转换，实现跨系统、跨协议的服务能力互通。</description></item><item><title>Dubbo Java 3.0.2.1 发版公告</title><link>https://dubbo.apache.org/zh-cn/blog/2021/08/23/dubbo-java-3.0.2.1-%E5%8F%91%E7%89%88%E5%85%AC%E5%91%8A/</link><pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/08/23/dubbo-java-3.0.2.1-%E5%8F%91%E7%89%88%E5%85%AC%E5%91%8A/</guid><description>这是 3.0.2 的错误修正版本。 除了以下更改外，与版本 3.0.2 完全相同。
Bug 修复 修复 nacos group 在消费者端不生效的问题 (#8533) 修复请求超时时序列化检查的 NPE (#8547) 兼容使用 dubbo-all 时未导入 farbic-io 包的问题 (#8546)</description></item><item><title>Dubbo Java 3.0.1 发版公告</title><link>https://dubbo.apache.org/zh-cn/blog/2021/07/02/dubbo-java-3.0.1-%E5%8F%91%E7%89%88%E5%85%AC%E5%91%8A/</link><pubDate>Fri, 02 Jul 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/07/02/dubbo-java-3.0.1-%E5%8F%91%E7%89%88%E5%85%AC%E5%91%8A/</guid><description>优化 重构服务自省映射关系，支持地址迁移时直接配置上游应用名 为 Spring 扫描添加缓存 优化配置覆盖逻辑 支持 Servlet 环境下控制 Dubbo 生命周期 添加 ServiceListener 用于监听 ServiceConfig 优化方法回调参数设置 Bug 修复 启用强制校验 更正多注册中心情况下，一个注册中心启动时无地址就销毁的逻辑 移除冗余的日志输出 忽略无效的 MetadataReportConfig 修复消费端启动时 NPE 的情况 修复若干和低版本兼容问题 修复若干应用级服务发现逻辑存在的问题 优化地址迁移规则，支持应用级地址重订阅 修复 MetadataInfo 存在 NPE 的情况 修复应用级注册到注册中心的实例信息被错误覆盖的问题 代码质量提升 感谢以下提高 Apache Dubbo 的稳定性的贡献。
#8043, #8044, #8048, #8071, #8119, #8132</description></item><item><title>Dubbo3 应用级服务发现</title><link>https://dubbo.apache.org/zh-cn/blog/2021/06/02/dubbo3-%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</link><pubDate>Wed, 02 Jun 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/06/02/dubbo3-%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</guid><description>1 服务发现（Service Discovery） 概述 从 Internet 刚开始兴起，如何动态感知后端服务的地址变化就是一个必须要面对的问题，为此人们定义了 DNS 协议，基于此协议，调用方只需要记住由固定字符串组成的域名，就能轻松完成对后端服务的访问，而不用担心流量最终会访问到哪些机器 IP，因为有代理组件会基于 DNS 地址解析后的地址列表，将流量透明的、均匀的分发到不同的后端机器上。
在使用微服务构建复杂的分布式系统时，如何感知 backend 服务实例的动态上下线，也是微服务框架最需要关心并解决的问题之一。业界将这个问题称之为 - 微服务的地址发现（Service Discovery），业界比较有代表性的微服务框架如 SpringCloud、Dubbo 等都抽象了强大的动态地址发现能力，并且为了满足微服务业务场景的需求，绝大多数框架的地址发现都是基于自己设计的一套机制来实现，因此在能力、灵活性上都要比传统 DNS 丰富得多。如 SpringCloud 中常用的 Eureka， Dubbo 中常用的 Zookeeper、Nacos 等，这些注册中心实现不止能够传递地址（IP + Port），还包括一些微服务的 Metadata 信息，如实例序列化类型、实例方法列表、各个方法级的定制化配置等。
下图是微服务中 Service Discovery 的基本工作原理图，微服务体系中的实例大概可分为三种角色：服务提供者（Provider）、服务消费者（Consumer）和注册中心（Registry）。而不同框架实现间最主要的区别就体现在注册中心数据的组织：地址如何组织、以什么粒度组织、除地址外还同步哪些数据？
我们今天这篇文章就是围绕这三个角色展开，重点看下 Dubbo 中对于服务发现方案的设计，包括之前老的服务发现方案的优势和缺点，以及 Dubbo 3.0 中正在设计、开发中的全新的面向应用粒度的地址发现方案，我们期待这个新的方案能做到：
支持几十万/上百万级集群实例的地址发现 与不同的微服务体系（如 Spring Cloud）实现在地址发现层面的互通 2 Dubbo 地址发现机制解析 我们先以一个 DEMO 应用为例，来快速的看一下 Dubbo “接口粒度”服务发现与“应用粒度”服务发现体现出来的区别。这里我们重点关注 Provider 实例是如何向注册中心注册的，并且，为了体现注册中心数据量变化，我们观察的是两个 Provider 实例的场景。
应用 DEMO 提供的服务列表如下：
&amp;lt;dubbo:service interface=&amp;#34;org.apache.dubbo.samples.basic.api.DemoService&amp;#34; ref=&amp;#34;demoService&amp;#34;/&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;org.apache.dubbo.samples.basic.api.GreetingService&amp;#34; ref=&amp;#34;greetingService&amp;#34;/&amp;gt; 我们示例注册中心实现采用的是 Zookeeper ，启动 192.</description></item><item><title>dubbo-go 白话文</title><link>https://dubbo.apache.org/zh-cn/blog/2021/02/20/dubbo-go-%E7%99%BD%E8%AF%9D%E6%96%87/</link><pubDate>Sat, 20 Feb 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/02/20/dubbo-go-%E7%99%BD%E8%AF%9D%E6%96%87/</guid><description>一、前言 本文基于 dubbogo 1.5.4 版本
最近开始参与 dubbogo 的一些开发测试，之前都是直接拿 samples 的例子验证功能，而这次为了复现一个功能问题，打算从零开始搭建一个 dubbo-go 和 dubbo 调用的工程，踩到了一些新人使用 dubbogo 的坑，把这个过程记录下供大家参考。
通过本文你可以了解到：
如何常规配置 dubbogo 消费方去调用 dubbo 和 dubbogo 服务提供方 通过一个实际的 BUG 介绍解决问题的思路 二、解决问题 2.1 准备 dubbo 服务提供者 2.1.1 基本定义 定义 DemoService 接口：
public interface DemoService { String sayHello(String name); String sayHello(User user); String sayHello(User user, String name); } 定义 User 对象：
public class User implements Serializable { private String name; private int age; ...... } 2.</description></item><item><title>dubbo-go源码笔记（二）客户端调用过程</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/15/dubbo-go%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/</link><pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/15/dubbo-go%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/</guid><description>随着微服务架构的流行，许多高性能 rpc 框架应运而生，由阿里开源的 dubbo 框架 go 语言版本的 dubbo-go 也成为了众多开发者不错的选择。本文将介绍 dubbo-go 框架的基本使用方法，以及从 export 调用链的角度进行 server 端源码导读，希望能引导读者进一步认识这款框架。
前言 有了上一篇文章《dubbo-go 源码笔记（一）Server服务暴露过程详解》 的铺垫，可以大致上类比客户端服务类似于服务端启动过程。其中最大的区别是服务端通过zk注册服务，发布自己的ivkURL并订阅事件开启监听；而服务端应该是通过zk注册组件，拿到需要调用的serviceURL，更新invoker并重写用户的RPCService，从而实现对远程过程调用细节的封装。
1. 配置文件和客户端源码 1.1 client配置文件 helloworld提供的demo：profiles/client.yaml
registries : &amp;#34;demoZk&amp;#34;: protocol: &amp;#34;zookeeper&amp;#34; timeout : &amp;#34;3s&amp;#34; address: &amp;#34;127.0.0.1:2181&amp;#34; username: &amp;#34;&amp;#34; password: &amp;#34;&amp;#34; references: &amp;#34;UserProvider&amp;#34;: # 可以指定多个registry，使用逗号隔开;不指定默认向所有注册中心注册 registry: &amp;#34;demoZk&amp;#34; protocol : &amp;#34;dubbo&amp;#34; interface : &amp;#34;com.ikurento.user.UserProvider&amp;#34; cluster: &amp;#34;failover&amp;#34; methods : - name: &amp;#34;GetUser&amp;#34; retries: 3 可看到配置文件与之前讨论过的server端非常类似，其refrences部分字段就是对当前服务要主调的服务的配置，其中详细说明了调用协议、注册协议、接口id、调用方法、集群策略等，这些配置都会在之后与注册组件交互，重写ivk、调用的过程中使用到。
1.2 客户端使用框架源码 user.go
func init() { config.SetConsumerService(userProvider) hessian.RegisterPOJO(&amp;amp;User{}) } main.go</description></item><item><title>dubbogo 3.0：牵手 gRPC 走向云原生时代</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/15/dubbogo-3.0%E7%89%B5%E6%89%8B-grpc-%E8%B5%B0%E5%90%91%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3/</link><pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/15/dubbogo-3.0%E7%89%B5%E6%89%8B-grpc-%E8%B5%B0%E5%90%91%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3/</guid><description>自从 2011 年 Dubbo 开源之后，被大量中小公司采用，一直是国内最受欢迎的 RPC 框架。2014 年，由于阿里内部组织架构调整，Dubbo 暂停维护了一段时间，之后随着 Spring Cloud 的面世，两个体系在融合中一起助推了微服务的火热。
不过这世界变化快，自从以 docker 为代表的的容器技术和以 K8s 为代表的容器编排技术登上舞台之后，云原生时代到来了。在云原生时代，不可变的基础设施给原有的中间件带来了不可变的中间件基础设施：gRPC 统一了底层通信层；protobuf 统一了序列化协议；以 envoy + istio 为代表的 service mesh 逐渐统一了服务的控制面与数据面。
dubbogo 的天然使命是：Bridging the gap between Java and Go。保持 Go 应用与 Java 应用互联互通的同时，借助 Go 语言（事实上的第一云原生语言）的优势拥抱云原生时代。dubbogo 社区 2020 年勠力打造三支箭：
已经发布的对齐 dubbo 2.7 的 dubbogo v1.5 版本； 近期将要发布的 sidecar 形态的 dubbo-go-proxy 项目； 以及处于进行时的 dubbogo 3.0。 用一句话概括 dubbogo 3.0 即是：新通信协议、新序列化协议、新应用注册模型以及新的服务治理能力！本文主要着重讨论 dubbogo 3.0 的新通信协议和应用级服务注册发现模型。
dubbogo 3.0 vs gRPC 知己知彼，方能进步。dubbogo 3.</description></item><item><title>分布式事务框架 seata-golang 通信模型详解</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6-seata-golang-%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</link><pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6-seata-golang-%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</guid><description>简介 Java 的世界里，大家广泛使用一个高性能网络通信框架 —— netty，很多 RPC 框架都是基于 netty 来实现的。在 golang 的世界里，getty 也是一个类似 netty 的高性能网络通信库。getty 最初由 dubbo-go 项目负责人于雨开发，作为底层通信库在 dubbo-go 中使用。随着 dubbo-go 捐献给 apache 基金会，在社区小伙伴的共同努力下，getty 也最终进入到 apache 这个大家庭，并改名 dubbo-getty。
18 年的时候，我在公司里实践微服务，当时遇到最大的问题就是分布式事务问题。同年，阿里在社区开源他们的分布式事务解决方案，我也很快关注到这个项目，起初还叫 fescar，后来更名 seata。由于我对开源技术很感兴趣，加了很多社区群，当时也很关注 dubbo-go 这个项目，在里面默默潜水。随着对 seata 的了解，逐渐萌生了做一个 go 版本的分布式事务框架的想法。
要做一个 golang 版的分布式事务框架，首先需要解决的一个问题就是如何实现 RPC 通信。dubbo-go 就是摆在眼前很好的一个例子，遂开始研究 dubbo-go 的底层 getty。
如何基于 getty 实现 RPC 通信 getty 框架的整体模型图如下：
下面结合相关代码，详述 seata-golang 的 RPC 通信过程。
1. 建立连接 实现 RPC 通信，首先要建立网络连接，这里先从 client.go 开始看起。
func (c *client) connect() { var ( err error ss Session ) for { // 建立一个 session 连接 ss = c.</description></item><item><title>Dubbo Go 1.5.0</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/14/dubbo-go-1.5.0/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/14/dubbo-go-1.5.0/</guid><description>引语 计算机技术浪潮每 10 年都有一次技术颠覆，相关知识体系最迟每 5 年都会革新一次，大概每两年贬值一半，在应用服务通信框架领域亦然。凡是有长期生命的通信框架，大概有 5 年的成长期和 5 年的稳定成熟期。每个时代都有其匹配的应用通信框架，在 20 年前的 2G 时代，强跨语言跨平台而弱性能的 gRPC 是不会被采用的。
每个通信框架，不同的人从不同角度看出不同的结论：初学者看重易用易学，性能测评者注重性能，应用架构师考虑其维护成本，老板则考虑则综合成本。一个应用通信框架的性能固然重要，其稳定性和进化能力更重要，得到有效维护的框架可在长时间单位内降低其综合成本：学习成本、维护成本、升级成本和更换成本。
什么是 Dubbo-go？第一，它是 Dubbo 的 Go 语言版本，全面兼容 Dubbo 是其第一要义。第二，它是一个 Go 语言应用通信框架，会充分利用作为云原生时代第一语言&amp;mdash;Go 语言的优势，扩展 dubbo 的能力。
2008 年诞生的 Dubbo 已有十多年历史，依靠阿里和其社区，历久弥新。2016 年发布的 Dubbo-go 也已进入第五个年头，如今全面兼容 Dubbo v2.7.x 的 Dubbo-go v1.5 终于发布了。
回首过往，Dubbo-go 已经具备如下能力：
互联互通：打通了 gRPC 和 Spring Cloud 生态； 可观测性：基于 OpenTracing 和 Prometheus，使得其在 Logging、Tracing 和 Metrics 方面有了长足进步； 云原生：Dubbo-go 实现了基于 Kubernetes API Server 为注册中心的通信能力，做到了升级成本最低。 毋庸讳言，相较于现有成绩，发展阶段的 Dubbo-go 对未来有更多的期待之处：
易用性：Dubbo-go 的入门成本并不低，把很多感兴趣者挡在了门外。但好消息是，随着 Dubbo-go 在阿里内部的逐步推开，阿里中间件团队对其进行了进一步的封装，经生产环境检验后会开放给社区使用。 云原生：目前的 Dubbo-go 的基于 kubernetes 的方案，从技术分层角度来看， Kubernetes API Server 终究是系统的运维态组件，不应该暴露给应用层，否则会造成 APIServer 自身通信压力过大，且系统整体风险很高：应用层使用不当，或者框架自身的流量方面的 bug，可能会把 APIServer 打垮，后果就是造成整体后端服务能力的瘫痪！所以应用层需要感知的是 kubernetes 提供给应用层的 Operator，不断进化的 Dubbo-go 计划在 v1.</description></item><item><title>dubbo-go 可信调用实现</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/14/dubbo-go-%E5%8F%AF%E4%BF%A1%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/14/dubbo-go-%E5%8F%AF%E4%BF%A1%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0/</guid><description>Apache Dubbo/Dubbo-Go 作为阿里巴巴开源的一款服务治理框架，因其适应 Java/Go 开发者面向接口的编程习惯、完全透明的调用方式、优越的性能以及强大的扩展性等优点，在国内使用非常广泛。除此之外，Dubbo 开源版本原生集成了很多开箱即用的服务治理功能，包括链路追踪，路由、负载均衡、服务注册发现、监控、认证等。
本文将讲解如何在 Dubbo/Dubbo-Go 中实现灵活，安全和高效的身份验证和授权方案。
可信的目的 为什么需要鉴权认证？实际生产中类似支付之类的安全性敏感的业务会有限制匿名系统调用的需求，其他业务在接入该类敏感业务之前，需要通过审批方可正常调用，这就需要对这类敏感服务进行权限管控。尽管 Dubbo 开源版本中支持 Token 方式的鉴权实现，但是该实现方式总体来说安全性并不高，并且无法满足我们需要动态下发以及变更的灵活性需求。
针对于此，我们内部着重从巩固安全性和拓展灵活性层面重新设计了一套 Dubbo/Dubbo-Go 的服务间调用的鉴权认证功能。本文我们将主要从实现层面讲解其大致实现思路。
可信方案 抽象来看鉴权认证主要围绕以下两个问题，
身份认证：指验证应用的身份，每个应用在其生命周期内只有唯一身份，无法变更和伪造。 权限鉴定：根据身份信息鉴定权限是否满足调用。权限粒度可以进行控制。 我们通过 Access Key ID/Secret Access Key (后文简称为 AK/SK) 信息标识应用和应用之间的身份关系。例如上游 应用A 依赖下游 服务B 和 C，则 A 对 B 和 C 分别有一套 AK/SK。其相互独立没有任何关系。就算 A服务 的 AK/SK 信息泄漏，也无法通过该 AK/SK 信息调用其他的服务。
在权限鉴定方面也借鉴了公有云开放 API 常用的 AK/SK 签名机制。 在请求过程中使用 SK 签名生成 SigningKey，并通过 Dubbo 的 attachment 机制将额外的元数据信息以及 SigningKey 传输到服务端，交由服务端计算和验签，验签通过方能正常处理和响应。
签名过程主要通过如下三个方式进行加强 SigningKey 的可靠性和安全性。
验证请求者的身份
签名会通过对应应用的SK作为加密密钥对请求元数据(以及参数)进行加密，保证签名的唯一性和不可伪造性。
支持对参数进行计算签名，防止非法篡改</description></item><item><title>Dubbo-go 源码笔记（一）Server 端开启服务过程</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/14/dubbo-go-%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%E4%B8%80server-%E7%AB%AF%E5%BC%80%E5%90%AF%E6%9C%8D%E5%8A%A1%E8%BF%87%E7%A8%8B/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/14/dubbo-go-%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%E4%B8%80server-%E7%AB%AF%E5%BC%80%E5%90%AF%E6%9C%8D%E5%8A%A1%E8%BF%87%E7%A8%8B/</guid><description>随着微服务架构的流行，许多高性能 rpc 框架应运而生，由阿里开源的 dubbo 框架 go 语言版本的 dubbo-go 也成为了众多开发者不错的选择。本文将介绍 dubbo-go 框架的基本使用方法，以及从 export 调用链的角度进行 server 端源码导读，希望能引导读者进一步认识这款框架。
当拿到一款框架之后，一种不错的源码阅读方式大致如下：从运行最基础的 helloworld demo 源码开始 —&amp;gt; 再查看配置文件 —&amp;gt; 开启各种依赖服务（比如zk、consul） —&amp;gt; 开启服务端 —&amp;gt; 再到通过 client 调用服务端 —&amp;gt; 打印完整请求日志和回包。调用成功之后，再根据框架的设计模型，从配置文件解析开始，自顶向下递阅读整个框架的调用栈。
对于 C/S 模式的 rpc 请求来说，整个调用栈被拆成了 client 和 server 两部分，所以可以分别从 server 端的配置文件解析阅读到 server 端的监听启动，从 client 端的配置文件解析阅读到一次 invoker Call 调用。这样一次完整请求就明晰了起来。
运行官网提供的 helloworld-demo 官方 demo 相关链接：https://github.com/dubbogo/dubbo-samples/tree/master/golang/helloworld/dubbo
1. dubbo-go 2.7 版本 QuickStart 1）开启一个 go-server 服务 将仓库 clone 到本地 $ git clone https://github.com/dubbogo/dubbo-samples.git 进入 dubbo 目录 $ cd dubbo-samples/golang/helloworld/dubbo 进入目录后可看到四个文件夹，分别支持 go 和 java 的 client 以及 server，我们尝试运行一个 go 的 server。进入 app 子文件夹内，可以看到里面保存了 go 文件。</description></item><item><title>dubbo-go 中 REST 协议实现</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/14/dubbo-go-%E4%B8%AD-rest-%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/14/dubbo-go-%E4%B8%AD-rest-%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0/</guid><description>什么是 REST 协议 REST 是 REpresentational State Transfer（表述性状态转移）的简写，是一种软件架构风格。虽然 REST 架构风格不是一定要基于 HTTP 协议进行传输，但是因为 HTTP 协议的通用性和易用性，现在越来越多的 web 服务采用基于 HTTP 协议实现 RESTful 架构。
在 dubbo-go 中的 REST 协议指的是一种基于 HTTP 协议的远程调用方式。简单的来讲，REST 协议就是把dubbo 服务发布成 RESTful 风格的 HTTP 接口并且能够能像调用 dubbo 接口一样的方式调用 HTTP 接口。
为什么要支持 REST 协议 在没有 REST 协议之前，小伙伴们是否一直在苦恼这样几个问题：
传统的 web 服务不能直接调用我们发布的 dubbo 服务 前端不能直接调用 dubbo 服务 dubbo 服务不能发布 Open API 上述问题，就是 REST 协议解决的核心问题。现在我们很多应用场景都是需要与异构的系统进行交互，而 REST 采用的 HTTP 通信协议非常适合用来打通异构系统，如图：
REST 协议没那么简单 REST 协议核心要解决一个问题：Go 方法到 HTTP 接口的双向映射。普通 HTTP 调用 dubbo-go 服务，考虑的是HTTP 到 Go 方法的映射；而 dubbo-go 服务调用 HTTP 服务，则是 ** Go** 方法到 HTTP 接口的映射。</description></item><item><title>dubbo-go 中将 Kubernets 原⽣作为注册中⼼的设计和实现</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/14/dubbo-go-%E4%B8%AD%E5%B0%86-kubernets-%E5%8E%9F%E4%BD%9C%E4%B8%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/14/dubbo-go-%E4%B8%AD%E5%B0%86-kubernets-%E5%8E%9F%E4%BD%9C%E4%B8%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0/</guid><description>今天这篇⽂章将会介绍 dubbo-go 将 Kubernetes 作为注册中⼼的服务注册的初衷、设计⽅案，以及具体实现。
到⽬前为⽌该⽅案的实现已经被合并到 dubbo-go 的 master 分⽀。具体实现为关于 Kubernetes 的 PullRequest 。
Kubernetes管理资源的哲学 Kubernetes 作为容器集群化管理⽅案管理资源的维度可主观的分为服务进程管理和服务接⼊管理。
服务实例管理，主要体现⽅式为 Pod 设计模式加控制器模式，控制器保证具有特定标签 （ Kubernetes-Label ）的 Pod 保持在恒定的数量（多删，少补）。 服务管理，主要为 Kubernetes-Service ，该 Service 默认为具有特定标签（ Kubernetes-Label ）的 Pod 统⼀提供⼀个 VIP（ Kubernetes-ClusterIP ）所有需要请求该组 Pod 的请求都默认会按照 round-robin 的负载策略转发到真正提供服务的 Pod 。并且 CoreDNS 为该 Kubernetes-Service 提供集群内唯⼀的域名。 Kubernetes的服务发现模型 为了明确 K8s 在服务接入管理提供的解决方案，我们以 kube-apiserver 提供的 API(HTTPS) 服务为例。K8s 集群为该服务分配了一个集群内有效的 ClusterIP ，并通过 CoreDNS 为其分配了唯一的域名 kubernetes 。如果集群内的 Pod 需要访问该服务时直接通过 https://kubernetes:443 即可完成。
具体流程如上图所示 ( 红⾊为客户端，绿⾊为 kube-apiserver )：</description></item><item><title>Dubbo Go Hessian2 v1.6.0</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/14/dubbo-go-hessian2-v1.6.0/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/14/dubbo-go-hessian2-v1.6.0/</guid><description>1. 增加缓存优化 dubbo-go-hessian2 在解析数据的数据大量使用到了 struct 的结构信息，这部分信息可以缓存起来反复利用，使得性能提升了一倍。优化过程记录可以详细阅读《记一次对 dubbo-go-hessian2 的性能优化》.
对应 pr #179，作者 micln。
2. string 解析性能优化 由于 hessian （ dubbo 序列化协议，下称：hessian ）对 string 的定义是16 bit 的 unicode 的 UTF-8 表示形式，字符长度表示是16 bit 的字符数。这是仅针对 java 制定的规范，java 中一个字符是16 bit，对应到 UTF-16. hessian 库也是对每一个字符进行转码序列化。但 golang 里面字符是和 UTF-8 对应的，dubbo-go-hessian2 里面的 rune 是 32bit，和 unicode一一映射。对于 U+10000 ~ U+10FFFF 的字符，需按照 UTF16 的规范，将字符转换为 2 个字节的代理字符，再做转换，才能和 java 的序列化方式对应起来。
原来不管是编码还是解析都是一个字符一个字符处理，特别是解析的时候，从流里面一个字节一个字节读取并组装成 rune，然后再转换为 string，这样效率特别低。我们的优化方案是，批次读取字节流到 buffer 中，对 buffer 进行解析转为 UTF-8 数组，并统计字符数量。其中需要对代理对字符将其转换为标准 UTF-8 子节数组。如果统计的字符数量不足，再进一步读取流种的数据进行解析。通过此方式提升一倍的解析效率。
对应 pr #188，作者 zonghaishang。</description></item><item><title>Dubbo-go应用维度注册模型</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/14/dubbo-go%E5%BA%94%E7%94%A8%E7%BB%B4%E5%BA%A6%E6%B3%A8%E5%86%8C%E6%A8%A1%E5%9E%8B/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/14/dubbo-go%E5%BA%94%E7%94%A8%E7%BB%B4%E5%BA%A6%E6%B3%A8%E5%86%8C%E6%A8%A1%E5%9E%8B/</guid><description>Dubbo 3.0 将至。其最重要的一点就是服务自省，其基础即是应用维度的注册模型，作为目前与 Dubbo 在功能上完全对齐的 Dubbo-go，已于 本年【2020 年】7 月份发布了其 v1.5.0 版本，实现了该模型，为年底实现与 Dubbo 3.0 对齐的新版本奠定了基础。
Dubbo-go 作为 Dubbo 的 Go 语言版本，因跨语言之故，二者针对同一模型的实现必然有较大差异，故本文注重讨论 Dubbo-go 社区自身对该模型的理解和实现，以及其与 Dubbo 之间的差异。
1 引语 在 v1.5 以前，Dubbo-go 注册模型都是以服务为维度的，直观的理解可认为其是接口维度。譬如注册信息，按照服务维度模型其示例如下：
&amp;#34;com.xxx.User&amp;#34;:[ {&amp;#34;name&amp;#34;:&amp;#34;instance1&amp;#34;, &amp;#34;ip&amp;#34;:&amp;#34;127.0.0.1&amp;#34;, &amp;#34;metadata&amp;#34;:{&amp;#34;timeout&amp;#34;:1000}}, {&amp;#34;name&amp;#34;:&amp;#34;instance2&amp;#34;, &amp;#34;ip&amp;#34;:&amp;#34;127.0.0.2&amp;#34;, &amp;#34;metadata&amp;#34;:{&amp;#34;timeout&amp;#34;:2000}}, {&amp;#34;name&amp;#34;:&amp;#34;instance3&amp;#34;, &amp;#34;ip&amp;#34;:&amp;#34;127.0.0.3&amp;#34;, &amp;#34;metadata&amp;#34;:{&amp;#34;timeout&amp;#34;:3000}}, ] 这种模式的好处是不言而喻的，简单直观，提供了细粒度的服务控制手段。
而近两年，随着云时代的到来，这种模式就暴露了不足：
主流的注册模型都是应用维度的； 以服务维度来注册，那么规模与服务数量成正比，大规模集群之下【工行软件中心的接口注册规模达到万级】，注册中心压力非常大； 2 Dubbo-go v1.5.0 的新注册模型 这次 Dubbo-go 支持了新的注册模型，也就是应用维度的注册模型。简单而言，在应用维度注册下，其注册信息类似：
&amp;#34;application1&amp;#34;: [ {&amp;#34;name&amp;#34;:&amp;#34;instance1&amp;#34;, &amp;#34;ip&amp;#34;:&amp;#34;127.0.0.1&amp;#34;, &amp;#34;metadata&amp;#34;:{}}, {&amp;#34;name&amp;#34;:&amp;#34;instance2&amp;#34;, &amp;#34;ip&amp;#34;:&amp;#34;127.0.0.2&amp;#34;, &amp;#34;metadata&amp;#34;:{}}, {&amp;#34;name&amp;#34;:&amp;#34;instanceN&amp;#34;, &amp;#34;ip&amp;#34;:&amp;#34;127.0.0.3&amp;#34;, &amp;#34;metadata&amp;#34;:{}} ] 在此模式之下，可以看到注册信息将会大幅度减少，集群规模只与实例数量相关。
与此同时，在实现这一个功能的时候，Dubbo-go 还希望保持两个目标：
对用户完全兼容，用户迁移无感知； 保持住原本服务粒度上精细控制的能力——即保留现有的服务维度的元数据； 因此 Dubbo-go 要着力解决以下几点：</description></item><item><title>Go 版本入 Dubbo 生态一周年</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/14/go-%E7%89%88%E6%9C%AC%E5%85%A5-dubbo-%E7%94%9F%E6%80%81%E4%B8%80%E5%91%A8%E5%B9%B4/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/14/go-%E7%89%88%E6%9C%AC%E5%85%A5-dubbo-%E7%94%9F%E6%80%81%E4%B8%80%E5%91%A8%E5%B9%B4/</guid><description>去年 5 月，阿里开源的高性能 RPC 框架 Dubbo 从 ASF 毕业并晋升顶级项目，同时，还宣布 Go 语言版本的 Dubbo-go 正式加入 Dubbo 官方生态。
经过一年的发展， Dubbo-go 在技术和社区运营方面都已经有了不错的成绩。Dubbo-go 是 Dubbo 的完整 Go 语言实现，在功能实现和技术路径上与 Dubbo 有不同程度的对标，项目团队预计很快便可以追平 Java 版的功能。当然，也是因为基于 Go 语言开发，Dubbo-go 更易上手，未来或将反哺 Dubbo 的云原生化。
Dubbo-go 近期还实现了 REST 协议以及 gRPC 的支持，打通了 Spring Cloud 和 gRPC 生态，再加上与 Java Dubbo 的互通，应用场景广泛。因此，它被其开发者叫做“all-in-one”的 RPC 框架。
目前 Dubbo 官方已经投入人力参与 Dubbo-go 的开发，阿里集团今年完成 HSF 和 Dubbo 的融合后，会在集团内逐步推广使用 Dubbo-go。
开源中国采访了当前正在开发中的 v1.5 版本的主要推进者邓明，回顾 Dubbo-go 的过往，尤其是最近一年的发展情况，并展望项目未来的发展。
Dubbo-go 过去发展回顾 OSCHINA： 作为项目主要推动者之一，可以简单回顾下 Dubbo-go 的发展历程吗？
Dubbo-go 邓明：</description></item><item><title>都已经十岁的 Apache Dubbo，还能再乘风破浪吗？</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/14/%E9%83%BD%E5%B7%B2%E7%BB%8F%E5%8D%81%E5%B2%81%E7%9A%84-apache-dubbo%E8%BF%98%E8%83%BD%E5%86%8D%E4%B9%98%E9%A3%8E%E7%A0%B4%E6%B5%AA%E5%90%97/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/14/%E9%83%BD%E5%B7%B2%E7%BB%8F%E5%8D%81%E5%B2%81%E7%9A%84-apache-dubbo%E8%BF%98%E8%83%BD%E5%86%8D%E4%B9%98%E9%A3%8E%E7%A0%B4%E6%B5%AA%E5%90%97/</guid><description>纵观中国开源历史，你真的没法找到第二个像 Dubbo 一样自带争议和讨论热度的开源项目。
一方面，2011 年，它的开源填补了当时生产环境使用的 RPC 框架的空白，一发布就被广泛采用；另一方面，它经历了停止维护、重启维护后捐献给 Apache 基金会、接着又以顶级项目的身份毕业。
面对多疑的开发者，在云原生时代，Apache Dubbo 将如何延续当前光芒？
今年是 Dubbo 从 Apache 基金会毕业的一周年，同时也是推进 Dubbo 3.0，即全面拥抱云原生的重要一年。开源中国与 Apaceh Dubbo 共同策划**【Dubbo 云原生之路】**系列文章，和大家一起回顾 Apache Dubbo 社区的发展。系列文章主要涵盖 Dubbo 技术解读、社区、应用案例解析三大部分，之后每周都会和大家见面。
在【阿里巴巴云原生公众号】留言说出与 Apache Dubbo 的故事，点赞排名前十的同学可领取 Dubbo 送出的专属奖品杯子一只；另外由Apache Dubbo PMC @Chickenlj 随机抽取一名幸运读者，赠送价值 260 元护眼灯一台。下周三开奖。
作者简介
刘军，花名陆龟，GitHub 账号 Chickenlj，Apache Dubbo PMC，项目核心开发，见证了 Dubbo 重启开源，到从 Apache 基金会毕业的整个过程。现任职阿里云云原生应用平台团队，参与服务框架、微服务相关工作，目前主要在推动 Dubbo 3.0 - Dubbo 云原生。
系列开篇：3.0 全面铺开、ASF 毕业一周年 从 2019 年到现在，在 Dubbo 毕业的这一年时间里，Dubbo 社区和产品都取得长足进步，同时 Dubbo 云原生版本 - Dubbo 3.0 的开发工作也已经全面铺开。</description></item><item><title>记一次在 mosn 对 dubbo、dubbo-go-hessian2 的性能优化</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/14/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8-mosn-%E5%AF%B9-dubbodubbo-go-hessian2-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/14/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8-mosn-%E5%AF%B9-dubbodubbo-go-hessian2-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid><description>背景 蚂蚁内部对 Service Mesh 的稳定性和性能要求是比较高的，内部 mosn 广泛用于生产环境。在云上和开源社区，RPC 领域 dubbo 和 spring cloud 同样广泛用于生产环境，我们在 mosn 基础上，支持了 dubbo 和 spring cloud 流量代理。我们发现在支持 dubbo 协议过程中，经过 Mesh 流量代理后，性能有非常大的性能损耗，在大商户落地 Mesh 中也对性能有较高要求，因此本文会重点描述在基于 Go 语言库 dubbo-go-hessian2 、dubbo 协议中对 mosn 所做的性能优化。
性能优化概述 根据实际业务部署场景，并没有选用高性能机器，使用普通 linux 机器，配置和压测参数如下：
Intel(R) Xeon(R) Platinum 8163 CPU @ 2.50GHz 4 核 16G 。 pod 配置 2c、1g，JVM 参数 -server -Xms1024m -Xmx1024m。 网络延迟 0.23 ms, 2 台 linux 机器，分别部署 server + mosn, 压测程序 rpc-perfomance。 经过 3 轮性能优化后，使用优化版本 mosn 将会获得以下性能收益（框架随机 512 和 1k 字节压测）：</description></item><item><title>解构 Dubbo-go 的核心注册引擎 Nacos</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/14/%E8%A7%A3%E6%9E%84-dubbo-go-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E5%86%8C%E5%BC%95%E6%93%8E-nacos/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/14/%E8%A7%A3%E6%9E%84-dubbo-go-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E5%86%8C%E5%BC%95%E6%93%8E-nacos/</guid><description>近几年，随着Go语言社区逐渐发展和壮大，越来越多的公司开始尝试采用Go搭建微服务体系，也涌现了一批Go的微服务框架，如go-micro、go-kit、Dubbo-go等，跟微服务治理相关的组件也逐渐开始在Go生态发力，如Sentinel、Hystrix等都推出了Go语言版本，而作为微服务框架的核心引擎&amp;ndash;注册中心，也是必不可缺少的组件，市面已经有多款注册中心支持Go语言，应该如何选择呢？我们可以对目前主流的支持Go语言的注册中心做个对比。
根据上表的对比我们可以从以下几个维度得出结论：
生态:各注册中心对Go语言都有支持，但是Nacos、 Consul、Etcd 社区活跃，zookeeper和Eureka社区活跃度较低； 易用性：Nacos、Eureka、Consul都有现成的管控平台，Etcd、zookeeper本身作为kv存储，没有相应的管控平台，Nacos支持中文界面，比较符合国人使用习惯； 场景支持：CP模型主要针对强一致场景，如金融类，AP模型适用于高可用场景，Nacos可以同时满足两种场景，Eureka主要满足高可用场景，Consul、Zookeepr、Etcd主要满足强一致场景，此外Nacos支持从其它注册中心同步数据，方便用户注册中心迁移； 功能完整性：所有注册中心都支持健康检查，Nacos、Consul支持的检查方式较多，满足不同应用场景，Zookeeper通过keep alive方式，能实时感知实例变化；Nacos、Consul和Eureka都支持负载均衡策略，Nacos通过Metadata selector支持更灵活的策略；此外，Nacos、Eureka都支持雪崩保护，避免因为过多的实例不健康对健康的实例造成雪崩效应。 综合上面各维度的对比，可以了解到Nacos作为注册中心有一定的优势，那么它对Go微服务生态的集成做得如何？接下来我们首先探索下Nacos是如何与Dubbo-go集成。
引言 Dubbo-go目前是Dubbo多语言生态中最火热的一个项目，从2016年发布至今，已经走过5个年头。最近，Dubbo-go发布了v1.5版本，全面兼容Dubbo 2.7.x版本，支持了应用维度的服务注册与发现，和主流的注册模型保持一致，标志着Dubbo-go向云原生迈出了关键的一步。作为驱动服务运转的核心引擎&amp;ndash;注册中心，在切换到应用维度的注册模型后，也需要做相应的适配，本文将解析如何以Nacos为核心引擎实现应用维度的服务注册与发现，并且给出相应的实践案例。此外，本文代码基于Dubbo-go v1.5.1，Nacos-SDK-go v1.0.0和Nacos v1.3.2。
服务注册与发现架构 从架构中，我们可以看到，与接口级别的服务注册发现不同的是，Dubbo-go的provider启动后会调用Nacos-go-sdk的RegisterInstance接口向Nacos注册服务实例，注册的服务名即为应用名称，而不是接口名称。Conusmer启动后则会调用Subscribe接口订阅该应用的服务实例变化，并对的实例发起服务调用。
服务模型 图3是我们Dubbo-go的应用维度服务发现模型，主要有服务和实例两个层级关系，服务实例的属性主要包含实例Id、主机地址、服务端口、激活状态和元数据。图4为Nacos的服务分级存储模型，包含服务、集群和实例三个层次。两者对比，多了一个集群维度的层级，而且实例属性信息能够完全匹配。所以在Dubbo-go将应用服务实例注册到Nacos时，我们只需要将集群设置为默认集群，再填充服务和实例的相关属性，即可完成服务模型上的匹配。此外Nacos可以将服务注册到不同的Namespace下，实现多租户的隔离。
! 服务实例心跳维持 Dubbo-go的Provider在向Nacos注册应用服务实例信息后，需要主动上报心跳，让Nacos服务端感知实例的存活与否，以判断是否将该节点从实例列表中移除。维护心跳的工作是在Nacos-SDK-go完成的，从图5代码中可以看到，当Dubbo-go调用RegisterInstance注册一个服务实例时，SDK除了调用Nacos的Register API之外，还会调用AddBeatInfo，将服务实例信息添加到本地缓存，通过后台协程定期向Nacos发送服务实例信息，保持心跳。当服务下线时，可以通过调用DeRegisterInstance执行反注册，并移除本地的心跳保持任务，Nacos实例列表中也会将该实例移除。
订阅服务实例变化 Dubbo-go的Consumer在启动的时候会调用Nacos-SDK-go的Subscribe接口，该接口入参如图6，订阅的时候只需要传递ServiceName即应用名和回调函数SubscribeCallback，Nacos在服务实例发生变化的时候即可通过回调函数通知Dubbo-go。Nacos-SDK-go是如何感知Nacos的服务实例变化的呢？主要有两种方式：
Nacos服务端主动推送，Nacos-SDK-go在启动的时候会监听一个UDP端口，该端口在调用Nacos Register API的时候作为参数传递，Nacos会记录Ip和端口，当服务实例发生变化时，Nacos会对所有监听该服务的Ip和端口发送UDP请求，推送变化后的服务实例信息。
Nacos-SDK-go定期查询，SDK会对订阅的服务实例定时调用查询接口，如果查询有变化则通过回调接口通知Dubbo-go。作为兜底策略保证Nacos服务端推送失败后，仍能感知到变化。
此外Nacos-SDK-go还支持推空保护，当Nacos推送的实例列表为空时，不更新本地缓存，也不通知Dubbo-go变更，避免Consumer无可用实例调用，造成故障。同时，SDK还支持服务实例信息本地持久化存储，可以保证在Nacos服务故障过程中，Consumer重启也能获取到可用实例，具备容灾效果。
范例实践 环境准备 dubbo-go samples代码下载：https://github.com/apache/dubbo-go-samples/tree/master，基于Nacos注册中心的应用级服务发现的hello world代码目录在 registry/servicediscovery/nacos。
Nacos服务端搭建，参考官方文档：https://nacos.io/zh-cn/docs/quick-start.html，或者使用官方提供的公共Nacos服务：http://console.nacos.io/nacos(账号密码:nacos，仅供测试)，或者购买阿里云服务：https://help.aliyun.com/document_detail/139460.html?spm=a2c4g.11186623.6.559.d7e264b7bLpZIs
Server端搭建 进入registry/servicediscovery/nacos/go-server/profiles文件，可以看到有dev、release和test三个文件夹，分别对应开发、测试和生产配置。我们使用dev配置来搭建开发环境，dev文件下有log.yml和server.yml文件，下面对server.yml配置进行修改。
remote配置，这里使用公共的Nacos服务，address支持配置多个地址，用逗号分割。params参数配置nacos-sdk的日志目录。
remote: nacos: address: &amp;#34;console.nacos.io:80&amp;#34; timeout: &amp;#34;5s&amp;#34; params: logDir: &amp;#34;/data/nacos-sdk/log&amp;#34; configCenter配置 config_center: protocol: &amp;#34;nacos&amp;#34; address: &amp;#34;console.nacos.io:80&amp;#34; 配置server端环境变量
export CONF_PROVIDER_FILE_PATH=server端的server.yml文件路径 export APP_LOG_CONF_FILE=server端的log.yml文件路径 进入registry/servicediscovery/nacos/go-server/app，运行server.go的main方法，可以从Nacos的控制台（http://console.nacos.io/nacos/#/serviceManagement?dataId=&amp;amp;group=&amp;amp;appName=&amp;amp;namespace=）
看到，应用user-info-server已经注册成功。
Client端搭建 client的配置文件在registry/servicediscovery/nacos/go-server/profiles目录下，需要修改的地方跟server端一样，这里不赘述。
配置client端环境变量
export CONF_CONSUMER_FILE_PATH=client端的server.yml文件路径 export APP_LOG_CONF_FILE=client端的log.</description></item><item><title>快速上手 dubbo-go</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/14/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-dubbo-go/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/14/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-dubbo-go/</guid><description>前言 每次技术调研总会发现自己学不动了怎么办？用已有的知识来拓展要学习的新知识就好了~ by LinkinStar
最近需要调研使用 dubbo，之前完全是 0 基础，对于 dubbo 只存在于听说，今天上手实战一把，告诉你如何快速用 go 上手 dubbo
PS：以下的学习方式适用于很多新技术
基本概念 首先学习一个技术首先要看看它的整体架构和基本概念，每个技术都有着自己的名词解释和实现方式，如果文档齐全就简单很多。
基本概念
大致浏览了背景、需求、架构之后基本上有一个大致概念
其实整体架构和很多微服务的架构都是类似的，就是有一个注册中心管理所有的服务列表，服务提供方先向注册中心注册，而消费方向注册中心请求服务列表，通过服务列表调用最终的服务。总的来说 dubbo 将整个过程封装在了里面，而作为使用者的我们来说更加关心业务实现，它帮我们做好了治理的工作。
然后我抓住了几个我想要知道的重点：
注册中心可替换，官方推荐的是 zk 如果有变更，注册中心将基于长连接推送变更数据给消费者，注册中心，服务提供者，服务消费者三者之间均为长连接 基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用 消费者在本地缓存了提供者列表 实际上手 官网文档中也给出如果使用 golang 开发，那么有 https://github.com/apache/dubbo-go 可以用，那么废话不多说，上手实践一把先。因为你看再多，都比不上实践一把来学的快。
环境搭建 大多数教程就会跟你说，一个 helloWorld 需要 zookeeper 环境，但是不告诉你如何搭建，因为这对于他们来说太简单了，而我不一样，我是 0 基础，那如何快速搭建一个需要调研项目的环境呢？最好的方式就是 docker。
version: &amp;#39;3&amp;#39; services: zookeeper: image: zookeeper ports: - 2181:2181 admin: image: apache/dubbo-admin depends_on: - zookeeper ports: - 8080:8080 environment: - admin.registry.address=zookeeper://zookeeper:2181 - admin.config-center=zookeeper://zookeeper:2181 - admin.metadata-report.address=zookeeper://zookeeper:2181 version: &amp;#39;3&amp;#39; services: zookeeper: image: zookeeper ports: - 2181:2181 admin: image: chenchuxin/dubbo-admin depends_on: - zookeeper ports: - 8080:8080 environment: - dubbo.</description></item><item><title>涂鸦智能 dubbo-go 亿级流量的实践与探索</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/14/%E6%B6%82%E9%B8%A6%E6%99%BA%E8%83%BD-dubbo-go-%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%8E%A2%E7%B4%A2/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/14/%E6%B6%82%E9%B8%A6%E6%99%BA%E8%83%BD-dubbo-go-%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%8E%A2%E7%B4%A2/</guid><description>dubbo 是一个基于 Java 开发的高性能的轻量级 RPC 框架，dubbo 提供了丰富的服务治理功能和优秀的扩展能力。而 dubbo-go 在 java 与 golang 之间提供统一的服务化能力与标准，是涂鸦智能目前最需要解决的主要问题。本文分为实践和快速接入两部分，分享在涂鸦智能的 dubbo-go 实战经验，意在帮助用户快速接入 dubbo-go RPC 框架，希望能让大家少走些弯路。
另外，文中的测试代码基于 dubbo-go版本 v1.4.0。
dubbo-go 网关实践 dubbo-go 在涂鸦智能的使用情况如上图，接下来会为大家详细介绍落地细节，希望这些在生产环境中总结的经验能够帮助到大家。
背景 在涂鸦智能，dubbo-go 已经作为了 golang 服务与原有 dubbo 集群打通的首选 RPC 框架。其中比较有代表性的 open-gateway 网关系统（下文统一称 gateway，开源版本见 https://github.com/dubbogo/dubbo-go-proxy）。该 gateway 动态加载内部 dubbo 接口信息，以HTTP API 的形式对外暴露。该网关意在解决上一代网关的以下痛点。
通过页面配置 dubbo 接口开放规则，步骤繁琐，权限难以把控。 接口非 RESTful 风格，对外部开发者不友好。 依赖繁重，升级风险大。 并发性能问题。 架构设计 针对如上痛点，随即着手准备设计新的 gateway 架构。首先就是语言选型，golang 的协程调用模型使得 golang 非常适合构建 IO 密集型的应用，且应用部署上也较 java 简单。经过调研后我们敲定使用 golang 作为 proxy 的编码语言，并使用 dubbo-go 用于连接 dubbo provider 集群。provider 端的业务应用通过使用 java 的插件，以注解形式配置 API 配置信息，该插件会将配置信息和 dubbo 接口元数据更新到元数据注册中心（下图中的 redis ）。这样一来，配置从管理后台页面转移到了程序代码中。开发人员在编码时，非常方便地看到 dubbo 接口对外的 API 描述，无需从另外一个管理后台配置 API 的使用方式。</description></item><item><title>Dubbo Go 1.4.0</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/12/dubbo-go-1.4.0/</link><pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/12/dubbo-go-1.4.0/</guid><description>得益于社区活跃的支持，2020 年 3 月 25 日 我们发布了一个让人兴奋的版本——dubbo-go v1.4.0。除了继续支持已有的 Dubbo 的一些特性外， dubbo-go 开始了一些自己的创新尝试。
这个版本，最大的意义在于，做了一些支持云原生的准备工作。比如说，社区在探讨了很久的 k8s 落地之后，终于拿出来了使用 k8s 作为注册中心的解决方案。
其次一个比较大的改进是&amp;ndash;我们在可观测性上也迈出了重要的一步。在这之前，dubbo-go只提供了日志这么一个单一手段，内部的信息比较不透明，这个版本将有很大的改善。
最后一个令人心动的改进是，我们支持了 REST 协议。
1. K8s 注册中心 dubbo-go 注册中心的本质为K/V型的数据存储。当前版本实现了以 Endpoint 为维度在 k8s API Server 进行服务注册和发现的方案【下文简称 Endpoint 方案】，架构图如下。
Endpoint 方案，首先将每个 dubbo-go 进程自身服务信息序列化后，通过 Kubernetes 提供的 Patch 的接口写入在自身 Pod 对象的 Annotation 中。其次，通过 Kubernetes 的 Watch 接口观察集群中本 Namespace 内带有某些固定lable [见上图] Pod 的Annotation 信息的更新，处理服务健康检查、服务上下线等情况并实时更新本地缓存。整体流程仅使用 Kubernetes 原生 API 完成将 Kubernetes 作为注册中心的功能特性。
这个方案非常简洁，不需要实现额外的第三方模块，也不需要对 Dubbo 业务作出改动，仅仅把 k8s 当做部署平台，依赖其容器管理能力，没有使用其 label selector 和 service 等服务治理特性。如果站在 k8s Operator 的角度来看，Operator 方案的优点即 Endpoint 方案的缺点，Endpoint 方案无法使用 k8s 的健康检查能力，亦没有使用 k8s service 的事件监听能力，每个 consumer 冗余监听一些不必要监听的事件，当 Endpoint 过多时会加大 API Server 的网络压力。</description></item><item><title>dubbo-go 中如何实现路由规则功能</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/12/dubbo-go-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99%E5%8A%9F%E8%83%BD/</link><pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/12/dubbo-go-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99%E5%8A%9F%E8%83%BD/</guid><description>Let‘s Go! 最近在 Apache/dubbo-go（以下简称 dubbo-go ）社区中，路由规则突然成了呼声最高的功能之一。那到底为什么需要路由规则？
先路由规则需要实现的功能：
路由规则（ routing rule ）是为了改变网络流量所经过的途径而修改路由信息的技术，主要通过改变路由属性（包括可达性）来实现。在发起一次 RPC 调用前起到过滤目标服务器地址的作用，过滤后的地址列表，将作为消费端最终发起 RPC 调用的备选地址。
试想该下场景：使用 dubbo-go 在生产环境上，排除预发布机。使用路由规则实现不是很合适吗？
虽然知道了路由规则需要实现什么功能，但还不足以实现一个完整的路由规则功能。除此之外，还需要知道如何方便的管理路由规则。
目标 综上所述，可以总结出以下 目标
支持方便扩展路由规则的配置； 可以方便的管理路由规则配置，如支持本地与远程配置中心管理； 与 Dubbo 现有的配置中心内的路由规则配置文件兼容，降低在新增语言栈的学习及使用成本； 路由规则设计 在设计之初，首先要考虑的是路由规则应该放在整个服务治理周期的哪个阶段呢？
有些读者可能会有点困惑，我连架构图都不知道，如何考虑在哪个阶段？不怕，下图马上给你解惑。
可以看到图中的 Router 就是路由规则插入的位置，目前路由规则主要用于控制 Consumer 到 Provider 之间的网络流量的路由路径。
除此之外，还有几个问题是需要优先考虑：
1.需要什么功能？
通过配置信息生成路由规则，包括：读取并解析本地配置文件，读取并解析配置中心的配置。以责任链模式串联起来。 通过路由规则，匹配本地信息与远端服务信息，过滤出可以调用的远端节点，再进行负载均衡。 2.如何设计接口？
通过第一点，我们能设计出以下接口来实现所需的功能。
路由规则接口：用于路由规则过滤出可以调用的远端节点。 路由规则责任链接口：允许执行多个路由规则。 配置信息生成路由规则接口：解析内部配置信息（common.URL）生成对应的路由规则。 配置文件生成路由规则接口：解析配置文件生成对应的路由规则。 3.如何实现本地与远程路由规则配置加载？
本地路由规则配置：在原配置加载阶段，新增读取路由配置文件。使用 FIleRouterFactory 解析后，生成对应路由规则，放置到内存中备用。 远程路由规则配置：在 zookeeper 注册并监听静态资源目录后。读取静态资源，筛选符合路由规则配置信息，通过 RouterFactory 生成对应路由规则，放置到内存中备用。 Router 匹配及过滤远程实例的路由规则。
// Router type Router interface { // Route determine the target invoker list.</description></item><item><title>记一次对 dubbo-go-hessian2 的性能优化</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9-dubbo-go-hessian2-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link><pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9-dubbo-go-hessian2-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid><description>dubbo-go-hessian2 是一个用 Go 实现的 hessian 协议 v2.0 版本的序列化库。从项目名称里可以看到主要用在 dubbo-go 这个项目里。hessian 协议作为 dubbo 的默认协议，因此对性能有比较高的要求。
立项 譬如有网文 基于Go的马蜂窝旅游网分布式IM系统技术实践 把 dubbo-go 与其他 RPC 框架对比如下：
Go STDPRC: Go 标准库的 RPC，性能最优，但是没有治理； RPCX: 性能优势 2*GRPC + 服务治理； GRPC: 跨语言，但性能没有 RPCX 好； TarsGo: 跨语言，性能 5*GRPC，缺点是框架较大，整合起来费劲； Dubbo-Go: 性能稍逊一筹，比较适合 Go 和 Java 间通信场景使用 有鉴于此，社区便开始组织部分人力，启动了对 dubbo-go 性能优化【同时也欢迎上文作者到钉钉群 23331795 与我们社区交流】。考察 dubbo-go 的各个组件，大家不约而同地决定首先优化比较独立的 dubbo-go-hessian2。
起步 在最开始的时候，并没有太想清楚需要做什么，改哪个地方，要优化到何种程度，所以最简单的办法就是看看现状。
首先，写了一个简单的例子，把常见的类型到一个结构体里，然后测一下耗时。
type Mix struct { A int B string CA time.Time CB int64 CC string CD []float64 D map[string]interface{} } m := Mix{A: int(&amp;#39;a&amp;#39;), B: `hello`} m.</description></item><item><title>Dubbo Go 踩坑记</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/11/dubbo-go-%E8%B8%A9%E5%9D%91%E8%AE%B0/</link><pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/11/dubbo-go-%E8%B8%A9%E5%9D%91%E8%AE%B0/</guid><description>扯淡 前尘 由于我的一个项目需要做公司用户鉴权，而组内其他小伙伴刚好有一个 dubbo 的鉴权 rpc ，一开始我是打算直接的读 redis 数据然后自己做解密。工作进行到一半，由于考虑到如果以后这个服务有任何变动，我这边要有联动行为，所以改用 go 来调用 dubbo 的 rpc ，于是我在 github 上找到了 雨神 的 https://github.com/apache/dubbo-go-samples/tree/master (PS: 这个是 dubbo-go 前身)。不得不说，雨神是热心的人儿啊，当时还帮着我调试代码。最后也是接入了一个阉割版的吧，主要是当时 hessian2 对泛型支持的不怎么好。
现在 目前 dubbo-go隶属于 apache 社区，相比以前做了部分重构，并且维护也很活跃了。
接入 问题 目前整个项目在快速的迭代中，很多功能还没有完善，维护人员还没有时间来完善文档，所以在接入的时候要自己看源码或调试。
说明 目前我司在使用 dubbo 的过程使用的 zookeeper 作为注册中心，序列化是 hessian2 ，所以我们要做如下初始化：
import ( _ &amp;#34;github.com/apache/dubbo-go/common/proxy/proxy_factory&amp;#34; _ &amp;#34;github.com/apache/dubbo-go/registry/protocol&amp;#34; _ &amp;#34;github.com/apache/dubbo-go/filter/impl&amp;#34; _ &amp;#34;github.com/apache/dubbo-go/cluster/cluster_impl&amp;#34; _ &amp;#34;github.com/apache/dubbo-go/cluster/loadbalance&amp;#34; _ &amp;#34;github.com/apache/dubbo-go/registry/zookeeper&amp;#34; ) 配置 由于我是接入客户端，所以我这边只配置了 ConsumerConfig 。
dubbo: # client request_timeout: &amp;#34;3s&amp;#34; # connect timeout connect_timeout: &amp;#34;3s&amp;#34; check: true application: organization: &amp;#34;dfire.</description></item><item><title>Dubbo Go 的前世今生</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/11/dubbo-go-%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</link><pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/11/dubbo-go-%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</guid><description>dubbo-go 是目前 Dubbo 多语言生态最火热的项目。dubbo-go 最早的版本应该要追溯到 2016 年，由社区于雨同学编写 dubbo-go 的初版。当时很多东西没有现成的轮子，如 Go 语言没有像 netty 一样的基于事件的网络处理引擎、 hessian2 协议没有 Go 语言版本实现，加上当时 Dubbo 也没有开始重新维护。所以从协议库到网络引擎，再到上层 dubbo-go ，其实都是从零开始写的。
在 2018 年，携程开始做 Go 语言的一些中间件以搭建内部的 Go 语言生态，需要有一个 Go 的服务框架可以与携程的现有 dubbo soa 生态互通。所以由我负责重构了 dubbo－go 并开源出这个版本。当时调研了很多开源的 Go 语言服务框架，当时能够支持 hessian2 协议的并跟 Dubbo 可以打通的仅找到了当时于雨写的 dubbo-go 早期版本。由于携程对社区版本的 Dubbo 做了挺多的扩展，源于对扩展性的需求我们 Go 语言版本需要一个更易于扩展的版本，加上当时这个版本本身的功能也比较简单，所以我们找到了作者合作重构了一个更好的版本。经过了大半年时间，在上图第三阶段 19 年 6 月的时候，基本上已经把 dubbo-go 重构了一遍，总体的思路是参考的 Dubbo 整体的代码架构，用Go语言完全重写了一个完整的具备服务端跟消费端的 Golang rpc/ 微服务框架。
后来我们将重构后的版本 dubbo-go 1.0 贡献给 Apache 基金会，到现在已经过去了两个多月的时间，近期社区发布了1.1版本。目前为止，已经有包括携程在内的公司已经在生产环境开始了试用和推广。
Start dubbo-go 现在的 dubbo-go 已经能够跟 Java 版本做比较好的融合互通，同时 dubbo-go 自身也是一个完成的 Go 语言 rpc/ 微服务框架，它也可以脱离 java dubbo 来独立使用。</description></item><item><title>冲上云原生，Dubbo 发布 Go 版本</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/11/%E5%86%B2%E4%B8%8A%E4%BA%91%E5%8E%9F%E7%94%9Fdubbo-%E5%8F%91%E5%B8%83-go-%E7%89%88%E6%9C%AC/</link><pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/11/%E5%86%B2%E4%B8%8A%E4%BA%91%E5%8E%9F%E7%94%9Fdubbo-%E5%8F%91%E5%B8%83-go-%E7%89%88%E6%9C%AC/</guid><description>5 月 21 日，经过一年多的孵化，Apache Dubbo 从 Apache 软件基金会毕业，成为 Apache 顶级项目。
Dubbo 是阿里于 2011 年开源的一款高性能 RPC 框架，在 Java 生态中具有不小的影响力。当初经历过一段被外界诟病的“停止维护”灰暗时光，后来在 2017 年 Dubbo 浪子回头，官方宣布重新重点维护。
重新启航的 Dubbo 将首要目标定位于重新激活社区，赢回开发者的信任，并且逐渐将 Dubbo 打造成一个国际化与现代化的项目，目前距离宣布重启已经过了一年半的时间。
在这个过程中，Dubbo 发布了多个版本，并逐渐从一个 RPC 框架向微服务生态系统转变，18 年年初 Dubbo 入驻 Apache 软件基金会孵化器，开始以 Apache 之道发展社区。
一年之后，Dubbo 在 Apache 孵化器中发布了重启维护以来的首个里程碑版本 2.7.0，添加了社区呼声很高的异步化支持，以及注册中心与配置中心分离等特性。
这期间 Dubbo 3.0 的开发工作也被提上了日程，今年 4 月中旬，官方正式公布了 Dubbo 3.0 的进度，此版本新特性包括支持 Filter 链的异步化、响应式编程、云原生/Service Mesh 方向的探索，以及与阿里内外融合。
然后，Dubbo 毕业了。毕业后的 Dubbo 近期有什么消息呢？生态还在发展，Dubbo 社区在前几日公开了 Dubbo Roadmap 2019，计划在 2020 年 2 月份发布 Dubbo 3.0 正式版，感兴趣的同学可以详细查阅。</description></item><item><title>Dubbo Go 回顾与展望</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/11/dubbo-go-%E5%9B%9E%E9%A1%BE%E4%B8%8E%E5%B1%95%E6%9C%9B/</link><pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/11/dubbo-go-%E5%9B%9E%E9%A1%BE%E4%B8%8E%E5%B1%95%E6%9C%9B/</guid><description>Dubbo 是阿里于 2011 年开源的一款高性能 RPC 框架，在 Java 生态中具有不小的影响力。2019年5月21日，Dubbo 从 Apache 软件基金会毕业，成为 Apache 顶级项目。目前，毕业后的 Dubbo 项目的生态中已经正式官宣引入了 Go 语言，发布了 Dubbogo 项目。本文即是对 Dubbogo 这一项目的完整回顾与真实展望。由蚂蚁金服中间件技术专家于雨和携程基础中台研发部工程师方银城合作完成。
一 Dubbogo 整体框架 先介绍一下 dubbogo 的缘起，先看下面这幅图：
最右边的 service0 和 service1 是 Dubbo 的服务端，左边的 gateway 是网关，HTTP 请求从网关进来，必须转化成 Dubbo 的协议才能到后面的服务，所以中间加了一层proxy 完成相关功能。基本上每个 service 都需要一个 proxy 去转化协议和请求，所以这个时候 dubbogo 的项目需求就出来了。最初的实现就是以 Dubbo 的 Go 版本作为目标，实现与 Java 版本 Dubbo 的互调。
Dubbogo 目标 然后这个图是 dubbogo 的现在达到的目标：用一份 Go 客户端的代码能够在没有任何代理和其他中间件的情况下直接调用其他语言端，主要是Java 服务端的服务和 Go 服务端的服务，而 Go 作为服务端的时候，Java 客户端也可以直接调用 Go 服务端的服务。
Dubbogo 发展历程 下面介绍 dubbogo 的整个发展历程，在2016年8月份的时候是于雨构建了 dubbogo 项目，那个时候的 dubbogo 只支持通过 jsonrpc 2.</description></item><item><title>Dubbo Go 快速开始</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/11/dubbo-go-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/</link><pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/11/dubbo-go-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/</guid><description>环境 Go编程环境 启动zookeeper服务，也可以使用远程实例 从服务端开始 第一步：编写 Provider 结构体和提供服务的方法 https://github.com/dubbogo/dubbo-samples/blob/master/golang/helloworld/dubbo/go-server/app/user.go
编写需要被编码的结构体，由于使用 Hessian2 作为编码协议，User 需要实现 JavaClassName 方法，它的返回值在dubbo中对应User类的类名。 type User struct { Id string Name string Age int32 Time time.Time } func (u User) JavaClassName() string { return &amp;#34;com.ikurento.user.User&amp;#34; } 编写业务逻辑，UserProvider 相当于dubbo中的一个服务实现。需要实现 Reference 方法，返回值是这个服务的唯一标识，对应dubbo的 beans 和 path 字段。 type UserProvider struct { } func (u *UserProvider) GetUser(ctx context.Context, req []interface{}) (*User, error) { println(&amp;#34;req:%#v&amp;#34;, req) rsp := User{&amp;#34;A001&amp;#34;, &amp;#34;hellowworld&amp;#34;, 18, time.Now()} println(&amp;#34;rsp:%#v&amp;#34;, rsp) return &amp;amp;rsp, nil } func (u *UserProvider) Reference() string { return &amp;#34;UserProvider&amp;#34; } 注册服务和对象 func init() { config.</description></item><item><title>Dubbo Go 中 metrics 的设计</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/11/dubbo-go-%E4%B8%AD-metrics-%E7%9A%84%E8%AE%BE%E8%AE%A1/</link><pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/11/dubbo-go-%E4%B8%AD-metrics-%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid><description>最近因为要在 Apache/dubbo-go（以下简称 dubbo-go ）里面实现类似的这个 metrics 功能，于是花了很多时间去了解现在 Dubbo 里面的 metrics 是怎么实现的。该部分，实际上是被放在一个独立的项目里面，即 metrics ，见 https://github.com/flycash/dubbo-go/tree/feature/MetricsFilter 下 metrics 子目录。
总体上来说，Dubbo 的 metrics 是一个从设计到实现都非常优秀的模块，理论上来说，大部分的 Java 项目是可以直接使用 metrics 的。但也因为兼顾性能、扩展性等各种非功能特性，所以初看代码会有种无从下手的感觉。
今天这篇文章将会从比较大的概念和抽象上讨论一下 dubbo-go 中的 metrics 模块的设计——实际上也就是 Dubbo 中的 metrics 的设计。因为我仅仅是将 Dubbo 里面的相关内容在 dubbo-go 中复制一份。
目前 dubbo-go 的 metrics 刚刚开始起步，第一个 PR 是： https://github.com/apache/dubbo-go/pull/278
总体设计 Metrics 要想理解 metrics 的设计，首先要理解，我们需要收集一些什么数据。我们可以轻易列举出来在 RPC 领域里面我们所关心的各种指标，诸如每个服务的调用次数，响应时间；如果更加细致一点，还有各种响应时间的分布，平均响应时间，999线……
但是上面列举的是从数据的内容上划分的。 metrics 在抽象上，则是摒弃了这种划分方式，而是结合了数据的特性和表现形式综合划分的。
从源码里面很容易找到这种划分的抽象。
metrics 设计了 Metric 接口作为所有数据的顶级抽象：
在 Dubbo 里面，其比较关键的子接口是：
为了大家理解，这里我抄一下这些接口的用途：
Gauge: 一种实时数据的度量，反映的是瞬态的数据，不具有累加性，例如当前 JVM 的线程数； Counter: 计数器型指标，适用于记录调用总量等类型的数据； Histogram : 直方分布指标，例如，可以用于统计某个接口的响应时间，可以展示 50%, 70%, 90% 的请求响应时间落在哪个区间内； Meter: 一种用于度量一段时间内吞吐率的计量器。例如，一分钟内，五分钟内，十五分钟内的qps指标； Timer: Timer相当于Meter+Histogram的组合，同时统计一段代码，一个方法的qps，以及执行时间的分布情况； 目前 dubbo-go 只实现了 FastCompass ，它也是 Metric 的子类：</description></item><item><title>Dubbo Go 中的 TPS Limit 设计与实现</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/11/dubbo-go-%E4%B8%AD%E7%9A%84-tps-limit-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link><pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/11/dubbo-go-%E4%B8%AD%E7%9A%84-tps-limit-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid><description>前言 Apache Dubbo是由阿里开源的一个RPC框架，除了基本的RPC功能以外，还提供了一整套的服务治理相关功能。目前它已经是Apache基金会下的顶级项目。
而dubbogo则是dubbo的go语言实现。
最近在dubbogo的todo list上发现，它还没有实现TPS Limit的模块，于是就抽空实现了这个部分。
TPS limit实际上就是限流，比如说限制一分钟内某个接口只能访问200次，超过这个次数，则会被拒绝服务。在Dubbo的Java版本上，只有一个实现，就是DefaultTPSLimiter。
DefaultTPSLimiter是在服务级别上进行限流。虽然dubbo的官方文档里面声称可以在method级别上进行限流，但是我看了一下它的源码，实际上这个是做不到的。当然，如果自己通过实现Filter接口来实现method级别的限流，那么自然是可以的——这样暴露了dubboJava版本实现的另外一个问题，就是dubbo的TpsLimitFilter实现，是不允许接入自己TpsLimiter的实现的。这从它的源码也可以看出来：
它直接写死了TpsLimiter的实现。
这个实现的目前只是合并到了develop上，等下次发布正式版本的时候才会发布出来。
Github: https://github.com/apache/dubbo-go/pull/237
设计思路 于是我大概参考了一下dubbo已有的实现，做了一点改进。
dubbo里面的核心抽象是TpsLimiter接口。TpsLimitFilter只是简单调用了一下这个接口的方法而已：
这个抽象是很棒的。但是还欠缺了一些抽象。
实际上，一个TPS Limit就要解决三个问题：
对什么东西进行limit。比如说，对服务进行限流，或者对某个方法进行限流，或者对IP进行限流，或者对用户进行限流； 如何判断已经over limitation。这是从算法层面上考虑，即用什么算法来判断某个调用进来的时候，已经超过配置的上限了； 被拒绝之后该如何处理。如果一个请求被断定为已经over limititation了，那么该怎么处理； 所以在TpsLimiter接口的基础上，我再加了两个抽象：
type TpsLimiter interface { // IsAllowable will check whether this invocation should be enabled for further process IsAllowable(*common.URL, protocol.Invocation) bool } type TpsLimitStrategy interface { // IsAllowable will return true if this invocation is not over limitation IsAllowable() bool } type RejectedExecutionHandler interface { // RejectedExecution will be called if the invocation was rejected by some component.</description></item><item><title>dubbo-go 中如何实现远程配置管理？</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/11/dubbo-go-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/11/dubbo-go-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/</guid><description>之前在 Apache/dubbo-go（以下简称 dubbo-go ）社区中，有同学希望配置文件不仅可以放于本地，还可以放于配置管理中心里。那么，放在本地和配置管理中心究竟有哪些不一样呢？
放在本地，每次更新需要重启，配置文件管理困难，无法做到实时更新即刻生效。此外，本地文件还依赖人工版本控制，在微服务的场景下，大大的增加了运维的成本与难度。
而配置管理中心提供了统一的配置文件管理，支持文件更新、实时同步、统一版本控制、权限管理等功能。
目标 基于以上几个背景，可以总结出以下目标
与 Dubbo 现有的配置中心内的配置文件兼容，降低新增语言栈的学习成本； 支持多种配置文件格式； 支持主流配置中心，适应不一样的使用场景，实现高扩展的配置下发； 配置中心 配置中心在 dubbo-go 中主要承担以下场景的职责：
作为外部化配置中心，即存储 dubbo.properties 配置文件，此时，key 值通常为文件名如 dubbo.properties , value 则为配置文件内容。 存储单个配置项，如各种开关项、常量值等。 存储服务治理规则，此时 key 通常按照 “服务名 + 规则类型” 的格式来组织，而 value 则为具体的治理规则。 就目前而言，dubbo-go 首要支持的是 Dubbo 中支持的开源配置中心，包括：
Apollo：携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。 ZooKeeper：一个分布式的，开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，是 Hadoop 和 Hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 Nacos: Alibaba 开源的配置管理组件，提供了一组简单易用的特性集，帮助您实现动态服务发现、服务配置管理、服务及流量管理。 而考虑到某些公司内部有自身的研发的配置中心，又或者当前流行而 Dubbo 尚未支持的配置中心，如 etcd，我们的核心在于设计一套机制，允许我们，也包括用户，可以通过扩展接口新的实现，来快速接入不同的配置中心。
那在 dubbo-go 中究竟怎么实现呢？我们的答案是：基于动态的插件机制在启动时按需加载配置中心的不同实现。
实现该部分功能放置于一个独立的子项目中，见： https://github.com/apache/dubbo-go/tree/master/config_center
dubbo-go 设计 原逻辑为：启动时读取本地配置文件，将其加载进内存，通过配置文件中的配置读取注册中心的信息获取服务提供者，注册服务消费者。
有些读者会有点困惑，不是说好了使用配置中心的，为什么现在又要读取本地配置呢？答案就是，读取的这部分信息分成两部分：
使用什么作为配置中心； 该配置中心的元数据，比如说使用 zookeeper 作为配置中心，那么 zookeeper 的链接信息就是元数据，毕竟我们只有在知道了链接信息之后才能连上 zookeeper； 在改造的时候，需要考虑以下的问题：</description></item><item><title>Dubbo Go Getty 开发日志</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/11/dubbo-go-getty-%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</link><pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/11/dubbo-go-getty-%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</guid><description>0 说明 [getty][3]是一个go语言实现的网络层引擎，可以处理TCP/UDP/websocket三种网络协议。
2016年6月我在上海做一个即时通讯项目时，接口层的底层网络驱动是当时的同事sanbit写的，原始网络层实现了TCP Server，其命名规范学习了著名的netty。当时这个引擎比较简洁，随着我对这个项目的改进这个网络层引擎也就随之进化了（添加了TCP Client、抽象出了 TCP connection 和 TCP session），至2016年8月份（又添加了websocket）其与原始实现已经大异其趣了，征得原作者和相关领导同意后就放到了github上。
将近两年的时间我不间断地对其进行改进，年齿渐增但记忆速衰，觉得有必要记录下一些开发过程中遇到的问题以及解决方法，以备将来回忆之参考。
1 UDP connection 2018年3月5日 起给 getty 添加了UDP支持。
1.1 UDP connect UDP自身分为unconnected UDP和connected UDP两种，connected UDP的底层原理见下图。
当一端的UDP endpoint调用connect之后，os就会在内部的routing table上把udp socket和另一个endpoint的地址关联起来，在发起connect的udp endpoint端建立起一个单向的连接四元组：发出的datagram packet只能发往这个endpoint（不管sendto的时候是否指定了地址）且只能接收这个endpoint发来的udp datagram packet（如图???发来的包会被OS丢弃）。
UDP endpoint发起connect后，OS并不会进行TCP式的三次握手，操作系统共仅仅记录下UDP socket的peer udp endpoint 地址后就理解返回，仅仅会核查对端地址是否存在网络中。
至于另一个udp endpoint是否为connected udp则无关紧要，所以称udp connection是单向的连接。如果connect的对端不存在或者对端端口没有进程监听，则发包后对端会返回ICMP “port unreachable” 错误。
如果一个POSIX系统的进程发起UDP write时没有指定peer UDP address，则会收到ENOTCONN错误，而非EDESTADDRREQ。
一般发起connect的为 UDP client，典型的场景是DNS系统，DNS client根据/etc/resolv.conf里面指定的DNS server进行connect动作。
至于 UDP server 发起connect的情形有 TFTP，UDP client 和 UDP server 需要进行长时间的通信， client 和 server 都需要调用 connect 成为 connected UDP。</description></item><item><title>无缝衔接 gRPC 与 dubbo-go</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/11/%E6%97%A0%E7%BC%9D%E8%A1%94%E6%8E%A5-grpc-%E4%B8%8E-dubbo-go/</link><pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/11/%E6%97%A0%E7%BC%9D%E8%A1%94%E6%8E%A5-grpc-%E4%B8%8E-dubbo-go/</guid><description>最近我们 dubbo-go 社区里面，呼声很大的一个 feature 就是对 gRPC 的支持。在某位大佬的不懈努力之下，终于弄出来了。
今天我就给大家分析一下大佬是怎么连接 dubbo-go 和 gRPC 。
gRPC 先来简单介绍一下 gRPC 。它是 Google 推出来的一个 RPC 框架。gRPC是通过 IDL ( Interface Definition Language )——接口定义语言——编译成不同语言的客户端来实现的。可以说是RPC理论的一个非常非常标准的实现。
因而 gRPC 天然就支持多语言。这几年，它几乎成为了跨语言 RPC 框架的标准实现方式了，很多优秀的rpc框架，如 Spring Cloud 和 dubbo ，都支持 gRPC 。
server 端
在 Go 里面，server 端的用法是：
它的关键部分是：s := grpc.NewServer()和pb.RegisterGreeterServer(s, &amp;amp;server{})两个步骤。第一个步骤很容易，唯独第二个步骤RegisterGreeterServer有点麻烦。为什么呢？
因为pb.RegisterGreeterServer(s, &amp;amp;server{})这个方法是通过用户定义的protobuf编译出来的。
好在，这个编译出来的方法，本质上是：
也就是说，如果我们在 dubbo-go 里面拿到这个 _Greeter_serviceDesc ，就可以实现这个 server 的注册。因此，可以看到，在 dubbo-go 里面，要解决的一个关键问题就是如何拿到这个 serviceDesc 。
Client 端 Client 端的用法是：
这个东西要复杂一点：1、创建连接：conn, err := grpc.Dial(address)2、创建client：c := pb.</description></item><item><title>在dubbo-go中使用sentinel</title><link>https://dubbo.apache.org/zh-cn/blog/2021/01/11/%E5%9C%A8dubbo-go%E4%B8%AD%E4%BD%BF%E7%94%A8sentinel/</link><pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/01/11/%E5%9C%A8dubbo-go%E4%B8%AD%E4%BD%BF%E7%94%A8sentinel/</guid><description>时至今日，Apache/dubbo-go（以下简称 dubbo-go ）项目在功能上已经逐步对齐java版本，稳定性也在不同的生产环境得到了验证。社区便开始再服务治理、监控等方向发力。随着 1.2和1.3 版本发布， dubbo-go 新增了大量此类新feature。
今天我们聊一聊限流相关话题，此前dubbo-go已经支持了tps limit、execute limit 、hystrix 的内置filter，用户只要简单配置就能马上用上。但我们知道，在 java 的 dubbo 生态中，有一项限流工具被广泛使用，那就是sentinel。sentinel因为强大的动态规划配置、优秀的dashboard以及对dubbo的良好适配，成为众多使用dubbo的企业选用限流工具的不二之选。
就在前些日子，社区非常高兴得知 Sentinel Golang 首个版本 0.1.0 正式发布，这使得 dubbo-go也可以使用 sentinel 作为工具进行一些服务治理、监控的工作了。随着sentinel golang的健壮，我们相信用户马上可以像sentinel管理java dubbo服务那样管理dubbo-go的服务了。
完成sentinel golang的dubbo-adapter其实非常简单，这得益于dubbo-go早就完成了filter链的构造，用户可以自定义filter，并且灵活的安排其执行顺序。在1.3发布后，增加了filter中的context传递，构建sentinel/adapter/dubbo更为方便。
我们以其中的provider filter适配为例:
此 filter 实现了 dubbo-go的filter接口，只要用户在服务启动时将此filter加载到dubbo-go中，即可使用此filter。
sentinel实现原理与其他限流、熔断库大同小异，底层是用的滑动窗口算法。与hystrix等框架相比不同点是设计理念，Sentinel 的设计理念是让您自由选择控制的角度，并进行灵活组合，从而达到想要的效果。
下面我整理了完整的使用流程：(注意：dubbo-go版本请使用1.3.0-rc3及其以上版本)
在dubbo-go中使用sentinel主要分为以下几步：
初始化sentinel 将sentinel注入dubbo-go的filter 初始化dubbo-go 配置规划 初始化sentinel 示例代码：
import ( sentinel &amp;#34;github.com/alibaba/sentinel-golang/api&amp;#34; ) func initSentinel() { err := sentinel.InitWithLogDir(confPath, logDir) if err != nil { // 初始化 Sentinel 失败 } } 将sentinel注入dubbo-go的filter 你可以通过import包的形式执行，执行其中的init()来注入filter</description></item><item><title>Dubbo-Api-Docs -- Apache Dubbo文档展示&amp;测试工具</title><link>https://dubbo.apache.org/zh-cn/blog/2020/12/22/dubbo-api-docs--apache-dubbo%E6%96%87%E6%A1%A3%E5%B1%95%E7%A4%BA%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</link><pubDate>Tue, 22 Dec 2020 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2020/12/22/dubbo-api-docs--apache-dubbo%E6%96%87%E6%A1%A3%E5%B1%95%E7%A4%BA%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</guid><description>Dubbo-Api-Docs 背景 Swagger 是一个规范和完整的前端框架,用于生成,描述,调用和可视化 RESTful 风格的 Web 服务. Swagger 规范也逐渐发展成为了 OpenAPI 规范.
Springfox 是一个集成了Swagger,基于 Sring MVC/Spring Webflux 实现的一个 Swagger 描述文件生成框架,通过使用它定义的 一些描述接口的注解自动生成Swagger的描述文件, 使 Swagger 能够展示并调用接口.
相信很多人都听说和使用过Swagger和Springfox, 这里就不再赘述了.
Dubbo-Admin中有接口测试功能,但是缺少接口描述的文档,所以该测试功能比较适合接口开发人员用于测试接口.而其他人想要使用该功能就必须 先通过接口开发者编写的文档或者其他方式了解清楚接口信息才能使用该功能测试接口. Dubbo这边有没有集合文档展示和测试功能,能不用写文档就能把接口直接给调用方,类似Swagger/Springfox的工具呢? 之前做过一些调研,找到一些类似的工具:
有些是基于Springfox做的,直接一个文本域放JSON, 与目前Admin中的测试功能大同小异 有些是直接基于Swagger的Java版OpenApi规范生成工具做的,能把一些基础数据类型的简单参数作为表单项展示 它们都有一个共同点: 会把你的提供者变为Web项目. 当然有些提供者是通过web容器加载启动的,甚至也有和web工程在一起的,那就无所谓了. 但也有非web的提供者. 为了文档我得把它变为web项目吗?(还要引入一堆Web框架的依赖?比如Spring MVC)或者说生产环境打包时删除它的引用 和代码里的相关注解? 有没有简单点的方式呢?
OpenAPI中没有RPC的规范,Swagger是OpenAPI的实现,所以也不支持RPC相关调用.Springfox是通过Swagger实现的 RESTful API的工具, 而RESTful又是基于Web的,Dubbo没法直接使用.我们最终选择了自己实现:
提供一些描述接口信息的简单注解 在提供者启动时解析注解并缓存解析结果 在提供者增加几个Dubbo-Api-Docs使用的获取接口信息的接口 在Dubbo Admin侧通过Dubbo泛化调用实现Http方式调用Dubbo接口的网关 在Dubbo Admin侧实现接口信息展示和调用接口功能 下列情况中的参数直接展示为表单项,其他的展示为JSON: 方法参数为基础数据类型的 方法参数为一个Bean,Bena中属性为基础数据类型的 很少的第三方依赖,甚至大部分都是你项目里本身就使用的 可以通过profile决定是否加载, 打包时简单的修改profile就能区分生产和测试,甚至profile你本来就使用了 今天,我很高兴的宣布: Dubbo 用户也可以享受类似Swagger的体验了 &amp;ndash; Dubbo-Api-Docs发布了.
简介 Dubbo-Api-Docs 是一个展示dubbo接口文档,测试接口的工具.
使用 Dubbo-Api-Docs 分为两个主要步骤:
在dubbo项目引入Dubbo-Api-Docs 相关jar包,并增加类似Swagger的注解.</description></item><item><title>Dubbo Java 2.7.5 功能解析</title><link>https://dubbo.apache.org/zh-cn/blog/2020/05/18/dubbo-java-2.7.5-%E5%8A%9F%E8%83%BD%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 18 May 2020 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2020/05/18/dubbo-java-2.7.5-%E5%8A%9F%E8%83%BD%E8%A7%A3%E6%9E%90/</guid><description>近日，备受瞩目的 Dubbo 2.7.5 版本正式发布，在 2.7.5 版本中，Dubbo 引入了很多新的特性、对现有的很多功能做了增强、同时在性能上也有了非常大的提升，这个版本无论对 Dubbo 社区亦或是开发者来说，都将是一个里程碑式的版本。
应用粒度服务注册【beta】 HTTP/2 (gRPC) 协议支持 Protobuf 支持 性能优化，调用链路性能提升 30% 支持 TLS 安全传输链路 优化的消费端线程模型 新增更适应多集群部署场景的负载均衡策略 全新的应用开发 API （兼容老版本应用）【beta】 其他一些功能增强与 bugfix 首先，从服务发现上，新版本突破以往基于接口粒度的模型，引入了全新的基于应用粒度的服务发现机制 - 服务自省，虽然该机制当前仍处于 beta 阶段，但对于 Dubbo 向整个微服务云原生体系靠齐，都打下了非常好的基础；得益于紧凑的协议设计和代码实现上的优化，Dubbo 一直以来都具有较好的性能表现，在 2.7.5 版本中，性能上有了进一步的提升，根据来自官方维护团队的压测，新版本在调用链路上性能提升达到 30%；云原生微服务时代，多语言需求变得越来越普遍，协议的通用性和穿透性对于构建打通前后端的整套微服务体系也变得非常关键，Dubbo 通过实现 gRPC 协议实现了对 HTTP/2 协议的支持，同时增加了与 Protobuf 的结合。
1. 应用粒度服务注册【beta】 从 Java 实现版本的角度来说，Dubbo 是一个面向接口代理的服务开发框架，服务定义、服务发布以及服务引用都是基于接口，服务治理层面包括服务发现、各种规则定义也都是基于接口定义的，基于接口可以说是 Dubbo 的一大优势，比如向开发者屏蔽了远程调用细节、治理粒度更精细等。但基于接口的服务定义同时也存在一些问题，如服务，与业界通用的微服务体系等。
针对以上问题，2.7.5 版本引入了一种新的服务定义/治理机制：服务自省，简单来说这是一种基于应用粒度的服务治理方案。一个实例只向注册中心注册一条记录，彻底解决服务推送性能瓶颈，同时由于这样的模型与主流微服务体系如 SpringCloud、K8S 等天然是对等的，因此为 Dubbo 解决和此类异构体系间的互联互通清除了障碍。有兴趣进一步了解 Dubbo 服务自省机制如何解决异构微服务体系互联互通问题的，可具体参考我们之前的文章解析《Dubbo 如何成为联通异构微服务体系的最佳服务开发框架》。
以下是服务自省机制的基本工作原理图。
要了解更多关于服务自省工作原理的细节，请参与官方文档及后续文章。
服务自省与当前已有的机制之间可以说是互补的关系，Dubbo 框架会继续保持接口粒度的服务治理的优势，实现接口和应用两个粒度互为补充的局面，兼顾性能、灵活性和通用性，力争使 Dubbo 成为微服务开发的最佳框架。
2. HTTP/2 (gRPC) 协议支持 Dubbo RPC 协议是构建在 TCP 之上，这有很多优势也有一些缺点，缺点比如通用性、协议穿透性不强，对多语言实现不够友好等。HTTP/2 由于其标准 HTTP 协议的属性，无疑将具有更好的通用性，现在或将来在各层网络设备上肯定都会得到很好的支持，gRPC 之所以选在 HTTP/2 作为传输层载体很大程度上也是因为这个因素。当前 gRPC 在云原生、Mesh 等体系下的认可度和采用度逐步提升，俨然有成为 RPC 协议传输标准的趋势，Dubbo 和 gRPC 在协议层面是对等竞争的，但是在框架实现上却各有侧重，Dubbo 无疑有更丰富的服务开发和治理体验 。</description></item><item><title>从 2019 到 2020，Apache Dubbo 年度回顾与总结</title><link>https://dubbo.apache.org/zh-cn/blog/2020/05/11/%E4%BB%8E-2019-%E5%88%B0-2020apache-dubbo-%E5%B9%B4%E5%BA%A6%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 11 May 2020 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2020/05/11/%E4%BB%8E-2019-%E5%88%B0-2020apache-dubbo-%E5%B9%B4%E5%BA%A6%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%80%BB%E7%BB%93/</guid><description>非常感谢大家对 Dubbo 社区的关注，通过这篇文章我们将：总结过去一年 Dubbo 社区取得的成绩，包括社区和框架演进两个方面；展望未来 Dubbo 社区和框架的新的规划（roadmap）。社区建设是推动 Dubbo 健康持续发展的一个非常重要的环节，我们需要与社区保持良性的互动、有活跃的贡献者、有积极的富有建设性的讨论，而整个 Dubbo 社区过去一年在这方面都做的不错；在框架演进上，我们主要发布了 2.7.0 - 2.7.5 共 6 个特性版本，功能层面涵盖编程模型、协议、服务治理、性能优化等多个方面；除了已经发布的功能外，我们在 Dubbo 3.0 协议、服务自省和云原生等方向上也做了深入的探索，对这些方向的支持将是 Dubbo 接下来的重要工作方向，希望能通过这篇文章将其中更详细的思考和计划同步给大家。
社区回顾 回顾 Dubbo 社区过去一年的发展，其中一个重要的节点就是 2019 年 5 月从 Apache 孵化毕业。成为第二个由 Alibaba 捐献后从 Apache 毕业的项目，我有幸参与到了从重启开源、进入 Apache 孵化到毕业的整个过程，社区在此过程中做了大量的工作，包括邮件列表建设、代码规范检查、文档和代码国际化、issue/pr 处理等，这些一方面是 Apache 社区要求的工作，同时也为推动 Dubbo 的发展起到了正面的作用。
在从 Apache 毕业之后，Dubbo 相关的项目也进行了迁移，都迁移到了 Apache 组织之下：
Dubbo 社区的项目总共有 24 个之多，维护如此多的项目，并不是单纯靠几个活跃的开发者就能做到的，而是靠整个社区努力的结果。我总结了过去一年提名的所有 Committer/PMC，总过有 27 人获得提名（23 名 committer、4 名 PMC），通过下方的饼状图可以看出，只有不到 20% 的贡献者是来自于 Alibaba，而 80% 以上是来自各个不同组织的开发者或爱好者。这样的 Committer 分布，是加入 Apache 带给 Dubbo 社区的一个最重要的变化之一：Dubbo 项目是属于整个社区的，反映的是不同组织不同开发者的共同诉求，它的发展不是由一个公司控制或决定的，而是由社区共同讨论后决定的。如果你对参与到 Dubbo 社区感兴趣，都可以参与到 Dubbo 发展的讨论、决策和 coding 中来，也非常期待各位能成为下一个 Committer。</description></item><item><title>Dubbo测试验证</title><link>https://dubbo.apache.org/zh-cn/blog/2019/12/02/dubbo%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81/</link><pubDate>Mon, 02 Dec 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/12/02/dubbo%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81/</guid><description>除了线上常规的使用场景以外，我们在日常使用中还需要一些特定的使用方式，比如对正在开发的功能进行验证测试，比如单独调用某台机器的服务，这篇文章就来介绍一下这些场景下的使用方式。
只订阅 为方便开发测试，经常会在线下共用一个所有服务可用的注册中心，这时，如果一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。
可以让服务提供者开发方，只订阅服务(开发的服务可能依赖其它服务)，而不注册正在开发的服务，通过直连测试正在开发的服务。 禁用注册配置
&amp;lt;dubbo:registry address=&amp;quot;10.20.153.10:9090&amp;quot; register=&amp;quot;false&amp;quot; /&amp;gt; 或者
&amp;lt;dubbo:registry address=&amp;quot;10.20.153.10:9090?register=false&amp;quot; /&amp;gt; 指定IP调用 在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表
可以通过以下几种配置来指定IP调用
XML 配置： 如果是线上需求需要点对点，可在 dubbo:reference 中配置 url 指向提供者，将绕过注册中心，多个地址用分号隔开，配置如下： &amp;lt;dubbo:reference id=&amp;quot;xxxService&amp;quot; interface=&amp;quot;com.alibaba.xxx.XxxService&amp;quot; url=&amp;quot;dubbo://localhost:20890&amp;quot; /&amp;gt; 通过-D参数指定： 在 JVM 启动参数中加入-D参数映射服务地址，如：java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890 通过文件映射: 如果服务比较多，也可以用文件映射，用 -Ddubbo.resolve.file 指定映射文件路径，此配置优先级高于 dubbo:reference 中的配置，如： java -Ddubbo.resolve.file=xxx.properties
然后在映射文件 xxx.properties 中加入配置，其中 key 为服务名，value 为服务提供者 URL：com.alibaba.xxx.XxxService=dubbo://localhost:20890 回声测试 使用方式 回声测试用于检测服务是否可用，回声测试按照正常请求流程执行，能够测试整个调用是否通畅，可用于监控。
所有服务自动实现 EchoService 接口，只需将任意服务引用强制转型为 EchoService，即可使用。
Spring 配置：
&amp;lt;dubbo:reference id=&amp;quot;memberService&amp;quot; interface=&amp;quot;com.xxx.MemberService&amp;quot; /&amp;gt; 代码：
// 远程服务引用 MemberService memberService = ctx.</description></item><item><title>Dubbo 在 Service Mesh 下的思考和方案</title><link>https://dubbo.apache.org/zh-cn/blog/2019/11/30/dubbo-%E5%9C%A8-service-mesh-%E4%B8%8B%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E6%96%B9%E6%A1%88/</link><pubDate>Sat, 30 Nov 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/11/30/dubbo-%E5%9C%A8-service-mesh-%E4%B8%8B%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E6%96%B9%E6%A1%88/</guid><description>开头 Service Mesh这个“热”词是2016年9月被“造”出来，而今年2018年更是被称为service Mesh的关键之年，各家大公司都希望能在这个思潮下领先一步。今天我也分享阿里中间件在这方面的观点，思考和实践。考虑到有些人没了解过Dubbo(集团内以HSF为主)和Servicemesh，先简单介绍下这两个词。Dubbo应该是国内最受欢迎的远程服务框架，在Github上有超过2w的star数，也是阿里分布式架构互联互通的核心所在。跟Dubbo一样，servicemesh也是面向服务互联互通这一问题域，是云原生技术栈的核心之一；大家可以简单理解service mesh就是云原生组织定义的微服务架构解决理念。Dubbo是实现框架，融入service mesh理念就是我们今天分享的。
现状和挑战 当前Dubbo支撑的阿里分布式应用内支撑万级别的应用数，运行在20多万的服务器实例上，每天调用量是万亿级别，这应该是国内最大的分布式应用集群。
挑战主要来自三方面
首先， 数以万计的应用意味着有以十万级的服务，理顺错综复杂的服务拓扑关系，甚至及时诊断某个异常调用链路，需要考虑海量数据的拉取分析，是非常有挑战的，阿里通过EagleEye鹰眼链路系统提供可观察性和治理能力来解决； 第二个挑战是机房级别容灾，阿里的机房是分布在天南海北，大家可以想象横跨数千公里的网络延迟会造成服务互通很大的影响，所以在保证一定恢复时间和一定数据容错的情况下做异地多活是有巨大挑战，阿里通过支持异地多活的单元化架构解决。 第三个挑战是阿里业务众多，尤其像阿里生态中的高德，UC，优酷等所使用的开发语言跟淘系Java是不一样的，比如PHP，C，Nodejs，Dart等，要维护多个版本并保证各版本具有同样的功能是成本比较高的；这个挑战在云原生的新一代理念下更具挑战，毕竟。今天主题跟第三个挑战是息息相关，能解决一定的问题。 这里讲个大鱼吃小鱼的故事来简单理解下云原生：软件会吃掉这个世界，也就是信息化不可避免，而开源会吃掉软件，最终云原生会吃掉开源。这正代表了云原生理念的颠覆性，从商业软件到开源到云原生，环环相套，以体系化和层次化的方式推荐各个方面的开源方案和标准，这会极大降低企业级架构服务的技术门槛，是企业信息化之路的一大利好，当然也是进化方向。这个故事跟今天的主题&amp;ndash;开发者定义软件未来，是非常契合，也就是说这个趋势至少在企业级软件服务领域正在发生。云原生：Cloud Native is Patterns with A complete and trusted tool kit for modern architectures。
Service Mesh的典型方案
Service Mesh的典型方案 讲完故事，回到servicemesh。
传统形态下SDK代表着一个特定语言的库，由应用和微服务框架共处一进程内，在发布升级中共享生命周期。比较典型的代表是Twitter的finagle，Google的stubby/grpc，阿里巴巴的HSF/Dubbo.
Serviemesh下推荐是右边Sidecar方案，Sidecar方案没有引入新的功能，只是改变了原有功能的位置，以独立的应用来存在，大家可以暂时以nginx来理解其网络代理能力也可以。
在这张图中希望大家关注两个信息， 1）所有的sidecar形成逻辑网络被称为数据面，是业务服务的链路中是强依赖节点，承载了业务数据互联互通的基础；传统的ops管控服务被称为控制面，这部分跟传统是大同小异。 2）在sidecar形态下，网络会增加两跳，即应用与sidecar之间，他们之间的数据互通也是基于协议规范。后面会详细讲。
Sidecar模式的优劣 接下来从开发和运维两个阶段来分开比较。
多语言支持方面，既然sidecar是独立应用，用最合适的一种语言开发完成即可，就避免了需要针对不同语言的应用场景做不同的版本开发。当前阿里选择基于C语言的Envoy做二次开发来追求最小的footprint和性能，当然也曾经历一些弯路，比如曾经用Java开发过一个sidecar，但最终由于引入JRE体量大和GC带来的抖动等问题证明不可行。有必要强调的是：这里说的是sidecar自身开发现在避免了多语言多版本的问题，而真要支持任意服务自由采用任意语言实现这一理想，是需要站在从业务到数据面再到业务的整个链路上的数据交互做思考。 性能方面，sidecar情形下由于会增加两跳，这两跳是业务应用与sidecar的两个进程之间的调用，这是本机，即便是经过优化，也是会增加进程切换以及数据转换的开销。经过我们的优化测试，在正常的业务访问下，相比SDK形态下最多增加1毫秒的开销，这在大多数业务情形下是基本无感知无影响。 再看运维阶段的比较，一般SDK形态的服务框架都是只关心开发的诉求，对于如何运维都是不关心，而软件生命周期中运维是最长的，如何从中间件角度解决更多的运维问题是非常有意义的。阿里的中间件经常需要升级，以库的形式升级时就需要业务方应用重新打包，这个推动业务方变更的方式是比较被动，而且周期很长。 当以镜像为基本原子单位进行发布部署时，阿里的中间件SDK体量大概是200兆，需要与业务一起打包，这样在业务应用升级时让分发的包就显得笨重，时效性相比sidecar形态就差一截。 稍微总结下，sidecar具有两个明显优势，一个是多语言开发维护成本低 ，另一个是独立升级，当然代价是需要增加一点点的网络延迟。至此大家是不是觉得Sidecar基本完美？ 别着急，需要大家再思考一个问题：SDK模式下中间件组件会随应用一起发布，拥有完全一致的生命周期；而在sidecar模式下，如何管理sidecar的生命周期？这里可以拿无线耳机来举个例子，无线耳机是独立了，但必须独立电源的驱动，所以充电是要的。是的，在大规模的集群中这个点会带来不小的复杂性。
关键点 下面跟大家分享下我们对servicemesh理解的三个关键技术点。分别是sidecar运维，数据面与控制面的集成，协议。
先说sidecar的运维，这是个难点，也是为什么sidecar方案以前没有被广泛应用的重要原因。前面说sidecar与应用现在成为两个不同的进程，要考虑多个事宜，一是要考虑如何把sidecar与应用部署在一起，二是考虑业务进程或sidecar进程一方需要升级重启时如何协同来保证请求的正常处理或转发，即优雅上下线的问题。这些事宜考虑清楚并解决后，算是具备servicemesh的前提条件。当然，kubernetes解决了这块的事情，提供了initiator类似插件的机制来对原子性的pod进行注入sidecar，并通过健康检查机制来保证两个进程的协同。简单地也可以这么理解：先把kubernetes容器调度平台的实施是servicemesh的前提条件。 数据面中的sidecar的服务治理能力则是其核心竞争力，包括负载均衡策略，路由，安全，权重等等，这些能力是以规则形式通过控制面来统一下发给数据面。在传统微服务框架下数据面和控制面的集成是紧耦合，也就是数据面和控制面是一体的，举例来说用了Dubbo框架，只能选择Dubbo-Ops。而Envoy作为servicemesh思潮的带领者，提出了一整套的API规范，Istio可以实现其xDS接口，阿里巴巴也可以根据自己的架构设计实现类似的服务平台。 协议 协议 协议， 重要的事说三遍。。。sidecar和Dubbo的内核是网络协议的处理器，而sidecar又是面向多语言场景的，所以自然协议处理能力是要强调的。先说下阿里Dubbo当下向Mesh方向发展时遇到难点。首先我们的服务接口都是通过Java Interface描述，其次涉及的传输模型DTO也是Java POJO定义，最后协议也是私有的。这会导致跨语言比较难，而sidecar形态需要面向多语言，这些问题更是首当其冲。考虑到这里有点稍微偏细节点，希望大家带着如下问题来先思考下：业务应用到sidecar之间的数据交换要考虑什么? Sidecar自身在处理网络字节流时又要考虑什么？是的，首先业务应用最好都不依赖特定协议库，也不依赖特接口定义库；Sidecar自身处理数据时跟nginx很接近，但最好具备协议转换适配的能力，比如把基于HTTP的请求转换为Dubbo请求，就能轻松集成Dubbo遗留系统。 回看协议 既然协议在跨语言场景下如此重要，有必要稍微回归下协议的历史轨迹。看历史一般是轻松有趣的过程，最重要的好处是能使我们头脑清晰而不迷茫。
我们先从2008年说起，很近也就10年，阿里服务框架诞生这一年。当年各大公司还在炒作SOA思想的时候，阿里在不清楚SOA思想的情况下根据自身业务诉求实践拥抱了SOA的架构。阿里服务框架一直是从三个层面来定义，第一RPC通信 第二是提供丰富强大的治理能力 第三就是基于容器隔离的运维能力，使得中间件可以独立升级。这个理念直到今日都是非常先进，非常的赞。就像前面说的，Dubbo主要是面向Java领域的微服务架构解决方案，在以Java为主导的技术架构下是绝对首选，但因为其协议设计是私有特性，要想成为跨语言的协议标准是有一定难度。
事实上，之前已经出现了很多通用的跨语言的服务集成规范。最早是91年的CORBA，是分布式对象访问协议，2000年的SOAP是当年webservice思想下的协议，无论是CORBA还是SOAP都是支持所有平台和语言的一套规范，但是设计地比较复杂笨重，且性能存在一定问题。
REST是一种架构风格，相比SOAP的设计，有非常优秀的理念和最佳实践指导，并且万维网作为世界上最大型最成功的的分布式应用是REST最好的证明。但跟SOAP一样，REST跑在1上有性能瓶颈，这个也可能是当年阿里服务框架没有选择REST规范的原因。额外提下，REST思想虽然很早就有，但事实上REST的规范在Java领域JAX-RS API 直到最近两年在2.2版本下才算稳定成形，且越来越接近微服务框架。
1996年的1在连接通道不支持多工复用，根本无法发挥TCP/UDP的网络能力；而到了2015年HTTP2则解决这些，能够最大限度的利用TCP层的网络宽带，且支持了streaming，push等交互模式，这些跟很多的私有或专有应用协议干得是一个事，但是标准化的大家都容易接受的事。这里必须提一下，伴随HTTP2而来的是grpc，原先Google早早推出了Protocolbuffer，但一直没把自家stubby开源，我猜测最大的原因是不想grpc跑在一个私有协议上，而是在等HTTP2.
总结下来，协议技术一直在向着轻量级和标准规范化的方向发展。像SOAP，CORBA这些重量级的不跨平台的协议必然消失在历史车轮里，私有或专有的协议也会向标准协议靠拢。在面向跨语言的场景下，有两种的协议规范是大概率胜出，一种是REST，一种是grpc，两者都是以HTTP为交换通道。
面向多语言协议的三层面 展开来讲，在面向多语言的协议需要考虑三个层面。</description></item><item><title>Dubbo服务端异步接口的实现背景和实践</title><link>https://dubbo.apache.org/zh-cn/blog/2019/11/02/dubbo%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E5%92%8C%E5%AE%9E%E8%B7%B5/</link><pubDate>Sat, 02 Nov 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/11/02/dubbo%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E5%92%8C%E5%AE%9E%E8%B7%B5/</guid><description>铺垫 建议先对Dubbo的处理过程中涉及的线程阶段先做个了解，具体可参考Dubbo客户端异步接口的实现背景和使用场景。
实现背景 有必要比较详细点的介绍下服务端的线程策略来加深用户在选择服务端异步的判断依据，同时有必要引出协程这一在服务端异步中常常会用到的“秘密武器”。
服务端的线程策略 Dubbo支持多种NIO框架来做Remoting的协议实现，无论是Netty，Mina或者Grizzly，实现都大同小异，都是基于事件驱动的方式来做网络通道建立，数据流读取的。其中以Grizzly对于线程策略的介绍为例，通常支持以下四种。Dubbo作为一个RPC框架，默认选择的是第一种策略，原因在于业务服务是CPU密集型还是IO阻塞型，是无法断定的，第一种策略是最保险的策略。当然，对于这几种策略有了了解后，再结合业务场景做针对性的选择是最完美的。
Worker-thread策略 最常用最普适的策略，其中IO线程将NIO事件处理委托给工作线程。
此策略具有很高的伸缩性。我们可以根据需要更改IO和worker线程池的大小，并且不存在在特定NIO事件处理期间可能发生的，同一Selector各个Channel之间相互干扰的风险。
缺点是有线程上下文切换的代价。
Same-thread策略 可能是最有效的策略。与第一种不同，同一线程处理当前线程中的NIO事件，避免了昂贵的线程上下文切换。
这个策略可以调整IO线程池大小，也是具备可伸缩性；缺点也很明显，它要求业务处理中一定不要有阻塞处理，因为它可能会阻止在同一个IO线程上发生的其他NIO事件的处理。
Dynamic策略 如前所述，前两种策略具有明显的优点和缺点。但是，如果策略可以尝试在运行时根据当前条件（负载，收集的统计信息等）巧妙地交换它们，何如？
这种策略可能会带来很多好处，能更好地控制资源，前提是不要使条件评估逻辑过载，防止评估判断的复杂性会使这种策略效率低下。 多说一句，希望大家对这个策略多留意一下，它可能是Dubbo服务端异步方式的最佳搭配。我也多扯个淡，这几天关注了些adaptive XX或者predictive XX，这里看到dynamic真是亲切，Dubbo作为产品级生产级的微服务解决方案，是必须既要adaptive，又要predictive，还要dynamic，哈哈。
Leader-follower策略 此策略类似于第一种，但它不是将NIO事件处理传递给worker线程，而是通过将控制传递给Selector给工作线程，并将实际NIO事件处理当前IO线程中。这种策略其实是把worker和IO线程阶段做了混淆，个人不建议。
协程与线程 在CPU资源的管理上，OS和JVM的最小调度单位都是线程，业务应用通过扩展实现的协程包是可以具备独立的运行单位，事实上也是基于线程来做的，核心应该是遇到IO阻塞，或者锁等待时，保存上下文，然后切换到另一个协程。至于说的协程开销低，能更高效的使用CPU，这些考虑到协程库的用户态实现和上下文设计是支持的，但也建议大家结合实际业务场景做性能测试。
在默认的Dubbo线程策略中，是有worker线程池来执行业务逻辑，但也常常会发生ThreadPool Full的问题，为了尽快释放worker线程，在业务服务的实现中会另起线程。代价是再次增加线程上下文切换，同时需要考虑链路级别的数据传送(比如tracing信息)和流控的出口控制等等。当然，如果Dubbo能够切换到Same-thread策略，再配合协程库的支持，服务端异步是一种值得推荐的使用方式。
示例 通过示例来体验下Dubbo服务端异步接口。Demo代码请访问github之https://github.com/dubbo/dubbo-samples/tree/master/2-advanced/dubbo-samples-notify。
public class AsyncServiceImpl implements AsyncService { @Override public String sayHello(String name) { System.out.println(&amp;#34;Main sayHello() method start.&amp;#34;); final AsyncContext asyncContext = RpcContext.startAsync(); new Thread(() -&amp;gt; { asyncContext.signalContextSwitch(); System.out.println(&amp;#34;Attachment from consumer: &amp;#34; + RpcContext.getContext().getAttachment(&amp;#34;consumer-key1&amp;#34;)); System.out.println(&amp;#34; -- Async start.&amp;#34;); try { Thread.sleep(500); } catch (InterruptedException e) { e.</description></item><item><title>Dubbo客户端异步接口的实现背景和实践</title><link>https://dubbo.apache.org/zh-cn/blog/2019/11/01/dubbo%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E5%92%8C%E5%AE%9E%E8%B7%B5/</link><pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/11/01/dubbo%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E5%92%8C%E5%AE%9E%E8%B7%B5/</guid><description>铺垫 先简单介绍下一次完整的Dubbo调用所经历的线程阶段。几个信息这里罗列下
Biz~代表业务线程，即便是业务逻辑处理所处的线程，Biz~线程池可能是业务自己创建维护，大多数的可能是系统框架自身管理的（比如web型的业务系统跑在Tomcat容器下，Biz~线程就是Tomcat维护）；IO~代表网络数据处理线程，是IO框架（比如Netty，Grizzly）创建维护，Dubbo Remoting所默认Netty实现是NioEventloopLoopGroup；另外按照Channel与IO线程的绑定关系，也可以直接把IO~看成一个可接受事件消息的Channel。像Biz和IO这样的异步处理阶段在JDK8中有个很精确地抽象描述，叫CompletionStage。
大家知道，线程与线程之间做数据通信的方式是共享变量，Biz和IO两个stage之间的数据通信是Queue，具体到Dubbo实现，在客户端一侧的实现（即上图中用1所标注的步骤）中Biz是通过向EventLoop的LinkedBlockingQueue放置一个Task，而EventLoop有对应的Thread会不停的迭代Queue来执行Task中所包含的信息，具体代码可以看SingleThreadEventExecutor（顺便提下，Netty中默认是用无上限的LinkedBlockingQueue，在Biz的速率高于网络速率情况下，似乎好像有Memory Leak的风险）。
如上图所示，标准的一次RPC调用经过了图中所示的1,2,3,4的四次消息(事件)传递，分别是客户端业务线程到IO线程的请求发出，服务端IO线程到业务逻辑线程的__请求接受，__服务端处理完成后由业务逻辑线程到IO线程的响应写出，客户端收到结果后从IO线程到业务逻辑的响应处理。除了1与4之间一般需要维护响应和请求的映射对应关系，四次的事件处理都是完全独立的，所以一次RPC调用天然是异步的，而同步是基于异步而来。
客户端异步 实现背景 在Java语言（其他语言不清楚）下一次本地接口的调用可以透明地通过代理机制转为远程RPC的调用，大多数业务方也比较喜欢这种与本地接口类似的编程方式做远程服务集成，所以虽然RPC内部天然是异步的，但使用Dubbo的用户使用最广泛的还是同步，而异步反而成为小众的使用场景。同步的优点是编程模型更加符合业务方的“传统”习惯，代价是在图中的1代表的请求发出事件后需要阻塞当前的Biz~线程，一直等到4代表的响应处理后才能唤醒。在这个短则微秒级别，长则秒级的1,2,3,4处理过程中都要阻塞Biz~线程，就会消耗线程资源，增加系统资源的开销。
所以，客户端异步的出发点是节省线程资源开销，代价是需要了解下异步的使用方式:)。在同步方式下API接口的返回类型是代表着某个业务类，而当异步情况下，响应返回与请求发出是完全独立的两个事件，需要API接口的返回类型变为上述中说的CompletionStage才是最贴合的，这是Dubbo在异步上支持的必然异步。回到最近的Dubbo发布版，是不改变接口的情况下，需要在服务创建时注册一个回调接口来处理响应返回事件。
下面以示例来说。
示例 事件通知的示例代码请参考：https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-notify
事件通知允许 Consumer 端在调用之前、调用正常返回之后或调用出现异常时，触发 oninvoke、onreturn、onthrow 三个事件。
可以通过在配置 Consumer 时，指定事件需要通知的方法，如：
&amp;lt;bean id=&amp;#34;demoCallback&amp;#34; class=&amp;#34;com.alibaba.dubbo.samples.notify.impl.NotifyImpl&amp;#34; /&amp;gt; &amp;lt;dubbo:reference id=&amp;#34;demoService&amp;#34; check=&amp;#34;false&amp;#34; interface=&amp;#34;com.alibaba.dubbo.samples.notify.api.DemoService&amp;#34; version=&amp;#34;1.0.0&amp;#34; group=&amp;#34;cn&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;sayHello&amp;#34; onreturn=&amp;#34;demoCallback.onreturn&amp;#34; onthrow=&amp;#34;demoCallback.onthrow&amp;#34;/&amp;gt; &amp;lt;/dubbo:reference&amp;gt; 其中，NotifyImpl 的代码如下：
public class NotifyImpl implements Notify{ public Map&amp;lt;Integer, String&amp;gt; ret = new HashMap&amp;lt;Integer, String&amp;gt;(); public void onreturn(String name, int id) { ret.put(id, name); System.out.println(&amp;#34;onreturn: &amp;#34; + name); } public void onthrow(Throwable ex, String name, int id) { System.</description></item><item><title>Dubbo 在跨语言和协议穿透性方向上的探索：支持 HTTP/2 gRPC 和 Protobuf</title><link>https://dubbo.apache.org/zh-cn/blog/2019/10/28/dubbo-%E5%9C%A8%E8%B7%A8%E8%AF%AD%E8%A8%80%E5%92%8C%E5%8D%8F%E8%AE%AE%E7%A9%BF%E9%80%8F%E6%80%A7%E6%96%B9%E5%90%91%E4%B8%8A%E7%9A%84%E6%8E%A2%E7%B4%A2%E6%94%AF%E6%8C%81-http/2-grpc-%E5%92%8C-protobuf/</link><pubDate>Mon, 28 Oct 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/10/28/dubbo-%E5%9C%A8%E8%B7%A8%E8%AF%AD%E8%A8%80%E5%92%8C%E5%8D%8F%E8%AE%AE%E7%A9%BF%E9%80%8F%E6%80%A7%E6%96%B9%E5%90%91%E4%B8%8A%E7%9A%84%E6%8E%A2%E7%B4%A2%E6%94%AF%E6%8C%81-http/2-grpc-%E5%92%8C-protobuf/</guid><description>本文总体上可分为基础产品简介、Dubbo 对 gRPC (HTTP/2) 和 Protobuf 的支持及示例演示三部分，在简介部分介绍了 Dubbo、HTTP/2、gRPC、Protobuf 的基本概念和特点；第二部分介绍了 Dubbo 为何要支持 gRPC (HTTP/2) 和 Protobuf，以及这种支持为 gRPC 和 Dubbo 开发带来的好处与不同；第三部分通过两个实例分别演示了 Dubbo gRPC 和 Dubbo Protobuf 的使用方式。
基本介绍 Dubbo 协议 从协议层面展开，以下是当前 2.7 版本支持的 Dubbo 协议
众所周知，Dubbo 协议是直接定义在 TCP 传输层协议之上，由于 TCP 高可靠全双工的特点，为 Dubbo 协议的定义提供了最大的灵活性，但同时也正是因为这样的灵活性，RPC 协议普遍都是定制化的私有协议，Dubbo 同样也面临这个问题。在这里我们着重讲一下 Dubbo 在协议通用性方面值得改进的地方，关于协议详细解析请参见官网博客
Dubbo 协议体 Body 中有一个可扩展的 attachments 部分，这给 RPC 方法之外额外传递附加属性提供了可能，是一个很好的设计。但是类似的 Header 部分，却缺少类似的可扩展 attachments，这点可参考 HTTP 定义的 Ascii Header 设计，将 Body Attachments 和 Header Attachments 做职责划分。 Body 协议体中的一些 RPC 请求定位符如 Service Name、Method Name、Version 等，可以提到 Header 中，和具体的序列化协议解耦，以更好的被网络基础设施识别或用于流量管控。 扩展性不够好，欠缺协议升级方面的设计，如 Header 头中没有预留的状态标识位，或者像 HTTP 有专为协议升级或协商设计的特殊 packet。 在 Java 版本的代码实现上，不够精简和通用。如在链路传输中，存在一些语言绑定的内容；消息体中存在冗余内容，如 Service Name 在 Body 和 Attachments 中都存在。 HTTP/1 相比于直接构建与 TPC 传输层的私有 RPC 协议，构建于 HTTP 之上的远程调用解决方案会有更好的通用性，如WebServices 或 REST 架构，使用 HTTP + JSON 可以说是一个事实标准的解决方案。</description></item><item><title>本地存根和本地伪装</title><link>https://dubbo.apache.org/zh-cn/blog/2019/10/22/%E6%9C%AC%E5%9C%B0%E5%AD%98%E6%A0%B9%E5%92%8C%E6%9C%AC%E5%9C%B0%E4%BC%AA%E8%A3%85/</link><pubDate>Tue, 22 Oct 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/10/22/%E6%9C%AC%E5%9C%B0%E5%AD%98%E6%A0%B9%E5%92%8C%E6%9C%AC%E5%9C%B0%E4%BC%AA%E8%A3%85/</guid><description>基本概念 典型的 RPC 调用客户端是依赖并且只依赖接口编程来进行远程调用的。在真正发起远程调用之前，用户往往需要做一些预处理的工作，比如提前校验参数。在拿到返回调用结果之后，用户可能需要缓存结果，或者是在调用失败的时候构造容错数据，而不是简单的抛出异常。
这个时候，用户可以编写出类似以下的代码来处理上面提出的这些场景：
try { preProcess(); return service.invoke(...); } catch (Throwable e) { return mockValue; } finally { postProcess(); } 类似的，用户也可以通过面向切面编程 AOP 的高级技巧来解决上面的诉求，比如通过 Spring AOP 的方式可以通过类似下面的这段配置来完成。使用 AOP 的技巧相比上面的代码来说，避免了容错处理等与业务无关的代码对业务代码的侵入，使得业务处理主逻辑更简洁。
&amp;lt;bean id=&amp;#34;demo-service-stub&amp;#34; class=&amp;#34;org.apache.dubbo.demo.DemoServiceStub&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;demo-service-mock&amp;#34; class=&amp;#34;org.apache.dubbo.demo.DemoServiceMock&amp;#34;/&amp;gt; &amp;lt;aop:config&amp;gt; &amp;lt;aop:aspect id=&amp;#34;stub&amp;#34; ref=&amp;#34;demo-service-stub&amp;#34;&amp;gt; &amp;lt;aop:pointcut id=&amp;#34;stubPointcut&amp;#34; expression=&amp;#34;execution(* org.apache.dubbo.samples.DemoService+.*(..))&amp;#34;/&amp;gt; &amp;lt;aop:before method=&amp;#34;preProcess&amp;#34; pointcut-ref=&amp;#34;stubPointcut&amp;#34;/&amp;gt; &amp;lt;aop:after-returning method=&amp;#34;postProcess&amp;#34; pointcut-ref=&amp;#34;stubPointcut&amp;#34;/&amp;gt; &amp;lt;/aop:aspect&amp;gt; &amp;lt;aop:aspect id=&amp;#34;mock&amp;#34; ref=&amp;#34;demo-service-mock&amp;#34;&amp;gt; &amp;lt;aop:pointcut id=&amp;#34;mockPointcut&amp;#34; expression=&amp;#34;execution(* org.apache.dubbo.samples.DemoService+.*(..))&amp;#34;/&amp;gt; &amp;lt;aop:after-throwing method=&amp;#34;mock&amp;#34; pointcut-ref=&amp;#34;mockPointcut&amp;#34;/&amp;gt; &amp;lt;/aop:aspect&amp;gt; &amp;lt;/aop:config&amp;gt; 为了进一步的方便用户做 Dubbo 开发，框架提出了本地存根 Stub 和本地伪装 Mock 的概念。通过约定大于配置的理念，进一步的简化了配置，使用起来更加方便，并且不依赖额外的 AOP 框架就达到了 AOP 的效果。</description></item><item><title>Dubbo 中的 URL 统一模型</title><link>https://dubbo.apache.org/zh-cn/blog/2019/10/17/dubbo-%E4%B8%AD%E7%9A%84-url-%E7%BB%9F%E4%B8%80%E6%A8%A1%E5%9E%8B/</link><pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/10/17/dubbo-%E4%B8%AD%E7%9A%84-url-%E7%BB%9F%E4%B8%80%E6%A8%A1%E5%9E%8B/</guid><description>定义 在不谈及 dubbo 时，我们大多数人对 URL 这个概念并不会感到陌生。统一资源定位器 (RFC1738――Uniform Resource Locators (URL)）应该是最广为人知的一个 RFC 规范，它的定义也非常简单
因特网上的可用资源可以用简单字符串来表示，该文档就是描述了这种字符串的语法和语 义。而这些字符串则被称为：“统一资源定位器”（URL）
一个标准的 URL 格式至多可以包含如下的几个部分
protocol://username:password@host:port/path?key=value&amp;amp;key=value 一些典型 URL
http://www.facebook.com/friends?param1=value1&amp;amp;amp;param2=value2 https://username:password@10.20.130.230:8080/list?version=1.0.0 ftp://username:password@192.168.1.7:21/1/read.txt 当然，也有一些不太符合常规的 URL，也被归类到了 URL 之中
192.168.1.3:20880 url protocol = null, url host = 192.168.1.3, port = 20880, url path = null file:///home/user1/router.js?type=script url protocol = file, url host = null, url path = home/user1/router.js file://home/user1/router.js?type=script&amp;lt;br&amp;gt; url protocol = file, url host = home, url path = user1/router.js file:///D:/1/router.js?type=script url protocol = file, url host = null, url path = D:/1/router.</description></item><item><title>研究 Dubbo 网卡地址注册时的一点思考</title><link>https://dubbo.apache.org/zh-cn/blog/2019/10/01/%E7%A0%94%E7%A9%B6-dubbo-%E7%BD%91%E5%8D%A1%E5%9C%B0%E5%9D%80%E6%B3%A8%E5%86%8C%E6%97%B6%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</link><pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/10/01/%E7%A0%94%E7%A9%B6-dubbo-%E7%BD%91%E5%8D%A1%E5%9C%B0%E5%9D%80%E6%B3%A8%E5%86%8C%E6%97%B6%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</guid><description>1 如何选择合适的网卡地址 可能相当一部分人还不知道我这篇文章到底要讲什么，我说个场景，大家应该就明晰了。在分布式服务调用过程中，以 Dubbo 为例，服务提供者往往需要将自身的 IP 地址上报给注册中心，供消费者去发现。在大多数情况下 Dubbo 都可以正常工作，但如果你留意过 Dubbo 的 github issue，其实有不少人反馈：Dubbo Provider 注册了错误的 IP。如果你能立刻联想到：多网卡、内外网地址共存、VPN、虚拟网卡等关键词，那我建议你一定要继续将本文看下去，因为我也想到了这些，它们都是本文所要探讨的东西！那么“如何选择合适的网卡地址”呢，Dubbo 现有的逻辑到底算不算完备？我们不急着回答它，而是带着这些问题一起进行研究，相信到文末，其中答案，各位看官自有评说。
2 Dubbo 是怎么做的 Dubbo 获取网卡地址的逻辑在各个版本中也是千回百转，走过弯路，也做过优化，我们用最新的 2.7.2-SNAPSHOT 版本来介绍，在看以下源码时，大家可以怀着质疑的心态去阅读，在 dubbo github 的 master 分支可以获取源码。获取 localhost 的逻辑位于 org.apache.dubbo.common.utils.NetUtils#getLocalAddress0() 之中
private static InetAddress getLocalAddress0() { InetAddress localAddress = null; // 首先尝试获取 /etc/hosts 中 hostname 对应的 IP localAddress = InetAddress.getLocalHost(); Optional&amp;lt;InetAddress&amp;gt; addressOp = toValidAddress(localAddress); if (addressOp.isPresent()) { return addressOp.get(); } // 没有找到适合注册的 IP，则开始轮询网卡 Enumeration&amp;lt;NetworkInterface&amp;gt; interfaces = NetworkInterface.getNetworkInterfaces(); if (null == interfaces) { return localAddress; } while (interfaces.</description></item><item><title>Dubbo Admin服务测试功能</title><link>https://dubbo.apache.org/zh-cn/blog/2019/08/26/service-test/</link><pubDate>Mon, 26 Aug 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/08/26/service-test/</guid><description>基于Dubbo2.7的元数据，Dubbo Admin实现了服务测试功能，可以通过泛化调用，在控制台上调用真实的服务提供者
使用方式 部署服务提供者： 可以在这里下载demo，此工程基于spring boot，方便在IDE或者命令行启动，对于服务测试来说，只需要启动dubbo-basic-provider即可。 服务查询： 完成服务端部署后，可以到Dubbo Admin的服务测试页面上查询对应的服务: 这里的信息和元数据类似，包含方法名，参数类型和返回值信息，点击右边的标签就可以进入服务测试页面 服务测试： 服务测试页面包含了两个json编辑器，参数类型的信息都是以json格式保存，这里需要填入对应的参数值(本例中数类型时String)，填写完成后点击执行即可对服务端发起调用，调用结果展示在右边的编辑器中，如果调用失败，会显示详细的失败原因，下面来看一下调用失败的例子：
本例中，先关掉Dubbo服务提供者的进程，再执行服务测试，可以看到返回的结果是找不到服务提供者的异常。和普通调用一样，业务和框架的异常都会返回在结果中，方便业务排查。 复合类型参数
考虑UserService中的以下方法和类型： //org.apache.dubbo.demo.api.UserService Result getUser(String name, UserInfoDO userInfoDO); public class UserInfoDO { private int id; private LocationDO locationDO; private DepartmentDO departmentDO; @Override public String toString() { return &amp;#34;UserInfoDO{&amp;#34; + &amp;#34;id=&amp;#34; + id + &amp;#34;, locationDO=&amp;#34; + locationDO.toString() + &amp;#34;, departmentDO=&amp;#34; + departmentDO.toString() + &amp;#39;}&amp;#39;; } } public class DepartmentDO { private String departName; private LocationDO departLocation; @Override public String toString() { return &amp;#34;DepartmentDO{&amp;#34; + &amp;#34;departName=&amp;#39;&amp;#34; + departName + &amp;#39;\&amp;#39;&amp;#39; + &amp;#34;, departLocation=&amp;#34; + departLocation.</description></item><item><title>本地调用</title><link>https://dubbo.apache.org/zh-cn/blog/2019/08/11/%E6%9C%AC%E5%9C%B0%E8%B0%83%E7%94%A8/</link><pubDate>Sun, 11 Aug 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/08/11/%E6%9C%AC%E5%9C%B0%E8%B0%83%E7%94%A8/</guid><description>本地调用介绍 当一个应用既是一个服务的提供者，同时也是这个服务的消费者的时候，可以直接对本机提供的服务发起本地调用。从 2.2.0 版本开始，Dubbo 默认在本地以 injvm 的方式暴露服务，这样的话，在同一个进程里对这个服务的调用会优先走本地调用。
与本地对象上方法调用不同的是，Dubbo 本地调用会经过 Filter 链，其中包括了 Consumer 端的 Filter 链以及 Provider 端的 Filter 链。通过这样的机制，本地消费者和其他消费者都是统一对待，统一监控，服务统一进行治理。
同时，相比于远程调用来说，Dubbo 本地调用性能较优，省去了请求、响应的编解码及网络传输的过程。
要使用 Dubbo 本地调用不需做特殊配置，按正常 Dubbo 服务暴露服务即可。任一服务在暴露远程服务的同时，也会同时以 injvm 的协议暴露本地服务。injvm 是一个伪协议，不会像其他协议那样对外开启端口，只用于本地调用的目的。
以下面的 XML 配置为例：
&amp;lt;dubbo:registry address=&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;/&amp;gt; &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;20800&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;demoServiceTarget&amp;#34; class=&amp;#34;org.apache.dubbo.samples.local.impl.DemoServiceImpl&amp;#34;/&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;org.apache.dubbo.samples.local.api.DemoService&amp;#34; ref=&amp;#34;demoServiceTarget&amp;#34;/&amp;gt; &amp;lt;dubbo:reference id=&amp;#34;demoService&amp;#34; interface=&amp;#34;org.apache.dubbo.samples.local.api.DemoService&amp;#34;/&amp;gt; 这里同时配置了同一服务 DemoService 的提供者以及消费者。在这种情况下，该应用中的 DemoService 的消费方会优先使用 injvm 协议进行本地调用。上述的例子可以在 dubbo-samples 工程中找到源码：https://github.com/apache/dubbo-samples/blob/master/dubbo-samples-local
细粒度控制本地调用 本地调用是可以显示关闭的，通过这种方式，服务提供者可以做到对远端服务消费者和本地消费者一视同仁。具体做法是通过 scope=&amp;ldquo;remote&amp;rdquo; 来关闭 injvm 协议的暴露，这样，即使是本地调用者，也需要从注册中心上获取服务地址列表，然后才能发起调用，而这个时候的调用过程，与远端的服务消费者的过程是一致的。
&amp;lt;bean id=&amp;#34;target&amp;#34; class=&amp;#34;org.apache.dubbo.samples.local.impl.DemoServiceImpl&amp;#34;/&amp;gt; &amp;lt;!-- 服务提供者指定 scope=&amp;#34;remote&amp;#34; --&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;org.apache.dubbo.samples.local.api.DemoService&amp;#34; ref=&amp;#34;target&amp;#34; scope=&amp;#34;remote&amp;#34;/&amp;gt; &amp;lt;dubbo:reference id=&amp;#34;demoService&amp;#34; interface=&amp;#34;org.</description></item><item><title>使用Apache Skywalking (Incubator) 做分布式跟踪</title><link>https://dubbo.apache.org/zh-cn/blog/2019/08/11/%E4%BD%BF%E7%94%A8apache-skywalking-incubator-%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F%E8%B7%9F%E8%B8%AA/</link><pubDate>Sun, 11 Aug 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/08/11/%E4%BD%BF%E7%94%A8apache-skywalking-incubator-%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F%E8%B7%9F%E8%B8%AA/</guid><description>Apache Skywalking(Incubator)简介 Apache Skywalking(Incubator) 专门为微服务架构和云原生架构系统而设计并且支持分布式链路追踪的APM系统。Apache Skywalking(Incubator)通过加载探针的方式收集应用调用链路信息，并对采集的调用链路信息进行分析，生成应用间关系和服务间关系以及服务指标。Apache Skywalking (Incubating)目前支持多种语言，其中包括Java，.Net Core，Node.js和Go语言。
目前Skywalking已经支持从6个可视化维度剖析分布式系统的运行情况。总览视图是应用和组件的全局视图，其中包括组件和应用数量，应用的告警波动，慢服务列表以及应用吞吐量；拓扑图从应用依赖关系出发，展现整个应用的拓扑关系；应用视图则是从单个应用的角度，展现应用的上下游关系，TopN的服务和服务器，JVM的相关信息以及对应的主机信息。服务视图关注单个服务入口的运行情况以及此服务的上下游依赖关系，依赖度，帮助用户针对单个服务的优化和监控；调用链展现了调用的单次请求经过的所有埋点以及每个埋点的执行时长；告警视图根据配置阈值针对应用、服务器、服务进行实时告警。
Dubbo与Apache Skywalking(Incubator) 编写Dubbo示例程序 Dubbo实例程序已上传到Github仓库中。方便大家下载使用。
API工程 服务接口：
package org.apache.skywalking.demo.interfaces; public interface HelloService { String sayHello(String name); } Dubbo服务提供工程 package org.apache.skywalking.demo.provider; @Service(version = &amp;#34;${demo.service.version}&amp;#34;, application = &amp;#34;${dubbo.application.id}&amp;#34;, protocol = &amp;#34;${dubbo.protocol.id}&amp;#34;, registry = &amp;#34;${dubbo.registry.id}&amp;#34;, timeout = 60000) public class HelloServiceImpl implements HelloService { public String sayHello(String name) { LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(1)); return &amp;#34;Hello, &amp;#34; + name; } } Consumer工程 package org.apache.skywalking.demo.consumer; @RestController public class ConsumerController { private static int COUNT = 0; @Reference(version = &amp;#34;${demo.</description></item><item><title>在 Dubbo 中使用 REST</title><link>https://dubbo.apache.org/zh-cn/blog/2019/07/26/%E5%9C%A8-dubbo-%E4%B8%AD%E4%BD%BF%E7%94%A8-rest/</link><pubDate>Fri, 26 Jul 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/07/26/%E5%9C%A8-dubbo-%E4%B8%AD%E4%BD%BF%E7%94%A8-rest/</guid><description>什么是 REST REST 是 Roy Thomas Fielding 1 在 2000 年他的博士论文 2 “架构风格以及基于网络的软件架构设计” 中提出来的一个概念。REST 是 REpresentational State Transfer 的缩写，翻译过来就是 “表现层状态转化”。REST 就是 Roy 在这篇论文中提出的面向互联网的软件所应当具备的架构风格。
按照 REpresentational State Transfer 的字面意思，可以把应用看成是一个虚拟的状态机，软件提供的不是服务而是一系列的资源，对这些资源的访问通过统一的操作来访问，而返回的结果代表了资源状态的一次跃迁。REST 是一种架构风格，如果一个软件架构符合 REST 风格，就可以称之为 RESTful 架构。这个架构应当具备以下一些设计上的约束：资源具有唯一标示、资源之间有关联关系、使用标准的方式来访问、资源有多种表现形式、无状态交互。
举例来说，一个简单的静态 HTML 页面的网站就很好的符合了 RESTful 架构风格。访问 http://example.com/accounts 返回一个包含所有账号的页面，选取其中一个链接 http://example.com/accounts/1 又会返回包含用户 1 的详细信息。爬虫软件在这种场景下工作的很好，当知道了某个网站的首页地址后，可以自举发现这个网站上所有关联的网页。更重要的是，这种访问形式不依赖网站提供的任何客户端，而是仅仅通过 HTTP 标准的访问方式完成的。可以说，HTML 这种超媒体文档的组织形式就是资源的表现层状态迁移的一种形式。
对于一个提供服务的动态网站来说，可以按照类似的思路将其 RESTful 化：
GET http://example.com/accounts 返回所有账号信息
POST http://example.com/accounts 创建一个新的账号
GET http://example.com/accounts/1 返回账号 1 的信息
DELETE http://example.com/accounts/1 删除账号 1
PUT http://example.com/accounts/1 更新账号 1 信息</description></item><item><title>使用 Dubbo 连接异构微服务体系</title><link>https://dubbo.apache.org/zh-cn/blog/2019/06/22/%E4%BD%BF%E7%94%A8-dubbo-%E8%BF%9E%E6%8E%A5%E5%BC%82%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BD%93%E7%B3%BB/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/06/22/%E4%BD%BF%E7%94%A8-dubbo-%E8%BF%9E%E6%8E%A5%E5%BC%82%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BD%93%E7%B3%BB/</guid><description>从编程开发的角度来说，Dubbo 首先是一款 RPC 服务框架，它最大的优势在于提供了面向接口代理的服务编程模型，对开发者屏蔽了底层的远程通信细节。同时 Dubbo 也是一款服务治理框架，它为分布式部署的微服务提供了服务发现、流量调度等服务治理解决方案。
在这篇文章中，我们将以以上基础能力为背景，尝试突破 Dubbo 体系自身，探索如何利用 Dubbo 对多协议、多服务发现模型的支持，来实现异构微服务体系间的互联互通。在实际业务场景中，这可以用来解决异构技术体系共存场景下的通信问题，帮助公司实现在异构技术体系间作平滑迁移，解决大规模跨区域、多集群部署场景的地址发现及流量调度等问题。
面向接口代理的透明服务开发框架 我们还是从 Dubbo 是一个微服务开发框架 这个大家熟知的概念开始。就像 Spring 是开发 Java 应用的基础框架一样，我们经常会选用 Dubbo 作为开发微服务业的基础框架。 Dubbo 框架的最大优势我认为就在其面向接口的编程模型，使得开发远程服务调用就像开发本地服务一样（以 Java 语言为例）：
服务定义 public interface GreetingsService { String sayHi(String name); } 消费方调用服务 // 和调用本地服务一样，完全透明。 @Reference private GreetingService greetingService; public void doSayHello(String name) { greetingService.sayHi(&amp;#34;Hello world!&amp;#34;); } 下图是 Dubbo 的基本工作原理图，服务提供者与服务消费者之间通过注册中心协调地址，通过约定的协议实现数据交换。
同构/异构微服务体系面临的问题 关于 Dubbo 协议本身及其服务治理相关功能细节并不是本文的重点，我们今天将从一个更高的层次，来看看公司内部构建微服务体系所面的挑战，以及 Dubbo 能为架构选型和迁移等提供哪些解决思路。
一个公司内部的微服务可能都是基于某一个相同的服务框架开发的，比如说 Dubbo，对于这样的架构，我们称之为是同构的微服务体系；而有些公司的微服务可能是使用多个不同的服务框架所建设，我们称之为异构的微服务体系，多个不同技术栈微服务体系的共存在大型组织内还是非常普遍的，造成这种局面可能有很多原因。比如，可能是遗留系统带来的，也可能是公司正在做技术栈迁移，或者就是不同业务部门为了满足各自特殊需求而做的独立选型（这也意味着异构微服务体系的长期共存）。
1. 异构微服务体系共存
我们很容易想到的一个挑战是：不同的体系间通常是使用不同的 RPC 通信协议、部署独立的注册中心集群，面对这种多协议、多注册中心集群的场景，要如何实现相互之间透明的地址发现和透明的 RPC 调用？ 如果我们什么都不做，那么每个微服务体系就只能感知到自己体系内的服务状态，流量也在各自的体系内封闭。而要做到从体系 A 平滑的迁移到体系 B，或者想长期的保持公司内部多个体系的共存，则解决不同体系间的互联互通，实现流量的透明调度将是非常重要的环节。</description></item><item><title>Dubbo可扩展机制源码解析</title><link>https://dubbo.apache.org/zh-cn/blog/2019/05/02/dubbo%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Thu, 02 May 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/05/02/dubbo%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>在Dubbo可扩展机制实战中，我们了解了Dubbo扩展机制的一些概念，初探了Dubbo中LoadBalance的实现，并自己实现了一个LoadBalance。是不是觉得Dubbo的扩展机制很不错呀，接下来，我们就深入Dubbo的源码，一睹庐山真面目。
ExtensionLoader ExtensionLoader 是最核心的类，负责扩展点的加载和生命周期管理。我们就以这个类开始吧。 ExtensionLoader 的方法比较多，比较常用的方法有:
public static &amp;lt;T&amp;gt; ExtensionLoader&amp;lt;T&amp;gt; getExtensionLoader(Class&amp;lt;T&amp;gt; type) public T getExtension(String name) public T getAdaptiveExtension() 比较常见的用法有:
LoadBalance lb = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(loadbalanceName) RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getAdaptiveExtension() 说明：在接下来展示的源码中，我会将无关的代码(比如日志，异常捕获等)去掉，方便大家阅读和理解。
getExtensionLoader方法 这是一个静态工厂方法，入参是一个可扩展的接口，返回一个该接口的ExtensionLoader实体类。通过这个实体类，可以根据name获得具体的扩展，也可以获得一个自适应扩展。 public static &amp;lt;T&amp;gt; ExtensionLoader&amp;lt;T&amp;gt; getExtensionLoader(Class&amp;lt;T&amp;gt; type) { // 扩展点必须是接口 if (!type.isInterface()) { throw new IllegalArgumentException(&amp;#34;Extension type(&amp;#34; + type + &amp;#34;) is not interface!&amp;#34;); } // 必须要有@SPI注解 if (!withExtensionAnnotation(type)) { throw new IllegalArgumentException(&amp;#34;Extension type without @SPI Annotation!&amp;#34;); } // 从缓存中根据接口获取对应的ExtensionLoader // 每个扩展只会被加载一次 ExtensionLoader&amp;lt;T&amp;gt; loader = (ExtensionLoader&amp;lt;T&amp;gt;) EXTENSION_LOADERS.</description></item><item><title>Dubbo 一致性Hash负载均衡实现剖析</title><link>https://dubbo.apache.org/zh-cn/blog/2019/05/01/dubbo-%E4%B8%80%E8%87%B4%E6%80%A7hash%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0%E5%89%96%E6%9E%90/</link><pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/05/01/dubbo-%E4%B8%80%E8%87%B4%E6%80%A7hash%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0%E5%89%96%E6%9E%90/</guid><description>需要强调的是，Dubbo的Hash映射模型与大部分网上资料描述的环形队列Hash映射模型是存在一些区别的。于我而言，环形队列Hash映射模型，不足以让我对一致性Hash有足够彻底的了解。直到看懂了Dubbo的一致性Hash的实现，才觉得豁然开朗。
一、环形队列Hash映射模型 这种方案，其基础还是基于取模运算。对2^32取模，那么，Hash值的区间为[0, 2^32-1]。接下来要做的，就包括两部分：
a、映射服务 将服务地址（ip+端口）按照一定规则构造出特定的识别码（如md5码），再用识别码对2^32取模，确定服务在Hash值区间对应的位置。假设有Node1、Node2、Node3三个服务，其映射关系如下：
b、映射请求、定位服务 在发起请求时，我们往往会带上参数，而这些参数，就可以被我们用来确定具体调用哪一个服务。假设有请求R1、R2、R3，对它们的参数也经过计算特定识别码、取余的一系列运算之后，有如下映射关系：
从图中，我们可以看到，R1请求映射在0-Node1中间，R2请求映射在Node1-Node2中间，R3请求映射在Node2-Node3中间。我们取服务Hash值大于等于请求Hash值的第一个服务作为实际的调用服务。也就是说，R1请求将调用Node1服务，R2请求将调用Node2服务，R3请求将调用Node3服务。
c、新增服务节点 假设新增服务Node4，映射在Node3之前，恰巧破坏了原来的一个映射关系：
这样，请求R3将会实际调用服务Node4，但请求R1、R2不受影响。
d、删除服务节点 假设服务Node2宕机，那么R2请求将会映射到Node3：
原本的R1、R3请求不受影响。
可以看出，当新增、删除服务时，受影响的请求是有限的。不至于像简单取模映射一般，服务发生变化时，需要调整全局的映射关系。
e、平衡性与虚拟节点 在我们上面的假设中，我们假设Node1、Node2、Node3三个服务在经过Hash映射后所分布的位置恰巧把环切成了均等的三分，请求的分布也基本是平衡的。但是实际上计算服务Hash值的时候，是很难这么巧的。也许一不小心就映射成了这个样子：
这样，就会导致大部分请求都会被映射到Node1上。因此，引出了虚拟节点。
所谓虚拟节点，就是除了对服务本身地址进行Hash映射外，还通过在它地址上做些处理（比如Dubbo中，在ip+port的字符串后加上计数符1、2、3&amp;hellip;&amp;hellip;，分别代表虚拟节点1、2、3），以达到同一服务映射多个节点的目的。通过引入虚拟节点，我们可以把上图中映射给Node1的请求进一步拆分：
如上图所示，若有请求落在Node3-Node1&amp;rsquo;区间，该请求应该是调用Node1&amp;rsquo;服务，但是因为Node1&amp;rsquo;是Node1的虚拟节点，所以实际调用的是Node1服务。通过引入虚拟节点，请求的分布就会比较平衡了。
二、Dubbo一致性Hash的使用与负载均衡策略的引入阶段 a、如何使用一致性Hash作为Dubbo的负载均衡策略？ dubbo:service、dubbo:reference、dubbo:provider、dubbo:consumer、dubbo:method这几个配置项都可以配置Dubbo的负载均衡策略，其中一致性Hash的属性值是：consistenthash。
以dubbo:reference为例：
XML配置：
&amp;lt;dubbo:reference loadbalance=&amp;ldquo;consistenthash&amp;rdquo; /&amp;gt;
Properties配置：
dubbo.reference.loadbalance=consistenthash
注解：
@Reference(loadbalance = &amp;ldquo;consistenthash&amp;rdquo;)
b、Dubbo负载均衡策略的引入阶段 Dubbo实现的是客户端负载均衡。关于服务接口代理类的实现，这里不做详细描述，可以参考官网：
服务引入：/zh-cn/docs/source_code_guide/refer-service.html
在接口代理类生成、并且装配好后，服务的调用基本是这样一个流程：proxy -&amp;gt; MockClusterInvoker -&amp;gt; 集群策略（如：FailoverClusterInvoker） -&amp;gt; 初始化负载均衡策略 -&amp;gt; 根据选定的负载均衡策略确定Invoker。
负载均衡策略的初始化是在AbstractClusterInvoker中的initLoadBalance方法中初始化的：
protected LoadBalance initLoadBalance(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, Invocation invocation) { if (CollectionUtils.isNotEmpty(invokers)) { return ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(0).getUrl() .getMethodParameter(RpcUtils.getMethodName(invocation), LOADBALANCE_KEY, DEFAULT_LOADBALANCE)); } else { return ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(DEFAULT_LOADBALANCE); } } 这部分代码逻辑分为两部分：</description></item><item><title>Dubbo可扩展机制实战</title><link>https://dubbo.apache.org/zh-cn/blog/2019/04/25/dubbo%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E5%AE%9E%E6%88%98/</link><pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/04/25/dubbo%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E5%AE%9E%E6%88%98/</guid><description>1. Dubbo的扩展机制 在Dubbo的官网上，Dubbo描述自己是一个高性能的RPC框架。今天我想聊聊Dubbo的另一个很棒的特性, 就是它的可扩展性。 如同罗马不是一天建成的，任何系统都一定是从小系统不断发展成为大系统的，想要从一开始就把系统设计的足够完善是不可能的，相反的，我们应该关注当下的需求，然后再不断地对系统进行迭代。在代码层面，要求我们适当的对关注点进行抽象和隔离，在软件不断添加功能和特性时，依然能保持良好的结构和可维护性，同时允许第三方开发者对其功能进行扩展。在某些时候，软件设计者对扩展性的追求甚至超过了性能。
在谈到软件设计时，可扩展性一直被谈起，那到底什么才是可扩展性，什么样的框架才算有良好的可扩展性呢？它必须要做到以下两点:
作为框架的维护者，在添加一个新功能时，只需要添加一些新代码，而不用大量的修改现有的代码，即符合开闭原则。 作为框架的使用者，在添加一个新功能时，不需要去修改框架的源码，在自己的工程中添加代码即可。 Dubbo很好的做到了上面两点。这要得益于Dubbo的微内核+插件的机制。接下来的章节中我们会慢慢揭开Dubbo扩展机制的神秘面纱。
2. 可扩展的几种解决方案 通常可扩展的实现有下面几种:
Factory模式 IoC容器 OSGI容器 Dubbo作为一个框架，不希望强依赖其他的IoC容器，比如Spring，Guice。OSGI也是一个很重的实现，不适合Dubbo。最终Dubbo的实现参考了Java原生的SPI机制，但对其进行了一些扩展，以满足Dubbo的需求。
3. Java SPI机制 既然Dubbo的扩展机制是基于Java原生的SPI机制，那么我们就先来了解下Java SPI吧。了解了Java的SPI，也就是对Dubbo的扩展机制有一个基本的了解。如果对Java SPI比较了解的同学，可以跳过。
Java SPI(Service Provider Interface)是JDK内置的一种动态加载扩展点的实现。在ClassPath的META-INF/services目录下放置一个与接口同名的文本文件，文件的内容为接口的实现类，多个实现类用换行符分隔。JDK中使用java.util.ServiceLoader来加载具体的实现。 让我们通过一个简单的例子，来看看Java SPI是如何工作的。
定义一个接口IRepository用于实现数据储存 public interface IRepository { void save(String data); } 提供IRepository的实现 IRepository有两个实现。MysqlRepository和MongoRepository。 public class MysqlRepository implements IRepository { public void save(String data) { System.out.println(&amp;#34;Save &amp;#34; + data + &amp;#34; to Mysql&amp;#34;); } } public class MongoRepository implements IRepository { public void save(String data) { System.</description></item><item><title>提前if判断帮助CPU分支预测</title><link>https://dubbo.apache.org/zh-cn/blog/2019/02/03/%E6%8F%90%E5%89%8Dif%E5%88%A4%E6%96%AD%E5%B8%AE%E5%8A%A9cpu%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/</link><pubDate>Sun, 03 Feb 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/02/03/%E6%8F%90%E5%89%8Dif%E5%88%A4%E6%96%AD%E5%B8%AE%E5%8A%A9cpu%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/</guid><description>分支预测 在stackoverflow上有一个非常有名的问题：为什么处理有序数组要比非有序数组快？，可见分支预测对代码运行效率有非常大的影响。
现代CPU都支持分支预测(branch prediction)和指令流水线(instruction pipeline)，这两个结合可以极大提高CPU效率。对于像简单的if跳转，CPU是可以比较好地做分支预测的。但是对于switch跳转，CPU则没有太多的办法。switch本质上是据索引，从地址数组里取地址再跳转。
要提高代码执行效率，一个重要的原则就是尽量避免CPU把流水线清空，那么提高分支预测的成功率就非常重要。
那么对于代码里，如果某个switch分支概率很高，是否可以考虑代码层面帮CPU把判断提前，来提高代码执行效率呢？
Dubbo里ChannelEventRunnable的switch判断 在ChannelEventRunnable里有一个switch来判断channel state，然后做对应的逻辑：查看
一个channel建立起来之后，超过99.9%情况它的state都是ChannelState.RECEIVED，那么可以考虑把这个判断提前。
benchmark验证 下面通过jmh来验证下：
public class TestBenchMarks { public enum ChannelState { CONNECTED, DISCONNECTED, SENT, RECEIVED, CAUGHT } @State(Scope.Benchmark) public static class ExecutionPlan { @Param({ &amp;#34;1000000&amp;#34; }) public int size; public ChannelState[] states = null; @Setup public void setUp() { ChannelState[] values = ChannelState.values(); states = new ChannelState[size]; Random random = new Random(new Date().getTime()); for (int i = 0; i &amp;lt; size; i++) { int nextInt = random.</description></item><item><title>当Dubbo遇上Arthas：排查问题的实践</title><link>https://dubbo.apache.org/zh-cn/blog/2019/02/02/%E5%BD%93dubbo%E9%81%87%E4%B8%8Aarthas%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E8%B7%B5/</link><pubDate>Sat, 02 Feb 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/02/02/%E5%BD%93dubbo%E9%81%87%E4%B8%8Aarthas%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E8%B7%B5/</guid><description>Apache Dubbo是Alibaba开源的高性能RPC框架，在国内有非常多的用户。
Github: https://github.com/apache/dubbo 文档：http://dubbo.apache.org/zh-cn/ Arthas是Alibaba开源的应用诊断利器，9月份开源以来，Github Star数三个月超过6000。
Github: https://github.com/alibaba/arthas 文档：https://arthas.aliyun.com/doc/ Arthas开源交流QQ群: 916328269 Arthas开源交流钉钉群: 21965291 当Dubbo遇上Arthas，会碰撞出什么样的火花呢？下面来分享Arthas排查Dubbo问题的一些经验。
dubbo-arthas-demo 下面的排查分享基于这个dubbo-arthas-demo，非常简单的一个应用，浏览器请求从Spring MVC到Dubbo Client，再发送到Dubbo Server。
Demo里有两个spring boot应用，可以先启动server-demo，再启动client-demo。
https://github.com/hengyunabc/dubbo-arthas-demo /user/{id} -&amp;gt; UserService -&amp;gt; UserServiceImpl Browser Dubbo Client Dubbo Server Client端：
@RestController public class UserController { @Reference(version = &amp;#34;1.0.0&amp;#34;) private UserService userService; @GetMapping(&amp;#34;/user/{id}&amp;#34;) public User findUserById(@PathVariable Integer id) { return userService.findUser(id); } Server端：
@Service(version = &amp;#34;1.0.0&amp;#34;) public class UserServiceImpl implements UserService { @Override public User findUser(int id) { if (id &amp;lt; 1) { throw new IllegalArgumentException(&amp;#34;user id &amp;lt; 1, id: &amp;#34; + id); } for (User user : users) { if (user.</description></item><item><title>遇见Dubbo</title><link>https://dubbo.apache.org/zh-cn/blog/2019/01/26/%E9%81%87%E8%A7%81dubbo/</link><pubDate>Sat, 26 Jan 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/01/26/%E9%81%87%E8%A7%81dubbo/</guid><description>我是一个有Dubbo情节的程序员。
Dubbo以不同方式，陪伴了我时间不长的整个代码生涯。不久前，通过社区投票，我被选举为Committer。当时我在朋友圈发了一句话，也是贯穿我从开始使用Dubbo、研究Dubbo、贡献Dubbo到最后成为Committer的全过程，一直为我提供内心无与伦比愉悦的源泉：成长这种事，能看见脚印特别幸福。
今天来个回忆杀，把我和Dubbo的那些事拿出来说说。
小白 我知道Dubbo，是在我大三翘课出去实习的时候，那个时候是无知的，我眼里最牛的人就是能熟练使用各种配置，精通SSH框架的人。就是在那种情况下，我外出实习，遇到了一群影响我至今的人。当时也是机缘巧合，我们进行了两个非常小的模块的服务化改造。那时的团队除了我们老大，全是一群新兵蛋子，老大指哪我们打哪。老大说，就用Dubbo吧，从那时候开始，我才知道，哦！原来还有一种东西叫做RPC，还有个阿里巴巴的RPC框架叫Dubbo。
苦于当时非常有限的水平和高强度的工作，我和Dubbo的缘分也就停留在一面之缘的程度——要说认识谈不上，说不认识也牵强。
Contributor 我在二维火任职的一年算是我Dubbo生涯里承上启下的一年。二维火当时自己维护了一个Dubbo的分支，有一群对Dubbo非常了解的人。那时候，工作结束搞Dubbo，周六加班研究Dubbo。看源码，看不懂就debug一下，debug也不明白就问，问人，问google，里外折腾了个遍。
后来毕业加入网易云音乐。大概是今年五月份的时候，我发现了一个Dubbo的小bug，并且给Dubbo提交了pull request。在第一次被merge之后，非常受鼓舞，这才有了后续的故事。后来，回看这第一次提交，真的算是我和Dubbo的一个拐点，拐弯之后，我才逐渐走上一条成为Committer的路。
可能很多人看到这里要望而却步了，这也是做开源给很多人留下的固有的印象——是不是没发现BUG就不能提交pull request，不能做贡献？其实完全不是的，这里给大家敲黑板划重点：其实很多贡献者的第一次贡献，贡献的并非代码，而是文档修改或者单元测试。相比于BUG或者新的Feature，单测和文档上的修复门槛就比较低了。
我自己的方法论就是：先尝试增加单元测试，写单测的时候顺手debug+看代码。或者多看文档，了解框架的同时，发现错别字、语意不明或者文档上的链接干脆点不开的情况，直接提交PR到对应的仓库。
万事开头难。第一次被merge代码，你就可以成为一个Contributor了。Contributor很多，但是Committer很少，下面继续说怎么从一个Contributor成长为独当一面的Committer。
Committer 做开源和写代码一样，都不是一朝一夕的事情，而是量变促成质变的过程。这是一个没捷径可走的过程，欲带皇冠必承其重。身后的Dubbo功底自不必多说，这个部分主要是想跟大家说一下除了钻研和热爱之外，其他需要注意的地方。
首先是多提交高质量PR。任何一个PR都会被review，代码中的问题，思路上的偏差，都会被指正。提交PR是一个反复琢磨的过程。PR的质量不能简单的归结于新增了多少行代码，高质量的PR一定是经过缜密思考的，为什么删除代码，新增的代码有什么意义，修改之后有什么效果等等。希望大家更加重视质量而非数量，眼光放长远，相信你的收获一定会非常大！
第二个就是，我们需要培养一种思维方式——Apache Way。一句话概括就是社区重于代码。Apache是一个注重社区的的开源组织，其行为方式相比于目前我们的开发方式，还是有所不同，这里我举一个Apache Way的例子，用以说明传统方式相较于Apache Way的区别在哪里，这里假设我想为Dubbo开发一个功能A。
Old Way：
功能设计：做一个设计文档（根据功能大小而定），大概划定需要修改或新增的类，大体设计接口等。 开发代码。 提交PR。 Review &amp;amp; Merge 可以看到，我们整个过程中，真正与社区交互的只有最后一步。
Apache Way：
功能设计：发送邮件至mailing list并且提交ISSUE，与社区成员共同探讨，产出一个设计文档（根据功能大小而定），大概划定需要修改或新增的类，大体设计接口等。然后再次发送邮件并且回复ISSUE，通知社区设计文档定稿或者方案确定。 开发代码：发送邮件至社区，通知社区成员我即将投入开发功能A，如需帮助，可以同时说明需要协助。 提交PR：发送邮件并且回复ISSUE，提醒社区开发结束，贴上PR地址以通知社区review代码。 Review + Merge后，发送邮件并且关闭ISSUE，通知社区功能A的开发功能告一段落。 可以看到，Apache Way就是在整个开发过程中，不断地与社区交互，最大发挥社区的功能，汲取众人之力，这才是所谓社区以及所谓开源的含义。
结尾 Dubbo目前还在孵化阶段，整个Dubbo社区还不完善，我们也在跟着Dubbo一起成长，我们非常希望更多的Dubbo爱好者深度参与到Dubbo中，为你的代码生涯树一个里程碑。
相信过程，收获结果；天道酬勤，功不唐捐！</description></item><item><title>如何使用Seata保证Dubbo微服务间的一致性</title><link>https://dubbo.apache.org/zh-cn/blog/2019/01/17/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8seata%E4%BF%9D%E8%AF%81dubbo%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%B4%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</link><pubDate>Thu, 17 Jan 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/01/17/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8seata%E4%BF%9D%E8%AF%81dubbo%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%B4%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</guid><description>案例 用户采购商品业务，整个业务包含3个微服务:
库存服务: 扣减给定商品的库存数量。 订单服务: 根据采购请求生成订单。 账户服务: 用户账户金额扣减。 业务结构图 StorageService public interface StorageService { /** * 扣除存储数量 */ void deduct(String commodityCode, int count); } OrderService public interface OrderService { /** * 创建订单 */ Order create(String userId, String commodityCode, int orderCount); } AccountService public interface AccountService { /** * 从用户账户中借出 */ void debit(String userId, int money); } 主要的业务逻辑： public class BusinessServiceImpl implements BusinessService { private StorageService storageService; private OrderService orderService; /** * 采购 */ public void purchase(String userId, String commodityCode, int orderCount) { storageService.</description></item><item><title>浅谈 RPC</title><link>https://dubbo.apache.org/zh-cn/blog/2019/01/07/%E6%B5%85%E8%B0%88-rpc/</link><pubDate>Mon, 07 Jan 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/01/07/%E6%B5%85%E8%B0%88-rpc/</guid><description>近几年随着微服务化项目的崛起，逐渐成为许多公司中大型分布式系统架构的主流方式，而今天所说的 RPC 在这其中扮演着至关重要的角色。随着这段日子公司项目微服务化的演进，发现在日常开发中都在隐式或显式的使用 RPC，一些刚刚接触 RPC 的小伙伴会感觉无所适从，而一些入行多年的老手虽然使用 RPC 经验丰富，但有些对其原理也一知半解，缺乏对原理的深入理解，往往也会造成开发中的一些误用。
什么是RPC？ RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。
RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。现在业界有很多开源的优秀 RPC 框架，例如 Spring Cloud、Dubbo、Thrift 等。
RPC 起源 RPC 这个概念术语在上世纪 80 年代由 Bruce Jay Nelson 提出。这里我们追溯下当初开发 RPC 的原动机是什么？在 Nelson 的论文 &amp;ldquo;Implementing Remote Procedure Calls&amp;rdquo; 中他提到了几点：
简单：RPC 概念的语义十分清晰和简单，这样建立分布式计算就更容易。 高效：过程调用看起来十分简单而且高效。 通用：在单机计算中过程往往是不同算法部分间最重要的通信机制。 通俗一点说，就是一般程序员对于本地的过程调用很熟悉，那么我们把 RPC 作成和本地调用完全类似，那么就更容易被接受，使用起来毫无障碍。Nelson 的论文发表于 30 年前，其观点今天看来确实高瞻远瞩，今天我们使用的 RPC 框架基本就是按这个目标来实现的。
RPC 结构 Nelson 的论文中指出实现 RPC 的程序包括 5 个部分：
User User-stub RPCRuntime Server-stub Server 这里 user 就是 client 端，当 user 想发起一个远程调用时，它实际是通过本地调用 user-stub。user-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 RPCRuntime 实例传输到远端的实例。远端 RPCRuntime 实例收到请求后交给 server-stub 进行解码后发起本地端调用，调用结果再返回给 user 端。</description></item><item><title>新版 Dubbo Admin 介绍</title><link>https://dubbo.apache.org/zh-cn/blog/2019/01/07/%E6%96%B0%E7%89%88-dubbo-admin-%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 07 Jan 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/01/07/%E6%96%B0%E7%89%88-dubbo-admin-%E4%BB%8B%E7%BB%8D/</guid><description>github: https://github.com/apache/dubbo-ops Dubbo Admin之前的版本过于老旧，也长期疏于维护，因此在去年年中的时候，对该项目进行了一次重构，项目结构上的变化如下：
将后端框架从webx替换成spring boot 前端采用Vue和Vuetify.js作为开发框架 移除velocity模板 集成swagger，提供api管理功能 当前版本的Dubbo Admin包含了之前版本中的绝大部分功能，包括服务治理，服务查询等，同时支持了Dubbo2.7中服务治理的新特性。
配置规范 由于在Dubbo2.7中，配置中心和注册中心做了分离，并且增加了元数据中心，因此Dubbo Admin的配置方式也做了更新，application.properties中的配置如下:
admin.registry.address=zookeeper://127.0.0.1:2181 admin.config-center=zookeeper://127.0.0.1:2181 admin.metadata-report.address=zookeeper://127.0.0.1:2181 也可以和Dubbo2.7一样，在配置中心指定元数据和注册中心的地址，以zookeeper为例，配置的路径和内容如下:
# /dubbo/config/dubbo/dubbo.properties dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 配置中心里的地址会覆盖掉本地application.properties的配置
功能介绍 功能上，主要延续了之前版本的功能，包括服务查询和服务治理，2.7版本在服务治理的功能上有了很大的改进，这些改进也大部分都会以Dubbo Admin作为入口来体现。
标签路由 标签路由是Dubbo2.7引入的新功能，配置以应用作为维度，给不同的服务器打上不同名字的标签，配置如下图所示：
调用的时候，客户端可以通过setAttachment的方式，来设置不同的标签名称，比如本例中，setAttachment(tag1)，客户端的选址范围就在如图所示的三台机器中，可以通过这种方式来实现流量隔离，灰度发布等功能。
应用级别的服务治理 在Dubbo2.6及更早版本中，所有的服务治理规则都只针对服务粒度，如果要把某条规则作用到应用粒度上，需要为应用下的所有服务配合相同的规则，变更，删除的时候也需要对应的操作，这样的操作很不友好，因此Dubbo2.7版本中增加了应用粒度的服务治理操作，对于条件路由(包括黑白名单)，动态配置(包括权重，负载均衡)都可以做应用级别的配置：
上图是条件路由的配置，可以按照应用名，服务名两个维度来填写，也可以按照这两个维度来查询。
条件路由，标签路由和动态配置都采用了yaml格式的文本编写，其他的规则配置还是采用了表单的形式。
关于兼容性 Dubbo2.6到Dubbo2.7，服务治理发生了比较大的变化，Dubbo Admin兼容两个版本的用法：
对于服务级别的配置，会按照Dubbo2.6(URL)和Dubbo2.7(配置文件)两种格式进行写入，保证Dubbo2.6的客户端能够正确读取，解析规则 对于应用级别的配置，包括标签路由，只会按照Dubbo2.7的格式进行写入，因为Dubbo2.6无此功能，不需要做向前兼容。 Dubbo Admin只会按照Dubbo2.7的格式进行配置读取，因此，所有在Dubbo Admin上做的配置都可以被读到，但是之前遗留的，Dubbo2.6格式的URL无法被读取。 对于同一个应用或者服务，每种规则只能够配置一条，否则新的会覆盖旧的。 配置管理 配置管理也是配合Dubbo2.7新增的功能，在Dubbo2.7中，增加了全局和应用维度的配置，
全局配置： 全局配置里可以指定注册中心，元数据中心的地址，服务端和客户端的超时时间等，这些配置在全局内生效。除了配置写入，也可以用来查看。如果使用zookeeper作为注册中心和元数据中心，还可以看到配置文件所在位置的目录结构。
应用， 服务配置 应用级别的配置可以为应用或者应用内的服务指定配置，在服务维度上，需要区分提供者和消费者。dubbo.reference.{serviceName}表示作为该服务消费者的配置，dubbo.provider.{servcieName}表示作为该服务提供者的配置。优先级服务 &amp;gt; 应用 &amp;gt; 全局。其中注册中心和元数据中心的地址，只能在全局配置中指定，这也是Dubbo2.7中推荐的使用方式。
元数据和服务测试 元数据是Dubbo2.7中新引入的元素，主要的使用场景就在Dubbo Admin中，主要体现在两个地方：
服务详情展示： 跟之前版本相比，Dubbo2.7中增加了对服务方法完整签名的记录，因此服务详情中也增加了方法信息的详情，可以看到方法名，方法参数列表以及返回值信息。
服务测试： 更重要的，元数据为服务测试提供了数据基础，可以在页面上调用真实的服务提供者，方便测试，也不需要为了调用服务去搭建一套Dubbo环境以及编写消费端代码。</description></item><item><title>Dubbo 在瓜子二手车的实践</title><link>https://dubbo.apache.org/zh-cn/blog/2019/01/05/dubbo-%E5%9C%A8%E7%93%9C%E5%AD%90%E4%BA%8C%E6%89%8B%E8%BD%A6%E7%9A%84%E5%AE%9E%E8%B7%B5/</link><pubDate>Sat, 05 Jan 2019 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2019/01/05/dubbo-%E5%9C%A8%E7%93%9C%E5%AD%90%E4%BA%8C%E6%89%8B%E8%BD%A6%E7%9A%84%E5%AE%9E%E8%B7%B5/</guid><description>前言 随着瓜子业务的不断发展，系统规模在逐渐扩大，目前在瓜子的私有云上已经运行着数百个dubbo应用，上千个dubbo实例。瓜子各部门业务迅速发展，版本没有来得及统一，各个部门都有自己的用法。随着第二机房的建设，dubbo版本统一的需求变得越发迫切。几个月前，公司发生了一次与dubbo相关的生产事故，成为了公司dubbo版本升级的诱因。
接下来，我会从这次事故开始，讲讲我们这段时间所做的dubbo版本升级的历程以及dubbo后续多机房的方案。
一、Ephermal节点未及时删除导致provider不能恢复注册的问题修复 事故背景 在生产环境，瓜子内部各业务线共用一套zookeeper集群作为dubbo的注册中心。2019年9月份，机房的一台交换机发生故障，导致zookeeper集群出现了几分钟的网络波动。在zookeeper集群恢复后，正常情况下dubbo的provider应该会很快重新注册到zookeeper上，但有一小部分的provider很长一段时间没有重新注册到zookeeper上，直到手动重启应用后才恢复注册。
排查过程 首先，我们统计了出现这种现象的dubbo服务的版本分布情况，发现在大多数的dubbo版本中都存在这种问题，且发生问题的服务比例相对较低，在github中我们也未找到相关问题的issues。因此，推断这是一个尚未修复的且在网络波动情况的场景下偶现的问题。
接着，我们便将出现问题的应用日志、zookeeper日志与dubbo代码逻辑进行相互印证。在应用日志中，应用重连zookeeper成功后provider立刻进行了重新注册，之后便没有任何日志打印。而在zookeeper日志中，注册节点被删除后，并没有重新创建注册节点。对应到dubbo的代码中，只有在FailbackRegistry.register(url)的doRegister(url)执行成功或线程被挂起的情况下，才能与日志中的情况相吻合。
public void register(URL url) { super.register(url); failedRegistered.remove(url); failedUnregistered.remove(url); try { // Sending a registration request to the server side doRegister(url); } catch (Exception e) { Throwable t = e; // If the startup detection is opened, the Exception is thrown directly. boolean check = getUrl().getParameter(Constants.CHECK_KEY, true) &amp;amp;&amp;amp; url.getParameter(Constants.CHECK_KEY, true) &amp;amp;&amp;amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol()); boolean skipFailback = t instanceof SkipFailbackWrapperException; if (check || skipFailback) { if (skipFailback) { t = t.</description></item><item><title>第五届Dubbo开发者沙龙在杭州成功举办</title><link>https://dubbo.apache.org/zh-cn/blog/2018/12/10/%E7%AC%AC%E4%BA%94%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E6%9D%AD%E5%B7%9E%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/</link><pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/12/10/%E7%AC%AC%E4%BA%94%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E6%9D%AD%E5%B7%9E%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/</guid><description>第五届Dubbo开发者沙龙在杭州成功举办，
分享嘉宾
李鼎: 如何参与Dubbo开源社区 slides 曹胜利: Dubbo 2.7新特性介绍及演示 slides 陶杨: Dubbo在考拉的应用实践 slides 小马哥: Dubbo+Nacos服务治理重新实现 slides 赵奕豪: Sentinel:分布式服务的流量防卫兵 slides 陈志轩: 当Dubbo遇上Arthas:排查问题的实践 slides</description></item><item><title>Dubbo 融合 Nacos 成为注册中心</title><link>https://dubbo.apache.org/zh-cn/blog/2018/11/07/dubbo-%E8%9E%8D%E5%90%88-nacos-%E6%88%90%E4%B8%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</link><pubDate>Wed, 07 Nov 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/11/07/dubbo-%E8%9E%8D%E5%90%88-nacos-%E6%88%90%E4%B8%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</guid><description>Nacos 作为 Dubbo 生态系统中重要的注册中心实现，其中 dubbo-registry-nacos 则是 Dubbo 融合 Nacos 注册中心的实现。
预备工作 当您将 dubbo-registry-nacos 整合到您的 Dubbo 工程之前，请确保后台已经启动 Nacos 服务。如果您尚且不熟悉 Nacos 的基本使用的话，可先行参考 Nacos 快速入门：https://nacos.io/en-us/docs/quick-start.html。建议使用 Nacos 0.6.1 以上的版本。
快速上手 Dubbo 融合 Nacos 成为注册中心的操作步骤非常简单，大致步骤可分为“增加 Maven 依赖”以及“配置注册中心“。
增加 Maven 依赖 首先，您需要 dubbo-registry-nacos 的 Maven 依赖添加到您的项目中 pom.xml 文件中，并且强烈地推荐您使用 Dubbo 2.6.5：
&amp;lt;dependencies&amp;gt; ... &amp;lt;!-- Dubbo Nacos registry dependency --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-registry-nacos&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.0.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- Keep latest Nacos client version --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.nacos&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;nacos-client&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;[0.6.1,)&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- Dubbo dependency --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.</description></item><item><title>Dubbo服务分组和版本聚合</title><link>https://dubbo.apache.org/zh-cn/blog/2018/10/27/dubbo%E6%9C%8D%E5%8A%A1%E5%88%86%E7%BB%84%E5%92%8C%E7%89%88%E6%9C%AC%E8%81%9A%E5%90%88/</link><pubDate>Sat, 27 Oct 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/10/27/dubbo%E6%9C%8D%E5%8A%A1%E5%88%86%E7%BB%84%E5%92%8C%E7%89%88%E6%9C%AC%E8%81%9A%E5%90%88/</guid><description>我们在调用Dubbo服务的时候，一般只需要将Consumer端的dubbo:reference指定成服务端中dubbo:service暴露的服务，就可以找到服务端，完成调用，也就是说，Dubbo只需要服务接口信息就可以找到服务提供者。 其实除了服务提供者以外，Dubbo也有服务分组和版本的概念，在客户端去寻找“匹配”的服务端的时候，需要服务接口，版本号，组别这三个信息都匹配，才算是一个有效的服务端：
public static boolean isMatch(URL consumerUrl, URL providerUrl) { String consumerInterface = consumerUrl.getServiceInterface(); String providerInterface = providerUrl.getServiceInterface(); if (!(Constants.ANY_VALUE.equals(consumerInterface) || StringUtils.isEquals(consumerInterface, providerInterface))) return false; if (!isMatchCategory(providerUrl.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY), consumerUrl.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY))) { return false; } if (!providerUrl.getParameter(Constants.ENABLED_KEY, true) &amp;amp;&amp;amp; !Constants.ANY_VALUE.equals(consumerUrl.getParameter(Constants.ENABLED_KEY))) { return false; } String consumerGroup = consumerUrl.getParameter(Constants.GROUP_KEY); String consumerVersion = consumerUrl.getParameter(Constants.VERSION_KEY); String consumerClassifier = consumerUrl.getParameter(Constants.CLASSIFIER_KEY, Constants.ANY_VALUE); String providerGroup = providerUrl.getParameter(Constants.GROUP_KEY); String providerVersion = providerUrl.getParameter(Constants.VERSION_KEY); String providerClassifier = providerUrl.getParameter(Constants.CLASSIFIER_KEY, Constants.ANY_VALUE); return (Constants.</description></item><item><title>Dubbo 协议详解</title><link>https://dubbo.apache.org/zh-cn/blog/2018/10/05/dubbo-%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Fri, 05 Oct 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/10/05/dubbo-%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</guid><description>协议的概念 协议是两个网络实体进行通信的基础，数据在网络上从一个实体传输到另一个实体，以字节流的形式传递到对端。在这个字节流的世界里，如果没有协议，就无法将这个一维的字节流重塑成为二维或者多维的数据结构以及领域对象。
协议是什么 协议是双方确定的交流语义，比如：我们设计一个字符串传输的协议，它允许客户端发送一个字符串，服务端接收到对应的字符串。这个协议很简单，首先发送一个4字节的消息总长度，然后再发送1字节的字符集charset长度，接下来就是消息的payload，字符集名称和字符串正文。
发送一个iso-8859-1的字符串abc到对端。经过协议编码，内容是：18 = 4 + 1 + 10 + 3|10|iso-8859-1|abc，当这些字节流发往服务端后，当服务端收到字节流后，首先读取4个字节，将其转换为int，在这个例子中是18，接下来继续读14个字节，将首个字节得到字符集名称长度10，将后续内容的前10字节转换为字符串，内容是iso-8859-1，使用该字符集将后续的字节数组造型成为字符串new String(bytes, &amp;quot;iso-8859-1&amp;quot;)。
在前面自定义字符串传输协议的例子中，我们已经看到协议在双方传输数据中起到的作用，没有协议就无法完成数据交换，下面是维基百科对于通信协议的定义。
In telecommunication, a communication protocol is a system of rules that allow two or more entities of a communications system to transmit information via any kind of variation of a physical quantity. The protocol defines the rules syntax, semantics and synchronization of communication and possible error recovery methods. Protocols may be implemented by hardware, software, or a combination of both.</description></item><item><title>Dubbo与Kubernetes集成</title><link>https://dubbo.apache.org/zh-cn/blog/2018/09/30/dubbo%E4%B8%8Ekubernetes%E9%9B%86%E6%88%90/</link><pubDate>Sun, 30 Sep 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/09/30/dubbo%E4%B8%8Ekubernetes%E9%9B%86%E6%88%90/</guid><description>大体目标 Dubbo的provider不再关心服务注册的事宜，只需要把其Dubbo服务端口打开，由Kubernetes来进行服务的声明和发布；Dubbo的consumer在服务发现时直接发现kubernetes的对应服务endpoints，从而复用Dubbo已有的微服务通道能力。好处是无需依赖三方的软负载注册中心；同时无缝融入Kubernetes的多租户安全体系。Demo的代码参照： https://github.com/dubbo/dubbo-kubernetes
闲谈 Kubernates是建立在扩展性的具备二次开发的功能层次丰富的体系化系统
首先其最核心的功能是管理容器集群，能管理容器化的集群（包括存储，计算），当然这个是建立在对容器运行时(CRI)，网络接口(CNI),存储服务接口（CSI/FV）的基础上； 其次是面向应用(包括无状态/有状态,批处理/服务型应用)的部署和路由能力，特别是基于微服务架构的应用管理，具备了其服务定义和服务发现，以及基于configmap的统一配置能力； 在基础资源（主要是抽象底层IaaS的资源）和应用层的抽象模型之上是治理层，包含弹性扩容，命名空间/租户，等。当然，基于其原子内核的基础能力，在Kubernetes的核心之上搭建统一的日志中心和全方位监控等服务是水到渠成的，CNCF更是有其认定推荐。 来张Kubernetes Architecture的一张图解释下上述描述。在2018年Kubernetes往事实的paas底座的标配迈出质的一步，有人说原因在于基于扩展的二次开发能力，有人说在于其声明式编程和背靠Google和Redhat的强大社区运作，我觉得回归本质是在于下图中的Layered架构和其问题域的领域建模抽象。
以微服务架构视角，Kubernetes在一定意义上是微服务框架（这时较叫微服务平台或toolkit集更合适），支持微服务的服务发现/注册的基本能力。借用如下图做一个简单描述。
话题再展开一下，微服务领域涉及众多问题，大概可以用下图说明。
Kubernetes解决得只是少部分，而像动态路由，稳定性控制（断路器，隔水舱等），分布式服务追踪等是个空白，这也就是servicemesh要解决的，是在CNCF的Trail Map占有重要一席；当然Dubbo是基本具备完备的微服务，也就是使得其集成到k8s体系下具有相当的意义。Dubbo在serviemesh中基于sidecar的方案是解决跨语言诉求的通用servicemesh方案，需要新开一个话题来展开说；而引用serviemsh的原始定义：
A service mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable delivery of requests through the complex topology of services that comprise a modern, cloud native application.
首先服务网格是一个云原生环境下基础设施层，功能在于处理服务间通信，职责是负责实现请求的可靠传递，被使得被监控跟踪，被治理，最终使得微服务架构被赋予高可控的稳定性和快速的问题定位排查能力。
可以得出现有Dubbo集成云原生基础设施Kubernetes的基础能力而并解决微服务相关核心问题也算是一种狭义上的servicemesh方案，只是是Java领域的罢了；当玩笑理解也行，哈哈。
思路/方案 Kubernetes是天然可作为微服务的地址注册中心，类似于Zookeeper， 阿里巴巴内部用到的VIPserver，Configserver。 具体来说，Kubernetes中的Pod是对于应用的运行实例，Pod的被调度部署/启停都会调用API-Server的服务来保持其状态到ETCD；Kubernetes中的service是对应微服务的概念，定义如下
A Kubernetes Service is an abstraction layer which defines a logical set of Pods and enables external traffic exposure, load balancing and service discovery for those Pods.</description></item><item><title>Dubbo Mesh ｜ Service Mesh的实践与探索</title><link>https://dubbo.apache.org/zh-cn/blog/2018/09/20/dubbo-mesh-service-mesh%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%8E%A2%E7%B4%A2/</link><pubDate>Thu, 20 Sep 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/09/20/dubbo-mesh-service-mesh%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%8E%A2%E7%B4%A2/</guid><description>近日，在Aliware Open Source•成都站-Apache Dubbo 开发者沙龙上，阿里巴巴中间件高级技术专家李云（至简）向开发者们分享了阿里巴巴中间件团队在Service Mmesh领域的探索和最新实践。本文是根据至简的现场分享所整理，为大家回顾分享中的精彩内容。
精彩观点导读 我们去探索一项技术，并不会仅仅因为其先进性，而是因为我们目前遇到了一些无法解决的问题，而这项技术正好能解决这个问题。
所有软件最重要的使命不是满足功能要求，而是演进，从而持续成长。
微服务本质是对服务的拆分，微服务架构符合工程领域常用的“分而治之”范式。
前言 我们去探索一项技术，并不会仅仅因为其先进性，而是因为我们目前遇到了一些无法解决的问题，而这项技术正好能解决这个问题。现在，阿里巴巴整个集团业务的体量很大，在技术上会遇到很多的挑战。而正是因为这些挑战，让我们思考通过哪些新技术可以去解决这些痛点，这也是我们在Service Mesh领域进行探索和实践的出发点。首先，我们先来看看自己遇到了哪些挑战。
微服务的5大挑战 挑战一：微服务框架自身演进困难。 任何软件都会有他的生命进化曲线，从最初的萌芽，进入形成期，往上发展，再进入平台期，最后进入衰亡期。当然我们希望我们的软件可以在进入平台期后，能借助某次演进进入新的发展期。从这个维度看，所有软件最重要的使命不是满足功能要求，而是演进，从而持续成长。相反，当某个软件无法演进的时候，就会意味着死亡。但软件的演进并不是一个简单的事情，以微服务框架为例，为了进一步提升双11期间整个中间件平台的稳定性，我们会修改若干个功能，并以SDK的方式去提供给业务方，但业务代码和微服务框架SDK是强耦合的，这时候需要我们推动各个业务方和我们一同去做升级。虽然我们的初衷是实现平台稳定性的提升，帮助业务更好的发展，但这时由于大家的出发点和诉求有所不同，业务方和我们一起去做升级是比较困难的。所以要发展微服务框架，首先遇到的挑战就是演进困难。 挑战二：微服务框架SDK多语言并行开发与维护成本高。 以前我们都是通过对技术栈的统一来提升成本优势和团队效率，大家可以用一种语言去开发和维护，避免多语言时团队的不聚焦。但在软件和开源生态演进的过程中，多语言已经成为一种流行，因为不同语言都有其自身的优势，今天大家能看到的一个现象是云原生的生态中有多种开发语言，使用频率最高的语言已经不是Java了，而是Go，是因为Go的footprint很小。再以 Dubbo为例，除了Java，我们还提供C++，Node.js的SDK，以便让更多的开发者可以加入Dubbo生态，但所有的这些，如果没有社区力量的参与，是很难维持的。 挑战三：异构服务框架难以共存完成渐进式演进。 我们结合场景来看看这个挑战。阿里巴巴收购了一些企业，被收购企业的技术栈可能和阿里巴巴不同，比如有些用的是Go语言，有些用的是PHP，这时候为了统一技术栈，我们需要对这类技术平台推倒重来，但这个过程中，我们会面临一系列问题，首当其冲的就是推倒重来会带来巨大的技术风险，其次是可能会面临技术人员大批量流失的风险，这在社会责任的层面也是很难接受。所以我们在寻求一种可能的方案，去解决这类问题。
挑战四：是单一的语言限制了人才的多样性。 这里，我们不去争论某个编程语言的好与坏，每个语言都有其适用场景，你不能说我手里有个榔头，你面对的都是钉子。以前我们觉得统一技术栈可以集中开发力量，并且带来较高的运维便利性。但伴随着互联网带来的快节奏，以往的团队能力设置已经很难满足这类变化，对工程师个体提出了更高的要求，我们不仅仅需要是某一方面的专家，而且还需要具备多域的工作技能，DevOps和全栈工程师就是这类快节奏变化下最好的注脚。 挑战五：是点状的服务治理难以做到及时、有效和经济。 微服务和架构的核心是拆分，通过拆分，让每个模块可以独立运行，跟上业务的发展速度，持续推动业务的创新。但拆完后新的问题出来了，缺少横向的内容拉通所有独立的烟囱，从而在服务治理上带来极大的挑战。
分布式应用的发展趋势 微服务会成为大规模分布式应用的主流架构。任何复杂的工程问题都会归结为devide and conquer（分而治之），意思就是就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。微服务本质是对服务的拆分，与工程领域惯用的“分而治之”的思路是一致的。
微服务架构下应用的开发是多语言的。没有一个语言是一家独大的，每种语言在特定场景下都有其自身的优势，我们希望这种优势能够将技术到产品的周期（time to market）缩短。技术的核心在于创造价值，无论是交付给客户，还是服务于整个社会。因此，微服务是需要不同语言的开发者发挥自身的优势，去进一步完善我们的微服务架构，释放技术价值。 数据安全将成为公有云分布式应用的生命线。云原生时代，业务即便没上云，企业对自身数据的安全都是有诉求的，尤其是在金融行业，如果通过抓包就能获取一些敏感信息，这将会给企业带来巨大的风险。
Cloud native成为distributionless（无分布式）的主要探索路径。分布式发展的终极形式是无分布式，在未来我们做开发，所有的代码在web上写好后，通过点击一个按钮，所有部署都会自动实现，所有的code review的工作可以在一个统一的工作台上全部实现。 以更快的速度，通过构建软件去探索新业务。工程师服务的是客户，通过技术输出来实现技术价值，以互联网的架构帮助赋能传统企业，帮助企业获得差异化竞争力。
什么是Service Mesh Service Mesh是层次化、规范化、体系化、无侵入的分布式服务治理技术平台。
层次化 分为数据面和控制面两个概念，数据面是指所有数据流动的那个层面，控制面是用来控制这个数据面的，对服务去做处理。对数据面和控制面进行分层，带来的好处是，针对一个复杂的系统进行切分，可以获得更清晰的认识，这和devide and conque是同一个理念。
规范化 是指通过标准协议完成数据平面和控制平面的连接，同时，sidecar成为所有traffic互联、互通的约束标准。
体系化 包含两个维度，一是指observability全局考虑。目前在整个分布式治理过程中的最大挑战是：logging、metrics、tracing这三个observability领域的核心内容缺少体系性的关注。另一个是集中管理的维度，包括服务管理、限流、熔断、安全、灰度在内的服务模块都可以在获得体系化的呈现，每个服务都可以被看到，而非团队a只看限流，团队b只看logging，需要一种技术能力拉通所有的服务模块，这个体系化这个角度看，Service Mesh是一个理想的技术方案。
无侵入 是指我们希望通过无侵入，当新增一个业务的时候，不需要考虑一个SDK去初始化，而是可以通过sidecar的进程方式来解耦。
Service Mesh的形态 我们从三个维度对比的来看 ServiceMesh 的形态。
图中左边是传统的微服务形态，调用者和被调用者是通过一个SDK的方式来实现共享服务的，以Dubbo为例，我们会在SDK里提供服务路由、服务发现等功能，虽然我们的开发者在做应用开发的时候并不会太关注SDK的构成，但这些功能是面临不断被变更的可能，有着比较重的逻辑。在右边Service Mesh的形态中，我们首先会对厚重的SDK进行分解，将复杂的逻辑下沉到sidecar，借助sidecar来实现服务的调用。
虽然在Service Mesh的形态，调用路径要长于传统的形态，路径越长消耗越大，对性能影响越大。但在当前的分布式应用的治理过程中，易用性已经成为一个比性能更重要的话题。当我们给客户部署一套微服务，即便性能很强，但没有处理好易用性问题的话，这将会给技术的推广带来巨大的阻碍，不仅是会影响外部的客户，也会影响内部的用户，如何实现喝着咖啡从容应对双11，必须先解决易用性的问题。在解决易用性问题后，沿着技术的发展路径再去解决性能问题。
Service Mesh的形态中的control plan不会导致重复建设，但在shared service是有可能存在重复建设的。
Service Mesh下的应用架构 无论是单体应用，还是分布式应用，都可以建立在Service Mesh上，mesh上的sidecar支撑了所有的上层应用，业务开发者无须关心底层构成，可以用Java，也可以用Go等语言完成自己的业务开发。</description></item><item><title>如何基于Dubbo实现全异步调用链</title><link>https://dubbo.apache.org/zh-cn/blog/2018/09/02/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Edubbo%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E9%93%BE/</link><pubDate>Sun, 02 Sep 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/09/02/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Edubbo%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E9%93%BE/</guid><description>基于Dubbo实现全异步编程，是在2.7.0版本中对现有异步方式增强后新引入的功能。本文先是回顾2.6.x及之前版本对异步的支持情况及存在的问题，引出了2.7.0版本基于CompletableFuture做了哪些针对性的增强，通过几个示例详细阐述了增强后的异步编程的使用方式，最后总结了引入异步模式带来的新问题及Dubbo的解决方法。通过阅读这篇文章，可以很容易的基于Dubbo2.7.0+版本实现一个全异步的远程服务调用链路。
从3.0.0版本开始，Dubbo框架提供了对Reactive编程范式的支持，除了编程接口之外，在跨进程的RPC通信中引入了Reactive的语义。如果你所在的环境需要使用Reactive编程范式，或者你的RPC调用需要支持流式传输，Reactive应该会给你带来帮助，具体请参考发布在阿里巴巴中间件公众号上的响应式编程支持相关文章。
注意，你可能并不是总需要Reactive的语义，尤其是在RPC的场景，CompletableFuture本身也能带给你Reactive模式的编程模型，在选择Reactive（RxJava、Reactor之类）而不是理解及使用成本更低的CompletableFuture前，请尝试关注以下问题：
你是请求/响应是一次性传输的还是流式传输的，一个明显特征是你定义的数据类型是 List&amp;lt;String&amp;gt; 还是 Stream&amp;lt;String&amp;gt; 你的RPC请求有没有要求是Cold，即在subscribe后触发，因为CompletableFuture总是hot的 你依赖的编程上下文中是否已经在大量使用Reactive的编程接口 你是否需要Rx框架提供的更丰富的Operator，而这点和1又是密切相关的 2.6.x版本之前的异步方式 在2.6.x及之前的版本提供了一定的异步编程能力，包括Consumer端异步调用、参数回调、事件通知等，在上面的文档链接中有关于使用方式的简单介绍和Demo。
关于参数回调，其本质上是一种服务端的数据推送能力，这是终端应用很常见的一种需求，关于这部分的重构计划，不在本文讨论范围。
但当前的异步方式存在以下问题：
Future获取方式不够直接 Future接口无法实现自动回调，而自定义ResponseFuture虽支持回调但支持的异步场景有限，如不支持Future间的相互协调或组合等 不支持Provider端异步 以Consumer端异步使用方式为例：
定义一个普通的同步接口并声明支持异步调用 public interface FooService { String findFoo(String name); } &amp;lt;dubbo:reference id=&amp;#34;fooService&amp;#34; interface=&amp;#34;com.alibaba.foo.FooService&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;findFoo&amp;#34; async=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; 通过RpcContext获取Future // 此调用会立即返回null fooService.findFoo(fooId); // 拿到调用的Future引用，当结果返回后，会被通知和设置到此Future Future&amp;lt;Foo&amp;gt; fooFuture = RpcContext.getContext().getFuture(); fooFuture.get(); 或
// 此调用会立即返回null fooService.findFoo(fooId); // 拿到Dubbo内置的ResponseFuture并设置回调 ResponseFuture future = ((FutureAdapter)RpcContext.getContext().getFuture()).getFuture(); future.setCallback(new ResponseCallback() { @Override public void done(Object response) { System.out.print(response); } @Override public void caught(Throwable exception) { exception.</description></item><item><title>如何准备Apache Release</title><link>https://dubbo.apache.org/zh-cn/blog/2018/09/02/%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87apache-release/</link><pubDate>Sun, 02 Sep 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/09/02/%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87apache-release/</guid><description>理解Apache发布的内容和流程 总的来说，Source Release是Apache关注的重点，也是发布的必须内容；而Binary Release是可选项，Dubbo可以选择是否发布二进制包到Apache仓库或者发布到Maven中央仓库。
请参考以下链接，找到更多关于ASF的发布指南:
Apache Release Guide Apache Release Policy Maven Release Info 本地构建环境准备 主要包括签名工具、Maven仓库认证相关准备
安装GPG 详细文档请参见这里, Mac OS下配置如下
$ brew install gpg $ gpg --version #检查版本，应该为2.x 用gpg生成key 根据提示，生成key
$ gpg --full-gen-key gpg (GnuPG) 2.0.12; Copyright (C) 2009 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) Your selection?</description></item><item><title>第四届Dubbo开发者沙龙于8月26日在成都举行</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/26/%E7%AC%AC%E5%9B%9B%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E4%BA%8E8%E6%9C%8826%E6%97%A5%E5%9C%A8%E6%88%90%E9%83%BD%E4%B8%BE%E8%A1%8C/</link><pubDate>Sun, 26 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/26/%E7%AC%AC%E5%9B%9B%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E4%BA%8E8%E6%9C%8826%E6%97%A5%E5%9C%A8%E6%88%90%E9%83%BD%E4%B8%BE%E8%A1%8C/</guid><description>用户深度沟通交流 8.26上午10:00-12:00，邀请到货车帮，云图金控，前BBD，飞鱼星四家公司开源爱好者及重度用户参与面对面交流；据参与者反馈，解答了对Dubbo的诸多疑惑，特别是如何参与贡献社区，以及捐献代码所带来的价值点。希望后面可以更加深入参与Dubbo社区及活动中。
meetup活动信息 本次活动依旧爆满，总报名人数976，现场用户350+，直播PV 13207。
报名信息 Aliware Open Source•成都站-Apache Dubbo开发者沙龙于8月26日(周日)在成都高新区天府五街200号菁蓉国际广场8号楼2楼会议厅举办，技术GG们的思想盛宴，干货与福利一个都不会少。
报名链接：http://www.huodongxing.com/event/7453091088400</description></item><item><title>Dubbo 集群容错</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/22/dubbo-%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99/</link><pubDate>Wed, 22 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/22/dubbo-%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99/</guid><description>Design For failure 在分布式系统中，集群某个某些节点出现问题是大概率事件，因此在设计分布式RPC框架的过程中，必须要把失败作为设计的一等公民来对待。一次调用失败之后，应该如何选择对失败的选择策略，这是一个见仁见智的问题，每种策略可能都有自己独特的应用场景。因此，作为框架来说，应当针对不同场景提供多种策略，供用户进行选择。
在Dubbo设计中，通过Cluster这个接口的抽象，把一组可供调用的Provider信息组合成为一个统一的Invoker供调用方进行调用。经过路由规则过滤，负载均衡选址后，选中一个具体地址进行调用，如果调用失败，则会按照集群配置的容错策略进行容错处理。
Dubbo默认内置了若干容错策略，如果不能满足用户需求，则可以通过自定义容错策略进行配置。
内置容错策略 Dubbo主要内置了如下几种策略：
Failover(失败自动切换) Failsafe(失败安全) Failfast(快速失败) Failback(失败自动恢复) Forking(并行调用) Broadcast(广播调用) 这些名称比较相似，概念也比较容易混淆，下面逐一进行解释。
Failover(失败自动切换) Failover是高可用系统中的一个常用概念，服务器通常拥有主备两套机器配置，如果主服务器出现故障，则自动切换到备服务器中，从而保证了整体的高可用性。
Dubbo也借鉴了这个思想，并且把它作为Dubbo默认的容错策略。当调用出现失败的时候，根据配置的重试次数，会自动从其他可用地址中重新选择一个可用的地址进行调用，直到调用成功，或者是达到重试的上限位置。
Dubbo里默认配置的重试次数是2，也就是说，算上第一次调用，最多会调用3次。
其配置方法，容错策略既可以在服务提供方配置，也可以服务调用方进行配置。而重试次数的配置则更为灵活，既可以在服务级别进行配置，也可以在方法级别进行配置。具体优先顺序为：
服务调用方方法级配置 &amp;gt; 服务调用方服务级配置 &amp;gt; 服务提供方方法级配置 &amp;gt; 服务提供方服务级配置 以XML方式为例，具体配置方法如下：
服务提供方，服务级配置
&amp;lt;dubbo:service interface=&amp;#34;org.apache.dubbo.demo.DemoService&amp;#34; ref=&amp;#34;demoService&amp;#34; cluster=&amp;#34;failover&amp;#34; retries=&amp;#34;2&amp;#34; /&amp;gt; 服务提供方，方法级配置
&amp;lt;dubbo:service interface=&amp;#34;org.apache.dubbo.demo.DemoService&amp;#34; ref=&amp;#34;demoService&amp;#34;cluster=&amp;#34;failover&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;sayHello&amp;#34; retries=&amp;#34;2&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; 服务调用方，服务级配置
&amp;lt;dubbo:reference id=&amp;#34;demoService&amp;#34; interface=&amp;#34;org.apache.dubbo.demo.DemoService&amp;#34; cluster=&amp;#34;failover&amp;#34; retries=&amp;#34;1&amp;#34;/&amp;gt; 服务调用方，方法级配置：
&amp;lt;dubbo:reference id=&amp;#34;demoService&amp;#34; interface=&amp;#34;org.apache.dubbo.demo.DemoService&amp;#34; cluster=&amp;#34;failover&amp;#34;&amp;gt; &amp;lt;dubbo:method name=&amp;#34;sayHello&amp;#34; retries=&amp;#34;3&amp;#34; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt; Failover可以自动对失败进行重试，对调用者屏蔽了失败的细节，但是Failover策略也会带来一些副作用：
重试会额外增加一下开销，例如增加资源的使用，在高负载系统下，额外的重试可能让系统雪上加霜。 重试会增加调用的响应时间。 某些情况下，重试甚至会造成资源的浪费。考虑一个调用场景，A-&amp;gt;B-&amp;gt;C，如果A处设置了超时100ms，再B-&amp;gt;C的第一次调用完成时已经超过了100ms，但很不幸B-&amp;gt;C失败，这时候会进行重试，但其实这时候重试已经没有意义，因此在A看来这次调用已经超时，A可能已经开始执行其他逻辑。 Failsafe(失败安全) 失败安全策略的核心是即使失败了也不会影响整个调用流程。通常情况下用于旁路系统或流程中，它的失败不影响核心业务的正确性。在实现上，当出现调用失败时，会忽略此错误，并记录一条日志，同时返回一个空结果，在上游看来调用是成功的。
应用场景，可以用于写入审计日志等操作。
具体配置方法：
服务提供方，服务级配置
&amp;lt;dubbo:service interface=&amp;#34;org.</description></item><item><title>Spring应用快速集成Dubbo + Hystrix</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/22/spring%E5%BA%94%E7%94%A8%E5%BF%AB%E9%80%9F%E9%9B%86%E6%88%90dubbo--hystrix/</link><pubDate>Wed, 22 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/22/spring%E5%BA%94%E7%94%A8%E5%BF%AB%E9%80%9F%E9%9B%86%E6%88%90dubbo--hystrix/</guid><description>背景 Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能。
Dubbo是Alibaba开源的，目前国内最流行的java rpc框架。
本文介绍在spring应用里，怎么把Dubbo和Hystrix结合起来使用。
https://github.com/Netflix/Hystrix https://github.com/apache/dubbo Spring Boot应用 Demo地址： https://github.com/dubbo/dubbo-samples/tree/master/4-governance/dubbo-samples-spring-boot-hystrix
生成dubbo集成spring boot的应用 对于不熟悉dubbo 集成spring boot应用的同学，可以在这里直接生成dubbo + spring boot的工程： http://start.dubbo.io/
配置spring-cloud-starter-netflix-hystrix spring boot官方提供了对hystrix的集成，直接在pom.xml里加入依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.4.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 然后在Application类上增加@EnableHystrix来启用hystrix starter：
@SpringBootApplication @EnableHystrix public class ProviderApplication { 配置Provider端 在Dubbo的Provider上增加@HystrixCommand配置，这样子调用就会经过Hystrix代理。
@Service(version = &amp;#34;1.0.0&amp;#34;) public class HelloServiceImpl implements HelloService { @HystrixCommand(commandProperties = { @HystrixProperty(name = &amp;#34;circuitBreaker.requestVolumeThreshold&amp;#34;, value = &amp;#34;10&amp;#34;), @HystrixProperty(name = &amp;#34;execution.isolation.thread.timeoutInMilliseconds&amp;#34;, value = &amp;#34;2000&amp;#34;) }) @Override public String sayHello(String name) { // System.</description></item><item><title>Dubbo 现有心跳方案总结以及改进建议</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/19/dubbo-%E7%8E%B0%E6%9C%89%E5%BF%83%E8%B7%B3%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8A%E6%94%B9%E8%BF%9B%E5%BB%BA%E8%AE%AE/</link><pubDate>Sun, 19 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/19/dubbo-%E7%8E%B0%E6%9C%89%E5%BF%83%E8%B7%B3%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8A%E6%94%B9%E8%BF%9B%E5%BB%BA%E8%AE%AE/</guid><description>1 前言 设计一个好的心跳机制并不是一件容易的事，就我所熟知的几个 RPC 框架，它们的心跳机制可以说大相径庭，这篇文章我将探讨一下如何设计一个优雅的心跳机制，主要从 Dubbo 的现有方案以及一个改进方案来做分析。
2 预备知识 因为后续我们将从源码层面来进行介绍，所以一些服务治理框架的细节还需要提前交代一下，方便大家理解。
2.1 客户端如何得知请求失败了？ 高性能的 RPC 框架几乎都会选择使用 Netty 来作为通信层的组件，非阻塞式通信的高效不需要我做过多的介绍。但也由于非阻塞的特性，导致其发送数据和接收数据是一个异步的过程，所以当存在服务端异常、网络问题时，客户端是接收不到响应的，那么我们如何判断一次 RPC 调用是失败的呢？
误区一：Dubbo 调用不是默认同步的吗？
Dubbo 在通信层是异步的，呈现给使用者同步的错觉是因为内部做了阻塞等待，实现了异步转同步。
误区二： Channel.writeAndFlush 会返回一个 channelFuture，我只需要判断 channelFuture.isSuccess 就可以判断请求是否成功了。
注意，writeAndFlush 成功并不代表对端接受到了请求，返回值为 true 只能保证写入网络缓冲区成功，并不代表发送成功。
避开上述两个误区，我们再来回到本小节的标题：客户端如何得知请求失败？正确的逻辑应当是以客户端接收到失败响应为判断依据。等等，前面不还在说在失败的场景中，服务端是不会返回响应的吗？没错，既然服务端不会返回，那就只能客户端自己造了。
一个常见的设计是：客户端发起一个 RPC 请求，会设置一个超时时间 client_timeout，发起调用的同时，客户端会开启一个延迟 client_timeout 的定时器
接收到正常响应时，移除该定时器。 定时器倒计时完毕，还没有被移除，则认为请求超时，构造一个失败的响应传递给客户端。 Dubbo 中的超时判定逻辑：
public static DefaultFuture newFuture(Channel channel, Request request, int timeout) { final DefaultFuture future = new DefaultFuture(channel, request, timeout); // timeout check timeoutCheck(future); return future; } private static void timeoutCheck(DefaultFuture future) { TimeoutCheckTask task = new TimeoutCheckTask(future); TIME_OUT_TIMER.</description></item><item><title>Dubbo2.7 三大新特性详解</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/15/dubbo2.7-%E4%B8%89%E5%A4%A7%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/</link><pubDate>Wed, 15 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/15/dubbo2.7-%E4%B8%89%E5%A4%A7%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/</guid><description>1 背景介绍 自 2017 年 7 月阿里重启 Dubbo 开源，到目前为止 github star 数，contributor 数都有了非常大的提升。2018 年 2 月 9 日阿里决定将 Dubbo 项目贡献给 Apache，经过一周的投票，顺利成为了 Apache 的孵化项目，也就是大家现在看到的 Incubator Dubbo。预计在 2019 年 4 月，Dubbo 可以达成毕业，成为 Apache 的顶级项目。
2 分支介绍 Dubbo 目前有如图所示的 5 个分支，其中 2.7.1-release 只是一个临时分支，忽略不计，对其他 4 个分支进行介绍。
2.5.x 近期已经通过投票，Dubbo 社区即将停止对其的维护。 2.6.x 为长期支持的版本，也是 Dubbo 贡献给 Apache 之前的版本，其包名前缀为：com.alibaba，JDK 版本对应 1.6。 3.x-dev 是前瞻性的版本，对 Dubbo 进行一些高级特性的补充，如支持 rx 特性。 master 为长期支持的版本，版本号为 2.7.x，也是 Dubbo 贡献给 Apache 的开发版本，其包名前缀为：org.apache，JDK 版本对应 1.8。 如果想要研究 Dubbo 的源码，建议直接浏览 master 分支。</description></item><item><title>Dubbo 关于同步/异步调用的几种方式</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/14/dubbo-%E5%85%B3%E4%BA%8E%E5%90%8C%E6%AD%A5/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</link><pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/14/dubbo-%E5%85%B3%E4%BA%8E%E5%90%8C%E6%AD%A5/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid><description>我们知道，Dubbo 缺省协议采用单一长连接，底层实现是 Netty 的 NIO 异步通讯机制；基于这种机制，Dubbo 实现了以下几种调用方式：
同步调用 异步调用 参数回调 事件通知 同步调用 同步调用是一种阻塞式的调用方式，即 Consumer 端代码一直阻塞等待，直到 Provider 端返回为止；
通常，一个典型的同步调用过程如下：
Consumer 业务线程调用远程接口，向 Provider 发送请求，同时当前线程处于阻塞状态； Provider 接到 Consumer 的请求后，开始处理请求，将结果返回给 Consumer； Consumer 收到结果后，当前线程继续往后执行。 这里有 2 个问题：
Consumer 业务线程是怎么进入阻塞状态的？ Consumer 收到结果后，如何唤醒业务线程往后执行的？ 其实，Dubbo 的底层 IO 操作都是异步的。Consumer 端发起调用后，得到一个 Future 对象。对于同步调用，业务线程通过Future#get(timeout)，阻塞等待 Provider 端将结果返回；timeout则是 Consumer 端定义的超时时间。当结果返回后，会设置到此 Future，并唤醒阻塞的业务线程；当超时时间到结果还未返回时，业务线程将会异常返回。
异步调用 基于 Dubbo 底层的异步 NIO 实现异步调用，对于 Provider 响应时间较长的场景是必须的，它能有效利用 Consumer 端的资源，相对于 Consumer 端使用多线程来说开销较小。
异步调用，对于 Provider 端不需要做特别的配置。下面的例子中，Provider 端接口定义如下：
public interface AsyncService { String goodbye(String name); } Consumer 配置 &amp;lt;dubbo:reference id=&amp;#34;asyncService&amp;#34; interface=&amp;#34;com.</description></item><item><title>Dubbo 基本用法 - Dubbo Consumer 配置</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/14/dubbo-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-dubbo-consumer-%E9%85%8D%E7%BD%AE/</link><pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/14/dubbo-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-dubbo-consumer-%E9%85%8D%E7%BD%AE/</guid><description>Dubbo Consumer配置 Consumer配置详解 配置Dubbo Consumer有3种方式：XML配置，API调用方式配置，注解方式配置。
XML配置 最简单的配置的样例： &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;dubbo:application name=&amp;#34;hello-world-app&amp;#34; /&amp;gt; &amp;lt;dubbo:registry address=&amp;#34;multicast://224.5.6.7:1234&amp;#34; /&amp;gt; &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;20880&amp;#34; /&amp;gt; &amp;lt;dubbo:reference id=&amp;#34;demoServiceRemote&amp;#34; interface=&amp;#34;com.alibaba.dubbo.demo.DemoService&amp;#34; /&amp;gt; &amp;lt;/beans&amp;gt; 支持的配置标签及对应的配置项详解，参考provider中的用法。
接下来重点讲解下&amp;lt;dubbo:reference/&amp;gt;的配置。
&amp;lt;dubbo:reference/&amp;gt;支持的主要属性列表： 属性名 说明 id 服务引用id，作为java bean id，需要唯一 interface 接口名，用于查找服务 version 版本号，与服务提供者的版本一致 timeout 服务方法调用超时时间(毫秒) retries 远程服务调用重试次数，不包括第一次调用，不需要重试请设为0 connections 对每个提供者的最大连接数，rmi、http、hessian等短连接协议表示限制连接数，dubbo等长连接协表示建立的长连接个数 loadbalance 负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用 async 是否异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程 generic 泛化调用，可以绕过 check 启动时检查提供者是否存在，true报错，false忽略 actives 每服务消费者每服务每方法最大并发调用数 其他配置属性请参考xsd：http://dubbo.apache.org/schema/dubbo/dubbo.xsd
&amp;lt;dubbo:method/&amp;gt;作为&amp;lt;dubbo:reference/&amp;gt;的子元素，它可以针对方法进行配置。比较常用的属性有： 属性名 说明 executes 服务执行的请求上限 retries 超时重试次数 timeout 调用超时时间 loadbalance 负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用 async 是否异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程 actives 每服务消费者最大并发调用限制 其他属性，可以参考上面的xsd。</description></item><item><title>Dubbo 基础用法 - Provider 配置</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/14/dubbo-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95-provider-%E9%85%8D%E7%BD%AE/</link><pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/14/dubbo-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95-provider-%E9%85%8D%E7%BD%AE/</guid><description>Dubbo基本用法 本章节主要讲述如何配置dubbo，按照配置方式上分，可以分为：XML配置，properties方式配置，注解方式配置，API调用方式配置。 按照功能角度进行划分，可以分为Dubbo Provider和Dubbo Consumer。接下来章节中，分别对dubbo provider和Dubbo consumer进行讲解。
Dubbo Provider配置 Provider 配置详解 配置Dubbo Provider有4种方式：XML配置，properties方式配置，API调用方式配置，注解方式配置。
XML配置 最简单的配置的样例： &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;dubbo:application name=&amp;#34;hello-world-app&amp;#34; /&amp;gt; &amp;lt;dubbo:registry address=&amp;#34;multicast://224.5.6.7:1234&amp;#34; /&amp;gt; &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;20880&amp;#34; /&amp;gt; &amp;lt;dubbo:service interface=&amp;#34;com.alibaba.dubbo.demo.DemoService&amp;#34; ref=&amp;#34;demoServiceLocal&amp;#34; /&amp;gt; &amp;lt;dubbo:reference id=&amp;#34;demoServiceRemote&amp;#34; interface=&amp;#34;com.alibaba.dubbo.demo.DemoService&amp;#34; /&amp;gt; &amp;lt;/beans&amp;gt; 上面样例中，注意下dubbo schema的写法：
&amp;lt;beans xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://code.alibabatech.com/schema/dubbo&amp;#34; xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; 支持的配置标签 标签 用途 解释 &amp;lt;dubbo:service/&amp;gt; 服务配置 用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心 &amp;lt;dubbo:reference/&amp;gt; 引用配置 用于创建一个远程服务代理，一个引用可以指向多个注册中心 &amp;lt;dubbo:protocol/&amp;gt; 协议配置 用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受 &amp;lt;dubbo:application/&amp;gt; 应用配置 用于配置当前应用信息，不管该应用是提供者还是消费者 &amp;lt;dubbo:module/&amp;gt; 模块配置 用于配置当前模块信息，可选 &amp;lt;dubbo:registry/&amp;gt; 注册中心配置 用于配置连接注册中心相关信息 &amp;lt;dubbo:monitor/&amp;gt; 监控中心配置 用于配置连接监控中心相关信息，可选 &amp;lt;dubbo:provider/&amp;gt; 提供方配置 当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选 &amp;lt;dubbo:consumer/&amp;gt; 消费方配置 当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选 &amp;lt;dubbo:method/&amp;gt; 方法配置 用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息 &amp;lt;dubbo:argument/&amp;gt; 参数配置 用于指定方法参数配置 配置项详解 &amp;lt;dubbo:application name=&amp;ldquo;hello-world-app&amp;rdquo; /&amp;gt;</description></item><item><title>Dubbo 优雅停机</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/14/dubbo-%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA/</link><pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/14/dubbo-%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA/</guid><description>背景 对于任何一个线上应用，如何在服务更新部署过程中保证客户端无感知是开发者必须要解决的问题，即从应用停止到重启恢复服务这个阶段不能影响正常的业务请求。理想条件下，在没有请求的时候再进行更新是最安全可靠的，然而互联网应用必须要保证可用性，因此在技术层面上优化应用更新流程来保证服务在更新时无损是必要的。
传统的解决方式是通过将应用更新流程划分为手工摘流量、停应用、更新重启三个步骤，由人工操作实现客户端无对更新感知。这种方式简单而有效，但是限制较多：不仅需要使用借助网关的支持来摘流量，还需要在停应用前人工判断来保证在途请求已经处理完毕。这种需要人工介入的方式运维复杂度较高，只能适用规模较小的应用，无法在大规模系统上使用。
因此，如果在容器/框架级别提供某种自动化机制，来自动进行摘流量并确保处理完以到达的请求，不仅能保证业务不受更新影响，还可以极大地提升更新应用时的运维效率。
这个机制也就是优雅停机，目前Tomcat/Undertow/Dubbo等容器/框架都有提供相关实现。下面给出正式一些的定义：优雅停机是指在停止应用时，执行的一系列保证应用正常关闭的操作。这些操作往往包括等待已有请求执行完成、关闭线程、关闭连接和释放资源等，优雅停机可以避免非正常关闭程序可能造成数据异常或丢失，应用异常等问题。优雅停机本质上是JVM即将关闭前执行的一些额外的处理代码。
适用场景 JVM主动关闭(System.exit(int)； JVM由于资源问题退出(OOM)； 应用程序接受到SIGTERM或SIGINT信号。 配置方式 服务的优雅停机 在Dubbo中，优雅停机是默认开启的，停机等待时间为10000毫秒。可以通过配置dubbo.service.shutdown.wait来修改等待时间。
例如将等待时间设置为20秒可通过增加以下配置实现：
dubbo.service.shutdown.wait=20000 容器的优雅停机 当使用org.apache.dubbo.container.Main这种容器方式来使用 Dubbo 时，也可以通过配置dubbo.shutdown.hook为true来开启优雅停机。
通过QOS优雅上下线 基于ShutdownHook方式的优雅停机无法确保所有关闭流程一定执行完，所以 Dubbo 推出了多段关闭的方式来保证服务完全无损。
多段关闭即将停止应用分为多个步骤，通过运维自动化脚本或手工操作的方式来保证脚本每一阶段都能执行完毕。
在关闭应用前，首先通过 QOS 的offline指令下线所有服务，然后等待一定时间确保已经到达请求全部处理完毕，由于服务已经在注册中心下线，当前应用不会有新的请求。这时再执行真正的关闭(SIGTERM 或 SIGINT)流程，就能保证服务无损。
QOS可通过 telnet 或 HTTP 方式使用，具体方式请见Dubbo-QOS命令使用说明。
流程 Provider在接收到停机指令后
从注册中心上注销所有服务； 从配置中心取消监听动态配置； 向所有连接的客户端发送只读事件，停止接收新请求； 等待一段时间以处理已到达的请求，然后关闭请求处理线程池； 断开所有客户端连接。 Consumer在接收到停机指令后
拒绝新到请求，直接返回调用异常； 等待当前已发送请求执行完毕，如果响应超时则强制关闭连接。 当使用容器方式运行 Dubbo 时，在容器准备退出前，可进行一系列的资源释放和清理工。
例如使用 SpringContainer时，Dubbo 的ShutdownHook线程会执行ApplicationContext的stop和close方法，保证 Bean的生命周期完整。
实现原理 在加载类org.apache.dubbo.config.AbstractConfig时，通过org.apache.dubbo.config.DubboShutdownHook向JVM注册 ShutdownHook。
/** * Register the ShutdownHook */ public void register() { if (!registered.get() &amp;amp;&amp;amp; registered.compareAndSet(false, true)) { Runtime.getRuntime().addShutdownHook(getDubboShutdownHook()); } } 每个ShutdownHook都是一个单独的线程，由JVM在退出时触发执行org.</description></item><item><title>Dubbo的泛化调用</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/14/dubbo%E7%9A%84%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8/</link><pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/14/dubbo%E7%9A%84%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8/</guid><description>以下几种场景可以考虑使用泛化调用：
服务测试平台 API 服务网关 泛化调用主要用于消费端没有 API 接口的情况；不需要引入接口 jar 包，而是直接通过 GenericService 接口来发起服务调用，参数及返回值中的所有 POJO 均用 Map 表示。泛化调用对于服务端无需关注，按正常服务进行暴露即可。
下面来看看消费端如何使用泛化调用进行服务调用。
通过 Spring XML 配置进行泛化调用 在 Spring 配置申明 generic=&amp;quot;true&amp;quot;，如：
&amp;lt;dubbo:reference id=&amp;#34;userService&amp;#34; interface=&amp;#34;com.alibaba.dubbo.samples.generic.api.IUserService&amp;#34; generic=&amp;#34;true&amp;#34;/&amp;gt; 需要使用的地方，通过强制类型转化为 GenericService 进行调用：
GenericService userService = (GenericService) context.getBean(&amp;#34;userService&amp;#34;); // primary param and return value String name = (String) userService.$invoke(&amp;#34;delete&amp;#34;, new String[]{int.class.getName()}, new Object[]{1}); System.out.println(name); 其中：
GenericService 这个接口只有一个方法，名为 $invoke，它接受三个参数，分别为方法名、方法参数类型数组和参数值数组； 对于方法参数类型数组 如果是基本类型，如 int 或 long，可以使用 int.class.getName()获取其类型； 如果是基本类型数组，如 int[]，则可以使用 int[].class.getName()； 如果是 POJO，则直接使用全类名，如 com.alibaba.dubbo.samples.generic.api.Params。 通过 API 编程进行泛化调用 ApplicationConfig application = new ApplicationConfig(); application.</description></item><item><title>Spring Boot Dubbo应用启停源码分析</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/14/spring-boot-dubbo%E5%BA%94%E7%94%A8%E5%90%AF%E5%81%9C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/14/spring-boot-dubbo%E5%BA%94%E7%94%A8%E5%90%AF%E5%81%9C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>背景介绍 Dubbo Spring Boot 工程致力于简化 Dubbo RPC 框架在Spring Boot应用场景的开发。同时也整合了 Spring Boot 特性：
自动装配 (比如： 注解驱动, 自动装配等). Production-Ready (比如： 安全, 健康检查, 外部化配置等). DubboConsumer启动分析 你有没有想过一个问题？dubbo-spring-boot-project中的DubboConsumerDemo应用就一行代码，main方法执行完之后，为什么不会直接退出呢？
@SpringBootApplication(scanBasePackages = &amp;#34;com.alibaba.boot.dubbo.demo.consumer.controller&amp;#34;) public class DubboConsumerDemo { public static void main(String[] args) { SpringApplication.run(DubboConsumerDemo.class,args); } } 其实要回答这样一个问题，我们首先需要把这个问题进行一个抽象，即一个JVM进程，在什么情况下会退出？
以Java 8为例，通过查阅JVM语言规范[1]，在12.8章节中有清晰的描述：
A program terminates all its activity and exits when one of two things happens:
All the threads that are not daemon threads terminate. Some thread invokes the exit method of class Runtime or class System, and the exit operation is not forbidden by the security manager.</description></item><item><title>从跨语言调用到dubbo2.js</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/14/%E4%BB%8E%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8%E5%88%B0dubbo2.js/</link><pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/14/%E4%BB%8E%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8%E5%88%B0dubbo2.js/</guid><description>dubbo2.js 是 千米网 贡献给 dubbo 社区的一款 nodejs dubbo 客户端，它提供了 nodejs 对原生 dubbo 协议的支持，使得 nodejs 和 java 这两种异构语言的 rpc 调用变得便捷，高效。
微服务跨语言调用 微服务架构已成为目前互联网架构的趋势，关于微服务的讨论，几乎占据了各种技术大会的绝大多数版面。国内使用最多的服务治理框架非阿里开源的 dubbo 莫属，千米网也选择了 dubbo 作为微服务治理框架。另一方面，和大多数互联网公司一样，千米的开发语言是多样的，大多数后端业务由 java 支撑，而每个业务线有各自开发语言的选择权，便出现了 nodejs，python，go 多语言调用的问题。 跨语言调用是一个很大的话题，也是一个很有挑战的技术活，目前业界经常被提及的解决方案有如下几种，不妨拿出来老生常谈一番：
spring cloud。spring cloud 提供了一整套微服务开发组件，它主要面向 java 开发，但由于其使用的协议是基于 restful 风格的 http 协议，这使得其天然具备跨语言能力，异构语言只需要提供 http 客户端，便可以实现跨语言调用。 service mesh。号称下一代微服务框架的 service mesh，其解决跨语言问题的核心在于 SideCar ，SideCar 在 service mesh 的发展过程中概念不断的迁移，但本质都是完成了一件事：处理服务间通信，负责实现请求的可靠传递。 motan。motan 是新浪微博开源的一款跨语言服务治理框架，在其早期版本中仅支持 motan-java，随着版本演进，在目前最新版本(1.1.0)中，提供了 motan-go，motan-php，motan-openresty 等跨语言特性。类似于 service mesh 中的 SideCar，motan 借助于 motan-go 作为 agent 完成协议的转发，并且依赖于定制协议：motan2，实现跨语言调用。 当我们再聊跨语言调用时我们在聊什么？纵观上述几个较为通用，成熟的解决方案，可以得出结论：解决跨语言调用的思路无非是两种：
寻找一个通用的协议 使用 agent 完成协议的适配 如果一个新型的团队面临技术选型，我认为上述的方案都可以纳入参考，可考虑到遗留系统的兼容性问题</description></item><item><title>通过QoS对服务进行动态控制</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/14/%E9%80%9A%E8%BF%87qos%E5%AF%B9%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8C%E5%8A%A8%E6%80%81%E6%8E%A7%E5%88%B6/</link><pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/14/%E9%80%9A%E8%BF%87qos%E5%AF%B9%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8C%E5%8A%A8%E6%80%81%E6%8E%A7%E5%88%B6/</guid><description>QoS，全称为Quality of Service, 是常见于网络设备中的一个术语 ，例如在路由器中，可以通过Qos动态的调整和控制某些端口的权重，从而优先的保障运行在这些端口上的服务质量。
在Dubbo中，QoS这个概念被用于动态的对服务进行查询和控制。例如对获取当前提供和消费的所有服务，以及对服务进行动态的上下线，即从注册中心上进行注册和反注册操作。
QoS工作机制 从Dubbo 2.5.8开始，默认引入了Qos功能，默认处于启动状态。所有的QoS功能被抽象成一个个的命令，通过执行这些命令，Qos会返回响应的结果。
Qos功能基于Netty4实现，在Dubbo 2.6.x之前的版本中，默认依赖的是Netty3，因此需要显示的添加Netty4的依赖，才能确保Netty4正常工作。如果使用http://start.dubbo.io自动生成的Dubbo应用，则无需添加额外的配置，因为已经默认加上了Netty4的依赖。
Qos的工作机制如下图所示：
启动并监听一个端口，默认端口是22222 识别目标请求的协议是Http或者是Telnet，根据协议不同动态添加对应的处理器 针对不同的协议进行解码，解析出需要执行的命令 执行命令并返回结果 QoS命令 QoS目前支持的命令包括：
help: 帮助命令，列出 ls: 列出当前所有的正在提供的服务，以及消费的服务 online: 动态将某个或全部服务向注册中心进行注册 offline: 动态将某个或全部服务从注册中心摘除（反注册） quit: 退出当前telnet会话 下面，我们具体来操作一下如何通过用QoS对服务进行动态控制。
通过Telnet方式访问QoS 假设我们的Dubbo服务端已经启动，我们通过Telnet方式进行连接：
$ telnet localhost 22222 Trying 127.0.0.1... Connected to localhost. Escape character is &amp;#39;^]&amp;#39;. ????????? ??? ?? ??????????? ??????????? ???????? ??? ???? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ?</description></item><item><title>Dubbo的负载均衡</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/10/dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link><pubDate>Fri, 10 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/10/dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid><description>背景 Dubbo是一个分布式服务框架，能避免单点故障和支持服务的横向扩容。一个服务通常会部署多个实例。如何从多个服务 Provider 组成的集群中挑选出一个进行调用，就涉及到一个负载均衡的策略。
几个概念 在讨论负载均衡之前，我想先解释一下这3个概念。
负载均衡 集群容错 服务路由 这3个概念容易混淆。他们都描述了怎么从多个 Provider 中选择一个来进行调用。那他们到底有什么区别呢?下面我来举一个简单的例子，把这几个概念阐述清楚吧。
有一个Dubbo的用户服务，在北京部署了10个，在上海部署了20个。一个杭州的服务消费方发起了一次调用，然后发生了以下的事情:
根据配置的路由规则，如果杭州发起的调用，会路由到比较近的上海的20个 Provider。 根据配置的随机负载均衡策略，在20个 Provider 中随机选择了一个来调用，假设随机到了第7个 Provider。 结果调用第7个 Provider 失败了。 根据配置的Failover集群容错模式，重试其他服务器。 重试了第13个 Provider，调用成功。 上面的第1，2，4步骤就分别对应了路由，负载均衡和集群容错。 Dubbo中，先通过路由，从多个 Provider 中按照路由规则，选出一个子集。再根据负载均衡从子集中选出一个 Provider 进行本次调用。如果调用失败了，根据集群容错策略，进行重试或定时重发或快速失败等。 可以看到Dubbo中的路由，负载均衡和集群容错发生在一次RPC调用的不同阶段。最先是路由，然后是负载均衡，最后是集群容错。 本文档只讨论负载均衡，路由和集群容错在其他的文档中进行说明。
Dubbo内置负载均衡策略 Dubbo内置了4种负载均衡策略:
RandomLoadBalance:随机负载均衡。随机的选择一个。是Dubbo的默认负载均衡策略。 RoundRobinLoadBalance:轮询负载均衡。轮询选择一个。 LeastActiveLoadBalance:最少活跃调用数，相同活跃数的随机。活跃数指调用前后计数差。使慢的 Provider 收到更少请求，因为越慢的 Provider 的调用前后计数差会越大。 ConsistentHashLoadBalance:一致性哈希负载均衡。相同参数的请求总是落在同一台机器上。 1.随机负载均衡 顾名思义，随机负载均衡策略就是从多个 Provider 中随机选择一个。但是 Dubbo 中的随机负载均衡有一个权重的概念，即按照权重设置随机概率。比如说，有10个 Provider，并不是说，每个 Provider 的概率都是一样的，而是要结合这10个 Provider 的权重来分配概率。
Dubbo中，可以对 Provider 设置权重。比如机器性能好的，可以设置大一点的权重，性能差的，可以设置小一点的权重。权重会对负载均衡产生影响。可以在Dubbo Admin中对 Provider 进行权重的设置。
基于权重的负载均衡算法
随机策略会先判断所有的 Invoker 的权重是不是一样的，如果都是一样的，那么处理就比较简单了。使用random.nexInt(length)就可以随机生成一个 Invoker 的序号,根据序号选择对应的 Invoker 。如果没有在Dubbo Admin中对服务 Provider 设置权重，那么所有的 Invoker 的权重就是一样的，默认是100。 如果权重不一样，那就需要结合权重来设置随机概率了。算法大概如下： 假如有4个 Invoker。</description></item><item><title>Dubbo 注解驱动</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/07/dubbo-%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8/</link><pubDate>Tue, 07 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/07/dubbo-%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8/</guid><description>注解驱动（Annotation-Driven） @DubboComponentScan 起始版本： 2.5.7 &amp;lt;dubbo:annotation&amp;gt; 历史遗留问题 1. 注解支持不充分 在 Dubbo 2.5.7之前的版本 ，Dubbo 提供了两个核心注解 @Service 以及 @Reference，分别用于Dubbo 服务提供和 Dubbo 服务引用。
其中，@Service 作为 XML 元素 &amp;lt;dubbo:service&amp;gt;的替代注解，与 Spring Framework @org.springframework.stereotype.Service 类似，用于服务提供方 Dubbo 服务暴露。与之相对应的@Reference，则是替代&amp;lt;dubbo:reference 元素，类似于 Spring 中的 @Autowired。 2.5.7 之前的Dubbo，与早期的 Spring Framework 2.5 存在类似的不足，即注解支持不够充分。注解需要和 XML 配置文件配合使用，如下所示：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:dubbo=&amp;#34;http://code.alibabatech.com/schema/dubbo&amp;#34; xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&amp;#34;&amp;gt; &amp;lt;dubbo:application name=&amp;#34;annotation-provider&amp;#34;/&amp;gt; &amp;lt;dubbo:registry address=&amp;#34;127.0.0.1:4548&amp;#34;/&amp;gt; &amp;lt;dubbo:annotation package=&amp;#34;com.alibaba.dubbo.config.spring.annotation.provider&amp;#34;/&amp;gt; &amp;lt;/beans&amp;gt; 2. @Service Bean 不支持 Spring AOP 同时，使用 &amp;lt;dubbo:annotation&amp;gt; 方式扫描后的Dubbo @Service ，在 Spring 代理方面存在问题，如 GitHub 上的 issue https://github.</description></item><item><title>第一个 Dubbo 应用</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/07/dubbo-101/</link><pubDate>Tue, 07 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/07/dubbo-101/</guid><description>Java RMI 简介 Java RMI （Remote Method Invocation）- 远程方法调用，能够让客户端像使用本地调用一样调用服务端 Java 虚拟机中的对象方法。RMI 是面向对象语言领域对 RPC （Remote Procedure Call）的完善，用户无需依靠 IDL 的帮助来完成分布式调用，而是通过依赖接口这种更简单自然的方式。
Java RMI 工作原理 一个典型的 RMI 调用如下图所示：
服务端向 RMI 注册服务绑定自己的地址， 客户端通过 RMI 注册服务获取目标地址， 客户端调用本地的 Stub 对象上的方法，和调用本地对象上的方法一致， 本地存根对象将调用信息打包，通过网络发送到服务端， 服务端的 Skeleton 对象收到网络请求之后，将调用信息解包， 然后找到真正的服务对象发起调用，并将返回结果打包通过网络发送回客户端。 (来源：https://www.cs.rutgers.edu/~pxk/417/notes/images/rpc-rmi_flow.png)
Java RMI 基本概念 Java RMI 是 Java 领域创建分布式应用的技术基石。后续的 EJB 技术，以及现代的分布式服务框架，其中的基本理念依旧是 Java RMI 的延续。在 RMI 调用中，有以下几个核心的概念：
通过接口进行远程调用
通过客户端的 Stub 对象和服务端的 Skeleton 对象的帮助将远程调用伪装成本地调用
通过 RMI 注册服务完成服务的注册和发现
对于第一点，客户端需要依赖接口，而服务端需要提供该接口的实现。
对于第二点，在 J2SE 1.5 版本之前需要通过 rmic 预先编译好客户端的 Stub 对象和服务端的 Skeleton 对象。在之后的版本中，不再需要事先生成 Stub 和 Skeleton 对象。</description></item><item><title>使用jdk17编译运行dubbo 2.7.14项目</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/07/%E4%BD%BF%E7%94%A8jdk17%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Cdubbo-2.7.14%E9%A1%B9%E7%9B%AE/</link><pubDate>Tue, 07 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/07/%E4%BD%BF%E7%94%A8jdk17%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Cdubbo-2.7.14%E9%A1%B9%E7%9B%AE/</guid><description>概述 java 17是java目前最新的长期支持(LTS)版本，但是由于其强封装 JDK 的内部 API的新特性，导致dubbo项目无法直接使用jdk17编译运行。通过参考openjdk的说明，可以发现只需要添加相应参数即可绕开java 17的限制
对于普通的dubbo项目，只需要在运行时添加
--add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/sun.reflect.generics.reflectiveObjects=ALL-UNNAMED --add-opens java.base/java.math=ALL-UNNAMED
如上参数即可。如果项目的其它依赖也有类似问题则可能需要加入更多参数，参数的获得方式和详细示例将在下面给出
本解决方案只能解决由于java 17强封装 JDK 的内部 API的特性造成的问题，其他的兼容性问题请寻找其它方案
参数的获得方法和示例 我们以dubbo官方仓库中的demo为例 首先使用java 17作为我们的开发环境，通过
git clone git@github.com:apache/dubbo.git git checkout dubbo-2.7.14 cd dubbo-demo/dubbo-demo-annotation 获得dubbo官方仓库的代码中的demo，然后可以尝试直接使用java 17编译dubbo的demo
确认java版本
➜ ~ java -version openjdk version &amp;#34;17.0.1&amp;#34; 2021-10-19 OpenJDK Runtime Environment Temurin-17.0.1+12 (build 17.0.1+12) OpenJDK 64-Bit Server VM Temurin-17.0.1+12 (build 17.0.1+12, mixed mode, sharing) 然后运行
mvn -U clean package --no-transfer-progress -D maven.test.skip=true 启动zookeeper docker run --name some-zookeepep -p 2181:2181 -it --rm zookeeper 作为注册中心 尝试运行provider</description></item><item><title>在 Dubbo 应用中使用 Zookeeper</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/07/%E5%9C%A8-dubbo-%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8-zookeeper/</link><pubDate>Tue, 07 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/07/%E5%9C%A8-dubbo-%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8-zookeeper/</guid><description>Zookeeper 介绍 基本概念 在现代的分布式应用中，往往会出现节点和节点之间的协调问题，其中就包括了：选主、集群管理、分布式锁、分布式配置管理、统一命名服务、状态同步等诉求。Apache Zookeeper，正如它的名字所暗示的那样，动物园管理员，就是为了解决这些诉求的一个分布式协调服务框架。
为了保证高可用，ZooKeeper 本身也可以部署成集群模式，称之为 ZooKeeper ensemble。ZooKeeper 集群中始终确保其中的一台为 leader 的角色，并通过 ZAB (Zookeeper Atomic Broadcast Protocol) 1 协议确保所有节点上的信息的一致。客户端可以访问集群中的任何一台进行读写操作，而不用担心数据出现不一致的现象。
Image Credit : ebook -Zookeeper-Distributed Process Coordination from O&amp;rsquo;Reilly
Zookeeper 中的数据存储方式与传统的 UNIX 文件系统相似，节点按照树状结构来组织，其中，节点被称之为 znodes (ZooKeeper data nodes)
Image Credit : ebook -Zookeeper-Distributed Process Coordination from O&amp;rsquo;Reilly
基本用法 可以通过直接下载的方式 2安装并运行 Zookeeper ，在 Mac 上也可以通过 Homebrew 3 brew install zookeeper 来安装，考虑到通用性，本文采用 docker 的方式来运行 Zookeeper。如果没有安装 docker，请先准备好 docker 环境 4。
1. 启动 Zookeeper 执行命令将 Zookeeper 运行在 docker 容器中</description></item><item><title>在 Dubbo 中使用注解</title><link>https://dubbo.apache.org/zh-cn/blog/2018/08/07/%E5%9C%A8-dubbo-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3/</link><pubDate>Tue, 07 Aug 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/08/07/%E5%9C%A8-dubbo-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3/</guid><description>在 Dubbo 中使用注解 随着微服务架构的广泛地推广和实施。在 Java 生态系统中，以 Spring Boot 和 Spring Cloud 为代表的微服务框架，引入了全新的编程模型，包括：
注解驱动（Annotation-Driven） 外部化配置（External Configuration） 以及自动装配（Auto-Configure） 新的编程模型无需 XML 配置、简化部署、提升开发效率。为了更好地实践微服务架构，Dubbo 从 2.5.8 版本开始， 分别针对了上述的三个场景，提供了更完善的支持。本文不讨论传统的 XML 配置方式，而是侧重介绍注解这种方式。外部配置、自动装配两种自动装配会在另外的文章中专门介绍。
注解介绍 @EnableDubbo @EnableDubbo 注解是 @EnableDubboConfig 和 @DubboComponentScan两者组合的便捷表达方式。与注解驱动相关的是 @DubboComponentScan。
package org.apache.dubbo.config.spring.context.annotation; @EnableDubboConfig @DubboComponentScan public @interface EnableDubbo { /** * Base packages to scan for annotated @Service classes. * &amp;lt;p&amp;gt; * Use {@link #scanBasePackageClasses()} for a type-safe alternative to String-based * package names. * * @return the base packages to scan * @see DubboComponentScan#basePackages() */ @AliasFor(annotation = DubboComponentScan.</description></item><item><title>第三届Dubbo开发者沙龙在深圳成功举办</title><link>https://dubbo.apache.org/zh-cn/blog/2018/07/30/%E7%AC%AC%E4%B8%89%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E6%B7%B1%E5%9C%B3%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/</link><pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/07/30/%E7%AC%AC%E4%B8%89%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E6%B7%B1%E5%9C%B3%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/</guid><description>第三届Dubbo开发者沙龙在深圳成功举办，超过2000位开发者报名，现场参与人数700+，通过阿里云天池、云栖社区、大咖说引导线上直播观看次数17000+
分享嘉宾
陈志轩: Dubbo开源现状和2.7规划 康彬: 乐信集团的微服务化之路 林佳梁: Sentinel——企业用户的全方位流量哨兵</description></item><item><title>Sentinel 为 Dubbo 服务保驾护航</title><link>https://dubbo.apache.org/zh-cn/blog/2018/07/27/sentinel-%E4%B8%BA-dubbo-%E6%9C%8D%E5%8A%A1%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA/</link><pubDate>Fri, 27 Jul 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/07/27/sentinel-%E4%B8%BA-dubbo-%E6%9C%8D%E5%8A%A1%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA/</guid><description>在复杂的生产环境下可能部署着成千上万的 Dubbo 服务实例，流量持续不断地进入，服务之间进行相互调用。但是分布式系统中可能会因流量激增、系统负载过高、网络延迟等一系列问题，导致某些服务不可用，如果不进行相应的控制可能导致级联故障，影响服务的可用性，因此如何对流量进行合理的控制，成为保障服务稳定性的关键。
Sentinel 是阿里中间件团队开源的，面向分布式服务架构的轻量级流量控制产品，主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户保护服务的稳定性。本文将基于 Dubbo，看看 Sentinel 是如何进行流量控制的，并且提供 Dubbo 整合 Sentinel 的最佳实践。
快速接入 Sentinel Sentinel 意为哨兵，这个命名形象的诠释了 Sentinel 在分布式系统中的工作角色和重要性。以 Sentinel 在 Dubbo 生态系统中的作用为例，Dubbo 的核心模块包括注册中心、服务提供方、服务消费方（服务调用方）和监控四个模块。Sentinel 通过对服务提供方和服务消费方的限流来进一步提升服务的可用性。接下来我们看看 Sentinel 对服务提供方和服务消费方限流的技术实现方式。
Sentinel 提供了与 Dubbo 适配的模块 – Sentinel Dubbo Adapter，包括针对服务提供方的过滤器和服务消费方的过滤器（Filter）。使用时我们只需引入以下模块（以 Maven 为例）：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.csp&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;sentinel-dubbo-adapter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;x.y.z&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 引入此依赖后，Dubbo 的服务接口和方法（包括调用端和服务端）就会成为 Sentinel 中的资源，在配置了规则后就可以自动享受到 Sentinel 的防护能力。同时提供了灵活的配置选项，例如若不希望开启 Sentinel Dubbo Adapter 中的某个 Filter，可以手动关闭对应的 Filter。
接入 Sentinel Dubbo Adapter 后，即使未配置规则，Sentinel 也会对相应的 Dubbo 服务的调用信息进行统计。那么我们怎么知道 Sentinel 接入成功了呢？这时候就要请出一大利器 —— Sentinel 控制台了。
限流必备 - 监控管理 流量具有很强的实时性，之所以需要限流，是因为我们无法对流量的到来作出精确的预判，不然的话我们完全可以通过弹性的计算资源来处理，所以这时候为了保证限流的准确性，限流框架的监控功能就非常重要了。</description></item><item><title>Dubbo 2.7.x repackage 后的兼容实现方案</title><link>https://dubbo.apache.org/zh-cn/blog/2018/07/22/dubbo-2.7.x-repackage-%E5%90%8E%E7%9A%84%E5%85%BC%E5%AE%B9%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</link><pubDate>Sun, 22 Jul 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/07/22/dubbo-2.7.x-repackage-%E5%90%8E%E7%9A%84%E5%85%BC%E5%AE%B9%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</guid><description>Dubbo至加入Apache孵化器以来，一个很强的诉求就是需要rename groupId和package name，这两项工作在项目毕业前需要完成。其中rename package相对来说复杂一些，除了要修改所有类的包名为org.apache.dubbo外，更多的是需要考虑如何老版本的兼容性。
常见的兼容性包括但不限于以下几种情况：
用户API 编程API Spring注解 扩展SPI 扩展Filter 2.7.x里就是通过增加了一个新的模块dubbo-compatible来解决以上兼容性问题。
编程使用API 编程使用API是最直接最原始的使用方式，其他方式诸如Spring schema、注解等方式都是基于原始API的；因此非常有必要对API编程形式进行兼容。
所有编程相关API的兼容代码均在com.alibaba.dubbo.config包下，下面我们看看几个常见API的兼容实现。
ApplicationConfig package com.alibaba.dubbo.config; @Deprecated public class ApplicationConfig extends org.apache.dubbo.config.ApplicationConfig { public ApplicationConfig() { super(); } public ApplicationConfig(String name) { super(name); } } ProtocolConfig package com.alibaba.dubbo.config; @Deprecated public class ProtocolConfig extends org.apache.dubbo.config.ProtocolConfig { public ProtocolConfig() { } public ProtocolConfig(String name) { super(name); } public ProtocolConfig(String name, int port) { super(name, port); } } 可以看到：
兼容类是直接通过继续repacakge后的类，达到最大程度的代码复用； 构造函数也需要保持兼容； 整个兼容包中，除了上述API以外，包括一些常用的类比如Constants、URL以及绝大部分的兼容类都是通过简单的继承，让用户基于老的API实现的类能正确运行。</description></item><item><title>Dubbo 上下文信息</title><link>https://dubbo.apache.org/zh-cn/blog/2018/07/12/dubbo-%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF/</link><pubDate>Thu, 12 Jul 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/07/12/dubbo-%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF/</guid><description>简介 上下文信息是一次 RPC 调用过程中附带的环境信息，如方法名、参数类型、真实参数、本端/对端地址等。这些数据仅属于一次调用，作用于 Consumer 到 Provider 调用的整个流程。
提供上下文信息是 RPC 框架很重要的一个功能，使用上下文不仅可以为单次调用指定不同配置，还能在此基础上提供强大的上层功能，如分布式链路追踪。其实现原理就是在上下文中维护一个span_id，Consumer 和 Provider 通过传递span_id来连接一次RPC调用，分别上报日志后可以在追踪系统中串联并展示完整的调用流程。这样可以更方便地发现异常，定位问题。
使用说明 Dubbo中代表上下文的类是org.apache.dubbo.rpc.RpcContext，可通过下述代码来获取上下文信息。
RpcContext.getContext() 使用场景 获取调用信息 方法名 用途 作用范围 说明 getRequest 获取 RPC 请求对象 Consumer 获取底层 RPC 请求对象，例如 HttpServletRequest，其他情况为 null getResponse 获取 RPC 请求响应 Consumer 获取底层 RPC 响应对象，例如HttpServletResponse，其他情况为 null isProviderSide 当前是否属于 Provider 上下文 Both 服务被调用时为 true，调用其他服务时为false isConsumerSide 当前是否属于 Consumer 上下文 Both 服务被调用时为 false，调用其他服务时为 true getUrls 获取当前能调用的 Url 列表 Both Consumer 端会根据不同的 Failover 策略实时变化 getRemotePort 获取远端端口 Both Consumer 端为最后一次调用的 Provider 端口，Provider 为当前请求的 Consumer 端口 getRemoteHost 获取远端主机地址 Both getRemoteHostName 获取远端主机名 Both getRemoteAddressString 获取远端地址 Both getRemoteAddress 获取远端地址 Both getLocalPort 获取本端端口 Both getLocalHost 获取本端主机地址 Both getLocalHostName 获取本端主机名 Both getLocalAddressString 获取本端地址 Both getLocalAddress 获取本端地址 Both 传递用户参数 本端传递 调用get和set方法即可完成参数传递。主要用于本端 Filter 之间的数据共享。</description></item><item><title>使用Pinpoint做分布式跟踪</title><link>https://dubbo.apache.org/zh-cn/blog/2018/07/12/%E4%BD%BF%E7%94%A8pinpoint%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F%E8%B7%9F%E8%B8%AA/</link><pubDate>Thu, 12 Jul 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/07/12/%E4%BD%BF%E7%94%A8pinpoint%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F%E8%B7%9F%E8%B8%AA/</guid><description>在使用Dubbo进行服务化或者整合应用后，假设某个服务后台日志显示有异常，这个服务又被多个应用调用的情况下，我们通常很难判断是哪个应用调用的，问题的起因是什么，因此我们需要一套分布式跟踪系统来快速定位问题，Pinpoint可以帮助我们快速定位问题（当然，解决方案也不止这一种）。
什么是Pinpoint 摘自Pinpoint学习笔记
Pinpoint是一个开源的 APM (Application Performance Management/应用性能管理)工具，用于基于java的大规模分布式系统。 仿照Google Dapper，Pinpoint通过跟踪分布式应用之间的调用来提供解决方案，以帮助分析系统的总体结构和内部模块之间如何相互联系。
注：对于各个模块之间的通讯英文原文中用的是transaction一词，但是我觉得如果翻译为&amp;quot;事务&amp;quot;容易引起误解，所以替换为&amp;quot;交互&amp;quot;或者&amp;quot;调用&amp;quot;这种比较直白的字眼。
在使用上力图简单高效：
安装agent，不需要修改哪怕一行代码 最小化性能损失 服务器地图(ServerMap) 通过可视化分布式系统的模块和他们之间的相互联系来理解系统拓扑。点击某个节点会展示这个模块的详情，比如它当前的状态和请求数量。
实时活动线程图表(Realtime Active Thread Chart) 实时监控应用内部的活动线程。
请求/应答分布图表(Request/Response Scatter Chart) 长期可视化请求数量和应答模式来定位潜在问题。通过在图表上拉拽可以选择请求查看更多的详细信息。
调用栈(CallStack) 在分布式环境中为每个调用生成代码级别的可视图，在单个视图中定位瓶颈和失败点。
巡查(Inspector) 查看应用上的其他详细信息，比如CPU使用率，内存/垃圾回收，TPS，和JVM参数。
支持模块 JDK 6+ Tomcat 6/7/8, Jetty 8/9, JBoss EAP 6, Resin 4, Websphere 6/7/8, Vertx 3.3/3.4/3.5 Spring, Spring Boot (Embedded Tomcat, Jetty) Apache HTTP Client 3.x/4.x, JDK HttpConnector, GoogleHttpClient, OkHttpClient, NingAsyncHttpClient Thrift Client, Thrift Service, DUBBO PROVIDER, DUBBO CONSUMER ActiveMQ, RabbitMQ MySQL, Oracle, MSSQL, CUBRID,POSTGRESQL, MARIA Arcus, Memcached, Redis, CASSANDRA iBATIS, MyBatis DBCP, DBCP2, HIKARICP gson, Jackson, Json Lib log4j, Logback 自定义模块 Pinpoint与Dubbo的结合 启动Pinpoint 参考Pinpoint的Quick start搭建环境（不需要启动TestApp）</description></item><item><title>第一个 Dubbo Filter</title><link>https://dubbo.apache.org/zh-cn/blog/2018/07/01/%E7%AC%AC%E4%B8%80%E4%B8%AA-dubbo-filter/</link><pubDate>Sun, 01 Jul 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/07/01/%E7%AC%AC%E4%B8%80%E4%B8%AA-dubbo-filter/</guid><description>概述 在Dubbo的整体设计中，Filter是一个很重要的概念，包括Dubbo本身的大多数功能，都是基于此扩展点实现的，在每次的调用过程中，Filter的拦截都会被执行。
Dubbo Filter的加载机制 Dubbo中已经实现的Filter大概有二十几个，它们的入口都是ProtocolFilterWrapper，ProtocolFilterWrapper对Protocol做了Wrapper，会在加载扩展的时候被加载进来，下面我们来看下这个Filter链是如何构造的。
//ProtocolFilterWrapper.java public &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; refer(Class&amp;lt;T&amp;gt; type, URL url) throws RpcException { if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) { return protocol.refer(type, url); } return buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER); } private static &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; buildInvokerChain(final Invoker&amp;lt;T&amp;gt; invoker, String key, String group) { Invoker&amp;lt;T&amp;gt; last = invoker; List&amp;lt;Filter&amp;gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group); if (filters.size() &amp;gt; 0) { for (int i = filters.size() - 1; i &amp;gt;= 0; i --) { final Filter filter = filters.</description></item><item><title>回声测试</title><link>https://dubbo.apache.org/zh-cn/blog/2018/06/26/%E5%9B%9E%E5%A3%B0%E6%B5%8B%E8%AF%95/</link><pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/06/26/%E5%9B%9E%E5%A3%B0%E6%B5%8B%E8%AF%95/</guid><description>回声测试用于检测服务是否可用。客户端通过 EchoService 来使用回声测试。EchoService 申明如下：
public interface EchoService { /** * echo test. * * @param message message. * @return message. */ Object $echo(Object message); } 用户通过 $echo 方法发起的请求，会按照正常请求的流程执行，能够测试整个调用是否通畅，监控系统可以使用回声测试来检测服务可用性。
使用范例 所有服务引用自动实现 EchoService 接口，用户只需将服务引用强制转型为 EchoService，即可使用。配置和代码范例如下所示。 Spring 配置：
&amp;lt;dubbo:reference id=&amp;#34;demoService&amp;#34; interface=&amp;#34;org.apache.dubbo.samples.echo.DemoService&amp;#34; /&amp;gt; 代码：
// 远程服务引用 DemoService demoService= ctx.getBean(&amp;#34;demoService&amp;#34;); // 强制转型为EchoService EchoService echoService = (EchoService) demoService; // 回声测试可用性 String status = echoService.$echo(&amp;#34;OK&amp;#34;); assert(status.equals(&amp;#34;OK&amp;#34;)); 实现原理 我们在配置服务引用时，并没有配置 EchoService 这个接口，为什么可以直接把服务引用转型为 EchoService 呢？ 用户拿到的服务引用其实是一个 Proxy，Dubbo 在生成 Proxy 的时候，已经默认将 EchoService 这个接口加入到 Proxy 的接口列表中，所以用户拿到的 Proxy 都已经实现了 EchoService。生成代理相关代码如下：</description></item><item><title>第二届Dubbo开发者沙龙在上海成功举办</title><link>https://dubbo.apache.org/zh-cn/blog/2018/06/23/%E7%AC%AC%E4%BA%8C%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E4%B8%8A%E6%B5%B7%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/</link><pubDate>Sat, 23 Jun 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/06/23/%E7%AC%AC%E4%BA%8C%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E4%B8%8A%E6%B5%B7%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/</guid><description>第二届Dubbo开发者沙龙在上海成功举办，超过700位开发者报名，现场参与人数300+，通过阿里云天池、云栖社区、大咖说引导线上直播观看次数10000+
分享嘉宾及PPT:
朱勇: Dubbo开源现状与未来规划 (中文) slides 小马哥: Dubbo Cloud Native 之路的实践与思考 (中文) slides 郭平: Nacos - 贡献Dubbo生态，阿里巴巴注册中心和配置中心开源计划 (中文) slides 潘志伟: Dubbo在互金行业的应用场景 (中文) slides</description></item><item><title>在 Dubbo 中使用 Zipkin</title><link>https://dubbo.apache.org/zh-cn/blog/2018/06/17/%E5%9C%A8-dubbo-%E4%B8%AD%E4%BD%BF%E7%94%A8-zipkin/</link><pubDate>Sun, 17 Jun 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/06/17/%E5%9C%A8-dubbo-%E4%B8%AD%E4%BD%BF%E7%94%A8-zipkin/</guid><description>随着业务的发展，应用的规模不断的扩大，传统的应用架构无法满足诉求，服务化架构改造势在必行，以 Dubbo 为代表的分布式服务框架成为了服务化改造架构中的基石。随着微服务理念逐渐被大众接受，应用进一步向更细粒度拆分，并且，不同的应用由不同的开发团队独立负责，整个分布式系统变得十分复杂。没有人能够清晰及时的知道当前系统整体的依赖关系。当出现问题时，也无法及时知道具体是链路上的哪个环节出了问题。
在这个背景下，Google 发表了 Dapper 的论文，描述了如何通过一个分布式追踪系统解决上述问题。基于该论文，各大互联网公司实现并部署了自己的分布式追踪系统，其中比较出名的有阿里巴巴的 EagleEye。本文中提到的 Zipkin 是 Twitter 公司开源的分布式追踪系统。下面会详细介绍如何在 Dubbo 中使用 Zipkin 来实现分布式追踪。
Zipkin 简介 Zipkin 是基于 Dapper 论文实现，由 Twitter 开源的分布式追踪系统，通过收集分布式服务执行时间的信息来达到追踪服务调用链路、以及分析服务执行延迟等目的。
Zipkin 架构 Collector 收集器、Storage 存储、API、UI 用户界面等几部分构成了 Zipkin Server 部分，对应于 GitHub 上 openzipkin/zipkin 这个项目。而收集应用中调用的耗时信息并将其上报的组件与应用共生，并拥有各个语言的实现版本，其中 Java 的实现是 GitHub 上 openzipkin/brave。除了 Java 客户端实现之外，openzipkin 还提供了许多其他语言的实现，其中包括了 go、php、JavaScript、.net、ruby 等，具体列表可以参阅 Zipkin 的 Exiting instrumentations。
Zipkin 的工作过程 当用户发起一次调用时，Zipkin 的客户端会在入口处为整条调用链路生成一个全局唯一的 trace id，并为这条链路中的每一次分布式调用生成一个 span id。span 与 span 之间可以有父子嵌套关系，代表分布式调用中的上下游关系。span 和 span 之间可以是兄弟关系，代表当前调用下的两次子调用。一个 trace 由一组 span 组成，可以看成是由 trace 为根节点，span 为若干个子节点的一棵树。</description></item><item><title>以 Dubbo 为例，聊聊如何向开源项目做贡献</title><link>https://dubbo.apache.org/zh-cn/blog/2018/06/03/%E4%BB%A5-dubbo-%E4%B8%BA%E4%BE%8B%E8%81%8A%E8%81%8A%E5%A6%82%E4%BD%95%E5%90%91%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%81%9A%E8%B4%A1%E7%8C%AE/</link><pubDate>Sun, 03 Jun 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/06/03/%E4%BB%A5-dubbo-%E4%B8%BA%E4%BE%8B%E8%81%8A%E8%81%8A%E5%A6%82%E4%BD%95%E5%90%91%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%81%9A%E8%B4%A1%E7%8C%AE/</guid><description>Github 上有众多优秀的开源项目，大多数 IT 从业者将其当做了予取予求的工具库，遇到什么需求，先去 Github 搜一把，但有没有想过有一天自己也可以给开源事业做一些贡献呢？本文将会以 dubbo 项目为例，向你阐释，给开源项目做贡献并不是一件难事。
1 为何要给开源贡献力量 为开源项目做贡献得到的收益是多方面的，为了让你有足够的信心加入到开源项目中，我在文章最开始列举出它的诸多好处。
1.1 巩固技能 无论你是提交代码，撰写文档，提交 Issue，组织活动，当你切身参与到一个开源项目中，相关的技能都会得到历练，并且在开源项目中找到自己的位置。一方面，日常工作中我们中的大多数人接触到的是业务场景，并没有太多机会接触到基础架构组件，开源项目为我们提供了一个平台，在这里，你可以尽情挑选自己熟悉的项目为它添砖加瓦（以 Dubbo 为例，并不是所有 IT 公司都有能力自研服务治理框架）；另一方面，你所提交的代码，会有管理员协助审核，他们会给出专业的建议，更好的代码规范以及更优的编程思路最终都会变成你的经验。
1.2 结交朋友 开源社区为你提供了一个平台，在这里，你可以认识很多纯粹的技术爱好者，开源贡献者是最符合 geek 定义的那群人，你所接触到的往往是某个领域最厉害的那批人。
1.3 建立口碑 这是一个很好的展示个人实力的地方，俗话说：talk is cheap，show me the code. 作为技术人员，没有什么比一个漂亮的 Github 主页更有说服力的了。如果你能够为开源项目做出可观的贡献，你也将收获到业界的知名度，此时开源项目的成就和你是密不可分的。
1.4 传承开源精神 只有源源不断的贡献者给开源项目添砖加瓦，才可以为 Github 一类的开源社区形成良好的开源风气。否则，只有输出没有输入，开源会失去活力。
1.5 养成习惯 相信我，一旦养成了每天提交代码的习惯，就像你不想中断打卡一样，你绝不想中断 commit。不止有英语打卡，健身打卡，还有开源打卡！
2 贡献代码时的一些疑难杂症 如果你是一名开源界的新手，可能会对贡献的流程心生畏惧。比如：我该怎么修改代码并提交？我的代码要是存在bug怎么办？我的代码别人会不会很 low？我该如何寻找合适的开源项目？开源社区那么多的工具和词汇都是什么意思？
文章的第二部分将从一个小白的角度，介绍一下开源中的一些常见问题。
2.1 git 常规操作 一般而言，我们选择使用 git 来作为版本管理的工具，你不一定要非常熟练的使用它，在我看来掌握 clone，add，commit，pull，push 即可，遇到复杂的场景，你还有谷歌。
fork 与 clone
如果你只是想下载源码，查看他的源码实现，使用 Clone or download 按钮即可。
如果你想要给开源项目做改动，并且最终请求合并，让开源项目存在你贡献的代码，就应该使用 fork。
fork 将会复制一份当前主分支的代码进入到你的仓库中，之后你所有的修改，应当基于自己的仓库进行，在功能开发/bug 修复之后，可以使用你的仓库向源仓库提交 pull request。只有源仓库的管理员才有权利合并你的请求。</description></item><item><title>Dubbo 外部化配置</title><link>https://dubbo.apache.org/zh-cn/blog/2018/05/21/dubbo-%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 21 May 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/05/21/dubbo-%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE/</guid><description>Dubbo 外部化配置 外部化配置 在Dubbo 注解驱动例子中，无论是服务提供方，还是服务消费方，均需要转配相关配置Bean：
@Bean public ApplicationConfig applicationConfig() { ApplicationConfig applicationConfig = new ApplicationConfig(); applicationConfig.setName(&amp;#34;dubbo-annotation-consumer&amp;#34;); return applicationConfig; } 虽然实现类似于ProviderConfiguration 和 ConsumerConfiguration 这样的 Spring @Configuration Bean 成本并不高，不过通过 Java Code 的方式定义配置 Bean，或多或少是一种 Hard Code（硬编码）的行为，缺少弹性。
尽管在 Spring 应用中，可以通过 @Value 或者 Environment 的方式获取外部配置，其代码简洁性以及类型转换灵活性存在明显的不足。因此，Spring Boot 提出了外部化配置（External Configuration）的感念，即通过程序以外的配置源，动态地绑定指定类型。
随着 Spring Boot / Spring Cloud 应用的流行，开发人员逐渐地接受并且使用 Spring Boot 外部化配置（External Configuration），即通过 application.properties 或者 bootstrap.properties 装配配置 Bean。
下列表格记录了 Dubbo 内置配置类：
配置类 标签 用途 解释 ProtocolConfig &amp;lt;dubbo:protocol/&amp;gt; 协议配置 用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受 ApplicationConfig &amp;lt;dubbo:application/&amp;gt; 应用配置 用于配置当前应用信息，不管该应用是提供者还是消费者 ModuleConfig &amp;lt;dubbo:module/&amp;gt; 模块配置 用于配置当前模块信息，可选 RegistryConfig &amp;lt;dubbo:registry/&amp;gt; 注册中心配置 用于配置连接注册中心相关信息 MonitorConfig &amp;lt;dubbo:monitor/&amp;gt; 监控中心配置 用于配置连接监控中心相关信息，可选 ProviderConfig &amp;lt;dubbo:provider/&amp;gt; 提供方配置 当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选 ConsumerConfig &amp;lt;dubbo:consumer/&amp;gt; 消费方配置 当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选 MethodConfig &amp;lt;dubbo:method/&amp;gt; 方法配置 用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息 ArgumentConfig &amp;lt;dubbo:argument/&amp;gt; 参数配置 用于指定方法参数配置 通过申明对应的 Spring 扩展标签，在 Spring 应用上下文中将自动生成相应的配置 Bean。</description></item><item><title>首届Dubbo开发者沙龙在北京成功举办</title><link>https://dubbo.apache.org/zh-cn/blog/2018/05/12/%E9%A6%96%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E5%8C%97%E4%BA%AC%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/</link><pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/05/12/%E9%A6%96%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E5%8C%97%E4%BA%AC%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/</guid><description>首届Dubbo开发者沙龙在北京成功举办, 超过400位开发者参加。这是一个很好的开始！
分享嘉宾及主体如下：
罗毅: Dubbo 的现状现状与未来规划 PDF 刘军: 第四届阿里中间件性能挑战赛 PDF 陈志轩: 通过 Dubbo 和 Spring-boot 快速构建微服务 PDF 王欣: Dubbo 和微店的服务化实践历程分享 PDF</description></item><item><title>ApacheCon NA 大会议程公布</title><link>https://dubbo.apache.org/zh-cn/blog/2018/05/02/apachecon-na-%E5%A4%A7%E4%BC%9A%E8%AE%AE%E7%A8%8B%E5%85%AC%E5%B8%83/</link><pubDate>Wed, 02 May 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/05/02/apachecon-na-%E5%A4%A7%E4%BC%9A%E8%AE%AE%E7%A8%8B%E5%85%AC%E5%B8%83/</guid><description>罗毅/刘军将在蒙特利尔举办的 ApacheCon 大会上进行题为&amp;quot;Introducing Apache Dubbo(Incubating): What is Dubbo and How it Works&amp;quot;的演讲。请点击此处查看大会议程，并在此处中进行注册。</description></item><item><title>谷歌编程之夏会议上2018个项目被宣布</title><link>https://dubbo.apache.org/zh-cn/blog/2018/04/25/%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%8F%E4%BC%9A%E8%AE%AE%E4%B8%8A2018%E4%B8%AA%E9%A1%B9%E7%9B%AE%E8%A2%AB%E5%AE%A3%E5%B8%83/</link><pubDate>Wed, 25 Apr 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/04/25/%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%8F%E4%BC%9A%E8%AE%AE%E4%B8%8A2018%E4%B8%AA%E9%A1%B9%E7%9B%AE%E8%A2%AB%E5%AE%A3%E5%B8%83/</guid><description>谷歌编程之夏会议上2018个项目被宣布, Raghu Reddy 的项目&amp;quot;Apache Dubbo 扩展串行协议支持&amp;quot; 被接受! 祝贺他!</description></item><item><title>在DockerHub发布Dubbo Admin镜像</title><link>https://dubbo.apache.org/zh-cn/blog/2018/04/23/%E5%9C%A8dockerhub%E5%8F%91%E5%B8%83dubbo-admin%E9%95%9C%E5%83%8F/</link><pubDate>Mon, 23 Apr 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/04/23/%E5%9C%A8dockerhub%E5%8F%91%E5%B8%83dubbo-admin%E9%95%9C%E5%83%8F/</guid><description>Dubbo Admin是Dubbo的服务治理中心，提供了大量日常运维所需的服务治理、配置管理等功能。
Dubbo Admin同时包含了前端代码和后端代码，如果用户需要自己下载源码并编译打包，需要花费一定时间。 特别是对于一些希望快速调研和试用Dubbo Admin的用户，这种流程的体验并不是很好。
Docker是一个开源的应用容器引擎，让开发者可以打包应用以及依赖包到一个可移植的镜像中，社区对于提供Dubbo Admin镜像的呼声较高。 Docker官方维护了一个公共仓库DockerHub，该仓库还有很多国内镜像，访问速度快，将Dubbo Admin镜像发布到DockerHub是一个较好的选择。
DockerHub账号申请 要在DockerHub上发布镜像，自然需要对应的账号。 而DockerHub有两种常见账号，一种是面向个人的，一种是面向组织的。Apache在DockerHub上有一个组织账号1。 自然我们首选是发布在组织账号下。
DockerHub对于组织账号的管理是基于组的，也就是一个组织账号下有多个组，每个组有不同的成员，而一个组可以管理一个或者多个镜像。
所以要做的第一步就是申请权限，这个需要提一个issue给Apache Infrastructure团队，申请DockerHub的镜像仓库和组权限。 目前镜像和组已经申请好了，只需要申请组的权限就行了，可以参考之前的申请2。
申请完权限以后使用Apache账号登陆应该就可以看到对应的镜像和配置选项了。
添加新的构建规则 发布镜像到DockerHub有两种办法，一种是本地构建好镜像以后远程push到DockerHub，另外一种是提供Dockerfile并借助DockerHub提供的构建功能直接在DockerHub构建。 后者明显操作性和便捷性要好很多，目前Dubbo Admin的镜像也是这样构建发布的。
当Dubbo Admin有新版本发布以后，需要在项目的docker目录新增一个Dockerfile文件，可以参考目前0.1.0版本的Dockerfile3，其中的配置根据具体的版本可能有细微差别，但是大致上是一致的。
在添加了Dockerfile之后，进入DockerHub对应的管理界面新增Build Rules
根据实际情况填写即可。这里需要注意两点：
latest 版本要和最新的版本配置一致 不要勾选Autobuild 勾选Autobuild会导致每次git提交都会触发自动构建，但是由于Dubbo Admin不提供snapshot的Docker镜像，所以只有发布新版本的时候才需要构建发布。
修改以后点Save，然后手动触发构建即可。
总结 总的来说DockerHub上发布镜像的步骤并不复杂，如果已经申请过权限的话，操作起来是很流畅的。
另外DockerHub的构建是需要排队的，有时候会遇到长时间没有开始构建的情况，需要耐心等待。
https://hub.docker.com/r/apache&amp;#160;&amp;#x21a9;&amp;#xfe0e;
https://issues.apache.org/jira/browse/INFRA-18167&amp;#160;&amp;#x21a9;&amp;#xfe0e;
https://github.com/apache/dubbo-admin/blob/develop/docker/0.1.0/Dockerfile&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>Dubbo路线图在QCon Beijing 2018上公布</title><link>https://dubbo.apache.org/zh-cn/blog/2018/04/22/dubbo%E8%B7%AF%E7%BA%BF%E5%9B%BE%E5%9C%A8qcon-beijing-2018%E4%B8%8A%E5%85%AC%E5%B8%83/</link><pubDate>Sun, 22 Apr 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/04/22/dubbo%E8%B7%AF%E7%BA%BF%E5%9B%BE%E5%9C%A8qcon-beijing-2018%E4%B8%8A%E5%85%AC%E5%B8%83/</guid><description>罗毅在Qcon Beijing 2018上进行了Dubbo开源现状及未来规划的主题演讲。详细内容请查看幻灯片。</description></item><item><title>如何参与贡献Dubbo社区</title><link>https://dubbo.apache.org/zh-cn/blog/2018/03/11/%E5%A6%82%E4%BD%95%E5%8F%82%E4%B8%8E%E8%B4%A1%E7%8C%AEdubbo%E7%A4%BE%E5%8C%BA/</link><pubDate>Sun, 11 Mar 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/03/11/%E5%A6%82%E4%BD%95%E5%8F%82%E4%B8%8E%E8%B4%A1%E7%8C%AEdubbo%E7%A4%BE%E5%8C%BA/</guid><description>前言 本文首次分享是在Apache Dubbo成都meetup上，这个话题是第一次在meetup上讲，不是我们没有更好的话题，相反，我们认为这个话题非常重要，甚至建议这个话题以后每次meetup都要讲。
Dubbo的发展历史大家应该并不陌生了，这里我还是简单回顾一下。Dubbo于2011年在github开源，后面几年由于一些原因停止了维护，直接去年7月份阿里重启维护，并于2018年2月16日捐献给Apache。
为什么会选择捐献给Apache，主要是为了打消社区对Dubbo未来发展的顾虑，给Dubbo用户足够的信心；Apache认为社区大于代码，非常注重多样性，强调一个项目需要有多个公司和个人贡献者参与，现在Dubbo的发展完全是按The Apache Way社区化的方式来运作的。
Apache的诞生 说到Apache，大家都非常熟悉了，它是全球目前最大的软件基金；Apache的很多项目我们都用过，比如Maven、Log4j、Tomcat等，但有一个项目要特别强调的，那就是 Apache httpd server，这是Apache的第一个项目。
Apache软件基金会正式创建于1999年，主要是为公众提供有用的免费软件，并为软件开发者社区提供支持和服务；它的创建者是一个自称为Apache组织的群体；
早在1995年，这个组织就存在了，他们聚集在一起，在美国伊利诺伊大学超级计算机应用程序国家中心开发的NCSA HTTPd服务器的基础上开发与维护了一个叫Apache的HTTP服务器。
最早NCSA HTTPd服务器是一个叫Rob McCool的人开发的，但是后来慢慢失去了兴趣，导致这个功能强大又好用的服务器没人维护；于是一些爱好者和用户就自发开始维护起来，并不断改善功能、发布版本；为了更好进行沟通，一哥们就创建了一个邮件组，并把维护工作高效组织起来，且自称是Apache组织，并把这个软件叫Apache 服务器。
这也是为什么Apache的所有的项目到今天为止依然以邮件列表作为沟通的主要方式。
关于Apache的命名来源，从北美当地的一支叫Apache的印第安部落名称而来，这支部落以高超的军事素养和超人的忍耐力著称，19世纪后半期对侵占他们领土的入侵者进行了反抗；为了对这支部落表示敬仰，就取了这个名字；但这里还流传着一个小故事，说是在NCSA HTTPd基础上，大家都通过打补丁不断在修改这个软件，被戏称为A Patchy Server，和Apache Server读音很像。
随着后来商业需求扩大，围绕Apache HTTP服务器的项目越来越多，后来越来越多的项目启动，也有很多外部组织捐献项目；为了让这些外部项目能顺利进入到Apache基金会，2002年创建了Incubator（孵化）项目。可以看到，经过10多年的发展，到2010年，75个顶级项目，30个孵化项目，每天2697封讨论邮件；2018年这个数据进一步增长，194个顶级项目，54个孵化项目，3255个committers；其中中国人主导的项目，有RocketMQ，WeeX，ECharts，Skywalking等。
Dubbo正在成为Apache顶级项目的路上——Apache孵化项目中。
回顾一下Apache这些历史和数据，我们不难发现几个关键词：兴趣、参与、邮件；这些就是我们后面要重点介绍的The Apache Way。
ASF组织架构 我们知道每个组织都有它自己的架构，ASF同样也不例外；那Apache的组织架构是什么样的呢？它有什么独特的地方吗？这里特别要强调的是Project Management Committees，即 PMC，每个项目从孵化阶段开始就会有PMC，主要负责保证开源项目的社区活动都能运转良好，这里运转的机制就是The Apache Way。
图中，Board就是负责整个基金会符合章程的运作。Board我们一般很少能接触到，接触更多的是PMC以及下面的这几层。
参与Apache项目社区活动的人，一般分为以下几类：
直接用户：在座的都是Dubbo的用户，可能部分现在还不是，但将来肯定会是
贡献者：部分用户在使用Dubbo过程中，遇到问题，自己通过分析调试找到解决方案，并提交给Dubbo官方，最终被接受，这些用户就是Dubbo的贡献者
提交者：贡献多了，经过PMC的提议和投票，就会成为Committer；Committer即意味着正式加入Apache，拥有个人Apache帐号以及相应项目的写权限
PMC：Committer再往上走就是PMC，这个必须由现有PMC成员提名
个人在社区的成长，就像我们在公司晋升一样，一步一步往上走。
本文的目的就是告诉大家，从User到Contributor没有大家想像的那么难，从Contributor到Committer也不是不可能；只要大家拥有一颗开源的心，找到自己感兴趣的项目，并持续投入，付出肯定会有回报。
The Apache Way 就像你加入一家公司需要了解这家公司的文化一样，参与Apache开源项目之前，同样我们需要需要了解ASF的文化，这个文化就称为The Apache Way。
这里想特别强调以下几点：
社区胜于代码：把项目构建出来这不是开源，去构建社区才是真正的开源；对社区而言，一切都是围绕代码而生，无代码则社区不复存在；在代码之上，则是如何做事、如何待人、如何决策的理念体现；一个健康的社区远比优秀的代码重要——如果代码奇烂无比，社区可以重写，但社区有了毛病，代码最终也会付之东流； 公开透明与共识决策：If it doesn't happen on email, it doesn't happen. 所有的决定，不管是技术feature、发展方向，还是版本发布等，都应该被公开讨论，而形式就是邮件列表，这些讨论过程和结论都会被永久存档；而讨论的过程，就是大家自由发表意见的过程，但最终大家要投票，比较民主的做法； 任人唯贤：Those that have proven they can do, get to do more.</description></item><item><title>Dubbo 博客文档中文排版指南</title><link>https://dubbo.apache.org/zh-cn/blog/2018/01/01/dubbo-%E5%8D%9A%E5%AE%A2%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2018/01/01/dubbo-%E5%8D%9A%E5%AE%A2%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97/</guid><description>Dubbo 博客文档中文排版指南 [TOC]
空格 「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。与大家共勉之。」—— vinta/paranoid-auto-spacing
中英文之间需要增加空格 正确：
在 LeanCloud 上，数据存储是围绕 AVObject 进行的。
错误：
在LeanCloud上，数据存储是围绕AVObject进行的。
在 LeanCloud上，数据存储是围绕AVObject 进行的。
完整的正确用法：
在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。
例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。
中文与数字之间需要增加空格 正确：
今天出去买菜花了 5000 元。
错误：
今天出去买菜花了 5000元。
今天出去买菜花了5000元。
数字与单位之间需要增加空格 正确：
我家的光纤入户宽带有 10 Gbps，SSD 一共有 20 TB。
错误：
我家的光纤入户宽带有 10Gbps，SSD 一共有 10TB。
例外：度／百分比与数字之间不需要增加空格：
正确：
今天是 233° 的高温。
新 MacBook Pro 有 15% 的 CPU 性能提升。</description></item><item><title/><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/page/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/impls/page/</guid><description>页面扩展 扩展说明 对等网络节点组网器。
扩展接口 org.apache.dubbo.container.page.PageHandler
扩展配置 &amp;lt;dubbo:protocol page=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; &amp;lt;!-- 缺省值设置，当&amp;lt;dubbo:protocol&amp;gt;没有配置page属性时，使用此配置 --&amp;gt; &amp;lt;dubbo:provider page=&amp;#34;xxx,yyy&amp;#34; /&amp;gt; 已知扩展 org.apache.dubbo.container.page.pages.HomePageHandler org.apache.dubbo.container.page.pages.StatusPageHandler org.apache.dubbo.container.page.pages.LogPageHandler org.apache.dubbo.container.page.pages.SystemPageHandler 扩展示例 Maven 项目结构：
src |-main |-java |-com |-xxx |-XxxPageHandler.java (实现PageHandler接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.container.page.PageHandler (纯文本文件，内容为：xxx=com.xxx.XxxPageHandler) XxxPageHandler.java：
package com.xxx; import org.apache.dubbo.container.page.PageHandler; public class XxxPageHandler implements PageHandler { public Group lookup(URL url) { // ... } } META-INF/dubbo/org.apache.dubbo.container.page.PageHandler：
xxx=com.xxx.XxxPageHandler</description></item><item><title/><link>https://dubbo.apache.org/zh-cn/docsv2.7/dev/principals/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/dev/principals/introduction/</guid><description>设计原则 本章节的设计原则摘录自梁飞在 javaeye 上发表的系列文章。</description></item><item><title/><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/auth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/examples/auth/</guid><description>服务鉴权 类似支付之类的对安全性敏感的业务可能会有限制匿名调用的需求。在加固安全性方面，2.7.5 引入了基于AK/SK机制的认证鉴权机制，并且引入了鉴权服务中心，主要原理是消费端在请求需要鉴权的服务时，会通过SK、请求元数据、时间戳、参数等信息来生成对应的请求签名，通过Dubbo的Attahcment机制携带到对端进行验签，验签通过才进行业务逻辑处理。如下图所示：
具体的接入方式也并不复杂：
使用者需要在微服务站点上填写自己的应用信息，并为该应用生成唯一的证书凭证。
之后在管理站点上提交工单，申请某个敏感业务服务的使用权限，并由对应业务管理者进行审批，审批通过之后，会生成对应的AK/SK到鉴权服务中心。
导入该证书到对应的应用下，并且进行配置。配置方式也十分简单，以注解方式为例：
服务提供端，只需要设置service.auth为true，表示该服务的调用需要鉴权认证通过。param.sign为true表示需要对参数也进行校验。
@Service(parameters = {&amp;#34;service.auth&amp;#34;,&amp;#34;true&amp;#34;,&amp;#34;param.sign&amp;#34;,&amp;#34;true&amp;#34;}) public class AuthDemoServiceImpl implements AuthService { } 服务消费端，只需要配置好对应的证书等信息即可，之后会自动地在对这些需要认证的接口发起调用前进行签名操作，通过与鉴权服务的交互，用户无需在代码中配置AK/SK这些敏感信息，并且在不重启应用的情况下刷新AK/SK，达到权限动态下发的目的。
该方案目前已经提交给Dubbo开源社区，并且完成了基本框架的合并，除了AK/SK的鉴权方式之外，通过SPI机制支持用户可定制化的鉴权认证以及适配公司内部基础设施的密钥存储。</description></item><item><title/><link>https://dubbo.apache.org/zh-cn/docsv2.7/user/new-features-in-a-glance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docsv2.7/user/new-features-in-a-glance/</guid><description>Dubbo 版本发布及新特性速览 版本速览 Dubbo 社区目前主力维护的有 2.6.x 和 2.7.x 两大版本，其中，
2.6.x 主要以 bugfix 和少量 enhancements 为主，因此能完全保证稳定性 2.7.x 作为社区的主要开发版本，得到持续更新并增加了大量新 feature 和优化，同时也带来了一些稳定性挑战 2.7.x 版本 版本 重要功能 升级建议 1 2.7.6 bugfix of 2.7.5
服务鉴权 推荐生产使用 2 2.7.5 服务自省
HTTP/2（gRPC） Protobuf TLS
性能优化
https://github.com/apache/dubbo/releases/tag/dubbo-2.7.5 不建议大规模生产使用 3 2.7.4.1 bugfixes and enhancements of 2.7.3 推荐生产使用 4 2.7.3 bigfixes of and enhancements of 2.7.2 推荐生产使用 5 2.7.2 bigfixes of and enhancements of 2.7.1 不建议大规模生产使用 6 2.7.1 bigfixes of and enhancements of 2.</description></item><item><title>AOP 与可扩展机制</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/sourcecode/aop_and_extension/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/sourcecode/aop_and_extension/</guid><description>1. extension 模块与 init 方法 1.1 接口与实现 golang 中的一个接口往往伴随多个实现类，dubbo-go 提供了针对接口实现类的可插拔可扩展机制。降低模块之间的耦合性，方便开发者引入、自定义组件。
1.2 golang 中的 init 方法 init 方法作为 golang 中特殊的方法，用户引入一组模块后，会在程序启动时率先执行这些模块内的init 方法，进行加载逻辑，该方法是dubbogo注册扩展组件的重要方式。
1.3 extension 模块 在框架源码中，有一个特殊的模块: common/extension ，这一模块负责缓存所有可扩展组件的实现。
以负载均衡模块为例：common/extension/loadbalance.go
package extension import ( &amp;#34;dubbo.apache.org/dubbo-go/v3/cluster/loadbalance&amp;#34; ) var loadbalances = make(map[string]func() loadbalance.LoadBalance) // SetLoadbalance sets the loadbalance extension with @name // For example: random/round_robin/consistent_hash/least_active/... func SetLoadbalance(name string, fcn func() loadbalance.LoadBalance) { loadbalances[name] = fcn } // GetLoadbalance finds the loadbalance extension with @name func GetLoadbalance(name string) loadbalance.</description></item><item><title>client</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-1.5/configuration/client/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-1.5/configuration/client/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
client 第一步：编写消费端的服务 编写需要被编码的结构体，由于使用 Hessian2 作为编码协议，User 需要实现 JavaClassName 方法，它的返回值在dubbo中对应User类的类名。
type User struct { Id string Name string Age int32 Time time.Time } func (u User) JavaClassName() string { return &amp;#34;org.apache.dubbo.User&amp;#34; } 与服务端不同的是，提供服务的方法作为结构体的参数，不需要编写具体业务逻辑。另外，Provider 不对应dubbo中的实现，而是对应一个接口。
type UserProvider struct { GetUser func(ctx context.Context, req []interface{}, rsp *User) error } func (u *UserProvider) Reference() string { return &amp;#34;UserProvider&amp;#34; } 注册服务和对象
func init() { config.SetConsumerService(userProvider) hessian.RegisterPOJO(&amp;amp;User{}) } 第二步：编写消费端主程序 引入必需的dubbo-go包
import ( hessian &amp;#34;github.com/apache/dubbo-go-hessian2&amp;#34; _ &amp;#34;github.</description></item><item><title>dubbo-go 3.0 新特性</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/preface/3.0_feature/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/preface/3.0_feature/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo-go 3.0 新特性介绍 1. Triple 协议 1.1 概述 通信层面
Triple 协议，也称为Dubbo3协议，是基于HTTP2 + gRPC协议，增加特定字段和逻辑的扩展协议，保证了和原生gRPC协议互通。在此基础之上，Triple 新协议将更原生地支持 Dubbo 服务治理能力。并支持流式RPC调用。
简单来说，可以理解为 Triple = gRPC + Dubbo
序列化
Triple 协议使用高效的PB序列化方式，并在此基础之上增加序列化协议的可扩展支持。
用户开发习惯：
Triple 服务在开发前需要预定义.proto文件，对于习惯在编码前先定义IDL的Go语言开发者带来便捷。不同于符合java编程习惯的，定义JavaClassName用于描述接口的 Dubbo-go 1.x版本。
跨语言互通性：
可与 Dubbo-Java 实现跨语言互通。
2. 应用级服务发现 2.1 简介 在服务注册阶段，服务端实例将应用级别的注册信息，主要包含从应用名到实例IP的映射注册到注册中心。在服务发现阶段，客户端实例，通过注册中心获取到需要请求的服务实例IP。进入服务自省阶段，服务自省过程为通过应用信息获取接口信息的过程。如上图，包含两种模式：
remote模式：通过元数据中心（例如 zk ）获取应用到接口元数据的映射 local模式：直接通过服务端获取应用到接口元数据的映射（通过 Dubbo 协议针对 Metadata Service 发起 RPC 调用） 经过服务自省后，客户端正式向对应实例发起调用。这样做最明显的好处是减少了注册中心的数据量，即注册中心只保存了应用级别的数据。
用户在使用 Dubbo-go 3.0的应用级服务发现能力时，可以仿照示例，直接在配置文件中配置服务自省模式和元数据中心信息，引入依赖，开启应用级别服务发现。
2.2 应用级服务发现介绍文章 应用级服务发现解析
3. Mesh 路由由规则 用户可定义路由文件：
virtual_service.yaml
以及 dist_rule.yml
框架可根据路由文件针对特定的请求进行流量转发。
4. 相关文章 阿里云官方介绍文章：《Dubbo 3.</description></item><item><title>Dubbo-go 协议快速开始</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/quickstart/quickstart_dubbo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/quickstart/quickstart_dubbo/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo-go 协议快速开始 1. 环境安装 1.1 安装 Go 语言环境 建议使用最新版 go 1.17
go version &amp;gt;= go 1.15
【Go 语言官网下载地址】
构建如下文件目录，使用命令 go mod init dubbo3-demo 初始化 go module。
quickstart ├── api │ └── api.go ├── client │ ├── client.go │ └── dubbogo.yml ├── go.mod └── server ├── dubbogo.yml └── server.go 1.2 启动zookeeper 选择您喜欢的方式启动zk，如您安装docker-compose可直接从文件启动:
zookeeper.yml:
version: &amp;#39;3&amp;#39; services: zookeeper: image: zookeeper ports: - 2181:2181 restart: on-failure docker-compose -f ./zookeeper.yml up -d 2.</description></item><item><title>Dubbo的应用和接口</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/sourcecode/app_and_interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/sourcecode/app_and_interface/</guid><description>Dubbogo 服务层级 Dubbogo 服务层级为两个级别：分别是应用级别(App Level)和接口级别(Interface Level)，该服务分层与框架配置结构息息相关。
如下图所示，可以看到，应用级别的组件以浅红色标注，接口级别的组件以浅蓝色标注：
1. 应用级别组件 应用级别组件的特点：被当前应用的所有接口级别组件共用。
应用级别的主要组件如下：
应用信息模块
包含应用维度相关信息，包括应用名、版本号、数据上报方式等
Consumer 模块
Consumer 模块负责客户端相关信息，包括一个或多个引用（Reference）结构，以及超时、客户端过滤器（consumer filter）等相关信息。
Provider 模块
Provider 模块负责服务端相关信息，包括一个或多个服务（Service）结构、服务端过滤器（provider filter）等相关信息。
注册中心（Registry）模块
注册中心模块负责定义好所要使用的一系列注册中心，例如框架支持的ZK、Nacos、ETCD等中间件。应用级别的注册模块只负责声明，由接口级别的组件进行引用，引用时以用户自定义的注册中心ID（registryID) 作为索引。
协议（Protocol）模块
协议模块只存在于服务端。
协议模块关心服务的暴露信息，例如协议名、服务监听IP、端口号等信息。协议模块属于应用级别，只负责声明，由接口级别的组件进行引用，引用时以用户自定义的协议ID（protocolID) 作为索引。
元数据中心模块
元数据中心类似于注册中心模块，负责声明框架需要使用的元数据中心，从而将元数据成功上报。
配置中心模块
路由模块
日志模块
监控模块
2. 接口级别组件 服务（Service）模块
服务模块被使用于任何暴露的服务，声明接口暴露所需的信息，包括例如接口名、协议、序列化方式等，负责单个服务接口的暴露。
引用（Reference）模块
引用模块被使用于需要调用的远程服务的客户端，其声明了需要请求接口所需的信息，包括例如接口名、协议、序列化方式等、负责特定协议的抽象，参与客户端的生成。
3. 说明 暴露的服务是接口级别的，一个用户定义的 Provider Struct/一个用户定义的Consumer Struct，对应一个Service/Reference 模块，一个应用可以同时存在Consumer 模块和 Provider 模块，因此可以同时存在多个Service/Reference 模块。</description></item><item><title>Dubbo-go 3.0 自定义filter</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/custom-filter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/custom-filter/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo-go 3.0 自定义Filter组件 参考samples dubbo-go-samples/filter
1. Filter 概念 // Filter interface defines the functions of a filter // Extension - Filter type Filter interface { // Invoke is the core function of a filter, it determines the process of the filter Invoke(context.Context, protocol.Invoker, protocol.Invocation) protocol.Result // OnResponse updates the results from Invoke and then returns the modified results. OnResponse(context.Context, protocol.Result, protocol.Invoker, protocol.Invocation) protocol.Result } Filter 可以加载在 Consumer 端或者 Provider端。当加载在 Consumer 端，其Invoke函数调用的下游为网络层，OnResponse 为请求结束从网络层获取到返回结果后被调用。当加载在 Provider 端，其 Invoke 函数调用的下游为用户代码，OnResponse 为用户代码执行结束后向下传递至网络层前被调用。</description></item><item><title>go-java 3.0 互通示例</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/go_java_interactive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/go_java_interactive/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Go-Java 互通示例 准备工作 环境 JDK 8，Golang &amp;gt;= 1.15，Dubbo 3.0.2，zookeeper 启动，
Go- Java 互通前提 Go/Java 定义的传输结构一致
PB 序列化 proto for Go
// The response message containing the greetings message User { string name = 1; string id = 2; int32 age = 3; } proto for Java
// The response message containing the greetings message User { string name = 1; string id = 2; int32 age = 3; } Hessian 序列化 POJO for Go，需参考 Dubbo-go Hessian 序列化支持文档</description></item><item><title>Dubbo-go 数据上报</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/metrics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/metrics/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo-go 3.0 数据上报 参考Samples： dubbo-go-samples/metrics
1. 数据上报配置 在不指定 metrics: 字段的时候，默认开启拉模式 prometheus 数据上报，端口默认为9090，监听path默认为/metrics。可参考如下服务端配置例子来定制化。
dubbo: application: version: 3.0.0-rc3 # 版本号 metrics: enable: true # default is true path: /custom-metrics-path # default is /metrics port: 9091 # default is 9090 namespace: dubbo # default is dubbo 作为数据上报 metrics 的前缀 registries: myzk: protocol: zookeeper address: localhost:2181 protocols: triple: name: tri port: 20000 provider: services: GreeterProvider: group: dubbo-go # 所属 group，需要与客户端一致 interface: com.apache.dubbo.HelloService # 接口名 2.</description></item><item><title>如何安装 Protocol Buffer Compiler</title><link>https://dubbo.apache.org/zh-cn/overview/reference/protoc-installation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/protoc-installation/</guid><description>虽然不是强制性的，但 Apache Dubbo 支持使用 Protocol Buffers (proto3版本) 作为服务定义和序列化协议。
在 Protocol buffer 体系下，我们使用 .proto 文件定义服务和消息体格式，使用 protoc 编译器编译 .proto 文件，你可以使用以下几种方式安装 protoc。
使用包管理器安装 在 Linux 或 macOS 环境下，你可以使用包管理器安装 protoc。
Warning 一定要注意检查所安装 protoc 的版本！ 检查方法如下文说述，因为有时一些包管理器安装的 protoc 版本是严重过时的。
下一节所展示的 使用预先编译好的二进制文件安装 可以确保你安装正确的 protoc 版本。
Linux，使用 apt 或者 apt-get，比如：
$ apt install -y protobuf-compiler $ protoc --version # Ensure compiler version is 3+ MacOS，使用 Homebrew:
$ brew install protobuf $ protoc --version # Ensure compiler version is 3+ 使用预先编译好的二进制文件安装（适用任何操作系统） 参考以下步骤安装 最新版本 的 protoc 二进制包：</description></item><item><title>dubbo-go 3.0 示例仓库</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/samples_repo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/samples_repo/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
为了方便 Dubbo-go 框架用户的使用，我们提供了 Samples 仓库以供用户参考：
【Dubbo-go-samples 仓库地址】
1. Samples 仓库包含的例子 config-api: 使用 API 进行配置初始化 configcenter: 使用不同的配置中心，目前支持三种：zookeeper、apollo、和 nacos context: 如何使用上下文传递 attachment direct: 直连模式 game: 游戏服务例子 generic: 泛化调用 rpc: RPC 调用例子, 包含 Triple、Dubbo等协议以及跨语言/gRPC互通示例 helloworld: RPC调用入门例子 logger: 日志例子 registry: 展示与不同注册中心的对接，包含了 zk、nacos、etcd metrics: 数据上报 filter: 使用提供filter和自定义filter的例子 registry/servicediscovery：应用级服务发现例子 router: 路由例子 tracing: 链路追踪例子 2. 如何运行 目前有三种方式来运行 dubbo-go 的示例:
通过 bash 命令快速开始: 通过简单的命令行启动样例以及进行单元测试 在 IDE 中快速开始，这也是推荐的方式: 在工程 &amp;ldquo;.run&amp;rdquo; 子目录下，提供了所有示例的 GoLand 运行配置文件，因此用户可以简单在 IDE 中单击运行所有的示例。 在 IDE 中手工配置并运行: 为了完整性的目的，也为了万一您不使用 GoLand 而使用其他的 IDE，这里也提供了如何一步一步的配置的指南，帮助用户理解如何在 IDE 中配置，运行或者调试 dubbo-go 的示例。 2.</description></item><item><title>service providers</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-1.5/configuration/provider/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-1.5/configuration/provider/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
service providers 第一步：编写提供端的服务 编写需要被编码的结构体，由于使用 Hessian2 作为编码协议，User 需要实现 JavaClassName 方法，它的返回值在dubbo中对应User类的类名。
type User struct { Id string Name string Age int32 Time time.Time } func (u User) JavaClassName() string { return &amp;#34;org.apache.dubbo.User&amp;#34; } 编写业务逻辑，UserProvider 相当于dubbo中的一个服务实现。需要实现 Reference 方法，返回值是这个服务的唯一标识，对应dubbo的 beans 和 path 字段。
type UserProvider struct { } func (u *UserProvider) GetUser(ctx context.Context, req []interface{}) (*User, error) { println(&amp;#34;req:%#v&amp;#34;, req) rsp := User{&amp;#34;A001&amp;#34;, &amp;#34;hellowworld&amp;#34;, 18, time.Now()} println(&amp;#34;rsp:%#v&amp;#34;, rsp) return &amp;amp;rsp, nil } func (u *UserProvider) Reference() string { return &amp;#34;UserProvider&amp;#34; } 注册服务和对象</description></item><item><title>Triple 协议快速开始</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/quickstart/quickstart_triple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/quickstart/quickstart_triple/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Triple 协议快速开始 1. 环境安装 1.1 安装Go语言环境 建议使用最新版 go 1.17
go version &amp;gt;= go 1.15
【Go 语言官网下载地址】
将 $GOPATH/bin 加入环境变量
1.2 安装序列化工具protoc 【protoc 下载地址】
1.3 安装 protoc-gen-go, proto-gen-go-triple 编译插件 本章 quick start 按照最新版示例和组件进行介绍。
依赖 Dubbo-go Triple protoc-gen-go-triple 适配版本号 v3.0.0-rc4-1 v1.1.3 v1.0.2 适配版本号 v3.0.0-rc3 v1.0.9 v1.0.0 export GO111MODULE=&amp;#34;on&amp;#34; export GOPROXY=&amp;#34;https://goproxy.cn&amp;#34; go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.26.0 go install github.com/dubbogo/tools/cmd/protoc-gen-go-triple@v1.0.2 确保上述protoc 和安装的 protoc-gen-go-triple 位于$(GOPATH)/bin, 在系统环境变量内
$ protoc --version libprotoc 3.14.0 $ protoc-gen-go --version protoc-gen-go v1.</description></item><item><title>Dubbo-go 3.0 异常回传</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/exception_response/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/exception_response/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Triple 协议异常回传 参考samples dubbo-go-samples/error
用户异常回传介绍 用户可以在 provider 端生成用户定义的异常信息，可以记录异常产生堆栈，triple 协议可保证将用户在客户端获取到异常 message ，并可以查看报错堆栈，便于定位问题。
注意返回 error 非 nil 时，框架不负责其他返回值的传递。
在Triple provider 端返回异常，以 pb 序列化为例： package main import ( &amp;#34;context&amp;#34; ) import ( &amp;#34;dubbo.apache.org/dubbo-go/v3/common/logger&amp;#34; // 使用可以记录对战信息的异常库，此处以 &amp;#34;github.com/pkg/errors&amp;#34; 为例 &amp;#34;github.com/pkg/errors&amp;#34; ) import ( triplepb &amp;#34;github.com/apache/dubbo-go-samples/api&amp;#34; ) // 一个实现了 pb 接口的服务提供结构 type ErrorResponseProvider struct { triplepb.UnimplementedGreeterServer } // 回传错误的接口 func (s *ErrorResponseProvider) SayHello(ctx context.Context, in *triplepb.HelloRequest) (*triplepb.User, error) { logger.Infof(&amp;#34;Dubbo3 GreeterProvider get user name = %s\n&amp;#34; + in.</description></item><item><title>Triple协议Http标准能力增强-多Content-Type支持</title><link>https://dubbo.apache.org/zh-cn/overview/reference/proposals/support-more-content-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/proposals/support-more-content-types/</guid><description>Triple协议Http标准能力增强-多Content-Type支持 本文主要介绍Triple对更多HTTP标准Content-Type的支持方式，以及服务该如何接收这些请求。
概述 Triple目前支持两种序列化方式：Json和protobuf，对应的ContentType：
application/json application/grpc+proto 这在消费者和提供者都是后端服务时没有问题。但对于浏览器客户端，其可能发送更多类型的ContentType，需要服务端支持解码，如：
multipart/formdata text/plain application/x-www-form-urlencoded application/xml Rest已基本实现上述解码能力，使Triple实现这些能力是让Triple服务端与浏览器客户端完全互通的重要一步。
用法 multipart/formdata POST /org.apache.dubbo.samples.tri.noidl.api.PojoGreeter/greetPojo HTTP/1.1 Host: 192.168.202.1:50052 Content-Type: multipart/form-data; boundary=example-part-boundary Accept: application/json --example-part-boundary Content-Disposition: form-data; name=&amp;#34;username&amp;#34; Content-Type: text/plain LuYue --example-part-boundary Content-Disposition: form-data; name=&amp;#34;userdetail&amp;#34; Content-Type: application/json { &amp;#34;location&amp;#34;:&amp;#34;beijing&amp;#34;, &amp;#34;username&amp;#34;:&amp;#34;LuYue&amp;#34; } --example-part-boundary Content-Disposition: form-data; name=&amp;#34;userimg&amp;#34;;filename=&amp;#34;user.jpeg&amp;#34; Content-Type: image/jpeg &amp;lt;binary-image data&amp;gt; --example-part-boundary-- 接收：
@Override public ServerResponse greetPojo(String username, User user, byte[] attachment) { //LuYue System.out.println(username); //user.name=Luyue;user.location=beijing System.out.println(user); //&amp;lt;binary-image data&amp;gt; System.out.println(new String(attachment, StandardCharsets.UTF_8)); return new ServerResponse(&amp;#34;Server Received:&amp;#34;+username); } 每一个 part 根据其 Content-Type 解码 若方法参数是 byte[] 或 Byte[]，对应字段不会解码 响应使用 application/json 编码 application/x-www-form-urlencoded POST /org.</description></item><item><title>错误码机制的介绍</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/faq/intro/</guid><description>背景 Dubbo 内部依赖的 Logger 抽象层提供了日志输出能力，但是大部分的异常日志都没有附带排查说明，导致用户看到异常后无法进行处理。
为了解决这个问题，自 Dubbo 3.1 版本开始，引入了错误码机制。其将官方文档中的错误码 FAQ 与日志框架连接起来。在日志抽象输出异常的同时附带输出对应的官网文档链接，引导用户进行自主排查。
错误码格式 [Cat]-[X]
两个空格均为数字。其中第一个数字为类别，第二个数字为具体错误码。
提示显示的格式 This may be caused by ..., go to https://dubbo.apache.org/faq/[Cat]/[X] to find instructions. 另外在这句话后可以指定补充的信息（即 extendedInformation）。
显示的实例 [31/07/22 02:43:07:796 CST] main WARN support.AbortPolicyWithReport: [DUBBO] Thread pool is EXHAUSTED! Thread Name: Test, Pool Size: 0 (active: 0, core: 1, max: 1, largest: 0), Task: 0 (completed: 0), Executor status:(isShutdown:false, isTerminated:false, isTerminating:false), in dubbo://10.20.130.230:20880!, dubbo version: , current host: 10.</description></item><item><title>发布使用不同协议的多个服务，通过单端口监听</title><link>https://dubbo.apache.org/zh-cn/blog/1/01/01/%E5%8F%91%E5%B8%83%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E9%80%9A%E8%BF%87%E5%8D%95%E7%AB%AF%E5%8F%A3%E7%9B%91%E5%90%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/1/01/01/%E5%8F%91%E5%B8%83%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E9%80%9A%E8%BF%87%E5%8D%95%E7%AB%AF%E5%8F%A3%E7%9B%91%E5%90%AC/</guid><description>通过对protocol进行配置，dubbo3可以支持端口的协议复用。 比如使用Triple协议启动端口复用后，可以在相同的端口上为服务增加 Dubbo协议支持，以及Qos协议支持。这些协议的识别都是由一个统一的端口复用 服务器进行处理的，可以用于服务的协议迁移，并且可以节约端口以及相关的资源，减少运维的复杂性。
在服务的创建阶段，通过从Config层获取到服务导出的协议配置从而创建不同的Protocol对象进行导出。在导出的过程 中，如果不是第一次创建端口复用的Server，那么Exchanger会将Protcol层传递的数据保存到Server，用于后续处理该协议类型的消息。
当客户端的消息传递过来后，首先会通过Server传递给ProtocolDetector，如果完成了识别，那么就会标记该客户端为对应的协议。并通过WireProtocol配置对应的处理逻辑，最后交给ChannelOperator完成底层的IO框架和对应的Dubbo框架的处理逻辑的绑定。
以上的协议识别完成之后，Channel已经确定了如何处理远程的客户端消息，通过对应的ServerPipeline进行处理即可（在处理的过程中也会根据配置信息决定消息的处理线程）。
使用方式 在同一主机上部署多个服务或需要通过负载均衡器访问多个服务。
参考用例 https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-port-unification
配置方式 关于Dubbo支持的配置方式，可以参考配置说明
服务多协议导出 ext-protocol参数支持配置多个不同的协议，协议之间通过&amp;quot;,&amp;ldquo;进行分隔。
xml 配置 &amp;lt;dubbo:protocol name=&amp;#34;dubbo&amp;#34; port=&amp;#34;-1&amp;#34; ext-protocol=&amp;#34;tri,&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;greetingService&amp;#34; class=&amp;#34;org.apache.dubbo.demo.provider.GreetingServiceImpl&amp;#34;/&amp;gt; &amp;lt;dubbo:service delay=&amp;#34;5000&amp;#34; version=&amp;#34;1.0.0&amp;#34; group=&amp;#34;greeting&amp;#34; timeout=&amp;#34;5000&amp;#34; interface=&amp;#34;org.apache.dubbo.demo.GreetingService&amp;#34; ref=&amp;#34;greetingService&amp;#34; protocol=&amp;#34;dubbo&amp;#34;/&amp;gt; API 配置 ProtocolConfig config = new ProtocolConfig(CommonConstants.TRIPLE, -1); config.setExtProtocol(CommonConstants.DUBBO+&amp;#34;,&amp;#34;); yaml 配置 dubbo: application: name: dubbo-springboot-demo-provider protocol: name: tri port: -1 ext-protocol: dubbo, properties 配置 dubbo.protocol.name=tri dubbo.protocol.ext-protocol=dubbo, dubbo.protocol.port=20880 Qos接入 Qos模块导入 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dubbo-qos&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 完成Qos模块的导入之后，相关的配置项可参考Qos操作手册进行配置。
默认情况下，基于端口复用的Qos服务在模块导入后是启动的。
使用方式 Qos使用 将Qos协议接入到端口复用的场景下，需要在建立连接之后，客户端先向服务端发送消息，对比将Qos协议通过单个端口提供服务，端口复用版的Qos协议在处理telnet连接的情况下需要用户执行一些操作，完成协议识别（二选一）。</description></item><item><title>Dubbo-go 泛化调用</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/generic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/generic/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo-go 泛化调用 1. Dubbo-go 泛化调用 Java Server 使用 Triple 协议 + hessian2 序列化方案
可参考Dubbo-go 3.0 泛化调用文档
1.1 Java-Server启动 传输结构定义 package org.apache.dubbo; import java.io.Serializable; import java.util.Date; public class User implements Serializable { private String id; private String name; private int age; private Date time = new Date(); } 接口定义 package org.apache.dubbo; import java.util.ArrayList; import java.util.List; import java.util.Map; //import org.apache.dubbo.rpc.filter.GenericFilter; public interface UserProvider { User GetUser1(String userId); } 1.2 Go-Client 泛化调用 此处展示以 API 的形式构造泛化接口引用</description></item><item><title>Dubbo-go 的应用和接口</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/concept/app_and_interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/concept/app_and_interface/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo-go 服务层级 Dubbo-go 服务层级为两个级别：分别是应用级别(App Level)和接口级别(Interface Level)，该服务分层与框架配置结构息息相关。
如下图所示，可以看到，应用级别的组件以浅红色标注，接建立如下文件目录口级别的组件以浅蓝色标注：
1. 应用级别组件 应用级别组件的特点：被当前应用的所有接口级别组件共用。
应用级别的主要组件如下：
应用信息模块
包含应用维度相关信息，包括应用名、版本号、数据上报方式等
Consumer 模块
Consumer 模块负责客户端相关信息，包括一个或多个引用（Reference）结构，以及超时、客户端过滤器（consumer filter）等相关信息。
Provider 模块
Provider 模块负责服务端相关信息，包括一个或多个服务（Service）结构、服务端过滤器（provider filter）等相关信息。
注册中心（Registry）模块
注册中心模块负责定义好所要使用的一系列注册中心，例如框架支持的ZK、Nacos、ETCD等中间件。应用级别的注册模块只负责声明，由接口级别的组件进行引用，引用时以用户自定义的注册中心ID（registryID) 作为索引。
协议（Protocol）模块
协议模块只存在于服务端。
协议模块关心服务的暴露信息，例如协议名、服务监听IP、端口号等信息。协议模块属于应用级别，只负责声明，由接口级别的组件进行引用，引用时以用户自定义的协议ID（protocolID) 作为索引。
元数据中心模块
元数据中心类似于注册中心模块，负责声明框架需要使用的元数据中心，从而将元数据成功上报。
配置中心模块
路由模块
日志模块
监控模块
2. 接口级别组件 服务（Service）模块
服务模块被使用于任何暴露的服务，声明接口暴露所需的信息，包括例如接口名、协议、序列化方式等，负责单个服务接口的暴露。
引用（Reference）模块
饮用模块被使用于需要调用的远程服务的客户端，其声明了需要请求接口所需的信息，包括例如接口名、协议、序列化方式等、负责特定协议的抽象，参与客户端的生成。
3. 说明 暴露的服务是接口级别的，一个用户定义的 Provider Struct/一个用户定义的Consumer Struct，对应一个Service/Reference 模块，一个应用可以同时存在Consumer 模块和 Provider 模块，因此可以同时存在多个Service/Reference 模块。</description></item><item><title>架构</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/preface/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/preface/architecture/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
架构 节点说明 Registry : dubbo-go中负责服务注册与发现的注册中心 Consumer : 调用远程服务的服务消费方 Provider : 暴露服务的服务提供方 过程说明 0. register : 当服务提供方在启动的时候，会自动将自己的服务注册到注册中心 1. subscribe : 服务消费方会在启动的时候，向注册中心订阅自己所需要的服务 2. notify : 注册中心返回服务注册的信息给到服务消费方，当订阅的服务发生变更，会推送变更的数据给到消费方 3. invoke : 服务消费者根据从注册中心获得的服务地址，经过负载均衡算法选出一个合适的服务地址发起请求</description></item><item><title>架构</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/sourcecode/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/sourcecode/architecture/</guid><description>架构说明 节点说明 Registry : dubbo-go中负责服务注册与发现的注册中心 Consumer : 调用远程服务的服务消费方 Provider : 暴露服务的服务提供方 过程说明 0. register : 当服务提供方在启动的时候，会自动将自己的服务注册到注册中心 1. subscribe : 服务消费方会在启动的时候，向注册中心订阅自己所需要的服务 2. notify : 注册中心返回服务注册的信息给到服务消费方，当订阅的服务发生变更，会推送变更的数据给到消费方 3. invoke : 服务消费者根据从注册中心获得的服务地址，经过负载均衡算法选出一个合适的服务地址发起请求</description></item><item><title>架构设计</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/developer/design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/developer/design/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
源文件：dubbo-go-arch.pptx</description></item><item><title>快速开始</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-1.5/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-1.5/quick-start/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
快速开始 通过一个 hellowworld 例子带领大家快速上手Dubbo-go框架。
协议：Dubbo 编码：Hessian2
注册中心：Zookeeper
环境 Go编程环境 启动zookeeper服务，也可以使用远程实例 从服务端开始 第一步：编写 Provider 结构体和提供服务的方法 https://github.com/dubbogo/dubbo-samples/blob/master/golang/helloworld/dubbo/go-server/app/user.go
编写需要被编码的结构体，由于使用 Hessian2 作为编码协议，User 需要实现 JavaClassName 方法，它的返回值在dubbo中对应User类的类名。 type User struct { Id string Name string Age int32 Time time.Time } func (u User) JavaClassName() string { return &amp;#34;com.ikurento.user.User&amp;#34; } 编写业务逻辑，UserProvider 相当于dubbo中的一个服务实现。需要实现 Reference 方法，返回值是这个服务的唯一标识，对应dubbo的 beans 和 path 字段。 type UserProvider struct { } func (u *UserProvider) GetUser(ctx context.Context, req []interface{}) (*User, error) { println(&amp;#34;req:%#v&amp;#34;, req) rsp := User{&amp;#34;A001&amp;#34;, &amp;#34;hellowworld&amp;#34;, 18, time.</description></item><item><title>Dubbo-go的配置</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/concept/configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/concept/configuration/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo-go 配置项 1. 配置结构 1.1 框架配置结构 根配置 ProviderConfig ConsumerConfig 1.2 配置例子 dubbo: application: # 应用配置 name: dubbo-go module: local version: 1.0.0 owner: zhaoyunxing organization: dubbo-go metadata-type: local # 元数据上报方式，默认为本地 metadata-report: # 元数据上报配置, 不包含此字段则不开启元数据上报，应用级服务发现依赖此字段，参考例子：https://github.com/apache/dubbo-go-samples/tree/45a0d843b54e4922c240900e63516176cc7da4f6/registry/servicediscovery protocol: nacos # 元数据上报方式，支持nacos/zookeeper address: 127.0.0.1:8848 username: &amp;#34;&amp;#34; password: &amp;#34;&amp;#34; timeout: &amp;#34;3s&amp;#34; group: &amp;#34;dubbo&amp;#34; protocols: tripleProtocol: # triple协议定义，参考例子https://github.com/apache/dubbo-go-samples/tree/f7febed9d686cb940ea55d34b5baa567d7574a44/rpc/tri name: tri # 网络协议，支持tri/dubbo/jsonrpc/grpc port: 20001 dubboProtocol: # dubbo协议定义，参考例子https://github.com/apache/dubbo-go-samples/tree/f7febed9d686cb940ea55d34b5baa567d7574a44/rpc/dubbo name: dubbo port: 20000 params: # dubbo 传输层配置，此字段不配置则使用协议默认值 reconnect-interval: 0 connection-number: 1 heartbeat-period: 5s session-timeout: 180s pool-size: 64 pool-ttl: 600 getty-session-param: compress-encoding: false tcp-no-delay: true tcp-keep-alive: true keep-alive-period: 120s tcp-r-buf-size: 262144 tcp-w-buf-size: 65536 pkg-rq-size: 1024 pkg-wq-size: 512 tcp-read-timeout: 1s tcp-write-timeout: 5s wait-timeout: 1s max-msg-len: 1024000 session-name: client config-center: # 配置中心，参考例子：https://github.</description></item><item><title>扩展点开发指南</title><link>https://dubbo.apache.org/zh-cn/docs/references/spis/dubbo-spi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/references/spis/dubbo-spi/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
1.简介 SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。SPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI，我们可以很容易的对 Dubbo 进行拓展。 Dubbo 中，SPI 主要有两种用法，一种是加载固定的扩展类，另一种是加载自适应扩展类。这两种方式会在下面详细的介绍。 需要特别注意的是: 在 Dubbo 中，基于 SPI 扩展加载的类是单例的。
1.1 加载固定的扩展类 如果让你来设计加载固定扩展类，你会怎么做了？ 一种常见思路是读取特定目录下的配置文件，然后解析出全类名，通过反射机制来实例化这个类，然后将这个类放在集合中存起来，如果有需要的时候，直接从集合中取。Dubbo 中的实现也是这么一个思路。 不过在 Dubbo 中，实现的更加完善，它实现类了 IOC 和 AOP 的功能。IOC 就是说如果这个扩展类依赖其他属性，Dubbo 会自动的将这个属性进行注入。这个功能如何实现了？一个常见思路是获取这个扩展类的 setter 方法，调用 setter 方法进行属性注入。AOP 指的是什么了？这个说的是 Dubbo 能够为扩展类注入其包装类。比如 DubboProtocol 是 Protocol 的扩展类，ProtocolListenerWrapper 是 DubboProtocol 的包装类。
1.2 加载自适应扩展类 先说明下自适应扩展类的使用场景。比如我们有需求，在调用某一个方法时，基于参数选择调用到不同的实现类。和工厂方法有些类似，基于不同的参数，构造出不同的实例对象。 在 Dubbo 中实现的思路和这个差不多，不过 Dubbo 的实现更加灵活，它的实现和策略模式有些类似。每一种扩展类相当于一种策略，基于 URL 消息总线，将参数传递给 ExtensionLoader，通过 ExtensionLoader 基于参数加载对应的扩展类，实现运行时动态调用到目标实例上。</description></item><item><title>扩展点开发指南</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/dubbo-spi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/dubbo-spi/</guid><description>1. Dubbo SPI 扩展简介 Dubbo 中的扩展机制与 JDK 标准的 SPI 扩展点 原理类似。Dubbo 对其做了一定的改造与加强：
JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。 如果扩展点加载失败，JDK SPI 没给出详细信息，不方便定位问题，Dubbo SPI 在失败时记录真正的失败原因，并打印出来 增加 IOC、AOP 能力 增加排序能力 增加条件激活能力 提供了一系列更灵活的 API，如获取所有 SPI 扩展实现、根据名称查询某个扩展实现、根据类型查询扩展实现、查询匹配条件的扩展实现等。 1.1 SPI定义 Dubbo 中的 SPI 插件是标准的 Java Interface 定义，并且必须包含 @org.apache.dubbo.common.extension.SPI 注解：
@SPI(value = &amp;#34;dubbo&amp;#34;, scope = ExtensionScope.FRAMEWORK) public interface Protocol { // ... } @SPI 注解的定义如下：
@Documented @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE}) public @interface SPI { /** * default extension name */ String value() default &amp;#34;&amp;#34;; /** * scope of SPI, default value is application scope.</description></item><item><title>Dubbo-go v3 统一路由规则</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/mesh_router/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/mesh_router/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo-go v3 Mesh路由规则 路由规则介绍 《微服务Mesh路由方案草案V2》
简介 路由规则，简单来说就是根据特定的条件，将特定的请求流量发送到特定的服务提供者。从而实现流量的分配。
在 Dubbo3 统一路由规则的定义中，需要提供两个yaml格式的资源：virtual service 和 destination rule。其格式和 service mesh 定义的路由规则非常相似。
virtual service 定义host，用于和destination rule建立联系。
定义 service 匹配规则
定义 match 匹配规则
匹配到特定请求后，进行目标集群的查找和验证，对于为空情况，使用 fallback 机制。
destination rule 定义特定集群子集，以及子集所适配的标签，标签从 provider 端暴露的 url 中获取，并尝试匹配。
提供能力 基于配置中心的路由配置 sample示例参见Mesh Router
1. 路由规则文件注解 路由规则只针对客户端，对于服务端，只需要在服务提供时打好特定的参数标签即可。
1.1 virtual-service apiVersion: service.dubbo.apache.org/v1alpha1 kind: VirtualService metadata: {name: demo-route} spec: dubbo: # 使用正则表达式匹配service名，只有个满足该service名的请求才能路由。 # 就此例子来说，不满足service名的请求会直接找不到provider # - services: # - { regex: org.apache.dubbo.UserProvider* } - routedetail: - match: # 匹配规则，如果（sourceLabel）客户端url满足存在参数 `trafficLabel: xxx` 的才能匹配成功 - sourceLabels: {trafficLabel: xxx} name: xxx-project route: # 一旦匹配上述match规则，将选择 dest_rule 里定义的名为 isolation 的子集 - destination: {host: demo, subset: isolation} - match: - sourceLabels: {trafficLabel: testing-trunk} name: testing-trunk route: # 一旦匹配上述match规则，将选择 dest_rule 里定义的名为 testing-trunk 的子集 - destination: {host: demo, subset: testing-trunk} - name: testing # 没有match，兜底逻辑，上述不满足后一定会被匹配到。 route: - destination: {host: demo, subset: testing} services: - {exact: com.</description></item><item><title>Dubbo-go 3.0 动态配置</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/config-center-dynamic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/config-center-dynamic/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbogo 3.0 配置中心和配置监听 1. 配置中心概念 配置中心即为在分布式场景下，无法将最新的框架配置文件和应用程序绑定在一起，可以指定好配置中心的信息，例如配置中心类型和地址，并在框架启动时从配置中心拉取相应配置进行启动。
2. 配置中心的配置 参考仓库：dubbo-go-samples/configcenter
dubbogo.yml
dubbo: config-center: protocol: nacos address: 127.0.0.1:8848 data-id: dubbo-go-samples-configcenter-nacos-server namespace: myNamespaceID # 可选配置 nacos namespace ID, 默认是 public group: mygroup # 可选配置 nacos group, 默认是 DEFAULT_GROUP 配置中心 nacos 内
group 默认为 dubbo
dataID 为指定的id：dubbo-go-samples-configcenter-nacos-server
写入框架配置例如下面，即可正常启动。
dubbo: registries: demoZK: protocol: zookeeper timeout: 3s address: 127.0.0.1:2181 protocols: triple: name: tri port: 20000 provider: services: GreeterProvider: interface: com.apache.dubbo.sample.basic.IGreeter 3. Dubbogo 动态配置 API Config API 为 dubbogo 3.</description></item><item><title>Dubbo-go 3.0 启动时检查</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/start-check/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/start-check/</guid><description> 此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
启动时检查 在启动时检查依赖的服务是否可用
Dubbo-go 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止应用初始化完成，以便上线时，能及早发现问题，默认 check=&amp;ldquo;true&amp;rdquo;，并等待3s。
可以通过 check=&amp;ldquo;false&amp;rdquo; 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。
关闭 check 后，请注意 provider数量比较多时， consumer 订阅 provider 生成服务字典可能会有一定延迟，如果 consumer 一启动就对外提供服务， 可能会造成&amp;quot;冷启动&amp;quot;。所以在这个时候，请对服务进行预热。
示例：
dubbo: consumer: check : false reference: myserivce: check: true</description></item><item><title>Dubbo-go 3.0 自定义日志</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/custom-logger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/custom-logger/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo-go 3.0 自定义日志组件 参考samples dubbo-go-samples/logger
1. 日志配置 Dubbo-go 3.0 默认采用 zap 日志库，在配置文件中不添加 logger 配置，日志将会打印到控制默认级别为debug。您也可在配置文件中配置日志级别、, 可参照如下方式来配置zap-config和lumberjack-config，从而定制化日志输出。
dubbo: logger: zap-config: level: debug # 日志级别 development: false disableCaller: false disableStacktrace: false encoding: &amp;#34;console&amp;#34; # zap encoder 配置 encoderConfig: messageKey: &amp;#34;message&amp;#34; levelKey: &amp;#34;level&amp;#34; timeKey: &amp;#34;time&amp;#34; nameKey: &amp;#34;logger&amp;#34; callerKey: &amp;#34;caller&amp;#34; stacktraceKey: &amp;#34;stacktrace&amp;#34; lineEnding: &amp;#34;&amp;#34; levelEncoder: &amp;#34;capitalColor&amp;#34; timeEncoder: &amp;#34;iso8601&amp;#34; durationEncoder: &amp;#34;seconds&amp;#34; callerEncoder: &amp;#34;short&amp;#34; nameEncoder: &amp;#34;&amp;#34; outputPaths: - &amp;#34;stderr&amp;#34; errorOutputPaths: - &amp;#34;stderr&amp;#34; lumberjack-config: # 写日志的文件名称 filename: &amp;#34;logs.</description></item><item><title>Dubbo-go 的网络协议</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/concept/protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/concept/protocol/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
网络协议 1. 网络协议是什么 对于 Dubbo-go 微服务框架，网络协议为远程过程调用中负责网络通信的模块，负责应用层到网络层的数据序列化、打包、请求发起、网络端口监听等功能。Dubbo-go 为协议抽象了一套接口如下：
type Protocol interface { // Export service for remote invocation Export(invoker Invoker) Exporter // Refer a remote service Refer(url *common.URL) Invoker // Destroy will destroy all invoker and exporter, so it only is called once. Destroy() } 该接口包含三个方法。其中 Export 方法负责服务的暴露过程。入参 invoker 为dubbo 的概念，其封装了一个可以被调用的实例。在具体网络协议（例如Triple）实现的 Export 方法中，会针对特定的协议，将封装有一定逻辑的可调用实例 Invoker 以网络端口监听的形式暴露给外部服务，来自外部针对该网络端口的请求将会被 Export 方法开启的监听协程获取，进而根据网络协议进行拆解包和反序列化，得到解析后的请求数据。
Refer 方法负责服务的引用过程，其入参 url 为 dubbo 框架通用的结构，可以描述一个希望引用的服务，url 参数中包含了多个希望引用服务的参数，例如对应服务的接口名(interface)，版本号(version)，使用协议(protocol) 等等。在具体网络协议（例如Triple）实现的 Refer 方法中，会将特定的网络协议封装到 Invoker 可调用实例的方法中，用户层发起的 RPC 调用即可直接通过返回的 Invoker 对象，发起特定协议的网络请求。</description></item><item><title>无代理服务网格</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/deploy2/proxyless_service_mesh/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/deploy2/proxyless_service_mesh/</guid><description>1. 什么是 Proxyless Service-Mesh (无代理服务网格) ? 1.1 Service Mesh 简析 Istio 是当今最流行的开源服务网格。它由控制平面和数据平面构成，其架构如下，图片摘自 istio官网
位于图中下半部分的控制平面负责配置、服务信息、证书等资源的下发。位于上半部分的数据平面关注业务之间的通信流量；传统服务网格通过代理的方式拦截所有的业务网络流量，代理需要感知到控制平面下发的配置资源，从而按照要求控制网络流量的走向。
在 Istiod 环境中，其控制平面是一个名为 istiod 的进程，网络代理是 envoy 。istiod 通过监听 K8S 资源 例如Service、Endpoint 等，获取服务信息，并将这些资源统一通过 XDS 协议下发给位于数据平面的网络代理。envoy 是一个独立的进程，以 sidecar（边车）的形式伴随业务应用 Pod 运行，他与应用进程共用同一个主机网络，并通过修改路由表的方式，劫持业务应用的网络流量。
Service Mesh 可以解决微服务场景下的众多问题，随着集群规模的扩大与业务复杂度的增长，基于原生 k8s 的容器编排方案将会难以应付，开发人员不得不面对巨大的服务治理挑战。而 Service Mesh 很好地解决了这一问题，它将服务治理需求封装在了控制平面与代理中，业务开发人员只需要关注于业务逻辑。在应用部署之后，只需要运维人员通过修改配置，即可实现例如故障恢复、负载均衡、灰度发布等功能，这极大地提高了研发和迭代效率。
Istio 的 sidecar 通过容器注入的形式伴随业务应用进程的整个生命周期，对于业务应用是毫无侵入的，这解决了业务应用可迁移、多语言、基础架构耦合等问题。但这也带来了高资源消耗、请求时延增长的问题。
Service 为服务治理提供了一个很好的思路，将基础架构与业务逻辑解耦，让应用开发人员只需关注业务。另一方面，由于 sidecar 的弊端，我们可以考虑使用 sdk 的形式，来替代 sidecar 支撑起数据平面。
1.2 Proxyless Service-Mesh 无代理服务网格，是近几年提出的一个新的概念，isito、gRPC、brpc 等开源社区都在这一方向进行了探索和实践。无代理服务网格框架以 SDK 的形式被业务应用引入，负责服务之间的通信、治理。来自控制平面的配置直接下发至服务框架，由服务框架代替上述 sidecar 的功能。
服务框架（SDK）的主要能力可以概括为以下三点：
对接控制平面，监听配置资源。 对接应用，为开发者提供方便的接口。 对接网络，根据资源变动，响应流量规则。 1.3 Proxyless 的优缺点 优点：
性能：无代理模式的网络调用为点对点的直接通信，网络时延会比代理模式小很多。 稳定性：proxyless 的模式是单进程，拓扑简单，便于调试，稳定性高。 框架集成：市面上已有众多 sdk 模式的服务框架，切换至 mesh 后便与复用框架已有能力 资源消耗：没有 sidecar，资源消耗低 缺点：</description></item><item><title>Dubbo-go 3.0 应用级服务发现</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/service-discovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/service-discovery/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo-go 3.0 应用级服务发现 参考文章《Dubbo 迈出云原生重要一步 应用级服务发现解析》
参考仓库：dubbo-go-samples/registry/serivcediscovery
配置方案 Consumer 端 dubbo: registries: demoZK: protocol: nacos address: 127.0.0.1:8848 registry-type: service # 指定该注册中心为应用级服务发现，不填默认为接口级 metadata-report: # 定义元数据中心 protocol: nacos # 元数据中心可选nacos/zk address: 127.0.0.1:8848 consumer: references: GreeterClientImpl: protocol: tri interface: com.apache.dubbo.sample.basic.IGreeter Provider 端 dubbo: registries: demoZK: protocol: nacos address: 127.0.0.1:8848 registry-type: service # 指定该注册中心为应用级服务发现，不填默认为接口级 metadata-report: # 定义元数据中心 protocol: nacos # 元数据中心可选nacos/zk address: 127.0.0.1:8848 protocols: triple: name: tri port: 20000 provider: services: GreeterProvider: interface: com.</description></item><item><title>优雅下线</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/deploy2/graceful_shutdown/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/tutorial/deploy2/graceful_shutdown/</guid><description>优雅下线 背景 在稳定生产的过程中，容器调度完全由 k8s 管控，微服务治理完全由服务框架或者运维人员进行维护和管理。而在发布新版本，或者扩缩容的场景下，会终止旧的容器实例，并使用新的容器实例进行替换，对于承载高流量的线上生产环境，这个替换过程的衔接如果不合理，将在短时间内造成大量的错误请求，触发报警甚至影响正常业务。对于体量较大的厂家，发布过程出现问题所造成的损失会是巨大的。 因此，优雅下线的诉求被提出。这要求服务框架在拥有稳定服务调用能力、传统服务治理能力的基础之上，应当提供服务下线过程中稳定的保障，从而减少运维成本，提高应用稳定性。
特性说明 在一次完整的RPC调用过程中，中间服务往往充当服务提供者和服务消费者两个角色。中间服务在接收到来自上游服务的请求之后，处理请求得到结果返回给上游服务，然后根据需要调用下游服务提供的接口使用下游服务。因此优雅下线功能需要兼顾服务作为服务提供者和服务消费者两侧的稳定性，具体可以分为以下几步：
向注册中心进行反注册，销毁在注册中心注册的服务信息 作为服务提供者，要等待一段时间，保证客户端成功更新服务信息以及上游任务请求处理完毕，然后拒绝接收新的请求 作为服务消费者，要等待一段时间，保证使用下游服务的请求得到响应，然后取消对注册中心的订阅 销毁对下游任务的引用，销毁对外提供服务暴露的端口 执行用户的自定义回调操作 通过以上步骤，可以保证dubbo-go服务实例安全平稳停止，不对进行中的业务产生影响。
注意：取消对注册中心的订阅不能在步骤1中执行，这是因为中间服务对下游服务发送请求的时候可能存在下游服务信息的变动
使用场景 对dubbo-go实例使用kill pid命令停止实例
使用方式 以下是在yaml配置文件中，用户可以自定义的配置
作为服务提供者，dubbo-go实例下线时需要等待客户端成功更新服务信息，这段时间在配置中对应的字段为consumer-update-wait-time，默认3s 作为服务提供者，dubbo-go实例下线时如果来自上游任务的请求暂未处理完毕，需要等待上游任务请求处理完毕。作为服务消费者，dubbo-go实例需要等待对下游的请求收到回复。这段时间在配置中对应的字段为step-timeout，默认3s 作为服务提供者，dubbo-go实例下线时如果来自上游任务的请求已经处理完毕，需要等待一段窗口时间，如果在窗口时间内没有接收到新的请求，再执行后续步骤。这段时间在配置中对应的字段为offline-request-window-timeout，默认0s 用户可以自定义是否开启优雅下线功能，在配置中对应的字段为internal-signal，默认开启。 dubbo-go实例在优雅下线过程中可能因为异常导致卡死，在配置中可以配置超时时间，实例在超时之后强制关闭。这在配置中对应的字段为timeout，默认60s dubbo: shutdown: timeout:60 step-timeout:3 consumer-update-wait-time:3 internal-signal:true offline-request-window-timeout:0 此外，如果用户希望在下线逻辑彻底结束后，执行一些自定义的回调操作，可以使用如下代码
extension.AddCustomShutdownCallback(func() { // 用户自定义操作 }) 参考资料 【Dubbo-go 优雅上下线的设计与实践】</description></item><item><title>Dubbo-go 的注册中心</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/concept/registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/concept/registry/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
注册中心 1. Dubbo 的注册中心是什么 对于 Dubbo-go 微服务框架，注册中心在 RPC 场景下复杂保存 Provider 应用的服务信息。Provider 注册地址到注册中心，Consumer 从注册中心读取和订阅 Provider 地址列表。如图所示：
关于 Dubbo 服务发现细节，详情可参考 Dubbo 官网的概念介绍
Dubbo-go 为注册中心抽象了一套接口如下：
// Registry Extension - Registry type Registry interface { common.Node // Register is used for service provider calling, register services // to registry. And it is also used for service consumer calling, register // services cared about, for dubbo&amp;#39;s admin monitoring. Register(url *common.URL) error // UnRegister is required to support the contract: // 1.</description></item><item><title>Dubbo-go 3.0 注册中心</title><link>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/docs/languages/golang/dubbo-go-3.0/samples/registry/</guid><description>此文档已经不再维护。您当前查看的是快照版本。如果想要查看最新版本的文档，请参阅最新版本。
Dubbo-go 3.0 注册中心配置 参考samples dubbo-go-samples/registry
Registry 注册中心配置 Nacos 注册中心 dubbo: application: # 应用信息，服务启动后会将相关信息注册到注册中心，可被客户端从 url 中识别 name: myApp # application=myApp; name=myApp module: opensource # module=opensource organization: dubbo # organization=dubbo owner: laurence # owner=laurence version: myversion # app.version=myversion environment: pro # environment=pro registries: nacosWithCustomGroup: protocol: nacos # 注册中心选择 nacos address: 127.0.0.1:8848 # nacos ip group: myGroup # nacos group, 默认 DEFAULT_GROUP namespace: 9fb00abb-278d-42fc-96bf-e0151601e4a1 # nacos namespaceID, should be created before. 默认public username: abc password: abc protocols: dubbo: name: dubbo port: 20000 provider: services: UserProviderWithCustomGroupAndVersion: # 接口三元组：接口名、版本号、分组。client 和 server 需要保持一致。 interface: org.</description></item></channel></rss>