<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>参考手册 on Apache Dubbo</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/</link><description>Recent content in 参考手册 on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/index.xml" rel="self" type="application/rss+xml"/><item><title>生态组件</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/ecology/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/ecology/</guid><description>Dubbo-go github.com/apache/dubbo-go
Apache Dubbo Go 语言实现主仓库
Dubbo-go-samples github.com/apache/dubbo-go-samples
dubbo-go 的使用示例：
config-api: 使用 API 进行配置初始化 configcenter: 使用不同的配置中心，目前支持三种：zookeeper、apollo、和 nacos context: 如何使用上下文传递 attachment direct: 直连模式 game: 游戏服务例子 generic: 泛化调用 rpc: RPC 调用例子, 包含 Triple、Dubbo等协议以及跨语言/gRPC互通示例 helloworld: RPC调用入门例子 logger: 日志例子 registry: 展示与不同注册中心的对接，包含了 zk、nacos、etcd metrics: 数据上报 filter: 使用提供filter和自定义filter的例子 registry/servicediscovery：应用级服务发现例子 router: 路由例子 tracing: 链路追踪例子 Dubbo-go-pixiu github.com/apache/dubbo-go-pixiu
dubbo-go-pixiu 网关支持以 dubbo 协议和 http 协议调用 dubbo/dubbo-go 集群
Dubbo-getty github.com/apache/dubbo-getty
dubbo-getty 是一个Go语言异步网络 io 库，支持 tcp/udp/websocket 协议。
Dubbo-go-hessian2 github.com/apache/dubbo-go-hessian2
Dubbo-go-hessian2 是一个Go语言 hessian2 序列化协议库</description></item><item><title>泛化调用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/generic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/generic/</guid><description>废弃警告 dubbo-go 泛化调用仅适用于 dubbo2 协议，不适用 triple 协议 泛化调用是一种 Dubbo-Go 的特殊调用方式，它允许中间节点在没有接口信息的情况下传递调用信息，常被用于测试、网关的场景下。泛化调用支持 Dubbo 和 Triple 协议，但是目前序列化方案只支持 Hessian。
背景 为了便于理解，这篇文档中以网关使用场景介绍泛化调用。我们先来考虑普通调用（非泛化调用）。下图包含了 consumer 和 provider 两个关键角色（后文中用 endpoint 代表一个 consumer 或一个 provider），各自都有一份关于 org.apache.dubbo.sample.User 接口的定义。假定在调用行为中需要使用 org.apache.dubbo.sample.User 接口。
RPC 需要借助网络介质传输，因此数据不能以 go struct 形式传输，而必须以二进制形式传输。这就要求 consumer 端在传输前，需要将实现 org.apache.dubbo.sample.User 接口的结构体序列化为二进制格式。同样的，对于 provider 端，需要将二进制数据反序列化为结构体信息。总之，普通调用要求接口信息在每一个 endpoint 必须有相同的定义，这样才能保证数据序列化和反序列化的结果与预期一致。
在网关场景下，网关不可能存储全部接口定义。比如一个网关需要转发 100 个服务调用，每个服务需要的接口数量为 10 个，普通调用要求把 1000 个（100 * 10）接口定义提前全部存储在网关内，这显然是难以做到的。所以有没有一种方式可以既不需要提前存储接口定义，又能正确转发调用呢？答案是肯定的，这就是使用泛化调用的原因。
原理 泛化调用本质上就是把复杂结构转化为通用结构，这里说的通用结构是指 map、string 等，网关是可以顺利解析并传递这些通用结构的。
目前，Dubbo-go v3 只支持 Map 泛化方式（default）。我们以 User 接口为例，其定义如下所示。
// definition type User struct { ID string Name string Age int32 } func (u *User) JavaClassName() string { return &amp;#34;org.</description></item><item><title>使用 dubbogo-cli 工具</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/use_dubbogo_cli/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/use_dubbogo_cli/</guid><description>废弃警告 自 dubbo-go 3.1.0 版本开始，本工具不再适用。本工具已经停止维护，未来将由 dubboctl 代替，请关注社区动态了解 dubboctl 最新进展。 1. 安装 dubbogo-cli 是 Apach/dubbo-go 生态的子项目，为开发者提供便利的应用模板创建、工具安装、接口调试等功能，以提高用户的研发效率。
执行以下指令安装dubbogo-cli 至 $GOPATH/bin
go install github.com/dubbogo/dubbogo-cli@latest 2. 功能概览 dubbogo-cli 支持以下能力
应用模板创建
dubbogo-cli newApp . 在当前目录下创建应用模板
Demo 创建
dubbogo-cli newDemo . 在当前目录下创建 RPC 示例，包含一个客户端和一个服务端
编译、调试工具安装
dubbogo-cli install all 一键安装以下等工具至 $GOPATH/bin
protoc-gen-go-triple
用于 triple 协议接口编译
imports-formatter
用于整理代码 import 块。
import-formatte README
查看 dubbo-go 应用注册信息
查看 Zookeeper 上面的注册信息, 获取接口及方法列表
$ dubbogo-cli show --r zookeeper --h 127.0.0.1:2181 interface: com.</description></item><item><title>使用 Nacos 作为注册中心</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/nacos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/golang-sdk/refer/nacos/</guid><description>1. 准备工作 dubbo-go cli 工具和依赖工具已安装 创建一个新的 demo 应用 2. 使用 grpc_cli 工具进行 Dubbo 服务调试 2.1 开启服务端 示例：user.go:
func (u *UserProvider) GetUser(ctx context.Context, userStruct *CallUserStruct) (*User, error) { fmt.Printf(&amp;#34;=======================\nreq:%#v\n&amp;#34;, userStruct) rsp := User{&amp;#34;A002&amp;#34;, &amp;#34;Alex Stocks&amp;#34;, 18, userStruct.SubInfo} fmt.Printf(&amp;#34;=======================\nrsp:%#v\n&amp;#34;, rsp) return &amp;amp;rsp, nil } 服务端开启一个服务，名为GetUser，传入一个CallUserStruct的参数，返回一个User参数
CallUserStruct参数定义：
type CallUserStruct struct { ID string Male bool SubInfo SubInfo // 嵌套子结构 } func (cs CallUserStruct) JavaClassName() string { return &amp;#34;com.ikurento.user.CallUserStruct&amp;#34; } type SubInfo struct { SubID string SubMale bool SubAge int } func (s SubInfo) JavaClassName() string { return &amp;#34;com.</description></item></channel></rss>