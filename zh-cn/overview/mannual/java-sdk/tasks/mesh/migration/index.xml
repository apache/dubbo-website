<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>传统 Dubbo 微服务集群如何平滑迁移到 Istio 服务网格体系 on Apache Dubbo</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/migration/</link><description>Recent content in 传统 Dubbo 微服务集群如何平滑迁移到 Istio 服务网格体系 on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/migration/index.xml" rel="self" type="application/rss+xml"/><item><title>地址同步</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/migration/dubbo-mesh/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/migration/dubbo-mesh/</guid><description>遵循以下步骤，可以轻松掌握如何开发符合 Service Mesh 架构的 Dubbo 服务，并将其部署到 Kubernetes 并接入 Istio 的流量治理体系。在此查看 完整示例源码
1 总体目标 部署 Dubbo 应用到 Kubernetes Istio 自动注入 Envoy 并实现流量拦截 基于 Istio 规则进行流量治理 2 基本流程与工作原理 这个示例演示了如何将 Dubbo 开发的应用部署在 Istio 体系下，以实现 Envoy 对 Dubbo 服务的自动代理，示例总体架构如下图所示。
完成示例将需要的步骤如下：
创建一个 Dubbo 应用( dubbo-samples-mesh-k8s ) 构建容器镜像并推送到镜像仓库（ 本示例官方镜像 ） 分别部署 Dubbo Provider 与 Dubbo Consumer 到 Kubernetes 并验证 Envoy 代理注入成功 验证 Envoy 发现服务地址、正常拦截 RPC 流量并实现负载均衡 基于 Istio VirtualService 实现按比例流量转发 3 详细步骤 3.1 环境要求 请确保本地安装如下环境，以提供容器运行时、Kubernetes集群及访问工具
Docker Minikube Kubectl Istio Kubens(optional) 通过以下命令启动本地 Kubernetes 集群</description></item><item><title>协议识别</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/migration/deploy-on-k8s/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/migration/deploy-on-k8s/</guid><description>可以按照下文步骤，将 Dubbo 服务轻松部署到 Kubernetes 集群，此查看文章用到的 完整代码示例地址
1 总体目标 部署 Dubbo 应用到 Kubernetes 基于 Kubernetes 内置 Service 实现服务发现 将 Dubbo 应用对接到 Kubernetes 生命周期 2 基本流程 创建一个 Dubbo 应用( dubbo-samples-kubernetes ) 构建容器镜像并推送到镜像仓库（ dubbo-demo 示例例镜像 ） 分别部署 Dubbo Provider 与 Dubbo Consumer 到 Kubernetes 验证服务发现与调用正常 3 详细步骤 3.1 环境要求 请确保本地安装如下环境，以提供容器运行时、Kubernetes集群及访问工具
Docker Minikube Kubectl Kubens(optional) 通过以下命令启动本地 Kubernetes 集群
minikube start 通过 kubectl 检查集群正常运行，且 kubectl 绑定到默认本地集群
kubectl cluster-info 3.2 前置条件 由于示例 Dubbo 项目均部署在 Pod 中且与 API-SERVER 有交互，因此有相应的权限要求，我们这里创建独立 ServiceAccount 并绑定必须的 Roles，后面所有的 Dubbo Kubernetes 资源都将使用这里新建的 ServiceAccount。</description></item><item><title>其他问题？</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/migration/proxyless/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/mesh/migration/proxyless/</guid><description>Proxyless 模式是指 Dubbo 直接与 Istiod 通信，通过 xDS 协议实现服务发现和服务治理等能力。 本示例中将通过一个简单的示例来演示如何使用 Proxyless 模式。
示例地址
代码架构 本小节中主要介绍本文所使用的示例的代码架构，通过模仿本示例中的相关配置改造已有的项目代码可以使已有的项目快速跑在 Proxyless Mesh 模式下。
1. 接口定义 为了示例足够简单，这里使用了一个简单的接口定义，仅对参数做拼接进行返回。
public interface GreetingService { String sayHello(String name); } 2. 接口实现 @DubboService(version = &amp;#34;1.0.0&amp;#34;) public class AnnotatedGreetingService implements GreetingService { @Override public String sayHello(String name) { System.out.println(&amp;#34;greeting service received: &amp;#34; + name); return &amp;#34;hello, &amp;#34; + name + &amp;#34;! from host: &amp;#34; + NetUtils.getLocalHost(); } } 3. 客户端订阅方式 由于原生 xDS 协议无法支持获取从接口到应用名的映射，因此需要配置 providedBy 参数来标记此服务来自哪个应用。</description></item></channel></rss>