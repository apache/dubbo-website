<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust SDK 手册 on Apache Dubbo</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/</link><description>Recent content in Rust SDK 手册 on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/index.xml" rel="self" type="application/rss+xml"/><item><title>快速开始</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/quick-start/</guid><description>请在此查看完整 示例。
1 前置条件 安装 Rust 开发环境 安装 protoc 工具 2 使用 IDL 定义 Dubbo 服务 Greeter 服务定义如下，包含一个 Unary(request-response) 模型的 Dubbo 服务。
// ./proto/greeter.proto syntax = &amp;#34;proto3&amp;#34;; option java_multiple_files = true; package org.apache.dubbo.sample.tri; // The request message containing the user&amp;#39;s name. message GreeterRequest { string name = 1; } // The response message containing the greetings message GreeterReply { string message = 1; } service Greeter{ // unary rpc greet(GreeterRequest) returns (GreeterReply); } 3 添加 Dubbo-rust 及相关依赖到项目 # .</description></item><item><title>Rust和Java互相调用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/java-interoperability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/java-interoperability/</guid><description>1 前置条件 安装 Rust 开发环境 安装 protoc 工具 安装 Java 开发环境 2 运行示例 Java 版本的 Dubbo provider Java 版本的 Dubbo provider 示例源码见https://github.com/apache/dubbo-samples/tree/master/3-extensions/protocol/dubbo-samples-triple。
Clone 源代码、编译构建，并运行 provider：
$ # clone 源代码 $ git clone https://github.com/apache/dubbo-samples.git $ cd dubbo-samples/dubbo-samples-triple/ $ # 构建 $ mvn clean compile package -DskipTests $ # 运行 provider $ java -Dprovider.port=8888 -jar ./target/dubbo-samples-triple-1.0-SNAPSHOT.jar # ……省略部分日志 Dubbo triple stub server started, port=8888 Java 侧的接口定义
3 运行 Rust 版本的 Dubbo consumer Rust 版本的 Dubbo consumer 示例源码见https://github.</description></item><item><title>服务发现</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/service-discovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/service-discovery/</guid><description>Dubbo Rust服务发现简介 Dubbo Rust提供的是一种 Client-Based 的服务发现机制，依赖第三方注册中心组件来协调服务发现过程，支持的注册中心： Nacos、Zookeeper
以下是 Dubbo Rust服务发现机制的基本工作原理图：
服务发现包含提供者、消费者和注册中心三个参与角色，其中，Dubbo 提供者实例注册 URL 地址到注册中心，注册中心负责对数据进行聚合，Dubbo 消费者从注册中心读取地址列表并订阅变更，每当地址列表发生变化，注册中心将最新的列表通知到所有订阅的消费者实例。
Dubbo Rust注册中心以服务粒度聚合实例数据，消费者按消费需求精准订阅。 Dubbo Rust服务发现的一个示例：example
高效地址推送实现 从注册中心视角来看，它负责以服务名 (例如：org.apache.dubbo.sample.tri.Greeter) 对整个集群的实例地址进行聚合，每个对外提供服务的实例将自身的实例ip:port 地址信息 (例如：127.0.0.1:8848) 注册到注册中心。
配置方式 Dubbo Rust服务发现支持两种注册中心组件，既Nacos、Zookeeper，可以通过以下方式创建不同的注册中心，并将其绑定到Dubbo Rust框架。
配置方式： 假设有服务：Greeter，对应的服务实现为GreeterServerImpl
服务端：
//注册服务 register_server(GreeterServerImpl { name: &amp;#34;greeter&amp;#34;.to_string(), }); //创建注册中心 let zkr = ZookeeperRegistry::default(); let r = RootConfig::new(); let r = match r.load() { Ok(config) =&amp;gt; config, Err(_err) =&amp;gt; panic!(&amp;#34;err: {:?}&amp;#34;, _err), // response was droped }; //启动Dubbo框架 let mut f = Dubbo::new() .</description></item><item><title>服务路由规则</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/router-module/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/router-module/</guid><description>条件路由 使用模式与 条件路由文档 中的模式类似，但配置格式略有不同，以下是条件路由规则示例。
基于以下示例规则，所有 org.apache.dubbo.sample.tri.Greeter 服务 greet 方法的调用都将被转发到有 port=8888 标记的地址子集
configVersion: v1.0 scope: &amp;#34;service&amp;#34; force: false enabled: true key: &amp;#34;org.apache.dubbo.sample.tri.Greeter&amp;#34; conditions: - method=greet =&amp;gt; port=8888 注：
dubbo rust目前还没有实现对于应用粒度的区分，无法区分服务来自哪个应用
因此对于标签路由和条件路由，都仅能配置一条应用级别的配置
对于应用级别的配置，默认key指定为application，此配置将对全部服务生效
例如：
configVersion: v1.0 scope: &amp;#34;application&amp;#34; force: false enabled: true key: application conditions: - ip=127.0.0.1 =&amp;gt; port=8000~8888 匹配/过滤条件 参数支持
服务调用上下文，如：service_name, method等 URL 本身的字段，如：location, ip, port等 URL params中存储的字段信息 条件支持
等号 = 表示 &amp;ldquo;匹配&amp;rdquo;，如：method = getComment 不等号 != 表示 &amp;ldquo;不匹配&amp;rdquo;，如：method != getComment 值支持</description></item><item><title>Streaming 通信模型</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/streaming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/streaming/</guid><description>本文重点讲解 Dubbo Rust Streaming 通信模式，请先查看 Quick Start 了解 Dubbo Rust 基本使用，在此查看本文的完整示例。
1 IDL 中增加 Streaming 模型定义 完整 Greeter 服务定义如下，包含一个 Unary、Client stream、Server stream、Bidirectional stream 模型的 Dubbo 服务。
// ./proto/greeter.proto syntax = &amp;#34;proto3&amp;#34;; option java_multiple_files = true; package org.apache.dubbo.sample.tri; // The request message containing the user&amp;#39;s name. message GreeterRequest { string name = 1; } // The response message containing the greetings message GreeterReply { string message = 1; } service Greeter{ // unary rpc greet(GreeterRequest) returns (GreeterReply); // clientStream rpc greetClientStream(stream GreeterRequest) returns (GreeterReply); // serverStream rpc greetServerStream(GreeterRequest) returns (stream GreeterReply); // bi streaming rpc greetStream(stream GreeterRequest) returns (stream GreeterReply); } 2 使用 Streaming 模型定义编写逻辑 2.</description></item><item><title>使用Unix套接字连接器通信</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/unix-transport/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/rust-sdk/unix-transport/</guid><description>本文重点讲解 Dubbo Rust Triple 协议使用Unix 套接，请先查看 Quick Start 了解 Dubbo Rust 基本使用，在此查看本文的完整示例。
1 使用 Unix 套接字连接器 说明 #[cfg(any(target_os = &amp;ldquo;macos&amp;rdquo;, target_os=&amp;ldquo;unix&amp;rdquo;))] 当操作系统符合cfg配置时，unix 模块会被编译使用，否则无法使用
2 使用 client/connection 使用 Unix 套接字连接器编写逻辑 2.1 编写 Client 端 // examples/echo/src/echo/client.rs // 使用 ClientBuilder 初始化 Client let builder = ClientBuilder::new().with_connector(&amp;#34;unix&amp;#34;).with_host(&amp;#34;unix://127.0.0.1:8888&amp;#34;); let mut cli = EchoClient::build(builder); 2.2 编写 Server 端 // examples/echo/src/echo/server.rs // 通过 serverbuilder 来初始化 Server let builder = ServerBuilder::new() .with_listener(&amp;#34;unix&amp;#34;.to_string()) .with_service_names(vec![&amp;#34;grpc.examples.echo.Echo&amp;#34;.to_string()]) .with_addr(&amp;#34;127.0.0.1:8888&amp;#34;); builder.build().serve().await.unwrap(); 3 运行示例 编译 执行cargo build来编译server和client。</description></item></channel></rss>