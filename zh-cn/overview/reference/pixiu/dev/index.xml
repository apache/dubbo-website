<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>开发者指南 on Apache Dubbo</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/dev/</link><description>Recent content in 开发者指南 on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://dubbo.apache.org/zh-cn/overview/reference/pixiu/dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Pixiu Filter体系介绍</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/dev/filter-extension/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/dev/filter-extension/</guid><description>怎样编写一个Filter 更详细的信息，请移步Blog《谈谈Pixiu的Filter》
我们来尝试写一个简单的Filter，这个Filter将会有简单的配置，在Decode阶段把请求的Body Log出来，并翻转后作为Mock的返回值。最后在Encode阶段根据配置把返回值Log出来。
1.首先创建一个Filter
type DemoFilter struct { logPrefix string } // Decode阶段，发生在调用Upstream之前 func (f *DemoFilter) Decode(ctx *contexthttp.HttpContext) filter.FilterStatus { body, _ := ioutil.ReadAll(ctx.Request.Body) logger.Infof(&amp;#34;request body: %s&amp;#34;, body) //reverse res str runes := []rune(string(body)) for i := 0; i &amp;lt; len(runes)/2; i += 1 { runes[i], runes[len(runes)-1-i] = runes[len(runes)-1-i], runes[i] } reverse := string(runes) //mock response ctx.SendLocalReply(200, []byte(reverse)) return filter.Stop } // Encode阶段，此时可以获取到Upstream的Response func (f *DemoFilter) Encode(ctx *contexthttp.HttpContext) filter.FilterStatus { res := ctx.</description></item><item><title>dubbo-pilot Control Plane 部署</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/dev/dubbo-pilot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/dev/dubbo-pilot/</guid><description>1.总体目标 2.基本流程 3.详细步骤 3.1 环境要求 3.2 istio 本地部署 3.2.1 编译 3.2.2 部署 &amp;amp; debug 3.3 istio 容器部署 3.3.1 编译 3.3.2 部署 &amp;amp; debug 1 总体目标 控制面编译和镜像构建 使用 istioctl 在 kubernetes 环境部署 如何对控制面程序 debug 2 基本流程 这个例子将演示如何在编译 dubbo-pilot 控制平面并在 kubernetes 环境下如何使用 istioctl 进行部署 本地启动控制平面，对 dubbo-pilot 进行启动和 debug 使用 istioctl 在 k8s 环境启动和 debug 3 详细步骤 3.1 环境要求 Golang Docker Minikube/Kind Kubectl Dlv 3.2 本地部署 3.2.1 编译 编译 docker-builder cd dubbo-go-pixiu/tools/docker-builder &amp;amp;&amp;amp; go install docker-builder -h: Builds Istio docker images Usage: [flags] Flags: --architecures strings architectures to build (default [linux/amd64]) --base-version string base version to use (default &amp;#34;latest&amp;#34;) --builder string type of builder to use.</description></item><item><title>Trie 前缀树介绍</title><link>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/dev/trie/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/reference/pixiu/dev/trie/</guid><description>简介 网关的核心之一是路由逻辑，决定一个请求需要经过怎样的加工，被转发到哪个下行服务。
其中 80% 的路由需求表达都以 URL 为基础。需要描述清楚具有某个特征的 URL 或者 URL 集合对应怎样的一系列下游处理策略。
例如，&amp;rsquo;/test/&amp;rsquo; 开头的 URL 路由到测试环境集群，&amp;rsquo;/release/user/&amp;rsquo; 开头的 URL 会被路由到正式环境的 user 服务集群。
同时网关作为所有请求的入口，每一毫秒的延时都会做用在全量的业务下，在 mesh 场景下，延时还会随着调用链路的加深，被倍数放大。按照生产环境业务相应 &amp;lt;=7 毫秒的标准来看，规则匹配的性能要求也是十分苛刻的。一定不能随着规则数目的增加而性能退化。
使用介绍 仅从使用方的角度阐述 pixiu 的配置文件如何描述 URL 相关的路由规则。（下面，我们介绍一下如何配置 URL 路由规则）
如下是一份 pixiu 的 api 配置文件，这份配置文件会被解析后生成一份对应的内存模型，作为 pixiu 路由相关配置的初始状态。之后由 RDS 协议修改解析后得到的内存模型，实现路由逻辑动态生效的效果。RDS 协议（RDS：xDS 协议下描述路由规则的部分）相关内容是后话不详细阐述。我们把注意力聚焦到resource部分。
resource 下 path 部分就是上文阐述的，URL 相关的路由描述。意思是满足 path 描述特征的 URL 会被成功匹配。
name: server description: server sample resources: - path: &amp;#39;/api/v1/test-dubbo/user/name/:name&amp;#39; type: restful description: user methods: - httpVerb: GET enable: true timeout: 1000ms inboundRequest: requestType: http uri: - name: name required: true integrationRequest: requestType: dubbo mappingParams: - name: uri.</description></item></channel></rss>