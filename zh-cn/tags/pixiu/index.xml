<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pixiu on Apache Dubbo</title><link>https://dubbo.apache.org/zh-cn/tags/pixiu/</link><description>Recent content in Pixiu on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 19 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://dubbo.apache.org/zh-cn/tags/pixiu/index.xml" rel="self" type="application/rss+xml"/><item><title>谈谈Pixiu的Filter</title><link>https://dubbo.apache.org/zh-cn/blog/2022/02/19/%E8%B0%88%E8%B0%88pixiu%E7%9A%84filter/</link><pubDate>Sat, 19 Feb 2022 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2022/02/19/%E8%B0%88%E8%B0%88pixiu%E7%9A%84filter/</guid><description>Filter的生命周期 Pixiu作为一个面向云原生的gateway，通过简单的配置即可代理Http to Dubbo 2、Tripe甚至是Spring Cloud的请求。那Filter是怎样运行的呢？
首先Filter Plugin向Filter Manager注册自己**，然后Filter Manager根据配置创建好Filter Factory并持有它们，等待请求来临时，Manager创建一个一次性的用于此次请求的Filter Chain，然后利用Factory创建好Decode/Encode Filter并把它们加入链中，然后按照顺序去运行Decode Filter，然后去请求Upstream**，拿到Response再反向运行Encode Filter，让Filter可以访问到Response。
几个关键的概念：
Filter Manager
Filter的Manger。。。
// FilterManager manage filters type FilterManager struct { filters map[string]HttpFilterFactory filtersArray []*HttpFilterFactory } Filter Plugin：定义了Filter的（唯一的）名字和描述如何去创建一个Filter Factory。
其实结合Filter Factory的定义，可以认为Plugin是Filter Factory的Factory
// HttpFilterPlugin describe plugin HttpFilterPlugin interface { // Kind returns the unique kind name to represent itself. Kind() string // CreateFilterFactory return the filter factory CreateFilterFactory() (HttpFilterFactory, error) } Filter Factory：定义了Filter自身的配置，并且在请求来临时创建真实的Filter并把它添加到FilterChain中
Config() 的目的是能让Filter Manager能够有机会把配置交给Factory（此时golang泛型还没有落地） Apply() 在配置被注入到Factory后，有机会对config做一些检查和提前做一些初始化的工作 PrepareFilterChain() 创建Filter并加入Filter Chain // HttpFilterFactory describe http filter HttpFilterFactory interface { // Config Expose the config so that Filter Manger can inject it, so it must be a pointer Config() interface{} // Apply After the config is injected, check it or make it to default Apply() error // PrepareFilterChain create filter and append it to FilterChain // // Be Careful !</description></item><item><title>Dubbo 跨语言调用神兽：dubbo-go-pixiu</title><link>https://dubbo.apache.org/zh-cn/blog/2021/08/25/dubbo-%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8%E7%A5%9E%E5%85%BDdubbo-go-pixiu/</link><pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/blog/2021/08/25/dubbo-%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8%E7%A5%9E%E5%85%BDdubbo-go-pixiu/</guid><description>Pixiu 是什么 在回答 Pixiu 是什么之前，我们简单解释一下 Dubbo 是什么。Dubbo 是一个开源的高性能 RPC 框架，有着丰富的服务治理能力以及优秀的扩展能力。Dubbo 更扩展出 Dubbo-go【1】，为用户提供了 Golang 的 Dubbo 解决方案，打通了两种语言之间的隔阂，使 Dubbo 更加贴近云原生。
Dubbo-go 作为 Golang 服务，实现与 Dubbo 服务之间的相互调用。然而，在日常使用场景中，用户往往有把 Dubbo 服务以 RESTful 风格向外暴露的需求同时也要兼顾内部 Dubbo 调用。为了解决这种场景，作为 Dubbo API 网关的 Pixiu【2】 (中文: 貔貅， 曾用名 dubbo-go-proxy) 便应运而生。之所以采用 Pixiu 这个名称，是因为 Java 同类产品 Zuul 的意象是一个西方怪兽，Pixiu 作为一个国产产品，就用了我们中国的一个类似的神兽貔貅作为项目名称。也同时表达了 Dubbo 社区希望扩展出一整套云原生生态链的决心。
目前 Dubbo 多语言生态，发展最好的自然是 Java，其次是 Golang，其他语言都差强人意。dubbo-go-pixiu 项目是一个基于 dubbo-go 发展起来的项目，目前接口协议层支持的是七层的 HTTP 请求调用，计划在未来的 0.5 版本中支持 gRPC 请求调用，其另外一个使命是作为一种新的 dubbo 多语言解决方案。
为什么使用 Pixiu Pixiu 是基于 Dubbogo 的云原生、高性能、可扩展的微服务 API 网关。作为一款网关产品，Pixiu 帮助用户轻松创建、发布、维护、监控和保护任意规模的 API ，接受和处理成千上万个并发 API 调用，包括流量管理、 CORS 支持、授权和访问控制、限制、监控，以及 API 版本管理。除此以外，作为 Dubbo 的衍生产品，Pixiu 可以帮助 Dubbo 用户进行协议转换，实现跨系统、跨协议的服务能力互通。</description></item></channel></rss>