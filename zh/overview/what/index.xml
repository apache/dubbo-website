<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Apache Dubbo – 什么是 Dubbo</title><link>https://dubbo.apache.org/zh/overview/what/</link><description>Recent content in 什么是 Dubbo on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://dubbo.apache.org/zh/overview/what/index.xml" rel="self" type="application/rss+xml"/><item><title>Overview: Dubbo 简介</title><link>https://dubbo.apache.org/zh/overview/what/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/overview/what/overview/</guid><description>
&lt;p>Apache Dubbo 是一款 RPC 服务开发框架，用于解决微服务架构下的服务治理与通信问题，官方提供了 Java、Golang 等多语言 SDK 实现。使用 Dubbo 开发的微服务原生具备相互之间的远程地址发现与通信能力，
利用 Dubbo 提供的丰富服务治理特性，可以实现诸如服务发现、负载均衡、流量调度等服务治理诉求。Dubbo 被设计为高度可扩展，用户可以方便的实现流量拦截、选址的各种定制逻辑。&lt;/p>
&lt;p>Dubbo3 定义为面向云原生的下一代 RPC 服务框架。3.0 基于 &lt;a href="https://dubbo.apache.org/zh/docsv2.7">Dubbo 2.x&lt;/a> 演进而来，在保持原有核心功能特性的同时， Dubbo3 在易用性、超大规模微服务实践、云原生基础设施适配、安全性等几大方向上进行了全面升级。&lt;/p>
&lt;h3 id="dubbo-是什么">Dubbo 是什么&lt;/h3>
&lt;p>Apache Dubbo 最初在 2008 年由 Alibaba 捐献开源，很快成为了国内开源服务框架选型的事实标准框架 ，得到了各行各业的广泛应用。在 2017 年，Dubbo 正式捐献到 Apache 软件基金会并成为 Apache 顶级项目，目前 Dubbo3 已经是一站式的微服务解决方案提供：&lt;/p>
&lt;ul>
&lt;li>基于 HTTP/2 的 &lt;a href="https://dubbo.apache.org/zh/docs3-v2/java-sdk/concepts-and-architecture/triple/">Triple 协议&lt;/a>以及面向代理 API 的编程体验。&lt;/li>
&lt;li>强大的&lt;a href="../../tasks/traffic-management">流量治理能力&lt;/a>，如地址发现、负载均衡、路由选址、动态配置等。&lt;/li>
&lt;li>&lt;a href="../../mannual/">多语言 SDK 实现&lt;/a>，涵盖 Java、Golang、Javascript 等，更多语言实现将会陆续发布。&lt;/li>
&lt;li>灵活的适配与扩展能力，可轻松与微服务体系其他组件如 Tracing、Transaction 等适配。&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh/docs3-v2/java-sdk/concepts-and-architecture/mesh/">Dubbo Mesh 解决方案&lt;/a>，同时支持 Sidecar、Proxyless 等灵活的 Mesh 部署方案。&lt;/li>
&lt;/ul>
&lt;p>Apache Dubbo 总体架构能很好的满足企业的大规模微服务实践，因为它从设计之初就是为了解决超大规模微服务集群实践问题，不论是阿里巴巴还是工商银行、中国平安、携程等社区用户，它们都通过多年的大规模生产环境流量对 Dubbo 的稳定性与性能进行了充分验证，因此，Dubbo 在解决业务落地与规模化实践方面有着无可比拟的优势：&lt;/p>
&lt;ul>
&lt;li>开箱即用
&lt;ul>
&lt;li>易用性高，如 Java 版本的面向接口代理特性能实现本地透明调用&lt;/li>
&lt;li>功能丰富，基于原生库或轻量扩展即可实现绝大多数的微服务治理能力&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>面向超大规模微服务集群设计
&lt;ul>
&lt;li>极致性能，高性能的 RPC 通信协议设计与实现&lt;/li>
&lt;li>横向可扩展，轻松支持百万规模集群实例的地址发现与流量治理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="../extensibility">高度可扩展&lt;/a>
&lt;ul>
&lt;li>调用过程中对流量及协议的拦截扩展，如 Filter、Router、LB 等&lt;/li>
&lt;li>微服务治理组件扩展，如 Registry、Config Center、Metadata Center 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>企业级微服务治理能力
&lt;ul>
&lt;li>国内公有云厂商支持的事实标准服务框架&lt;/li>
&lt;li>多年企业实践经验考验，参考&lt;a href="../../../users">用户实践案例&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="dubbo-基本工作流程">Dubbo 基本工作流程&lt;/h3>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/rpc.png" alt="dubbo-rpc">&lt;/p>
&lt;p>Dubbo 首先是一款 RPC 框架，它定义了自己的 RPC 通信协议与编程方式。如上图所示，用户在使用 Dubbo 时首先需要定义好 Dubbo 服务；其次，是在将 Dubbo 服务部署上线之后，依赖 Dubbo 的应用层通信协议实现数据交换，Dubbo 所传输的数据都要经过序列化，而这里的序列化协议是完全可扩展的。
使用 Dubbo 的第一步就是定义 Dubbo 服务，服务在 Dubbo 中的定义就是完成业务功能的一组方法的集合，可以选择使用与某种语言绑定的方式定义，如在 Java 中 Dubbo 服务就是有一组方法的 Interface 接口，也可以使用语言中立的 Protobuf Buffers &lt;a href="../../tasks/triple/idl/">IDL 定义服务&lt;/a>。定义好服务之后，服务端（Provider）需要提供服务的具体实现，并将其声明为 Dubbo 服务，而站在服务消费方（Consumer）的视角，通过调用 Dubbo 框架提供的 API 可以获得一个服务代理（stub）对象，然后就可以像使用本地服务一样对服务方法发起调用了。
在消费端对服务方法发起调用后，Dubbo 框架负责将请求发送到部署在远端机器上的服务提供方，提供方收到请求后会调用服务的实现类，之后将处理结果返回给消费端，这样就完成了一次完整的服务调用。如图中的 Request、Response 数据流程所示。&lt;/p>
&lt;blockquote>
&lt;p>需要注意的是，在 Dubbo 中，我们提到服务时，通常是指 RPC 粒度的、提供某个具体业务增删改功能的接口或方法，与一些微服务概念书籍中泛指的服务并不是一个概念。&lt;/p>
&lt;/blockquote>
&lt;p>在分布式系统中，尤其是随着微服务架构的发展，应用的部署、发布、扩缩容变得极为频繁，作为 RPC 消费方，如何动态的发现服务提供方地址成为 RPC 通信的前置条件。Dubbo 提供了自动的地址发现机制，用于应对分布式场景下机器实例动态迁移的问题。如下图所示，通过引入注册中心来协调提供方与消费方的地址，提供者启动之后向注册中心注册自身地址，消费方通过拉取或订阅注册中心特定节点，动态的感知提供方地址列表的变化。&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/architecture.png" alt="arch-service-discovery">&lt;/p>
&lt;h3 id="dubbo-核心特性">Dubbo 核心特性&lt;/h3>
&lt;h4 id="高性能-rpc-通信协议">高性能 RPC 通信协议&lt;/h4>
&lt;p>跨进程或主机的服务通信是 Dubbo 的一项基本能力，Dubbo RPC 以预先定义好的协议编码方式将请求数据（Request）发送给后端服务，并接收服务端返回的计算结果（Response）。RPC 通信对用户来说是完全透明的，使用者无需关心请求是如何发出去的、发到了哪里，每次调用只需要拿到正确的调用结果就行。除了同步模式的 Request-Response 通信模型外，Dubbo3 还提供更丰富的通信模型选择：&lt;/p>
&lt;ul>
&lt;li>消费端异步请求(Client Side Asynchronous Request-Response)&lt;/li>
&lt;li>提供端异步执行（Server Side Asynchronous Request-Response）&lt;/li>
&lt;li>消费端请求流（Request Streaming）&lt;/li>
&lt;li>提供端响应流（Response Streaming）&lt;/li>
&lt;li>双向流式通信（Bidirectional Streaming）&lt;/li>
&lt;/ul>
&lt;p>具体可参见各语言 SDK 实现的可选协议列表 或 &lt;a href="https://dubbo.apache.org/zh/docs3-v2/java-sdk/concepts-and-architecture/triple/">Triple协议&lt;/a>&lt;/p>
&lt;h4 id="自动服务地址发现">自动服务（地址）发现&lt;/h4>
&lt;p>Dubbo 的服务发现机制，让微服务组件之间可以独立演进并任意部署，消费端可以在无需感知对端部署位置与 IP 地址的情况下完成通信。Dubbo 提供的是 Client-Based 的服务发现机制，使用者可以有多种方式启用服务发现：&lt;/p>
&lt;ul>
&lt;li>使用独立的注册中心组件，如 &lt;a href="https://nacos.io/">Nacos&lt;/a>、Zookeeper、Consul、Etcd 等。&lt;/li>
&lt;li>将服务的组织与注册交给底层容器平台，如 Kubernetes，这被理解是一种更云原生的使用方式&lt;/li>
&lt;/ul>
&lt;h4 id="运行态流量管控">运行态流量管控&lt;/h4>
&lt;p>透明地址发现让 Dubbo 请求可以被发送到任意 IP 实例上，这个过程中流量被随机分配。当需要对流量进行更丰富、更细粒度的管控时，就可以用到 Dubbo 的流量管控策略，Dubbo 提供了包括负载均衡、流量路由、请求超时、流量降级、重试等策略，基于这些基础能力可以轻松的实现更多场景化的路由方案，包括金丝雀发布、A/B测试、权重路由、同区域优先等，更酷的是，Dubbo 支持流控策略在运行态动态生效，无需重新部署。具体可参见：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="../../tasks/traffic-management">流量治理示例&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="丰富的扩展组件及生态">丰富的扩展组件及生态&lt;/h4>
&lt;p>Dubbo 强大的服务治理能力不仅体现在核心框架上，还包括其优秀的扩展能力以及周边配套设施的支持。通过 Filter、Router、Protocol 等几乎存在于每一个关键流程上的扩展点定义，我们可以丰富 Dubbo 的功能或实现与其他微服务配套系统的对接，包括 Transaction、Tracing 目前都有通过 SPI 扩展的实现方案，具体可以参见 Dubbo 扩展性的详情，也可以在 &lt;a href="https://github.com/apache/dubbo-spi-extensions">apache/dubbo-spi-extensions&lt;/a> 项目中发现与更多的扩展实现。具体可参见：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="../../what/ecosystem">Dubbo 生态&lt;/a>&lt;/li>
&lt;li>&lt;a href="../../what/extensibility">Dubbo 可扩展性设计&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="面向云原生设计">面向云原生设计&lt;/h4>
&lt;p>Dubbo 从设计上是完全遵循云原生微服务开发理念的，这体现在多个方面，首先是对云原生基础设施与部署架构的支持，包括 容器、Kubernetes 等，Dubbo Mesh 总体解决方案也在 3.1 版本正式发布；另一方面，Dubbo 众多核心组件都已面向云原生升级，包括 Triple 协议、统一路由规则、对多语言的支持。&lt;/p>
&lt;p>值得一提的是，如何使用 Dubbo 支持弹性伸缩的服务如 Serverless 也在未来计划之中，这包括利用 Native Image 提高 Dubbo 的启动速度与资源消耗等。&lt;/p>
&lt;p>结合当前版本，本节主要从以下两点展开 Dubbo 的云原生特性&lt;/p>
&lt;ul>
&lt;li>&lt;a href="../../tasks/kubernetes/deploy-on-k8s">容器调度平台（Kubernetes）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh/docs3-v2/java-sdk/concepts-and-architecture/mesh/">Dubbo Mesh&lt;/a>&lt;/li>
&lt;/ul>
&lt;h5 id="kubernetes">Kubernetes&lt;/h5>
&lt;p>Dubbo 微服务要支持 Kubernetes 平台调度，最基础的就是实现 dubbo 服务生命周期与容器生命周期的对齐，这包括 Dubbo 的启动、销毁、服务注册等生命周期事件。相比于以往 Dubbo 自行定义生命周期事件，并要求开发人员在运维实践过程中遵守约定，Kubernetes 底层基础设施定义了严格的组件生命周期事件(probe)，转而要求 Dubbo 去按约定适配。&lt;/p>
&lt;p>Kubernetes Service 是另一个层面的适配，这体现了服务定义与注册向云原生底层基础设施下沉的趋势。在这种模式下，用户不再需要搭建额外的注册中心组件，Dubbo 消费端节点能自动对接到 Kubernetes（API-Server 或 DNS），根据服务名（Kubernetes Service Name） 查询到实例列表（Kubernetes endpoints）。 此时服务是通过标准的 Kubernetes Service API 定义，并被调度到各个节点。&lt;/p>
&lt;h5 id="dubbo-mesh">Dubbo Mesh&lt;/h5>
&lt;p>Service Mesh 在业界得到了广泛的传播与认可，并被认为是下一代的微服务架构，这主要是因为它解决了很多棘手的问题，包括透明升级、多语言、依赖冲突、流量治理等。Service Mesh 的典型架构是通过部署独立的 Sidecar 组件来拦截所有的出口与入口流量，并在 Sidecar 中集成丰富的流量治理策略如负载均衡、路由等，除此之外，Service Mesh 还需要一个控制面（Control Panel）来实现对 Sidecar 流量的管控，即各种策略下发。我们在这里称这种架构为经典 Mesh。&lt;/p>
&lt;p>然而任何技术架构都不是完美的，经典 Mesh 在实施层面也面临成本过高的问题&lt;/p>
&lt;ol>
&lt;li>需要运维控制面（Control Panel）&lt;/li>
&lt;li>需要运维 Sidecar&lt;/li>
&lt;li>需要考虑如何从原有 SDK 迁移到 Sidecar&lt;/li>
&lt;li>需要考虑引入 Sidecar 后整个链路的性能损耗&lt;/li>
&lt;/ol>
&lt;p>为了解决 Sidecar 引入的相关成本问题，Dubbo 引入并实现了全新的 Proxyless Mesh 架构，顾名思义，Proxyless Mesh 就是指没有 Sidecar 的部署，转而由 Dubbo SDK 直接与控制面交互，其架构图如下&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/mesh/dubbo-proxyless.png" alt="dubbo-proxyless">&lt;/p>
&lt;p>可以设想，在不同的组织、不同的发展阶段，未来以 Dubbo 构建的微服务将会允许有三种部署架构：传统 SDK、基于 Sidecar 的 Service Mesh、脱离 Sidecar 的 Proxyless Mesh。基于 Sidecar 的 Service Mesh，即经典的 Mesh 架构，独立的 sidecar 运行时接管所有的流量，脱离 Sidecar 的 Proxyless Mesh，副 SDK 直接通过 xDS 与控制面通信。Dubbo 微服务允许部署在物理机、容器、Kubernetes 平台之上，能做到以 Admin 为控制面，以统一的流量治理规则进行治理。&lt;/p></description></item><item><title>Overview: 3.0 速览</title><link>https://dubbo.apache.org/zh/overview/what/dubbo3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/overview/what/dubbo3/</guid><description>
&lt;p>本文将带你快速了解 Dubbo3 的设计背景、总体架构与核心特性、与典型用户如阿里巴巴 HSF2 的关系等。也可以通过如下部分了解更多：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>小白用户，快速浏览 Dubbo3 核心特性：&lt;/strong>
&lt;ul>
&lt;li>&lt;a href="https://dubbo.apache.org/zh/docs3-v2/java-sdk/concepts-and-architecture/triple/">下一代通信协议 - Triple&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh/docs3-v2/java-sdk/concepts-and-architecture/service-discovery/">百万实例集群的秘密 - 应用级服务发现&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh/docs3-v2/java-sdk/concepts-and-architecture/mesh/">Dubbo Mesh&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Dubbo3 的兼容性与迁移成本?&lt;/strong>
&lt;ul>
&lt;li>&lt;a href="https://dubbo.apache.org/zh/docs3-v2/java-sdk/upgrades-and-compatibility">Java - 迁移指南&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh/docs3-v2/golang-sdk/">Golang - 迁移指南&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Dubbo3 相关资源：&lt;/strong>
&lt;ul>
&lt;li>更多资料，如性能指标、高级特性说明等请参考 &lt;a href="https://dubbo.apache.org/zh/overview/mannual/">多语言 SDK 实现&lt;/a>&lt;/li>
&lt;li>演讲与线下活动&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="背景">背景&lt;/h3>
&lt;p>Dubbo3 的设计与开发有两个大的背景。&lt;/p>
&lt;p>&lt;strong>首先，如何更好的满足企业实践诉求。&lt;/strong> Dubbo 自 2011 由阿里巴巴捐献开源以来，一直是众多大型企业微服务实践的首选开源服务框架。在此期间，企业架构经历了从 SOA 架构到微服务架构变迁，Dubbo 社区自身也在不断的更新迭代以更好的满足企业诉求。然而 Dubbo2 架构上的局限逐渐在实践中凸显：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>协议&lt;/strong>，Dubbo2 协议以性能、简洁著称，但却在云原生时代遇到越来越多的通用性、穿透性问题；&lt;/li>
&lt;li>&lt;strong>可伸缩性&lt;/strong>，Dubbo2 在可伸缩性上依旧远超很多其他框架，但随着微服务带来更多应用与实例我们不得不思考如何应对更大规模集群的实战；&lt;/li>
&lt;li>&lt;strong>服务治理易用性&lt;/strong>，如更丰富的流量治理、可观测性、智能负载均衡等。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>其次，适配云原生技术栈的发展。&lt;/strong> 微服务让业务开发演进更灵活、快捷的同时，也带来了一些它独有的特征和需求：如微服务之后组件数量越来越多，如何解决各个组件的稳定性，如何快速的水平扩容等，以 Docker、Kubernetes、Service Mesh 为代表的云原生基础设施为解决这些问题带来了一些新的选择。随着更多的微服务组件及能力正下沉到以 Kubernetes 为代表的基础设施层，传统微服务开发框架应剔除一些冗余机制，积极的适配到基础设施层以做到能力复用，微服务框架生命周期、服务治理等能力应更好地与 Kubernetes 服务编排机制融合； 以 Service Mesh 为代表微服务架构给微服务开发带来的新的选择，Sidecar 给多语言、透明升级、流量管控等带来的优势，但同时也带来运维复杂性、性能损耗等弊端，因此基于服务框架的传统微服务体系还将是主流，长期仍将占据半壁江山，在长时间内将会维持混合部署状态。&lt;/p>
&lt;h3 id="总体目标">总体目标&lt;/h3>
&lt;p>Dubbo3 依旧保持了 2.x 的经典架构，以解决微服务进程间通信为主要职责，通过丰富的服务治理（如地址发现、流量管理等）能力来更好的管控微服务集群；Dubbo3 对原有框架的升级是全面的，体现在核心 Dubbo 特性的几乎每个环节，通过升级实现了稳定性、性能、伸缩性、易用性的全面提升。&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/architecture-1.png" alt="architecture-1">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>通用的通信协议。&lt;/strong> 全新的 RPC 协议应摒弃私有协议栈，以更通用的 HTTP/2 协议为传输层载体，借助 HTTP 协议的标准化特性，解决流量通用性、穿透性等问题，让协议能更好的应对前后端对接、网关代理等场景；支持 Stream 通信模式，满足不同业务通信模型诉求的同时给集群带来更大的吞吐量。&lt;/li>
&lt;li>&lt;strong>面向百万集群实例，集群高度可伸缩。&lt;/strong> 随着微服务实践的推广，微服务集群实例的规模也在不停的扩展，这得益于微服务轻量化、易于水平扩容的特性，同时也给整个集群容量带来了负担，尤其是一些中心化的服务治理组件；Dubbo3 需要解决实例规模扩展带来的种种资源瓶颈问题，实现真正的无限水平扩容。&lt;/li>
&lt;li>&lt;strong>更丰富的编程模型，更小的业务侵入。&lt;/strong> 在开发态业务应用面向 Dubbo SDK 编程，在运行态 SDK 与业务应用运行在同一个进程，SDK 的易用性、稳定性与资源消耗将在很大程度上影响业务应用；因此 3.0 应该具备更抽象的 API、更友好的配置模式、更少的侵占业务应用资源、具备更高的可用性。&lt;/li>
&lt;li>&lt;strong>更易用、更丰富的服务治理能力。&lt;/strong> 微服务的动态特性给治理工作带来了很高的复杂性，而 Dubbo 这方面一直做的不错，是最早的一批治理能力定义者与实践者；3.0 需面向更丰富的场景化，提供诸如可观测性、安全性、灰度发布、错误注入、外部化配置、统一的治理规则等能力。&lt;/li>
&lt;li>&lt;strong>全面拥抱云原生。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="面向企业生产实践痛点">面向企业生产实践痛点&lt;/h3>
&lt;p>Dubbo2 仍旧是国内首选开源服务框架，被广泛应用在互联网、金融保险、软件企业、传统企业等几乎所有数字化转型企业中，久经规模化生产环境检验。以 Dubbo2 的贡献者和典型用户阿里巴巴为例，阿里巴巴基于 Dubbo2 在内部维护的 HSF2 框架经历了历次双十一峰值考验，每天数十亿次的 RPC 调用，治理着超过千万的服务实例。在长期的优化和实践积累中，阿里巴巴有了对下一代服务框架的设想与方案，在内部开始了快速演进，并快速的被贡献到 Apache 社区，如同阿里巴巴一样，其他用户的实践诉求与痛点也在开源社区快速的积累，形成了一致的方向和技术方案，可以说 Dubbo3 的诞生就来自于超大基数的企业用户积累，为了更好的满足他们的实践诉求。&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/dubbo-hsf.png" alt="dubbo3-hsf">&lt;/p>
&lt;p>Dubbo3 融合了阿里巴巴 HSF2 及其他社区企业的大量服务治理经验，当前 Dubbo3 已经被全面应用到生产实践环境，用户包括阿里巴巴电商、饿了么、钉钉、考拉、阿里云、小米、工商银行、风火递、平安健康等。社区与用户的合作形成的良性循环极大的促进了 Dubbo3 的发展，阿里巴巴已经以社区版 Dubbo3 完全取代了内部维护的 HSF2 框架，他们的实践经验一方面推动 Dubbo3 的稳定性，另一方面正够源源不断的将服务治理实践经验输出到开源社区。&lt;/p>
&lt;h3 id="面向百万集群实例横向可扩容">面向百万集群实例，横向可扩容&lt;/h3>
&lt;p>随着微服务实践经验的积累，微服务被拆分成更细粒度，部署到越来越多的机器实例，以支撑不断增长的业务规模。在众多的 Dubbo2 企业用户中，尤其是以金融保险、互联网为代表的规模化企业开始遇到集群容量瓶颈问题（典型的请参照 &lt;a href="https://dubbo.apache.org/zh/users/icbc/">工商银行实践案例&lt;/a> ）：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>服务发现过程&lt;/strong>
&lt;ul>
&lt;li>注册中心数据存储规模达到容量瓶颈&lt;/li>
&lt;li>数据注册&amp;amp;推送效率严重下降&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Dubbo 进程&lt;/strong>
&lt;ul>
&lt;li>侵占更多机器资源，导致业务资源利用率降低&lt;/li>
&lt;li>频繁 GC 影响业务稳定性&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Dubbo3 在设计上很好的解决了这些问题，通过全新设计实现的服务治理（服务发现）模型，可以实现服务发现链路上的数据传输、数据存储量平均下降 90% 左右；同时 Dubbo3 自身在业务进程中变得更轻量、更稳定，实现提升资源利用率 50%。&lt;/p>
&lt;p>Dubbo3 一个更大的优势在于其对整体架构稳定性的提升，新的服务发现架构使得对于整个集群容量、可伸缩性评估变得更容易、更准确。&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/capacity.png" alt="capacity">&lt;/p>
&lt;p>如果将应用开发粗略划分为业务开发、运维部署两个层次，其中变化比较频繁的因素包括服务（接口）、应用、机器实例。在 2.x 时代，所有这三个因素的增长都会影响微服务集群的总体容量，尤其是接口增减带来的波动，对整体容量评估是非常不透明的。而在 3.0 中集群容量变化仅与应用名、机器实例两个因素相关，而容量评估的对象往往都是应用与实例，因此整个集群变的更稳定透明。&lt;/p>
&lt;h3 id="云原生">云原生&lt;/h3>
&lt;p>在云原生时代，底层基础设施的变革正深刻影响应用的部署、运维甚至开发过程，往上也影响了 Dubbo3 微服务技术方案的选型与部署模式。&lt;/p>
&lt;h4 id="下一代-rpc-协议">下一代 RPC 协议&lt;/h4>
&lt;p>新一代的 Triple 协议基于 HTTP/2 作为传输层，具备更好的网关、代理穿透性，原生支持 Stream 通信语义，兼容 gRPC 协议。&lt;/p>
&lt;h4 id="多语言友好">多语言友好&lt;/h4>
&lt;p>Dubbo3 从服务定义、RPC 协议、序列化、服务治理等多个方面都已经将多语言友好性作为重点考量因素，目前提供了 Java、Golang 稳定的多语言版本，更多语言版本的 3.0 实现如 Rust、Javascript、C/C++、C# 等在开发建设中。&lt;/p>
&lt;h4 id="kubernetes">Kubernetes&lt;/h4>
&lt;p>Dubbo3 开发的应用可以原生部署到 Kubernetes 平台，Dubbo3 在地址、生命周期等已设计可与 Kubernetes 等容器调度平台对齐；对于要进一步复用 Kubernetes 底层基础设施能力的用户来说，Dubbo3 也已对接到了原生的 Kubernetes Service 体系。&lt;/p>
&lt;h4 id="service-mesh">Service Mesh&lt;/h4>
&lt;p>Service Mesh 强调控制面在微服务治理中的作用，在一定程度上推动了控制面通信协议、职责范围的扩展与标准化；传统 Mesh 架构下的 Sidecar 模型强调旁路代理对于流量的统一管控，以实现透明升级、多语言无感、无业务侵入等特性。&lt;/p>
&lt;p>Dubbo3 提供了基于自身思考的 Dubbo Mesh 解决方案，强调了控制面对微服务集群的统一管控，而在部署架构上，同时支持 sidecar 与无 sidecar 的 proxyless 部署架构，使用 Dubbo Mesh 的用户基于自身的业务特点将有更多的部署架构选择。&lt;/p>
&lt;h4 id="异构体系互通">异构体系互通&lt;/h4>
&lt;p>我们正看到越来越多的异构微服务体系互通的诉求，典型如 Dubbo、Spring Cloud、gRPC 等。有些是因为技术栈迁移，有些是组织合并后需要实现业务互调，Dubbo3 借助于新的服务发现模型以及可灵活扩展的 RPC 协议，可以成为 Dubbo3 未来的发展目标。&lt;/p></description></item><item><title>Overview: 概念与架构</title><link>https://dubbo.apache.org/zh/overview/what/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/overview/what/architecture/</guid><description>
&lt;h2 id="rpc-通信">RPC 通信&lt;/h2>
&lt;p>Dubbo3 的 Triple 协议构建在 HTTP/2 协议之上，因此具有更好的穿透性与通用性，Triple 协议兼容 gRPC，提供 Request Response、Request Streaming、Response Streaming、Bi-directional Streaming 等通信模型；从 Triple 协议开始，Dubbo 还支持基于 IDL 的服务定义。&lt;/p>
&lt;p>此外，Dubbo 还集成了业界主流的大部分协议，使得用户可以在 Dubbo 框架范围内使用这些通信协议，为用户提供了统一的编程模型与服务治理模型，这些协议包括 rest、hessian2、jsonrpc、thrift 等，注意不同语言 SDK 实现支持的范围会有一些差异。&lt;/p>
&lt;p>具体可查看&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dubbo.apache.org/zh/docs3-v2/java-sdk/concepts-and-architecture/triple/">Triple 速览&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/apache/dubbo-awesome/blob/master/proposals/D0-triple.md">Specification&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="服务发现">服务发现&lt;/h2>
&lt;p>服务发现，即消费端自动发现服务地址列表的能力，是微服务框架需要具备的关键能力，借助于自动化的服务发现，微服务之间可以在无需感知对端部署位置与 IP 地址的情况下实现通信。&lt;/p>
&lt;p>实现服务发现的方式有很多种，Dubbo 提供的是一种 Client-Based 的服务发现机制，通常还需要部署额外的第三方注册中心组件来协调服务发现过程，如常用的 &lt;a href="https://nacos.io/">Nacos&lt;/a>、Consul、Zookeeper 等，Dubbo 自身也提供了对多种注册中心组件的对接，用户可以灵活选择。&lt;/p>
&lt;p>Dubbo 基于消费端的自动服务发现能力，其基本工作原理如下图：&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/architecture.png" alt="architecture">&lt;/p>
&lt;p>在传统的部署架构下，服务发现涉及提供者、消费者和注册中心三个参与角色，其中，提供者注册 URL 地址到注册中心，注册中心负责对数据进行聚合，消费者从注册中心订阅 URL 地址更新。
在云原生背景下，比如当应用部署在 Kubernetes 等平台，由于平台自身维护了应用/服务与实例间的映射关系，因此注册中心与注册动作在一定程度上被下沉到了基础设施层，因此框架自身的注册动作有时并不是必须的。&lt;/p>
&lt;p>Dubbo3 提供了全新的应用级服务发现模型，该模型在设计与实现上区别于 Dubbo2 的接口级服务发现模型。可在此查看：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dubbo.apache.org/zh/docs3-v2/java-sdk/concepts-and-architecture/service-discovery/#%E5%BA%94%E7%94%A8%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%AE%80%E4%BB%8B">应用级服务发现&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="流量治理">流量治理&lt;/h2>
&lt;p>Dubbo2 开始 Dubbo 就提供了丰富服务治理规则，包括路由规则、动态配置等。&lt;/p>
&lt;p>一方面 Dubbo3 正在通过对接 xDS 对接到时下流行的 Mesh 产品如 Istio 中所使用的以 VirtualService、DestinationRule 为代表的治理规则，另一方面 Dubbo 正寻求设计一套自有规则以实现在不同部署场景下的流量治理，以及灵活的治理能力。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="../../tasks/traffic-management">Dubbo2 服务治理规则&lt;/a>&lt;/li>
&lt;li>Dubbo3 服务治理规则&lt;/li>
&lt;/ul>
&lt;h2 id="dubbo-mesh">Dubbo Mesh&lt;/h2>
&lt;p>Dubbo Mesh 的目标是提供适应 Dubbo 体系的完整 Mesh 解决方案，包含定制化控制面（Control Plane）、定制化数据面解决方案。Dubbo 控制面基于业界主流 Istio 扩展，支持更丰富的流量治理规则、Dubbo应用级服务发现模型等，Dubbo 数据面可以采用 Envoy Sidecar，即实现 Dubbo SDK + Envoy 的部署方案，也可以采用 Dubbo Proxyless 模式，直接实现 Dubbo 与控制面的通信。Dubbo Mesh 在快速演进中，我们将努力保持文档内容的更新。&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/mesh/mix-mesh.png" alt="mix-mesh">&lt;/p>
&lt;p>在此查看 Dubbo Mesh 设计细节&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/apache/dubbo-awesome/blob/master/proposals/D3.1-thinsdk-sidecar-mesh.md">Dubbo Proxy Mesh&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/apache/dubbo-awesome/blob/master/proposals/D3.2-proxyless-mesh.md">Dubbo Proxyless Mesh&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/apache/dubbo-awesome/blob/master/proposals/D3.2-proxyless-mesh.md">Dubbo 控制面规划&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="部署架构">部署架构&lt;/h2>
&lt;blockquote>
&lt;p>本节侧重描述传统模式下的 Dubbo 部署架构，在云原生背景下的部署架构会有些变化，主要体现在基础设施（Kubernetes、Service Mesh等）会承担更多的职责，
中心化组件如注册中心、元数据中心、配置中心等的职责被集成、运维变得更加简单，但通过强调这些中心化的组件能让我们更容易理解 Dubbo 的工作原理。&lt;/p>
&lt;/blockquote>
&lt;p>作为一个微服务框架，Dubbo sdk 跟随着微服务组件被部署在分布式集群各个位置，为了在分布式环境下实现各个微服务组件间的协作，
Dubbo 定义了一些中心化组件，这包括：&lt;/p>
&lt;ul>
&lt;li>注册中心。协调 Consumer 与 Provider 之间的地址注册与发现&lt;/li>
&lt;li>配置中心。
&lt;ul>
&lt;li>存储 Dubbo 启动阶段的全局配置，保证配置的跨环境共享与全局一致性&lt;/li>
&lt;li>负责服务治理规则（路由规则、动态配置等）的存储与推送。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>元数据中心。
&lt;ul>
&lt;li>接收 Provider 上报的服务接口元数据，为 Admin 等控制台提供运维能力（如服务测试、接口文档等）&lt;/li>
&lt;li>作为服务发现机制的补充，提供额外的接口/方法级别配置信息的同步能力，相当于注册中心的额外扩展&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/threecenters.png" alt="threecenters">&lt;/p>
&lt;p>上图完整的描述了 Dubbo 微服务组件与各个中心的交互过程。&lt;/p>
&lt;p>以上三个中心并不是运行 Dubbo 的必要条件，用户完全可以根据自身业务情况决定只启用其中一个或多个，以达到简化部署的目的。通常情况下，所有用户都会以独立的注册中心
以开始 Dubbo 服务开发，而配置中心、元数据中心则会在微服务演进的过程中逐步的按需被引入进来。&lt;/p>
&lt;h3 id="注册中心">注册中心&lt;/h3>
&lt;p>注册中心扮演着非常重要的角色，它承载着服务注册和服务发现的职责。目前Dubbo支持以下两种粒度的服务发现和服务注册，分别是接口级别和应用级别，注册中心可以按需进行部署：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在传统的Dubbo SDK使用姿势中，如果仅仅提供直连模式的RPC服务，不需要部署注册中心。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>无论是接口级别还是应用级别，如果需要Dubbo SDK自身来做服务注册和服务发现，则可以选择部署注册中心，在Dubbo中集成对应的注册中心。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在Dubbo + Mesh 的场景下，随着 Dubbo 服务注册能力的弱化，Dubbo内的注册中心也不再是必选项，其职责开始被控制面取代，如果采用了Dubbo + Mesh的部署方式，无论是ThinSDK的mesh方式还是Proxyless的mesh方式，都不再需要独立部署注册中心。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>而注册中心并不依赖于配置中心和元数据中心，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/centers-registry.png" alt="centers-registry">&lt;/p>
&lt;p>该图中没有部署配置中心和元数据中心，在Dubbo中会默认将注册中心的实例同时作为配置中心和元数据中心，这是Dubbo的默认行为，如果确实不需要配置中心或者元数据中心的能力，可在配置中关闭，在注册中心的配置中有两个配置分别为use-as-config-center和use-as-metadata-center，将配置置为false即可。&lt;/p>
&lt;h3 id="元数据中心">元数据中心&lt;/h3>
&lt;p>元数据中心在2.7.x版本开始支持，随着应用级别的服务注册和服务发现在Dubbo中落地，元数据中心也变的越来越重要。在以下几种情况下会需要部署元数据中心：&lt;/p>
&lt;ol>
&lt;li>对于一个原先采用老版本Dubbo搭建的应用服务，在迁移到Dubbo 3时，Dubbo 3 会需要一个元数据中心来维护RPC服务与应用的映射关系（即接口与应用的映射关系），因为如果采用了应用级别的服务发现和服务注册，在注册中心中将采用“应用 —— 实例列表”结构的数据组织形式，不再是以往的“接口 —— 实例列表”结构的数据组织形式，而以往用接口级别的服务注册和服务发现的应用服务在迁移到应用级别时，得不到接口与应用之间的对应关系，从而无法从注册中心得到实例列表信息，所以Dubbo为了兼容这种场景，在Provider端启动时，会往元数据中心存储接口与应用的映射关系。&lt;/li>
&lt;li>为了让注册中心更加聚焦于地址的发现和推送能力，减轻注册中心的负担，元数据中心承载了所有的服务元数据、大量接口/方法级别配置信息等，无论是接口粒度还是应用粒度的服务发现和注册，元数据中心都起到了重要的作用。&lt;/li>
&lt;/ol>
&lt;p>如果有以上两种需求，都可以选择部署元数据中心，并通过Dubbo的配置来集成该元数据中心。&lt;/p>
&lt;p>元数据中心并不依赖于注册中心和配置中心，用户可以自由选择是否集成和部署元数据中心，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/centers-metadata.png" alt="centers-metadata">&lt;/p>
&lt;p>该图中不配备配置中心，意味着可以不需要全局管理配置的能力。该图中不配备注册中心，意味着可能采用了Dubbo mesh的方案，也可能不需要进行服务注册，仅仅接收直连模式的服务调用。&lt;/p>
&lt;h3 id="配置中心">配置中心&lt;/h3>
&lt;p>配置中心与其他两大中心不同，它无关于接口级还是应用级，它与接口并没有对应关系，它仅仅与配置数据有关，即使没有部署注册中心和元数据中心，配置中心也能直接被接入到Dubbo应用服务中。在整个部署架构中，整个集群内的实例（无论是Provider还是Consumer）都将会共享该配置中心集群中的配置，如下图所示：
&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/centers-config.png" alt="centers-config">&lt;/p>
&lt;p>该图中不配备注册中心，意味着可能采用了Dubbo mesh的方案，也可能不需要进行服务注册，仅仅接收直连模式的服务调用。&lt;/p>
&lt;p>该图中不配备元数据中心，意味着Consumer可以从Provider暴露的MetadataService获取服务元数据，从而实现RPC调用&lt;/p>
&lt;h3 id="保证三大中心高可用的部署架构">保证三大中心高可用的部署架构&lt;/h3>
&lt;p>虽然三大中心已不再是Dubbo应用服务所必须的，但是在真实的生产环境中，一旦已经集成并且部署了该三大中心，三大中心还是会面临可用性问题，Dubbo需要支持三大中心的高可用方案。在Dubbo中就支持多注册中心、多元数据中心、多配置中心，来满足同城多活、两地三中心、异地多活等部署架构模式的需求。&lt;/p>
&lt;p>Dubbo SDK对三大中心都支持了Multiple模式。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>多注册中心：Dubbo 支持多注册中心，即一个接口或者一个应用可以被注册到多个注册中心中，比如可以注册到ZK集群和Nacos集群中，Consumer也能够从多个注册中心中进行订阅相关服务的地址信息，从而进行服务发现。通过支持多注册中心的方式来保证其中一个注册中心集群出现不可用时能够切换到另一个注册中心集群，保证能够正常提供服务以及发起服务调用。这也能够满足注册中心在部署上适应各类高可用的部署架构模式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>多配置中心：Dubbo支持多配置中心，来保证其中一个配置中心集群出现不可用时能够切换到另一个配置中心集群，保证能够正常从配置中心获取全局的配置、路由规则等信息。这也能够满足配置中心在部署上适应各类高可用的部署架构模式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>多元数据中心：Dubbo 支持多元数据中心：用于应对容灾等情况导致某个元数据中心集群不可用，此时可以切换到另一个元数据中心集群，保证元数据中心能够正常提供有关服务元数据的管理能力。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>拿注册中心举例，下面是一个多活场景的部署架构示意图：&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/multiple-registry-deployment-architecture.png" alt="multiple-registry-deployment-architecture">&lt;/p></description></item><item><title>Overview: 可扩展性</title><link>https://dubbo.apache.org/zh/overview/what/extensibility/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/overview/what/extensibility/</guid><description>
&lt;h2 id="扩展设计理念">扩展设计理念&lt;/h2>
&lt;p>可扩展性是任何一个系统所追求的，对于 Dubbo 来说是同样适用。&lt;/p>
&lt;h3 id="什么是可扩展性">什么是可扩展性&lt;/h3>
&lt;p>可扩展性是一种设计理念，代表了我们对未来的一种预想，我们希望在现有的架构或设计基础上，当未来某些方面发生变化的时候，我们能够以最小的改动来适应这种变化。&lt;/p>
&lt;h3 id="可扩展性的优点">可扩展性的优点&lt;/h3>
&lt;p>可扩展性的优点主要表现模块之间解耦，它符合开闭原则，对扩展开放，对修改关闭。当系统增加新功能时，不需要对现有系统的结构和代码进行修改，仅仅新增一个扩展即可。&lt;/p>
&lt;h3 id="扩展实现方式">扩展实现方式&lt;/h3>
&lt;p>一般来说，系统会采用 Factory、IoC、OSGI 等方式管理扩展(插件)生命周期。考虑到 Dubbo 的适用面，不想强依赖 Spring 等 IoC 容器。
而自己造一个小的 IoC 容器，也觉得有点过度设计，所以选择最简单的 Factory 方式管理扩展(插件)。在 Dubbo 中，所有内部实现和第三方实现都是平等的。&lt;/p>
&lt;h3 id="dubbo-中的可扩展性">Dubbo 中的可扩展性&lt;/h3>
&lt;ul>
&lt;li>平等对待第三方的实现。在 Dubbo 中，所有内部实现和第三方实现都是平等的，用户可以基于自身业务需求，替换 Dubbo 提供的原生实现。&lt;/li>
&lt;li>每个扩展点只封装一个变化因子，最大化复用。每个扩展点的实现者，往往都只是关心一件事。如果用户有需求需要进行扩展，那么只需要对其关注的扩展点进行扩展就好，极大的减少用户的工作量。&lt;/li>
&lt;/ul>
&lt;h2 id="dubbo-扩展的特性">Dubbo 扩展的特性&lt;/h2>
&lt;p>Dubbo 中的扩展能力是从 JDK 标准的 SPI 扩展点发现机制加强而来，它改进了 JDK 标准的 SPI 以下问题：&lt;/p>
&lt;ul>
&lt;li>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。&lt;/li>
&lt;li>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK 标准的 ScriptEngine，通过 getName() 获取脚本类型的名称，但如果 RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby 脚本时，会报不支持 ruby，而不是真正失败的原因。&lt;/li>
&lt;/ul>
&lt;p>用户能够基于 Dubbo 提供的扩展能力，很方便基于自身需求扩展其他协议、过滤器、路由等。下面介绍下 Dubbo 扩展能力的特性。&lt;/p>
&lt;ul>
&lt;li>按需加载。Dubbo 的扩展能力不会一次性实例化所有实现，而是用哪个扩展类则实例化哪个扩展类，减少资源浪费。&lt;/li>
&lt;li>增加扩展类的 IOC 能力。Dubbo 的扩展能力并不仅仅只是发现扩展服务实现类，而是在此基础上更进一步，如果该扩展类的属性依赖其他对象，则 Dubbo 会自动的完成该依赖对象的注入功能。&lt;/li>
&lt;li>增加扩展类的 AOP 能力。Dubbo 扩展能力会自动的发现扩展类的包装类，完成包装类的构造，增强扩展类的功能。&lt;/li>
&lt;li>具备动态选择扩展实现的能力。Dubbo 扩展会基于参数，在运行时动态选择对应的扩展类，提高了 Dubbo 的扩展能力。&lt;/li>
&lt;li>可以对扩展实现进行排序。能够基于用户需求，指定扩展实现的执行顺序。&lt;/li>
&lt;li>提供扩展点的 Adaptive 能力。该能力可以使的一些扩展类在 consumer 端生效，一些扩展类在 provider 端生效。&lt;/li>
&lt;/ul>
&lt;p>从 Dubbo 扩展的设计目标可以看出，Dubbo 实现的一些例如动态选择扩展实现、IOC、AOP 等特性，能够为用户提供非常灵活的扩展能力。&lt;/p>
&lt;h2 id="dubbo-扩展加载流程">Dubbo 扩展加载流程&lt;/h2>
&lt;p>Dubbo 加载扩展的整个流程如下：&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/extension-load.png" alt="//imgs/v3/concepts/extension-load.png">&lt;/p>
&lt;p>主要步骤为 4 个：&lt;/p>
&lt;ul>
&lt;li>读取并解析配置文件&lt;/li>
&lt;li>缓存所有扩展实现&lt;/li>
&lt;li>基于用户执行的扩展名，实例化对应的扩展实现&lt;/li>
&lt;li>进行扩展实例属性的 IOC 注入以及实例化扩展的包装类，实现 AOP 特性&lt;/li>
&lt;/ul>
&lt;h2 id="如何使用-dubbo-扩展能力进行扩展">如何使用 Dubbo 扩展能力进行扩展&lt;/h2>
&lt;p>下面以扩展协议为例进行说明如何利用 Dubbo 提供的扩展能力扩展 Triple 协议。&lt;/p>
&lt;p>(1) 在协议的实现 jar 包内放置文本文件：META-INF/dubbo/org.apache.dubbo.remoting.api.WireProtocol&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>tri=org.apache.dubbo.rpc.protocol.tri.TripleHttp2Protocol
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>(2) 实现类内容&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Activate&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">TripleHttp2Protocol&lt;/span> &lt;span style="color:#268bd2">extends&lt;/span> Http2WireProtocol &lt;span style="color:#719e07">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&lt;/span>&lt;span style="color:#719e07">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>说明下：Http2WireProtocol 实现了 WireProtocol 接口&lt;/p>
&lt;p>(3) Dubbo 配置模块中，扩展点均有对应配置属性或标签，通过配置指定使用哪个扩展实现。比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>&amp;lt;dubbo:protocol name=&amp;#34;tri&amp;#34; /&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上面的扩展步骤可以看出，用户基本在黑盒下就完成了扩展。&lt;/p>
&lt;h2 id="dubbo-扩展的应用">Dubbo 扩展的应用&lt;/h2>
&lt;p>Dubbo 的扩展能力非常灵活，在自身功能的实现上无处不在。&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/concepts/extension-use.png" alt="//imgs/v3/concepts/extension-use.png">&lt;/p>
&lt;p>Dubbo 扩展能力使得 Dubbo 项目很方便的切分成一个一个的子模块，实现热插拔特性。用户完全可以基于自身需求，替换 Dubbo 原生实现，来满足自身业务需求。&lt;/p>
&lt;h2 id="使用场景">使用场景&lt;/h2>
&lt;ul>
&lt;li>如果你需要自定义负载均衡策略，你可以使用 Dubbo 扩展能力。&lt;/li>
&lt;li>如果你需要实现自定义的注册中心，你可以使用 Dubbo 扩展能力。&lt;/li>
&lt;li>如果你需要实现自定义的过滤器，你可以使用 Dubbo 扩展能力。&lt;/li>
&lt;/ul>
&lt;p>Dubbo 扩展平等的对待内部实现和第三方实现。更多使用场景，参见 &lt;a href="https://dubbo.apache.org/zh/docs3-v2/java-sdk/reference-manual/spi/description/">SPI 扩展实现&lt;/a>&lt;/p></description></item><item><title>Overview: Dubbo 生态</title><link>https://dubbo.apache.org/zh/overview/what/ecosystem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/overview/what/ecosystem/</guid><description>
&lt;h3 id="dashboard">Dashboard&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/apache/dubbo-admin">Dubbo-admin&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="支持的组件与部署架构">支持的组件与部署架构&lt;/h3>
&lt;p>Dubbo 实现普遍支持以下产品或部署架构，具体多语言 SDK 实现可能有差异。&lt;/p>
&lt;ul>
&lt;li>注册中心
&lt;ul>
&lt;li>Zookeeper&lt;/li>
&lt;li>&lt;a href="https://nacos.io/zh-cn/docs/use-nacos-with-dubbo.html">Nacos&lt;/a>&lt;/li>
&lt;li>Kubernetes&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>元数据中心
&lt;ul>
&lt;li>Zookeeper&lt;/li>
&lt;li>&lt;a href="https://nacos.io/zh-cn/docs/use-nacos-with-dubbo.html">Nacos&lt;/a>&lt;/li>
&lt;li>Redis&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>配置中心
&lt;ul>
&lt;li>Zookeeper&lt;/li>
&lt;li>&lt;a href="https://nacos.io/zh-cn/docs/use-nacos-with-dubbo.html">Nacos&lt;/a>&lt;/li>
&lt;li>Redis&lt;/li>
&lt;li>Apollo&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Mesh
&lt;ul>
&lt;li>数据面 Envoy&lt;/li>
&lt;li>控制面 Istio&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="协议与互通性">协议与互通性&lt;/h3>
&lt;ul>
&lt;li>基于 Triple 协议可实现与 gRPC 体系互通&lt;/li>
&lt;li>基于 REST 协议以及应用级服务发现可实现 Spring Cloud 体系在协议和地址发现层面的互通&lt;/li>
&lt;/ul>
&lt;h3 id="spi-集成">SPI 集成&lt;/h3>
&lt;p>这里有众多的 Dubbo 扩展实现，包括协议、序列化、注册中心等&lt;/p>
&lt;ul>
&lt;li>[dubbo-spi-extensions]&lt;/li>
&lt;/ul>
&lt;h3 id="网关组件">网关组件&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://dubbo.apache.org/zh/blog/2022/05/04/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-apache-shenyu-%E7%BD%91%E5%85%B3%E4%BB%A3%E7%90%86-dubbo-%E6%9C%8D%E5%8A%A1/">Apache Shenyu&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dubbo.apache.org/zh/blog/2022/01/18/%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E6%93%8D%E4%BD%9C%E8%AE%A9%E4%BD%A0%E5%9C%A8-apache-apisix-%E4%B8%AD%E4%BB%A3%E7%90%86-dubbo-%E6%9C%8D%E5%8A%A1%E6%9B%B4%E4%BE%BF%E6%8D%B7/">Apache APISIX&lt;/a>&lt;/li>
&lt;li>[Apache Dubbo-pixiu]&lt;/li>
&lt;li>[Tengine]&lt;/li>
&lt;/ul>
&lt;h3 id="链路追踪">链路追踪&lt;/h3>
&lt;ul>
&lt;li>[Zipkin]&lt;/li>
&lt;li>[Apache Skywalking]&lt;/li>
&lt;/ul>
&lt;h3 id="其他微服务组件">其他微服务组件&lt;/h3>
&lt;ul>
&lt;li>限流 [Sentinel]&lt;/li>
&lt;li>事务 [Seata]&lt;/li>
&lt;/ul>
&lt;h3 id="多语言实现">多语言实现&lt;/h3>
&lt;ul>
&lt;li>Golang&lt;/li>
&lt;li>Java&lt;/li>
&lt;li>Rust&lt;/li>
&lt;li>Node&lt;/li>
&lt;li>Python&lt;/li>
&lt;li>PHP&lt;/li>
&lt;/ul></description></item><item><title>Overview: 用户案例</title><link>https://dubbo.apache.org/zh/overview/what/usecases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/overview/what/usecases/</guid><description/></item></channel></rss>